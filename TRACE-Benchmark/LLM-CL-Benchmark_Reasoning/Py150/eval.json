[{"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from google_voice . main import GoogleVoice <EOL> from africa_talking . main import AfricaTalking <EOL> import config <EOL> '''<STR_LIT>''' <EOL> class VoiceXTransport : <EOL>", "answer": "def __init__ ( self , auth ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> import reversion <EOL> import unittest <EOL> from onadata . apps . main . tests . test_base import TestBase <EOL> from onadata . apps . logger . models import XForm , Instance <EOL> class TestXForm ( TestBase ) : <EOL> def test_submission_count_filters_deleted ( self ) : <EOL> self . _publish_transportation_form_and_submit_instance ( ) <EOL> self . xform = XForm . objects . get ( pk = self . xform . id ) <EOL> self . assertEqual ( self . xform . submission_count ( ) , <NUM_LIT:1> ) <EOL> instance = Instance . objects . get ( xform = self . xform ) <EOL>", "answer": "instance . set_deleted ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from libcloud . utils import deprecated_warning <EOL> from libcloud . compute . deployment import * <EOL>", "answer": "deprecated_warning ( __name__ ) "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import struct <EOL> from twisted . conch . ssh . common import NS , getNS , getMP <EOL> from twisted . conch . error import ConchError , MissingKeyStoreError <EOL> from twisted . conch . ssh import keys <EOL> from twisted . internet import defer , protocol <EOL> class SSHAgentClient ( protocol . Protocol ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> self . buf = '<STR_LIT>' <EOL> self . deferreds = [ ] <EOL> def dataReceived ( self , data ) : <EOL> self . buf += data <EOL> while <NUM_LIT:1> : <EOL> if len ( self . buf ) <= <NUM_LIT:4> : <EOL> return <EOL> packLen = struct . unpack ( '<STR_LIT>' , self . buf [ : <NUM_LIT:4> ] ) [ <NUM_LIT:0> ] <EOL> if len ( self . buf ) < <NUM_LIT:4> + packLen : <EOL> return <EOL> packet , self . buf = self . buf [ <NUM_LIT:4> : <NUM_LIT:4> + packLen ] , self . buf [ <NUM_LIT:4> + packLen : ] <EOL> reqType = ord ( packet [ <NUM_LIT:0> ] ) <EOL> d = self . deferreds . pop ( <NUM_LIT:0> ) <EOL> if reqType == AGENT_FAILURE : <EOL> d . errback ( ConchError ( '<STR_LIT>' ) ) <EOL> elif reqType == AGENT_SUCCESS : <EOL> d . callback ( '<STR_LIT>' ) <EOL> else : <EOL> d . callback ( packet ) <EOL> def sendRequest ( self , reqType , data ) : <EOL> pack = struct . pack ( '<STR_LIT>' , len ( data ) + <NUM_LIT:1> , reqType ) + data <EOL> self . transport . write ( pack ) <EOL> d = defer . Deferred ( ) <EOL> self . deferreds . append ( d ) <EOL> return d <EOL> def requestIdentities ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> d = self . sendRequest ( AGENTC_REQUEST_IDENTITIES , '<STR_LIT>' ) <EOL> d . addCallback ( self . _cbRequestIdentities ) <EOL> return d <EOL> def _cbRequestIdentities ( self , data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ord ( data [ <NUM_LIT:0> ] ) != AGENT_IDENTITIES_ANSWER : <EOL> raise ConchError ( '<STR_LIT>' % ord ( data [ <NUM_LIT:0> ] ) ) <EOL> numKeys = struct . unpack ( '<STR_LIT>' , data [ <NUM_LIT:1> : <NUM_LIT:5> ] ) [ <NUM_LIT:0> ] <EOL> keys = [ ] <EOL> data = data [ <NUM_LIT:5> : ] <EOL> for i in range ( numKeys ) : <EOL> blob , data = getNS ( data ) <EOL> comment , data = getNS ( data ) <EOL> keys . append ( ( blob , comment ) ) <EOL> return keys <EOL> def addIdentity ( self , blob , comment = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> req = blob <EOL> req += NS ( comment ) <EOL> return self . sendRequest ( AGENTC_ADD_IDENTITY , req ) <EOL> def signData ( self , blob , data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> req = NS ( blob ) <EOL> req += NS ( data ) <EOL> req += '<STR_LIT>' <EOL> return self . sendRequest ( AGENTC_SIGN_REQUEST , req ) . addCallback ( self . _cbSignData ) <EOL> def _cbSignData ( self , data ) : <EOL> if ord ( data [ <NUM_LIT:0> ] ) != AGENT_SIGN_RESPONSE : <EOL> raise ConchError ( '<STR_LIT>' % ord ( data [ <NUM_LIT:0> ] ) ) <EOL> signature = getNS ( data [ <NUM_LIT:1> : ] ) [ <NUM_LIT:0> ] <EOL> return signature <EOL> def removeIdentity ( self , blob ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> req = NS ( blob ) <EOL> return self . sendRequest ( AGENTC_REMOVE_IDENTITY , req ) <EOL> def removeAllIdentities ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . sendRequest ( AGENTC_REMOVE_ALL_IDENTITIES , '<STR_LIT>' ) <EOL> class SSHAgentServer ( protocol . Protocol ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> self . buf = '<STR_LIT>' <EOL> def dataReceived ( self , data ) : <EOL> self . buf += data <EOL> while <NUM_LIT:1> : <EOL> if len ( self . buf ) <= <NUM_LIT:4> : <EOL> return <EOL> packLen = struct . unpack ( '<STR_LIT>' , self . buf [ : <NUM_LIT:4> ] ) [ <NUM_LIT:0> ] <EOL> if len ( self . buf ) < <NUM_LIT:4> + packLen : <EOL> return <EOL> packet , self . buf = self . buf [ <NUM_LIT:4> : <NUM_LIT:4> + packLen ] , self . buf [ <NUM_LIT:4> + packLen : ] <EOL> reqType = ord ( packet [ <NUM_LIT:0> ] ) <EOL> reqName = messages . get ( reqType , None ) <EOL> if not reqName : <EOL> self . sendResponse ( AGENT_FAILURE , '<STR_LIT>' ) <EOL> else : <EOL> f = getattr ( self , '<STR_LIT>' % reqName ) <EOL> if getattr ( self . factory , '<STR_LIT>' , None ) is None : <EOL> self . sendResponse ( AGENT_FAILURE , '<STR_LIT>' ) <EOL> raise MissingKeyStoreError ( ) <EOL> f ( packet [ <NUM_LIT:1> : ] ) <EOL> def sendResponse ( self , reqType , data ) : <EOL> pack = struct . pack ( '<STR_LIT>' , len ( data ) + <NUM_LIT:1> , reqType ) + data <EOL> self . transport . write ( pack ) <EOL> def agentc_REQUEST_IDENTITIES ( self , data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert data == '<STR_LIT>' <EOL> numKeys = len ( self . factory . keys ) <EOL> resp = [ ] <EOL> resp . append ( struct . pack ( '<STR_LIT>' , numKeys ) ) <EOL> for key , comment in self . factory . keys . itervalues ( ) : <EOL> resp . append ( NS ( key . blob ( ) ) ) <EOL> resp . append ( NS ( comment ) ) <EOL> self . sendResponse ( AGENT_IDENTITIES_ANSWER , '<STR_LIT>' . join ( resp ) ) <EOL> def agentc_SIGN_REQUEST ( self , data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> blob , data = getNS ( data ) <EOL>", "answer": "if blob not in self . factory . keys :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import print_function , division , absolute_import <EOL> import re <EOL> import os <EOL> import sys <EOL> import subprocess <EOL> from os . path import isdir , isfile , join , expanduser <EOL> from conda . utils import memoized <EOL> def find_executable ( executable , include_others = True ) : <EOL> global dir_paths <EOL> if include_others : <EOL> if sys . platform == '<STR_LIT:win32>' : <EOL> dir_paths = [ join ( sys . prefix , '<STR_LIT>' ) , <EOL> '<STR_LIT>' ] <EOL> else : <EOL> dir_paths = [ join ( sys . prefix , '<STR_LIT>' ) ] <EOL> else : <EOL> dir_paths = [ ] <EOL> dir_paths . extend ( os . environ [ '<STR_LIT>' ] . split ( os . pathsep ) ) <EOL> for dir_path in dir_paths : <EOL> if sys . platform == '<STR_LIT:win32>' : <EOL> for ext in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> path = join ( dir_path , executable + ext ) <EOL> if isfile ( path ) : <EOL> return path <EOL> else : <EOL> path = join ( dir_path , executable ) <EOL> if isfile ( expanduser ( path ) ) : <EOL> return expanduser ( path ) <EOL> return None <EOL> @ memoized <EOL> def find_commands ( include_others = True ) : <EOL> if include_others : <EOL> if sys . platform == '<STR_LIT:win32>' : <EOL> dir_paths = [ join ( sys . prefix , '<STR_LIT>' ) , <EOL> '<STR_LIT>' ] <EOL> else : <EOL> dir_paths = [ join ( sys . prefix , '<STR_LIT>' ) ] <EOL> else : <EOL> dir_paths = [ ] <EOL>", "answer": "if sys . platform == '<STR_LIT:win32>' :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import logging <EOL> from util import full_stack <EOL> from util import exec_remote_command <EOL> from util import build_context_script <EOL> from dbaas_cloudstack . models import HostAttr as CS_HostAttr <EOL> from workflow . steps . util . base import BaseStep <EOL> from workflow . exceptions . error_codes import DBAAS_0023 <EOL> from workflow . steps . util import test_bash_script_error <EOL> from workflow . steps . mongodb . util import build_disable_authentication_single_instance_script <EOL> from workflow . steps . mongodb . util import build_dump_database_script <EOL>", "answer": "from workflow . steps . mongodb . util import build_restart_database_script"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import logging <EOL> import sys <EOL> from kmip . core import enums <EOL> from kmip . demos import utils <EOL> from kmip . pie import client <EOL> from kmip . pie import objects <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL>", "answer": "logger = utils . build_console_logger ( logging . INFO )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys <EOL> import os <EOL> sys . path . insert ( <NUM_LIT:0> , os . path . abspath ( '<STR_LIT>' ) ) <EOL> extensions = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> templates_path = [ '<STR_LIT>' ] <EOL> source_suffix = '<STR_LIT>' <EOL> master_doc = '<STR_LIT:index>' <EOL> project = u'<STR_LIT>' <EOL> copyright = u'<STR_LIT>' <EOL> version = '<STR_LIT>' <EOL> release = '<STR_LIT>' <EOL> exclude_patterns = [ ] <EOL> pygments_style = '<STR_LIT>' <EOL> html_theme = '<STR_LIT:default>' <EOL> html_static_path = [ '<STR_LIT>' ] <EOL> htmlhelp_basename = '<STR_LIT>' <EOL> latex_elements = { <EOL> } <EOL> latex_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> man_pages = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> [ u'<STR_LIT>' ] , <NUM_LIT:1> ) <EOL> ] <EOL>", "answer": "texinfo_documents = ["}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import setuptools <EOL> import glob <EOL> VERSION_BYTES = b'<STR_LIT:1.0>' <EOL> def full_version_bytes ( ) : <EOL> import subprocess , time <EOL> try : <EOL> commit_bytes = subprocess . check_output ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> t_bytes = subprocess . check_output ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> t = int ( t_bytes . strip ( ) . decode ( '<STR_LIT:utf-8>' ) ) <EOL> tm = time . gmtime ( t ) <EOL> timestamp_utc = time . strftime ( \"<STR_LIT>\" , time . gmtime ( t ) ) <EOL> return VERSION_BYTES + b'<STR_LIT:->' + timestamp_utc . encode ( '<STR_LIT:utf-8>' ) + b'<STR_LIT:->' + commit_bytes . strip ( ) <EOL> except subprocess . CalledProcessError : <EOL> return VERSION_BYTES <EOL> version_bytes = full_version_bytes ( ) <EOL> with open ( '<STR_LIT>' , '<STR_LIT:wb>' ) as out : <EOL> out . write ( version_bytes ) <EOL> out . write ( b'<STR_LIT:\\n>' ) ; <EOL> setuptools . setup ( name = '<STR_LIT>' , <EOL> version = version_bytes . decode ( '<STR_LIT:utf-8>' ) , <EOL> description = '<STR_LIT>' , <EOL> url = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL>", "answer": "author_email = '<STR_LIT>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import mistune <EOL> from pygments import highlight <EOL> from pygments . lexers import get_lexer_by_name <EOL> from pygments . formatters import HtmlFormatter <EOL> class MyRenderer ( mistune . Renderer ) : <EOL> def block_code ( self , code , lang ) : <EOL>", "answer": "if not lang :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sublime , sublime_plugin <EOL> from subprocess import call <EOL> import os <EOL> import platform <EOL>", "answer": "try :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from laikaboss . objectmodel import ModuleObject , ExternalVars <EOL> from laikaboss . si_module import SI_MODULE <EOL> import gzip <EOL> import StringIO <EOL> class EXPLODE_GZIP ( SI_MODULE ) : <EOL> def __init__ ( self , ) : <EOL> self . module_name = \"<STR_LIT>\" <EOL> def _run ( self , scanObject , result , depth , args ) : <EOL> moduleResult = [ ] <EOL> file = StringIO . StringIO ( scanObject . buffer ) <EOL>", "answer": "gzip_file = gzip . GzipFile ( fileobj = file )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from decimal import Decimal as D <EOL> from django . conf import settings <EOL> from django . contrib . sites . models import Site <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from oscar . core . loading import get_class , get_model <EOL> from . import exceptions <EOL> Order = get_model ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> Line = get_model ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> OrderDiscount = get_model ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> order_placed = get_class ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> class OrderNumberGenerator ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def order_number ( self , basket ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return <NUM_LIT> + basket . id <EOL> class OrderCreator ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def place_order ( self , basket , total , <EOL> shipping_method , shipping_charge , user = None , <EOL> shipping_address = None , billing_address = None , <EOL> order_number = None , status = None , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if basket . is_empty : <EOL> raise ValueError ( _ ( \"<STR_LIT>\" ) ) <EOL> if not order_number : <EOL> generator = OrderNumberGenerator ( ) <EOL> order_number = generator . order_number ( basket ) <EOL> if not status and hasattr ( settings , '<STR_LIT>' ) : <EOL> status = getattr ( settings , '<STR_LIT>' ) <EOL> try : <EOL> Order . _default_manager . get ( number = order_number ) <EOL> except Order . DoesNotExist : <EOL> pass <EOL> else : <EOL> raise ValueError ( _ ( \"<STR_LIT>\" ) <EOL> % order_number ) <EOL> order = self . create_order_model ( <EOL> user , basket , shipping_address , shipping_method , shipping_charge , <EOL>", "answer": "billing_address , total , order_number , status , ** kwargs )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pyrseas . augment import DbAugmentDict , DbAugment <EOL> from pyrseas . dbobject import split_schema_obj <EOL> from pyrseas . dbobject . trigger import Trigger <EOL> class CfgTrigger ( DbAugment ) : <EOL> \"<STR_LIT>\" <EOL> keylist = [ '<STR_LIT:name>' ] <EOL> def apply ( self , table ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> newtrg = Trigger ( schema = table . schema , table = table . name , <EOL>", "answer": "** self . __dict__ )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> import sys <EOL> TEST_RUNNER = '<STR_LIT>' <EOL> PROJECT_ROOT = os . path . dirname ( os . path . abspath ( __file__ ) ) <EOL> path = lambda * a : os . path . join ( PROJECT_ROOT , * a ) <EOL>", "answer": "sys . path . insert ( <NUM_LIT:0> , path ( '<STR_LIT:..>' , '<STR_LIT:..>' ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL> import frappe <EOL> from frappe import _ <EOL> from frappe . model . document import Document <EOL> from frappe . model import no_value_fields <EOL> from frappe . translate import set_default_language <EOL> from frappe . utils import cint <EOL> from frappe . utils . momentjs import get_all_timezones <EOL> class SystemSettings ( Document ) : <EOL> def validate ( self ) : <EOL> for key in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> if self . get ( key ) : <EOL> parts = self . get ( key ) . split ( \"<STR_LIT::>\" ) <EOL> if len ( parts ) != <NUM_LIT:2> or not ( cint ( parts [ <NUM_LIT:0> ] ) or cint ( parts [ <NUM_LIT:1> ] ) ) : <EOL> frappe . throw ( _ ( \"<STR_LIT>\" ) . format ( \"<STR_LIT>\" ) ) <EOL>", "answer": "def on_update ( self ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import time <EOL> def TestAction ( aname , args , modelResult ) : <EOL> if aname == '<STR_LIT>' : <EOL> ( seconds , ) = args <EOL> time . sleep ( seconds ) <EOL> else : <EOL>", "answer": "raise NotImplementedError , '<STR_LIT>' % aname"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . contrib . humanize . templatetags import humanize <EOL> from django . utils import text <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> import six <EOL> from horizon import tables <EOL> def show_date ( datum ) : <EOL> return datum . split ( '<STR_LIT:T>' ) [ <NUM_LIT:0> ] <EOL> class ModifyUsageReportParameters ( tables . LinkAction ) : <EOL> name = \"<STR_LIT>\" <EOL> verbose_name = _ ( \"<STR_LIT>\" ) <EOL> url = \"<STR_LIT>\" <EOL> classes = ( \"<STR_LIT>\" , ) <EOL> icon = \"<STR_LIT>\" <EOL> class CreateCSVUsageReport ( tables . LinkAction ) : <EOL> name = \"<STR_LIT>\" <EOL> verbose_name = _ ( \"<STR_LIT>\" ) <EOL> url = \"<STR_LIT>\" <EOL> classes = ( \"<STR_LIT>\" , ) <EOL> icon = \"<STR_LIT>\" <EOL> class ReportTable ( tables . DataTable ) : <EOL> project = tables . Column ( '<STR_LIT>' , verbose_name = _ ( '<STR_LIT>' ) ) <EOL> service = tables . Column ( '<STR_LIT>' , verbose_name = _ ( '<STR_LIT>' ) ) <EOL> meter = tables . Column ( '<STR_LIT>' , verbose_name = _ ( '<STR_LIT>' ) ) <EOL> description = tables . Column ( '<STR_LIT:description>' , verbose_name = _ ( '<STR_LIT>' ) ) <EOL> time = tables . Column ( '<STR_LIT:time>' , verbose_name = _ ( '<STR_LIT>' ) , <EOL> filters = [ show_date ] ) <EOL> value = tables . Column ( '<STR_LIT:value>' , verbose_name = _ ( '<STR_LIT>' ) , <EOL> filters = [ humanize . intcomma ] ) <EOL> unit = tables . Column ( '<STR_LIT>' , verbose_name = _ ( '<STR_LIT>' ) ) <EOL> def get_object_id ( self , obj ) : <EOL> return \"<STR_LIT>\" % ( obj [ '<STR_LIT>' ] , obj [ '<STR_LIT>' ] , obj [ '<STR_LIT>' ] ) <EOL> class Meta ( object ) : <EOL>", "answer": "name = '<STR_LIT>'"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Static ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import ssl <EOL> import warnings <EOL> from . . _compat import MODERN_SSL <EOL> try : <EOL> from ssl import ( <EOL> OP_NO_SSLv2 , OP_NO_SSLv3 , OP_NO_COMPRESSION , <EOL> OP_CIPHER_SERVER_PREFERENCE , OP_SINGLE_DH_USE , OP_SINGLE_ECDH_USE <EOL> ) <EOL> except ImportError : <EOL> OP_NO_SSLv2 = <NUM_LIT> <EOL> OP_NO_SSLv3 = <NUM_LIT> <EOL> OP_NO_COMPRESSION = <NUM_LIT> <EOL> OP_CIPHER_SERVER_PREFERENCE = <NUM_LIT> <EOL> OP_SINGLE_DH_USE = <NUM_LIT> <EOL> OP_SINGLE_ECDH_USE = <NUM_LIT> <EOL> DEFAULT_CIPHERS = ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) <EOL> RESTRICTED_SERVER_CIPHERS = ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) <EOL> class InsecurePlatformWarning ( Warning ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> try : <EOL> from ssl import SSLContext <EOL> except ImportError : <EOL> import sys <EOL> class SSLContext ( object ) : <EOL> supports_set_ciphers = ( ( <NUM_LIT:2> , <NUM_LIT:7> ) <= sys . version_info < ( <NUM_LIT:3> , ) or <EOL> ( <NUM_LIT:3> , <NUM_LIT:2> ) <= sys . version_info ) <EOL> def __init__ ( self , protocol_version ) : <EOL> self . protocol = protocol_version <EOL> self . check_hostname = False <EOL> self . verify_mode = ssl . CERT_NONE <EOL> self . ca_certs = None <EOL> self . options = <NUM_LIT:0> <EOL> self . certfile = None <EOL> self . keyfile = None <EOL> self . ciphers = None <EOL> def load_cert_chain ( self , certfile = None , keyfile = None ) : <EOL> self . certfile = certfile <EOL> self . keyfile = keyfile <EOL> def load_verify_locations ( self , cafile = None , capath = None ) : <EOL> if capath is not None : <EOL> raise OSError ( \"<STR_LIT>\" ) <EOL> self . ca_certs = cafile <EOL> def set_ciphers ( self , cipher_suite ) : <EOL> if not self . supports_set_ciphers : <EOL> raise TypeError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> self . ciphers = cipher_suite <EOL> def wrap_socket ( self , socket , server_hostname = None , server_side = False ) : <EOL> warnings . warn ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> InsecurePlatformWarning <EOL> ) <EOL> kwargs = { <EOL> \"<STR_LIT>\" : self . keyfile , <EOL> \"<STR_LIT>\" : self . certfile , <EOL> \"<STR_LIT>\" : self . ca_certs , <EOL>", "answer": "\"<STR_LIT>\" : self . verify_mode ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from . . utils . access_permissions import BaseAccessPermissions <EOL> class MediafileAccessPermissions ( BaseAccessPermissions ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import argparse <EOL> import collections <EOL> import functools <EOL> import logging <EOL> import os <EOL> import sys <EOL> from six . moves import BaseHTTPServer <EOL> from six . moves import http_client <EOL> from six . moves import socketserver <EOL> import OpenSSL <EOL> from acme import challenges <EOL> from acme import crypto_util <EOL> logger = logging . getLogger ( __name__ ) <EOL> class TLSServer ( socketserver . TCPServer ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . certs = kwargs . pop ( \"<STR_LIT>\" , { } ) <EOL> self . method = kwargs . pop ( <EOL> \"<STR_LIT>\" , crypto_util . _DEFAULT_TLSSNI01_SSL_METHOD ) <EOL> self . allow_reuse_address = kwargs . pop ( \"<STR_LIT>\" , True ) <EOL> socketserver . TCPServer . __init__ ( self , * args , ** kwargs ) <EOL> def _wrap_sock ( self ) : <EOL> self . socket = crypto_util . SSLSocket ( <EOL> self . socket , certs = self . certs , method = self . method ) <EOL> def server_bind ( self ) : <EOL> self . _wrap_sock ( ) <EOL> return socketserver . TCPServer . server_bind ( self ) <EOL> class ACMEServerMixin : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> server_version = \"<STR_LIT>\" <EOL> allow_reuse_address = True <EOL> class TLSSNI01Server ( TLSServer , ACMEServerMixin ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , server_address , certs ) : <EOL> TLSServer . __init__ ( <EOL> self , server_address , BaseRequestHandlerWithLogging , certs = certs ) <EOL> class BaseRequestHandlerWithLogging ( socketserver . BaseRequestHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def log_message ( self , format , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> logger . debug ( \"<STR_LIT>\" , self . client_address [ <NUM_LIT:0> ] , format % args ) <EOL> def handle ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . log_message ( \"<STR_LIT>\" ) <EOL> socketserver . BaseRequestHandler . handle ( self ) <EOL> class HTTP01Server ( BaseHTTPServer . HTTPServer , ACMEServerMixin ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , server_address , resources ) : <EOL> BaseHTTPServer . HTTPServer . __init__ ( <EOL> self , server_address , HTTP01RequestHandler . partial_init ( <EOL> simple_http_resources = resources ) ) <EOL> class HTTP01RequestHandler ( BaseHTTPServer . BaseHTTPRequestHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> HTTP01Resource = collections . namedtuple ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . simple_http_resources = kwargs . pop ( \"<STR_LIT>\" , set ( ) ) <EOL> socketserver . BaseRequestHandler . __init__ ( self , * args , ** kwargs ) <EOL> def log_message ( self , format , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> logger . debug ( \"<STR_LIT>\" , self . client_address [ <NUM_LIT:0> ] , format % args ) <EOL> def handle ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . log_message ( \"<STR_LIT>\" ) <EOL> BaseHTTPServer . BaseHTTPRequestHandler . handle ( self ) <EOL> def do_GET ( self ) : <EOL> if self . path == \"<STR_LIT:/>\" : <EOL> self . handle_index ( ) <EOL> elif self . path . startswith ( \"<STR_LIT:/>\" + challenges . HTTP01 . URI_ROOT_PATH ) : <EOL> self . handle_simple_http_resource ( ) <EOL> else : <EOL> self . handle_404 ( ) <EOL> def handle_index ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . send_response ( <NUM_LIT:200> ) <EOL> self . send_header ( \"<STR_LIT:Content-Type>\" , \"<STR_LIT>\" ) <EOL> self . end_headers ( ) <EOL> self . wfile . write ( self . server . server_version . encode ( ) ) <EOL> def handle_404 ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . send_response ( http_client . NOT_FOUND , message = \"<STR_LIT>\" ) <EOL> self . send_header ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . end_headers ( ) <EOL> self . wfile . write ( b\"<STR_LIT>\" ) <EOL> def handle_simple_http_resource ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for resource in self . simple_http_resources : <EOL> if resource . chall . path == self . path : <EOL> self . log_message ( \"<STR_LIT>\" , <EOL> resource . chall . encode ( \"<STR_LIT>\" ) ) <EOL> self . send_response ( http_client . OK ) <EOL> self . end_headers ( ) <EOL> self . wfile . write ( resource . validation . encode ( ) ) <EOL> return <EOL> else : <EOL> self . log_message ( \"<STR_LIT>\" ) <EOL> self . log_message ( \"<STR_LIT>\" , <EOL> self . path ) <EOL> @ classmethod <EOL> def partial_init ( cls , simple_http_resources ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . conf import settings <EOL> from ionyweb . website . rendering . medias import * <EOL> from ionyweb . website . rendering . utils import render_view <EOL> RENDER_MEDIAS = ( <EOL> JSMedia ( '<STR_LIT>' ) , <EOL> JSMedia ( '<STR_LIT>' ) , <EOL> CSSMedia ( '<STR_LIT>' ) , <EOL>", "answer": "JSAdminMedia ( '<STR_LIT>' )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from . . ndtypes import Float64 , make_array_type <EOL> from seq_expr import SeqExpr <EOL> class ArrayExpr ( SeqExpr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , array , type = None , source_info = None ) : <EOL> self . array = array <EOL> self . type = type <EOL> self . source_info = source_info <EOL> def children ( self ) : <EOL> yield self . array <EOL> class Array ( ArrayExpr ) : <EOL> def __init__ ( self , elts , type = None , source_info = None ) : <EOL> self . elts = tuple ( elts ) <EOL> self . type = type <EOL> self . source_info = source_info <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % \"<STR_LIT:U+002CU+0020>\" . join ( str ( e ) for e in self . elts ) <EOL> def children ( self ) : <EOL> return self . elts <EOL> def __hash__ ( self ) : <EOL> return hash ( self . elts ) <EOL> class Slice ( ArrayExpr ) : <EOL> def __init__ ( self , start , stop , step , type = None , source_info = None ) : <EOL> self . start = start <EOL> self . stop = stop <EOL> self . step = step <EOL> self . type = type <EOL> self . source_info = source_info <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . start . short_str ( ) , <EOL> self . stop . short_str ( ) , <EOL> self . step . short_str ( ) ) <EOL> def __repr__ ( self ) : <EOL> return str ( self ) <EOL> def children ( self ) : <EOL> yield self . start <EOL> yield self . stop <EOL> yield self . step <EOL> def __eq__ ( self , other ) : <EOL> return other . __class__ is Slice and other . start == self . start and other . stop == self . stop and other . step == self . step <EOL> def __hash__ ( self ) : <EOL> return hash ( ( self . start , self . stop , self . step ) ) <EOL> class ConstArray ( ArrayExpr ) : <EOL> def __init__ ( self , shape , value , type = None , source_info = None ) : <EOL> self . shape = shape <EOL> self . value = value <EOL> self . type = type <EOL> self . source_info = source_info <EOL> def children ( self ) : <EOL> yield self . shape <EOL> yield self . value <EOL> class DiagonalArray ( ArrayExpr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , shape , value , offset = None , type = None , source_info = None ) : <EOL> self . shape = shape <EOL> self . value = value <EOL> self . offset = offset <EOL> self . type = type <EOL> self . source_info = source_info <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . shape , self . value , self . offset ) <EOL> def children ( self ) : <EOL> yield self . shape <EOL> yield self . value <EOL> if self . offset is not None : <EOL> yield self . offset <EOL> class ExtractDiagonal ( ArrayExpr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class ConstArrayLike ( ArrayExpr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , array , value , type = None , source_info = None ) : <EOL> self . array = array <EOL> self . value = value <EOL> self . type = type <EOL> self . source_info = source_info <EOL> def children ( self ) : <EOL> yield self . array <EOL> yield self . value <EOL> class Range ( ArrayExpr ) : <EOL> def __init__ ( self , start , stop , step , type = None , source_info = None ) : <EOL> self . start = start <EOL> self . stop = stop <EOL> self . step = step <EOL> self . type = type <EOL> self . source_info = source_info <EOL> def children ( self ) : <EOL> yield self . start <EOL> yield self . stop <EOL> yield self . step <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . start , self . stop , self . step ) <EOL> class AllocArray ( ArrayExpr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , shape , elt_type , type = None , order = \"<STR_LIT:C>\" , source_info = None ) : <EOL> self . shape = shape <EOL> self . elt_type = elt_type <EOL> self . type = type <EOL> self . source_info = source_info <EOL> assert order == \"<STR_LIT:C>\" , \"<STR_LIT>\" % order <EOL> self . order = order <EOL> def children ( self ) : <EOL> yield self . shape <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . shape , self . elt_type ) <EOL> class ArrayView ( ArrayExpr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , data , shape , strides , offset , size , type = None , source_info = None ) : <EOL> self . data = data <EOL> self . shape = shape <EOL> self . strides = strides <EOL> self . offset = offset <EOL> self . size = size <EOL> self . type = type <EOL> self . source_info = source_info <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . data , self . shape , self . strides , self . offset , self . size ) <EOL> def children ( self ) : <EOL> yield self . data <EOL> yield self . shape <EOL> yield self . strides <EOL> yield self . offset <EOL> yield self . size <EOL> class Ravel ( ArrayExpr ) : <EOL> def children ( self ) : <EOL> return ( self . array , ) <EOL> def __str__ ( self ) : <EOL>", "answer": "return \"<STR_LIT>\" % self . array"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from setuptools import setup <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> url = '<STR_LIT>' , <EOL> license = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> long_description = __doc__ , <EOL> py_modules = [ '<STR_LIT>' ] , <EOL> zip_safe = False , <EOL> platforms = '<STR_LIT>' , <EOL> install_requires = [ <EOL> '<STR_LIT>' <EOL> ] , <EOL> tests_require = '<STR_LIT>' , <EOL> test_suite = '<STR_LIT>' , <EOL> classifiers = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import nmrglue . fileio . pipe as pipe <EOL> import nmrglue . process . pipe_proc as p <EOL> d , a = pipe . read ( \"<STR_LIT>\" ) <EOL> d , a = p . em ( d , a , lb = <NUM_LIT> , c = <NUM_LIT:0.5> , start = <NUM_LIT:100> , size = <NUM_LIT> , one = True ) <EOL> pipe . write ( \"<STR_LIT>\" , d , a , overwrite = True ) <EOL>", "answer": "d , a = pipe . read ( \"<STR_LIT>\" )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from ctypes import BigEndianStructure , Union , c_uint8 , c_uint16 , c_uint32 <EOL> from io import BytesIO <EOL> from . compat import * <EOL> from . error import * <EOL> from . packet import * <EOL> from . types import * <EOL> from . util import * <EOL> class Box ( Packet ) : <EOL> exception = F4VError <EOL> def __init__ ( self , type , payload , extended_size = False ) : <EOL> self . type = type <EOL> self . payload = payload <EOL> self . extended_size = extended_size <EOL> @ property <EOL> def size ( self ) : <EOL> size = <NUM_LIT:8> <EOL> size += self . payload . size <EOL> if size > <NUM_LIT> or self . extended_size : <EOL> size += <NUM_LIT:8> <EOL> return size <EOL> @ classmethod <EOL> def _deserialize ( cls , io , strict = False , raw_payload = False ) : <EOL> size = U32BE . read ( io ) <EOL> type_ = FourCC . read ( io ) <EOL> header_size = <NUM_LIT:8> <EOL> extended_size = False <EOL> if size == <NUM_LIT:1> : <EOL> size = U64BE . read ( io ) <EOL> header_size += <NUM_LIT:8> <EOL> extended_size = True <EOL> if size == <NUM_LIT:0> : <EOL> data = io . read ( ) <EOL> else : <EOL> data = chunked_read ( io , size - header_size , exception = F4VError ) <EOL> if type_ in PayloadTypes and not raw_payload : <EOL> payloadcls = PayloadTypes [ type_ ] <EOL> payloadio = BytesIO ( data ) <EOL> payload = payloadcls . deserialize ( payloadio ) <EOL> else : <EOL> payload = RawPayload ( data ) <EOL> box = cls ( type_ , payload , extended_size ) <EOL> if strict and box . size != size : <EOL> raise F4VError ( \"<STR_LIT>\" ) <EOL> return box <EOL> def _serialize ( self , packet ) : <EOL> size = self . payload . size <EOL> if size > <NUM_LIT> or self . extended_size : <EOL> packet += U32BE ( <NUM_LIT:1> ) <EOL> else : <EOL> packet += U32BE ( size + <NUM_LIT:8> ) <EOL> packet += FourCC ( self . type ) <EOL> if size > <NUM_LIT> or self . extended_size : <EOL> packet += U64BE ( size + <NUM_LIT:16> ) <EOL> if isinstance ( self . payload , BoxPayload ) : <EOL> self . payload . serialize ( packet ) <EOL> else : <EOL> packetwrite ( self . payload ) <EOL> class BoxPayload ( Packet ) : <EOL> exception = F4VError <EOL> @ property <EOL> def size ( self ) : <EOL> return <NUM_LIT:0> <EOL> @ classmethod <EOL> def box ( cls , * args , ** kw ) : <EOL> type_ = None <EOL> for name , kls in PayloadTypes . items ( ) : <EOL> if kls == cls : <EOL> type_ = name <EOL> break <EOL> payload = cls ( * args , ** kw ) <EOL> return Box ( type_ , <NUM_LIT:0> , payload ) <EOL> class BoxContainer ( BoxPayload ) : <EOL> def __init__ ( self , boxes ) : <EOL> self . boxes = boxes <EOL> @ property <EOL> def size ( self ) : <EOL> size = <NUM_LIT:0> <EOL> for box in self . boxes : <EOL> size += box . size <EOL> return size <EOL> def _serialize ( self , packet ) : <EOL> for box in self . boxes : <EOL> box . serialize ( packet ) <EOL> @ classmethod <EOL> def _deserialize ( cls , io ) : <EOL> boxes = [ ] <EOL> while True : <EOL> try : <EOL> box = Box . deserialize ( io ) <EOL> except IOError : <EOL> break <EOL> boxes . append ( box ) <EOL> return cls ( boxes ) <EOL> class BoxContainerSingle ( BoxPayload ) : <EOL> def __init__ ( self , box ) : <EOL> self . box = box <EOL> @ property <EOL> def size ( self ) : <EOL> return self . box . size <EOL> def _serialize ( self , packet ) : <EOL> self . box . serialize ( packet ) <EOL> @ classmethod <EOL> def _deserialize ( cls , io ) : <EOL> box = Box . deserialize ( io ) <EOL> return cls ( box ) <EOL> class RawPayload ( BoxPayload ) : <EOL> def __init__ ( self , data ) : <EOL> self . data = data <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" . format ( self . size ) <EOL> @ property <EOL> def size ( self ) : <EOL> return len ( self . data ) <EOL> @ classmethod <EOL> def _deserialize ( cls , io ) : <EOL> data = io . read ( ) <EOL> return cls ( data ) <EOL> def _serialize ( self , packet ) : <EOL> packet += self . data <EOL> class BoxPayloadFTYP ( BoxPayload ) : <EOL> def __init__ ( self , major_brand = \"<STR_LIT>\" , minor_version = <NUM_LIT:0> , <EOL> compatible_brands = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) : <EOL> self . major_brand = major_brand <EOL> self . minor_version = minor_version <EOL> self . compatible_brands = compatible_brands <EOL> @ property <EOL> def size ( self ) : <EOL> return <NUM_LIT:4> + <NUM_LIT:4> + ( len ( self . compatible_brands ) * <NUM_LIT:4> ) <EOL> def _serialize ( self , packet ) : <EOL> packet += FourCC ( self . major_brand ) <EOL> packet += U32BE ( self . minor_version ) <EOL> for brand in self . compatible_brands : <EOL> packet += FourCC ( brand ) <EOL> @ classmethod <EOL> def _deserialize ( cls , io ) : <EOL> major_brand = FourCC . read ( io ) <EOL> minor_version = U32BE . read ( io ) <EOL> compatible_brands = [ ] <EOL> while True : <EOL> try : <EOL> brand = FourCC . read ( io ) <EOL> except IOError : <EOL> break <EOL> compatible_brands . append ( brand ) <EOL> return cls ( major_brand , minor_version , <EOL> compatible_brands ) <EOL> class BoxPayloadMVHD ( BoxPayload ) : <EOL> def __init__ ( self , version = <NUM_LIT:0> , creation_time = <NUM_LIT:0> , modification_time = <NUM_LIT:0> , <EOL> time_scale = <NUM_LIT:1000> , duration = <NUM_LIT:0> , rate = <NUM_LIT:1.0> , volume = <NUM_LIT:1.0> , <EOL> matrix = [ <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT> ] , <EOL> next_track_id = <NUM_LIT:0> ) : <EOL> self . version = version <EOL> self . creation_time = creation_time <EOL> self . modification_time = modification_time <EOL> self . time_scale = time_scale <EOL> self . duration = duration <EOL> self . rate = rate <EOL> self . volume = volume <EOL> self . matrix = matrix <EOL> self . next_track_id = next_track_id <EOL> @ property <EOL> def size ( self ) : <EOL> size = <NUM_LIT:1> + <NUM_LIT:3> + <NUM_LIT:4> + <NUM_LIT:4> + <NUM_LIT:2> + <NUM_LIT:2> + <NUM_LIT:4> + <NUM_LIT:4> + ( <NUM_LIT:9> * <NUM_LIT:4> ) + ( <NUM_LIT:6> * <NUM_LIT:4> ) + <NUM_LIT:4> <EOL> if self . version == <NUM_LIT:1> : <EOL> size += <NUM_LIT:3> * <NUM_LIT:8> <EOL> else : <EOL> size += <NUM_LIT:3> * <NUM_LIT:4> <EOL> return size <EOL> def _serialize ( self , packet ) : <EOL> packet += U8 ( self . version ) <EOL> packet += U24BE ( <NUM_LIT:0> ) <EOL> packet += U3264 ( self . creation_time , self . version ) <EOL> packet += U3264 ( self . modification_time , self . version ) <EOL> packet += U32BE ( self . time_scale ) <EOL> packet += U3264 ( self . duration , self . version ) <EOL> packet += S16BE_16 ( self . rate ) <EOL> packet += S8_8BE ( self . volume ) <EOL> packet += U16BE ( <NUM_LIT:0> ) <EOL> packet += U32BE ( <NUM_LIT:0> ) <EOL> packet += U32BE ( <NUM_LIT:0> ) <EOL> for m in self . matrix : <EOL> packet += U32BE ( m ) <EOL> for i in range ( <NUM_LIT:6> ) : <EOL> packet += U32BE ( <NUM_LIT:0> ) <EOL> packet += U32BE ( self . next_track_id ) <EOL> @ classmethod <EOL> def _deserialize ( cls , io ) : <EOL> version = U8 . read ( io ) <EOL> U24BE . read ( io ) <EOL> creation_time = U3264 . read ( io , version ) <EOL> modification_time = U3264 . read ( io , version ) <EOL> time_scale = U32BE . read ( io ) <EOL> duration = U3264 . read ( io , version ) <EOL> rate = S16_16 . read ( io ) <EOL> volume = S8_8BE . read ( io ) <EOL> U16BE . read ( io ) <EOL> U32BE . read ( io ) <EOL> U32BE . read ( io ) <EOL> matrix = [ ] <EOL> for i in range ( <NUM_LIT:9> ) : <EOL> matrix . append ( U32BE . read ( io ) ) <EOL> for i in range ( <NUM_LIT:6> ) : <EOL> U32BE . read ( io ) <EOL> next_track_id = U32BE . read ( io ) <EOL> return cls ( version , creation_time , <EOL> modification_time , time_scale , duration , <EOL> rate , volume , matrix , next_track_id ) <EOL> class SampleFlags ( BoxPayload ) : <EOL> class Flags ( Union ) : <EOL> class Bits ( BigEndianStructure ) : <EOL> _fields_ = [ ( \"<STR_LIT>\" , c_uint8 , <NUM_LIT:6> ) , <EOL> ( \"<STR_LIT>\" , c_uint8 , <NUM_LIT:2> ) , <EOL> ( \"<STR_LIT>\" , c_uint8 , <NUM_LIT:2> ) , <EOL> ( \"<STR_LIT>\" , c_uint8 , <NUM_LIT:2> ) , <EOL> ( \"<STR_LIT>\" , c_uint8 , <NUM_LIT:3> ) , <EOL> ( \"<STR_LIT>\" , c_uint8 , <NUM_LIT:1> ) , <EOL> ( \"<STR_LIT>\" , c_uint16 , <NUM_LIT:16> ) ] <EOL> _fields_ = [ ( \"<STR_LIT>\" , Bits ) , ( \"<STR_LIT>\" , c_uint32 ) ] <EOL> def __init__ ( self , sample_depends_on , sample_is_depended_on , <EOL> sample_has_redundancy , sample_padding_value , <EOL> sample_is_difference_sample , sample_degradation_priority ) : <EOL> self . flags = self . Flags ( ) <EOL> self . flags . bit . reserved = <NUM_LIT:0> <EOL> self . flags . bit . sample_depends_on = sample_depends_on <EOL> self . flags . bit . sample_is_depended_on = sample_is_depended_on <EOL> self . flags . bit . sample_has_redundancy = sample_has_redundancy <EOL> self . flags . bit . sample_padding_value = sample_padding_value <EOL> self . flags . bit . sample_is_difference_sample = sample_is_difference_sample <EOL> self . flags . bit . sample_degradation_priority = sample_degradation_priority <EOL> @ property <EOL> def size ( self ) : <EOL> return <NUM_LIT:4> <EOL> def _serialize ( self , packet ) : <EOL> packet += U32BE ( self . flags . byte ) <EOL> @ classmethod <EOL> def _deserialize ( cls , io ) : <EOL> flags = cls . Flags ( ) <EOL> flags . byte = U32BE . read ( io ) <EOL> return cls ( flags . bit . sample_depends_on , flags . bit . sample_is_depended_on , <EOL> flags . bit . sample_has_redundancy , flags . bit . sample_padding_value , <EOL> flags . bit . sample_is_difference_sample , flags . bit . sample_degradation_priority ) <EOL> class BoxPayloadTREX ( BoxPayload ) : <EOL> def __init__ ( self , version , track_id , <EOL> default_sample_description_index , <EOL> default_sample_duration , default_sample_size , <EOL> default_sample_flags ) : <EOL> self . version = version <EOL> self . track_id = track_id <EOL> self . default_sample_description_index = default_sample_description_index <EOL> self . default_sample_duration = default_sample_duration <EOL> self . default_sample_size = default_sample_size <EOL> self . default_sample_flags = default_sample_flags <EOL> @ property <EOL> def size ( self ) : <EOL> return <NUM_LIT:1> + <NUM_LIT:3> + <NUM_LIT:4> + <NUM_LIT:4> + <NUM_LIT:4> + <NUM_LIT:4> + self . default_sample_flags . size <EOL> def _serialize ( self , packet ) : <EOL> packet += U8 ( self . version ) <EOL> packet += U24BE ( <NUM_LIT:0> ) <EOL> packet += U32BE ( self . track_id ) <EOL> packet += U32BE ( self . default_sample_description_index ) <EOL> packet += U32BE ( self . default_sample_duration ) <EOL> packet += U32BE ( self . default_sample_size ) <EOL> self . default_sample_flags . serialize ( packet ) <EOL> @ classmethod <EOL> def _deserialize ( cls , io ) : <EOL> version = U8 . read ( io ) <EOL> flags = U24BE . read ( io ) <EOL> track_id = U32BE . read ( io ) <EOL> default_sample_description_index = U32BE . read ( io ) <EOL> default_sample_duration = U32BE . read ( io ) <EOL> default_sample_size = U32BE . read ( io ) <EOL> default_sample_flags = SampleFlags . deserialize ( io ) <EOL> return cls ( version , track_id , <EOL> default_sample_description_index , <EOL> default_sample_duration , default_sample_size , <EOL> default_sample_flags ) <EOL> class BoxPayloadTKHD ( BoxPayload ) : <EOL> def __init__ ( self , version = <NUM_LIT:0> , flags = <NUM_LIT:1> , creation_time = <NUM_LIT:0> , modification_time = <NUM_LIT:0> , <EOL> track_id = <NUM_LIT:1> , duration = <NUM_LIT:0> , layer = <NUM_LIT:0> , alternate_group = <NUM_LIT:0> , volume = <NUM_LIT:0.0> , <EOL> transform_matrix = [ <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT> ] , <EOL> width = <NUM_LIT:0.0> , height = <NUM_LIT:0.0> ) : <EOL> self . version = version <EOL> self . flags = flags <EOL> self . creation_time = creation_time <EOL> self . modification_time = modification_time <EOL> self . track_id = track_id <EOL> self . duration = duration <EOL> self . layer = layer <EOL> self . alternate_group = alternate_group <EOL> self . volume = volume <EOL> self . transform_matrix = transform_matrix <EOL> self . width = width <EOL> self . height = height <EOL> @ property <EOL> def size ( self ) : <EOL> size = <NUM_LIT:1> + <NUM_LIT:3> + <NUM_LIT:4> + <NUM_LIT:4> + <NUM_LIT:4> + <NUM_LIT:4> + <NUM_LIT:4> + ( <NUM_LIT:4> * <NUM_LIT:2> ) + <NUM_LIT:2> + <NUM_LIT:2> + <NUM_LIT:2> + <NUM_LIT:2> + ( <NUM_LIT:9> * <NUM_LIT:4> ) + <NUM_LIT:4> + <NUM_LIT:4> <EOL> if self . version == <NUM_LIT:1> : <EOL> size += <NUM_LIT:4> * <NUM_LIT:3> <EOL> return size <EOL> def _serialize ( self , packet ) : <EOL> packet += U8 ( self . version ) <EOL> packet += U24BE ( self . flags ) <EOL> packet += U3264 ( self . creation_time , self . version ) <EOL> packet += U3264 ( self . modification_time , self . version ) <EOL> packet += U32BE ( self . track_id ) <EOL> packet += U32BE ( <NUM_LIT:0> ) <EOL> packet += U3264 ( self . duration , self . version ) <EOL> for i in range ( <NUM_LIT:2> ) : <EOL> packet += U32BE ( <NUM_LIT:0> ) <EOL> packet += S16BE ( self . layer ) <EOL> packet += S16BE ( self . alternate_group ) <EOL> packet += S8_8BE ( self . volume ) <EOL> packet += U16BE ( <NUM_LIT:0> ) <EOL> for i in range ( <NUM_LIT:9> ) : <EOL> packet += U32BE ( self . transform_matrix [ i ] ) <EOL> packet += S16BE_16 ( self . width ) <EOL> packet += S16BE_16 ( self . height ) <EOL> @ classmethod <EOL> def _deserialize ( cls , io ) : <EOL> version = U8 . read ( io ) <EOL> flags = U24BE . read ( io ) <EOL> creation_time = U3264 . read ( io , version ) <EOL> modification_time = U3264 . read ( io , version ) <EOL> track_id = U32BE . read ( io ) <EOL> U32BE . read ( io ) <EOL> duration = U3264 . read ( io , version ) <EOL> for i in range ( <NUM_LIT:2> ) : <EOL> U32BE . read ( io ) <EOL> layer = S16BE . read ( io ) <EOL> alternate_group = S16BE . read ( io ) <EOL> volume = S8_8BE . read ( io ) <EOL> U16BE . read ( io ) <EOL> transform_matrix = [ ] <EOL> for i in range ( <NUM_LIT:9> ) : <EOL> transform_matrix . append ( S32BE . read ( io ) ) <EOL> width = S16_16 . read ( io ) <EOL> height = S16_16 . read ( io ) <EOL> return cls ( version , flags , creation_time , modification_time , <EOL> track_id , duration , layer , alternate_group , volume , <EOL> transform_matrix , width , height ) <EOL> class BoxPayloadMDHD ( BoxPayload ) : <EOL> def __init__ ( self , version = <NUM_LIT:0> , creation_time = <NUM_LIT:0> , modification_time = <NUM_LIT:0> , <EOL> time_scale = <NUM_LIT:1000> , duration = <NUM_LIT:0> , language = \"<STR_LIT>\" ) : <EOL> self . version = version <EOL> self . creation_time = creation_time <EOL> self . modification_time = modification_time <EOL> self . time_scale = time_scale <EOL> self . duration = duration <EOL> self . language = language <EOL> @ property <EOL> def size ( self ) : <EOL> size = <NUM_LIT:1> + <NUM_LIT:3> + <NUM_LIT:4> + <NUM_LIT:4> + <NUM_LIT:4> + <NUM_LIT:4> + <NUM_LIT:2> + <NUM_LIT:2> <EOL> if self . version == <NUM_LIT:1> : <EOL> size += <NUM_LIT:4> * <NUM_LIT:3> <EOL> return size <EOL> def _serialize ( self , packet ) : <EOL> packet += U8 ( self . version ) <EOL> packet += U24BE ( <NUM_LIT:0> ) <EOL> packet += U3264 ( self . creation_time , self . version ) <EOL> packet += U3264 ( self . modification_time , self . version ) <EOL> packet += U32BE ( self . time_scale ) <EOL> packet += U3264 ( self . duration , self . version ) <EOL> packet += S16BE ( iso639_to_lang ( self . language ) ) <EOL> packet += U16BE ( <NUM_LIT:0> ) <EOL> @ classmethod <EOL> def _deserialize ( cls , io ) : <EOL> version = U8 . read ( io ) <EOL> U24BE . read ( io ) <EOL> creation_time = U3264 . read ( io , version ) <EOL> modification_time = U3264 . read ( io , version ) <EOL> time_scale = U32BE . read ( io ) <EOL> duration = U3264 . read ( io , version ) <EOL> language = lang_to_iso639 ( U16BE . read ( io ) ) <EOL> U16BE . read ( io ) <EOL> return cls ( version , creation_time , modification_time , <EOL> time_scale , duration , language ) <EOL> class BoxPayloadHDLR ( BoxPayload ) : <EOL> def __init__ ( self , version = <NUM_LIT:0> , predefined = <NUM_LIT:0> , handler_type = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" ) : <EOL> self . version = version <EOL> self . predefined = predefined <EOL> self . handler_type = handler_type <EOL> self . name = name <EOL> @ property <EOL> def size ( self ) : <EOL> size = <NUM_LIT:1> + <NUM_LIT:3> + <NUM_LIT:4> + <NUM_LIT:4> + ( <NUM_LIT:3> * <NUM_LIT:4> ) <EOL> size += len ( self . name ) <EOL> return size <EOL> def _serialize ( self , packet ) : <EOL> packet += U8 ( self . version ) <EOL> packet += U24BE ( <NUM_LIT:0> ) <EOL> packet += U32BE ( self . predefined ) <EOL> packet += FourCC ( self . handler_type ) <EOL> for i in range ( <NUM_LIT:3> ) : <EOL> packet += U32BE ( <NUM_LIT:0> ) <EOL> packet += CString ( self . name ) <EOL> @ classmethod <EOL> def _deserialize ( cls , io ) : <EOL> version = U8 . read ( io ) <EOL> flags = U24BE . read ( io ) <EOL> predefined = U32BE . read ( io ) <EOL> handler_type = FourCC . read ( io ) <EOL> for i in range ( <NUM_LIT:3> ) : <EOL> U32BE . read ( io ) <EOL> name = CString . read ( io ) <EOL> return cls ( version , predefined , handler_type , <EOL> name ) <EOL> class BoxPayloadVMHD ( BoxPayload ) : <EOL> def __init__ ( self , version = <NUM_LIT:0> , flags = <NUM_LIT:1> , graphics_mode = <NUM_LIT:0> , op_color = [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] ) : <EOL> self . version = version <EOL> self . flags = flags <EOL> self . graphics_mode = graphics_mode <EOL> self . op_color = op_color <EOL> @ property <EOL> def size ( self ) : <EOL> return <NUM_LIT:1> + <NUM_LIT:3> + <NUM_LIT:2> + ( <NUM_LIT:3> * <NUM_LIT:2> ) <EOL> def _serialize ( self , packet ) : <EOL> packet += U8 ( self . version ) <EOL> packet += U24BE ( self . flags ) <EOL> packet += U16BE ( self . graphics_mode ) <EOL> for i in range ( <NUM_LIT:3> ) : <EOL> packet += U16BE ( self . op_color [ i ] ) <EOL> @ classmethod <EOL> def _deserialize ( cls , io ) : <EOL> version = U8 . read ( io ) <EOL> flags = U24BE . read ( io ) <EOL> graphics_mode = U16BE . read ( io ) <EOL> op_color = [ ] <EOL> for i in range ( <NUM_LIT:3> ) : <EOL> op_color . append ( U16BE . read ( io ) ) <EOL> return cls ( version , flags , graphics_mode , op_color ) <EOL> class BoxPayloadDREF ( BoxContainer ) : <EOL> def __init__ ( self , version = <NUM_LIT:0> , boxes = [ ] ) : <EOL> self . version = version <EOL> self . boxes = boxes <EOL> @ property <EOL> def size ( self ) : <EOL> size = <NUM_LIT:1> + <NUM_LIT:3> + <NUM_LIT:4> <EOL> for box in self . boxes : <EOL> size += box . size <EOL> return size <EOL> def _serialize ( self , packet ) : <EOL> packet += U8 ( self . version ) <EOL> packet += U24BE ( <NUM_LIT:0> ) <EOL> packet += U32BE ( len ( self . boxes ) ) <EOL> for box in self . boxes : <EOL> box . serialize ( packet ) <EOL> @ classmethod <EOL>", "answer": "def _deserialize ( cls , io ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import division <EOL> from vistrails . db . domain import DBPluginData <EOL> import unittest <EOL> import copy <EOL> import random <EOL> from vistrails . db . domain import IdScope <EOL> import vistrails . core <EOL> class PluginData ( DBPluginData ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> DBPluginData . __init__ ( self , * args , ** kwargs ) <EOL> if self . id is None : <EOL> self . id = - <NUM_LIT:1> <EOL> def __copy__ ( self ) : <EOL> return PluginData . do_copy ( self ) <EOL> def do_copy ( self , new_ids = False , id_scope = None , id_remap = None ) : <EOL> cp = DBPluginData . do_copy ( self , new_ids , id_scope , id_remap ) <EOL> cp . __class__ = PluginData <EOL> return cp <EOL> @ staticmethod <EOL> def convert ( _plugin_data ) : <EOL> _plugin_data . __class__ = PluginData <EOL> id = DBPluginData . db_id <EOL> data = DBPluginData . db_data <EOL> def __eq__ ( self , other ) : <EOL>", "answer": "if type ( other ) != type ( self ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> from setuptools import setup <EOL> setup ( <EOL> name = \"<STR_LIT>\" , <EOL> version = \"<STR_LIT>\" , <EOL> author = \"<STR_LIT>\" , <EOL> author_email = \"<STR_LIT>\" , <EOL> description = ( \"<STR_LIT>\" ) , <EOL> license = \"<STR_LIT>\" , <EOL> keywords = \"<STR_LIT>\" , <EOL> url = \"<STR_LIT>\" , <EOL> packages = [ '<STR_LIT>' , ] , <EOL> scripts = [ '<STR_LIT>' ] , <EOL> classifiers = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL>", "answer": "\"<STR_LIT>\" ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from inspect import getargspec <EOL> from django . template import Library , base <EOL> from . . import get_option <EOL> register = Library ( ) <EOL> def optional_assignment_tag ( func = None , takes_context = None , name = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def dec ( func ) : <EOL> params , varargs , varkw , defaults = getargspec ( func ) <EOL> class AssignmentNode ( base . TagHelperNode ) : <EOL> def __init__ ( self , takes_context , args , kwargs , target_var = None ) : <EOL> super ( AssignmentNode , self ) . __init__ ( takes_context , args , kwargs ) <EOL> self . target_var = target_var <EOL> def render ( self , context ) : <EOL> resolved_args , resolved_kwargs = self . get_resolved_arguments ( context ) <EOL> output = func ( * resolved_args , ** resolved_kwargs ) <EOL> if self . target_var is None : <EOL> return output <EOL> else : <EOL> context [ self . target_var ] = output <EOL> return '<STR_LIT>' <EOL> function_name = ( name or <EOL> getattr ( func , '<STR_LIT>' , func ) . __name__ ) <EOL> def compile_func ( parser , token ) : <EOL> bits = token . split_contents ( ) [ <NUM_LIT:1> : ] <EOL> if len ( bits ) < <NUM_LIT:2> or bits [ - <NUM_LIT:2> ] != '<STR_LIT>' : <EOL> target_var = None <EOL>", "answer": "else :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> from setuptools import setup <EOL> def read ( fname ) : <EOL> return open ( os . path . join ( os . path . dirname ( __file__ ) , fname ) ) . read ( ) <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> long_description = read ( \"<STR_LIT>\" ) , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> url = '<STR_LIT>' , <EOL> keywords = \"<STR_LIT>\" , <EOL>", "answer": "packages = [ '<STR_LIT>' ] ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from simplejson import JSONDecodeError <EOL> from rest_framework import viewsets , decorators , exceptions , status <EOL> from rest_framework . response import Response <EOL> from nodeconductor . core import filters as core_filters <EOL> from nodeconductor . structure import filters as structure_filters <EOL> from nodeconductor . template import models , serializers , filters <EOL> class TemplateGroupViewSet ( viewsets . ReadOnlyModelViewSet ) : <EOL> queryset = models . TemplateGroup . objects . filter ( is_active = True ) . prefetch_related ( '<STR_LIT>' ) <EOL> serializer_class = serializers . TemplateGroupSerializer <EOL> lookup_field = '<STR_LIT>' <EOL> filter_class = filters . TemplateGroupFilter <EOL> filter_backends = ( core_filters . DjangoMappingFilterBackend , structure_filters . TagsFilter ) <EOL> tags_filter_db_field = '<STR_LIT>' <EOL> tags_filter_request_field = '<STR_LIT>' <EOL> def list ( self , request , * args , ** kwargs ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> class BaseTask ( object ) : <EOL> helptext_short = \"<STR_LIT>\" <EOL> def __init__ ( self ) : <EOL> raise NotImplementedError <EOL> @ classmethod <EOL> def help ( cls ) : <EOL> raise NotImplementedError <EOL> @ classmethod <EOL> def run ( cls , * args , ** kwargs ) : <EOL> raise NotImplementedError <EOL> @ classmethod <EOL>", "answer": "def usage ( cls ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from warnings import warn as _warn <EOL> from types import MethodType as _MethodType , BuiltinMethodType as _BuiltinMethodType <EOL> from math import log as _log , exp as _exp , pi as _pi , e as _e <EOL> from math import sqrt as _sqrt , acos as _acos , cos as _cos , sin as _sin <EOL> from os import urandom as _urandom <EOL> from binascii import hexlify as _hexlify <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] <EOL> NV_MAGICCONST = <NUM_LIT:4> * _exp ( - <NUM_LIT:0.5> ) / _sqrt ( <NUM_LIT> ) <EOL> TWOPI = <NUM_LIT> * _pi <EOL> LOG4 = _log ( <NUM_LIT> ) <EOL> SG_MAGICCONST = <NUM_LIT:1.0> + _log ( <NUM_LIT> ) <EOL> BPF = <NUM_LIT> <EOL> RECIP_BPF = <NUM_LIT:2> ** - BPF <EOL> import _random <EOL> class Random ( _random . Random ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> VERSION = <NUM_LIT:2> <EOL> def __init__ ( self , x = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . seed ( x ) <EOL> self . gauss_next = None <EOL> def seed ( self , a = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if a is None : <EOL> try : <EOL> a = long ( _hexlify ( _urandom ( <NUM_LIT:16> ) ) , <NUM_LIT:16> ) <EOL> except NotImplementedError : <EOL> import time <EOL> a = long ( time . time ( ) * <NUM_LIT> ) <EOL> super ( Random , self ) . seed ( a ) <EOL> self . gauss_next = None <EOL> def getstate ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . VERSION , super ( Random , self ) . getstate ( ) , self . gauss_next <EOL> def setstate ( self , state ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> version = state [ <NUM_LIT:0> ] <EOL> if version == <NUM_LIT:2> : <EOL> version , internalstate , self . gauss_next = state <EOL> super ( Random , self ) . setstate ( internalstate ) <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % <EOL> ( version , self . VERSION ) ) <EOL> def __getstate__ ( self ) : <EOL> return self . getstate ( ) <EOL> def __setstate__ ( self , state ) : <EOL> self . setstate ( state ) <EOL> def __reduce__ ( self ) : <EOL> return self . __class__ , ( ) , self . getstate ( ) <EOL> def randrange ( self , start , stop = None , step = <NUM_LIT:1> , int = int , default = None , <EOL> maxwidth = <NUM_LIT:1> L << BPF ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> istart = int ( start ) <EOL> if istart != start : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> if stop is default : <EOL> if istart > <NUM_LIT:0> : <EOL> if istart >= maxwidth : <EOL> return self . _randbelow ( istart ) <EOL> return int ( self . random ( ) * istart ) <EOL> raise ValueError , \"<STR_LIT>\" <EOL> istop = int ( stop ) <EOL> if istop != stop : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> width = istop - istart <EOL> if step == <NUM_LIT:1> and width > <NUM_LIT:0> : <EOL> if width >= maxwidth : <EOL> return int ( istart + self . _randbelow ( width ) ) <EOL> return int ( istart + int ( self . random ( ) * width ) ) <EOL> if step == <NUM_LIT:1> : <EOL> raise ValueError , \"<STR_LIT>\" % ( istart , istop , width ) <EOL> istep = int ( step ) <EOL> if istep != step : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> if istep > <NUM_LIT:0> : <EOL> n = ( width + istep - <NUM_LIT:1> ) // istep <EOL> elif istep < <NUM_LIT:0> : <EOL> n = ( width + istep + <NUM_LIT:1> ) // istep <EOL> else : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> if n <= <NUM_LIT:0> : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> if n >= maxwidth : <EOL> return istart + self . _randbelow ( n ) <EOL> return istart + istep * int ( self . random ( ) * n ) <EOL> def randint ( self , a , b ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . randrange ( a , b + <NUM_LIT:1> ) <EOL> def _randbelow ( self , n , _log = _log , int = int , _maxwidth = <NUM_LIT:1> L << BPF , <EOL> _Method = _MethodType , _BuiltinMethod = _BuiltinMethodType ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> getrandbits = self . getrandbits <EOL> except AttributeError : <EOL> pass <EOL> else : <EOL> if type ( self . random ) is _BuiltinMethod or type ( getrandbits ) is _Method : <EOL> k = int ( <NUM_LIT> + _log ( n - <NUM_LIT:1> , <NUM_LIT> ) ) <EOL> r = getrandbits ( k ) <EOL> while r >= n : <EOL> r = getrandbits ( k ) <EOL> return r <EOL> if n >= _maxwidth : <EOL> _warn ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> return int ( self . random ( ) * n ) <EOL> def choice ( self , seq ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return seq [ int ( self . random ( ) * len ( seq ) ) ] <EOL> def shuffle ( self , x , random = None , int = int ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if random is None : <EOL> random = self . random <EOL> for i in reversed ( xrange ( <NUM_LIT:1> , len ( x ) ) ) : <EOL> j = int ( random ( ) * ( i + <NUM_LIT:1> ) ) <EOL> x [ i ] , x [ j ] = x [ j ] , x [ i ] <EOL> def sample ( self , population , k ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> n = len ( population ) <EOL> if not <NUM_LIT:0> <= k <= n : <EOL> raise ValueError , \"<STR_LIT>\" <EOL> random = self . random <EOL> _int = int <EOL> result = [ None ] * k <EOL> if n < <NUM_LIT:6> * k : <EOL> pool = list ( population ) <EOL> for i in xrange ( k ) : <EOL> j = _int ( random ( ) * ( n - i ) ) <EOL> result [ i ] = pool [ j ] <EOL> pool [ j ] = pool [ n - i - <NUM_LIT:1> ] <EOL> else : <EOL> try : <EOL> n > <NUM_LIT:0> and ( population [ <NUM_LIT:0> ] , population [ n // <NUM_LIT:2> ] , population [ n - <NUM_LIT:1> ] ) <EOL> except ( TypeError , KeyError ) : <EOL> population = tuple ( population ) <EOL> selected = { } <EOL> for i in xrange ( k ) : <EOL> j = _int ( random ( ) * n ) <EOL> while j in selected : <EOL> j = _int ( random ( ) * n ) <EOL> result [ i ] = selected [ j ] = population [ j ] <EOL> return result <EOL> def uniform ( self , a , b ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return a + ( b - a ) * self . random ( ) <EOL> def normalvariate ( self , mu , sigma ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> random = self . random <EOL> while <NUM_LIT:1> : <EOL> u1 = random ( ) <EOL> u2 = <NUM_LIT:1.0> - random ( ) <EOL> z = NV_MAGICCONST * ( u1 - <NUM_LIT:0.5> ) / u2 <EOL> zz = z * z / <NUM_LIT> <EOL> if zz <= - _log ( u2 ) : <EOL> break <EOL> return mu + z * sigma <EOL> def lognormvariate ( self , mu , sigma ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return _exp ( self . normalvariate ( mu , sigma ) ) <EOL> def expovariate ( self , lambd ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> random = self . random <EOL> u = random ( ) <EOL> while u <= <NUM_LIT> : <EOL> u = random ( ) <EOL> return - _log ( u ) / lambd <EOL> def vonmisesvariate ( self , mu , kappa ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> random = self . random <EOL> if kappa <= <NUM_LIT> : <EOL> return TWOPI * random ( ) <EOL> a = <NUM_LIT:1.0> + _sqrt ( <NUM_LIT:1.0> + <NUM_LIT> * kappa * kappa ) <EOL> b = ( a - _sqrt ( <NUM_LIT> * a ) ) / ( <NUM_LIT> * kappa ) <EOL> r = ( <NUM_LIT:1.0> + b * b ) / ( <NUM_LIT> * b ) <EOL> while <NUM_LIT:1> : <EOL> u1 = random ( ) <EOL> z = _cos ( _pi * u1 ) <EOL> f = ( <NUM_LIT:1.0> + r * z ) / ( r + z ) <EOL> c = kappa * ( r - f ) <EOL> u2 = random ( ) <EOL> if u2 < c * ( <NUM_LIT> - c ) or u2 <= c * _exp ( <NUM_LIT:1.0> - c ) : <EOL> break <EOL> u3 = random ( ) <EOL> if u3 > <NUM_LIT:0.5> : <EOL> theta = ( mu % TWOPI ) + _acos ( f ) <EOL> else : <EOL> theta = ( mu % TWOPI ) - _acos ( f ) <EOL> return theta <EOL> def gammavariate ( self , alpha , beta ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if alpha <= <NUM_LIT:0.0> or beta <= <NUM_LIT:0.0> : <EOL> raise ValueError , '<STR_LIT>' <EOL> random = self . random <EOL> if alpha > <NUM_LIT:1.0> : <EOL> ainv = _sqrt ( <NUM_LIT> * alpha - <NUM_LIT:1.0> ) <EOL> bbb = alpha - LOG4 <EOL> ccc = alpha + ainv <EOL> while <NUM_LIT:1> : <EOL> u1 = random ( ) <EOL> if not <NUM_LIT> < u1 < <NUM_LIT> : <EOL> continue <EOL> u2 = <NUM_LIT:1.0> - random ( ) <EOL> v = _log ( u1 / ( <NUM_LIT:1.0> - u1 ) ) / ainv <EOL> x = alpha * _exp ( v ) <EOL> z = u1 * u1 * u2 <EOL> r = bbb + ccc * v - x <EOL> if r + SG_MAGICCONST - <NUM_LIT> * z >= <NUM_LIT:0.0> or r >= _log ( z ) : <EOL> return x * beta <EOL> elif alpha == <NUM_LIT:1.0> : <EOL> u = random ( ) <EOL> while u <= <NUM_LIT> : <EOL> u = random ( ) <EOL> return - _log ( u ) * beta <EOL> else : <EOL> while <NUM_LIT:1> : <EOL> u = random ( ) <EOL> b = ( _e + alpha ) / _e <EOL> p = b * u <EOL> if p <= <NUM_LIT:1.0> : <EOL> x = p ** ( <NUM_LIT:1.0> / alpha ) <EOL> else : <EOL> x = - _log ( ( b - p ) / alpha ) <EOL> u1 = random ( ) <EOL> if p > <NUM_LIT:1.0> : <EOL> if u1 <= x ** ( alpha - <NUM_LIT:1.0> ) : <EOL> break <EOL> elif u1 <= _exp ( - x ) : <EOL> break <EOL> return x * beta <EOL> def gauss ( self , mu , sigma ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> random = self . random <EOL> z = self . gauss_next <EOL> self . gauss_next = None <EOL> if z is None : <EOL> x2pi = random ( ) * TWOPI <EOL> g2rad = _sqrt ( - <NUM_LIT> * _log ( <NUM_LIT:1.0> - random ( ) ) ) <EOL> z = _cos ( x2pi ) * g2rad <EOL> self . gauss_next = _sin ( x2pi ) * g2rad <EOL> return mu + z * sigma <EOL> def betavariate ( self , alpha , beta ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> y = self . gammavariate ( alpha , <NUM_LIT:1.> ) <EOL> if y == <NUM_LIT:0> : <EOL> return <NUM_LIT:0.0> <EOL> else : <EOL> return y / ( y + self . gammavariate ( beta , <NUM_LIT:1.> ) ) <EOL> def paretovariate ( self , alpha ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> u = <NUM_LIT:1.0> - self . random ( ) <EOL> return <NUM_LIT:1.0> / pow ( u , <NUM_LIT:1.0> / alpha ) <EOL> def weibullvariate ( self , alpha , beta ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> u = <NUM_LIT:1.0> - self . random ( ) <EOL> return alpha * pow ( - _log ( u ) , <NUM_LIT:1.0> / beta ) <EOL> class WichmannHill ( Random ) : <EOL> VERSION = <NUM_LIT:1> <EOL> def seed ( self , a = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if a is None : <EOL> try : <EOL> a = long ( _hexlify ( _urandom ( <NUM_LIT:16> ) ) , <NUM_LIT:16> ) <EOL> except NotImplementedError : <EOL> import time <EOL> a = long ( time . time ( ) * <NUM_LIT> ) <EOL> if not isinstance ( a , ( int , long ) ) : <EOL> a = hash ( a ) <EOL> a , x = divmod ( a , <NUM_LIT> ) <EOL> a , y = divmod ( a , <NUM_LIT> ) <EOL> a , z = divmod ( a , <NUM_LIT> ) <EOL> self . _seed = int ( x ) + <NUM_LIT:1> , int ( y ) + <NUM_LIT:1> , int ( z ) + <NUM_LIT:1> <EOL> self . gauss_next = None <EOL> def random ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> x , y , z = self . _seed <EOL> x = ( <NUM_LIT> * x ) % <NUM_LIT> <EOL> y = ( <NUM_LIT> * y ) % <NUM_LIT> <EOL> z = ( <NUM_LIT> * z ) % <NUM_LIT> <EOL> self . _seed = x , y , z <EOL> return ( x / <NUM_LIT> + y / <NUM_LIT> + z / <NUM_LIT> ) % <NUM_LIT:1.0> <EOL> def getstate ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . VERSION , self . _seed , self . gauss_next <EOL> def setstate ( self , state ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> version = state [ <NUM_LIT:0> ] <EOL> if version == <NUM_LIT:1> : <EOL> version , self . _seed , self . gauss_next = state <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % <EOL> ( version , self . VERSION ) ) <EOL> def jumpahead ( self , n ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not n >= <NUM_LIT:0> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> x , y , z = self . _seed <EOL> x = int ( x * pow ( <NUM_LIT> , n , <NUM_LIT> ) ) % <NUM_LIT> <EOL> y = int ( y * pow ( <NUM_LIT> , n , <NUM_LIT> ) ) % <NUM_LIT> <EOL>", "answer": "z = int ( z * pow ( <NUM_LIT> , n , <NUM_LIT> ) ) % <NUM_LIT>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from . settings_base import * <EOL> INSTALLED_APPS += [ \"<STR_LIT>\" ] <EOL> VERSATILEIMAGEFIELD_SETTINGS = { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL>", "answer": "'<STR_LIT>' : '<STR_LIT>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT>''' <EOL> import optparse <EOL> import csv <EOL> import os <EOL> import pyvision as pv <EOL> from pyvision . face . CascadeDetector import CascadeDetector <EOL> from pyvision . face . FilterEyeLocator import FilterEyeLocator <EOL> import PIL <EOL> import random <EOL> EXTENSIONS = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> def parseOptions ( ) : <EOL> usage = \"<STR_LIT>\" <EOL> parser = optparse . OptionParser ( usage ) <EOL> parser . add_option ( \"<STR_LIT>\" , dest = \"<STR_LIT>\" , default = False , <EOL> action = \"<STR_LIT:store_true>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> parser . add_option ( \"<STR_LIT>\" , dest = \"<STR_LIT>\" , default = <NUM_LIT:1.0> , type = '<STR_LIT:float>' , <EOL> help = \"<STR_LIT>\" ) <EOL> parser . add_option ( \"<STR_LIT>\" , dest = \"<STR_LIT>\" , default = None , <EOL> help = \"<STR_LIT>\" ) <EOL> parser . add_option ( \"<STR_LIT>\" , dest = \"<STR_LIT>\" , default = None , <EOL> help = \"<STR_LIT>\" ) <EOL> parser . add_option ( \"<STR_LIT>\" , dest = \"<STR_LIT>\" , default = <NUM_LIT:1.0> , type = '<STR_LIT:float>' , <EOL> help = \"<STR_LIT>\" ) <EOL> parser . add_option ( \"<STR_LIT>\" , dest = \"<STR_LIT>\" , default = None , type = '<STR_LIT:int>' , <EOL> help = \"<STR_LIT>\" ) <EOL> parser . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> action = \"<STR_LIT:store_true>\" , dest = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> ( options , args ) = parser . parse_args ( ) <EOL> if len ( args ) != <NUM_LIT:2> : <EOL> parser . error ( \"<STR_LIT>\" ) <EOL> return options , args <EOL> def processFaces ( im , face_detect , locate_eyes ) : <EOL> faces = face_detect ( im ) <EOL> return locate_eyes ( im , faces ) <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL> options , args = parseOptions ( ) <EOL> image_names = [ ] <EOL> for dirpath , dirnames , filenames in os . walk ( args [ <NUM_LIT:0> ] ) : <EOL> for filename in filenames : <EOL> extension = filename . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] <EOL> extension = extension . upper ( ) <EOL> if ( options . extension == None and extension in EXTENSIONS ) or ( options . extension != None and options . extension . upper ( ) == extension ) : <EOL> pathname = os . path . join ( dirpath , filename ) <EOL> image_names . append ( pathname ) <EOL> if options . sample != None : <EOL> image_names = random . sample ( image_names , options . sample ) <EOL> f = open ( args [ <NUM_LIT:1> ] , '<STR_LIT:wb>' ) <EOL> csv_file = csv . writer ( f ) <EOL> headers = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> csv_file . writerow ( headers ) <EOL> ilog = None <EOL> if options . log_dir != None : <EOL> print \"<STR_LIT>\" <EOL> ilog = pv . ImageLog ( options . log_dir ) <EOL> face_detect = CascadeDetector ( image_scale = <NUM_LIT> * options . scale ) <EOL> locate_eyes = FilterEyeLocator ( ) <EOL> c = <NUM_LIT:0> <EOL> for pathname in image_names : <EOL> c += <NUM_LIT:1> <EOL> im = pv . Image ( pathname ) <EOL> scale = options . log_scale <EOL> log_im = pv . AffineScale ( scale , ( int ( scale * im . width ) , int ( scale * im . height ) ) ) . transformImage ( im ) <EOL> results = processFaces ( im , face_detect , locate_eyes ) <EOL> if options . rotate : <EOL> rot_image = pv . Image ( im . asPIL ( ) . transpose ( PIL . Image . ROTATE_90 ) ) <EOL> more_results = processFaces ( rot_image , face_detect , locate_eyes ) <EOL> for face , eye1 , eye2 in more_results : <EOL> results . append ( [ pv . Rect ( im . width - face . y - face . h , face . x , face . h , face . w ) , <EOL> pv . Point ( im . width - eye1 . Y ( ) , eye1 . X ( ) ) , <EOL> pv . Point ( im . width - eye2 . Y ( ) , eye2 . X ( ) ) ] ) <EOL> rot_image = pv . Image ( im . asPIL ( ) . transpose ( PIL . Image . ROTATE_180 ) ) <EOL>", "answer": "more_results = processFaces ( rot_image , face_detect , locate_eyes )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys <EOL> sys . path . insert ( <NUM_LIT:0> , '<STR_LIT>' ) <EOL> from pycparser import c_parser , c_ast , parse_file <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL>", "answer": "parser = c_parser . CParser ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys <EOL>", "answer": "from django . core . management . base import BaseCommand"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT>''' <EOL> from pprint import pformat <EOL> import copy <EOL> import cProfile <EOL> import crypt <EOL> import collections <EOL> import datetime <EOL> import hashlib <EOL> import logging <EOL> import os <EOL> import pstats <EOL> import re <EOL> from salt . config import master_config , minion_config <EOL> from salt . exceptions import SaltException <EOL> import salt . utils <EOL> import salt . utils . dictupdate <EOL> import salt . utils . network <EOL> from salt . utils . pycrypto import secure_password <EOL> from salt . utils . odict import OrderedDict <EOL> import salt . loader <EOL> from salt . ext import six as six <EOL> from mc_states import api <EOL> import mc_states . api <EOL> _CACHE = { '<STR_LIT>' : None } <EOL> _default_marker = object ( ) <EOL> _marker = object ( ) <EOL> log = logging . getLogger ( __name__ ) <EOL> def hash ( string , typ = '<STR_LIT>' , func = '<STR_LIT>' ) : <EOL> '''<STR_LIT>''' <EOL> if func not in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> func = '<STR_LIT>' <EOL> if typ not in [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' <EOL> ] : <EOL> raise TypeError ( '<STR_LIT>' . format ( typ ) ) <EOL> return getattr ( getattr ( hashlib , typ ) ( string ) , func ) ( ) <EOL> def uniquify ( * a , ** kw ) : <EOL> return api . uniquify ( * a , ** kw ) <EOL> def odict ( instance = True ) : <EOL> if instance : <EOL> return OrderedDict ( ) <EOL> return OrderedDict <EOL> def local_minion_id ( force = False ) : <EOL> '''<STR_LIT>''' <EOL> mid = _CACHE [ '<STR_LIT>' ] <EOL> if mid and not force : <EOL> return mid <EOL> paths = api . uniquify ( [ <EOL> __opts__ [ '<STR_LIT>' ] , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> for path in paths : <EOL> for cfgn , fun in OrderedDict ( <EOL> [ ( '<STR_LIT>' , master_config ) , <EOL> ( '<STR_LIT>' , minion_config ) ] <EOL> ) . items ( ) : <EOL> cfg = os . path . join ( path , cfgn ) <EOL> if os . path . exists ( cfg ) : <EOL> try : <EOL> cfgo = fun ( cfg ) <EOL> mid = cfgo . get ( '<STR_LIT:id>' , None ) <EOL> if mid . endswith ( '<STR_LIT>' ) : <EOL> mid = None <EOL> except Exception : <EOL> pass <EOL> if mid : <EOL>", "answer": "break"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sublime , sublime_plugin <EOL> class IncreaseFontSizeCommand ( sublime_plugin . ApplicationCommand ) : <EOL> def run ( self ) : <EOL> s = sublime . load_settings ( \"<STR_LIT>\" ) <EOL> current = s . get ( \"<STR_LIT>\" , <NUM_LIT:10> ) <EOL> if current >= <NUM_LIT> : <EOL> current += <NUM_LIT:4> <EOL> elif current >= <NUM_LIT> : <EOL> current += <NUM_LIT:2> <EOL> else : <EOL> current += <NUM_LIT:1> <EOL>", "answer": "if current > <NUM_LIT> :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL> from traits . testing . unittest_tools import unittest <EOL> from . . api import HasTraits , Instance , Str , Any , Property <EOL> class Foo ( HasTraits ) : <EOL> s = Str <EOL> class ClassWithAny ( HasTraits ) : <EOL> x = Property <EOL> _x = Any <EOL> def _get_x ( self ) : <EOL> return self . _x <EOL> def _set_x ( self , x ) : <EOL> self . _x = x <EOL> class ClassWithInstance ( HasTraits ) : <EOL> x = Property <EOL> _x = Instance ( Foo ) <EOL> def _get_x ( self ) : <EOL> return self . _x <EOL> def _set_x ( self , x ) : <EOL> self . _x = x <EOL> class ClassWithClassAttribute ( HasTraits ) : <EOL> name = '<STR_LIT>' <EOL> foo = Str <EOL> class BazAny ( HasTraits ) : <EOL> other = Any <EOL> class BarAny ( HasTraits ) : <EOL>", "answer": "other = Any"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . core . management . base import BaseCommand <EOL> from django . utils import autoreload <EOL> import os <EOL> import sys <EOL> import time <EOL> INPROGRESS_FILE = '<STR_LIT>' <EOL> def get_test_command ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from test_extensions . management . commands . test import Command as TestCommand <EOL> return TestCommand ( ) <EOL> def my_reloader_thread ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> while autoreload . RUN_RELOADER : <EOL> if autoreload . code_changed ( ) : <EOL> while os . path . exists ( INPROGRESS_FILE ) : <EOL> time . sleep ( <NUM_LIT:1> ) <EOL> sys . exit ( <NUM_LIT:3> ) <EOL> time . sleep ( <NUM_LIT:1> ) <EOL> autoreload . reloader_thread = my_reloader_thread <EOL> class Command ( BaseCommand ) : <EOL> option_list = BaseCommand . option_list <EOL> help = \"<STR_LIT>\" <EOL> args = '<STR_LIT>' <EOL> requires_model_validation = False <EOL> def handle ( self , * args , ** options ) : <EOL> if os . path . exists ( INPROGRESS_FILE ) : <EOL> os . remove ( INPROGRESS_FILE ) <EOL> def inner_run ( ) : <EOL> try : <EOL> open ( INPROGRESS_FILE , '<STR_LIT:wb>' ) . close ( ) <EOL> test_command = get_test_command ( ) <EOL> test_command . handle ( * args , ** options ) <EOL>", "answer": "finally :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from setuptools import setup , find_packages <EOL> try : <EOL> import multiprocessing <EOL> except ImportError : <EOL>", "answer": "pass"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from venusian . tests . fixtures import categorydecorator <EOL> from venusian . tests . fixtures import categorydecorator2 <EOL> @ categorydecorator ( function = True ) <EOL> def function ( request ) : <EOL> return request <EOL>", "answer": "@ categorydecorator2 ( function = True )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . utils . translation import ugettext_lazy as _ <EOL> import horizon <EOL>", "answer": "class ResourceTypes ( horizon . Panel ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import encoder <EOL> import optimizer <EOL> import unittest <EOL> import test_tools <EOL> import vp8_mpeg <EOL> class TestVp8Mpeg ( test_tools . FileUsingCodecTest ) : <EOL> def test_OneBlackFrame ( self ) : <EOL> codec = vp8_mpeg . Vp8CodecMpegMode ( ) <EOL> my_optimizer = optimizer . Optimizer ( codec ) <EOL> videofile = test_tools . MakeYuvFileWithOneBlankFrame ( <EOL> '<STR_LIT>' ) <EOL> encoding = my_optimizer . BestEncoding ( <NUM_LIT:1000> , videofile ) <EOL> encoding . Execute ( ) <EOL> self . assertLess ( <NUM_LIT> , my_optimizer . Score ( encoding ) ) <EOL> def test_ConfigurationFixups ( self ) : <EOL> codec = vp8_mpeg . Vp8CodecMpegMode ( ) <EOL> fixups = codec . ConfigurationFixups ( <EOL> encoder . OptionValueSet ( codec . option_set , <EOL> '<STR_LIT>' ) ) <EOL> self . assertEqual ( '<STR_LIT>' , fixups . ToString ( ) ) <EOL> def test_SuggestedTweakRefersToSameContext ( self ) : <EOL> codec = vp8_mpeg . Vp8CodecMpegMode ( ) <EOL> my_optimizer = optimizer . Optimizer ( codec ) <EOL> videofile = test_tools . MakeYuvFileWithOneBlankFrame ( <EOL> '<STR_LIT>' ) <EOL> encoding = my_optimizer . BestEncoding ( <NUM_LIT:1000> , videofile ) <EOL> encoding . result = { '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT:1000> } <EOL>", "answer": "next_encoding = codec . SuggestTweak ( encoding )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import pprint <EOL> import operator <EOL> import random <EOL> import md5 <EOL> import datetime <EOL> import chimpy <EOL> chimp = None <EOL> EMAIL_ADDRESS = '<STR_LIT>' <EOL> EMAIL_ADDRESS2 = '<STR_LIT>' <EOL> LIST_NAME = '<STR_LIT>' <EOL> LIST_ID = None <EOL> def setup_module ( ) : <EOL> assert '<STR_LIT>' in os . environ , \"<STR_LIT>\" \"<STR_LIT>\" \"<STR_LIT>\" \"<STR_LIT>\" <EOL> global chimp <EOL> chimp = chimpy . Connection ( os . environ [ '<STR_LIT>' ] ) <EOL> def test_ping ( ) : <EOL> assert chimp . ping ( ) == \"<STR_LIT>\" <EOL> def test_lists ( ) : <EOL> lists = chimp . lists ( ) <EOL> pprint . pprint ( lists ) <EOL> list_names = map ( lambda x : x [ '<STR_LIT:name>' ] , lists ) <EOL> assert LIST_NAME in list_names <EOL> def list_id ( ) : <EOL> global LIST_ID <EOL> if LIST_ID is None : <EOL> test_list = [ x for x in chimp . lists ( ) if x [ '<STR_LIT:name>' ] == LIST_NAME ] . pop ( ) <EOL> LIST_ID = test_list [ '<STR_LIT:id>' ] <EOL> return LIST_ID <EOL> def test_list_subscribe_and_unsubscribe ( ) : <EOL> result = chimp . list_subscribe ( list_id ( ) , EMAIL_ADDRESS , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } , <EOL> double_optin = False ) <EOL> pprint . pprint ( result ) <EOL> assert result == True <EOL> members = chimp . list_members ( list_id ( ) ) [ '<STR_LIT:data>' ] <EOL> print members <EOL> emails = map ( lambda x : x [ '<STR_LIT:email>' ] , members ) <EOL> print members <EOL> assert EMAIL_ADDRESS in emails <EOL> result = chimp . list_unsubscribe ( list_id ( ) , <EOL> EMAIL_ADDRESS , <EOL> delete_member = True , <EOL> send_goodbye = False , <EOL> send_notify = False ) <EOL> pprint . pprint ( result ) <EOL> assert result == True <EOL> def test_list_batch_subscribe_and_batch_unsubscribe ( ) : <EOL> batch = [ { '<STR_LIT>' : EMAIL_ADDRESS , '<STR_LIT>' : '<STR_LIT:html>' } , <EOL> { '<STR_LIT>' : EMAIL_ADDRESS2 , '<STR_LIT>' : '<STR_LIT:text>' } ] <EOL> result = chimp . list_batch_subscribe ( list_id ( ) , <EOL> batch , <EOL> double_optin = False , <EOL> update_existing = False , <EOL> replace_interests = False ) <EOL> assert result [ '<STR_LIT>' ] == <NUM_LIT:2> <EOL> members = chimp . list_members ( list_id ( ) ) [ '<STR_LIT:data>' ] <EOL> emails = map ( lambda x : x [ '<STR_LIT:email>' ] , members ) <EOL> assert EMAIL_ADDRESS in emails <EOL> assert EMAIL_ADDRESS2 in emails <EOL> result = chimp . list_batch_unsubscribe ( list_id ( ) , <EOL> [ EMAIL_ADDRESS , EMAIL_ADDRESS2 ] , <EOL> delete_member = True , <EOL> send_goodbye = False , <EOL> send_notify = False ) <EOL> assert result [ '<STR_LIT>' ] == <NUM_LIT:2> <EOL> def test_list_interest_groups_add_and_delete ( ) : <EOL> grouping_id = chimp . list_interest_groupings_add ( list_id ( ) , '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> assert len ( chimp . list_interest_groups ( list_id ( ) , grouping_id ) [ '<STR_LIT>' ] ) == <NUM_LIT:1> <EOL> assert chimp . list_interest_group_add ( list_id ( ) , '<STR_LIT:test>' , grouping_id ) <EOL> assert len ( chimp . list_interest_groups ( list_id ( ) , grouping_id ) [ '<STR_LIT>' ] ) == <NUM_LIT:2> <EOL> assert chimp . list_interest_group_del ( list_id ( ) , '<STR_LIT:test>' , grouping_id ) <EOL> assert len ( chimp . list_interest_groups ( list_id ( ) , grouping_id ) [ '<STR_LIT>' ] ) == <NUM_LIT:1> <EOL> assert ( chimp . list_interest_groupings_del ( grouping_id ) ) <EOL> def test_list_merge_vars_add_and_delete ( ) : <EOL> pprint . pprint ( chimp . list_merge_vars ( list_id ( ) ) ) <EOL> assert len ( chimp . list_merge_vars ( list_id ( ) ) ) == <NUM_LIT:3> <EOL> assert chimp . list_merge_var_add ( list_id ( ) , '<STR_LIT:test>' , '<STR_LIT>' ) <EOL> assert len ( chimp . list_merge_vars ( list_id ( ) ) ) == <NUM_LIT:4> <EOL> assert chimp . list_merge_var_del ( list_id ( ) , '<STR_LIT:test>' ) <EOL> assert len ( chimp . list_merge_vars ( list_id ( ) ) ) == <NUM_LIT:3> <EOL> def test_list_update_member_and_member_info ( ) : <EOL> assert chimp . list_subscribe ( list_id ( ) , EMAIL_ADDRESS , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } , <EOL> double_optin = False ) <EOL> assert chimp . list_merge_var_add ( list_id ( ) , '<STR_LIT>' , '<STR_LIT>' ) <EOL> grouping_id = chimp . list_interest_groupings_add ( list_id ( ) , '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> assert chimp . list_update_member ( list_id ( ) , EMAIL_ADDRESS , <EOL> { '<STR_LIT>' : '<STR_LIT:abc>' , <EOL> '<STR_LIT>' : '<STR_LIT>' } , replace_interests = False ) <EOL> info = chimp . list_member_info ( list_id ( ) , EMAIL_ADDRESS ) <EOL> pprint . pprint ( info ) <EOL> assert chimp . list_merge_var_del ( list_id ( ) , '<STR_LIT>' ) <EOL> assert chimp . list_interest_group_del ( list_id ( ) , '<STR_LIT>' , grouping_id ) <EOL> assert chimp . list_interest_groupings_del ( grouping_id ) <EOL> assert chimp . list_unsubscribe ( list_id ( ) , EMAIL_ADDRESS , <EOL> delete_member = True , <EOL> send_goodbye = False , <EOL> send_notify = False ) <EOL> assert '<STR_LIT>' in info [ '<STR_LIT>' ] <EOL> assert info [ '<STR_LIT>' ] [ '<STR_LIT>' ] == '<STR_LIT:abc>' <EOL> def test_create_delete_campaign ( ) : <EOL> uid = md5 . new ( str ( random . random ( ) ) ) . hexdigest ( ) <EOL> subject = '<STR_LIT>' % uid <EOL> options = { '<STR_LIT>' : list_id ( ) , <EOL> '<STR_LIT>' : subject , <EOL> '<STR_LIT>' : EMAIL_ADDRESS , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : True <EOL> } <EOL> segment_opts = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ { '<STR_LIT>' : '<STR_LIT:date>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } , <EOL> { '<STR_LIT>' : '<STR_LIT:email>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT:@>' } ] } <EOL> html = \"\"\"<STR_LIT>\"\"\" <EOL> content = { '<STR_LIT:html>' : html } <EOL> cid = chimp . campaign_create ( '<STR_LIT>' , options , content , segment_opts = segment_opts ) <EOL> assert isinstance ( cid , basestring ) <EOL> campaigns = chimp . campaigns ( filter_subject = subject ) <EOL> assert len ( campaigns [ '<STR_LIT:data>' ] ) == <NUM_LIT:1> <EOL> assert campaigns [ '<STR_LIT:data>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:id>' ] == cid <EOL> final_content = chimp . campaign_content ( cid ) <EOL> assert '<STR_LIT>' in final_content [ '<STR_LIT:html>' ] <EOL> assert '<STR_LIT>' in final_content [ '<STR_LIT:text>' ] <EOL> chimp . campaign_delete ( cid ) <EOL> def test_replicate_update_campaign ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> uid = md5 . new ( str ( random . random ( ) ) ) . hexdigest ( ) <EOL> subject = '<STR_LIT>' % uid <EOL> options = { '<STR_LIT>' : list_id ( ) , <EOL> '<STR_LIT>' : subject , <EOL> '<STR_LIT>' : EMAIL_ADDRESS , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : True <EOL> } <EOL> html = \"\"\"<STR_LIT>\"\"\" <EOL> content = { '<STR_LIT:html>' : html } <EOL> cid = chimp . campaign_create ( '<STR_LIT>' , options , content ) <EOL> newcid = chimp . campaign_replicate ( cid = cid ) <EOL> assert isinstance ( newcid , basestring ) <EOL> newsubject = '<STR_LIT>' + uid <EOL> newtitle = '<STR_LIT>' + uid <EOL> res = chimp . campaign_update ( newcid , '<STR_LIT>' , newsubject ) <EOL> assert res is True <EOL> res = chimp . campaign_update ( newcid , '<STR_LIT:title>' , newtitle ) <EOL> assert res is True <EOL> chimp . campaign_delete ( newcid ) <EOL> chimp . campaign_delete ( cid ) <EOL> def test_schedule_campaign ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> uid = md5 . new ( str ( random . random ( ) ) ) . hexdigest ( ) <EOL> subject = '<STR_LIT>' % uid <EOL> options = { '<STR_LIT>' : list_id ( ) , <EOL> '<STR_LIT>' : subject , <EOL> '<STR_LIT>' : EMAIL_ADDRESS , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : True <EOL> } <EOL>", "answer": "html = \"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT>''' <EOL> import os , cgi , __main__ <EOL> from google . appengine . ext . webapp import template <EOL> import wsgiref . handlers <EOL> from google . appengine . ext import webapp <EOL> from google . appengine . api import memcache <EOL> from google . appengine . ext import db <EOL> from appengine_utilities import cron <EOL> class MainPage ( webapp . RequestHandler ) : <EOL> def get ( self ) : <EOL> c = cron . Cron ( ) <EOL> query = cron . _AppEngineUtilities_Cron . all ( ) <EOL> results = query . fetch ( <NUM_LIT:1000> ) <EOL> template_values = { \"<STR_LIT>\" : results } <EOL> path = os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT>' ) <EOL> self . response . out . write ( template . render ( path , template_values ) ) <EOL> def post ( self ) : <EOL> if str ( self . request . get ( '<STR_LIT:action>' ) ) == '<STR_LIT>' : <EOL> cron . Cron ( ) . add_cron ( str ( self . request . get ( '<STR_LIT>' ) ) ) <EOL> elif str ( self . request . get ( '<STR_LIT:action>' ) ) == '<STR_LIT>' : <EOL> entry = db . get ( db . Key ( str ( self . request . get ( '<STR_LIT:key>' ) ) ) ) <EOL> entry . delete ( ) <EOL> query = cron . _AppEngineUtilities_Cron . all ( ) <EOL> results = query . fetch ( <NUM_LIT:1000> ) <EOL> template_values = { \"<STR_LIT>\" : results } <EOL> path = os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT>' ) <EOL> self . response . out . write ( template . render ( path , template_values ) ) <EOL> def main ( ) : <EOL> application = webapp . WSGIApplication ( <EOL>", "answer": "[ ( '<STR_LIT>' , MainPage ) ] ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from paver . easy import sh <EOL>", "answer": "def scp ( source , dest ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from ndscheduler import settings <EOL> from ndscheduler . core . datastore . providers import base <EOL> class DatastorePostgresql ( base . DatastoreBase ) : <EOL> @ classmethod <EOL> def get_db_url ( cls ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return '<STR_LIT>' % ( <EOL> settings . DATABASE_CONFIG_DICT [ '<STR_LIT:user>' ] , <EOL> settings . DATABASE_CONFIG_DICT [ '<STR_LIT:password>' ] , <EOL>", "answer": "settings . DATABASE_CONFIG_DICT [ '<STR_LIT>' ] ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> class ContextPlugin ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def preBuild ( self , site ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . context = site . config . get ( \"<STR_LIT>\" , { } , nested = True ) <EOL>", "answer": "def preBuildPage ( self , page , context , data ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function , unicode_literals <EOL> import os <EOL> import json <EOL> import time <EOL> from datetime import datetime , timedelta <EOL> from copy import deepcopy <EOL> from flexmock import flexmock <EOL> from osbs . api import OSBS <EOL> import osbs . conf <EOL> from atomic_reactor . inner import DockerBuildWorkflow <EOL> from atomic_reactor . plugin import ExitPluginsRunner <EOL> from atomic_reactor . plugins . post_rpmqa import PostBuildRPMqaPlugin <EOL> from atomic_reactor . plugins . exit_store_metadata_in_osv3 import StoreMetadataInOSv3Plugin <EOL> from atomic_reactor . plugins . exit_koji_promote import KojiPromotePlugin <EOL> from atomic_reactor . plugins . pre_cp_dockerfile import CpDockerfilePlugin <EOL> from atomic_reactor . plugins . pre_pyrpkg_fetch_artefacts import DistgitFetchArtefactsPlugin <EOL> from atomic_reactor . util import ImageName , LazyGit <EOL> import pytest <EOL> from tests . constants import LOCALHOST_REGISTRY , DOCKER0_REGISTRY , TEST_IMAGE , INPUT_IMAGE <EOL> from tests . util import is_string_type <EOL> DIGEST1 = \"<STR_LIT>\" <EOL> DIGEST2 = \"<STR_LIT>\" <EOL> class Y ( object ) : <EOL> pass <EOL> class X ( object ) : <EOL> image_id = INPUT_IMAGE <EOL> source = Y ( ) <EOL> source . dockerfile_path = None <EOL> source . path = None <EOL> base_image = ImageName ( repo = \"<STR_LIT>\" , tag = \"<STR_LIT>\" ) <EOL> def prepare ( ) : <EOL> def set_annotations_on_build ( build_id , labels ) : <EOL> pass <EOL> def update_labels_on_build ( build_id , labels ) : <EOL> pass <EOL> new_environ = deepcopy ( os . environ ) <EOL> new_environ [ \"<STR_LIT>\" ] = '''<STR_LIT>''' <EOL> flexmock ( OSBS , set_annotations_on_build = set_annotations_on_build ) <EOL> flexmock ( OSBS , update_labels_on_build = update_labels_on_build ) <EOL> ( flexmock ( osbs . conf ) <EOL> . should_call ( \"<STR_LIT>\" ) <EOL> . with_args ( namespace = \"<STR_LIT>\" , conf_file = None , verify_ssl = True , <EOL> openshift_url = \"<STR_LIT>\" , openshift_uri = \"<STR_LIT>\" , <EOL> use_auth = True ) ) <EOL> flexmock ( os ) <EOL> os . should_receive ( \"<STR_LIT>\" ) . and_return ( new_environ ) <EOL> workflow = DockerBuildWorkflow ( { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } , \"<STR_LIT>\" ) <EOL> workflow . push_conf . add_pulp_registry ( \"<STR_LIT:test>\" , LOCALHOST_REGISTRY ) <EOL> workflow . tag_conf . add_primary_image ( TEST_IMAGE ) <EOL> workflow . tag_conf . add_unique_image ( \"<STR_LIT>\" ) <EOL> r = workflow . push_conf . add_docker_registry ( DOCKER0_REGISTRY ) <EOL> r . digests [ TEST_IMAGE ] = DIGEST1 <EOL> r . digests [ \"<STR_LIT>\" ] = DIGEST2 <EOL> setattr ( workflow , '<STR_LIT>' , X ) <EOL> setattr ( workflow , '<STR_LIT>' , { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> workflow . build_logs = [ <EOL> \"<STR_LIT:a>\" , \"<STR_LIT:b>\" , <EOL> ] <EOL> workflow . source . lg = LazyGit ( None , commit = \"<STR_LIT>\" ) <EOL>", "answer": "flexmock ( workflow . source . lg )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from py2neo import Node , Path , Relationship , Graph , order , size <EOL> from test . util import GraphTestCase <EOL> class PathTestCase ( GraphTestCase ) : <EOL> def test_can_construct_simple_path ( self ) : <EOL> alice = Node ( name = \"<STR_LIT>\" ) <EOL> bob = Node ( name = \"<STR_LIT>\" ) <EOL> path = Path ( alice , \"<STR_LIT>\" , bob ) <EOL> assert order ( path ) == <NUM_LIT:2> <EOL> assert size ( path ) == <NUM_LIT:1> <EOL> assert len ( path ) == <NUM_LIT:1> <EOL> def test_can_construct_path_with_none_node ( self ) : <EOL> alice = Node ( name = \"<STR_LIT>\" ) <EOL> path = Path ( alice , \"<STR_LIT>\" , None ) <EOL> assert order ( path ) == <NUM_LIT:2> <EOL> assert size ( path ) == <NUM_LIT:1> <EOL> assert len ( path ) == <NUM_LIT:1> <EOL> def test_can_create_path ( self ) : <EOL> path = Path ( { \"<STR_LIT:name>\" : \"<STR_LIT>\" } , \"<STR_LIT>\" , { \"<STR_LIT:name>\" : \"<STR_LIT>\" } ) <EOL> nodes = path . nodes ( ) <EOL> assert len ( path ) == <NUM_LIT:1> <EOL> assert nodes [ <NUM_LIT:0> ] [ \"<STR_LIT:name>\" ] == \"<STR_LIT>\" <EOL> assert path [ <NUM_LIT:0> ] . type ( ) == \"<STR_LIT>\" <EOL> assert nodes [ - <NUM_LIT:1> ] [ \"<STR_LIT:name>\" ] == \"<STR_LIT>\" <EOL> path = Path ( path , \"<STR_LIT>\" , { \"<STR_LIT:name>\" : \"<STR_LIT>\" } ) <EOL> nodes = path . nodes ( ) <EOL> assert len ( path ) == <NUM_LIT:2> <EOL> assert nodes [ <NUM_LIT:0> ] [ \"<STR_LIT:name>\" ] == \"<STR_LIT>\" <EOL> assert path [ <NUM_LIT:0> ] . type ( ) == \"<STR_LIT>\" <EOL> assert nodes [ <NUM_LIT:1> ] [ \"<STR_LIT:name>\" ] == \"<STR_LIT>\" <EOL> path = Path ( { \"<STR_LIT:name>\" : \"<STR_LIT>\" } , \"<STR_LIT>\" , path ) <EOL>", "answer": "nodes = path . nodes ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL> from datetime import datetime <EOL> try : <EOL> from urllib2 import quote <EOL> to_str = unicode <EOL> except ImportError : <EOL> from urllib . parse import quote <EOL> to_str = str <EOL> def parse_timestamp ( timestamp ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL> from django . conf . urls import patterns <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL> ( r'<STR_LIT>' , lambda r : None , { } , \"<STR_LIT>\" ) , <EOL> ( r'<STR_LIT>' , lambda r : None , { } , \"<STR_LIT>\" ) , <EOL>", "answer": ") "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> import unittest <EOL>", "answer": "import netCDF4"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from __future__ import division <EOL> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> import socket <EOL> import struct <EOL> import gnlpy . netlink as netlink <EOL> IPVS_MASQUERADING = <NUM_LIT:0> <EOL> IPVS_LOCAL = <NUM_LIT:1> <EOL> IPVS_TUNNELING = <NUM_LIT:2> <EOL> IPVS_ROUTING = <NUM_LIT:3> <EOL> IPVS_METHODS = set ( [ <EOL> IPVS_MASQUERADING , <EOL> IPVS_LOCAL , <EOL> IPVS_TUNNELING , <EOL> IPVS_ROUTING <EOL> ] ) <EOL> IpvsStatsAttrList = netlink . create_attr_list_type ( <EOL> '<STR_LIT>' , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U64Type ) , <EOL> ( '<STR_LIT>' , netlink . U64Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ) <EOL> IpvsStatsAttrList64 = netlink . create_attr_list_type ( <EOL> '<STR_LIT>' , <EOL> ( '<STR_LIT>' , netlink . U64Type ) , <EOL> ( '<STR_LIT>' , netlink . U64Type ) , <EOL> ( '<STR_LIT>' , netlink . U64Type ) , <EOL> ( '<STR_LIT>' , netlink . U64Type ) , <EOL> ( '<STR_LIT>' , netlink . U64Type ) , <EOL> ( '<STR_LIT>' , netlink . U64Type ) , <EOL> ( '<STR_LIT>' , netlink . U64Type ) , <EOL> ( '<STR_LIT>' , netlink . U64Type ) , <EOL> ( '<STR_LIT>' , netlink . U64Type ) , <EOL> ( '<STR_LIT>' , netlink . U64Type ) , <EOL> ) <EOL> IpvsServiceAttrList = netlink . create_attr_list_type ( <EOL> '<STR_LIT>' , <EOL> ( '<STR_LIT>' , netlink . U16Type ) , <EOL> ( '<STR_LIT>' , netlink . U16Type ) , <EOL> ( '<STR_LIT>' , netlink . BinaryType ) , <EOL> ( '<STR_LIT>' , netlink . Net16Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . NulStringType ) , <EOL> ( '<STR_LIT>' , netlink . BinaryType ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , IpvsStatsAttrList ) , <EOL> ( '<STR_LIT>' , netlink . NulStringType ) , <EOL> ( '<STR_LIT>' , IpvsStatsAttrList64 ) , <EOL> ) <EOL> IpvsDestAttrList = netlink . create_attr_list_type ( <EOL> '<STR_LIT>' , <EOL> ( '<STR_LIT>' , netlink . BinaryType ) , <EOL> ( '<STR_LIT>' , netlink . Net16Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . I32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , IpvsStatsAttrList ) , <EOL> ( '<STR_LIT>' , netlink . U16Type ) , <EOL> ( '<STR_LIT>' , IpvsStatsAttrList64 ) , <EOL> ) <EOL> IpvsDaemonAttrList = netlink . create_attr_list_type ( <EOL> '<STR_LIT>' , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . NulStringType ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ) <EOL> IpvsInfoAttrList = netlink . create_attr_list_type ( <EOL> '<STR_LIT>' , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ) <EOL> IpvsCmdAttrList = netlink . create_attr_list_type ( <EOL> '<STR_LIT>' , <EOL> ( '<STR_LIT>' , IpvsServiceAttrList ) , <EOL> ( '<STR_LIT>' , IpvsDestAttrList ) , <EOL> ( '<STR_LIT>' , IpvsDaemonAttrList ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ( '<STR_LIT>' , netlink . U32Type ) , <EOL> ) <EOL> IpvsMessage = netlink . create_genl_message_type ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> ( '<STR_LIT>' , IpvsCmdAttrList ) , <EOL> required_modules = [ '<STR_LIT>' ] , <EOL> ) <EOL> def verbose ( f ) : <EOL> def g ( self , * args , ** kwargs ) : <EOL> if self . verbose : <EOL> s_args = [ repr ( a ) for a in args ] <EOL> s_args . extend ( [ '<STR_LIT>' . format ( k , repr ( v ) ) <EOL> for k , v in kwargs . items ( ) ] ) <EOL> print ( '<STR_LIT>' . format ( f . __name__ , '<STR_LIT:U+002CU+0020>' . join ( s_args ) ) ) <EOL> return f ( self , * args , ** kwargs ) <EOL> return g <EOL> def _validate_ip ( ip ) : <EOL> try : <EOL> socket . inet_pton ( _to_af ( ip ) , ip ) <EOL> return True <EOL> except socket . error : <EOL> return False <EOL> def _to_af ( ip ) : <EOL> return socket . AF_INET6 if '<STR_LIT::>' in ip else socket . AF_INET <EOL> def _to_af_union ( ip ) : <EOL> af = _to_af ( ip ) <EOL> return af , socket . inet_pton ( af , ip ) . ljust ( <NUM_LIT:16> , str ( '<STR_LIT>' ) ) <EOL> def _from_af_union ( af , addr ) : <EOL> n = <NUM_LIT:4> if af == socket . AF_INET else <NUM_LIT:16> <EOL> return socket . inet_ntop ( af , addr [ : n ] ) <EOL> def _to_proto_num ( proto ) : <EOL> if proto is None : <EOL> return None <EOL> if proto . lower ( ) == '<STR_LIT>' : <EOL> return socket . IPPROTO_TCP <EOL> elif proto . lower ( ) == '<STR_LIT>' : <EOL> return socket . IPPROTO_UDP <EOL> else : <EOL> assert False , '<STR_LIT>' % proto <EOL> def _from_proto_num ( n ) : <EOL> if n is None : <EOL> return None <EOL> if n == socket . IPPROTO_TCP : <EOL> return '<STR_LIT>' <EOL> elif n == socket . IPPROTO_UDP : <EOL> return '<STR_LIT>' <EOL> else : <EOL> assert False , '<STR_LIT>' % n <EOL> class Dest ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , d = { } , validate = False ) : <EOL> self . ip_ = d . get ( '<STR_LIT>' , None ) <EOL> self . weight_ = d . get ( '<STR_LIT>' , None ) <EOL> self . port_ = d . get ( '<STR_LIT:port>' , None ) <EOL> self . fwd_method_ = d . get ( '<STR_LIT>' , IPVS_TUNNELING ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . ip ( ) , self . weight ( ) ) <EOL> def ip ( self ) : <EOL> return self . ip_ <EOL> def weight ( self ) : <EOL> return self . weight_ <EOL> def port ( self ) : <EOL> return self . port_ <EOL> def fwd_method ( self ) : <EOL> return self . fwd_method_ <EOL> def validate ( self ) : <EOL> assert _validate_ip ( self . ip_ ) <EOL> assert isinstance ( self . weight_ , int ) <EOL> assert self . weight_ >= - <NUM_LIT:1> <EOL> assert self . fwd_method_ in IPVS_METHODS <EOL> def to_dict ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . ip_ , <EOL> '<STR_LIT>' : self . weight_ , <EOL> } <EOL> def to_attr_list ( self ) : <EOL> af , addr = _to_af_union ( self . ip_ ) <EOL> return IpvsDestAttrList ( addr_family = af , <EOL> addr = addr , <EOL> port = self . port_ , <EOL> fwd_method = self . fwd_method_ ) <EOL> def __eq__ ( self , other ) : <EOL> return isinstance ( other , Dest ) and self . to_dict ( ) == other . to_dict ( ) <EOL> def __ne__ ( self , other ) : <EOL> return not self . __eq__ ( other ) <EOL> @ staticmethod <EOL> def from_attr_list ( lst , default_af = None ) : <EOL> return Dest ( <EOL> d = { <EOL> '<STR_LIT>' : _from_af_union ( lst . get ( '<STR_LIT>' , default_af ) , <EOL> lst . get ( '<STR_LIT>' ) ) , <EOL> '<STR_LIT>' : lst . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT:port>' : lst . get ( '<STR_LIT:port>' ) , <EOL> '<STR_LIT>' : lst . get ( '<STR_LIT>' ) <EOL> } , <EOL> validate = True , <EOL>", "answer": ")"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from braintree . attribute_getter import AttributeGetter <EOL> class ValidationError ( AttributeGetter ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "pass "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Building ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . rename_column ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> db . rename_column ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> db . rename_column ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def backwards ( self , orm ) : <EOL> db . rename_column ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> db . rename_column ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> db . rename_column ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL>", "answer": "'<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import json <EOL> import mock <EOL> import testtools <EOL> from openstack import exceptions <EOL> from openstack . message . v1 import claim <EOL> CLIENT = '<STR_LIT>' <EOL> QUEUE = '<STR_LIT>' <EOL> LIMIT = <NUM_LIT:2> <EOL> FAKE = { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> <EOL> } <EOL> class TestClaim ( testtools . TestCase ) : <EOL> def test_basic ( self ) : <EOL> sot = claim . Claim ( ) <EOL> self . assertEqual ( '<STR_LIT>' , sot . resources_key ) <EOL> self . assertEqual ( '<STR_LIT>' , sot . base_path ) <EOL> self . assertEqual ( '<STR_LIT>' , sot . service . service_type ) <EOL> self . assertTrue ( sot . allow_create ) <EOL> self . assertFalse ( sot . allow_retrieve ) <EOL> self . assertFalse ( sot . allow_update ) <EOL> self . assertFalse ( sot . allow_delete ) <EOL> self . assertFalse ( sot . allow_list ) <EOL> def test_make_it ( self ) : <EOL> sot = claim . Claim . new ( client_id = CLIENT , <EOL> queue_name = QUEUE , <EOL> limit = LIMIT , <EOL> ** FAKE ) <EOL> self . assertEqual ( CLIENT , sot . client_id ) <EOL> self . assertEqual ( QUEUE , sot . queue_name ) <EOL> self . assertEqual ( LIMIT , sot . limit ) <EOL> self . assertEqual ( FAKE [ '<STR_LIT>' ] , sot . ttl ) <EOL> self . assertEqual ( FAKE [ '<STR_LIT>' ] , sot . grace ) <EOL> def test_create ( self ) : <EOL>", "answer": "sess = mock . Mock ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from datetime import datetime <EOL> import errno <EOL> from fnmatch import fnmatch <EOL> import io <EOL> import os <EOL> import shutil <EOL> import unicodedata <EOL> def to_unicode ( txt , encoding = '<STR_LIT:utf8>' ) : <EOL> if not isinstance ( txt , basestring ) : <EOL> txt = str ( txt ) <EOL> if isinstance ( txt , unicode ) : <EOL> return txt <EOL> return unicode ( txt , encoding ) <EOL> def unormalize ( text , form = '<STR_LIT>' ) : <EOL> return unicodedata . normalize ( form , text ) <EOL> def fullmatch ( path , pattern ) : <EOL> path = unormalize ( path ) <EOL> name = os . path . basename ( path ) <EOL>", "answer": "return fnmatch ( name , pattern ) or fnmatch ( path , pattern )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL> import logging <EOL> from django . conf import settings <EOL> import docutil . cache_util as cu <EOL> from codebase . models import CodeElementLink , CodeElement <EOL> PREFIX_GETANCESTORS = settings . CACHE_MIDDLEWARE_KEY_PREFIX + '<STR_LIT>' <EOL> PREFIX_GETDESCENDANTS = settings . CACHE_MIDDLEWARE_KEY_PREFIX + '<STR_LIT>' <EOL> PREFIX_GETHIERARCHY = settings . CACHE_MIDDLEWARE_KEY_PREFIX + '<STR_LIT>' <EOL> PREFIX_GETCONTEXT = settings . CACHE_MIDDLEWARE_KEY_PREFIX + '<STR_LIT>' <EOL> HIERARCHY = '<STR_LIT>' <EOL> SNIPPET = '<STR_LIT>' <EOL> LOCAL = '<STR_LIT>' <EOL> RETURN = '<STR_LIT>' <EOL> MIDDLE = '<STR_LIT>' <EOL> GLOBAL = '<STR_LIT>' <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> def add_ancestors ( code_element , ancestors , pk_set ) : <EOL> if code_element is None : <EOL> return <EOL> for parent in code_element . parents . all ( ) : <EOL> if parent . kind . is_type and parent . pk not in pk_set : <EOL> ancestors . append ( parent ) <EOL> pk_set . add ( parent . pk ) <EOL> add_ancestors ( parent , ancestors , pk_set ) <EOL> def get_ancestors_value ( code_element ) : <EOL> pk_set = set ( ) <EOL> ancestors = [ ] <EOL> add_ancestors ( code_element , ancestors , pk_set ) <EOL> return ancestors <EOL> def add_descendants ( code_element , descendants , pk_set ) : <EOL> if code_element is None : <EOL> return <EOL> for child in code_element . children . all ( ) : <EOL> if child . kind . is_type and child . pk not in pk_set : <EOL> descendants . append ( child ) <EOL> pk_set . add ( child . pk ) <EOL> add_descendants ( child , descendants , pk_set ) <EOL> def get_descendants_value ( code_element ) : <EOL> pk_set = set ( ) <EOL> descendants = [ ] <EOL> add_descendants ( code_element , descendants , pk_set ) <EOL> return descendants <EOL> def get_context_return_types_hier_value ( context_id , source , filter_func , <EOL> codebase , context_level ) : <EOL>", "answer": "return_types = get_context_return_types ( context_id , source , filter_func ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = - <NUM_LIT:1>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import pytest <EOL> import exceptions <EOL> def test_exceptions ( ) : <EOL> with pytest . raises ( Exception ) : <EOL> raise exceptions . CardinalException <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . InternalError <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . PluginError <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . CommandNotFoundError <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . ConfigNotFoundError <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . AmbiguousConfigError <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . EventAlreadyExistsError <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL>", "answer": "raise exceptions . EventDoesNotExistError"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from numpy import cos , sin <EOL> class Point ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "x = <NUM_LIT:0.>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import logging <EOL>", "answer": "logger = logging . getLogger ( __package__ ) "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . apps import AppConfig <EOL>", "answer": "class MturkConfig ( AppConfig ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT>''' <EOL> import functools <EOL> import inspect <EOL> import types <EOL> from combi . _python_toolbox . third_party import decorator as michele_decorator_module <EOL> def decorator ( caller , func = None ) : <EOL> '''<STR_LIT>''' <EOL> if func is not None : <EOL> evaldict = func . __globals__ . copy ( ) <EOL> evaldict [ '<STR_LIT>' ] = caller <EOL> evaldict [ '<STR_LIT>' ] = func <EOL> result = michele_decorator_module . FunctionMaker . create ( <EOL> func , \"<STR_LIT>\" , <EOL> evaldict , undecorated = func ) <EOL> result . __wrapped__ = func <EOL> return result <EOL> else : <EOL> if isinstance ( caller , functools . partial ) : <EOL> return functools . partial ( decorator , caller ) <EOL> first = inspect . getargspec ( caller ) [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] <EOL> evaldict = caller . __globals__ . copy ( ) <EOL> evaldict [ '<STR_LIT>' ] = caller <EOL> evaldict [ '<STR_LIT>' ] = decorator <EOL> return michele_decorator_module . FunctionMaker . create ( <EOL> '<STR_LIT>' % ( caller . __name__ , first ) , <EOL> '<STR_LIT>' % first , <EOL> evaldict , undecorated = caller , <EOL> doc = caller . __doc__ , module = caller . __module__ ) <EOL> def helpful_decorator_builder ( decorator_builder ) : <EOL> '''<STR_LIT>''' <EOL> assert isinstance ( decorator_builder , types . FunctionType ) <EOL> def inner ( same_decorator_builder , * args , ** kwargs ) : <EOL> if args and isinstance ( args [ <NUM_LIT:0> ] , types . FunctionType ) : <EOL> function = args [ <NUM_LIT:0> ] <EOL>", "answer": "function_name = function . __name__"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> import sys <EOL> msg = '''<STR_LIT>''' <EOL> print ( msg ) <EOL> msg = '''<STR_LIT>''' <EOL> print ( msg ) <EOL> fd = False <EOL> compat = True <EOL> sys . stdout . write ( '<STR_LIT>' ) <EOL> if os . path . exists ( '<STR_LIT>' ) : <EOL> print ( '<STR_LIT:yes>' ) <EOL> fd = True <EOL>", "answer": "else :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import numpy as np <EOL> from scipy import linalg , fftpack <EOL> from . io . pick import pick_types , pick_channels <EOL> from . io . base import _BaseRaw <EOL> from . io . constants import FIFF <EOL> from . forward import ( _magnetic_dipole_field_vec , _create_meg_coils , <EOL> _concatenate_coils , _read_coil_defs ) <EOL> from . cov import make_ad_hoc_cov , _get_whitener_data <EOL> from . transforms import ( apply_trans , invert_transform , _angle_between_quats , <EOL> quat_to_rot , rot_to_quat ) <EOL> from . utils import ( verbose , logger , check_version , use_log_level , deprecated , <EOL> _check_fname , warn ) <EOL> from . fixes import partial <EOL> from . externals . six import string_types <EOL> @ deprecated ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> @ verbose <EOL> def get_chpi_positions ( raw , t_step = None , return_quat = False , verbose = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( raw , _BaseRaw ) : <EOL> if t_step is None : <EOL> t_step = <NUM_LIT:1.0> <EOL> t_step = float ( t_step ) <EOL> picks = pick_types ( raw . info , meg = False , ref_meg = False , <EOL> chpi = True , exclude = [ ] ) <EOL> if len ( picks ) == <NUM_LIT:0> : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> time_idx = raw . time_as_index ( np . arange ( <NUM_LIT:0> , raw . times [ - <NUM_LIT:1> ] , t_step ) ) <EOL> data = [ raw [ picks , ti ] for ti in time_idx ] <EOL> t = np . array ( [ d [ <NUM_LIT:1> ] for d in data ] ) <EOL> data = np . array ( [ d [ <NUM_LIT:0> ] [ : , <NUM_LIT:0> ] for d in data ] ) <EOL> data = np . c_ [ t , data ] <EOL> else : <EOL> if not isinstance ( raw , string_types ) : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> if t_step is not None : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> data = read_head_pos ( raw ) <EOL> out = head_pos_to_trans_rot_t ( data ) <EOL> if return_quat : <EOL> out = out + ( data [ : , <NUM_LIT:1> : <NUM_LIT:4> ] , ) <EOL> return out <EOL> def read_head_pos ( fname ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _check_fname ( fname , must_exist = True , overwrite = True ) <EOL> data = np . loadtxt ( fname , skiprows = <NUM_LIT:1> ) <EOL> data . shape = ( - <NUM_LIT:1> , <NUM_LIT:10> ) <EOL> return data <EOL> def write_head_pos ( fname , pos ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _check_fname ( fname , overwrite = True ) <EOL> pos = np . array ( pos , np . float64 ) <EOL>", "answer": "if pos . ndim != <NUM_LIT:2> or pos . shape [ <NUM_LIT:1> ] != <NUM_LIT:10> :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . interfaces import ( <EOL> Connectable , <EOL> Dialect , <EOL> ExecutionContext , <EOL> ExceptionContext , <EOL> Compiled , <EOL> TypeCompiler <EOL> ) <EOL> from . base import ( <EOL> Connection , <EOL> Engine , <EOL> NestedTransaction , <EOL> RootTransaction , <EOL> Transaction , <EOL> TwoPhaseTransaction , <EOL> ) <EOL>", "answer": "from . result import ("}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> NOSE_ARGS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> COVERAGE_EXTRA_ARGS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> DEFAULT_ATTRS = [ ] <EOL> DEFAULT_DIRS = [ '<STR_LIT:test>' , '<STR_LIT>' ] <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL>", "answer": "from sys import argv , exit , stderr"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> PY2 = sys . version_info [ <NUM_LIT:0> ] == <NUM_LIT:2> <EOL> _identity = lambda x : x <EOL> if PY2 : <EOL> unichr = unichr <EOL> text_type = unicode <EOL> range_type = xrange <EOL> string_types = ( str , unicode ) <EOL> integer_types = ( int , long ) <EOL> iterkeys = lambda d : d . iterkeys ( ) <EOL> itervalues = lambda d : d . itervalues ( ) <EOL> iteritems = lambda d : d . iteritems ( ) <EOL> from cStringIO import StringIO as BytesIO , StringIO <EOL> import Queue <EOL> NativeStringIO = BytesIO <EOL> exec ( '<STR_LIT>' ) <EOL> else : <EOL> unichr = chr <EOL> range_type = range <EOL> text_type = str <EOL> string_types = ( str , ) <EOL>", "answer": "integer_types = ( int , )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from cafe . drivers . unittest . decorators import tags <EOL> from cloudcafe . images . common . types import ImageType <EOL> from cloudroast . images . fixtures import ObjectStorageIntegrationFixture <EOL>", "answer": "class TestGetImage ( ObjectStorageIntegrationFixture ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from base64 import b64decode <EOL> import datetime <EOL> import json <EOL> import httplib2 <EOL> import logging <EOL> import sys <EOL> import time <EOL> import requests <EOL> from redash import settings <EOL> from redash . query_runner import * <EOL> from redash . utils import JSONEncoder <EOL> logger = logging . getLogger ( __name__ ) <EOL> try : <EOL> import apiclient . errors <EOL> from apiclient . discovery import build <EOL> from apiclient . errors import HttpError <EOL> from oauth2client . client import SignedJwtAssertionCredentials <EOL> from oauth2client import gce <EOL> enabled = True <EOL> except ImportError : <EOL> enabled = False <EOL> types_map = { <EOL> '<STR_LIT>' : TYPE_INTEGER , <EOL> '<STR_LIT>' : TYPE_FLOAT , <EOL> '<STR_LIT>' : TYPE_BOOLEAN , <EOL> '<STR_LIT>' : TYPE_STRING , <EOL> '<STR_LIT>' : TYPE_DATETIME , <EOL> } <EOL> def transform_row ( row , fields ) : <EOL> column_index = <NUM_LIT:0> <EOL> row_data = { } <EOL> for cell in row [ \"<STR_LIT:f>\" ] : <EOL> field = fields [ column_index ] <EOL> cell_value = cell [ '<STR_LIT:v>' ] <EOL> if cell_value is None : <EOL> pass <EOL> elif field [ '<STR_LIT:type>' ] == '<STR_LIT>' : <EOL> cell_value = int ( cell_value ) <EOL> elif field [ '<STR_LIT:type>' ] == '<STR_LIT>' : <EOL> cell_value = float ( cell_value ) <EOL> elif field [ '<STR_LIT:type>' ] == '<STR_LIT>' : <EOL> cell_value = cell_value . lower ( ) == \"<STR_LIT:true>\" <EOL> elif field [ '<STR_LIT:type>' ] == '<STR_LIT>' : <EOL> cell_value = datetime . datetime . fromtimestamp ( float ( cell_value ) ) <EOL> row_data [ field [ \"<STR_LIT:name>\" ] ] = cell_value <EOL> column_index += <NUM_LIT:1> <EOL> return row_data <EOL> def _load_key ( filename ) : <EOL> f = file ( filename , \"<STR_LIT:rb>\" ) <EOL> try : <EOL> return f . read ( ) <EOL> finally : <EOL> f . close ( ) <EOL> def _get_query_results ( jobs , project_id , job_id , start_index ) : <EOL> query_reply = jobs . getQueryResults ( projectId = project_id , jobId = job_id , startIndex = start_index ) . execute ( ) <EOL> logging . debug ( '<STR_LIT>' , query_reply ) <EOL> if not query_reply [ '<STR_LIT>' ] : <EOL> time . sleep ( <NUM_LIT:10> ) <EOL> return _get_query_results ( jobs , project_id , job_id , start_index ) <EOL> return query_reply <EOL> class BigQuery ( BaseQueryRunner ) : <EOL> @ classmethod <EOL> def enabled ( cls ) : <EOL> return enabled <EOL> @ classmethod <EOL> def configuration_schema ( cls ) : <EOL> return { <EOL> '<STR_LIT:type>' : '<STR_LIT:object>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:type>' : '<STR_LIT:string>' , <EOL> '<STR_LIT:title>' : '<STR_LIT>' <EOL> } , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT:type>\" : \"<STR_LIT:string>\" , <EOL> '<STR_LIT:title>' : '<STR_LIT>' <EOL> } , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> '<STR_LIT:title>' : '<STR_LIT>' <EOL> } <EOL> } , <EOL> '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] <EOL> } <EOL> def __init__ ( self , configuration ) : <EOL> super ( BigQuery , self ) . __init__ ( configuration ) <EOL> def _get_bigquery_service ( self ) : <EOL> scope = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> key = json . loads ( b64decode ( self . configuration [ '<STR_LIT>' ] ) ) <EOL> credentials = SignedJwtAssertionCredentials ( key [ '<STR_LIT>' ] , key [ '<STR_LIT>' ] , scope = scope ) <EOL> http = httplib2 . Http ( timeout = settings . BIGQUERY_HTTP_TIMEOUT ) <EOL> http = credentials . authorize ( http ) <EOL> return build ( \"<STR_LIT>\" , \"<STR_LIT>\" , http = http ) <EOL> def _get_project_id ( self ) : <EOL> return self . configuration [ \"<STR_LIT>\" ] <EOL> def _get_total_bytes_processed ( self , jobs , query ) : <EOL> job_data = { <EOL> \"<STR_LIT>\" : query , <EOL> \"<STR_LIT>\" : True , <EOL> } <EOL> response = jobs . query ( projectId = self . _get_project_id ( ) , body = job_data ) . execute ( ) <EOL> return int ( response [ \"<STR_LIT>\" ] ) <EOL> def _get_query_result ( self , jobs , query ) : <EOL> project_id = self . _get_project_id ( ) <EOL> job_data = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : query , <EOL> } <EOL> } <EOL> } <EOL> insert_response = jobs . insert ( projectId = project_id , body = job_data ) . execute ( ) <EOL> current_row = <NUM_LIT:0> <EOL> query_reply = _get_query_results ( jobs , project_id = project_id , <EOL> job_id = insert_response [ '<STR_LIT>' ] [ '<STR_LIT>' ] , start_index = current_row ) <EOL> logger . debug ( \"<STR_LIT>\" , query_reply ) <EOL> rows = [ ] <EOL> while ( \"<STR_LIT>\" in query_reply ) and current_row < query_reply [ '<STR_LIT>' ] : <EOL> for row in query_reply [ \"<STR_LIT>\" ] : <EOL> rows . append ( transform_row ( row , query_reply [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] ) ) <EOL> current_row += len ( query_reply [ '<STR_LIT>' ] ) <EOL> query_reply = jobs . getQueryResults ( projectId = project_id , jobId = query_reply [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> startIndex = current_row ) . execute ( ) <EOL> columns = [ { '<STR_LIT:name>' : f [ \"<STR_LIT:name>\" ] , <EOL> '<STR_LIT>' : f [ \"<STR_LIT:name>\" ] , <EOL> '<STR_LIT:type>' : types_map . get ( f [ '<STR_LIT:type>' ] , \"<STR_LIT:string>\" ) } for f in query_reply [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] ] <EOL> data = { <EOL> \"<STR_LIT>\" : columns , <EOL> \"<STR_LIT>\" : rows <EOL> } <EOL> return data <EOL> def run_query ( self , query ) : <EOL> logger . debug ( \"<STR_LIT>\" , query ) <EOL> bigquery_service = self . _get_bigquery_service ( ) <EOL> jobs = bigquery_service . jobs ( ) <EOL> try : <EOL> if \"<STR_LIT>\" in self . configuration : <EOL> limitMB = self . configuration [ \"<STR_LIT>\" ] <EOL> processedMB = self . _get_total_bytes_processed ( jobs , query ) / <NUM_LIT> / <NUM_LIT> <EOL> if limitMB < processedMB : <EOL> return None , \"<STR_LIT>\" % ( limitMB , processedMB ) <EOL> data = self . _get_query_result ( jobs , query ) <EOL> error = None <EOL> json_data = json . dumps ( data , cls = JSONEncoder ) <EOL> except apiclient . errors . HttpError , e : <EOL> json_data = None <EOL> if e . resp . status == <NUM_LIT> : <EOL> error = json . loads ( e . content ) [ '<STR_LIT:error>' ] [ '<STR_LIT:message>' ] <EOL> else : <EOL> error = e . content <EOL> except KeyboardInterrupt : <EOL> error = \"<STR_LIT>\" <EOL> json_data = None <EOL> except Exception : <EOL> raise sys . exc_info ( ) [ <NUM_LIT:1> ] , None , sys . exc_info ( ) [ <NUM_LIT:2> ] <EOL> return json_data , error <EOL>", "answer": "class BigQueryGCE ( BigQuery ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import time , argparse , sys , json <EOL> from hashlib import sha1 <EOL> from sklearn . datasets import fetch_20newsgroups <EOL> import numpy as np <EOL> from datasketch import MinHashLSH , MinHash <EOL> def get_ngrams ( text , n = <NUM_LIT:3> ) : <EOL> onegrams = text . split ( ) <EOL> if n == <NUM_LIT:1> : <EOL> return onegrams <EOL> if len ( onegrams ) < n : <EOL> return text <EOL> return [ \"<STR_LIT:U+0020>\" . join ( onegrams [ i : i + n ] ) for i in range ( <NUM_LIT:0> , len ( onegrams ) - n + <NUM_LIT:1> ) ] <EOL> def get_newsgroup_data ( num_perm , subset ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> newsgroup = fetch_20newsgroups ( subset = subset , <EOL> remove = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> print ( \"<STR_LIT>\" ) <EOL> minhashes = [ None for _ in range ( len ( newsgroup . data ) ) ] <EOL> shingles = [ None for _ in range ( len ( newsgroup . data ) ) ] <EOL> for i , text in enumerate ( newsgroup . data ) : <EOL> minhashes [ i ] = MinHash ( num_perm ) <EOL> shingles [ i ] = set ( get_ngrams ( text ) ) <EOL> for ngram in shingles [ i ] : <EOL> minhashes [ i ] . update ( ngram . encode ( \"<STR_LIT:utf8>\" ) ) <EOL> newsgroup . minhashes = minhashes <EOL> newsgroup . shingles = shingles <EOL> return newsgroup <EOL> def benchmark_lsh ( threshold , index_data , query_data ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> num_perm = len ( index_data . minhashes [ <NUM_LIT:0> ] . hashvalues ) <EOL> lsh = MinHashLSH ( threshold , num_perm ) <EOL> for key , minhash in zip ( index_data . filenames , index_data . minhashes ) : <EOL> lsh . insert ( key , minhash ) <EOL> print ( \"<STR_LIT>\" ) <EOL> times = [ ] <EOL> results = [ ] <EOL> for minhash in query_data . minhashes : <EOL> start = time . clock ( ) <EOL> result = lsh . query ( minhash ) <EOL> duration = time . clock ( ) - start <EOL> times . append ( duration ) <EOL> results . append ( result ) <EOL> return times , results <EOL> def benchmark_linearscan ( threshold , index_data , query_data ) : <EOL> times = [ ] <EOL> results = [ ] <EOL> for q in query_data . minhashes : <EOL> start = time . clock ( ) <EOL> result = [ ] <EOL> for key , m in zip ( index_data . filenames , index_data . minhashes ) : <EOL> j = q . jaccard ( m ) <EOL> if j >= threshold : <EOL> result . append ( key ) <EOL> duration = time . clock ( ) - start <EOL> times . append ( duration ) <EOL> results . append ( result ) <EOL>", "answer": "return times , results"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Ship ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT>''' <EOL> from django . contrib . auth . backends import RemoteUserBackend <EOL> import logging <EOL>", "answer": "logger = logging . getLogger ( \"<STR_LIT>\" )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import division <EOL> from numpy import ( zeros , argmin , argwhere , take , sum as np_sum , <EOL> any as np_any , abs as np_abs ) <EOL> from numpy . linalg import norm <EOL> from neupy . utils import format_data <EOL> from neupy . core . properties import IntProperty <EOL> from neupy . algorithms . gd import NoStepSelection <EOL> from neupy . network . base import BaseNetwork <EOL> from neupy . network . learning import UnsupervisedLearning <EOL> __all__ = ( '<STR_LIT>' , ) <EOL> class RBFKMeans ( NoStepSelection , UnsupervisedLearning , BaseNetwork ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> n_clusters = IntProperty ( minval = <NUM_LIT:2> ) <EOL> def __init__ ( self , ** options ) : <EOL> self . centers = None <EOL> super ( RBFKMeans , self ) . __init__ ( ** options ) <EOL> def predict ( self , input_data ) : <EOL> input_data = format_data ( input_data ) <EOL> centers = self . centers <EOL> classes = zeros ( ( input_data . shape [ <NUM_LIT:0> ] , <NUM_LIT:1> ) ) <EOL> for i , value in enumerate ( input_data ) : <EOL> classes [ i ] = argmin ( norm ( centers - value , axis = <NUM_LIT:1> ) ) <EOL> return classes <EOL> def train_epoch ( self , input_train , target_train ) : <EOL> centers = self . centers <EOL> old_centers = centers . copy ( ) <EOL> output_train = self . predict ( input_train ) <EOL> for i , center in enumerate ( centers ) : <EOL> positions = argwhere ( output_train [ : , <NUM_LIT:0> ] == i ) <EOL> if not np_any ( positions ) : <EOL> continue <EOL> class_data = take ( input_train , positions , axis = <NUM_LIT:0> ) <EOL> centers [ i , : ] = ( <NUM_LIT:1> / len ( class_data ) ) * np_sum ( class_data , axis = <NUM_LIT:0> ) <EOL>", "answer": "return np_abs ( old_centers - centers )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import numpy as np <EOL> from collections import defaultdict <EOL> from . util import stacklast <EOL> from . testing import check_conversion <EOL> from . basics import ( sRGB1_to_sRGB1_linear , sRGB1_linear_to_sRGB1 , <EOL> sRGB1_linear_to_XYZ100 , XYZ100_to_sRGB1_linear , <EOL> XYZ_to_xyY , xyY_to_XYZ , <EOL> XYZ100_to_CIELab , CIELab_to_XYZ100 , <EOL> CIELab_to_CIELCh , CIELCh_to_CIELab ) <EOL> from . ciecam02 import CIECAM02Space <EOL> from . luoetal2006 import ( LuoEtAl2006UniformSpace , <EOL> CAM02UCS , CAM02LCD , CAM02SCD ) <EOL> from . cvd import machado_et_al_2009_matrix <EOL> from . transform_graph import Edge , MATCH , ANY , TransformGraph <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> EDGES = [ ] <EOL> def pair ( a , b , a2b , b2a ) : <EOL> if isinstance ( a , str ) : <EOL> a = { \"<STR_LIT:name>\" : a } <EOL> if isinstance ( b , str ) : <EOL> b = { \"<STR_LIT:name>\" : b } <EOL> return [ Edge ( a , b , a2b ) , Edge ( b , a , b2a ) ] <EOL> EDGES += pair ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> lambda sRGB1 : np . asarray ( sRGB1 ) * <NUM_LIT> , <EOL> lambda sRGB255 : np . asarray ( sRGB255 ) / <NUM_LIT> ) <EOL> def _apply_rgb_mat ( mat , rgb ) : <EOL> return np . einsum ( \"<STR_LIT>\" , mat , rgb ) <EOL> def _CVD_forward ( sRGB , cvd_type , severity ) : <EOL> mat = machado_et_al_2009_matrix ( cvd_type , severity ) <EOL> return _apply_rgb_mat ( mat , sRGB ) <EOL> def _CVD_inverse ( sRGB , cvd_type , severity ) : <EOL> forward = machado_et_al_2009_matrix ( cvd_type , severity ) <EOL> return _apply_rgb_mat ( np . linalg . inv ( forward ) , sRGB ) <EOL> EDGES += pair ( { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : MATCH , \"<STR_LIT>\" : MATCH } , <EOL> { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : MATCH , \"<STR_LIT>\" : MATCH } , <EOL> lambda x , ** kwargs : sRGB1_to_sRGB1_linear ( x ) , <EOL> lambda x , ** kwargs : sRGB1_linear_to_sRGB1 ( x ) , <EOL> ) <EOL> EDGES += pair ( { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : ANY , \"<STR_LIT>\" : ANY } , <EOL> \"<STR_LIT>\" , <EOL> _CVD_forward , _CVD_inverse ) <EOL> EDGES += pair ( \"<STR_LIT>\" , \"<STR_LIT>\" , sRGB1_to_sRGB1_linear , sRGB1_linear_to_sRGB1 ) <EOL> EDGES += pair ( \"<STR_LIT>\" , \"<STR_LIT>\" , sRGB1_linear_to_XYZ100 , XYZ100_to_sRGB1_linear ) <EOL> EDGES += pair ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> lambda XYZ100 : np . asarray ( XYZ100 ) / <NUM_LIT> , <EOL> lambda XYZ1 : np . asarray ( XYZ1 ) * <NUM_LIT> ) <EOL> EDGES += pair ( \"<STR_LIT>\" , \"<STR_LIT>\" , XYZ_to_xyY , xyY_to_XYZ ) <EOL> EDGES += pair ( \"<STR_LIT>\" , \"<STR_LIT>\" , XYZ_to_xyY , xyY_to_XYZ ) <EOL> EDGES += pair ( \"<STR_LIT>\" , { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : ANY } , <EOL> XYZ100_to_CIELab , CIELab_to_XYZ100 ) <EOL> def _CIELab_to_CIELCh ( CIELab , XYZ100_w ) : <EOL> return CIELab_to_CIELCh ( CIELab ) <EOL> def _CIELCh_to_CIELab ( CIELCh , XYZ100_w ) : <EOL> return CIELCh_to_CIELab ( CIELCh ) <EOL> EDGES += pair ( { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : MATCH } , <EOL> { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : MATCH } , <EOL> _CIELab_to_CIELCh , _CIELCh_to_CIELab ) <EOL> def _XYZ100_to_CIECAM02 ( XYZ100 , ciecam02_space ) : <EOL> return ciecam02_space . XYZ100_to_CIECAM02 ( XYZ100 ) <EOL> def _CIECAM02_to_XYZ100 ( CIECAM02 , ciecam02_space ) : <EOL> return ciecam02_space . CIECAM02_to_XYZ100 ( J = CIECAM02 . J , <EOL> C = CIECAM02 . C , <EOL> h = CIECAM02 . h ) <EOL> EDGES += pair ( \"<STR_LIT>\" , { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : ANY } , <EOL> _XYZ100_to_CIECAM02 , _CIECAM02_to_XYZ100 ) <EOL> _CIECAM02_axes = set ( \"<STR_LIT>\" ) <EOL> def _CIECAM02_to_CIECAM02_subset ( CIECAM02 , ciecam02_space , axes ) : <EOL> pieces = [ ] <EOL> for axis in axes : <EOL> pieces . append ( getattr ( CIECAM02 , axis ) ) <EOL> return stacklast ( * pieces ) <EOL> def _CIECAM02_subset_to_XYZ100 ( subset , ciecam02_space , axes ) : <EOL> subset = np . asarray ( subset , dtype = float ) <EOL> kwargs = { } <EOL> if subset . shape [ - <NUM_LIT:1> ] != len ( axes ) : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> % ( subset . shape [ - <NUM_LIT:1> ] , len ( axes ) , axes ) ) <EOL> for i , coord in enumerate ( axes ) : <EOL> kwargs [ coord ] = subset [ ... , i ] <EOL> return ciecam02_space . CIECAM02_to_XYZ100 ( ** kwargs ) <EOL> EDGES += [ <EOL> Edge ( { \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : MATCH } , <EOL> { \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : MATCH , \"<STR_LIT>\" : ANY } , <EOL> _CIECAM02_to_CIECAM02_subset ) , <EOL> Edge ( { \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : ANY , \"<STR_LIT>\" : ANY } , <EOL> { \"<STR_LIT:name>\" : \"<STR_LIT>\" } , <EOL> _CIECAM02_subset_to_XYZ100 ) , <EOL> ] <EOL> def _JMh_to_LuoEtAl2006 ( JMh , ciecam02_space , luoetal2006_space , axes ) : <EOL> return luoetal2006_space . JMh_to_Jpapbp ( JMh ) <EOL> def _LuoEtAl2006_to_JMh ( Jpapbp , ciecam02_space , luoetal2006_space , axes ) : <EOL> return luoetal2006_space . Jpapbp_to_JMh ( Jpapbp ) <EOL> EDGES += pair ( { \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : MATCH , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> { \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : MATCH , <EOL> \"<STR_LIT>\" : ANY } , <EOL> _JMh_to_LuoEtAl2006 , _LuoEtAl2006_to_JMh ) <EOL> GRAPH = TransformGraph ( EDGES , <EOL> [ [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> ] ) <EOL> ALIASES = { <EOL> \"<STR_LIT>\" : CAM02UCS , <EOL> \"<STR_LIT>\" : CAM02LCD , <EOL> \"<STR_LIT>\" : CAM02SCD , <EOL> \"<STR_LIT>\" : CIECAM02Space . sRGB , <EOL> \"<STR_LIT>\" : { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : CIECAM02Space . sRGB . XYZ100_w } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : CIECAM02Space . sRGB . XYZ100_w } , <EOL> } <EOL> def norm_cspace_id ( cspace ) : <EOL> try : <EOL> cspace = ALIASES [ cspace ] <EOL> except ( KeyError , TypeError ) : <EOL> pass <EOL> if isinstance ( cspace , str ) : <EOL> if _CIECAM02_axes . issuperset ( cspace ) : <EOL> return { \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : CIECAM02Space . sRGB , <EOL> \"<STR_LIT>\" : cspace } <EOL> else : <EOL> return { \"<STR_LIT:name>\" : cspace } <EOL> elif isinstance ( cspace , CIECAM02Space ) : <EOL> return { \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : cspace } <EOL> elif isinstance ( cspace , LuoEtAl2006UniformSpace ) : <EOL> return { \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : CIECAM02Space . sRGB , <EOL> \"<STR_LIT>\" : cspace } <EOL> elif isinstance ( cspace , dict ) : <EOL> if cspace [ \"<STR_LIT:name>\" ] in ALIASES : <EOL> base = ALIASES [ cspace [ \"<STR_LIT:name>\" ] ] <EOL> if isinstance ( base , dict ) and base [ \"<STR_LIT:name>\" ] == cspace [ \"<STR_LIT:name>\" ] : <EOL> return cspace <EOL> else : <EOL> base = norm_cspace_id ( base ) <EOL> cspace = dict ( cspace ) <EOL> del cspace [ \"<STR_LIT:name>\" ] <EOL> base = dict ( base ) <EOL> base . update ( cspace ) <EOL> return base <EOL> return cspace <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" % ( cspace , ) ) <EOL> def cspace_converter ( start , end ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> start = norm_cspace_id ( start ) <EOL> end = norm_cspace_id ( end ) <EOL> return GRAPH . get_transform ( start , end ) <EOL> def cspace_convert ( arr , start , end ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> converter = cspace_converter ( start , end ) <EOL> return converter ( arr ) <EOL> def check_cspace_convert ( source_cspace , target_cspace , gold , ** kwargs ) : <EOL> def forward ( source_values ) : <EOL> return cspace_convert ( source_values , source_cspace , target_cspace ) <EOL> def reverse ( target_values ) : <EOL> return cspace_convert ( target_values , target_cspace , source_cspace ) <EOL> check_conversion ( forward , reverse , gold , ** kwargs ) <EOL> def test_cspace_convert_trivial ( ) : <EOL> check_cspace_convert ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> [ ( [ <NUM_LIT:0.1> , <NUM_LIT> , <NUM_LIT> ] , [ <NUM_LIT:0.1> , <NUM_LIT> , <NUM_LIT> ] ) , <EOL> ( [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT:0.1> ] , [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT:0.1> ] ) , <EOL> ] ) <EOL> def test_cspace_convert_long_paths ( ) : <EOL> from . gold_values import sRGB1_xyY100_gold <EOL> check_cspace_convert ( \"<STR_LIT>\" , \"<STR_LIT>\" , sRGB1_xyY100_gold , <EOL> a_min = <NUM_LIT:0> , a_max = <NUM_LIT:1> , <EOL> b_min = <NUM_LIT:0> , b_max = [ <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:100> ] ) <EOL> from . gold_values import sRGB1_xyY1_gold <EOL> check_cspace_convert ( \"<STR_LIT>\" , \"<STR_LIT>\" , sRGB1_xyY1_gold , <EOL> a_min = <NUM_LIT:0> , a_max = <NUM_LIT:1> , <EOL> b_min = <NUM_LIT:0> , b_max = <NUM_LIT:1> ) <EOL> from . gold_values import XYZ1_sRGB255_gold <EOL> check_cspace_convert ( \"<STR_LIT>\" , \"<STR_LIT>\" , XYZ1_sRGB255_gold , <EOL> a_min = <NUM_LIT:0> , a_max = <NUM_LIT:1> , <EOL> b_min = <NUM_LIT:0> , b_max = <NUM_LIT:255> ) <EOL> from . gold_values import sRGB1_CIELab_gold_D65 <EOL> check_cspace_convert ( \"<STR_LIT>\" , \"<STR_LIT>\" , sRGB1_CIELab_gold_D65 , <EOL> a_min = <NUM_LIT:0> , a_max = <NUM_LIT:1> , <EOL> b_min = [ <NUM_LIT:10> , - <NUM_LIT:30> , <NUM_LIT:30> ] , b_max = [ <NUM_LIT> , <NUM_LIT:30> , <NUM_LIT:30> ] , <EOL> gold_rtol = <NUM_LIT> ) <EOL> from . gold_values import XYZ100_CIELab_gold_D50 <EOL> check_cspace_convert ( \"<STR_LIT>\" , { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> XYZ100_CIELab_gold_D50 , <EOL> b_min = [ <NUM_LIT:10> , - <NUM_LIT:30> , <NUM_LIT:30> ] , b_max = [ <NUM_LIT> , <NUM_LIT:30> , <NUM_LIT:30> ] ) <EOL> from . gold_values import XYZ100_CIELCh_gold_D65 <EOL> check_cspace_convert ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> XYZ100_CIELCh_gold_D65 , <EOL> a_min = [ <NUM_LIT:10> , - <NUM_LIT:30> , <NUM_LIT:30> ] , a_max = [ <NUM_LIT> , <NUM_LIT:30> , <NUM_LIT:30> ] , <EOL> b_min = <NUM_LIT:0> , b_max = [ <NUM_LIT:100> , <NUM_LIT:50> , <NUM_LIT> ] ) <EOL> from . gold_values import XYZ100_CIELCh_gold_D50 <EOL> check_cspace_convert ( \"<STR_LIT>\" , <EOL> { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> XYZ100_CIELCh_gold_D50 , <EOL> a_min = [ <NUM_LIT:10> , - <NUM_LIT:30> , <NUM_LIT:30> ] , a_max = [ <NUM_LIT> , <NUM_LIT:30> , <NUM_LIT:30> ] , <EOL> b_min = <NUM_LIT:0> , b_max = [ <NUM_LIT:100> , <NUM_LIT:50> , <NUM_LIT> ] ) <EOL> from . gold_values import XYZ100_CIECAM02_gold <EOL> for t in XYZ100_CIECAM02_gold : <EOL> xyY100 = cspace_convert ( t . XYZ100 , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> CIECAM02_got = cspace_convert ( xyY100 , \"<STR_LIT>\" , t . vc ) <EOL> for i in range ( len ( CIECAM02_got ) ) : <EOL> assert np . allclose ( CIECAM02_got [ i ] , t . expected [ i ] , atol = <NUM_LIT> ) <EOL> xyY100_got = cspace_convert ( CIECAM02_got , t . vc , \"<STR_LIT>\" ) <EOL> assert np . allclose ( xyY100_got , xyY100 ) <EOL> def subset ( axes ) : <EOL> return { \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : axes , \"<STR_LIT>\" : t . vc } <EOL> JCh = stacklast ( t . expected . J , t . expected . C , t . expected . h ) <EOL> xyY100_got2 = cspace_convert ( JCh , subset ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> assert np . allclose ( xyY100_got2 , xyY100 ) <EOL> JCh_got = cspace_convert ( xyY100 , \"<STR_LIT>\" , subset ( \"<STR_LIT>\" ) ) <EOL> assert np . allclose ( JCh_got , JCh , rtol = <NUM_LIT> ) <EOL> QMH = stacklast ( t . expected . Q , t . expected . M , t . expected . H ) <EOL> check_cspace_convert ( subset ( \"<STR_LIT>\" ) , subset ( \"<STR_LIT>\" ) , <EOL> [ ( JCh , QMH ) ] , <EOL> a_max = [ <NUM_LIT:100> , <NUM_LIT:100> , <NUM_LIT> ] , <EOL> b_max = [ <NUM_LIT:100> , <NUM_LIT:100> , <NUM_LIT> ] ) <EOL> t1 = XYZ100_CIECAM02_gold [ <NUM_LIT:0> ] <EOL> t2 = XYZ100_CIECAM02_gold [ <NUM_LIT:1> ] <EOL> got2 = cspace_convert ( t1 . expected , t1 . vc , t2 . vc ) <EOL> for i in range ( len ( got2 ) ) : <EOL> assert np . allclose ( got2 [ i ] , t2 . expected [ i ] , atol = <NUM_LIT> ) <EOL> JCh1 = stacklast ( t1 . expected . J , t1 . expected . C , t1 . expected . h ) <EOL> JCh2 = stacklast ( t2 . expected . J , t2 . expected . C , t2 . expected . h ) <EOL> JCh_space1 = { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : t1 . vc } <EOL> JCh_space2 = { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : t2 . vc } <EOL> check_cspace_convert ( JCh_space1 , JCh_space2 , <EOL> [ ( JCh1 , JCh2 ) ] , <EOL> a_max = [ <NUM_LIT:100> , <NUM_LIT:100> , <NUM_LIT> ] , <EOL> b_max = [ <NUM_LIT:100> , <NUM_LIT:100> , <NUM_LIT> ] ) <EOL> from . gold_values import JMh_to_CAM02UCS_silver <EOL> check_cspace_convert ( \"<STR_LIT>\" , \"<STR_LIT>\" , JMh_to_CAM02UCS_silver , <EOL> a_max = [ <NUM_LIT:100> , <NUM_LIT:100> , <NUM_LIT> ] , <EOL> b_min = [ <NUM_LIT:0> , - <NUM_LIT:30> , - <NUM_LIT:30> ] , b_max = [ <NUM_LIT:100> , <NUM_LIT:30> , <NUM_LIT:30> ] ) <EOL> from . gold_values import JMh_to_CAM02LCD_silver <EOL> check_cspace_convert ( \"<STR_LIT>\" , \"<STR_LIT>\" , JMh_to_CAM02LCD_silver , <EOL> a_max = [ <NUM_LIT:100> , <NUM_LIT:100> , <NUM_LIT> ] , <EOL> b_min = [ <NUM_LIT:0> , - <NUM_LIT:30> , - <NUM_LIT:30> ] , b_max = [ <NUM_LIT:100> , <NUM_LIT:30> , <NUM_LIT:30> ] ) <EOL> from . gold_values import JMh_to_CAM02SCD_silver <EOL> check_cspace_convert ( \"<STR_LIT>\" , \"<STR_LIT>\" , JMh_to_CAM02SCD_silver , <EOL> a_max = [ <NUM_LIT:100> , <NUM_LIT:100> , <NUM_LIT> ] , <EOL> b_min = [ <NUM_LIT:0> , - <NUM_LIT:30> , - <NUM_LIT:30> ] , b_max = [ <NUM_LIT:100> , <NUM_LIT:30> , <NUM_LIT:30> ] ) <EOL> from . gold_values import CVD_deut50_to_sRGB1_silver <EOL> check_cspace_convert ( <EOL> { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT:50> } , <EOL> \"<STR_LIT>\" , <EOL> CVD_deut50_to_sRGB1_silver , <EOL> ) <EOL> from . gold_values import CVD_prot95_to_sRGB1_silver <EOL> check_cspace_convert ( <EOL> { \"<STR_LIT:name>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } , <EOL> \"<STR_LIT>\" , <EOL> CVD_prot95_to_sRGB1_silver , <EOL> ) <EOL> def test_CIECAM02_subset_error_checking ( ) : <EOL> from nose . tools import assert_raises <EOL> assert_raises ( ValueError , <EOL> cspace_convert , np . ones ( ( <NUM_LIT:5> , <NUM_LIT:4> ) ) , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def test_name_aliases ( ) : <EOL> from . gold_values import JMh_to_CAM02UCS_silver <EOL> check_cspace_convert ( \"<STR_LIT>\" , \"<STR_LIT>\" , JMh_to_CAM02UCS_silver , <EOL> a_max = [ <NUM_LIT:100> , <NUM_LIT:100> , <NUM_LIT> ] , <EOL> b_min = [ <NUM_LIT:0> , - <NUM_LIT:30> , - <NUM_LIT:30> ] , b_max = [ <NUM_LIT:100> , <NUM_LIT:30> , <NUM_LIT:30> ] ) <EOL> check_cspace_convert ( \"<STR_LIT>\" , { \"<STR_LIT:name>\" : \"<STR_LIT>\" } , <EOL> JMh_to_CAM02UCS_silver , <EOL> a_max = [ <NUM_LIT:100> , <NUM_LIT:100> , <NUM_LIT> ] , <EOL> b_min = [ <NUM_LIT:0> , - <NUM_LIT:30> , - <NUM_LIT:30> ] , b_max = [ <NUM_LIT:100> , <NUM_LIT:30> , <NUM_LIT:30> ] ) <EOL> weird_space = CIECAM02Space ( \"<STR_LIT>\" , <NUM_LIT> , <NUM_LIT:30> ) <EOL> assert np . allclose ( <EOL> cspace_convert ( [ <NUM_LIT:0.1> , <NUM_LIT> , <NUM_LIT> ] , <EOL> \"<STR_LIT>\" , <EOL> { \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : weird_space } ) , <EOL> cspace_convert ( [ <NUM_LIT:0.1> , <NUM_LIT> , <NUM_LIT> ] , <EOL> \"<STR_LIT>\" , <EOL> { \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : weird_space , <EOL> \"<STR_LIT>\" : CAM02UCS } ) ) <EOL> from nose . tools import assert_raises <EOL>", "answer": "assert_raises ( ValueError ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . . phonemetadata import NumberFormat , PhoneNumberDesc , PhoneMetadata <EOL> PHONE_METADATA_YE = PhoneMetadata ( id = '<STR_LIT>' , country_code = <NUM_LIT> , international_prefix = '<STR_LIT>' , <EOL> general_desc = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> fixed_line = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' , example_number = '<STR_LIT>' ) , <EOL> mobile = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' , example_number = '<STR_LIT>' ) , <EOL> toll_free = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> premium_rate = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> shared_cost = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> personal_number = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> voip = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> pager = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> uan = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> voicemail = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> no_international_dialling = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> national_prefix = '<STR_LIT:0>' , <EOL>", "answer": "national_prefix_for_parsing = '<STR_LIT:0>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Creature ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import re <EOL> import time <EOL> from django import template <EOL> from django . contrib . auth . models import User <EOL> from django . core . urlresolvers import reverse <EOL> from django . test import TestCase <EOL> from urlcrypt . lib import generate_login_token , decode_login_token , encode_token , base64url_encode <EOL> from urlcrypt . conf import URLCRYPT_LOGIN_URL , URLCRYPT_USE_RSA_ENCRYPTION <EOL> class UrlCryptTests ( TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( UrlCryptTests , self ) . setUp ( ) <EOL> self . test_user = User . objects . create_user ( '<STR_LIT:test>' , '<STR_LIT>' , '<STR_LIT:test>' ) <EOL> def test_login_token ( self ) : <EOL> token = generate_login_token ( self . test_user , u'<STR_LIT>' ) <EOL> data = decode_login_token ( token ) <EOL> self . assertEquals ( data [ '<STR_LIT>' ] , self . test_user . id ) <EOL> self . assertEquals ( data [ '<STR_LIT:url>' ] , u'<STR_LIT>' ) <EOL> def test_blank_unicode_password ( self ) : <EOL> self . test_user . password = u\"<STR_LIT>\" <EOL> self . test_user . save ( ) <EOL> self . assertEqual ( type ( self . test_user . password ) , type ( u\"<STR_LIT>\" ) ) <EOL> self . test_login_token ( ) <EOL> def test_rsa ( self ) : <EOL> if URLCRYPT_USE_RSA_ENCRYPTION : <EOL> from urlcrypt import rsa <EOL> assert rsa . decrypt ( rsa . encrypt ( \"<STR_LIT:test>\" ) ) == \"<STR_LIT:test>\" <EOL> assert rsa . decrypt ( rsa . encrypt ( \"<STR_LIT:test>\" * <NUM_LIT:100> ) ) == \"<STR_LIT:test>\" * <NUM_LIT:100> <EOL> def test_login_token_failed_hax0r ( self ) : <EOL> fake_token = '<STR_LIT>' <EOL>", "answer": "response = self . client . get ( reverse ( '<STR_LIT>' , args = ( fake_token , ) ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Tangible ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Static ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> class _Getch : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> try : <EOL> self . impl = _GetchWindows ( ) <EOL> except ImportError : <EOL> self . impl = _GetchUnix ( ) <EOL> def __call__ ( self ) : return self . impl ( ) <EOL> class _GetchUnix : <EOL> def __init__ ( self ) : <EOL> import tty , sys <EOL> def __call__ ( self ) : <EOL> import sys , tty , termios <EOL> fd = sys . stdin . fileno ( ) <EOL> old_settings = termios . tcgetattr ( fd ) <EOL> try : <EOL> tty . setraw ( sys . stdin . fileno ( ) ) <EOL> ch = sys . stdin . read ( <NUM_LIT:1> ) <EOL> finally : <EOL> termios . tcsetattr ( fd , termios . TCSADRAIN , old_settings ) <EOL>", "answer": "return ch"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . array_source import ArraySource <EOL> from . builtin_image import BuiltinImage <EOL> from . builtin_surface import BuiltinSurface <EOL> from . chaco_reader import ChacoReader <EOL> from . image_reader import ImageReader <EOL> from . parametric_surface import ParametricSurface <EOL> from . plot3d_reader import PLOT3DReader <EOL> from . point_load import PointLoad <EOL>", "answer": "from . poly_data_reader import PolyDataReader"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import importlib <EOL> PLUGINS = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL>", "answer": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL>", "answer": "from django . db import models , migrations"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Ship ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from . client import InfluxDBClient <EOL> from . client import InfluxDBClusterClient <EOL> from . dataframe_client import DataFrameClient <EOL>", "answer": "from . helper import SeriesHelper"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL>", "answer": "import sys"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT>''' <EOL>", "answer": "import sys"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = <NUM_LIT:9> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> from unittest import TestLoader , TextTestRunner <EOL> sys . path . insert ( <NUM_LIT:0> , u'<STR_LIT:.>' ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> test_suite = TestLoader ( ) . discover ( '<STR_LIT>' , pattern = '<STR_LIT>' ) <EOL>", "answer": "test_results = TextTestRunner ( verbosity = <NUM_LIT:2> ) . run ( test_suite )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT>''' <EOL> import requests <EOL> import json <EOL> import datetime <EOL> import dateutil . parser <EOL> import urllib <EOL> import os <EOL> import pytz <EOL> from Empire . cloudservices . github import GithubOrg , GithubRepo , GithubCommit <EOL> from repos . base import RepoSource , RepoCommit , RepoPatch <EOL> from repos . diffparser import DiffParser <EOL> import logging <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> owner = '<STR_LIT>' <EOL> repo = '<STR_LIT>' <EOL> class GithubSource ( RepoSource ) : <EOL> def __init__ ( self , creds = None , host = '<STR_LIT>' , owner = '<STR_LIT>' , repo = '<STR_LIT>' ) : <EOL> self . _last_date = None <EOL> self . _last_identifier = None <EOL> self . _no_more_requests_until = None <EOL> github_org = GithubOrg ( host , owner , creds ) <EOL> self . _github_repo = GithubRepo ( github_org , repo ) <EOL> def processSinceIdentifier ( self , identifier , commit_started_callback , patch_callback , commit_finished_callback , path = None ) : <EOL> since_datetime = datetime . datetime . utcnow ( ) <EOL>", "answer": "since_datetime = since_datetime . replace ( tzinfo = pytz . UTC , hour = <NUM_LIT:0> , minute = <NUM_LIT:0> , second = <NUM_LIT:0> )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> import os <EOL> from binascii import b2a_hex , a2b_hex <EOL> import gadfly <EOL> from snakemq . message import Message , MAX_UUID_LENGTH <EOL> from snakemq . messaging import MAX_IDENT_LENGTH <EOL> from snakemq . storage import QueuesStorageBase <EOL> class GadflyQueuesStorage ( QueuesStorageBase ) : <EOL> def __init__ ( self , directory , filename ) : <EOL>", "answer": "if os . path . isfile ( os . path . join ( directory , filename + \"<STR_LIT>\" ) ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = <NUM_LIT:9> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> from os import makedirs <EOL> from os . path import ( join , <EOL> dirname , <EOL> realpath , <EOL> splitext ) <EOL> from argparse import ( ArgumentParser , <EOL> ArgumentDefaultsHelpFormatter ) <EOL> from src import ( log_dir , <EOL> formatter , <EOL> project_dir ) <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> logging_debug = logging . DEBUG <EOL> logger . setLevel ( logging_debug ) <EOL> loginfo = logger . info <EOL> logdebug = logger . debug <EOL> logerr = logger . error <EOL> logwarn = logger . warning <EOL> sh = logging . StreamHandler ( ) <EOL> sh . setLevel ( logging_debug ) <EOL> sh . setFormatter ( formatter ) <EOL> logger . addHandler ( sh ) <EOL> def main ( ) : <EOL> parser = ArgumentParser ( usage = '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> formatter_class = ArgumentDefaultsHelpFormatter ) <EOL> _add_arg = parser . add_argument <EOL> _add_arg ( '<STR_LIT>' , <EOL> help = '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> type = str , <EOL> required = True ) <EOL> _add_arg ( '<STR_LIT>' , <EOL> help = '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> default = False ) <EOL> _add_arg ( '<STR_LIT>' , <EOL> help = '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL>", "answer": "default = False )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import abc <EOL> import six <EOL> @ six . add_metaclass ( abc . ABCMeta ) <EOL> class Serializable ( object ) : <EOL> @ abc . abstractmethod <EOL> def to_dict ( self ) : <EOL> pass <EOL> @ classmethod <EOL> def from_dict ( cls , data ) : <EOL>", "answer": "return cls ( ** data )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . shortcuts import render , redirect <EOL> from django . conf import settings <EOL> from downtime . models import Period <EOL> class DowntimeMiddleware ( object ) : <EOL> def process_request ( self , request ) : <EOL> exempt_exact_urls = getattr ( settings , <EOL> '<STR_LIT>' , None ) <EOL> if exempt_exact_urls : <EOL> for url in exempt_exact_urls : <EOL> if request . path == url : <EOL>", "answer": "return None"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import print_function , unicode_literals <EOL> from datetime import datetime <EOL> from django . core import mail <EOL> from django . core . urlresolvers import reverse <EOL> from django . test import TestCase <EOL> from django . test . client import Client <EOL> from corehq import toggles <EOL> from corehq . apps . users . models import WebUser <EOL> from corehq . apps . domain . models import Domain , TransferDomainRequest <EOL> from corehq . apps . domain . forms import TransferDomainForm , TransferDomainFormErrors <EOL> from corehq . apps . domain . views import TransferDomainView <EOL> from corehq . apps . domain . exceptions import InactiveTransferDomainException <EOL> class BaseDomainTest ( TestCase ) : <EOL> def setUp ( self ) : <EOL> self . client = Client ( ) <EOL> self . domain = Domain ( name = \"<STR_LIT>\" , is_active = True ) <EOL> self . domain . save ( ) <EOL> toggles . TRANSFER_DOMAIN . set ( \"<STR_LIT>\" . format ( domain = self . domain . name ) , True ) <EOL> self . username = '<STR_LIT>' <EOL> self . password = '<STR_LIT>' <EOL> self . user = WebUser . create ( self . domain . name , self . username , self . password ) <EOL> self . user . set_role ( self . domain . name , '<STR_LIT>' ) <EOL> self . user . save ( ) <EOL> self . another_domain = Domain ( name = '<STR_LIT>' , is_active = True ) <EOL> self . another_domain . save ( ) <EOL> self . mugglename = '<STR_LIT>' <EOL> self . muggle = WebUser . create ( self . another_domain . name , self . mugglename , self . password ) <EOL> self . muggle . save ( ) <EOL> def tearDown ( self ) : <EOL> self . user . delete ( ) <EOL> self . domain . delete ( ) <EOL> self . muggle . delete ( ) <EOL> self . another_domain . delete ( ) <EOL> class TestTransferDomainForm ( BaseDomainTest ) : <EOL> def test_valid_data ( self ) : <EOL> data = { <EOL> '<STR_LIT>' : self . mugglename , <EOL> '<STR_LIT>' : self . domain . name , <EOL> } <EOL> form = TransferDomainForm ( self . domain . name , self . user . username , data ) <EOL> self . assertTrue ( form . is_valid ( ) , form . errors ) <EOL> transfer = form . save ( ) <EOL> self . assertEqual ( transfer . to_username , self . mugglename ) <EOL> self . assertEqual ( transfer . domain , self . domain . name ) <EOL> self . assertEqual ( transfer . from_username , self . username ) <EOL> def test_invalid_user_data ( self ) : <EOL> data = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> form = TransferDomainForm ( self . domain . name , self . user . username , data ) <EOL> self . assertFalse ( form . is_valid ( ) ) <EOL> self . assertEqual ( form . errors , { <EOL> '<STR_LIT>' : [ TransferDomainFormErrors . USER_DNE ] , <EOL> '<STR_LIT>' : [ TransferDomainFormErrors . DOMAIN_MISMATCH ] , <EOL> } ) <EOL> class TestTransferDomainModel ( BaseDomainTest ) : <EOL> def setUp ( self ) : <EOL> super ( TestTransferDomainModel , self ) . setUp ( ) <EOL> self . transfer = TransferDomainRequest ( <EOL> to_username = self . mugglename , <EOL> from_username = self . username , <EOL> domain = self . domain . name ) <EOL> self . transfer . save ( ) <EOL> def tearDown ( self ) : <EOL> super ( TestTransferDomainModel , self ) . tearDown ( ) <EOL> self . transfer . delete ( ) <EOL> def test_domain_transfer_inactive ( self ) : <EOL> self . transfer . active = False <EOL> self . transfer . save ( ) <EOL> with self . assertRaises ( InactiveTransferDomainException ) : <EOL> self . transfer . transfer_domain ( ) <EOL> with self . assertRaises ( InactiveTransferDomainException ) : <EOL> self . transfer . send_transfer_request ( ) <EOL> def test_domain_transfer ( self ) : <EOL> self . transfer . transfer_domain ( ) <EOL> self . assertFalse ( self . transfer . active ) <EOL> self . assertFalse ( self . transfer . from_user . is_member_of ( self . domain ) ) <EOL> self . assertTrue ( self . transfer . to_user . is_member_of ( self . domain ) ) <EOL> def test_send_transfer_request ( self ) : <EOL> self . transfer . send_transfer_request ( ) <EOL> self . assertIsNotNone ( self . transfer . transfer_guid ) <EOL> self . assertEqual ( len ( mail . outbox ) , <NUM_LIT:2> , <EOL> \"<STR_LIT>\" ) <EOL> def test_get_active_transfer ( self ) : <EOL> res = TransferDomainRequest . get_active_transfer ( self . domain , self . user . username ) <EOL> self . assertIsNotNone ( res ) <EOL> newer = TransferDomainRequest ( <EOL> to_username = self . mugglename , <EOL> from_username = self . username , <EOL> request_time = datetime . utcnow ( ) , <EOL> domain = self . domain . name ) <EOL> newer . save ( ) <EOL> res = TransferDomainRequest . get_active_transfer ( self . domain , self . user . username ) <EOL> self . assertEqual ( res . pk , newer . pk ) <EOL> self . assertFalse ( TransferDomainRequest . objects . get ( pk = self . transfer . pk ) . active ) <EOL> class TestTransferDomainViews ( BaseDomainTest ) : <EOL> def setUp ( self ) : <EOL> super ( TestTransferDomainViews , self ) . setUp ( ) <EOL> self . transfer = TransferDomainRequest ( <EOL> to_username = self . mugglename , <EOL> from_username = self . username , <EOL> domain = self . domain . name ) <EOL> self . transfer . save ( ) <EOL> self . transfer . send_transfer_request ( ) <EOL> self . rando = WebUser . create ( self . domain . name , '<STR_LIT>' , self . password ) <EOL> def tearDown ( self ) : <EOL> super ( TestTransferDomainViews , self ) . tearDown ( ) <EOL> self . transfer . delete ( ) <EOL>", "answer": "self . rando . delete ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Tangible ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL> from django . core . exceptions import ObjectDoesNotExist <EOL> from django . db . models import Model , NOT_PROVIDED <EOL> from django . utils . encoding import smart_text <EOL> def track_field ( field ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from auditlog . models import LogEntry <EOL> if field . many_to_many : <EOL> return False <EOL> if getattr ( field , '<STR_LIT>' , None ) is not None and field . rel . to == LogEntry : <EOL>", "answer": "return False"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import unittest <EOL> import numpy as np <EOL> import deltasigma as ds <EOL> class TestDSQuantize ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> t = np . arange ( - <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT> ) <EOL> t = t . reshape ( ( <NUM_LIT:1> , t . shape [ <NUM_LIT:0> ] ) ) <EOL> y = t <EOL> for _ in range ( <NUM_LIT:2> ) : <EOL> y = np . concatenate ( ( y , t ) , axis = <NUM_LIT:0> ) <EOL> n = np . array ( [ <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ] ) <EOL> self . re1_first = ds . ds_quantize ( y , n ) <EOL> self . re1_second = ds . ds_quantize ( y [ <NUM_LIT:1> , : ] , n = <NUM_LIT:3> ) <EOL> self . re2 = np . array ( <EOL> [ [ - <NUM_LIT:1.> , - <NUM_LIT:1.> , - <NUM_LIT:1.> , - <NUM_LIT:1.> , - <NUM_LIT:1.> , - <NUM_LIT:1.> , - <NUM_LIT:1.> , - <NUM_LIT:1.> , - <NUM_LIT:1.> , - <NUM_LIT:1.> , - <NUM_LIT:1.> , <EOL>", "answer": "- <NUM_LIT:1.> , - <NUM_LIT:1.> , - <NUM_LIT:1.> , - <NUM_LIT:1.> , <NUM_LIT:1.> , <NUM_LIT:1.> , <NUM_LIT:1.> , <NUM_LIT:1.> , <NUM_LIT:1.> , <NUM_LIT:1.> , <NUM_LIT:1.> , <NUM_LIT:1.> , <NUM_LIT:1.> ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT>''' <EOL> from __future__ import with_statement <EOL> from Cookie import CookieError , SimpleCookie <EOL> from atexit import register as atexit_register <EOL> from datetime import datetime , timedelta <EOL> from hashlib import sha224 <EOL> from os import close as os_close , makedirs , remove <EOL> from os . path import exists , dirname , join as path_join , isfile <EOL> from shutil import copy <EOL> from shutil import move <EOL> from tempfile import mkstemp <EOL> try : <EOL> from cPickle import dump as pickle_dump , load as pickle_load <EOL> except ImportError : <EOL> from pickle import dump as pickle_dump , load as pickle_load <EOL> from config import WORK_DIR <EOL> CURRENT_SESSION = None <EOL> SESSION_COOKIE_KEY = '<STR_LIT>' <EOL> SESSIONS_DIR = path_join ( WORK_DIR , '<STR_LIT>' ) <EOL> EXPIRATION_DELTA = timedelta ( days = <NUM_LIT:30> ) <EOL> class NoSessionError ( Exception ) : <EOL> pass <EOL> class SessionStoreError ( Exception ) : <EOL> pass <EOL> class SessionCookie ( SimpleCookie ) : <EOL> def __init__ ( self , sid = None ) : <EOL> if sid is not None : <EOL> self [ SESSION_COOKIE_KEY ] = sid <EOL> def set_expired ( self ) : <EOL> self [ SESSION_COOKIE_KEY ] [ '<STR_LIT>' ] = <NUM_LIT:0> <EOL> def set_sid ( self , sid ) : <EOL> self [ SESSION_COOKIE_KEY ] = sid <EOL> def get_sid ( self ) : <EOL> return self [ SESSION_COOKIE_KEY ] . value <EOL> def hdrs ( self ) : <EOL> hdrs = [ ( '<STR_LIT>' , '<STR_LIT>' ) ] <EOL> for cookie_line in self . output ( header = '<STR_LIT>' , <EOL> sep = '<STR_LIT:\\n>' ) . split ( '<STR_LIT:\\n>' ) : <EOL> hdrs . append ( tuple ( cookie_line . split ( '<STR_LIT>' , <NUM_LIT:1> ) ) ) <EOL> return tuple ( hdrs ) <EOL> @ classmethod <EOL> def load ( cls , cookie_data ) : <EOL> cookie = SessionCookie ( ) <EOL> SimpleCookie . load ( cookie , cookie_data ) <EOL> return cookie <EOL> class Session ( dict ) : <EOL> def __init__ ( self , cookie ) : <EOL> self . cookie = cookie <EOL> sid = self . cookie . get_sid ( ) <EOL> self . init_cookie ( sid ) <EOL> def init_cookie ( self , sid ) : <EOL> self . cookie . clear ( ) <EOL> self . cookie [ SESSION_COOKIE_KEY ] = sid <EOL> self . cookie [ SESSION_COOKIE_KEY ] [ '<STR_LIT:path>' ] = '<STR_LIT>' <EOL> self . cookie [ SESSION_COOKIE_KEY ] [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> self . cookie [ SESSION_COOKIE_KEY ] [ '<STR_LIT>' ] = ( <EOL> datetime . utcnow ( ) + EXPIRATION_DELTA <EOL> ) . strftime ( '<STR_LIT>' ) <EOL> try : <EOL> self . cookie [ SESSION_COOKIE_KEY ] [ '<STR_LIT>' ] = True <EOL> except CookieError : <EOL> pass <EOL> def get ( self , key , default = None ) : <EOL> try : <EOL> return self [ key ] <EOL> except KeyError : <EOL> return default <EOL> def get_sid ( self ) : <EOL> return self . cookie . get_sid ( ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . get_sid ( ) , self . cookie , dict . __str__ ( self ) , ) <EOL> def get_session_pickle_path ( sid ) : <EOL> return path_join ( SESSIONS_DIR , '<STR_LIT>' % ( sid , ) ) <EOL> def init_session ( remote_address , cookie_data = None ) : <EOL> if cookie_data is not None : <EOL> cookie = SessionCookie . load ( cookie_data ) <EOL> else : <EOL> cookie = None <EOL> sid = sha224 ( '<STR_LIT>' % ( remote_address , datetime . utcnow ( ) ) ) . hexdigest ( ) <EOL> if cookie is None : <EOL> cookie = SessionCookie ( sid ) <EOL> else : <EOL> try : <EOL> cookie . get_sid ( ) <EOL> except KeyError : <EOL> cookie . set_sid ( sid ) <EOL> global CURRENT_SESSION <EOL> ppath = get_session_pickle_path ( cookie . get_sid ( ) ) <EOL>", "answer": "if isfile ( ppath ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import subprocess <EOL> import shlex <EOL>", "answer": "import time"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from bokeh . models . widgets import Select <EOL> from bokeh . io import output_file , show , vform <EOL> output_file ( \"<STR_LIT>\" ) <EOL> select = Select ( title = \"<STR_LIT>\" , value = \"<STR_LIT:foo>\" , options = [ \"<STR_LIT:foo>\" , \"<STR_LIT:bar>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL>", "answer": "show ( vform ( select ) ) "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from collections import defaultdict <EOL> from alembic . autogenerate . api import compare_metadata <EOL> from datetime import datetime , timedelta <EOL> from corehq . apps . change_feed import topics <EOL> from corehq . apps . change_feed . consumer . feed import KafkaChangeFeed , MultiTopicCheckpointEventHandler <EOL> from corehq . apps . userreports . data_source_providers import DynamicDataSourceProvider , StaticDataSourceProvider <EOL> from corehq . apps . userreports . exceptions import TableRebuildError , StaleRebuildError <EOL> from corehq . apps . userreports . sql import IndicatorSqlAdapter , metadata <EOL> from corehq . apps . userreports . tasks import is_static , rebuild_indicators <EOL> from corehq . sql_db . connections import connection_manager <EOL> from corehq . util . soft_assert import soft_assert <EOL> from fluff . signals import get_migration_context , get_tables_to_rebuild <EOL> from pillowtop . checkpoints . manager import PillowCheckpoint <EOL> from pillowtop . pillow . interface import ConstructedPillow <EOL> from pillowtop . processors import PillowProcessor <EOL> REBUILD_CHECK_INTERVAL = <NUM_LIT:10> * <NUM_LIT> <EOL> UCR_CHECKPOINT_ID = '<STR_LIT>' <EOL> UCR_STATIC_CHECKPOINT_ID = '<STR_LIT>' <EOL> class ConfigurableReportTableManagerMixin ( object ) : <EOL> def __init__ ( self , data_source_provider , auto_repopulate_tables = False , * args , ** kwargs ) : <EOL> self . bootstrapped = False <EOL> self . last_bootstrapped = datetime . utcnow ( ) <EOL> self . data_source_provider = data_source_provider <EOL> self . auto_repopulate_tables = auto_repopulate_tables <EOL> super ( ConfigurableReportTableManagerMixin , self ) . __init__ ( * args , ** kwargs ) <EOL> def get_all_configs ( self ) : <EOL> return self . data_source_provider . get_data_sources ( ) <EOL> def needs_bootstrap ( self ) : <EOL> return ( <EOL> not self . bootstrapped <EOL> or datetime . utcnow ( ) - self . last_bootstrapped > timedelta ( seconds = REBUILD_CHECK_INTERVAL ) <EOL> ) <EOL> def bootstrap_if_needed ( self ) : <EOL> if self . needs_bootstrap ( ) : <EOL> self . bootstrap ( ) <EOL> def bootstrap ( self , configs = None ) : <EOL> if configs is None : <EOL> configs = self . get_all_configs ( ) <EOL> self . table_adapters = [ IndicatorSqlAdapter ( config ) for config in configs ] <EOL> self . rebuild_tables_if_necessary ( ) <EOL> self . bootstrapped = True <EOL> self . last_bootstrapped = datetime . utcnow ( ) <EOL> def rebuild_tables_if_necessary ( self ) : <EOL> tables_by_engine = defaultdict ( dict ) <EOL> for adapter in self . table_adapters : <EOL> tables_by_engine [ adapter . engine_id ] [ adapter . get_table ( ) . name ] = adapter <EOL> _assert = soft_assert ( to = '<STR_LIT:@>' . join ( [ '<STR_LIT>' , '<STR_LIT>' ] ) ) <EOL> _notify_cory = lambda msg , obj : _assert ( False , msg , obj ) <EOL> for engine_id , table_map in tables_by_engine . items ( ) : <EOL> engine = connection_manager . get_engine ( engine_id ) <EOL> with engine . begin ( ) as connection : <EOL> migration_context = get_migration_context ( connection , table_map . keys ( ) ) <EOL> diffs = compare_metadata ( migration_context , metadata ) <EOL> tables_to_rebuild = get_tables_to_rebuild ( diffs , table_map . keys ( ) ) <EOL> for table_name in tables_to_rebuild : <EOL> sql_adapter = table_map [ table_name ] <EOL> if not is_static ( sql_adapter . config . _id ) : <EOL> try : <EOL> rev_before_rebuild = sql_adapter . config . get_db ( ) . get_rev ( sql_adapter . config . _id ) <EOL> self . rebuild_table ( sql_adapter ) <EOL> except TableRebuildError , e : <EOL>", "answer": "_notify_cory ( unicode ( e ) , sql_adapter . config . to_json ( ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from vulyk . models . user import Group , User <EOL> def project_init ( allowed_types ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT>''' <EOL> from datetime import timedelta <EOL> COOKIE_NAME = '<STR_LIT>' <EOL> COOKIE_DURATION = timedelta ( days = <NUM_LIT> ) <EOL>", "answer": "COOKIE_SECURE = None"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL>", "answer": "from . base import * "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import unittest <EOL> from pyramid import testing <EOL> class Test_root_factory ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . config = testing . setUp ( ) <EOL> def tearDown ( self ) : <EOL> testing . tearDown ( ) <EOL> def _callFUT ( self , request , transaction , get_connection , evolve_packages ) : <EOL> from . . import root_factory <EOL> return root_factory ( request , transaction , get_connection , <EOL> evolve_packages ) <EOL> def _makeRequest ( self , app_root = None ) : <EOL> request = Dummy ( ) <EOL> request . registry = DummyRegistry ( ) <EOL> request . registry . content = Dummy ( ) <EOL> request . registry . content . create = lambda * arg : app_root <EOL> return request <EOL> def test_without_app_root ( self ) : <EOL> txn = DummyTransaction ( ) <EOL> root = { } <EOL> gc = Dummy_get_connection ( root ) <EOL> ep = DummyFunction ( True ) <EOL> app_root = object ( ) <EOL> request = self . _makeRequest ( app_root ) <EOL> result = self . _callFUT ( request , txn , gc , ep ) <EOL> self . assertEqual ( result , app_root ) <EOL> self . assertTrue ( txn . committed ) <EOL> self . assertTrue ( txn . savepointed ) <EOL> self . assertTrue ( ep . called ) <EOL> def test_with_app_root ( self ) : <EOL> txn = DummyTransaction ( ) <EOL> app_root = object ( ) <EOL> root = { '<STR_LIT>' : app_root } <EOL> gc = Dummy_get_connection ( root ) <EOL>", "answer": "ep = DummyFunction ( True )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . apps import apps <EOL> from django . dispatch import Signal <EOL> from django . utils import six <EOL> class_prepared = Signal ( providing_args = [ \"<STR_LIT:class>\" ] ) <EOL> class ModelSignal ( Signal ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ModelSignal , self ) . __init__ ( * args , ** kwargs ) <EOL> self . unresolved_references = { } <EOL> class_prepared . connect ( self . _resolve_references ) <EOL> def _resolve_references ( self , sender , ** kwargs ) : <EOL> opts = sender . _meta <EOL> reference = ( opts . app_label , opts . object_name ) <EOL> try : <EOL> receivers = self . unresolved_references . pop ( reference ) <EOL> except KeyError : <EOL> pass <EOL> else : <EOL> for receiver , weak , dispatch_uid in receivers : <EOL> super ( ModelSignal , self ) . connect ( <EOL> receiver , sender = sender , weak = weak , dispatch_uid = dispatch_uid <EOL> ) <EOL> def connect ( self , receiver , sender = None , weak = True , dispatch_uid = None ) : <EOL> if isinstance ( sender , six . string_types ) : <EOL> try : <EOL> app_label , model_name = sender . split ( '<STR_LIT:.>' ) <EOL> except ValueError : <EOL> raise ValueError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> try : <EOL> sender = apps . get_registered_model ( app_label , model_name ) <EOL> except LookupError : <EOL> ref = ( app_label , model_name ) <EOL> refs = self . unresolved_references . setdefault ( ref , [ ] ) <EOL> refs . append ( ( receiver , weak , dispatch_uid ) ) <EOL> return <EOL> super ( ModelSignal , self ) . connect ( <EOL> receiver , sender = sender , weak = weak , dispatch_uid = dispatch_uid <EOL> ) <EOL> pre_init = ModelSignal ( providing_args = [ \"<STR_LIT>\" , \"<STR_LIT:args>\" , \"<STR_LIT>\" ] , use_caching = True ) <EOL> post_init = ModelSignal ( providing_args = [ \"<STR_LIT>\" ] , use_caching = True ) <EOL> pre_save = ModelSignal ( providing_args = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> use_caching = True ) <EOL> post_save = ModelSignal ( providing_args = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , use_caching = True ) <EOL> pre_delete = ModelSignal ( providing_args = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] , use_caching = True ) <EOL> post_delete = ModelSignal ( providing_args = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] , use_caching = True ) <EOL> m2m_changed = ModelSignal ( <EOL> providing_args = [ \"<STR_LIT:action>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> use_caching = True , <EOL>", "answer": ")"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> import logging <EOL>", "answer": "from pants . build_graph . address_lookup_error import AddressLookupError"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL>", "answer": "__title__ = '<STR_LIT>'"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from hearthbreaker . cards . base import MinionCard <EOL> from hearthbreaker . cards . minions . neutral import Nerubian <EOL> from hearthbreaker . cards . spells . neutral import GallywixsCoin <EOL> from hearthbreaker . game_objects import Minion <EOL> from hearthbreaker . tags . action import Kill , Bounce , Summon , Give , Damage , ChangeTarget , AddCard , IncreaseWeaponAttack <EOL> from hearthbreaker . tags . base import Effect , Deathrattle , Battlecry , Buff , ActionTag <EOL> from hearthbreaker . tags . card_source import LastCard <EOL> from hearthbreaker . tags . condition import IsMinion , IsType , NotCurrentTarget , OneIn , Not , HasCardName , OpponentMinionCountIsGreaterThan , And , IsDamaged <EOL> from hearthbreaker . tags . event import DidDamage , MinionSummoned , TurnEnded , Attack , SpellCast <EOL> from hearthbreaker . tags . selector import TargetSelector , MinionSelector , PlayerSelector , UserPicker , BothPlayer , CharacterSelector , RandomPicker , SelfSelector , EnemyPlayer , FriendlyPlayer , Attribute , WeaponSelector <EOL> from hearthbreaker . constants import CHARACTER_CLASS , CARD_RARITY , MINION_TYPE <EOL> from hearthbreaker . tags . status import Stealth , ChangeAttack , ChangeHealth <EOL> class DefiasBandit ( MinionCard ) : <EOL> def __init__ ( self ) : <EOL> super ( ) . __init__ ( \"<STR_LIT>\" , <NUM_LIT:1> , CHARACTER_CLASS . ROGUE , CARD_RARITY . COMMON , False ) <EOL> def create_minion ( self , player ) : <EOL> return Minion ( <NUM_LIT:2> , <NUM_LIT:1> ) <EOL> class DefiasRingleader ( MinionCard ) : <EOL> def __init__ ( self ) : <EOL> super ( ) . __init__ ( \"<STR_LIT>\" , <NUM_LIT:2> , CHARACTER_CLASS . ROGUE , CARD_RARITY . COMMON , <EOL> combo = Battlecry ( Summon ( DefiasBandit ( ) ) , PlayerSelector ( ) ) ) <EOL> def create_minion ( self , player ) : <EOL> return Minion ( <NUM_LIT:2> , <NUM_LIT:2> ) <EOL> class EdwinVanCleef ( MinionCard ) : <EOL> def __init__ ( self ) : <EOL> super ( ) . __init__ ( \"<STR_LIT>\" , <NUM_LIT:3> , CHARACTER_CLASS . ROGUE , CARD_RARITY . LEGENDARY , <EOL> battlecry = Battlecry ( Give ( [ Buff ( ChangeAttack ( Attribute ( \"<STR_LIT>\" , PlayerSelector ( ) ) , <NUM_LIT:2> ) ) , <EOL> Buff ( ChangeHealth ( Attribute ( \"<STR_LIT>\" , PlayerSelector ( ) ) , <NUM_LIT:2> ) ) ] ) , <EOL> SelfSelector ( ) ) ) <EOL> def create_minion ( self , player ) : <EOL> return Minion ( <NUM_LIT:2> , <NUM_LIT:2> ) <EOL> class Kidnapper ( MinionCard ) : <EOL> def __init__ ( self ) : <EOL> super ( ) . __init__ ( \"<STR_LIT>\" , <NUM_LIT:6> , CHARACTER_CLASS . ROGUE , CARD_RARITY . EPIC , <EOL> combo = Battlecry ( Bounce ( ) , MinionSelector ( picker = UserPicker ( ) , players = BothPlayer ( ) ) ) ) <EOL> def create_minion ( self , player ) : <EOL> return Minion ( <NUM_LIT:5> , <NUM_LIT:3> ) <EOL> class MasterOfDisguise ( MinionCard ) : <EOL> def __init__ ( self ) : <EOL> super ( ) . __init__ ( \"<STR_LIT>\" , <NUM_LIT:4> , CHARACTER_CLASS . ROGUE , CARD_RARITY . RARE , <EOL> battlecry = Battlecry ( Give ( Stealth ( ) ) , MinionSelector ( picker = UserPicker ( ) ) ) ) <EOL> def create_minion ( self , player ) : <EOL> return Minion ( <NUM_LIT:4> , <NUM_LIT:4> ) <EOL> class PatientAssassin ( MinionCard ) : <EOL> def __init__ ( self ) : <EOL> super ( ) . __init__ ( \"<STR_LIT>\" , <NUM_LIT:2> , CHARACTER_CLASS . ROGUE , CARD_RARITY . EPIC ) <EOL> def create_minion ( self , player ) : <EOL> return Minion ( <NUM_LIT:1> , <NUM_LIT:1> , stealth = True , effects = [ Effect ( DidDamage ( ) , ActionTag ( Kill ( ) , TargetSelector ( IsMinion ( ) ) ) ) ] ) <EOL> class SI7Agent ( MinionCard ) : <EOL> def __init__ ( self ) : <EOL> super ( ) . __init__ ( \"<STR_LIT>\" , <NUM_LIT:3> , CHARACTER_CLASS . ROGUE , CARD_RARITY . RARE , <EOL> combo = Battlecry ( Damage ( <NUM_LIT:2> ) , CharacterSelector ( <EOL> players = BothPlayer ( ) , picker = UserPicker ( ) ) <EOL> ) ) <EOL> def create_minion ( self , player ) : <EOL> return Minion ( <NUM_LIT:3> , <NUM_LIT:3> ) <EOL> class AnubarAmbusher ( MinionCard ) : <EOL> def __init__ ( self ) : <EOL> super ( ) . __init__ ( \"<STR_LIT>\" , <NUM_LIT:4> , CHARACTER_CLASS . ROGUE , CARD_RARITY . COMMON ) <EOL> def create_minion ( self , player ) : <EOL> return Minion ( <NUM_LIT:5> , <NUM_LIT:5> , deathrattle = Deathrattle ( Bounce ( ) , MinionSelector ( picker = RandomPicker ( ) ) ) ) <EOL> class OneeyedCheat ( MinionCard ) : <EOL> def __init__ ( self ) : <EOL> super ( ) . __init__ ( \"<STR_LIT>\" , <NUM_LIT:2> , CHARACTER_CLASS . ROGUE , CARD_RARITY . RARE , minion_type = MINION_TYPE . PIRATE ) <EOL> def create_minion ( self , player ) : <EOL> return Minion ( <NUM_LIT:4> , <NUM_LIT:1> , effects = [ Effect ( MinionSummoned ( IsType ( MINION_TYPE . PIRATE ) ) , <EOL> ActionTag ( Give ( Stealth ( ) ) , SelfSelector ( ) ) ) ] ) <EOL> class IronSensei ( MinionCard ) : <EOL> def __init__ ( self ) : <EOL> super ( ) . __init__ ( \"<STR_LIT>\" , <NUM_LIT:3> , CHARACTER_CLASS . ROGUE , CARD_RARITY . RARE , minion_type = MINION_TYPE . MECH ) <EOL> def create_minion ( self , player ) : <EOL> return Minion ( <NUM_LIT:2> , <NUM_LIT:2> , effects = [ Effect ( TurnEnded ( ) , ActionTag ( Give ( [ Buff ( ChangeAttack ( <NUM_LIT:2> ) ) , Buff ( ChangeHealth ( <NUM_LIT:2> ) ) ] ) , <EOL> MinionSelector ( IsType ( MINION_TYPE . MECH ) , picker = RandomPicker ( ) ) ) ) ] ) <EOL> class OgreNinja ( MinionCard ) : <EOL> def __init__ ( self ) : <EOL> super ( ) . __init__ ( \"<STR_LIT>\" , <NUM_LIT:5> , CHARACTER_CLASS . ROGUE , CARD_RARITY . RARE ) <EOL> def create_minion ( self , player ) : <EOL> return Minion ( <NUM_LIT:6> , <NUM_LIT:6> , stealth = True , effects = [ Effect ( Attack ( ) , <EOL> ActionTag ( ChangeTarget ( <EOL> CharacterSelector ( NotCurrentTarget ( ) , <EOL> EnemyPlayer ( ) , <EOL> RandomPicker ( ) ) ) , <EOL> SelfSelector ( ) , <EOL> And ( OneIn ( <NUM_LIT:2> ) , <EOL> OpponentMinionCountIsGreaterThan ( <NUM_LIT:0> ) ) ) ) ] ) <EOL> class TradePrinceGallywix ( MinionCard ) : <EOL> def __init__ ( self ) : <EOL> super ( ) . __init__ ( \"<STR_LIT>\" , <NUM_LIT:6> , CHARACTER_CLASS . ROGUE , CARD_RARITY . LEGENDARY ) <EOL> def create_minion ( self , player ) : <EOL> return Minion ( <NUM_LIT:5> , <NUM_LIT:8> , effects = [ Effect ( SpellCast ( Not ( HasCardName ( \"<STR_LIT>\" ) ) , EnemyPlayer ( ) ) , <EOL> ActionTag ( AddCard ( LastCard ( ) ) , <EOL> PlayerSelector ( FriendlyPlayer ( ) ) ) ) , <EOL> Effect ( SpellCast ( Not ( HasCardName ( \"<STR_LIT>\" ) ) , EnemyPlayer ( ) ) , <EOL> ActionTag ( AddCard ( GallywixsCoin ( ) ) , <EOL> PlayerSelector ( EnemyPlayer ( ) ) ) ) ] ) <EOL>", "answer": "class GoblinAutoBarber ( MinionCard ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL> import decimal <EOL> from django . forms import TypedChoiceField , ValidationError <EOL> from django . test import SimpleTestCase <EOL> from django . utils import six <EOL>", "answer": "class TypedChoiceFieldTest ( SimpleTestCase ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import itertools <EOL> import os <EOL> import re <EOL> import stat <EOL> import tempfile <EOL> import thread <EOL> import threading <EOL> import time <EOL> import sqlite3 <EOL> import logging <EOL> from grr . lib import aff4 <EOL> from grr . lib import config_lib <EOL> from grr . lib import data_store <EOL> from grr . lib import rdfvalue <EOL> from grr . lib import utils <EOL> from grr . lib . data_stores import common <EOL> SQLITE_EXTENSION = \"<STR_LIT>\" <EOL> SQLITE_TIMEOUT = <NUM_LIT> <EOL> SQLITE_ISOLATION = \"<STR_LIT>\" <EOL> SQLITE_SUBJECT_SPEC = \"<STR_LIT>\" <EOL> SQLITE_DETECT_TYPES = <NUM_LIT:0> <EOL> SQLITE_FACTORY = sqlite3 . Connection <EOL> SQLITE_CACHED_STATEMENTS = <NUM_LIT:20> <EOL> SQLITE_PAGE_SIZE = <NUM_LIT> <EOL> class SqliteConnectionCache ( utils . FastStore ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> template = None <EOL> def _CreateModelDatabase ( self ) : <EOL> try : <EOL> if not os . path . isdir ( self . root_path ) : <EOL> os . makedirs ( self . root_path ) <EOL> except OSError : <EOL> pass <EOL> fd , model = tempfile . mkstemp ( dir = self . root_path ) <EOL> os . close ( fd ) <EOL> conn = sqlite3 . connect ( model , SQLITE_TIMEOUT , SQLITE_DETECT_TYPES , <EOL> SQLITE_ISOLATION , False , SQLITE_FACTORY , <EOL> SQLITE_CACHED_STATEMENTS ) <EOL> cursor = conn . cursor ( ) <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> cursor . execute ( \"<STR_LIT>\" % SQLITE_PAGE_SIZE ) <EOL> query = \"\"\"<STR_LIT>\"\"\" % { \"<STR_LIT>\" : SQLITE_SUBJECT_SPEC } <EOL> cursor . execute ( query ) <EOL> query = \"\"\"<STR_LIT>\"\"\" % { \"<STR_LIT>\" : SQLITE_SUBJECT_SPEC } <EOL> cursor . execute ( query ) <EOL> query = \"\"\"<STR_LIT>\"\"\" <EOL> cursor . execute ( query ) <EOL> query = \"\"\"<STR_LIT>\"\"\" <EOL> cursor . execute ( query ) <EOL> conn . commit ( ) <EOL> cursor . close ( ) <EOL> conn . close ( ) <EOL> with open ( model , \"<STR_LIT:rb>\" ) as model_file : <EOL> self . template = model_file . read ( ) <EOL> os . unlink ( model ) <EOL> def _WaitUntilReadable ( self , target_path ) : <EOL> start_time = time . time ( ) <EOL> while True : <EOL> if os . access ( target_path , os . R_OK ) : <EOL> return <EOL> time . sleep ( <NUM_LIT> ) <EOL> if time . time ( ) - start_time >= <NUM_LIT> : <EOL> raise IOError ( \"<STR_LIT>\" % target_path ) <EOL> def _EnsureDatabaseExists ( self , target_path ) : <EOL> if os . path . exists ( target_path ) : <EOL> self . _WaitUntilReadable ( target_path ) <EOL> return <EOL> umask_original = os . umask ( <NUM_LIT:0> ) <EOL> write_permissions = stat . S_IWUSR | stat . S_IWGRP <EOL> read_permissions = stat . S_IRUSR | stat . S_IRGRP <EOL> try : <EOL> fd = os . open ( target_path , os . O_CREAT | os . O_EXCL | os . O_WRONLY , <EOL> write_permissions ) <EOL> os . close ( fd ) <EOL> with open ( target_path , \"<STR_LIT:wb>\" ) as target_file : <EOL> target_file . write ( self . template ) <EOL> os . chmod ( target_path , write_permissions | read_permissions ) <EOL> except OSError : <EOL> if os . path . exists ( target_path ) : <EOL> self . _WaitUntilReadable ( target_path ) <EOL> else : <EOL> logging . error ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , target_path ) <EOL> finally : <EOL> os . umask ( umask_original ) <EOL> def __init__ ( self , max_size , path ) : <EOL> super ( SqliteConnectionCache , self ) . __init__ ( max_size = max_size ) <EOL> self . root_path = path or config_lib . CONFIG . Get ( \"<STR_LIT>\" ) <EOL> self . _CreateModelDatabase ( ) <EOL> self . RecreatePathing ( ) <EOL> def RecreatePathing ( self , pathing = None ) : <EOL> if not pathing : <EOL> pathing = config_lib . CONFIG . Get ( \"<STR_LIT>\" ) <EOL> try : <EOL> self . path_regexes = [ re . compile ( path ) for path in pathing ] <EOL> self . pathing = pathing <EOL> except re . error : <EOL> raise data_store . Error ( \"<STR_LIT>\" ) <EOL> def RootPath ( self ) : <EOL> return self . root_path <EOL> def ChangePath ( self , new_path ) : <EOL> self . root_path = new_path <EOL> def KillObject ( self , conn ) : <EOL> conn . Close ( ) <EOL> @ utils . Synchronized <EOL> def Get ( self , subject ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> filename , directory = common . ResolveSubjectDestination ( subject , <EOL> self . path_regexes ) <EOL> key = common . MakeDestinationKey ( directory , filename ) <EOL> try : <EOL> return super ( SqliteConnectionCache , self ) . Get ( key ) <EOL> except KeyError : <EOL> dirname = utils . JoinPath ( self . root_path , directory ) <EOL> path = utils . JoinPath ( dirname , filename ) + SQLITE_EXTENSION <EOL> dirname = utils . SmartStr ( dirname ) <EOL> path = utils . SmartStr ( path ) <EOL> if not os . path . isdir ( dirname ) : <EOL> try : <EOL> os . makedirs ( dirname ) <EOL> except OSError : <EOL> pass <EOL> self . _EnsureDatabaseExists ( path ) <EOL> connection = SqliteConnection ( path ) <EOL> super ( SqliteConnectionCache , self ) . Put ( key , connection ) <EOL> return connection <EOL> def GetPrefix ( self , subject_prefix ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> components = common . Components ( subject_prefix ) <EOL> components = [ common . ConvertStringToFilename ( x ) for x in components ] <EOL> path_prefix = utils . JoinPath ( * components ) <EOL> if path_prefix == \"<STR_LIT:/>\" : <EOL> path_prefix = \"<STR_LIT>\" <EOL> for regex in self . path_regexes : <EOL> result = common . EvaluatePrefix ( path_prefix , regex ) <EOL> if result == \"<STR_LIT>\" : <EOL> yield self . Get ( subject_prefix ) <EOL> return <EOL> if result == \"<STR_LIT>\" : <EOL> for conn in self . DatabasesByPath ( path_prefix ) : <EOL> yield conn <EOL> return <EOL> yield self . Get ( subject_prefix ) <EOL> def DatabasesInDir ( self , directory ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for ( path , dirs , files ) in os . walk ( directory , topdown = True ) : <EOL> dirs . sort ( ) <EOL> files . sort ( ) <EOL> for f in files : <EOL> if f . endswith ( SQLITE_EXTENSION ) : <EOL> f = f [ : - len ( SQLITE_EXTENSION ) ] <EOL> yield utils . JoinPath ( path , f ) <EOL> @ utils . Synchronized <EOL> def DatabasesByPath ( self , path_prefix ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dir_prefix = utils . JoinPath ( self . root_path , path_prefix ) <EOL> shortened_path_prefix = path_prefix <EOL> databases_found = set ( ) <EOL> while True : <EOL> shortened_path = utils . JoinPath ( self . root_path , shortened_path_prefix ) <EOL> if os . path . isdir ( shortened_path ) : <EOL> for db in self . DatabasesInDir ( shortened_path ) : <EOL> if db in databases_found : <EOL> continue <EOL> mod_db = db <EOL> if mod_db == utils . JoinPath ( self . root_path , \"<STR_LIT>\" ) : <EOL> mod_db = self . root_path <EOL> if mod_db . startswith ( dir_prefix ) or dir_prefix . startswith ( mod_db ) : <EOL> databases_found . add ( db ) <EOL> yield SqliteConnection ( db + SQLITE_EXTENSION ) <EOL> if not shortened_path_prefix : <EOL> break <EOL> components = shortened_path_prefix . split ( os . path . sep ) <EOL> shortened_path_prefix = utils . JoinPath ( * ( components [ : - <NUM_LIT:1> ] ) ) <EOL> if shortened_path_prefix == \"<STR_LIT:/>\" : <EOL> shortened_path_prefix = \"<STR_LIT>\" <EOL> class SqliteConnection ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , filename ) : <EOL> self . filename = filename <EOL> self . conn = sqlite3 . connect ( filename , SQLITE_TIMEOUT , SQLITE_DETECT_TYPES , <EOL> SQLITE_ISOLATION , False , SQLITE_FACTORY , <EOL> SQLITE_CACHED_STATEMENTS ) <EOL> self . conn . text_factory = str <EOL> self . cursor = self . conn . cursor ( ) <EOL> self . Execute ( \"<STR_LIT>\" ) <EOL> self . Execute ( \"<STR_LIT>\" ) <EOL> self . Execute ( \"<STR_LIT>\" ) <EOL> self . Execute ( \"<STR_LIT>\" ) <EOL> self . lock = threading . RLock ( ) <EOL> self . dirty = False <EOL> self . deleted = <NUM_LIT:0> <EOL> self . next_vacuum_check = config_lib . CONFIG [ \"<STR_LIT>\" ] <EOL> def Filename ( self ) : <EOL> return self . filename <EOL> def Execute ( self , * args ) : <EOL> try : <EOL> return self . cursor . execute ( * args ) <EOL> except sqlite3 . DatabaseError : <EOL> logging . exception ( \"<STR_LIT>\" , self . filename , <EOL> args ) <EOL> raise <EOL> @ utils . Synchronized <EOL> def GetLock ( self , subject ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subject = utils . SmartStr ( subject ) <EOL> query = \"<STR_LIT>\" <EOL> args = ( subject , ) <EOL> data = self . Execute ( query , args ) . fetchone ( ) <EOL> if data : <EOL> return data [ <NUM_LIT:0> ] , data [ <NUM_LIT:1> ] <EOL> else : <EOL> return None , None <EOL> @ utils . Synchronized <EOL> def SetLock ( self , subject , expires , token ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subject = utils . SmartStr ( subject ) <EOL> query = \"<STR_LIT>\" <EOL> args = ( subject , expires , token ) <EOL> self . Execute ( query , args ) <EOL> self . dirty = True <EOL> @ utils . Synchronized <EOL> def RemoveLock ( self , subject ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subject = utils . SmartStr ( subject ) <EOL> query = \"<STR_LIT>\" <EOL> args = ( subject , ) <EOL> self . Execute ( query , args ) <EOL> self . dirty = True <EOL> @ utils . Synchronized <EOL> def GetNewestValue ( self , subject , attribute ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subject = utils . SmartStr ( subject ) <EOL> attribute = utils . SmartStr ( attribute ) <EOL> query = \"\"\"<STR_LIT>\"\"\" <EOL> args = ( subject , attribute ) <EOL> data = self . Execute ( query , args ) . fetchone ( ) <EOL> if data : <EOL> return ( data [ <NUM_LIT:0> ] , data [ <NUM_LIT:1> ] ) <EOL> else : <EOL> return None <EOL> @ utils . Synchronized <EOL> def GetNewestFromPrefix ( self , subject , prefix , limit = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pattern = prefix + \"<STR_LIT:%>\" <EOL> subject = utils . SmartStr ( subject ) <EOL> query = \"\"\"<STR_LIT>\"\"\" <EOL> if limit : <EOL> query += \"<STR_LIT>\" <EOL> args = ( subject , pattern , limit ) <EOL> else : <EOL> args = ( subject , pattern ) <EOL> data = self . Execute ( query , args ) . fetchall ( ) <EOL> return [ ( pred , val , ts ) for pred , ts , val in data ] <EOL> @ utils . Synchronized <EOL> def GetValuesFromPrefix ( self , subject , prefix , start , end , limit = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pattern = prefix + \"<STR_LIT:%>\" <EOL> subject = utils . SmartStr ( subject ) <EOL> query = \"\"\"<STR_LIT>\"\"\" <EOL> if limit : <EOL> query += \"<STR_LIT>\" <EOL> args = ( subject , pattern , start , end , limit ) <EOL> else : <EOL> args = ( subject , pattern , start , end ) <EOL> data = self . Execute ( query , args ) . fetchall ( ) <EOL> return data <EOL> @ utils . Synchronized <EOL> def GetValues ( self , subject , attribute , start , end , limit = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subject = utils . SmartStr ( subject ) <EOL> attribute = utils . SmartStr ( attribute ) <EOL> query = \"\"\"<STR_LIT>\"\"\" <EOL> if limit : <EOL> query += \"<STR_LIT>\" <EOL> args = ( subject , attribute , start , end , limit ) <EOL> else : <EOL> args = ( subject , attribute , start , end ) <EOL> data = self . Execute ( query , args ) . fetchall ( ) <EOL> return data <EOL> def ScanAttributes ( self , <EOL> subject_prefix , <EOL> attributes , <EOL> after_urn = None , <EOL> max_records = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cursor = self . conn . cursor ( ) <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> query = \"\"\"<STR_LIT>\"\"\" % \"<STR_LIT:U+002C>\" . join ( \"<STR_LIT:?>\" * len ( attributes ) ) <EOL> subject_prefix = utils . SmartStr ( subject_prefix ) <EOL> if after_urn : <EOL> after_urn = utils . SmartStr ( after_urn ) <EOL> else : <EOL> after_urn = \"<STR_LIT>\" <EOL> args = [ subject_prefix + \"<STR_LIT:%>\" , after_urn ] + attributes <EOL> if max_records : <EOL> query += \"<STR_LIT>\" <EOL> args . append ( max_records * len ( attributes ) ) <EOL> cursor . execute ( query , args ) <EOL> for r in cursor : <EOL> yield r <EOL> @ utils . Synchronized <EOL> def DeleteAttribute ( self , subject , attribute ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subject = utils . SmartStr ( subject ) <EOL> attribute = utils . SmartStr ( attribute ) <EOL> query = \"<STR_LIT>\" <EOL> args = ( subject , attribute ) <EOL> self . Execute ( query , args ) <EOL> self . dirty = True <EOL> self . deleted += self . cursor . rowcount <EOL> @ utils . Synchronized <EOL> def SetAttribute ( self , subject , attribute , value , timestamp ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subject = utils . SmartStr ( subject ) <EOL> attribute = utils . SmartStr ( attribute ) <EOL> query = \"<STR_LIT>\" <EOL> args = ( subject , attribute , timestamp , value ) <EOL> self . Execute ( query , args ) <EOL> self . dirty = True <EOL> self . deleted = max ( <NUM_LIT:0> , self . deleted - self . cursor . rowcount ) <EOL> @ utils . Synchronized <EOL> def DeleteAttributeRange ( self , subject , attribute , start , end ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subject = utils . SmartStr ( subject ) <EOL> attribute = utils . SmartStr ( attribute ) <EOL> query = \"\"\"<STR_LIT>\"\"\" <EOL> args = ( subject , attribute , int ( start ) , int ( end ) ) <EOL> self . Execute ( query , args ) <EOL> self . dirty = True <EOL> self . deleted += self . cursor . rowcount <EOL> @ utils . Synchronized <EOL> def DeleteSubject ( self , subject ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subject = utils . SmartStr ( subject ) <EOL> query = \"<STR_LIT>\" <EOL> args = ( subject , ) <EOL> self . Execute ( query , args ) <EOL> self . dirty = True <EOL> self . deleted += self . cursor . rowcount <EOL> def PrettyPrint ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> query = \"<STR_LIT>\" <EOL> for sub , pred , ts , val in self . Execute ( query ) : <EOL> print \"<STR_LIT>\" % ( sub , pred , ts , val ) <EOL> print \"<STR_LIT>\" <EOL> def __enter__ ( self ) : <EOL> self . lock . acquire ( ) <EOL> return self <EOL> def __exit__ ( self , exc_type , exc_value , traceback ) : <EOL> if self . dirty : <EOL> self . Flush ( ) <EOL> self . dirty = False <EOL> self . lock . release ( ) <EOL> @ utils . Synchronized <EOL> def Flush ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . conn : <EOL> try : <EOL> self . conn . commit ( ) <EOL> except sqlite3 . OperationalError : <EOL> pass <EOL> if self . deleted >= self . next_vacuum_check : <EOL> if self . _NeedsVacuum ( ) and not self . _HasRecentVacuum ( ) : <EOL> self . Vacuum ( ) <EOL> self . deleted = <NUM_LIT:0> <EOL> self . next_vacuum_check = max ( <EOL> config_lib . CONFIG [ \"<STR_LIT>\" ] , <EOL> self . next_vacuum_check / <NUM_LIT:2> ) <EOL> else : <EOL> self . next_vacuum_check *= <NUM_LIT:2> <EOL> def _NeedsVacuum ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pages_result = self . Execute ( \"<STR_LIT>\" ) . fetchone ( ) <EOL> if not pages_result : <EOL> return False <EOL> pages = int ( pages_result [ <NUM_LIT:0> ] ) <EOL> vacuum_minsize = config_lib . CONFIG [ \"<STR_LIT>\" ] <EOL> if pages * SQLITE_PAGE_SIZE < vacuum_minsize : <EOL> return False <EOL> free_pages_result = self . Execute ( \"<STR_LIT>\" ) . fetchone ( ) <EOL> if not free_pages_result : <EOL> return False <EOL> free_pages = int ( free_pages_result [ <NUM_LIT:0> ] ) <EOL> vacuum_ratio = config_lib . CONFIG [ \"<STR_LIT>\" ] <EOL> return <NUM_LIT> * float ( free_pages ) / float ( pages ) >= vacuum_ratio <EOL> def _HasRecentVacuum ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> query = \"<STR_LIT>\" <EOL> data = self . Execute ( query ) . fetchone ( ) <EOL> if not data : <EOL> return False <EOL> try : <EOL> last_vacuum = int ( str ( data [ <NUM_LIT:0> ] ) ) <EOL> vacuum_frequency = config_lib . CONFIG [ \"<STR_LIT>\" ] <EOL> return time . time ( ) - last_vacuum < vacuum_frequency <EOL> except ValueError : <EOL> return False <EOL> def Vacuum ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> now = time . time ( ) <EOL> logging . debug ( \"<STR_LIT>\" ) <EOL> self . Execute ( \"<STR_LIT>\" ) <EOL> query = \"<STR_LIT>\" <EOL> args = ( str ( int ( now ) ) , ) <EOL> self . Execute ( query , args ) <EOL> try : <EOL> self . conn . commit ( ) <EOL> except sqlite3 . OperationalError : <EOL> pass <EOL> @ utils . Synchronized <EOL> def Close ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . dirty : <EOL> self . Flush ( ) <EOL> self . cursor . close ( ) <EOL> self . conn . close ( ) <EOL> self . conn = None <EOL> self . cursor = None <EOL> class SqliteDataStore ( data_store . DataStore ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cache = None <EOL> def __init__ ( self , path = None ) : <EOL> self . _CalculateAttributeStorageTypes ( ) <EOL> super ( SqliteDataStore , self ) . __init__ ( ) <EOL> self . cache = SqliteConnectionCache ( <EOL> config_lib . CONFIG [ \"<STR_LIT>\" ] , path ) <EOL> def RecreatePathing ( self , pathing ) : <EOL> self . cache . RecreatePathing ( pathing ) <EOL> def _CalculateAttributeStorageTypes ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _attribute_types = { } <EOL> for attribute in aff4 . Attribute . PREDICATES . values ( ) : <EOL> self . _attribute_types [ attribute . predicate ] = ( <EOL> attribute . attribute_type . data_store_type ) <EOL> def _Encode ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> return buffer ( value . SerializeToString ( ) ) <EOL> except AttributeError : <EOL> if isinstance ( value , ( int , long ) ) : <EOL> return value <EOL> else : <EOL> return buffer ( utils . SmartStr ( value ) ) <EOL> def _Decode ( self , attribute , value ) : <EOL> required_type = self . _attribute_types . get ( attribute , \"<STR_LIT>\" ) <EOL> if isinstance ( value , buffer ) : <EOL> value = str ( value ) <EOL> if required_type in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> return int ( value ) <EOL> elif required_type == \"<STR_LIT:string>\" : <EOL> return utils . SmartUnicode ( value ) <EOL> else : <EOL> return value <EOL> def MultiSet ( self , subject , values , timestamp = None , replace = True , <EOL> sync = True , to_delete = None , token = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . security_manager . CheckDataStoreAccess ( token , [ subject ] , \"<STR_LIT:w>\" ) <EOL> _ = sync <EOL> if timestamp is None or timestamp == self . NEWEST_TIMESTAMP : <EOL> timestamp = time . time ( ) * <NUM_LIT> <EOL> if to_delete is None : <EOL> to_delete = [ ] <EOL> with self . cache . Get ( subject ) as sqlite_connection : <EOL> if replace : <EOL> to_delete . extend ( values . keys ( ) ) <EOL> if to_delete : <EOL> for attribute in to_delete : <EOL> sqlite_connection . DeleteAttribute ( subject , attribute ) <EOL> for attribute , seq in values . items ( ) : <EOL> for v in seq : <EOL> element_timestamp = None <EOL> if isinstance ( v , ( list , tuple ) ) : <EOL> v , element_timestamp = v <EOL> if element_timestamp is None : <EOL> element_timestamp = timestamp <EOL> element_timestamp = long ( element_timestamp ) <EOL> value = self . _Encode ( v ) <EOL> sqlite_connection . SetAttribute ( subject , attribute , value , <EOL> element_timestamp ) <EOL> def DeleteAttributes ( self , subject , attributes , start = None , end = None , <EOL> sync = True , token = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . security_manager . CheckDataStoreAccess ( token , [ subject ] , \"<STR_LIT:w>\" ) <EOL> _ = sync <EOL> if isinstance ( attributes , basestring ) : <EOL> raise ValueError ( <EOL> \"<STR_LIT>\" ) <EOL> with self . cache . Get ( subject ) as sqlite_connection : <EOL> if start is None and end is None : <EOL> for attribute in list ( attributes ) : <EOL> sqlite_connection . DeleteAttribute ( subject , attribute ) <EOL> else : <EOL> start = start or <NUM_LIT:0> <EOL> if end is None : <EOL> end = ( <NUM_LIT:2> ** <NUM_LIT> ) - <NUM_LIT:1> <EOL> for attribute in list ( attributes ) : <EOL> sqlite_connection . DeleteAttributeRange ( subject , attribute , start , <EOL> end ) <EOL> def DeleteSubject ( self , subject , sync = False , token = None ) : <EOL> _ = sync <EOL> self . security_manager . CheckDataStoreAccess ( token , [ subject ] , \"<STR_LIT:w>\" ) <EOL> with self . cache . Get ( subject ) as sqlite_connection : <EOL> sqlite_connection . DeleteSubject ( subject ) <EOL> def MultiResolvePrefix ( self , subjects , attribute_prefix , timestamp = None , <EOL> limit = None , token = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = { } <EOL> remaining_limit = limit <EOL> for subject in subjects : <EOL> values = self . ResolvePrefix ( subject , attribute_prefix , token = token , <EOL> timestamp = timestamp , limit = remaining_limit ) <EOL> if values : <EOL> if limit : <EOL> if len ( values ) >= remaining_limit : <EOL> result [ subject ] = values [ : remaining_limit ] <EOL> return result . iteritems ( ) <EOL> remaining_limit -= len ( values ) <EOL> result [ subject ] = values <EOL> return result . iteritems ( ) <EOL> def _GetStartEndTimestamp ( self , timestamp ) : <EOL> if timestamp == self . ALL_TIMESTAMPS or timestamp is None : <EOL> return <NUM_LIT:0> , ( <NUM_LIT:2> ** <NUM_LIT> ) - <NUM_LIT:1> <EOL> elif timestamp == self . NEWEST_TIMESTAMP : <EOL> return - <NUM_LIT:1> , - <NUM_LIT:1> <EOL> elif isinstance ( timestamp , int ) : <EOL> return timestamp , timestamp <EOL> else : <EOL> try : <EOL> start , end = timestamp <EOL> return int ( start ) , int ( end ) <EOL> except ValueError : <EOL> return timestamp , timestamp <EOL> def ResolvePrefix ( self , subject , attribute_prefix , timestamp = None , <EOL> limit = None , token = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . security_manager . CheckDataStoreAccess ( <EOL> token , [ subject ] , self . GetRequiredResolveAccess ( attribute_prefix ) ) <EOL> if isinstance ( attribute_prefix , str ) : <EOL> attribute_prefix = [ attribute_prefix ] <EOL> start , end = self . _GetStartEndTimestamp ( timestamp ) <EOL> results = [ ] <EOL> with self . cache . Get ( subject ) as sqlite_connection : <EOL> for prefix in attribute_prefix : <EOL> nr_results = len ( results ) <EOL> if limit and nr_results >= limit : <EOL> break <EOL> new_limit = limit <EOL> if new_limit : <EOL> new_limit -= nr_results <EOL> if timestamp == self . NEWEST_TIMESTAMP : <EOL> data = sqlite_connection . GetNewestFromPrefix ( subject , prefix , <EOL> new_limit ) <EOL> for attribute , value , ts in data : <EOL> value = self . _Decode ( attribute , value ) <EOL> results . append ( ( attribute , value , ts ) ) <EOL> else : <EOL> data = sqlite_connection . GetValuesFromPrefix ( subject , prefix , start , <EOL> end , new_limit ) <EOL> for attribute , value , ts in data : <EOL> value = self . _Decode ( attribute , value ) <EOL> results . append ( ( attribute , value , ts ) ) <EOL> return results <EOL> def _GroupSubjects ( self , collection , max_records ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> record_count = <NUM_LIT:0> <EOL> current_subject = None <EOL> current_results = { } <EOL> for subject , attribute , timestamp , value in collection : <EOL> if not current_subject : <EOL> current_subject = subject <EOL> if current_subject != subject : <EOL> yield ( current_subject , current_results ) <EOL> record_count += <NUM_LIT:1> <EOL> if max_records and record_count >= max_records : <EOL> return <EOL> current_results = { } <EOL> current_subject = subject <EOL> current_results [ attribute ] = ( timestamp , self . _Decode ( attribute , value ) ) <EOL> if current_results : <EOL> yield ( current_subject , current_results ) <EOL> def ScanAttributes ( self , <EOL> subject_prefix , <EOL> attributes , <EOL> after_urn = None , <EOL> max_records = None , <EOL> token = None , <EOL> relaxed_order = False ) : <EOL> self . security_manager . CheckDataStoreAccess ( token , [ subject_prefix ] , \"<STR_LIT>\" ) <EOL> subject_prefix = utils . SmartStr ( rdfvalue . RDFURN ( subject_prefix ) ) <EOL> if subject_prefix [ - <NUM_LIT:1> ] != \"<STR_LIT:/>\" : <EOL> subject_prefix += \"<STR_LIT:/>\" <EOL> if after_urn : <EOL> after_urn = str ( after_urn ) <EOL> connection_iter = self . cache . GetPrefix ( subject_prefix ) <EOL> if relaxed_order : <EOL> for sqlite_connection in connection_iter : <EOL> with sqlite_connection : <EOL> for r in self . _GroupSubjects ( list ( sqlite_connection . ScanAttributes ( <EOL> subject_prefix , <EOL> attributes , <EOL> after_urn = after_urn , <EOL> max_records = max_records ) ) , max_records ) : <EOL> yield r <EOL> return <EOL> first_connections = [ ] <EOL> try : <EOL> first_connections . append ( connection_iter . next ( ) ) <EOL> first_connections . append ( connection_iter . next ( ) ) <EOL> except StopIteration : <EOL> pass <EOL> if not first_connections : <EOL> return <EOL> if len ( first_connections ) == <NUM_LIT:1> : <EOL> with first_connections [ <NUM_LIT:0> ] as sqlite_connection : <EOL> for r in self . _GroupSubjects ( list ( sqlite_connection . ScanAttributes ( <EOL> subject_prefix , <EOL> attributes , <EOL> after_urn = after_urn , <EOL> max_records = max_records ) ) , max_records ) : <EOL> yield r <EOL> return <EOL> raw_results = [ ] <EOL> for sqlite_connection in itertools . chain ( first_connections , <EOL> connection_iter ) : <EOL> for record in sqlite_connection . ScanAttributes ( subject_prefix , <EOL> attributes , <EOL> after_urn = after_urn , <EOL> max_records = max_records ) : <EOL> raw_results . append ( record ) <EOL> for r in self . _GroupSubjects ( sorted ( raw_results , key = lambda x : x [ <NUM_LIT:0> ] ) , <EOL> max_records ) : <EOL> yield r <EOL> def ResolveMulti ( self , subject , attributes , timestamp = None , <EOL> limit = None , token = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . security_manager . CheckDataStoreAccess ( <EOL> token , [ subject ] , self . GetRequiredResolveAccess ( attributes ) ) <EOL> results = [ ] <EOL> start , end = self . _GetStartEndTimestamp ( timestamp ) <EOL> with self . cache . Get ( subject ) as sqlite_connection : <EOL> for attribute in attributes : <EOL> if timestamp == self . NEWEST_TIMESTAMP : <EOL> ret = sqlite_connection . GetNewestValue ( subject , attribute ) <EOL> if ret : <EOL> value , ts = ret <EOL> value = self . _Decode ( attribute , value ) <EOL> results . append ( ( attribute , value , ts ) ) <EOL> if limit and len ( results ) >= limit : <EOL> break <EOL> else : <EOL> new_limit = limit <EOL> if new_limit : <EOL> new_limit = limit - len ( results ) <EOL> values = sqlite_connection . GetValues ( subject , attribute , start , end , <EOL> new_limit ) <EOL> for value , ts in values : <EOL> value = self . _Decode ( attribute , value ) <EOL> results . append ( ( attribute , value , ts ) ) <EOL> if limit and len ( results ) >= limit : <EOL> break <EOL> return results <EOL> def DumpDatabase ( self , token = None ) : <EOL> self . security_manager . CheckDataStoreAccess ( token , [ ] , \"<STR_LIT:r>\" ) <EOL> for _ , sql_connection in self . cache : <EOL> sql_connection . PrettyPrint ( ) <EOL> def Size ( self ) : <EOL> root_path = self . Location ( ) <EOL> if not os . path . exists ( root_path ) : <EOL> return <NUM_LIT:0> <EOL> if not os . path . isdir ( root_path ) : <EOL> raise IOError ( \"<STR_LIT>\" % <EOL> root_path ) <EOL> size , _ = common . DatabaseDirectorySize ( root_path , self . FileExtension ( ) ) <EOL> return size <EOL> @ staticmethod <EOL> def FileExtension ( ) : <EOL> return SQLITE_EXTENSION <EOL> def Location ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . cache . RootPath ( ) <EOL> def ChangeLocation ( self , location ) : <EOL> self . cache . ChangePath ( location ) <EOL> def Transaction ( self , subject , lease_time = None , token = None ) : <EOL> return SqliteTransaction ( self , subject , lease_time = lease_time , token = token ) <EOL> class SqliteTransaction ( data_store . CommonTransaction ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> lock_creation_lock = threading . Lock ( ) <EOL> locked = False <EOL> def __init__ ( self , store , subject , lease_time = None , token = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( SqliteTransaction , self ) . __init__ ( store , utils . SmartUnicode ( subject ) , <EOL> lease_time = lease_time , token = token ) <EOL> if lease_time is None : <EOL> lease_time = config_lib . CONFIG [ \"<STR_LIT>\" ] <EOL> self . lock_token = thread . get_ident ( ) <EOL> sqlite_connection = store . cache . Get ( self . subject ) <EOL> with sqlite_connection : <EOL> locked_until , stored_token = sqlite_connection . GetLock ( subject ) <EOL> if locked_until and time . time ( ) < float ( locked_until ) : <EOL> raise data_store . TransactionError ( \"<STR_LIT>\" % subject ) <EOL> self . expires = time . time ( ) + lease_time <EOL> sqlite_connection . SetLock ( subject , self . expires , self . lock_token ) <EOL> locked_until , stored_token = sqlite_connection . GetLock ( subject ) <EOL> if stored_token != self . lock_token : <EOL> raise data_store . TransactionError ( \"<STR_LIT>\" % subject ) <EOL> self . locked = True <EOL> def UpdateLease ( self , duration ) : <EOL> self . expires = time . time ( ) + duration <EOL> with self . store . cache . Get ( self . subject ) as sqlite_connection : <EOL> self . expires = time . time ( ) + duration <EOL> sqlite_connection . SetLock ( self . subject , self . expires , self . lock_token ) <EOL> def Abort ( self ) : <EOL> if self . locked : <EOL> self . _RemoveLock ( ) <EOL> def Commit ( self ) : <EOL> if self . locked : <EOL> super ( SqliteTransaction , self ) . Commit ( ) <EOL> self . _RemoveLock ( ) <EOL>", "answer": "def _RemoveLock ( self ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import copy <EOL> from datetime import datetime <EOL> from django . forms import ( <EOL> CharField , FileInput , MultipleChoiceField , MultiValueField , MultiWidget , <EOL> RadioSelect , SelectMultiple , SplitDateTimeField , SplitDateTimeWidget , <EOL> TextInput , <EOL> ) <EOL> from . base import WidgetTest <EOL> class MyMultiWidget ( MultiWidget ) : <EOL> def decompress ( self , value ) : <EOL> if value : <EOL> return value . split ( '<STR_LIT>' ) <EOL> return [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> class ComplexMultiWidget ( MultiWidget ) : <EOL> def __init__ ( self , attrs = None ) : <EOL> widgets = ( <EOL> TextInput ( ) , <EOL> SelectMultiple ( choices = WidgetTest . beatles ) , <EOL> SplitDateTimeWidget ( ) , <EOL> ) <EOL> super ( ComplexMultiWidget , self ) . __init__ ( widgets , attrs ) <EOL> def decompress ( self , value ) : <EOL> if value : <EOL> data = value . split ( '<STR_LIT:U+002C>' ) <EOL>", "answer": "return ["}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from pyasn1_modules . rfc2437 import * <EOL> class OtherPrimeInfo ( univ . Sequence ) : <EOL> componentType = namedtype . NamedTypes ( <EOL> namedtype . NamedType ( '<STR_LIT>' , univ . Integer ( ) ) , <EOL> namedtype . NamedType ( '<STR_LIT>' , univ . Integer ( ) ) , <EOL> namedtype . NamedType ( '<STR_LIT>' , univ . Integer ( ) ) <EOL>", "answer": ")"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import api <EOL> import random <EOL> import imp <EOL> import shutil <EOL> import os <EOL> from os import path <EOL> from functools import partial <EOL> from bson import json_util <EOL> from api . common import InternalException , SevereInternalException <EOL> log = api . logger . use ( __name__ ) <EOL> modifiable_problem_fields = [ \"<STR_LIT:description>\" ] <EOL> seed = \"<STR_LIT>\" <EOL> def is_autogen_problem ( pid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return api . problem . get_problem ( pid = pid ) . get ( \"<STR_LIT>\" , False ) <EOL> def get_metadata_path ( pid , n ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return path . join ( get_instance_path ( pid , n = n , public = False ) , \"<STR_LIT>\" ) <EOL> def write_metadata ( pid , n , data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> metadata_path = get_metadata_path ( pid , n ) <EOL> with open ( metadata_path , \"<STR_LIT:w>\" ) as f : <EOL> f . write ( json_util . dumps ( data ) ) <EOL> @ api . cache . memoize ( timeout = <NUM_LIT> , fast = True ) <EOL> def read_metadata ( pid , n ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> metadata_path = get_metadata_path ( pid , n ) <EOL> with open ( metadata_path , \"<STR_LIT:r>\" ) as f : <EOL> return json_util . loads ( f . read ( ) ) <EOL> def build_problem_instances ( pid , instances ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> problem = api . problem . get_problem ( pid = pid ) <EOL> if not is_autogen_problem ( pid ) : <EOL> raise InternalException ( \"<STR_LIT>\" . format ( problem [ \"<STR_LIT:name>\" ] ) ) <EOL> previous_state = seed_generator ( \"<STR_LIT>\" , pid ) <EOL> instance_path , static_instance_path = get_instance_path ( pid ) , get_static_instance_path ( pid ) <EOL> for autogen_path in [ instance_path , static_instance_path ] : <EOL> log . debug ( \"<STR_LIT>\" , autogen_path ) <EOL> if not path . isdir ( autogen_path ) : <EOL> log . debug ( \"<STR_LIT>\" ) <EOL> os . makedirs ( autogen_path ) <EOL> for n in range ( instances ) : <EOL> log . debug ( \"<STR_LIT>\" , problem [ \"<STR_LIT:name>\" ] , str ( n ) ) <EOL> build = get_generator ( pid ) . generate ( random , pid , api . autogen_tools , n ) <EOL> autogen_instance_path = get_instance_path ( pid , n = n ) <EOL> file_type_paths = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : get_instance_path ( pid , n = n , public = True ) , <EOL> \"<STR_LIT>\" : get_instance_path ( pid , n = n , public = False ) <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : get_static_instance_path ( pid , public = True ) , <EOL> \"<STR_LIT>\" : get_static_instance_path ( pid , public = False ) <EOL> } <EOL> } <EOL> for _ , file_types in file_type_paths . items ( ) : <EOL> for _ , autogen_path in file_types . items ( ) : <EOL> if not path . isdir ( autogen_path ) : <EOL> os . makedirs ( autogen_path ) <EOL> problem_updates = build . get ( \"<STR_LIT>\" , None ) <EOL> if problem_updates is None : <EOL> raise InternalException ( \"<STR_LIT>\" . format ( problem [ \"<STR_LIT>\" ] ) ) <EOL> write_metadata ( pid , n , problem_updates ) <EOL> for file_type , listings in build . items ( ) : <EOL> destination_type = file_type_paths . get ( file_type , None ) <EOL> if destination_type is not None : <EOL> for listing in listings : <EOL> destination = destination_type . get ( listing , None ) <EOL> if destination is not None : <EOL> files = listings [ listing ] <EOL> for f , name in files : <EOL> if path . isfile ( f ) : <EOL> shutil . copyfile ( f , path . join ( destination , name ) ) <EOL> elif path . isdir ( f ) : <EOL> shutil . copytree ( f , autogen_instance_path ) <EOL> api . autogen_tools . clear_build_directories ( ) <EOL> log . debug ( \"<STR_LIT>\" ) <EOL> random . setstate ( previous_state ) <EOL> def get_generator_path ( pid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> problem = api . problem . get_problem ( pid = pid ) <EOL> if not is_autogen_problem ( pid ) : <EOL> raise InternalException ( \"<STR_LIT>\" ) <EOL> if not problem . get ( \"<STR_LIT>\" , False ) : <EOL> raise InternalException ( \"<STR_LIT>\" . format ( problem [ \"<STR_LIT:name>\" ] ) ) <EOL> return path . join ( api . problem . grader_base_path , problem [ \"<STR_LIT>\" ] ) <EOL> def get_generator ( pid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> generator_path = get_generator_path ( pid ) <EOL> if not path . isfile ( generator_path ) : <EOL> raise InternalException ( \"<STR_LIT>\" . format ( generator_path ) ) <EOL> return imp . load_source ( generator_path [ : - <NUM_LIT:3> ] , generator_path ) <EOL> def get_seed ( pid , tid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return seed + tid + pid <EOL> def seed_generator ( pid , tid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> previous_state = random . getstate ( ) <EOL> random . seed ( get_seed ( pid , tid ) ) <EOL> return previous_state <EOL> @ api . cache . memoize ( timeout = <NUM_LIT> , fast = True ) <EOL> def get_instance_number ( pid , tid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> previous_state = seed_generator ( tid , pid ) <EOL> total_instances = get_number_of_instances ( pid ) <EOL> if total_instances == <NUM_LIT:0> : <EOL> raise InternalException ( \"<STR_LIT>\" . format ( pid ) ) <EOL> instance_number = random . randint ( <NUM_LIT:0> , total_instances - <NUM_LIT:1> ) <EOL> random . setstate ( previous_state ) <EOL> return instance_number <EOL> @ api . cache . memoize ( timeout = <NUM_LIT> , fast = True ) <EOL> def get_number_of_instances ( pid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> return [ dirname . isdigit ( ) for dirname in os . listdir ( get_instance_path ( pid , public = False ) ) ] . count ( True ) <EOL> except FileNotFoundError : <EOL> raise InternalException ( \"<STR_LIT>\" ) <EOL> def get_static_instance_path ( pid , public = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return path . abspath ( path . join ( get_instance_path ( pid , public = public ) , \"<STR_LIT>\" ) ) <EOL> def get_instance_path ( pid , n = \"<STR_LIT>\" , public = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> generator_path = get_generator_path ( pid ) <EOL> name = api . problem . get_problem ( pid ) [ \"<STR_LIT:name>\" ] <EOL> instance_path = path . join ( path . dirname ( generator_path ) , \"<STR_LIT>\" , name , str ( n ) ) <EOL> if public : <EOL> instance_path = path . join ( instance_path , \"<STR_LIT>\" ) <EOL> return path . abspath ( instance_path ) <EOL> @ api . cache . memoize ( timeout = <NUM_LIT> , fast = True ) <EOL> def get_problem_instance ( pid , tid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> problem = api . problem . get_problem ( pid = pid ) <EOL> n = get_instance_number ( pid , tid ) <EOL> metadata = read_metadata ( pid , n ) <EOL> if not set ( metadata ) . issubset ( modifiable_problem_fields ) : <EOL> invalid_keys = set ( metadata ) . difference ( modifiable_problem_fields ) <EOL> raise InternalException ( \"<STR_LIT>\" . format ( pid , invalid_keys ) ) <EOL> problem . update ( metadata ) <EOL> return problem <EOL> def grade_problem_instance ( pid , tid , key ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not is_autogen_problem ( pid ) : <EOL> raise InternalException ( \"<STR_LIT>\" . format ( pid ) ) <EOL> problem = api . problem . get_problem ( pid ) <EOL> n = get_instance_number ( pid , tid ) <EOL> grader_problem_instance = GraderProblemInstance ( pid , tid , n ) <EOL> grader = api . problem . get_grader ( pid ) <EOL> try : <EOL> correct , message = grader . grade ( grader_problem_instance , key ) <EOL> except Exception as e : <EOL> raise SevereInternalException ( \"<STR_LIT>\" . format ( pid , str ( e ) ) ) <EOL> return { <EOL> \"<STR_LIT>\" : correct , <EOL>", "answer": "\"<STR_LIT>\" : problem [ \"<STR_LIT>\" ] ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> from docopt import docopt <EOL> from iepy . data . db import DocumentManager <EOL> from iepy . preprocess . stanford_preprocess import StanfordPreprocess <EOL> from iepy . preprocess . pipeline import PreProcessPipeline <EOL>", "answer": "from iepy . preprocess . segmenter import SyntacticSegmenterRunner"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from settings import * <EOL> INSTALLED_APPS . append ( '<STR_LIT>' ) <EOL> DATABASES = { <EOL> '<STR_LIT:default>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' : DATABASE_NAME ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from __future__ import unicode_literals <EOL> from . import Extension <EOL> from . . preprocessors import Preprocessor <EOL> from . . inlinepatterns import Pattern <EOL> from . . treeprocessors import Treeprocessor <EOL> from . . postprocessors import Postprocessor <EOL> from . . util import etree , text_type <EOL> from . . odict import OrderedDict <EOL> import re <EOL> FN_BACKLINK_TEXT = \"<STR_LIT>\" <EOL> NBSP_PLACEHOLDER = \"<STR_LIT>\" <EOL> DEF_RE = re . compile ( r'<STR_LIT>' ) <EOL> TABBED_RE = re . compile ( r'<STR_LIT>' ) <EOL> class FootnoteExtension ( Extension ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . config = { <EOL> '<STR_LIT>' : <EOL> [ \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] , <EOL> '<STR_LIT>' : <EOL> [ False , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : <EOL> [ \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ] <EOL> } <EOL> super ( FootnoteExtension , self ) . __init__ ( * args , ** kwargs ) <EOL> self . unique_prefix = <NUM_LIT:0> <EOL> self . reset ( ) <EOL> def extendMarkdown ( self , md , md_globals ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> md . registerExtension ( self ) <EOL> self . parser = md . parser <EOL> self . md = md <EOL> md . preprocessors . add ( <EOL> \"<STR_LIT>\" , FootnotePreprocessor ( self ) , \"<STR_LIT>\" <EOL> ) <EOL> FOOTNOTE_RE = r'<STR_LIT>' <EOL> md . inlinePatterns . add ( <EOL> \"<STR_LIT>\" , FootnotePattern ( FOOTNOTE_RE , self ) , \"<STR_LIT>\" <EOL> ) <EOL> md . treeprocessors . add ( <EOL> \"<STR_LIT>\" , FootnoteTreeprocessor ( self ) , \"<STR_LIT>\" <EOL> ) <EOL> md . postprocessors . add ( <EOL> \"<STR_LIT>\" , FootnotePostprocessor ( self ) , \"<STR_LIT>\" <EOL> ) <EOL> def reset ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . footnotes = OrderedDict ( ) <EOL> self . unique_prefix += <NUM_LIT:1> <EOL> def findFootnotesPlaceholder ( self , root ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def finder ( element ) : <EOL> for child in element : <EOL> if child . text : <EOL> if child . text . find ( self . getConfig ( \"<STR_LIT>\" ) ) > - <NUM_LIT:1> : <EOL> return child , element , True <EOL> if child . tail : <EOL> if child . tail . find ( self . getConfig ( \"<STR_LIT>\" ) ) > - <NUM_LIT:1> : <EOL> return child , element , False <EOL> child_res = finder ( child ) <EOL> if child_res is not None : <EOL> return child_res <EOL> return None <EOL> res = finder ( root ) <EOL> return res <EOL> def setFootnote ( self , id , text ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . footnotes [ id ] = text <EOL> def get_separator ( self ) : <EOL> if self . md . output_format in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return '<STR_LIT:->' <EOL> return '<STR_LIT::>' <EOL> def makeFootnoteId ( self , id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . getConfig ( \"<STR_LIT>\" ) : <EOL>", "answer": "return '<STR_LIT>' % ( self . get_separator ( ) , self . unique_prefix , id )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . utils . translation import ugettext_lazy as _ <EOL> from horizon import tabs <EOL> class NetworkProfileTab ( tabs . Tab ) : <EOL> name = _ ( \"<STR_LIT>\" ) <EOL> slug = \"<STR_LIT>\" <EOL> template_name = '<STR_LIT>' <EOL>", "answer": "def get_context_data ( self , request ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . utils . translation import ugettext as _ <EOL> SPELLCHECK_LOCALIZATION = { <EOL>", "answer": "'<STR_LIT>' : _ ( '<STR_LIT>' ) ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import sys <EOL>", "answer": "os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "class V2_0Constants ( object ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from uliweb . core . js import simple_value , json_dumps <EOL> from uliweb . core . html import * <EOL> from uliweb . core . html import to_attrs <EOL> def test_simple_value ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testto_attrs ( ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import io <EOL> import logging <EOL> import os <EOL> import subprocess <EOL> import sys <EOL> import tempfile <EOL> from jinja2 import Template <EOL> from cookiecutter import utils <EOL> _HOOKS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> def find_hooks ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> hooks_dir = '<STR_LIT>' <EOL> r = { } <EOL> logging . debug ( '<STR_LIT>' . format ( hooks_dir ) ) <EOL> if not os . path . isdir ( hooks_dir ) : <EOL> logging . debug ( '<STR_LIT>' ) <EOL> return r <EOL> for f in os . listdir ( hooks_dir ) : <EOL> basename = os . path . splitext ( os . path . basename ( f ) ) [ <NUM_LIT:0> ] <EOL> if basename in _HOOKS : <EOL> r [ basename ] = os . path . abspath ( os . path . join ( hooks_dir , f ) ) <EOL> return r <EOL> def run_script ( script_path , cwd = '<STR_LIT:.>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> run_thru_shell = sys . platform . startswith ( '<STR_LIT>' ) <EOL> if script_path . endswith ( '<STR_LIT>' ) : <EOL> script_command = [ sys . executable , script_path ] <EOL> else : <EOL> script_command = [ script_path ] <EOL> utils . make_executable ( script_path ) <EOL> proc = subprocess . Popen ( <EOL> script_command , <EOL> shell = run_thru_shell , <EOL> cwd = cwd <EOL> ) <EOL> proc . wait ( ) <EOL> def run_script_with_context ( script_path , cwd , context ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _ , extension = os . path . splitext ( script_path ) <EOL> contents = io . open ( script_path , '<STR_LIT:r>' , encoding = '<STR_LIT:utf-8>' ) . read ( ) <EOL>", "answer": "with tempfile . NamedTemporaryFile ("}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from . ellipticcurve import CurveFp , Point <EOL> _a = <NUM_LIT> <EOL> _b = <NUM_LIT> <EOL> _p = <NUM_LIT> <EOL> _Gx = <NUM_LIT> <EOL> _Gy = <NUM_LIT> <EOL> _r = <NUM_LIT> <EOL>", "answer": "generator_secp256k1 = Point ( CurveFp ( _p , _a , _b ) , _Gx , _Gy , _r ) "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from base64 import b16encode , b16decode <EOL> from django . core . urlresolvers import reverse <EOL> from django . http import HttpResponseNotAllowed <EOL> from django . test import RequestFactory <EOL> from spam . views import ReportSpamCreateView <EOL> from test_plus . test import TestCase <EOL> from test_app . models import Data <EOL>", "answer": "from test_app . views import DataDetailView"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import pytest <EOL> from tests . helpers import ui , init_tiny_room <EOL> def travel_to_the_next_level ( ui ) : <EOL> ui . say ( \"<STR_LIT:i>\" ) <EOL>", "answer": "ui . say ( \"<STR_LIT:l>\" )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> def deepCopy ( dataOb ) : <EOL> newData = dataObject . NewInstance ( ) <EOL> newData . DeepCopy ( dataObj ) <EOL> return newData <EOL> def shallowCopy ( dataObj ) : <EOL>", "answer": "newData = dataObj . NewInstance ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os . path <EOL> from django . core . urlresolvers import reverse <EOL> from django . template import Context , Template <EOL> from django . template . defaultfilters import slugify <EOL> from django . test import TestCase <EOL> from django . test . client import Client <EOL> from radpress . compat import get_user_model <EOL> User = get_user_model ( ) <EOL> from radpress . models import Article , Page , Tag <EOL> from radpress . readers import get_reader <EOL> from radpress . settings import CONTEXT_DATA , MORE_TAG <EOL> from radpress . templatetags . radpress_tags import radpress_get_url <EOL> class RadpressTestCase ( TestCase ) : <EOL> fixtures = [ os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT>' ) ] <EOL> def setUp ( self ) : <EOL> self . client = Client ( ) <EOL> self . article1 = Article . objects . get ( pk = <NUM_LIT:1> ) <EOL> self . user1 = User . objects . get ( username = '<STR_LIT>' ) <EOL> self . user1 . set_password ( '<STR_LIT>' ) <EOL> self . user1 . save ( ) <EOL> self . user2 = User . objects . get ( username = '<STR_LIT>' ) <EOL> self . user2 . set_password ( '<STR_LIT>' ) <EOL> self . user2 . save ( ) <EOL> def render_template ( self , template , context ) : <EOL> context = Context ( context ) <EOL> return Template ( template ) . render ( context ) <EOL> class RadpressReaderTestCase ( RadpressTestCase ) : <EOL> markup = None <EOL> file_path = None <EOL> def setUp ( self ) : <EOL> self . reader = get_reader ( markup = self . markup ) <EOL> if self . file_path is not None : <EOL> file_path = os . path . join ( os . path . dirname ( __file__ ) , self . file_path ) <EOL> content = open ( file_path ) . read ( ) <EOL> self . content_body , self . metadata = self . reader ( content ) . read ( ) <EOL> def test_check_metadata ( self ) : <EOL> self . assertEqual ( self . metadata [ '<STR_LIT:image>' ] , '<STR_LIT:1>' ) <EOL> self . assertTrue ( self . metadata [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( self . metadata [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( self . metadata [ '<STR_LIT:title>' ] , '<STR_LIT>' ) <EOL> for tag in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> self . assertIn ( tag , self . metadata [ '<STR_LIT>' ] ) <EOL> def test_contents ( self ) : <EOL> for article in Article . objects . filter ( markup = self . markup ) : <EOL> content_body , metadata = self . reader ( article . content ) . read ( ) <EOL> self . assertEqual ( article . content_body , content_body ) <EOL> def test_more_tag ( self ) : <EOL> self . assertIn ( MORE_TAG , self . content_body ) <EOL> class BaseTest ( RadpressTestCase ) : <EOL> def test_all_published_articles ( self ) : <EOL> self . assertEqual ( Article . objects . all_published ( ) . count ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( Page . objects . all_published ( ) . count ( ) , <NUM_LIT:2> ) <EOL> def test_open_private_and_public_article_details ( self ) : <EOL> for article in Article . objects . all ( ) : <EOL> status_code = <NUM_LIT:200> if article . is_published else <NUM_LIT> <EOL> response = self . client . get ( article . get_absolute_url ( ) ) <EOL> self . assertEqual ( response . status_code , status_code ) <EOL> def test_preview_page ( self ) : <EOL> response = self . client . get ( reverse ( '<STR_LIT>' ) ) <EOL> expected_status_code = <NUM_LIT> <EOL> self . assertEqual ( response . status_code , expected_status_code ) <EOL> self . client . login ( username = '<STR_LIT>' , password = '<STR_LIT>' ) <EOL> response = self . client . get ( reverse ( '<STR_LIT>' ) ) <EOL> expected_status_code = <NUM_LIT> <EOL> self . assertEqual ( response . status_code , expected_status_code ) <EOL> def test_slugs ( self ) : <EOL> for article in Article . objects . all ( ) : <EOL> slug = slugify ( article . slug ) <EOL> self . assertEqual ( article . slug , slug ) <EOL> def test_tags ( self ) : <EOL> self . assertEqual ( Tag . objects . count ( ) , <NUM_LIT:2> ) <EOL> tag_name = '<STR_LIT>' <EOL> tag = Tag . objects . create ( name = tag_name ) <EOL> self . assertEqual ( tag . slug , slugify ( tag_name ) ) <EOL> self . article1 . articletag_set . create ( tag = tag ) <EOL> self . assertEqual ( self . article1 . tags . count ( ) , <NUM_LIT:1> ) <EOL> articles = Article . objects . filter ( tags__name = tag_name ) <EOL> self . assertEqual ( articles . count ( ) , <NUM_LIT:1> ) <EOL> def test_access_not_published_article ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> article = Article . objects . get ( slug = '<STR_LIT>' ) <EOL> page = Page . objects . get ( slug = '<STR_LIT>' ) <EOL> def get_responses ( ) : <EOL> response_article = self . client . get ( <EOL> reverse ( '<STR_LIT>' , args = [ article . slug ] ) ) <EOL> response_page = self . client . get ( <EOL> reverse ( '<STR_LIT>' , args = [ page . slug ] ) ) <EOL> return response_article , response_page <EOL> response_article , response_page = get_responses ( ) <EOL> self . assertEqual ( response_article . status_code , <NUM_LIT> ) <EOL> self . assertEqual ( response_page . status_code , <NUM_LIT> ) <EOL> self . client . login ( username = self . user2 . username , password = '<STR_LIT>' ) <EOL> self . assertFalse ( self . user2 . is_superuser ) <EOL> response_article , response_page = get_responses ( ) <EOL> self . assertEqual ( response_article . status_code , <NUM_LIT> ) <EOL> self . assertEqual ( response_page . status_code , <NUM_LIT> ) <EOL> self . user2 . is_superuser = True <EOL> self . user2 . save ( ) <EOL> self . assertTrue ( self . user2 . is_superuser ) <EOL> response_article , response_page = get_responses ( ) <EOL>", "answer": "self . assertEqual ( response_article . status_code , <NUM_LIT:200> )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import unittest <EOL> from test . asserting . config_source import ConfigSourceAssertion <EOL> from test . asserting . config_source import get_fixture_path <EOL> from vint . linting . config . config_file_source import ConfigFileSource <EOL> from vint . linting . level import Level <EOL> FIXTURE_CONFIG_FILE = get_fixture_path ( '<STR_LIT>' ) <EOL> class TestConfigFileSource ( ConfigSourceAssertion , unittest . TestCase ) : <EOL> class ConcreteConfigFileSource ( ConfigFileSource ) : <EOL> def get_file_path ( self , env ) : <EOL> return FIXTURE_CONFIG_FILE <EOL> def test_get_config_dict ( self ) : <EOL> expected_config_dict = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : Level . WARNING , <EOL> '<STR_LIT>' : <NUM_LIT:10> , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : True , <EOL> } , <EOL> } <EOL> } <EOL> config_source = self . initialize_config_source_with_env ( <EOL>", "answer": "TestConfigFileSource . ConcreteConfigFileSource )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from dj . choices import Choices <EOL> from django import forms <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> class RecordType ( Choices ) : <EOL> _ = Choices . Choice <EOL> a = _ ( '<STR_LIT:A>' ) <EOL> txt = _ ( '<STR_LIT>' ) <EOL> cname = _ ( '<STR_LIT>' ) <EOL> class DNSRecordForm ( forms . Form ) : <EOL> pk = forms . IntegerField ( <EOL> label = '<STR_LIT>' , <EOL>", "answer": "widget = forms . HiddenInput ( ) ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import markdown <EOL> import re <EOL> from urlparse import urlparse , urlunparse <EOL> import sys <EOL> if sys . version >= \"<STR_LIT>\" : <EOL> from html import entities as htmlentitydefs <EOL> else : <EOL> import htmlentitydefs <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> NOBRACKET = r'<STR_LIT>' <EOL> BRK = ( r'<STR_LIT>' <EOL> + ( NOBRACKET + r'<STR_LIT>' ) * <NUM_LIT:6> <EOL> + ( NOBRACKET + r'<STR_LIT>' ) * <NUM_LIT:6> <EOL> + NOBRACKET + r'<STR_LIT>' ) <EOL> NOIMG = r'<STR_LIT>' <EOL> BACKTICK_RE = r'<STR_LIT>' <EOL> ESCAPE_RE = r'<STR_LIT>' <EOL> EMPHASIS_RE = r'<STR_LIT>' <EOL> STRONG_RE = r'<STR_LIT>' <EOL> STRONG_EM_RE = r'<STR_LIT>' <EOL> if markdown . SMART_EMPHASIS : <EOL> EMPHASIS_2_RE = r'<STR_LIT>' <EOL> else : <EOL> EMPHASIS_2_RE = r'<STR_LIT>' <EOL> LINK_RE = NOIMG + BRK + r'''<STR_LIT>''' <EOL> IMAGE_LINK_RE = r'<STR_LIT>' + BRK + r'<STR_LIT>' <EOL> REFERENCE_RE = NOIMG + BRK + r'<STR_LIT>' <EOL> IMAGE_REFERENCE_RE = r'<STR_LIT>' + BRK + '<STR_LIT>' <EOL> NOT_STRONG_RE = r'<STR_LIT>' <EOL> AUTOLINK_RE = r'<STR_LIT>' <EOL> AUTOMAIL_RE = r'<STR_LIT>' <EOL> HTML_RE = r'<STR_LIT>' <EOL> ENTITY_RE = r'<STR_LIT>' <EOL> LINE_BREAK_RE = r'<STR_LIT>' <EOL> LINE_BREAK_2_RE = r'<STR_LIT>' <EOL> def dequote ( string ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ( ( string . startswith ( '<STR_LIT:\">' ) and string . endswith ( '<STR_LIT:\">' ) ) <EOL> or ( string . startswith ( \"<STR_LIT:'>\" ) and string . endswith ( \"<STR_LIT:'>\" ) ) ) : <EOL> return string [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> else : <EOL> return string <EOL> ATTR_RE = re . compile ( \"<STR_LIT>\" ) <EOL> def handleAttributes ( text , parent ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def attributeCallback ( match ) : <EOL> parent . set ( match . group ( <NUM_LIT:1> ) , match . group ( <NUM_LIT:2> ) . replace ( '<STR_LIT:\\n>' , '<STR_LIT:U+0020>' ) ) <EOL> return ATTR_RE . sub ( attributeCallback , text ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class Pattern : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , pattern , markdown_instance = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . pattern = pattern <EOL> self . compiled_re = re . compile ( \"<STR_LIT>\" % pattern , re . DOTALL ) <EOL> self . safe_mode = False <EOL> if markdown_instance : <EOL> self . markdown = markdown_instance <EOL> def getCompiledRegExp ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . compiled_re <EOL> def handleMatch ( self , m ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> def type ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . __class__ . __name__ <EOL> BasePattern = Pattern <EOL> class SimpleTextPattern ( Pattern ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def handleMatch ( self , m ) : <EOL> text = m . group ( <NUM_LIT:2> ) <EOL> if text == markdown . INLINE_PLACEHOLDER_PREFIX : <EOL> return None <EOL> return text <EOL> class SimpleTagPattern ( Pattern ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , pattern , tag ) : <EOL> Pattern . __init__ ( self , pattern ) <EOL> self . tag = tag <EOL> def handleMatch ( self , m ) : <EOL> el = markdown . etree . Element ( self . tag ) <EOL> el . text = m . group ( <NUM_LIT:3> ) <EOL> return el <EOL> class SubstituteTagPattern ( SimpleTagPattern ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def handleMatch ( self , m ) : <EOL> return markdown . etree . Element ( self . tag ) <EOL> class BacktickPattern ( Pattern ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , pattern ) : <EOL> Pattern . __init__ ( self , pattern ) <EOL> self . tag = \"<STR_LIT:code>\" <EOL> def handleMatch ( self , m ) : <EOL> el = markdown . etree . Element ( self . tag ) <EOL> el . text = markdown . AtomicString ( m . group ( <NUM_LIT:3> ) . strip ( ) ) <EOL> return el <EOL> class DoubleTagPattern ( SimpleTagPattern ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def handleMatch ( self , m ) : <EOL> tag1 , tag2 = self . tag . split ( \"<STR_LIT:U+002C>\" ) <EOL> el1 = markdown . etree . Element ( tag1 ) <EOL> el2 = markdown . etree . SubElement ( el1 , tag2 ) <EOL> el2 . text = m . group ( <NUM_LIT:3> ) <EOL> return el1 <EOL> class HtmlPattern ( Pattern ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def handleMatch ( self , m ) : <EOL> rawhtml = m . group ( <NUM_LIT:2> ) <EOL> inline = True <EOL> place_holder = self . markdown . htmlStash . store ( rawhtml ) <EOL> return place_holder <EOL> class LinkPattern ( Pattern ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def handleMatch ( self , m ) : <EOL> el = markdown . etree . Element ( \"<STR_LIT:a>\" ) <EOL> el . text = m . group ( <NUM_LIT:2> ) <EOL> title = m . group ( <NUM_LIT:11> ) <EOL> href = m . group ( <NUM_LIT:9> ) <EOL> if href : <EOL> if href [ <NUM_LIT:0> ] == \"<STR_LIT:<>\" : <EOL> href = href [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> el . set ( \"<STR_LIT>\" , self . sanitize_url ( href . strip ( ) ) ) <EOL> else : <EOL> el . set ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if title : <EOL> title = dequote ( title ) <EOL> el . set ( \"<STR_LIT:title>\" , title ) <EOL> return el <EOL> def sanitize_url ( self , url ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> locless_schemes = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> scheme , netloc , path , params , query , fragment = url = urlparse ( url ) <EOL> safe_url = False <EOL> if netloc != '<STR_LIT>' or scheme in locless_schemes : <EOL> safe_url = True <EOL> for part in url [ <NUM_LIT:2> : ] : <EOL> if \"<STR_LIT::>\" in part : <EOL> safe_url = False <EOL> if self . markdown . safeMode and not safe_url : <EOL> return '<STR_LIT>' <EOL> else : <EOL> return urlunparse ( url ) <EOL> class ImagePattern ( LinkPattern ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def handleMatch ( self , m ) : <EOL> el = markdown . etree . Element ( \"<STR_LIT>\" ) <EOL> src_parts = m . group ( <NUM_LIT:9> ) . split ( ) <EOL> if src_parts : <EOL> src = src_parts [ <NUM_LIT:0> ] <EOL> if src [ <NUM_LIT:0> ] == \"<STR_LIT:<>\" and src [ - <NUM_LIT:1> ] == \"<STR_LIT:>>\" : <EOL> src = src [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> el . set ( '<STR_LIT:src>' , self . sanitize_url ( src ) ) <EOL> else : <EOL> el . set ( '<STR_LIT:src>' , \"<STR_LIT>\" ) <EOL> if len ( src_parts ) > <NUM_LIT:1> : <EOL> el . set ( '<STR_LIT:title>' , dequote ( \"<STR_LIT:U+0020>\" . join ( src_parts [ <NUM_LIT:1> : ] ) ) ) <EOL> if markdown . ENABLE_ATTRIBUTES : <EOL> truealt = handleAttributes ( m . group ( <NUM_LIT:2> ) , el ) <EOL> else : <EOL> truealt = m . group ( <NUM_LIT:2> ) <EOL> el . set ( '<STR_LIT>' , truealt ) <EOL> return el <EOL> class ReferencePattern ( LinkPattern ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def handleMatch ( self , m ) : <EOL> if m . group ( <NUM_LIT:9> ) : <EOL> id = m . group ( <NUM_LIT:9> ) . lower ( ) <EOL> else : <EOL> id = m . group ( <NUM_LIT:2> ) . lower ( ) <EOL> if not id in self . markdown . references : <EOL> return None <EOL> href , title = self . markdown . references [ id ] <EOL> text = m . group ( <NUM_LIT:2> ) <EOL> return self . makeTag ( href , title , text ) <EOL> def makeTag ( self , href , title , text ) : <EOL> el = markdown . etree . Element ( '<STR_LIT:a>' ) <EOL> el . set ( '<STR_LIT>' , self . sanitize_url ( href ) ) <EOL> if title : <EOL> el . set ( '<STR_LIT:title>' , title ) <EOL> el . text = text <EOL> return el <EOL> class ImageReferencePattern ( ReferencePattern ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def makeTag ( self , href , title , text ) : <EOL> el = markdown . etree . Element ( \"<STR_LIT>\" ) <EOL> el . set ( \"<STR_LIT:src>\" , self . sanitize_url ( href ) ) <EOL> if title : <EOL> el . set ( \"<STR_LIT:title>\" , title ) <EOL> el . set ( \"<STR_LIT>\" , text ) <EOL> return el <EOL> class AutolinkPattern ( Pattern ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def handleMatch ( self , m ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = <NUM_LIT:11>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from errno import ENOENT <EOL> from stat import S_IFDIR , S_IFREG , S_IFLNK <EOL> from sys import argv , exit <EOL> import re <EOL> import time <EOL> import os <EOL> import argparse <EOL> from fuse import FUSE , FuseOSError , Operations , LoggingMixIn , fuse_get_context <EOL> from bioblend import galaxy <EOL> CACHE_TIME = <NUM_LIT:3> <EOL> def path_type ( path ) : <EOL> parts = filter ( lambda x : len ( x ) > <NUM_LIT:0> , path . split ( '<STR_LIT:/>' ) ) <EOL> if path == '<STR_LIT:/>' : <EOL> return ( '<STR_LIT:root>' , dict ( ) ) <EOL> elif path == '<STR_LIT>' : <EOL> return ( '<STR_LIT>' , dict ( ) ) <EOL> elif len ( parts ) == <NUM_LIT:2> and parts [ <NUM_LIT:0> ] == '<STR_LIT>' : <EOL> return ( '<STR_LIT>' , dict ( h_name = unesc_filename ( parts [ <NUM_LIT:1> ] ) ) ) <EOL> elif len ( parts ) == <NUM_LIT:3> and parts [ <NUM_LIT:0> ] == '<STR_LIT>' : <EOL> return ( '<STR_LIT:data>' , dict ( h_name = unesc_filename ( parts [ <NUM_LIT:1> ] ) , ds_name = unesc_filename ( parts [ <NUM_LIT:2> ] ) ) ) <EOL> print \"<STR_LIT>\" % path <EOL> return ( '<STR_LIT>' , <NUM_LIT:0> ) <EOL> def esc_filename ( fname ) : <EOL> def esc ( m ) : <EOL> c = m . group ( <NUM_LIT:0> ) <EOL> if c == '<STR_LIT:%>' : <EOL> return '<STR_LIT>' <EOL> elif c == '<STR_LIT:/>' : <EOL> return '<STR_LIT>' <EOL> return re . sub ( r'<STR_LIT>' , esc , fname ) <EOL> def unesc_filename ( fname ) : <EOL> def unesc ( m ) : <EOL> str = m . group ( <NUM_LIT:0> ) <EOL> if str == '<STR_LIT>' : <EOL> return '<STR_LIT:%>' <EOL> elif str == '<STR_LIT>' : <EOL> return '<STR_LIT:/>' <EOL> return re . sub ( r'<STR_LIT>' , unesc , fname ) <EOL> def parse_name_with_id ( fname ) : <EOL> m = re . match ( r\"<STR_LIT>\" , fname ) <EOL> if m is not None : <EOL> return ( m . group ( '<STR_LIT:name>' ) , m . group ( '<STR_LIT:id>' ) ) <EOL> else : <EOL> return ( fname , '<STR_LIT>' ) <EOL> class Context ( LoggingMixIn , Operations ) : <EOL> '<STR_LIT>' <EOL> def __init__ ( self , api_key ) : <EOL> self . gi = galaxy . GalaxyInstance ( url = '<STR_LIT>' , key = api_key ) <EOL> self . datasets_cache = { } <EOL> self . histories_cache = { '<STR_LIT:time>' : None , '<STR_LIT>' : None } <EOL> def getattr ( self , path , fh = None ) : <EOL> ( typ , kw ) = path_type ( path ) <EOL> now = time . time ( ) <EOL> if typ == '<STR_LIT:root>' or typ == '<STR_LIT>' : <EOL> st = dict ( st_mode = ( S_IFDIR | <NUM_LIT:0> <NUM_LIT> ) , st_nlink = <NUM_LIT:2> ) <EOL> st [ '<STR_LIT>' ] = st [ '<STR_LIT>' ] = st [ '<STR_LIT>' ] = now <EOL> elif typ == '<STR_LIT>' : <EOL> st = dict ( st_mode = ( S_IFDIR | <NUM_LIT:0> <NUM_LIT> ) , st_nlink = <NUM_LIT:2> ) <EOL> st [ '<STR_LIT>' ] = st [ '<STR_LIT>' ] = st [ '<STR_LIT>' ] = now <EOL>", "answer": "elif typ == '<STR_LIT:data>' :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys , re , operator , string , traceback <EOL> def extract_words ( path_to_file ) : <EOL> assert ( type ( path_to_file ) is str ) , \"<STR_LIT>\" <EOL> assert ( path_to_file ) , \"<STR_LIT>\" <EOL> try : <EOL> with open ( path_to_file ) as f : <EOL> str_data = f . read ( ) <EOL> except IOError as e : <EOL> print \"<STR_LIT>\" . format ( e . errno , path_to_file , e . strerror ) <EOL> raise e <EOL> pattern = re . compile ( '<STR_LIT>' ) <EOL> word_list = pattern . sub ( '<STR_LIT:U+0020>' , str_data ) . lower ( ) . split ( ) <EOL> return word_list <EOL> def remove_stop_words ( word_list ) : <EOL> assert ( type ( word_list ) is list ) , \"<STR_LIT>\" <EOL> try : <EOL> with open ( '<STR_LIT>' ) as f : <EOL> stop_words = f . read ( ) . split ( '<STR_LIT:U+002C>' ) <EOL> except IOError as e : <EOL> print \"<STR_LIT>\" . format ( e . errno , e . strerror ) <EOL> raise e <EOL> stop_words . extend ( list ( string . ascii_lowercase ) ) <EOL> return [ w for w in word_list if not w in stop_words ] <EOL> def frequencies ( word_list ) : <EOL> assert ( type ( word_list ) is list ) , \"<STR_LIT>\" <EOL> assert ( word_list < > [ ] ) , \"<STR_LIT>\" <EOL> word_freqs = { } <EOL> for w in word_list : <EOL> if w in word_freqs : <EOL> word_freqs [ w ] += <NUM_LIT:1> <EOL> else : <EOL> word_freqs [ w ] = <NUM_LIT:1> <EOL> return word_freqs <EOL> def sort ( word_freq ) : <EOL>", "answer": "assert ( type ( word_freq ) is dict ) , \"<STR_LIT>\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> import shutil <EOL> import zipfile <EOL> import tempfile <EOL> from django . contrib . gis import forms <EOL> from django . contrib . gis import gdal <EOL> from django . contrib . gis . gdal . srs import SpatialReference , SRSException <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from greenwich . geometry import Envelope <EOL> from spillway . compat import json <EOL> class CommaSepFloatField ( forms . FloatField ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> default_error_messages = { <EOL> '<STR_LIT>' : _ ( u'<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( u'<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( u'<STR_LIT>' ) , <EOL> } <EOL> def to_python ( self , value ) : <EOL> \"<STR_LIT>\" <EOL> if not value : <EOL> return [ ] <EOL> return map ( super ( CommaSepFloatField , self ) . to_python , value . split ( '<STR_LIT:U+002C>' ) ) <EOL> def run_validators ( self , values ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for val in values : <EOL> super ( CommaSepFloatField , self ) . run_validators ( val ) <EOL> class BoundingBoxField ( CommaSepFloatField ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , srid = <NUM_LIT> , * args , ** kwargs ) : <EOL> super ( BoundingBoxField , self ) . __init__ ( * args , ** kwargs ) <EOL> self . srid = srid <EOL> def to_python ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> value = super ( BoundingBoxField , self ) . to_python ( value ) <EOL> try : <EOL> bbox = gdal . OGRGeometry . from_bbox ( value ) . geos <EOL> except ( ValueError , AttributeError ) : <EOL> return [ ] <EOL>", "answer": "bbox . srid = self . srid"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import cmd <EOL> import sys <EOL> import getpass <EOL> import xmlrpclib <EOL> import socket <EOL> import errno <EOL> import urlparse <EOL> import threading <EOL> from supervisor . medusa import asyncore_25 as asyncore <EOL> from supervisor . options import ClientOptions <EOL> from supervisor . options import split_namespec <EOL> from supervisor import xmlrpc <EOL> from supervisor import states <EOL> class fgthread ( threading . Thread ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , program , ctl ) : <EOL> threading . Thread . __init__ ( self ) <EOL> import http_client <EOL> self . killed = False <EOL> self . program = program <EOL> self . ctl = ctl <EOL> self . listener = http_client . Listener ( ) <EOL> self . output_handler = http_client . HTTPHandler ( self . listener , <EOL> self . ctl . options . username , <EOL> self . ctl . options . password ) <EOL> self . error_handler = http_client . HTTPHandler ( self . listener , <EOL> self . ctl . options . username , <EOL> self . ctl . options . password ) <EOL> def start ( self ) : <EOL> self . __run_backup = self . run <EOL> self . run = self . __run <EOL> threading . Thread . start ( self ) <EOL> def run ( self ) : <EOL> self . output_handler . get ( self . ctl . options . serverurl , <EOL> '<STR_LIT>' % self . program ) <EOL> self . error_handler . get ( self . ctl . options . serverurl , <EOL> '<STR_LIT>' % self . program ) <EOL> asyncore . loop ( ) <EOL> def __run ( self ) : <EOL> sys . settrace ( self . globaltrace ) <EOL> self . __run_backup ( ) <EOL> self . run = self . __run_backup <EOL> def globaltrace ( self , frame , why , arg ) : <EOL> if why == '<STR_LIT>' : <EOL> return self . localtrace <EOL> else : <EOL> return None <EOL> def localtrace ( self , frame , why , arg ) : <EOL> if self . killed : <EOL> if why == '<STR_LIT>' : <EOL> raise SystemExit ( ) <EOL> return self . localtrace <EOL> def kill ( self ) : <EOL> self . output_handler . close ( ) <EOL> self . error_handler . close ( ) <EOL> self . killed = True <EOL> class Controller ( cmd . Cmd ) : <EOL> def __init__ ( self , options , completekey = '<STR_LIT>' , stdin = None , <EOL> stdout = None ) : <EOL> self . options = options <EOL> self . prompt = self . options . prompt + '<STR_LIT>' <EOL> self . options . plugins = [ ] <EOL> self . vocab = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT:start>' , '<STR_LIT>' , '<STR_LIT:version>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:status>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] <EOL> cmd . Cmd . __init__ ( self , completekey , stdin , stdout ) <EOL> for name , factory , kwargs in self . options . plugin_factories : <EOL> plugin = factory ( self , ** kwargs ) <EOL> self . options . plugins . append ( plugin ) <EOL> plugin . name = name <EOL> def emptyline ( self ) : <EOL> return <EOL> def onecmd ( self , line ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> origline = line <EOL> lines = line . split ( '<STR_LIT:;>' ) <EOL> line = lines . pop ( <NUM_LIT:0> ) <EOL> self . cmdqueue . extend ( lines ) <EOL> cmd , arg , line = self . parseline ( line ) <EOL> if not line : <EOL> return self . emptyline ( ) <EOL> if cmd is None : <EOL> return self . default ( line ) <EOL> self . lastcmd = line <EOL> if cmd == '<STR_LIT>' : <EOL> return self . default ( line ) <EOL> else : <EOL> do_func = self . _get_do_func ( cmd ) <EOL> if do_func is None : <EOL> return self . default ( line ) <EOL> try : <EOL> try : <EOL> return do_func ( arg ) <EOL> except xmlrpclib . ProtocolError , e : <EOL> if e . errcode == <NUM_LIT> : <EOL> if self . options . interactive : <EOL> self . output ( '<STR_LIT>' ) <EOL> username = raw_input ( '<STR_LIT>' ) <EOL> password = getpass . getpass ( prompt = '<STR_LIT>' ) <EOL> self . output ( '<STR_LIT>' ) <EOL> self . options . username = username <EOL> self . options . password = password <EOL> return self . onecmd ( origline ) <EOL> else : <EOL> self . options . usage ( '<STR_LIT>' ) <EOL> else : <EOL> raise <EOL> do_func ( arg ) <EOL> except SystemExit : <EOL> raise <EOL> except Exception , e : <EOL> ( file , fun , line ) , t , v , tbinfo = asyncore . compact_traceback ( ) <EOL> error = '<STR_LIT>' % ( t , v , file , line ) <EOL> self . output ( error ) <EOL> if not self . options . interactive : <EOL> sys . exit ( <NUM_LIT:2> ) <EOL> def _get_do_func ( self , cmd ) : <EOL> func_name = '<STR_LIT>' + cmd <EOL> func = getattr ( self , func_name , None ) <EOL> if not func : <EOL> for plugin in self . options . plugins : <EOL> func = getattr ( plugin , func_name , None ) <EOL> if func is not None : <EOL> break <EOL> return func <EOL> def output ( self , stuff ) : <EOL> if stuff is not None : <EOL> if isinstance ( stuff , unicode ) : <EOL> stuff = stuff . encode ( '<STR_LIT:utf-8>' ) <EOL> self . stdout . write ( stuff + '<STR_LIT:\\n>' ) <EOL> def get_supervisor ( self ) : <EOL> return self . get_server_proxy ( '<STR_LIT>' ) <EOL> def get_server_proxy ( self , namespace = None ) : <EOL> proxy = self . options . getServerProxy ( ) <EOL> if namespace is None : <EOL> return proxy <EOL> else : <EOL> return getattr ( proxy , namespace ) <EOL> def upcheck ( self ) : <EOL> try : <EOL> supervisor = self . get_supervisor ( ) <EOL> api = supervisor . getVersion ( ) <EOL> from supervisor import rpcinterface <EOL> if api != rpcinterface . API_VERSION : <EOL> self . output ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' % ( rpcinterface . API_VERSION , api ) ) <EOL> return False <EOL> except xmlrpclib . Fault , e : <EOL> if e . faultCode == xmlrpc . Faults . UNKNOWN_METHOD : <EOL> self . output ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> return False <EOL> raise <EOL> except socket . error , why : <EOL> if why [ <NUM_LIT:0> ] == errno . ECONNREFUSED : <EOL> self . output ( '<STR_LIT>' % self . options . serverurl ) <EOL> return False <EOL> elif why [ <NUM_LIT:0> ] == errno . ENOENT : <EOL> self . output ( '<STR_LIT>' % self . options . serverurl ) <EOL> return False <EOL> raise <EOL> return True <EOL> def completionmatches ( self , text , line , flag = <NUM_LIT:0> ) : <EOL> groups = [ ] <EOL> programs = [ ] <EOL> groupwiseprograms = { } <EOL> info = self . get_supervisor ( ) . getAllProcessInfo ( ) <EOL> for i in info : <EOL> programs . append ( i [ '<STR_LIT:name>' ] ) <EOL> if i [ '<STR_LIT>' ] not in groups : <EOL> groups . append ( i [ '<STR_LIT>' ] ) <EOL> groupwiseprograms [ i [ '<STR_LIT>' ] ] = [ ] <EOL> groupwiseprograms [ i [ '<STR_LIT>' ] ] . append ( i [ '<STR_LIT:name>' ] ) <EOL> total = [ ] <EOL> for i in groups : <EOL> if i in programs : <EOL> total . append ( i + '<STR_LIT:U+0020>' ) <EOL> else : <EOL> for n in groupwiseprograms [ i ] : <EOL> total . append ( i + '<STR_LIT::>' + n + '<STR_LIT:U+0020>' ) <EOL> if flag : <EOL> return [ i + '<STR_LIT:U+0020>' for i in groups if i . startswith ( text ) ] <EOL> if len ( line . split ( ) ) == <NUM_LIT:1> : <EOL> return total <EOL> else : <EOL> current = line . split ( ) [ - <NUM_LIT:1> ] <EOL> if line . endswith ( '<STR_LIT:U+0020>' ) and len ( line . split ( ) ) > <NUM_LIT:1> : <EOL> results = [ i for i in total if i . startswith ( text ) ] <EOL> return results <EOL> if '<STR_LIT::>' in current : <EOL> g = current . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] <EOL> results = [ i + '<STR_LIT:U+0020>' for i in groupwiseprograms [ g ] <EOL> if i . startswith ( text ) ] <EOL> return results <EOL> results = [ i for i in total if i . startswith ( text ) ] <EOL> return results <EOL> def complete ( self , text , state ) : <EOL> try : <EOL> import readline <EOL> except ImportError : <EOL> return None <EOL> line = readline . get_line_buffer ( ) <EOL> if line == '<STR_LIT>' : <EOL> results = [ i + '<STR_LIT:U+0020>' for i in self . vocab if i . startswith ( text ) ] + [ None ] <EOL> return results [ state ] <EOL> else : <EOL> exp = line . split ( ) [ <NUM_LIT:0> ] <EOL> if exp in [ '<STR_LIT:start>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:status>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> if not line . endswith ( '<STR_LIT:U+0020>' ) and len ( line . split ( ) ) == <NUM_LIT:1> : <EOL> return [ text + '<STR_LIT:U+0020>' , None ] [ state ] <EOL> if exp == '<STR_LIT>' : <EOL> if line . endswith ( '<STR_LIT:U+0020>' ) and len ( line . split ( ) ) > <NUM_LIT:1> : <EOL> return None <EOL> results = self . completionmatches ( text , line ) + [ None ] <EOL> return results [ state ] <EOL> elif exp in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT:version>' , '<STR_LIT>' ] : <EOL> return None <EOL> elif exp == '<STR_LIT>' : <EOL> if line . endswith ( '<STR_LIT:U+0020>' ) and len ( line . split ( ) ) > <NUM_LIT:1> : <EOL> return None <EOL> results = [ i + '<STR_LIT:U+0020>' for i in self . vocab if i . startswith ( text ) ] + [ None ] <EOL> return results [ state ] <EOL> elif exp in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> results = self . completionmatches ( text , line , flag = <NUM_LIT:1> ) + [ None ] <EOL> return results [ state ] <EOL> else : <EOL> results = [ i + '<STR_LIT:U+0020>' for i in self . vocab if i . startswith ( text ) ] + [ None ] <EOL> return results [ state ] <EOL> def do_help ( self , arg ) : <EOL> for plugin in self . options . plugins : <EOL> plugin . do_help ( arg ) <EOL> def help_help ( self ) : <EOL> self . output ( \"<STR_LIT>\" ) <EOL> self . output ( \"<STR_LIT>\" ) <EOL> def do_EOF ( self , arg ) : <EOL> self . output ( '<STR_LIT>' ) <EOL> return <NUM_LIT:1> <EOL> def help_EOF ( self ) : <EOL> self . output ( \"<STR_LIT>\" ) <EOL> def get_names ( inst ) : <EOL> names = [ ] <EOL> classes = [ inst . __class__ ] <EOL> while classes : <EOL> aclass = classes . pop ( <NUM_LIT:0> ) <EOL> if aclass . __bases__ : <EOL> classes = classes + list ( aclass . __bases__ ) <EOL> names = names + dir ( aclass ) <EOL> return names <EOL> class ControllerPluginBase : <EOL> name = '<STR_LIT>' <EOL> def __init__ ( self , controller ) : <EOL> self . ctl = controller <EOL> def _doc_header ( self ) : <EOL> return \"<STR_LIT>\" % self . name <EOL> doc_header = property ( _doc_header ) <EOL> def do_help ( self , arg ) : <EOL> if arg : <EOL> try : <EOL> func = getattr ( self , '<STR_LIT>' + arg ) <EOL> except AttributeError : <EOL> try : <EOL> doc = getattr ( self , '<STR_LIT>' + arg ) . __doc__ <EOL> if doc : <EOL> self . ctl . stdout . write ( \"<STR_LIT>\" % str ( doc ) ) <EOL> return <EOL> except AttributeError : <EOL> pass <EOL> self . ctl . stdout . write ( \"<STR_LIT>\" % str ( self . ctl . nohelp % ( arg , ) ) ) <EOL> return <EOL> func ( ) <EOL> else : <EOL> names = get_names ( self ) <EOL> cmds_doc = [ ] <EOL> cmds_undoc = [ ] <EOL> help = { } <EOL> for name in names : <EOL> if name [ : <NUM_LIT:5> ] == '<STR_LIT>' : <EOL> help [ name [ <NUM_LIT:5> : ] ] = <NUM_LIT:1> <EOL> names . sort ( ) <EOL> prevname = '<STR_LIT>' <EOL> for name in names : <EOL> if name [ : <NUM_LIT:3> ] == '<STR_LIT>' : <EOL> if name == prevname : <EOL> continue <EOL> prevname = name <EOL> cmd = name [ <NUM_LIT:3> : ] <EOL> if cmd in help : <EOL> cmds_doc . append ( cmd ) <EOL> del help [ cmd ] <EOL> elif getattr ( self , name ) . __doc__ : <EOL> cmds_doc . append ( cmd ) <EOL> else : <EOL> cmds_undoc . append ( cmd ) <EOL> self . ctl . stdout . write ( \"<STR_LIT:\\n>\" ) <EOL> self . ctl . print_topics ( self . doc_header , cmds_doc , <NUM_LIT:15> , <NUM_LIT> ) <EOL> class DefaultControllerPlugin ( ControllerPluginBase ) : <EOL> name = '<STR_LIT:default>' <EOL> listener = None <EOL> def _tailf ( self , path ) : <EOL> if not self . ctl . upcheck ( ) : <EOL> return <EOL> self . ctl . output ( '<STR_LIT>' ) <EOL> username = self . ctl . options . username <EOL> password = self . ctl . options . password <EOL> try : <EOL> import http_client <EOL> if self . listener is None : <EOL> listener = http_client . Listener ( ) <EOL> else : <EOL> listener = self . listener <EOL> handler = http_client . HTTPHandler ( listener , username , password ) <EOL> handler . get ( self . ctl . options . serverurl , path ) <EOL> asyncore . loop ( ) <EOL> except KeyboardInterrupt : <EOL> handler . close ( ) <EOL> self . ctl . output ( '<STR_LIT>' ) <EOL> return <EOL> def do_tail ( self , arg ) : <EOL> if not self . ctl . upcheck ( ) : <EOL> return <EOL> args = arg . strip ( ) . split ( ) <EOL> if len ( args ) < <NUM_LIT:1> : <EOL> self . ctl . output ( '<STR_LIT>' ) <EOL> self . help_tail ( ) <EOL> return <EOL> elif len ( args ) > <NUM_LIT:3> : <EOL> self . ctl . output ( '<STR_LIT>' ) <EOL> self . help_tail ( ) <EOL> return <EOL> modifier = None <EOL> if args [ <NUM_LIT:0> ] . startswith ( '<STR_LIT:->' ) : <EOL> modifier = args . pop ( <NUM_LIT:0> ) <EOL> if len ( args ) == <NUM_LIT:1> : <EOL> name = args [ - <NUM_LIT:1> ] <EOL> channel = '<STR_LIT>' <EOL> else : <EOL> if args : <EOL> name = args [ <NUM_LIT:0> ] <EOL> channel = args [ - <NUM_LIT:1> ] . lower ( ) <EOL> if channel not in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> self . ctl . output ( '<STR_LIT>' % channel ) <EOL> return <EOL> else : <EOL> self . ctl . output ( '<STR_LIT>' ) <EOL> return <EOL> bytes = <NUM_LIT> <EOL> if modifier is not None : <EOL> what = modifier [ <NUM_LIT:1> : ] <EOL> if what == '<STR_LIT:f>' : <EOL> bytes = None <EOL> else : <EOL> try : <EOL> bytes = int ( what ) <EOL> except : <EOL> self . ctl . output ( '<STR_LIT>' % modifier ) <EOL> return <EOL> supervisor = self . ctl . get_supervisor ( ) <EOL> if bytes is None : <EOL> return self . _tailf ( '<STR_LIT>' % ( name , channel ) ) <EOL> else : <EOL> try : <EOL> if channel is '<STR_LIT>' : <EOL> output = supervisor . readProcessStdoutLog ( name , <EOL> - bytes , <NUM_LIT:0> ) <EOL> else : <EOL> output = supervisor . readProcessStderrLog ( name , <EOL> - bytes , <NUM_LIT:0> ) <EOL> except xmlrpclib . Fault , e : <EOL> template = '<STR_LIT>' <EOL> if e . faultCode == xmlrpc . Faults . NO_FILE : <EOL> self . ctl . output ( template % ( name , '<STR_LIT>' ) ) <EOL> elif e . faultCode == xmlrpc . Faults . FAILED : <EOL> self . ctl . output ( template % ( name , <EOL> '<STR_LIT>' ) ) <EOL> elif e . faultCode == xmlrpc . Faults . BAD_NAME : <EOL> self . ctl . output ( template % ( name , <EOL> '<STR_LIT>' ) ) <EOL> else : <EOL> self . ctl . output ( output ) <EOL> def help_tail ( self ) : <EOL> self . ctl . output ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> def do_maintail ( self , arg ) : <EOL> if not self . ctl . upcheck ( ) : <EOL> return <EOL> args = arg . strip ( ) . split ( ) <EOL> if len ( args ) > <NUM_LIT:1> : <EOL> self . ctl . output ( '<STR_LIT>' ) <EOL> self . help_maintail ( ) <EOL> return <EOL> elif len ( args ) == <NUM_LIT:1> : <EOL> if args [ <NUM_LIT:0> ] . startswith ( '<STR_LIT:->' ) : <EOL> what = args [ <NUM_LIT:0> ] [ <NUM_LIT:1> : ] <EOL> if what == '<STR_LIT:f>' : <EOL> path = '<STR_LIT>' <EOL> return self . _tailf ( path ) <EOL> try : <EOL> what = int ( what ) <EOL> except : <EOL> self . ctl . output ( '<STR_LIT>' % args [ <NUM_LIT:0> ] ) <EOL> return <EOL> else : <EOL> bytes = what <EOL> else : <EOL> self . ctl . output ( '<STR_LIT>' % args [ <NUM_LIT:0> ] ) <EOL> return <EOL> else : <EOL> bytes = <NUM_LIT> <EOL> supervisor = self . ctl . get_supervisor ( ) <EOL> try : <EOL> output = supervisor . readLog ( - bytes , <NUM_LIT:0> ) <EOL> except xmlrpclib . Fault , e : <EOL> template = '<STR_LIT>' <EOL> if e . faultCode == xmlrpc . Faults . NO_FILE : <EOL> self . ctl . output ( template % ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> elif e . faultCode == xmlrpc . Faults . FAILED : <EOL> self . ctl . output ( template % ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) ) <EOL> else : <EOL> self . ctl . output ( output ) <EOL> def help_maintail ( self ) : <EOL> self . ctl . output ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> def do_quit ( self , arg ) : <EOL> sys . exit ( <NUM_LIT:0> ) <EOL> def help_quit ( self ) : <EOL> self . ctl . output ( \"<STR_LIT>\" ) <EOL> do_exit = do_quit <EOL> def help_exit ( self ) : <EOL> self . ctl . output ( \"<STR_LIT>\" ) <EOL> def _procrepr ( self , info ) : <EOL> template = '<STR_LIT>' <EOL> if info [ '<STR_LIT:name>' ] == info [ '<STR_LIT>' ] : <EOL> name = info [ '<STR_LIT:name>' ] <EOL> else : <EOL> name = '<STR_LIT>' % ( info [ '<STR_LIT>' ] , info [ '<STR_LIT:name>' ] ) <EOL> return template % { '<STR_LIT:name>' : name , '<STR_LIT:state>' : info [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : info [ '<STR_LIT:description>' ] } <EOL> def do_status ( self , arg ) : <EOL> if not self . ctl . upcheck ( ) : <EOL> return <EOL> supervisor = self . ctl . get_supervisor ( ) <EOL> names = arg . strip ( ) . split ( ) <EOL> if names : <EOL> for name in names : <EOL> try : <EOL> info = supervisor . getProcessInfo ( name ) <EOL> except xmlrpclib . Fault , e : <EOL> if e . faultCode == xmlrpc . Faults . BAD_NAME : <EOL> self . ctl . output ( '<STR_LIT>' % name ) <EOL> else : <EOL> raise <EOL> continue <EOL> self . ctl . output ( self . _procrepr ( info ) ) <EOL> else : <EOL> for info in supervisor . getAllProcessInfo ( ) : <EOL> self . ctl . output ( self . _procrepr ( info ) ) <EOL> def help_status ( self ) : <EOL> self . ctl . output ( \"<STR_LIT>\" ) <EOL> self . ctl . output ( <EOL> \"<STR_LIT>\" ) <EOL> self . ctl . output ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def do_pid ( self , arg ) : <EOL> supervisor = self . ctl . get_supervisor ( ) <EOL> if not self . ctl . upcheck ( ) : <EOL> return <EOL> names = arg . strip ( ) . split ( ) <EOL> if not names : <EOL> pid = supervisor . getPID ( ) <EOL> self . ctl . output ( str ( pid ) ) <EOL> elif '<STR_LIT:all>' in names : <EOL> for info in supervisor . getAllProcessInfo ( ) : <EOL> self . ctl . output ( str ( info [ '<STR_LIT>' ] ) ) <EOL> else : <EOL> for name in names : <EOL> try : <EOL> info = supervisor . getProcessInfo ( name ) <EOL> except xmlrpclib . Fault , e : <EOL> if e . faultCode == xmlrpc . Faults . BAD_NAME : <EOL> self . ctl . output ( '<STR_LIT>' % name ) <EOL> else : <EOL> raise <EOL> continue <EOL> self . ctl . output ( str ( info [ '<STR_LIT>' ] ) ) <EOL> def help_pid ( self ) : <EOL> self . ctl . output ( \"<STR_LIT>\" ) <EOL> self . ctl . output ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> self . ctl . output ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def _startresult ( self , result ) : <EOL> name = result [ '<STR_LIT:name>' ] <EOL> code = result [ '<STR_LIT:status>' ] <EOL> template = '<STR_LIT>' <EOL> if code == xmlrpc . Faults . BAD_NAME : <EOL> return template % ( name , '<STR_LIT>' ) <EOL> elif code == xmlrpc . Faults . NO_FILE : <EOL> return template % ( name , '<STR_LIT>' ) <EOL> elif code == xmlrpc . Faults . NOT_EXECUTABLE : <EOL> return template % ( name , '<STR_LIT>' ) <EOL> elif code == xmlrpc . Faults . ALREADY_STARTED : <EOL> return template % ( name , '<STR_LIT>' ) <EOL> elif code == xmlrpc . Faults . SPAWN_ERROR : <EOL> return template % ( name , '<STR_LIT>' ) <EOL> elif code == xmlrpc . Faults . ABNORMAL_TERMINATION : <EOL> return template % ( name , '<STR_LIT>' ) <EOL> elif code == xmlrpc . Faults . SUCCESS : <EOL> return '<STR_LIT>' % name <EOL> raise ValueError ( '<STR_LIT>' % ( code , name ) ) <EOL> def do_start ( self , arg ) : <EOL> if not self . ctl . upcheck ( ) : <EOL> return <EOL> names = arg . strip ( ) . split ( ) <EOL> supervisor = self . ctl . get_supervisor ( ) <EOL> if not names : <EOL> self . ctl . output ( \"<STR_LIT>\" ) <EOL> self . help_start ( ) <EOL> return <EOL> if '<STR_LIT:all>' in names : <EOL> results = supervisor . startAllProcesses ( ) <EOL> for result in results : <EOL> result = self . _startresult ( result ) <EOL> self . ctl . output ( result ) <EOL> else : <EOL> for name in names : <EOL> group_name , process_name = split_namespec ( name ) <EOL> if process_name is None : <EOL> results = supervisor . startProcessGroup ( group_name ) <EOL> for result in results : <EOL> result = self . _startresult ( result ) <EOL> self . ctl . output ( result ) <EOL> else : <EOL> try : <EOL> result = supervisor . startProcess ( name ) <EOL> except xmlrpclib . Fault , e : <EOL> error = self . _startresult ( { '<STR_LIT:status>' : e . faultCode , <EOL> '<STR_LIT:name>' : name , <EOL> '<STR_LIT:description>' : e . faultString } ) <EOL> self . ctl . output ( error ) <EOL> else : <EOL> self . ctl . output ( '<STR_LIT>' % name ) <EOL> def help_start ( self ) : <EOL> self . ctl . output ( \"<STR_LIT>\" ) <EOL> self . ctl . output ( \"<STR_LIT>\" ) <EOL> self . ctl . output ( <EOL> \"<STR_LIT>\" ) <EOL> self . ctl . output ( \"<STR_LIT>\" ) <EOL> def _stopresult ( self , result ) : <EOL>", "answer": "name = result [ '<STR_LIT:name>' ]"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import threading <EOL> from rx . blockingobservable import BlockingObservable <EOL> from rx . internal import extensionmethod <EOL> from rx . internal . enumerator import Enumerator <EOL> @ extensionmethod ( BlockingObservable ) <EOL> def to_iterable ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "condition = threading . Condition ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . core . management . base import NoArgsCommand <EOL> from events . models import Calendar <EOL>", "answer": "class Command ( NoArgsCommand ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import copy <EOL> from keystoneauth1 import exceptions as ks_exc <EOL> from openstackclient . identity . v2_0 import project <EOL> from openstackclient . tests import fakes <EOL> from openstackclient . tests . identity . v2_0 import fakes as identity_fakes <EOL> class TestProject ( identity_fakes . TestIdentityv2 ) : <EOL> def setUp ( self ) : <EOL> super ( TestProject , self ) . setUp ( ) <EOL> self . projects_mock = self . app . client_manager . identity . tenants <EOL> self . projects_mock . reset_mock ( ) <EOL> class TestProjectCreate ( TestProject ) : <EOL> columns = ( <EOL> '<STR_LIT:description>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT:id>' , <EOL> '<STR_LIT:name>' , <EOL> ) <EOL> datalist = ( <EOL> identity_fakes . project_description , <EOL> True , <EOL> identity_fakes . project_id , <EOL> identity_fakes . project_name , <EOL> ) <EOL> def setUp ( self ) : <EOL> super ( TestProjectCreate , self ) . setUp ( ) <EOL> self . projects_mock . create . return_value = fakes . FakeResource ( <EOL> None , <EOL> copy . deepcopy ( identity_fakes . PROJECT ) , <EOL> loaded = True , <EOL> ) <EOL> self . cmd = project . CreateProject ( self . app , None ) <EOL> def test_project_create_no_options ( self ) : <EOL> arglist = [ <EOL> identity_fakes . project_name , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT>' , False ) , <EOL> ( '<STR_LIT>' , False ) , <EOL> ( '<STR_LIT:name>' , identity_fakes . project_name ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> columns , data = self . cmd . take_action ( parsed_args ) <EOL> kwargs = { <EOL> '<STR_LIT:description>' : None , <EOL> '<STR_LIT>' : True , <EOL> } <EOL> self . projects_mock . create . assert_called_with ( <EOL> identity_fakes . project_name , <EOL> ** kwargs <EOL> ) <EOL> self . assertEqual ( self . columns , columns ) <EOL> self . assertEqual ( self . datalist , data ) <EOL> def test_project_create_description ( self ) : <EOL> arglist = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> identity_fakes . project_name , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT:description>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT:name>' , identity_fakes . project_name ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> columns , data = self . cmd . take_action ( parsed_args ) <EOL> kwargs = { <EOL> '<STR_LIT:description>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : True , <EOL> } <EOL> self . projects_mock . create . assert_called_with ( <EOL> identity_fakes . project_name , <EOL> ** kwargs <EOL> ) <EOL> self . assertEqual ( self . columns , columns ) <EOL> self . assertEqual ( self . datalist , data ) <EOL> def test_project_create_enable ( self ) : <EOL> arglist = [ <EOL> '<STR_LIT>' , <EOL> identity_fakes . project_name , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT>' , True ) , <EOL> ( '<STR_LIT>' , False ) , <EOL> ( '<STR_LIT:name>' , identity_fakes . project_name ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> columns , data = self . cmd . take_action ( parsed_args ) <EOL> kwargs = { <EOL> '<STR_LIT:description>' : None , <EOL> '<STR_LIT>' : True , <EOL> } <EOL> self . projects_mock . create . assert_called_with ( <EOL> identity_fakes . project_name , <EOL> ** kwargs <EOL> ) <EOL> self . assertEqual ( self . columns , columns ) <EOL> self . assertEqual ( self . datalist , data ) <EOL> def test_project_create_disable ( self ) : <EOL> arglist = [ <EOL> '<STR_LIT>' , <EOL> identity_fakes . project_name , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT>' , False ) , <EOL> ( '<STR_LIT>' , True ) , <EOL> ( '<STR_LIT:name>' , identity_fakes . project_name ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> columns , data = self . cmd . take_action ( parsed_args ) <EOL> kwargs = { <EOL> '<STR_LIT:description>' : None , <EOL> '<STR_LIT>' : False , <EOL> } <EOL> self . projects_mock . create . assert_called_with ( <EOL> identity_fakes . project_name , <EOL> ** kwargs <EOL> ) <EOL> self . assertEqual ( self . columns , columns ) <EOL> self . assertEqual ( self . datalist , data ) <EOL> def test_project_create_property ( self ) : <EOL> arglist = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> identity_fakes . project_name , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT>' , { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> ( '<STR_LIT:name>' , identity_fakes . project_name ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> columns , data = self . cmd . take_action ( parsed_args ) <EOL> kwargs = { <EOL> '<STR_LIT:description>' : None , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> self . projects_mock . create . assert_called_with ( <EOL> identity_fakes . project_name , <EOL> ** kwargs <EOL> ) <EOL> self . assertEqual ( self . columns , columns ) <EOL> self . assertEqual ( self . datalist , data ) <EOL> def test_project_create_or_show_exists ( self ) : <EOL> def _raise_conflict ( * args , ** kwargs ) : <EOL> raise ks_exc . Conflict ( None ) <EOL> self . projects_mock . create . side_effect = _raise_conflict <EOL> self . projects_mock . get . return_value = fakes . FakeResource ( <EOL> None , <EOL> copy . deepcopy ( identity_fakes . PROJECT ) , <EOL> loaded = True , <EOL> ) <EOL> arglist = [ <EOL> '<STR_LIT>' , <EOL> identity_fakes . project_name , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT:name>' , identity_fakes . project_name ) , <EOL> ( '<STR_LIT>' , True ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> columns , data = self . cmd . take_action ( parsed_args ) <EOL> self . projects_mock . get . assert_called_with ( identity_fakes . project_name ) <EOL> kwargs = { <EOL> '<STR_LIT:description>' : None , <EOL> '<STR_LIT>' : True , <EOL> } <EOL> self . projects_mock . create . assert_called_with ( <EOL> identity_fakes . project_name , <EOL> ** kwargs <EOL> ) <EOL> self . assertEqual ( self . columns , columns ) <EOL> self . assertEqual ( self . datalist , data ) <EOL> def test_project_create_or_show_not_exists ( self ) : <EOL> arglist = [ <EOL> '<STR_LIT>' , <EOL> identity_fakes . project_name , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT:name>' , identity_fakes . project_name ) , <EOL> ( '<STR_LIT>' , True ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> columns , data = self . cmd . take_action ( parsed_args ) <EOL> kwargs = { <EOL> '<STR_LIT:description>' : None , <EOL> '<STR_LIT>' : True , <EOL> } <EOL> self . projects_mock . create . assert_called_with ( <EOL> identity_fakes . project_name , <EOL> ** kwargs <EOL> ) <EOL> self . assertEqual ( self . columns , columns ) <EOL> self . assertEqual ( self . datalist , data ) <EOL> class TestProjectDelete ( TestProject ) : <EOL> def setUp ( self ) : <EOL> super ( TestProjectDelete , self ) . setUp ( ) <EOL> self . projects_mock . get . return_value = fakes . FakeResource ( <EOL> None , <EOL> copy . deepcopy ( identity_fakes . PROJECT ) , <EOL> loaded = True , <EOL> ) <EOL> self . projects_mock . delete . return_value = None <EOL> self . cmd = project . DeleteProject ( self . app , None ) <EOL> def test_project_delete_no_options ( self ) : <EOL> arglist = [ <EOL> identity_fakes . project_id , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT>' , [ identity_fakes . project_id ] ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> result = self . cmd . take_action ( parsed_args ) <EOL> self . projects_mock . delete . assert_called_with ( <EOL> identity_fakes . project_id , <EOL> ) <EOL> self . assertIsNone ( result ) <EOL> class TestProjectList ( TestProject ) : <EOL> def setUp ( self ) : <EOL> super ( TestProjectList , self ) . setUp ( ) <EOL> self . projects_mock . list . return_value = [ <EOL> fakes . FakeResource ( <EOL> None , <EOL> copy . deepcopy ( identity_fakes . PROJECT ) , <EOL> loaded = True , <EOL> ) , <EOL> ] <EOL> self . cmd = project . ListProject ( self . app , None ) <EOL> def test_project_list_no_options ( self ) : <EOL> arglist = [ ] <EOL> verifylist = [ ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> columns , data = self . cmd . take_action ( parsed_args ) <EOL> self . projects_mock . list . assert_called_with ( ) <EOL> collist = ( '<STR_LIT>' , '<STR_LIT:Name>' ) <EOL> self . assertEqual ( collist , columns ) <EOL> datalist = ( ( <EOL> identity_fakes . project_id , <EOL> identity_fakes . project_name , <EOL> ) , ) <EOL> self . assertEqual ( datalist , tuple ( data ) ) <EOL> def test_project_list_long ( self ) : <EOL> arglist = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT>' , True ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> columns , data = self . cmd . take_action ( parsed_args ) <EOL> self . projects_mock . list . assert_called_with ( ) <EOL> collist = ( '<STR_LIT>' , '<STR_LIT:Name>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertEqual ( collist , columns ) <EOL> datalist = ( ( <EOL> identity_fakes . project_id , <EOL> identity_fakes . project_name , <EOL> identity_fakes . project_description , <EOL> True , <EOL> ) , ) <EOL> self . assertEqual ( datalist , tuple ( data ) ) <EOL> class TestProjectSet ( TestProject ) : <EOL> def setUp ( self ) : <EOL> super ( TestProjectSet , self ) . setUp ( ) <EOL> self . projects_mock . get . return_value = fakes . FakeResource ( <EOL> None , <EOL> copy . deepcopy ( identity_fakes . PROJECT ) , <EOL> loaded = True , <EOL> ) <EOL> self . projects_mock . update . return_value = fakes . FakeResource ( <EOL> None , <EOL> copy . deepcopy ( identity_fakes . PROJECT ) , <EOL> loaded = True , <EOL> ) <EOL> self . cmd = project . SetProject ( self . app , None ) <EOL> def test_project_set_no_options ( self ) : <EOL> arglist = [ <EOL> identity_fakes . project_name , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT>' , identity_fakes . project_name ) , <EOL> ( '<STR_LIT>' , False ) , <EOL> ( '<STR_LIT>' , False ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> result = self . cmd . take_action ( parsed_args ) <EOL> self . assertIsNone ( result ) <EOL> def test_project_set_name ( self ) : <EOL> arglist = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> identity_fakes . project_name , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT:name>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , False ) , <EOL> ( '<STR_LIT>' , False ) , <EOL> ( '<STR_LIT>' , identity_fakes . project_name ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> result = self . cmd . take_action ( parsed_args ) <EOL> kwargs = { <EOL> '<STR_LIT:description>' : identity_fakes . project_description , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> self . projects_mock . update . assert_called_with ( <EOL> identity_fakes . project_id , <EOL> ** kwargs <EOL> ) <EOL> self . assertIsNone ( result ) <EOL> def test_project_set_description ( self ) : <EOL> arglist = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> identity_fakes . project_name , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT:description>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , False ) , <EOL> ( '<STR_LIT>' , False ) , <EOL> ( '<STR_LIT>' , identity_fakes . project_name ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> result = self . cmd . take_action ( parsed_args ) <EOL> kwargs = { <EOL> '<STR_LIT:description>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : identity_fakes . project_name , <EOL> } <EOL> self . projects_mock . update . assert_called_with ( <EOL> identity_fakes . project_id , <EOL> ** kwargs <EOL> ) <EOL> self . assertIsNone ( result ) <EOL> def test_project_set_enable ( self ) : <EOL> arglist = [ <EOL> '<STR_LIT>' , <EOL> identity_fakes . project_name , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT>' , True ) , <EOL> ( '<STR_LIT>' , False ) , <EOL> ( '<STR_LIT>' , identity_fakes . project_name ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> result = self . cmd . take_action ( parsed_args ) <EOL> kwargs = { <EOL> '<STR_LIT:description>' : identity_fakes . project_description , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : identity_fakes . project_name , <EOL> } <EOL> self . projects_mock . update . assert_called_with ( <EOL> identity_fakes . project_id , <EOL> ** kwargs <EOL> ) <EOL> self . assertIsNone ( result ) <EOL> def test_project_set_disable ( self ) : <EOL> arglist = [ <EOL> '<STR_LIT>' , <EOL> identity_fakes . project_name , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT>' , False ) , <EOL> ( '<STR_LIT>' , True ) , <EOL> ( '<STR_LIT>' , identity_fakes . project_name ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> result = self . cmd . take_action ( parsed_args ) <EOL> kwargs = { <EOL> '<STR_LIT:description>' : identity_fakes . project_description , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : identity_fakes . project_name , <EOL> } <EOL> self . projects_mock . update . assert_called_with ( <EOL> identity_fakes . project_id , <EOL> ** kwargs <EOL> ) <EOL> self . assertIsNone ( result ) <EOL> def test_project_set_property ( self ) : <EOL> arglist = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> identity_fakes . project_name , <EOL> ] <EOL> verifylist = [ <EOL> ( '<STR_LIT>' , { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> ( '<STR_LIT>' , identity_fakes . project_name ) , <EOL> ] <EOL> parsed_args = self . check_parser ( self . cmd , arglist , verifylist ) <EOL> result = self . cmd . take_action ( parsed_args ) <EOL> kwargs = { <EOL> '<STR_LIT:description>' : identity_fakes . project_description , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : identity_fakes . project_name , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> self . projects_mock . update . assert_called_with ( <EOL> identity_fakes . project_id , <EOL> ** kwargs <EOL> ) <EOL> self . assertIsNone ( result ) <EOL> class TestProjectShow ( TestProject ) : <EOL> def setUp ( self ) : <EOL> super ( TestProjectShow , self ) . setUp ( ) <EOL> self . projects_mock . get . return_value = fakes . FakeResource ( <EOL> None , <EOL> copy . deepcopy ( identity_fakes . PROJECT ) , <EOL> loaded = True , <EOL> ) <EOL>", "answer": "self . cmd = project . ShowProject ( self . app , None )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import itertools <EOL> from grr . gui import api_call_handler_base <EOL> from grr . gui import api_value_renderers <EOL> from grr . lib import aff4 <EOL> from grr . lib import flow <EOL> from grr . lib . aff4_objects import cronjobs as aff4_cronjobs <EOL> from grr . lib . rdfvalues import grr_rdf <EOL> from grr . lib . rdfvalues import structs as rdf_structs <EOL> from grr . proto import api_pb2 <EOL> CATEGORY = \"<STR_LIT>\" <EOL> class ApiCronJob ( rdf_structs . RDFProtoStruct ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> protobuf = api_pb2 . ApiCronJob <EOL> def GetArgsClass ( self ) : <EOL> if self . flow_name : <EOL> flow_cls = flow . GRRFlow . classes . get ( self . flow_name ) <EOL> if flow_cls is None : <EOL> raise ValueError ( \"<STR_LIT>\" % <EOL> self . flow_name ) <EOL> return flow_cls . args_type <EOL> def GetCronJobState ( cron_job ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if cron_job . Get ( cron_job . Schema . DISABLED ) : <EOL> return ApiCronJob . State . DISABLED <EOL> else : <EOL> return ApiCronJob . State . ENABLED <EOL> def IsCronJobFailing ( cron_job ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> statuses = itertools . islice ( <EOL> cron_job . GetValuesForAttribute ( cron_job . Schema . LAST_RUN_STATUS ) , <NUM_LIT:0> , <NUM_LIT:4> ) <EOL> failures_count = <NUM_LIT:0> <EOL> for status in statuses : <EOL> if status . status != grr_rdf . CronJobRunStatus . Status . OK : <EOL> failures_count += <NUM_LIT:1> <EOL> return failures_count >= <NUM_LIT:2> <EOL> def CronJobToApiCronJob ( cron_job ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cron_args = cron_job . Get ( cron_job . Schema . CRON_ARGS ) <EOL> api_cron_job = ApiCronJob ( urn = cron_job . urn , <EOL> description = cron_args . description , <EOL> flow_name = cron_args . flow_runner_args . flow_name , <EOL> flow_runner_args = cron_args . flow_runner_args , <EOL> periodicity = cron_args . periodicity , <EOL> lifetime = cron_args . lifetime , <EOL> allow_overruns = cron_args . allow_overruns , <EOL> state = GetCronJobState ( cron_job ) , <EOL> last_run_time = cron_job . Get ( <EOL> cron_job . Schema . LAST_RUN_TIME ) , <EOL> is_failing = IsCronJobFailing ( cron_job ) ) <EOL> try : <EOL> api_cron_job . flow_args = cron_args . flow_args <EOL> except ValueError : <EOL> pass <EOL> return api_cron_job <EOL> class ApiListCronJobsArgs ( rdf_structs . RDFProtoStruct ) : <EOL> protobuf = api_pb2 . ApiListCronJobsArgs <EOL> class ApiListCronJobsHandler ( api_call_handler_base . ApiCallHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> category = CATEGORY <EOL> args_type = ApiListCronJobsArgs <EOL> def Render ( self , args , token = None ) : <EOL> if not args . count : <EOL> stop = None <EOL> else : <EOL> stop = args . offset + args . count <EOL> cron_jobs_urns = list ( itertools . islice ( <EOL> aff4_cronjobs . CRON_MANAGER . ListJobs ( token = token ) , args . offset , stop ) ) <EOL> cron_jobs = aff4 . FACTORY . MultiOpen ( <EOL> cron_jobs_urns , aff4_type = \"<STR_LIT>\" , token = token , age = aff4 . ALL_TIMES ) <EOL>", "answer": "items = [ CronJobToApiCronJob ( cron_job ) for cron_job in cron_jobs ]"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import xmlrpclib <EOL> import jsonrpc <EOL> import logging <EOL> import datetime <EOL> import time <EOL> from foam . core . log import KeyAdapter <EOL> from foam . openflow . types import Port <EOL> import foam . core . allocation <EOL> MAXAGE = datetime . timedelta ( hours = <NUM_LIT:6> ) <EOL> class CachedSlice ( object ) : <EOL> def __init__ ( self , name ) : <EOL> self . name = name <EOL> self . _time = datetime . datetime . now ( ) <EOL> self . _info = Connection . getSliceInfo ( self . name ) <EOL> def exists ( self ) : <EOL> now = datetime . datetime . now ( ) <EOL> if ( now - self . _time ) > MAXAGE : <EOL> self . _time = now <EOL> self . _info = Connection . getSliceInfo ( self . name ) <EOL> if self . _info is not None : <EOL> return True <EOL> else : <EOL> return False <EOL> class SliceCache ( object ) : <EOL> def __init__ ( self ) : <EOL> self . _cache = { } <EOL> def exists ( self , slice_name ) : <EOL> try : <EOL> return self . _cache [ slice_name ] . exists ( ) <EOL> except KeyError , e : <EOL> sl = CachedSlice ( slice_name ) <EOL> self . _cache [ slice_name ] = sl <EOL> return sl . exists ( ) <EOL> def delete ( self , slice_name ) : <EOL> try : <EOL> del self . _cache [ slice_name ] <EOL> except : <EOL> return <EOL> def add ( self , slice_name ) : <EOL> self . _cache [ slice_name ] = CachedSlice ( slice_name ) <EOL> class _Connection ( object ) : <EOL> def __init__ ( self ) : <EOL> self . xmlcall = self . _xmlcall_time <EOL> self . log = KeyAdapter ( \"<STR_LIT>\" , logging . getLogger ( '<STR_LIT>' ) ) <EOL> self . plog = logging . getLogger ( \"<STR_LIT>\" ) <EOL> self . __host = ConfigDB . getConfigItemByKey ( \"<STR_LIT>\" ) . getValue ( ) <EOL> self . __passwd = ConfigDB . getConfigItemByKey ( \"<STR_LIT>\" ) . getValue ( ) <EOL> self . __jsonport = ConfigDB . getConfigItemByKey ( \"<STR_LIT>\" ) . getValue ( ) <EOL> self . __xmlport = ConfigDB . getConfigItemByKey ( \"<STR_LIT>\" ) . getValue ( ) <EOL> self . __sliceCache = SliceCache ( ) <EOL> self . buildConnections ( ) <EOL> def updateConfig ( self , info ) : <EOL> self . info = info <EOL> self . buildConnections ( ) <EOL> self . rebuildCache ( ) <EOL> def buildConnections ( self ) : <EOL> self . xmlconn = xmlrpclib . ServerProxy ( \"<STR_LIT>\" % ( <EOL> self . __passwd , self . __host , self . __xmlport ) ) <EOL> self . jsonconn = jsonrpc . ServiceProxy ( \"<STR_LIT>\" % ( <EOL> self . __passwd , self . __host , self . __jsonport ) ) <EOL> def _xmlcall_time ( self , method , * args ) : <EOL> m = getattr ( self . xmlconn , \"<STR_LIT>\" % ( method ) ) <EOL> t1 = time . time ( ) <EOL> ret = m ( * args ) <EOL> dur = time . time ( ) - t1 <EOL> self . plog . info ( \"<STR_LIT>\" % ( method , dur * <NUM_LIT:1000> ) ) <EOL> return ret <EOL> def _xmlcall_fast ( self , method , * args ) : <EOL> m = getattr ( self . xmlconn , \"<STR_LIT>\" % ( method ) ) <EOL> return m ( * args ) <EOL> def rebuildCache ( self ) : <EOL> self . __sliceCache = SliceCache ( ) <EOL> def getDeviceList ( self ) : <EOL> self . log . debug ( \"<STR_LIT>\" ) <EOL> dl = self . xmlcall ( \"<STR_LIT>\" ) <EOL> dl . sort ( ) <EOL> return dl <EOL> def getLinkList ( self ) : <EOL> self . log . debug ( \"<STR_LIT>\" ) <EOL> return self . xmlcall ( \"<STR_LIT>\" ) <EOL> def getFVVersion ( self ) : <EOL> self . log . debug ( \"<STR_LIT>\" ) <EOL> self . fvversion = self . xmlcall ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return self . fvversion <EOL> def getDevicePorts ( self , dpid ) : <EOL> self . log . debug ( \"<STR_LIT>\" % ( dpid ) ) <EOL> pinfoall = [ ] <EOL> if \"<STR_LIT>\" in self . getFVVersion ( ) : <EOL> pinfoall = self . xmlcall ( \"<STR_LIT>\" , dpid , \"<STR_LIT:all>\" ) <EOL> portlist = [ ] <EOL> dinfo = self . xmlcall ( \"<STR_LIT>\" , dpid ) <EOL> for portstr in dinfo [ \"<STR_LIT>\" ] . split ( \"<STR_LIT:U+002C>\" ) : <EOL> p = Port ( ) <EOL> elems = portstr . split ( \"<STR_LIT:(>\" ) <EOL> p . name = elems [ <NUM_LIT:0> ] <EOL> p . num = int ( elems [ <NUM_LIT:1> ] [ : - <NUM_LIT:1> ] ) <EOL> for pinfo in pinfoall : <EOL> pelems = pinfo . split ( \"<STR_LIT:U+002C>\" ) <EOL> if int ( pelems [ <NUM_LIT:0> ] ) == p . num : <EOL> p . features = pelems [ <NUM_LIT:2> ] <EOL> break <EOL> p . dpid = dpid <EOL> portlist . append ( p ) <EOL> return portlist <EOL> def getCombinedStats ( self , slice_name ) : <EOL> return None <EOL> def deleteSlice ( self , slice_name ) : <EOL> self . log . debug ( \"<STR_LIT>\" % ( slice_name ) ) <EOL> self . xmlcall ( \"<STR_LIT>\" , slice_name ) <EOL> self . __sliceCache . delete ( slice_name ) <EOL> def sliceExists ( self , slice_name ) : <EOL> return self . __sliceCache . exists ( slice_name ) <EOL> def getSliceInfo ( self , slice_name ) : <EOL> self . log . debug ( \"<STR_LIT>\" % ( slice_name ) ) <EOL> try : <EOL> sinfo = self . xmlcall ( \"<STR_LIT>\" , slice_name ) <EOL> return sinfo <EOL> except : <EOL> return None <EOL> def createSlice ( self , slice_name , controller , email ) : <EOL>", "answer": "self . log . debug ( \"<STR_LIT>\" % ( slice_name , controller , email ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = <NUM_LIT:8>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> class Notification ( object ) : <EOL> STARTUP = \"<STR_LIT>\" <EOL> SHOW_DIALOG = \"<STR_LIT>\" <EOL> HELLO = \"<STR_LIT:hello>\" <EOL> FILE_LOADED = \"<STR_LIT>\" <EOL> EDIT_SELECTED = \"<STR_LIT>\" <EOL>", "answer": "SUM_SELECTED = \"<STR_LIT>\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os , os . path <EOL> import shutil <EOL> import time <EOL> from play . utils import * <EOL> COMMANDS = [ '<STR_LIT>' ] <EOL>", "answer": "HELP = {"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> CONSTANTS = [ '<STR_LIT:e>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> FUNCTIONS = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> DISTRIBUTIONS = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from vyapp . plugins import ENV <EOL> from vyapp . areavi import AreaVi <EOL>", "answer": "ENV [ '<STR_LIT>' ] = lambda filename : AreaVi . ACTIVE . save_data_as ( filename )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import os <EOL> import unittest <EOL> class LauncherTests ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def run_test ( self , script , args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> old_cwd = os . getcwd ( ) <EOL>", "answer": "test_dir = os . path . dirname ( os . path . dirname ( __file__ ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import web <EOL> import socket <EOL> from karesansui . lib . rest import Rest , auth <EOL> from karesansui . lib . log . config import LogViewConfigParam <EOL> from karesansui . lib . const import LOG_VIEW_XML_FILE <EOL> class HostBy1Log ( Rest ) : <EOL> @ auth <EOL>", "answer": "def _GET ( self , * param , ** params ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import mock <EOL> from rally . plugins . openstack . context . nova import keypairs <EOL> from tests . unit import test <EOL> CTX = \"<STR_LIT>\" <EOL> class KeyPairContextTestCase ( test . TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( KeyPairContextTestCase , self ) . setUp ( ) <EOL> self . users = <NUM_LIT:2> <EOL> task = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> self . ctx_with_keys = { <EOL> \"<STR_LIT>\" : [ <EOL> { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT:id>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:key>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT:id>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:key>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> ] , <EOL> \"<STR_LIT>\" : task <EOL>", "answer": "}"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . contrib import admin <EOL> from models import ErrorReport <EOL> class ErrorReportAdmin ( admin . ModelAdmin ) : <EOL> search_fields = ( '<STR_LIT:message>' , <EOL> '<STR_LIT:url>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT:data>' ) <EOL> date_hierarchy = '<STR_LIT>' <EOL> list_display = ( '<STR_LIT>' , <EOL> '<STR_LIT:message>' , <EOL> '<STR_LIT:url>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from builtins import range <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> import sys <EOL> import re <EOL> PYTHON_VERSION = sys . version_info [ : <NUM_LIT:3> ] <EOL> PY2 = ( PYTHON_VERSION [ <NUM_LIT:0> ] == <NUM_LIT:2> ) <EOL> if PY2 : <EOL> if PYTHON_VERSION < ( <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:9> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> elif PYTHON_VERSION < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> import hpOneView as hpov <EOL> from pprint import pprint <EOL> def acceptEULA ( con ) : <EOL> con . get_eula_status ( ) <EOL> try : <EOL> if con . get_eula_status ( ) is True : <EOL> print ( '<STR_LIT>' ) <EOL> con . set_eula ( '<STR_LIT>' ) <EOL> except Exception as e : <EOL> print ( '<STR_LIT>' ) <EOL> print ( e ) <EOL> def login ( con , credential ) : <EOL> try : <EOL> con . login ( credential ) <EOL> except : <EOL> print ( '<STR_LIT>' ) <EOL> def get_managed_sans ( fcs ) : <EOL> sans = fcs . get_managed_sans ( ) <EOL> pprint ( sans ) <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( add_help = True , <EOL> formatter_class = argparse . RawTextHelpFormatter , <EOL> description = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:host>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:user>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT:-c>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> args = parser . parse_args ( ) <EOL> credential = { '<STR_LIT>' : args . domain . upper ( ) , '<STR_LIT>' : args . user , '<STR_LIT:password>' : args . passwd } <EOL> con = hpov . connection ( args . host ) <EOL> fcs = hpov . fcsans ( con ) <EOL> if args . proxy : <EOL> con . set_proxy ( args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] , args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:1> ] ) <EOL>", "answer": "if args . cert :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import urllib <EOL> from twisted . internet import reactor <EOL> from twisted . web . client import getPage <EOL> from twisted . internet import defer <EOL> from testfixtures import LogCapture <EOL> from jasmin . routing . proxies import RouterPBProxy <EOL> from jasmin . routing . test . test_router import HappySMSCTestCase , SubmitSmTestCaseTools <EOL> from jasmin . routing . test . test_encoding import composeMessage <EOL> from jasmin . routing . test . codepages import GSM0338 <EOL> class LoggingTestCases ( RouterPBProxy , HappySMSCTestCase , SubmitSmTestCaseTools ) : <EOL> @ defer . inlineCallbacks <EOL> def run_test ( self , content , datacoding = None , port = <NUM_LIT> ) : <EOL> yield self . connect ( '<STR_LIT:127.0.0.1>' , self . pbPort ) <EOL> yield self . prepareRoutingsAndStartConnector ( ) <EOL> self . params [ '<STR_LIT:content>' ] = content <EOL> if datacoding is None and '<STR_LIT>' in self . params : <EOL> del self . params [ '<STR_LIT>' ] <EOL> if datacoding is not None : <EOL> self . params [ '<STR_LIT>' ] = datacoding <EOL> baseurl = '<STR_LIT>' % ( port , urllib . urlencode ( self . params ) ) <EOL> c = yield getPage ( baseurl , method = self . method , postdata = self . postdata ) <EOL> msgStatus = c [ : <NUM_LIT:7> ] <EOL> exitDeferred = defer . Deferred ( ) <EOL> reactor . callLater ( <NUM_LIT:2> , exitDeferred . callback , None ) <EOL> yield exitDeferred <EOL> yield self . stopSmppClientConnectors ( ) <EOL>", "answer": "self . assertEqual ( msgStatus , '<STR_LIT>' )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> import sys <EOL> from mistralclient . api import client <EOL> import mistralclient . commands . v2 . action_executions <EOL> import mistralclient . commands . v2 . actions <EOL> import mistralclient . commands . v2 . cron_triggers <EOL> import mistralclient . commands . v2 . environments <EOL> import mistralclient . commands . v2 . executions <EOL> import mistralclient . commands . v2 . members <EOL> import mistralclient . commands . v2 . services <EOL> import mistralclient . commands . v2 . tasks <EOL> import mistralclient . commands . v2 . workbooks <EOL> import mistralclient . commands . v2 . workflows <EOL> from mistralclient . openstack . common import cliutils as c <EOL> from cliff import app <EOL> from cliff import command <EOL> from cliff import commandmanager <EOL> import argparse <EOL> LOG = logging . getLogger ( __name__ ) <EOL> class OpenStackHelpFormatter ( argparse . HelpFormatter ) : <EOL> def __init__ ( self , prog , indent_increment = <NUM_LIT:2> , max_help_position = <NUM_LIT:32> , <EOL> width = None ) : <EOL> super ( OpenStackHelpFormatter , self ) . __init__ ( <EOL> prog , <EOL> indent_increment , <EOL> max_help_position , <EOL> width <EOL> ) <EOL> def start_section ( self , heading ) : <EOL> heading = '<STR_LIT>' % ( heading [ <NUM_LIT:0> ] . upper ( ) , heading [ <NUM_LIT:1> : ] ) <EOL> super ( OpenStackHelpFormatter , self ) . start_section ( heading ) <EOL> class HelpAction ( argparse . Action ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __call__ ( self , parser , namespace , values , option_string = None ) : <EOL> outputs = [ ] <EOL> max_len = <NUM_LIT:0> <EOL> app = self . default <EOL> parser . print_help ( app . stdout ) <EOL> app . stdout . write ( '<STR_LIT>' ) <EOL> for name , ep in sorted ( app . command_manager ) : <EOL> factory = ep . load ( ) <EOL> cmd = factory ( self , None ) <EOL> one_liner = cmd . get_description ( ) . split ( '<STR_LIT:\\n>' ) [ <NUM_LIT:0> ] <EOL> outputs . append ( ( name , one_liner ) ) <EOL> max_len = max ( len ( name ) , max_len ) <EOL> for ( name , one_liner ) in outputs : <EOL> app . stdout . write ( '<STR_LIT>' % ( name . ljust ( max_len ) , one_liner ) ) <EOL> sys . exit ( <NUM_LIT:0> ) <EOL> class BashCompletionCommand ( command . Command ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def take_action ( self , parsed_args ) : <EOL> commands = set ( ) <EOL> options = set ( ) <EOL> for option , _action in self . app . parser . _option_string_actions . items ( ) : <EOL> options . add ( option ) <EOL> for command_name , _cmd in self . app . command_manager : <EOL> commands . add ( command_name ) <EOL> print ( '<STR_LIT:U+0020>' . join ( commands | options ) ) <EOL> class MistralShell ( app . App ) : <EOL> def __init__ ( self ) : <EOL> super ( MistralShell , self ) . __init__ ( <EOL> description = __doc__ . strip ( ) , <EOL> version = mistralclient . __version__ , <EOL> command_manager = commandmanager . CommandManager ( '<STR_LIT>' ) , <EOL> ) <EOL> self . _set_shell_commands ( self . _get_commands_v2 ( ) ) <EOL> def configure_logging ( self ) : <EOL> log_lvl = logging . DEBUG if self . options . debug else logging . WARNING <EOL> logging . basicConfig ( <EOL> format = \"<STR_LIT>\" , <EOL> level = log_lvl <EOL> ) <EOL> logging . getLogger ( '<STR_LIT>' ) . setLevel ( logging . WARNING ) <EOL> if self . options . verbose_level <= <NUM_LIT:1> : <EOL> logging . getLogger ( '<STR_LIT>' ) . setLevel ( logging . WARNING ) <EOL> def build_option_parser ( self , description , version , <EOL> argparse_kwargs = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> argparse_kwargs = argparse_kwargs or { } <EOL> parser = argparse . ArgumentParser ( <EOL> description = description , <EOL> add_help = False , <EOL> formatter_class = OpenStackHelpFormatter , <EOL> ** argparse_kwargs <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:version>' , <EOL> version = '<STR_LIT>' . format ( version ) , <EOL> help = '<STR_LIT>' <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> action = '<STR_LIT:count>' , <EOL> dest = '<STR_LIT>' , <EOL> default = self . DEFAULT_VERBOSE_LEVEL , <EOL> help = '<STR_LIT>' , <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store>' , <EOL> default = None , <EOL> help = '<STR_LIT>' , <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> action = '<STR_LIT>' , <EOL> dest = '<STR_LIT>' , <EOL> const = <NUM_LIT:0> , <EOL> help = '<STR_LIT>' , <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> action = HelpAction , <EOL> nargs = <NUM_LIT:0> , <EOL> default = self , <EOL> help = \"<STR_LIT>\" , <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> default = False , <EOL> action = '<STR_LIT:store_true>' , <EOL> help = '<STR_LIT>' , <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store>' , <EOL> dest = '<STR_LIT>' , <EOL> default = c . env ( '<STR_LIT>' ) , <EOL> help = '<STR_LIT>' <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store>' , <EOL> dest = '<STR_LIT>' , <EOL> default = c . env ( '<STR_LIT>' , default = '<STR_LIT>' ) , <EOL> help = '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store>' , <EOL> dest = '<STR_LIT>' , <EOL> default = c . env ( '<STR_LIT>' , default = '<STR_LIT>' ) , <EOL> help = '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store>' , <EOL> dest = '<STR_LIT>' , <EOL> default = c . env ( '<STR_LIT>' , default = '<STR_LIT>' ) , <EOL> help = '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store>' , <EOL> dest = '<STR_LIT:username>' , <EOL> default = c . env ( '<STR_LIT>' , default = '<STR_LIT>' ) , <EOL> help = '<STR_LIT>' <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store>' , <EOL> dest = '<STR_LIT:password>' , <EOL> default = c . env ( '<STR_LIT>' ) , <EOL> help = '<STR_LIT>' <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store>' , <EOL> dest = '<STR_LIT>' , <EOL> default = c . env ( '<STR_LIT>' ) , <EOL> help = '<STR_LIT>' <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store>' , <EOL> dest = '<STR_LIT>' , <EOL> default = c . env ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> help = '<STR_LIT>' <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store>' , <EOL> dest = '<STR_LIT>' , <EOL> default = c . env ( '<STR_LIT>' ) , <EOL> help = '<STR_LIT>' <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store>' , <EOL> dest = '<STR_LIT>' , <EOL> default = c . env ( '<STR_LIT>' ) , <EOL> help = '<STR_LIT>' <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store>' , <EOL> dest = '<STR_LIT>' , <EOL> default = c . env ( '<STR_LIT>' ) , <EOL> help = '<STR_LIT>' <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> dest = '<STR_LIT>' , <EOL> default = c . env ( '<STR_LIT>' , default = False ) , <EOL> help = '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) <EOL> return parser <EOL> def initialize_app ( self , argv ) : <EOL> self . _clear_shell_commands ( ) <EOL> ver = client . determine_client_version ( self . options . mistral_version ) <EOL> self . _set_shell_commands ( self . _get_commands ( ver ) ) <EOL> do_help = ( '<STR_LIT>' in argv ) or ( '<STR_LIT>' in argv ) or not argv <EOL> if not self . options . auth_url : <EOL> if self . options . password or self . options . token : <EOL> self . options . auth_url = '<STR_LIT>' <EOL> if do_help or ( '<STR_LIT>' in argv ) : <EOL> self . options . auth_url = None <EOL> self . client = client . client ( <EOL> mistral_url = self . options . mistral_url , <EOL> username = self . options . username , <EOL> api_key = self . options . password , <EOL> project_name = self . options . tenant_name , <EOL> auth_url = self . options . auth_url , <EOL> project_id = self . options . tenant_id , <EOL> endpoint_type = self . options . endpoint_type , <EOL> service_type = self . options . service_type , <EOL> auth_token = self . options . token , <EOL> cacert = self . options . cacert , <EOL> insecure = self . options . insecure <EOL> ) <EOL> ClientManager = type ( <EOL> '<STR_LIT>' , <EOL> ( object , ) , <EOL> dict ( workflow_engine = self . client ) <EOL> ) <EOL> self . client_manager = ClientManager ( ) <EOL> def _set_shell_commands ( self , cmds_dict ) : <EOL> for k , v in cmds_dict . items ( ) : <EOL> self . command_manager . add_command ( k , v ) <EOL> def _clear_shell_commands ( self ) : <EOL> exclude_cmds = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> cmds = self . command_manager . commands . copy ( ) <EOL> for k , v in cmds . items ( ) : <EOL> if k not in exclude_cmds : <EOL> self . command_manager . commands . pop ( k ) <EOL> def _get_commands ( self , version ) : <EOL> if version == <NUM_LIT:2> : <EOL> return self . _get_commands_v2 ( ) <EOL> return { } <EOL> @ staticmethod <EOL> def _get_commands_v2 ( ) : <EOL> return { <EOL> '<STR_LIT>' : BashCompletionCommand , <EOL> '<STR_LIT>' : mistralclient . commands . v2 . workbooks . List , <EOL> '<STR_LIT>' : mistralclient . commands . v2 . workbooks . Get , <EOL> '<STR_LIT>' : mistralclient . commands . v2 . workbooks . Create , <EOL> '<STR_LIT>' : mistralclient . commands . v2 . workbooks . Delete , <EOL>", "answer": "'<STR_LIT>' : mistralclient . commands . v2 . workbooks . Update ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import logging <EOL> from os . path import realpath , dirname <EOL> from logging import config , DEBUG , INFO <EOL> __all__ = [ \"<STR_LIT>\" ] <EOL> class Log ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def debug ( self , debug ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . logger . isEnabledFor ( DEBUG ) : <EOL> self . logger . debug ( debug ) <EOL>", "answer": "def info ( self , info ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . rename_column ( '<STR_LIT>' , '<STR_LIT:float>' , '<STR_LIT>' ) <EOL> def backwards ( self , orm ) : <EOL> db . rename_column ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:float>' ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:password>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:username>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:5>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:0>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:None>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:1>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:0>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL>", "answer": "'<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> __author__ = \"<STR_LIT>\" <EOL> def merge_sort ( array ) : <EOL> '''<STR_LIT>''' <EOL> if len ( array ) < <NUM_LIT:2> : <EOL> return array <EOL> mid = len ( array ) // <NUM_LIT:2> <EOL> left = merge_sort ( array [ : mid ] ) <EOL> right = merge_sort ( array [ mid : ] ) <EOL> res = [ ] <EOL> i , j = <NUM_LIT:0> , <NUM_LIT:0> <EOL> while i < len ( left ) and j < len ( right ) : <EOL> if left [ i ] <= right [ j ] : <EOL> res . append ( left [ i ] ) <EOL> i += <NUM_LIT:1> <EOL> else : <EOL> res . append ( right [ j ] ) <EOL> j += <NUM_LIT:1> <EOL> if left [ i : ] : <EOL>", "answer": "res . extend ( left [ i : ] )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL> import os <EOL> from celery import Celery <EOL> from django . conf import settings <EOL> os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> app = Celery ( '<STR_LIT>' ) <EOL>", "answer": "app . config_from_object ( '<STR_LIT>' )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> from flask import Flask , request , render_template <EOL> from flask . ext . babel import Babel <EOL> from . config import DefaultConfig <EOL> from . user import User , user <EOL> from . settings import settings <EOL> from . frontend import frontend <EOL> from . api import api <EOL> from . admin import admin <EOL> from . extensions import db , mail , cache , login_manager , oid <EOL> from . utils import INSTANCE_FOLDER_PATH <EOL> __all__ = [ '<STR_LIT>' ] <EOL> DEFAULT_BLUEPRINTS = ( <EOL> frontend , <EOL> user , <EOL> settings , <EOL> api , <EOL> admin , <EOL> ) <EOL> def create_app ( config = None , app_name = None , blueprints = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if app_name is None : <EOL> app_name = DefaultConfig . PROJECT <EOL> if blueprints is None : <EOL> blueprints = DEFAULT_BLUEPRINTS <EOL> app = Flask ( app_name , instance_path = INSTANCE_FOLDER_PATH , instance_relative_config = True ) <EOL> configure_app ( app , config ) <EOL> configure_hook ( app ) <EOL> configure_blueprints ( app , blueprints ) <EOL> configure_extensions ( app ) <EOL> configure_logging ( app ) <EOL> configure_template_filters ( app ) <EOL>", "answer": "configure_error_handlers ( app )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , division , print_function <EOL> from datetime import datetime <EOL> try : <EOL> import unittest2 as unittest <EOL> except ImportError : <EOL> import unittest <EOL> import numpy as np <EOL> import quantities as pq <EOL> try : <EOL> from IPython . lib . pretty import pretty <EOL> except ImportError as err : <EOL> HAVE_IPYTHON = False <EOL> else : <EOL> HAVE_IPYTHON = True <EOL> from neo . core . segment import Segment <EOL> from neo . core import ( AnalogSignalArray , Block , <EOL> Epoch , EpochArray , <EOL> RecordingChannelGroup , SpikeTrain , Unit ) <EOL> from neo . core . container import filterdata <EOL> from neo . test . tools import ( assert_neo_object_is_compliant , <EOL> assert_same_sub_schema ) <EOL> from neo . test . generate_datasets import ( fake_neo , get_fake_value , <EOL> get_fake_values , get_annotations , <EOL> clone_object , TEST_ANNOTATIONS ) <EOL> class Test__generate_datasets ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> np . random . seed ( <NUM_LIT:0> ) <EOL> self . annotations = dict ( [ ( str ( x ) , TEST_ANNOTATIONS [ x ] ) for x in <EOL> range ( len ( TEST_ANNOTATIONS ) ) ] ) <EOL> def test__get_fake_values ( self ) : <EOL> self . annotations [ '<STR_LIT>' ] = <NUM_LIT:0> <EOL> file_datetime = get_fake_value ( '<STR_LIT>' , datetime , seed = <NUM_LIT:0> ) <EOL> rec_datetime = get_fake_value ( '<STR_LIT>' , datetime , seed = <NUM_LIT:1> ) <EOL> index = get_fake_value ( '<STR_LIT:index>' , int , seed = <NUM_LIT:2> ) <EOL> name = get_fake_value ( '<STR_LIT:name>' , str , seed = <NUM_LIT:3> , obj = Segment ) <EOL> description = get_fake_value ( '<STR_LIT:description>' , str , seed = <NUM_LIT:4> , obj = '<STR_LIT>' ) <EOL> file_origin = get_fake_value ( '<STR_LIT>' , str ) <EOL> attrs1 = { '<STR_LIT>' : file_datetime , <EOL> '<STR_LIT>' : rec_datetime , <EOL> '<STR_LIT:index>' : index , <EOL> '<STR_LIT:name>' : name , <EOL> '<STR_LIT:description>' : description , <EOL> '<STR_LIT>' : file_origin } <EOL> attrs2 = attrs1 . copy ( ) <EOL> attrs2 . update ( self . annotations ) <EOL> res11 = get_fake_values ( Segment , annotate = False , seed = <NUM_LIT:0> ) <EOL> res12 = get_fake_values ( '<STR_LIT>' , annotate = False , seed = <NUM_LIT:0> ) <EOL> res21 = get_fake_values ( Segment , annotate = True , seed = <NUM_LIT:0> ) <EOL> res22 = get_fake_values ( '<STR_LIT>' , annotate = True , seed = <NUM_LIT:0> ) <EOL> self . assertEqual ( res11 , attrs1 ) <EOL> self . assertEqual ( res12 , attrs1 ) <EOL> self . assertEqual ( res21 , attrs2 ) <EOL> self . assertEqual ( res22 , attrs2 ) <EOL> def test__fake_neo__cascade ( self ) : <EOL> self . annotations [ '<STR_LIT>' ] = None <EOL> obj_type = Segment <EOL> cascade = True <EOL> res = fake_neo ( obj_type = obj_type , cascade = cascade ) <EOL> self . assertTrue ( isinstance ( res , Segment ) ) <EOL> assert_neo_object_is_compliant ( res ) <EOL> self . assertEqual ( res . annotations , self . annotations ) <EOL> self . assertEqual ( len ( res . analogsignalarrays ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( res . analogsignals ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( res . irregularlysampledsignals ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( res . spiketrains ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( res . spikes ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( res . events ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( res . epochs ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( res . eventarrays ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( res . epocharrays ) , <NUM_LIT:1> ) <EOL> for child in res . children : <EOL> del child . annotations [ '<STR_LIT:i>' ] <EOL> del child . annotations [ '<STR_LIT>' ] <EOL> self . assertEqual ( res . analogsignalarrays [ <NUM_LIT:0> ] . annotations , <EOL> self . annotations ) <EOL> self . assertEqual ( res . analogsignals [ <NUM_LIT:0> ] . annotations , <EOL> self . annotations ) <EOL> self . assertEqual ( res . irregularlysampledsignals [ <NUM_LIT:0> ] . annotations , <EOL> self . annotations ) <EOL> self . assertEqual ( res . spiketrains [ <NUM_LIT:0> ] . annotations , <EOL> self . annotations ) <EOL> self . assertEqual ( res . spikes [ <NUM_LIT:0> ] . annotations , <EOL> self . annotations ) <EOL> self . assertEqual ( res . events [ <NUM_LIT:0> ] . annotations , <EOL> self . annotations ) <EOL> self . assertEqual ( res . epochs [ <NUM_LIT:0> ] . annotations , <EOL> self . annotations ) <EOL> self . assertEqual ( res . eventarrays [ <NUM_LIT:0> ] . annotations , <EOL> self . annotations ) <EOL> self . assertEqual ( res . epocharrays [ <NUM_LIT:0> ] . annotations , <EOL> self . annotations ) <EOL> def test__fake_neo__nocascade ( self ) : <EOL> self . annotations [ '<STR_LIT>' ] = None <EOL> obj_type = '<STR_LIT>' <EOL> cascade = False <EOL> res = fake_neo ( obj_type = obj_type , cascade = cascade ) <EOL> self . assertTrue ( isinstance ( res , Segment ) ) <EOL> assert_neo_object_is_compliant ( res ) <EOL> self . assertEqual ( res . annotations , self . annotations ) <EOL> self . assertEqual ( len ( res . analogsignalarrays ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( len ( res . analogsignals ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( len ( res . irregularlysampledsignals ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( len ( res . spiketrains ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( len ( res . spikes ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( len ( res . events ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( len ( res . epochs ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( len ( res . eventarrays ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( len ( res . epocharrays ) , <NUM_LIT:0> ) <EOL> class TestSegment ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . nchildren = <NUM_LIT:2> <EOL> blk = fake_neo ( Block , seed = <NUM_LIT:0> , n = self . nchildren ) <EOL> self . unit1 , self . unit2 , self . unit3 , self . unit4 = blk . list_units <EOL> self . seg1 , self . seg2 = blk . segments <EOL> self . targobj = self . seg1 <EOL> self . seed1 = self . seg1 . annotations [ '<STR_LIT>' ] <EOL> self . seed2 = self . seg2 . annotations [ '<STR_LIT>' ] <EOL> del self . seg1 . annotations [ '<STR_LIT:i>' ] <EOL> del self . seg2 . annotations [ '<STR_LIT:i>' ] <EOL> del self . seg1 . annotations [ '<STR_LIT>' ] <EOL> del self . seg2 . annotations [ '<STR_LIT>' ] <EOL> self . sigs1 = self . seg1 . analogsignals <EOL> self . sigs2 = self . seg2 . analogsignals <EOL> self . sigarrs1 = self . seg1 . analogsignalarrays <EOL> self . sigarrs2 = self . seg2 . analogsignalarrays <EOL> self . irsigs1 = self . seg1 . irregularlysampledsignals <EOL> self . irsigs2 = self . seg2 . irregularlysampledsignals <EOL> self . spikes1 = self . seg1 . spikes <EOL> self . spikes2 = self . seg2 . spikes <EOL> self . trains1 = self . seg1 . spiketrains <EOL> self . trains2 = self . seg2 . spiketrains <EOL> self . epcs1 = self . seg1 . epochs <EOL> self . epcs2 = self . seg2 . epochs <EOL> self . epcas1 = self . seg1 . epocharrays <EOL> self . epcas2 = self . seg2 . epocharrays <EOL> self . evts1 = self . seg1 . events <EOL> self . evts2 = self . seg2 . events <EOL> self . evtas1 = self . seg1 . eventarrays <EOL> self . evtas2 = self . seg2 . eventarrays <EOL> self . sigs1a = clone_object ( self . sigs1 ) <EOL> self . sigarrs1a = clone_object ( self . sigarrs1 , n = <NUM_LIT:2> ) <EOL> self . irsigs1a = clone_object ( self . irsigs1 ) <EOL> self . spikes1a = clone_object ( self . spikes1 ) <EOL> self . trains1a = clone_object ( self . trains1 ) <EOL> self . epcs1a = clone_object ( self . epcs1 ) <EOL> self . epcas1a = clone_object ( self . epcas1 ) <EOL> self . evts1a = clone_object ( self . evts1 ) <EOL> self . evtas1a = clone_object ( self . evtas1 ) <EOL> for obj , obja in zip ( self . sigs1 + self . sigarrs1 , <EOL> self . sigs1a + self . sigarrs1a ) : <EOL> obja . channel_index = obj . channel_index <EOL> def test_init ( self ) : <EOL> seg = Segment ( name = '<STR_LIT>' , index = <NUM_LIT:3> ) <EOL> assert_neo_object_is_compliant ( seg ) <EOL> self . assertEqual ( seg . name , '<STR_LIT>' ) <EOL> self . assertEqual ( seg . file_origin , None ) <EOL> self . assertEqual ( seg . index , <NUM_LIT:3> ) <EOL> def check_creation ( self , seg ) : <EOL> assert_neo_object_is_compliant ( seg ) <EOL> seed = seg . annotations [ '<STR_LIT>' ] <EOL> targ0 = get_fake_value ( '<STR_LIT>' , datetime , seed = seed + <NUM_LIT:0> ) <EOL> self . assertEqual ( seg . file_datetime , targ0 ) <EOL> targ1 = get_fake_value ( '<STR_LIT>' , datetime , seed = seed + <NUM_LIT:1> ) <EOL> self . assertEqual ( seg . rec_datetime , targ1 ) <EOL> targ2 = get_fake_value ( '<STR_LIT:index>' , int , seed = seed + <NUM_LIT:2> ) <EOL> self . assertEqual ( seg . index , targ2 ) <EOL> targ3 = get_fake_value ( '<STR_LIT:name>' , str , seed = seed + <NUM_LIT:3> , obj = Segment ) <EOL> self . assertEqual ( seg . name , targ3 ) <EOL> targ4 = get_fake_value ( '<STR_LIT:description>' , str , <EOL> seed = seed + <NUM_LIT:4> , obj = Segment ) <EOL> self . assertEqual ( seg . description , targ4 ) <EOL> targ5 = get_fake_value ( '<STR_LIT>' , str ) <EOL> self . assertEqual ( seg . file_origin , targ5 ) <EOL> targ6 = get_annotations ( ) <EOL> targ6 [ '<STR_LIT>' ] = seed <EOL> self . assertEqual ( seg . annotations , targ6 ) <EOL> self . assertTrue ( hasattr ( seg , '<STR_LIT>' ) ) <EOL> self . assertTrue ( hasattr ( seg , '<STR_LIT>' ) ) <EOL> self . assertTrue ( hasattr ( seg , '<STR_LIT>' ) ) <EOL> self . assertTrue ( hasattr ( seg , '<STR_LIT>' ) ) <EOL> self . assertTrue ( hasattr ( seg , '<STR_LIT>' ) ) <EOL> self . assertTrue ( hasattr ( seg , '<STR_LIT>' ) ) <EOL> self . assertTrue ( hasattr ( seg , '<STR_LIT>' ) ) <EOL> self . assertTrue ( hasattr ( seg , '<STR_LIT>' ) ) <EOL> self . assertTrue ( hasattr ( seg , '<STR_LIT>' ) ) <EOL> self . assertEqual ( len ( seg . analogsignals ) , self . nchildren ** <NUM_LIT:2> ) <EOL> self . assertEqual ( len ( seg . analogsignalarrays ) , self . nchildren ) <EOL> self . assertEqual ( len ( seg . irregularlysampledsignals ) , self . nchildren ** <NUM_LIT:2> ) <EOL> self . assertEqual ( len ( seg . epochs ) , self . nchildren ) <EOL> self . assertEqual ( len ( seg . epocharrays ) , self . nchildren ) <EOL> self . assertEqual ( len ( seg . events ) , self . nchildren ) <EOL> self . assertEqual ( len ( seg . eventarrays ) , self . nchildren ) <EOL> self . assertEqual ( len ( seg . spikes ) , self . nchildren ** <NUM_LIT:2> ) <EOL> self . assertEqual ( len ( seg . spiketrains ) , self . nchildren ** <NUM_LIT:2> ) <EOL> def test__creation ( self ) : <EOL> self . check_creation ( self . seg1 ) <EOL> self . check_creation ( self . seg2 ) <EOL> def test__merge ( self ) : <EOL> seg1a = fake_neo ( Block , seed = self . seed1 , n = self . nchildren ) . segments [ <NUM_LIT:0> ] <EOL> assert_same_sub_schema ( self . seg1 , seg1a ) <EOL> seg1a . spikes . append ( self . spikes2 [ <NUM_LIT:0> ] ) <EOL> seg1a . epocharrays . append ( self . epcas2 [ <NUM_LIT:0> ] ) <EOL> seg1a . annotate ( seed = self . seed2 ) <EOL> seg1a . merge ( self . seg2 ) <EOL> self . check_creation ( self . seg2 ) <EOL> assert_same_sub_schema ( self . sigs1a + self . sigs2 , seg1a . analogsignals ) <EOL> assert_same_sub_schema ( self . sigarrs1a + self . sigarrs2 , <EOL> seg1a . analogsignalarrays ) <EOL> assert_same_sub_schema ( self . irsigs1a + self . irsigs2 , <EOL> seg1a . irregularlysampledsignals ) <EOL> assert_same_sub_schema ( self . epcs1 + self . epcs2 , seg1a . epochs ) <EOL> assert_same_sub_schema ( self . epcas1 + self . epcas2 , seg1a . epocharrays ) <EOL> assert_same_sub_schema ( self . evts1 + self . evts2 , seg1a . events ) <EOL> assert_same_sub_schema ( self . evtas1 + self . evtas2 , seg1a . eventarrays ) <EOL> assert_same_sub_schema ( self . spikes1 + self . spikes2 , seg1a . spikes ) <EOL> assert_same_sub_schema ( self . trains1 + self . trains2 , seg1a . spiketrains ) <EOL> def test__children ( self ) : <EOL> blk = Block ( name = '<STR_LIT>' ) <EOL> blk . segments = [ self . seg1 ] <EOL> blk . create_many_to_one_relationship ( force = True ) <EOL> assert_neo_object_is_compliant ( self . seg1 ) <EOL> assert_neo_object_is_compliant ( blk ) <EOL> childobjs = ( '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> childconts = ( '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertEqual ( self . seg1 . _container_child_objects , ( ) ) <EOL> self . assertEqual ( self . seg1 . _data_child_objects , childobjs ) <EOL> self . assertEqual ( self . seg1 . _single_parent_objects , ( '<STR_LIT>' , ) ) <EOL> self . assertEqual ( self . seg1 . _multi_child_objects , ( ) ) <EOL> self . assertEqual ( self . seg1 . _multi_parent_objects , ( ) ) <EOL> self . assertEqual ( self . seg1 . _child_properties , ( ) ) <EOL> self . assertEqual ( self . seg1 . _single_child_objects , childobjs ) <EOL> self . assertEqual ( self . seg1 . _container_child_containers , ( ) ) <EOL> self . assertEqual ( self . seg1 . _data_child_containers , childconts ) <EOL> self . assertEqual ( self . seg1 . _single_child_containers , childconts ) <EOL> self . assertEqual ( self . seg1 . _single_parent_containers , ( '<STR_LIT>' , ) ) <EOL> self . assertEqual ( self . seg1 . _multi_child_containers , ( ) ) <EOL> self . assertEqual ( self . seg1 . _multi_parent_containers , ( ) ) <EOL> self . assertEqual ( self . seg1 . _child_objects , childobjs ) <EOL> self . assertEqual ( self . seg1 . _child_containers , childconts ) <EOL> self . assertEqual ( self . seg1 . _parent_objects , ( '<STR_LIT>' , ) ) <EOL> self . assertEqual ( self . seg1 . _parent_containers , ( '<STR_LIT>' , ) ) <EOL> totchildren = ( self . nchildren * <NUM_LIT:2> * <NUM_LIT:2> + <EOL> self . nchildren + <EOL> <NUM_LIT:2> * ( self . nchildren ** <NUM_LIT:2> ) + <EOL> <NUM_LIT:2> * ( self . nchildren ** <NUM_LIT:2> ) ) <EOL> self . assertEqual ( len ( self . seg1 . _single_children ) , totchildren ) <EOL> self . assertEqual ( len ( self . seg1 . data_children ) , totchildren ) <EOL> self . assertEqual ( len ( self . seg1 . children ) , totchildren ) <EOL> self . assertEqual ( len ( self . seg1 . data_children_recur ) , totchildren ) <EOL> self . assertEqual ( len ( self . seg1 . children_recur ) , totchildren ) <EOL> self . assertEqual ( len ( self . seg1 . _multi_children ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( len ( self . seg1 . container_children ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( len ( self . seg1 . container_children_recur ) , <NUM_LIT:0> ) <EOL> children = ( self . sigs1a + self . sigarrs1a + <EOL> self . epcs1a + self . epcas1a + <EOL> self . evts1a + self . evtas1a + <EOL> self . irsigs1a + <EOL> self . spikes1a + self . trains1a ) <EOL> assert_same_sub_schema ( list ( self . seg1 . _single_children ) , children ) <EOL> assert_same_sub_schema ( list ( self . seg1 . data_children ) , children ) <EOL> assert_same_sub_schema ( list ( self . seg1 . data_children_recur ) , children ) <EOL> assert_same_sub_schema ( list ( self . seg1 . children ) , children ) <EOL> assert_same_sub_schema ( list ( self . seg1 . children_recur ) , children ) <EOL> self . assertEqual ( len ( self . seg1 . parents ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( self . seg1 . parents [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> def test__size ( self ) : <EOL> targ1 = { \"<STR_LIT>\" : self . nchildren , \"<STR_LIT>\" : self . nchildren , <EOL> \"<STR_LIT>\" : self . nchildren ** <NUM_LIT:2> , <EOL> \"<STR_LIT>\" : self . nchildren ** <NUM_LIT:2> , <EOL> \"<STR_LIT>\" : self . nchildren ** <NUM_LIT:2> , <EOL> \"<STR_LIT>\" : self . nchildren ** <NUM_LIT:2> , <EOL> \"<STR_LIT>\" : self . nchildren , \"<STR_LIT>\" : self . nchildren , <EOL> \"<STR_LIT>\" : self . nchildren } <EOL> self . assertEqual ( self . targobj . size , targ1 ) <EOL> def test__filter_none ( self ) : <EOL> targ = [ ] <EOL> res0 = self . targobj . filter ( ) <EOL> res1 = self . targobj . filter ( { } ) <EOL> res2 = self . targobj . filter ( [ ] ) <EOL> res3 = self . targobj . filter ( [ { } ] ) <EOL> res4 = self . targobj . filter ( [ { } , { } ] ) <EOL> res5 = self . targobj . filter ( [ { } , { } ] ) <EOL> res6 = self . targobj . filter ( targdict = { } ) <EOL> res7 = self . targobj . filter ( targdict = [ ] ) <EOL> res8 = self . targobj . filter ( targdict = [ { } ] ) <EOL> res9 = self . targobj . filter ( targdict = [ { } , { } ] ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> assert_same_sub_schema ( res1 , targ ) <EOL> assert_same_sub_schema ( res2 , targ ) <EOL> assert_same_sub_schema ( res3 , targ ) <EOL> assert_same_sub_schema ( res4 , targ ) <EOL> assert_same_sub_schema ( res5 , targ ) <EOL> assert_same_sub_schema ( res6 , targ ) <EOL> assert_same_sub_schema ( res7 , targ ) <EOL> assert_same_sub_schema ( res8 , targ ) <EOL> assert_same_sub_schema ( res9 , targ ) <EOL> def test__filter_annotation_single ( self ) : <EOL> targ = ( self . sigs1a + self . sigarrs1a + <EOL> [ self . epcs1a [ <NUM_LIT:0> ] , self . epcas1a [ <NUM_LIT:0> ] ] + <EOL> [ self . evts1a [ <NUM_LIT:0> ] , self . evtas1a [ <NUM_LIT:0> ] ] + <EOL> self . irsigs1a + <EOL> self . spikes1a + self . trains1a ) <EOL> res0 = self . targobj . filter ( j = <NUM_LIT:0> ) <EOL> res1 = self . targobj . filter ( { '<STR_LIT>' : <NUM_LIT:0> } ) <EOL> res2 = self . targobj . filter ( targdict = { '<STR_LIT>' : <NUM_LIT:0> } ) <EOL> res3 = self . targobj . filter ( [ { '<STR_LIT>' : <NUM_LIT:0> } ] ) <EOL> res4 = self . targobj . filter ( targdict = [ { '<STR_LIT>' : <NUM_LIT:0> } ] ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> assert_same_sub_schema ( res1 , targ ) <EOL> assert_same_sub_schema ( res2 , targ ) <EOL> assert_same_sub_schema ( res3 , targ ) <EOL> assert_same_sub_schema ( res4 , targ ) <EOL> def test__filter_single_annotation_nores ( self ) : <EOL> targ = [ ] <EOL> res0 = self . targobj . filter ( j = <NUM_LIT:5> ) <EOL> res1 = self . targobj . filter ( { '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> res2 = self . targobj . filter ( targdict = { '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> res3 = self . targobj . filter ( [ { '<STR_LIT>' : <NUM_LIT:5> } ] ) <EOL> res4 = self . targobj . filter ( targdict = [ { '<STR_LIT>' : <NUM_LIT:5> } ] ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> assert_same_sub_schema ( res1 , targ ) <EOL> assert_same_sub_schema ( res2 , targ ) <EOL> assert_same_sub_schema ( res3 , targ ) <EOL> assert_same_sub_schema ( res4 , targ ) <EOL> def test__filter_attribute_single ( self ) : <EOL> targ = [ self . epcs1a [ <NUM_LIT:1> ] ] <EOL> res0 = self . targobj . filter ( name = self . epcs1a [ <NUM_LIT:1> ] . name ) <EOL> res1 = self . targobj . filter ( { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name } ) <EOL> res2 = self . targobj . filter ( targdict = { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name } ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> assert_same_sub_schema ( res1 , targ ) <EOL> assert_same_sub_schema ( res2 , targ ) <EOL> def test__filter_attribute_single_nores ( self ) : <EOL> targ = [ ] <EOL> res0 = self . targobj . filter ( name = self . epcs2 [ <NUM_LIT:0> ] . name ) <EOL> res1 = self . targobj . filter ( { '<STR_LIT:name>' : self . epcs2 [ <NUM_LIT:0> ] . name } ) <EOL> res2 = self . targobj . filter ( targdict = { '<STR_LIT:name>' : self . epcs2 [ <NUM_LIT:0> ] . name } ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> assert_same_sub_schema ( res1 , targ ) <EOL> assert_same_sub_schema ( res2 , targ ) <EOL> def test__filter_multi ( self ) : <EOL> targ = ( self . sigs1a + self . sigarrs1a + <EOL> [ self . epcs1a [ <NUM_LIT:0> ] , self . epcas1a [ <NUM_LIT:0> ] ] + <EOL> [ self . evts1a [ <NUM_LIT:0> ] , self . evtas1a [ <NUM_LIT:0> ] ] + <EOL> self . irsigs1a + <EOL> self . spikes1a + self . trains1a + <EOL> [ self . epcs1a [ <NUM_LIT:1> ] ] ) <EOL> res0 = self . targobj . filter ( name = self . epcs1a [ <NUM_LIT:1> ] . name , j = <NUM_LIT:0> ) <EOL> res1 = self . targobj . filter ( { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name , '<STR_LIT>' : <NUM_LIT:0> } ) <EOL> res2 = self . targobj . filter ( targdict = { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name , <EOL> '<STR_LIT>' : <NUM_LIT:0> } ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> assert_same_sub_schema ( res1 , targ ) <EOL> assert_same_sub_schema ( res2 , targ ) <EOL> def test__filter_multi_nores ( self ) : <EOL> targ = [ ] <EOL> res0 = self . targobj . filter ( [ { '<STR_LIT>' : <NUM_LIT:0> } , { } ] ) <EOL> res1 = self . targobj . filter ( { } , ttype = <NUM_LIT:0> ) <EOL> res2 = self . targobj . filter ( [ { } ] , ttype = <NUM_LIT:0> ) <EOL> res3 = self . targobj . filter ( { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name } , j = <NUM_LIT:0> ) <EOL> res4 = self . targobj . filter ( targdict = { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name } , <EOL> j = <NUM_LIT:0> ) <EOL> res5 = self . targobj . filter ( name = self . epcs1a [ <NUM_LIT:1> ] . name , <EOL> targdict = { '<STR_LIT>' : <NUM_LIT:0> } ) <EOL> res6 = self . targobj . filter ( name = self . epcs2 [ <NUM_LIT:0> ] . name , j = <NUM_LIT:5> ) <EOL> res7 = self . targobj . filter ( { '<STR_LIT:name>' : self . epcs2 [ <NUM_LIT:1> ] . name , '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> res8 = self . targobj . filter ( targdict = { '<STR_LIT:name>' : self . epcs2 [ <NUM_LIT:1> ] . name , <EOL> '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> res9 = self . targobj . filter ( { '<STR_LIT:name>' : self . epcs2 [ <NUM_LIT:1> ] . name } , j = <NUM_LIT:5> ) <EOL> res10 = self . targobj . filter ( targdict = { '<STR_LIT:name>' : self . epcs2 [ <NUM_LIT:1> ] . name } , <EOL> j = <NUM_LIT:5> ) <EOL> res11 = self . targobj . filter ( name = self . epcs2 [ <NUM_LIT:1> ] . name , <EOL> targdict = { '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> res12 = self . targobj . filter ( { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name } , j = <NUM_LIT:5> ) <EOL> res13 = self . targobj . filter ( targdict = { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name } , <EOL> j = <NUM_LIT:5> ) <EOL> res14 = self . targobj . filter ( name = self . epcs1a [ <NUM_LIT:1> ] . name , <EOL> targdict = { '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> assert_same_sub_schema ( res1 , targ ) <EOL> assert_same_sub_schema ( res2 , targ ) <EOL> assert_same_sub_schema ( res3 , targ ) <EOL> assert_same_sub_schema ( res4 , targ ) <EOL> assert_same_sub_schema ( res5 , targ ) <EOL> assert_same_sub_schema ( res6 , targ ) <EOL> assert_same_sub_schema ( res7 , targ ) <EOL> assert_same_sub_schema ( res8 , targ ) <EOL> assert_same_sub_schema ( res9 , targ ) <EOL> assert_same_sub_schema ( res10 , targ ) <EOL> assert_same_sub_schema ( res11 , targ ) <EOL> assert_same_sub_schema ( res12 , targ ) <EOL> assert_same_sub_schema ( res13 , targ ) <EOL> assert_same_sub_schema ( res14 , targ ) <EOL> def test__filter_multi_partres ( self ) : <EOL> targ = [ self . epcs1a [ <NUM_LIT:1> ] ] <EOL> res0 = self . targobj . filter ( name = self . epcs1a [ <NUM_LIT:1> ] . name , j = <NUM_LIT:5> ) <EOL> res1 = self . targobj . filter ( { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name , '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> res2 = self . targobj . filter ( targdict = { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name , <EOL> '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> res3 = self . targobj . filter ( [ { '<STR_LIT>' : <NUM_LIT:1> } , { '<STR_LIT:i>' : <NUM_LIT:2> } ] ) <EOL> res4 = self . targobj . filter ( { '<STR_LIT>' : <NUM_LIT:1> } , i = <NUM_LIT:2> ) <EOL> res5 = self . targobj . filter ( [ { '<STR_LIT>' : <NUM_LIT:1> } ] , i = <NUM_LIT:2> ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> assert_same_sub_schema ( res1 , targ ) <EOL> assert_same_sub_schema ( res2 , targ ) <EOL> assert_same_sub_schema ( res3 , targ ) <EOL> assert_same_sub_schema ( res4 , targ ) <EOL> assert_same_sub_schema ( res5 , targ ) <EOL> def test__filter_single_annotation_obj_single ( self ) : <EOL> targ = [ self . epcs1a [ <NUM_LIT:1> ] ] <EOL> res0 = self . targobj . filter ( j = <NUM_LIT:1> , objects = '<STR_LIT>' ) <EOL> res1 = self . targobj . filter ( j = <NUM_LIT:1> , objects = Epoch ) <EOL> res2 = self . targobj . filter ( j = <NUM_LIT:1> , objects = [ '<STR_LIT>' ] ) <EOL> res3 = self . targobj . filter ( j = <NUM_LIT:1> , objects = [ Epoch ] ) <EOL> res4 = self . targobj . filter ( j = <NUM_LIT:1> , objects = [ Epoch , <EOL> RecordingChannelGroup ] ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> assert_same_sub_schema ( res1 , targ ) <EOL> assert_same_sub_schema ( res2 , targ ) <EOL> assert_same_sub_schema ( res3 , targ ) <EOL> assert_same_sub_schema ( res4 , targ ) <EOL> def test__filter_single_annotation_obj_multi ( self ) : <EOL> targ = [ self . epcs1a [ <NUM_LIT:1> ] , self . epcas1a [ <NUM_LIT:1> ] ] <EOL> res0 = self . targobj . filter ( j = <NUM_LIT:1> , objects = [ '<STR_LIT>' , EpochArray ] ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> def test__filter_single_annotation_obj_none ( self ) : <EOL> targ = [ ] <EOL> res0 = self . targobj . filter ( j = <NUM_LIT:1> , objects = RecordingChannelGroup ) <EOL> res1 = self . targobj . filter ( j = <NUM_LIT:1> , objects = '<STR_LIT>' ) <EOL> res2 = self . targobj . filter ( j = <NUM_LIT:1> , objects = [ ] ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> assert_same_sub_schema ( res1 , targ ) <EOL> assert_same_sub_schema ( res2 , targ ) <EOL> def test__filter_single_annotation_norecur ( self ) : <EOL> targ = [ self . epcs1a [ <NUM_LIT:1> ] , self . epcas1a [ <NUM_LIT:1> ] , <EOL> self . evts1a [ <NUM_LIT:1> ] , self . evtas1a [ <NUM_LIT:1> ] ] <EOL> res0 = self . targobj . filter ( j = <NUM_LIT:1> , <EOL> recursive = False ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> def test__filter_single_attribute_norecur ( self ) : <EOL> targ = [ self . epcs1a [ <NUM_LIT:1> ] ] <EOL> res0 = self . targobj . filter ( name = self . epcs1a [ <NUM_LIT:1> ] . name , <EOL> recursive = False ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> def test__filter_single_annotation_nodata ( self ) : <EOL> targ = [ ] <EOL> res0 = self . targobj . filter ( j = <NUM_LIT:0> , <EOL> data = False ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> def test__filter_single_attribute_nodata ( self ) : <EOL> targ = [ ] <EOL> res0 = self . targobj . filter ( name = self . epcs1a [ <NUM_LIT:1> ] . name , <EOL> data = False ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> def test__filter_single_annotation_nodata_norecur ( self ) : <EOL> targ = [ ] <EOL> res0 = self . targobj . filter ( j = <NUM_LIT:0> , <EOL> data = False , recursive = False ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> def test__filter_single_attribute_nodata_norecur ( self ) : <EOL> targ = [ ] <EOL> res0 = self . targobj . filter ( name = self . epcs1a [ <NUM_LIT:1> ] . name , <EOL> data = False , recursive = False ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> def test__filter_single_annotation_container ( self ) : <EOL> targ = [ self . epcs1a [ <NUM_LIT:1> ] , self . epcas1a [ <NUM_LIT:1> ] , <EOL> self . evts1a [ <NUM_LIT:1> ] , self . evtas1a [ <NUM_LIT:1> ] ] <EOL> res0 = self . targobj . filter ( j = <NUM_LIT:1> , <EOL> container = True ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> def test__filter_single_attribute_container ( self ) : <EOL> targ = [ self . epcs1a [ <NUM_LIT:1> ] ] <EOL> res0 = self . targobj . filter ( name = self . epcs1a [ <NUM_LIT:1> ] . name , <EOL> container = True ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> def test__filter_single_annotation_container_norecur ( self ) : <EOL> targ = [ self . epcs1a [ <NUM_LIT:1> ] , self . epcas1a [ <NUM_LIT:1> ] , <EOL> self . evts1a [ <NUM_LIT:1> ] , self . evtas1a [ <NUM_LIT:1> ] ] <EOL> res0 = self . targobj . filter ( j = <NUM_LIT:1> , <EOL> container = True , recursive = False ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> def test__filter_single_attribute_container_norecur ( self ) : <EOL> targ = [ self . epcs1a [ <NUM_LIT:1> ] ] <EOL> res0 = self . targobj . filter ( name = self . epcs1a [ <NUM_LIT:1> ] . name , <EOL> container = True , recursive = False ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> def test__filter_single_annotation_nodata_container ( self ) : <EOL> targ = [ ] <EOL> res0 = self . targobj . filter ( j = <NUM_LIT:0> , <EOL> data = False , container = True ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> def test__filter_single_attribute_nodata_container ( self ) : <EOL> targ = [ ] <EOL> res0 = self . targobj . filter ( name = self . epcs1a [ <NUM_LIT:1> ] . name , <EOL> data = False , container = True ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> def test__filter_single_annotation_nodata_container_norecur ( self ) : <EOL> targ = [ ] <EOL> res0 = self . targobj . filter ( j = <NUM_LIT:0> , <EOL> data = False , container = True , <EOL> recursive = False ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> def test__filter_single_attribute_nodata_container_norecur ( self ) : <EOL> targ = [ ] <EOL> res0 = self . targobj . filter ( name = self . epcs1a [ <NUM_LIT:1> ] . name , <EOL> data = False , container = True , <EOL> recursive = False ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> data = self . targobj . children_recur <EOL> targ = ( self . sigs1a + self . sigarrs1a + <EOL> [ self . epcs1a [ <NUM_LIT:0> ] , self . epcas1a [ <NUM_LIT:0> ] ] + <EOL> [ self . evts1a [ <NUM_LIT:0> ] , self . evtas1a [ <NUM_LIT:0> ] ] + <EOL> self . irsigs1a + <EOL> self . spikes1a + self . trains1a + <EOL> [ self . epcs1a [ <NUM_LIT:1> ] ] ) <EOL> res0 = filterdata ( data , name = self . epcs1a [ <NUM_LIT:1> ] . name , j = <NUM_LIT:0> ) <EOL> res1 = filterdata ( data , { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name , '<STR_LIT>' : <NUM_LIT:0> } ) <EOL> res2 = filterdata ( data , targdict = { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name , '<STR_LIT>' : <NUM_LIT:0> } ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> assert_same_sub_schema ( res1 , targ ) <EOL> assert_same_sub_schema ( res2 , targ ) <EOL> def test__filterdata_multi_nores ( self ) : <EOL> data = self . targobj . children_recur <EOL> targ = [ ] <EOL> res0 = filterdata ( data , [ { '<STR_LIT>' : <NUM_LIT:0> } , { } ] ) <EOL> res1 = filterdata ( data , { } , ttype = <NUM_LIT:0> ) <EOL> res2 = filterdata ( data , [ { } ] , ttype = <NUM_LIT:0> ) <EOL> res3 = filterdata ( data , { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name } , j = <NUM_LIT:0> ) <EOL> res4 = filterdata ( data , targdict = { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name } , j = <NUM_LIT:0> ) <EOL> res5 = filterdata ( data , name = self . epcs1a [ <NUM_LIT:1> ] . name , targdict = { '<STR_LIT>' : <NUM_LIT:0> } ) <EOL> res6 = filterdata ( data , name = self . epcs2 [ <NUM_LIT:0> ] . name , j = <NUM_LIT:5> ) <EOL> res7 = filterdata ( data , { '<STR_LIT:name>' : self . epcs2 [ <NUM_LIT:1> ] . name , '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> res8 = filterdata ( data , targdict = { '<STR_LIT:name>' : self . epcs2 [ <NUM_LIT:1> ] . name , '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> res9 = filterdata ( data , { '<STR_LIT:name>' : self . epcs2 [ <NUM_LIT:1> ] . name } , j = <NUM_LIT:5> ) <EOL> res10 = filterdata ( data , targdict = { '<STR_LIT:name>' : self . epcs2 [ <NUM_LIT:1> ] . name } , j = <NUM_LIT:5> ) <EOL> res11 = filterdata ( data , name = self . epcs2 [ <NUM_LIT:1> ] . name , targdict = { '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> res12 = filterdata ( data , { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name } , j = <NUM_LIT:5> ) <EOL> res13 = filterdata ( data , targdict = { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name } , j = <NUM_LIT:5> ) <EOL> res14 = filterdata ( data , name = self . epcs1a [ <NUM_LIT:1> ] . name , targdict = { '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> assert_same_sub_schema ( res1 , targ ) <EOL> assert_same_sub_schema ( res2 , targ ) <EOL> assert_same_sub_schema ( res3 , targ ) <EOL> assert_same_sub_schema ( res4 , targ ) <EOL> assert_same_sub_schema ( res5 , targ ) <EOL> assert_same_sub_schema ( res6 , targ ) <EOL> assert_same_sub_schema ( res7 , targ ) <EOL> assert_same_sub_schema ( res8 , targ ) <EOL> assert_same_sub_schema ( res9 , targ ) <EOL> assert_same_sub_schema ( res10 , targ ) <EOL> assert_same_sub_schema ( res11 , targ ) <EOL> assert_same_sub_schema ( res12 , targ ) <EOL> assert_same_sub_schema ( res13 , targ ) <EOL> assert_same_sub_schema ( res14 , targ ) <EOL> def test__filterdata_multi_partres ( self ) : <EOL> data = self . targobj . children_recur <EOL> targ = [ self . epcs1a [ <NUM_LIT:1> ] ] <EOL> res0 = filterdata ( data , name = self . epcs1a [ <NUM_LIT:1> ] . name , j = <NUM_LIT:5> ) <EOL> res1 = filterdata ( data , { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name , '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> res2 = filterdata ( data , targdict = { '<STR_LIT:name>' : self . epcs1a [ <NUM_LIT:1> ] . name , '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> res3 = filterdata ( data , [ { '<STR_LIT>' : <NUM_LIT:1> } , { '<STR_LIT:i>' : <NUM_LIT:2> } ] ) <EOL> res4 = filterdata ( data , { '<STR_LIT>' : <NUM_LIT:1> } , i = <NUM_LIT:2> ) <EOL> res5 = filterdata ( data , [ { '<STR_LIT>' : <NUM_LIT:1> } ] , i = <NUM_LIT:2> ) <EOL> assert_same_sub_schema ( res0 , targ ) <EOL> assert_same_sub_schema ( res1 , targ ) <EOL> assert_same_sub_schema ( res2 , targ ) <EOL> assert_same_sub_schema ( res3 , targ ) <EOL> assert_same_sub_schema ( res4 , targ ) <EOL> assert_same_sub_schema ( res5 , targ ) <EOL> @ unittest . skipUnless ( HAVE_IPYTHON , \"<STR_LIT>\" ) <EOL> def test__pretty ( self ) : <EOL> ann = get_annotations ( ) <EOL> ann [ '<STR_LIT>' ] = self . seed1 <EOL> ann = pretty ( ann ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> res = pretty ( self . seg1 ) <EOL> sig0 = pretty ( self . sigs1 [ <NUM_LIT:0> ] ) <EOL> sig1 = pretty ( self . sigs1 [ <NUM_LIT:1> ] ) <EOL> sig2 = pretty ( self . sigs1 [ <NUM_LIT:2> ] ) <EOL> sig3 = pretty ( self . sigs1 [ <NUM_LIT:3> ] ) <EOL> sig0 = sig0 . replace ( '<STR_LIT:\\n>' , '<STR_LIT>' ) <EOL> sig1 = sig1 . replace ( '<STR_LIT:\\n>' , '<STR_LIT>' ) <EOL> sig2 = sig2 . replace ( '<STR_LIT:\\n>' , '<STR_LIT>' ) <EOL> sig3 = sig3 . replace ( '<STR_LIT:\\n>' , '<STR_LIT>' ) <EOL> sigarr0 = pretty ( self . sigarrs1 [ <NUM_LIT:0> ] ) <EOL> sigarr1 = pretty ( self . sigarrs1 [ <NUM_LIT:1> ] ) <EOL> sigarr0 = sigarr0 . replace ( '<STR_LIT:\\n>' , '<STR_LIT>' ) <EOL> sigarr1 = sigarr1 . replace ( '<STR_LIT:\\n>' , '<STR_LIT>' ) <EOL> targ = ( \"<STR_LIT>\" + <EOL> ( \"<STR_LIT>\" % <EOL> ( len ( self . sigs1a ) , len ( self . sigarrs1a ) ) ) + <EOL> ( \"<STR_LIT>\" % <EOL> ( len ( self . epcs1a ) , len ( self . epcas1a ) ) ) + <EOL> ( \"<STR_LIT>\" % <EOL> ( len ( self . evts1a ) , len ( self . evtas1a ) ) ) + <EOL> ( \"<STR_LIT>\" % <EOL> len ( self . irsigs1a ) ) + <EOL> ( \"<STR_LIT>\" % <EOL> ( len ( self . spikes1a ) , len ( self . trains1a ) ) ) + <EOL> ( \"<STR_LIT>\" % <EOL> ( self . seg1 . name , self . seg1 . description ) <EOL> ) + <EOL> ( \"<STR_LIT>\" % ann ) + <EOL> ( \"<STR_LIT>\" % len ( self . sigs1a ) ) + <EOL> ( '<STR_LIT>' % ( <NUM_LIT:0> , sig0 ) ) + <EOL> ( '<STR_LIT>' % ( <NUM_LIT:1> , sig1 ) ) + <EOL> ( '<STR_LIT>' % ( <NUM_LIT:2> , sig2 ) ) + <EOL> ( '<STR_LIT>' % ( <NUM_LIT:3> , sig3 ) ) + <EOL> ( \"<STR_LIT>\" % len ( self . sigarrs1a ) ) + <EOL> ( '<STR_LIT>' % ( <NUM_LIT:0> , sigarr0 ) ) + <EOL> ( '<STR_LIT>' % ( <NUM_LIT:1> , sigarr1 ) ) ) <EOL> self . assertEqual ( res , targ ) <EOL> def test__construct_subsegment_by_unit ( self ) : <EOL> nb_seg = <NUM_LIT:3> <EOL> nb_unit = <NUM_LIT:7> <EOL> unit_with_sig = np . array ( [ <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:5> ] ) <EOL> signal_types = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> sig_len = <NUM_LIT:100> <EOL> rcgs = [ RecordingChannelGroup ( name = '<STR_LIT>' , <EOL> channel_indexes = unit_with_sig ) , <EOL> RecordingChannelGroup ( name = '<STR_LIT>' , <EOL> channel_indexes = unit_with_sig ) ] <EOL> all_unit = [ ] <EOL> for u in range ( nb_unit ) : <EOL> un = Unit ( name = '<STR_LIT>' % u , channel_indexes = np . array ( [ u ] ) ) <EOL> assert_neo_object_is_compliant ( un ) <EOL> all_unit . append ( un ) <EOL> blk = Block ( ) <EOL> blk . recordingchannelgroups = rcgs <EOL> for s in range ( nb_seg ) : <EOL> seg = Segment ( name = '<STR_LIT>' % s ) <EOL> for j in range ( nb_unit ) : <EOL> st = SpikeTrain ( [ <NUM_LIT:1> , <NUM_LIT:2> ] , units = '<STR_LIT>' , <EOL> t_start = <NUM_LIT:0.> , t_stop = <NUM_LIT:10> ) <EOL> st . unit = all_unit [ j ] <EOL> for t in signal_types : <EOL> anasigarr = AnalogSignalArray ( np . zeros ( ( sig_len , <EOL> len ( unit_with_sig ) ) ) , <EOL> units = '<STR_LIT>' , <EOL> sampling_rate = <NUM_LIT> * pq . Hz , <EOL> channel_indexes = unit_with_sig ) <EOL> seg . analogsignalarrays . append ( anasigarr ) <EOL> blk . create_many_to_one_relationship ( ) <EOL> for unit in all_unit : <EOL> assert_neo_object_is_compliant ( unit ) <EOL> for rcg in rcgs : <EOL> assert_neo_object_is_compliant ( rcg ) <EOL> assert_neo_object_is_compliant ( blk ) <EOL> newseg = seg . construct_subsegment_by_unit ( all_unit [ : <NUM_LIT:4> ] ) <EOL> assert_neo_object_is_compliant ( newseg ) <EOL> def test_segment_take_spikes_by_unit ( self ) : <EOL> result1 = self . seg1 . take_spikes_by_unit ( ) <EOL> result21 = self . seg1 . take_spikes_by_unit ( [ self . unit1 ] ) <EOL> result22 = self . seg1 . take_spikes_by_unit ( [ self . unit2 ] ) <EOL> self . assertEqual ( result1 , [ ] ) <EOL> assert_same_sub_schema ( result21 , [ self . spikes1a [ <NUM_LIT:0> ] ] ) <EOL> assert_same_sub_schema ( result22 , [ self . spikes1a [ <NUM_LIT:1> ] ] ) <EOL> def test_segment_take_spiketrains_by_unit ( self ) : <EOL> result1 = self . seg1 . take_spiketrains_by_unit ( ) <EOL> result21 = self . seg1 . take_spiketrains_by_unit ( [ self . unit1 ] ) <EOL> result22 = self . seg1 . take_spiketrains_by_unit ( [ self . unit2 ] ) <EOL> self . assertEqual ( result1 , [ ] ) <EOL> assert_same_sub_schema ( result21 , [ self . trains1a [ <NUM_LIT:0> ] ] ) <EOL> assert_same_sub_schema ( result22 , [ self . trains1a [ <NUM_LIT:1> ] ] ) <EOL> def test_segment_take_analogsignal_by_unit ( self ) : <EOL> result1 = self . seg1 . take_analogsignal_by_unit ( ) <EOL> result21 = self . seg1 . take_analogsignal_by_unit ( [ self . unit1 ] ) <EOL> result22 = self . seg1 . take_analogsignal_by_unit ( [ self . unit2 ] ) <EOL> self . assertEqual ( result1 , [ ] ) <EOL> assert_same_sub_schema ( result21 , [ self . sigs1a [ <NUM_LIT:0> ] ] ) <EOL> assert_same_sub_schema ( result22 , [ self . sigs1a [ <NUM_LIT:1> ] ] ) <EOL> def test_segment_take_analogsignal_by_channelindex ( self ) : <EOL> ind1 = self . unit1 . channel_indexes [ <NUM_LIT:0> ] <EOL> ind2 = self . unit2 . channel_indexes [ <NUM_LIT:0> ] <EOL> result1 = self . seg1 . take_analogsignal_by_channelindex ( ) <EOL> result21 = self . seg1 . take_analogsignal_by_channelindex ( [ ind1 ] ) <EOL> result22 = self . seg1 . take_analogsignal_by_channelindex ( [ ind2 ] ) <EOL> self . assertEqual ( result1 , [ ] ) <EOL> assert_same_sub_schema ( result21 , [ self . sigs1a [ <NUM_LIT:0> ] ] ) <EOL> assert_same_sub_schema ( result22 , [ self . sigs1a [ <NUM_LIT:1> ] ] ) <EOL> def test_seg_take_slice_of_analogsignalarray_by_unit ( self ) : <EOL> seg = self . seg1 <EOL> result1 = seg . take_slice_of_analogsignalarray_by_unit ( ) <EOL> result21 = seg . take_slice_of_analogsignalarray_by_unit ( [ self . unit1 ] ) <EOL> result23 = seg . take_slice_of_analogsignalarray_by_unit ( [ self . unit3 ] ) <EOL> self . assertEqual ( result1 , [ ] ) <EOL> targ1 = [ self . sigarrs1a [ <NUM_LIT:0> ] [ : , np . array ( [ True ] ) ] , <EOL> self . sigarrs1a [ <NUM_LIT:1> ] [ : , np . array ( [ False ] ) ] ] <EOL> targ3 = [ self . sigarrs1a [ <NUM_LIT:0> ] [ : , np . array ( [ False ] ) ] , <EOL> self . sigarrs1a [ <NUM_LIT:1> ] [ : , np . array ( [ True ] ) ] ] <EOL> assert_same_sub_schema ( result21 , targ1 ) <EOL>", "answer": "assert_same_sub_schema ( result23 , targ3 )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Static ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from . core import get_ports <EOL>", "answer": "__all__ = [ \"<STR_LIT>\" ] "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import argparse <EOL> from tornado . ioloop import IOLoop <EOL> from tornado . wsgi import WSGIContainer <EOL> from tornado . httpserver import HTTPServer <EOL> from werkzeug . serving import run_simple <EOL> from osrc import create_app <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL> parser = argparse . ArgumentParser ( ) <EOL> parser . add_argument ( \"<STR_LIT>\" , \"<STR_LIT>\" , default = <NUM_LIT> , type = int , <EOL> help = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , \"<STR_LIT>\" , action = \"<STR_LIT:store_true>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> default = None , <EOL>", "answer": "help = \"<STR_LIT>\" )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import json <EOL> import os <EOL> import re <EOL> from django . core . urlresolvers import reverse <EOL> from django . test import TestCase <EOL> from corehq . apps . app_manager . tests . util import add_build <EOL> from corehq . apps . app_manager . util import new_careplan_module <EOL> from corehq . apps . app_manager . views import AppSummaryView <EOL> from corehq . apps . builds . models import BuildSpec <EOL> from corehq import toggles <EOL> from corehq . apps . users . models import WebUser <EOL> from corehq . apps . domain . models import Domain <EOL> from corehq . apps . app_manager . models import ( <EOL> AdvancedModule , <EOL> Application , <EOL> APP_V1 , <EOL> APP_V2 , <EOL> Module , <EOL> ReportModule , <EOL> ShadowModule , <EOL> ) <EOL> from . test_form_versioning import BLANK_TEMPLATE <EOL> class TestViews ( TestCase ) : <EOL> app = None <EOL> build = None <EOL> @ classmethod <EOL> def setUpClass ( cls ) : <EOL> cls . domain = Domain ( name = '<STR_LIT>' , is_active = True ) <EOL> cls . domain . save ( ) <EOL> cls . username = '<STR_LIT>' <EOL> cls . password = '<STR_LIT>' <EOL> cls . user = WebUser . create ( cls . domain . name , cls . username , cls . password , is_active = True ) <EOL> cls . user . is_superuser = True <EOL> cls . user . save ( ) <EOL> cls . build = add_build ( version = '<STR_LIT>' , build_number = <NUM_LIT> ) <EOL> cls . app = Application . new_app ( cls . domain . name , \"<STR_LIT>\" , application_version = APP_V2 ) <EOL> cls . app . build_spec = BuildSpec . from_string ( '<STR_LIT>' ) <EOL> toggles . CUSTOM_PROPERTIES . set ( \"<STR_LIT>\" . format ( domain = cls . domain . name ) , True ) <EOL> def setUp ( self ) : <EOL> self . client . login ( username = self . username , password = self . password ) <EOL> @ classmethod <EOL> def tearDownClass ( cls ) : <EOL> cls . user . delete ( ) <EOL> cls . build . delete ( ) <EOL> if cls . app : <EOL> cls . app . delete ( ) <EOL> cls . domain . delete ( ) <EOL> def test_download_file_bad_xform_404 ( self ) : <EOL> '''<STR_LIT>''' <EOL> module = self . app . add_module ( Module . new_module ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> build1 = { '<STR_LIT:version>' : '<STR_LIT>' , '<STR_LIT>' : <NUM_LIT> } <EOL> build2 = { '<STR_LIT:version>' : '<STR_LIT>' , '<STR_LIT>' : <NUM_LIT> } <EOL> add_build ( ** build1 ) <EOL> add_build ( ** build2 ) <EOL>", "answer": "with open ( os . path . join ( os . path . dirname ( __file__ ) , \"<STR_LIT:data>\" , \"<STR_LIT>\" ) ) as f :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL> from __future__ import unicode_literals <EOL> import logging <EOL> from string import Template <EOL> import six <EOL> from . errors import ConfigurationError <EOL> log = logging . getLogger ( __name__ ) <EOL> def interpolate_environment_variables ( config , section , environment ) : <EOL> def process_item ( name , config_dict ) : <EOL> return dict ( <EOL> ( key , interpolate_value ( name , key , val , section , environment ) ) <EOL> for key , val in ( config_dict or { } ) . items ( ) <EOL> ) <EOL> return dict ( <EOL> ( name , process_item ( name , config_dict or { } ) ) <EOL> for name , config_dict in config . items ( ) <EOL> ) <EOL> def interpolate_value ( name , config_key , value , section , mapping ) : <EOL> try : <EOL> return recursive_interpolate ( value , mapping ) <EOL> except InvalidInterpolation as e : <EOL> raise ConfigurationError ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' . format ( <EOL> config_key = config_key , <EOL> name = name , <EOL> section = section , <EOL> string = e . string ) ) <EOL> def recursive_interpolate ( obj , mapping ) : <EOL> if isinstance ( obj , six . string_types ) : <EOL> return interpolate ( obj , mapping ) <EOL> elif isinstance ( obj , dict ) : <EOL> return dict ( <EOL> ( key , recursive_interpolate ( val , mapping ) ) <EOL> for ( key , val ) in obj . items ( ) <EOL> ) <EOL> elif isinstance ( obj , list ) : <EOL> return [ recursive_interpolate ( val , mapping ) for val in obj ] <EOL> else : <EOL> return obj <EOL> def interpolate ( string , mapping ) : <EOL> try : <EOL> return Template ( string ) . substitute ( mapping ) <EOL> except ValueError : <EOL> raise InvalidInterpolation ( string ) <EOL>", "answer": "class InvalidInterpolation ( Exception ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys <EOL> import six <EOL> from . base import EmailTransport <EOL> class GenericFileMailbox ( EmailTransport ) : <EOL> _variant = None <EOL> _path = None <EOL>", "answer": "def __init__ ( self , path ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import pprint <EOL> from planetlab . model import * <EOL> from users import user_list <EOL> legacy_network_remap = { <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' , <EOL> <NUM_LIT:4> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <NUM_LIT:1> : '<STR_LIT>' , <EOL> <NUM_LIT:2> : '<STR_LIT>' , <EOL> <NUM_LIT:3> : '<STR_LIT>' } <EOL> } <EOL> Network . legacy_network_remap = legacy_network_remap <EOL> site_list = [ <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , None , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , exclude = [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] , arch = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , - <NUM_LIT> , <NUM_LIT> , user_list , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , <NUM_LIT> , user_list , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , <NUM_LIT> , user_list , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , <NUM_LIT> , user_list , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , count = <NUM_LIT:4> , arch = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , count = <NUM_LIT:4> , arch = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , count = <NUM_LIT:4> , arch = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , count = <NUM_LIT:4> , arch = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , <NUM_LIT> , user_list , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , <NUM_LIT> , user_list , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , <NUM_LIT> , user_list , count = <NUM_LIT:4> , v6gw = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , <NUM_LIT> , user_list , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , <NUM_LIT> , user_list , arch = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , None , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , exclude = [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , count = <NUM_LIT:4> , arch = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , count = <NUM_LIT:4> , arch = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , count = <NUM_LIT:4> , arch = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , count = <NUM_LIT:4> , arch = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , count = <NUM_LIT:4> , arch = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , count = <NUM_LIT:4> , arch = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , count = <NUM_LIT:4> , arch = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL> makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , count = <NUM_LIT:4> , arch = '<STR_LIT>' , nodegroup = '<STR_LIT>' ) , <EOL>", "answer": "makesite ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> , - <NUM_LIT> , user_list , nodegroup = '<STR_LIT>' ) ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL> from django . core . urlresolvers import reverse <EOL> from sentry . models import OrganizationMember , OrganizationMemberTeam , Team <EOL>", "answer": "from sentry . testutils import TestCase , PermissionTestCase"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import numpy as _np <EOL> def normal ( std ) : <EOL> def init ( shape , fan ) : <EOL>", "answer": "return std * _np . random . randn ( * shape )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import time <EOL> import unittest <EOL> import zmqpy <EOL> from zmqpy . utils . strtypes import asbytes <EOL> from . __init__ import BaseZMQTestCase <EOL> class TestPubSub ( BaseZMQTestCase ) : <EOL> def test_basic ( self ) : <EOL> s1 , s2 = self . create_bound_pair ( zmqpy . PUSH , zmqpy . PULL ) <EOL> msg1 = asbytes ( '<STR_LIT:message>' ) <EOL> s1 . send ( msg1 ) <EOL> time . sleep ( <NUM_LIT:0.1> ) <EOL> msg2 = s2 . recv ( ) <EOL> self . assertEquals ( msg1 , msg2 ) <EOL> def test_topic ( self ) : <EOL> s1 , s2 = self . create_bound_pair ( zmqpy . PUB , zmqpy . SUB ) <EOL> s2 . setsockopt ( zmqpy . SUBSCRIBE , asbytes ( '<STR_LIT:x>' ) ) <EOL> time . sleep ( <NUM_LIT:0.1> ) <EOL> msg1 = asbytes ( '<STR_LIT:message>' ) <EOL> s1 . send ( msg1 ) <EOL> self . assertRaisesErrno ( zmqpy . EAGAIN , s2 . recv , zmqpy . NOBLOCK ) <EOL> msg1 = asbytes ( '<STR_LIT>' ) <EOL> s1 . send ( msg1 ) <EOL> msg2 = s2 . recv ( ) <EOL>", "answer": "self . assertEquals ( msg1 , msg2 )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import base <EOL> from brewery import dq <EOL> import time <EOL> from brewery . metadata import expand_record <EOL> try : <EOL> from pyes . es import ES <EOL> except ImportError : <EOL> from brewery . utils import MissingPackage <EOL> pyes = MissingPackage ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class ESDataSource ( base . DataSource ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , document_type , database = None , host = None , port = None , <EOL> expand = False , ** elasticsearch_args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . document_type = document_type <EOL> self . database_name = database <EOL> self . host = host <EOL> self . port = port <EOL> self . elasticsearch_args = elasticsearch_args <EOL> self . expand = expand <EOL> self . connection = None <EOL> self . _fields = None <EOL> def initialize ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> args = self . elasticsearch_args . copy ( ) <EOL> server = \"<STR_LIT>\" <EOL> if self . host : <EOL> server = self . host <EOL> if self . port : <EOL> server += \"<STR_LIT::>\" + self . port <EOL> self . connection = ES ( server , ** args ) <EOL> self . connection . default_indices = self . database_name <EOL> self . connection . default_types = self . document_type <EOL> def read_fields ( self , limit = <NUM_LIT:0> ) : <EOL> keys = [ ] <EOL> probes = { } <EOL> def probe_record ( record , parent = None ) : <EOL> for key , value in record . items ( ) : <EOL> if parent : <EOL> full_key = parent + \"<STR_LIT:.>\" + key <EOL> else : <EOL> full_key = key <EOL> if self . expand and type ( value ) == dict : <EOL> probe_record ( value , full_key ) <EOL> continue <EOL> if not full_key in probes : <EOL> probe = dq . FieldTypeProbe ( full_key ) <EOL> probes [ full_key ] = probe <EOL> keys . append ( full_key ) <EOL> else : <EOL> probe = probes [ full_key ] <EOL> probe . probe ( value ) <EOL> for record in self . document_type . find ( limit = limit ) : <EOL> probe_record ( record ) <EOL> fields = [ ] <EOL> for key in keys : <EOL> probe = probes [ key ] <EOL> field = base . Field ( probe . field ) <EOL> storage_type = probe . unique_storage_type <EOL> if not storage_type : <EOL> field . storage_type = \"<STR_LIT>\" <EOL> elif storage_type == \"<STR_LIT>\" : <EOL> field . storage_type = \"<STR_LIT:string>\" <EOL> else : <EOL> field . storage_type = \"<STR_LIT>\" <EOL> field . concrete_storage_type = storage_type <EOL> fields . append ( field ) <EOL> self . fields = list ( fields ) <EOL> return self . fields <EOL> def rows ( self ) : <EOL> if not self . connection : <EOL> raise RuntimeError ( \"<STR_LIT>\" ) <EOL> from pyes . query import MatchAllQuery <EOL> fields = self . fields . names ( ) <EOL> results = self . connection . search ( MatchAllQuery ( ) , search_type = \"<STR_LIT>\" , timeout = \"<STR_LIT>\" , size = \"<STR_LIT>\" ) <EOL> return ESRowIterator ( results , fields ) <EOL> def records ( self ) : <EOL> if not self . connection : <EOL> raise RuntimeError ( \"<STR_LIT>\" ) <EOL> from pyes . query import MatchAllQuery <EOL> results = self . connection . search ( MatchAllQuery ( ) , search_type = \"<STR_LIT>\" , timeout = \"<STR_LIT>\" , size = \"<STR_LIT>\" ) <EOL> return ESRecordIterator ( results , self . expand ) <EOL> class ESRowIterator ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , resultset , field_names ) : <EOL> self . resultset = resultset <EOL> self . field_names = field_names <EOL> def __getitem__ ( self , index ) : <EOL> record = self . resultset . __getitem__ ( index ) <EOL> array = [ ] <EOL> for field in self . field_names : <EOL> value = record <EOL> for key in field . split ( '<STR_LIT:.>' ) : <EOL> if key in value : <EOL> value = value [ key ] <EOL> else : <EOL> break <EOL> array . append ( value ) <EOL> return tuple ( array ) <EOL> class ESRecordIterator ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , resultset , expand = False ) : <EOL> self . resultset = resultset <EOL> self . expand = expand <EOL> def __getitem__ ( self , index ) : <EOL> def expand_record ( record , parent = None ) : <EOL> ret = { } <EOL> for key , value in record . items ( ) : <EOL> if parent : <EOL> full_key = parent + \"<STR_LIT:.>\" + key <EOL> else : <EOL> full_key = key <EOL> if type ( value ) == dict : <EOL> expanded = expand_record ( value , full_key ) <EOL> ret . update ( expanded ) <EOL> else : <EOL> ret [ full_key ] = value <EOL> return ret <EOL> record = self . resultset . __getitem__ ( index ) <EOL> if not self . expand : <EOL> return record <EOL> else : <EOL> return expand_record ( record ) <EOL> class ESDataTarget ( base . DataTarget ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , document_type , database = \"<STR_LIT:test>\" , host = \"<STR_LIT:127.0.0.1>\" , port = \"<STR_LIT>\" , <EOL> truncate = False , expand = False , ** elasticsearch_args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . document_type = document_type <EOL> self . database_name = database <EOL> self . host = host <EOL> self . port = port <EOL> self . elasticsearch_args = elasticsearch_args <EOL> self . expand = expand <EOL> self . truncate = truncate <EOL> self . _fields = None <EOL> def initialize ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from pyes . es import ES <EOL> from pyes . exceptions import IndexAlreadyExistsException <EOL> args = self . elasticsearch_args . copy ( ) <EOL> server = \"<STR_LIT>\" <EOL> if self . host : <EOL> server = self . host <EOL> if self . port : <EOL> server += \"<STR_LIT::>\" + self . port <EOL> create = args . pop ( \"<STR_LIT>\" , False ) <EOL> replace = args . pop ( \"<STR_LIT:replace>\" , False ) <EOL> self . connection = ES ( server , ** args ) <EOL> self . connection . default_indices = self . database_name <EOL> self . connection . default_types = self . document_type <EOL> created = False <EOL> if create : <EOL> try : <EOL> self . connection . create_index ( self . database_name ) <EOL> self . connection . refresh ( self . database_name ) <EOL> created = True <EOL> except IndexAlreadyExistsException : <EOL> pass <EOL> if replace and not created : <EOL> self . connection . delete_index_if_exists ( self . database_name ) <EOL> time . sleep ( <NUM_LIT:2> ) <EOL> self . connection . create_index ( self . database_name ) <EOL> self . connection . refresh ( self . database_name ) <EOL> if self . truncate : <EOL> self . connection . delete_mapping ( self . database_name , self . document_type ) <EOL> self . connection . refresh ( self . database_name ) <EOL> def append ( self , obj ) : <EOL> record = obj <EOL> if not isinstance ( obj , dict ) : <EOL> record = dict ( zip ( self . fields . names ( ) , obj ) ) <EOL> if self . expand : <EOL> record = expand_record ( record ) <EOL> id = record . get ( '<STR_LIT:id>' ) or record . get ( '<STR_LIT>' ) <EOL>", "answer": "self . connection . index ( record , self . database_name , self . document_type , id , bulk = True )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> from pants . backend . jvm . targets . jvm_target import JvmTarget <EOL>", "answer": "from pants . build_graph . resources import Resources"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . core . urlresolvers import reverse <EOL> from django . utils . translation import ugettext as _ <EOL> from datetime import datetime <EOL> from google . appengine . api . labs import taskqueue <EOL> from google . appengine . ext import db <EOL> from appengine_django . auth . models import User <EOL> from userstorage . utils import get_user <EOL> from app . base import Base <EOL> from app . utils import break_url , trunc_string <EOL> from projects . models import Project , ProjectURL <EOL> from error . models import Group <EOL> from issues import signals <EOL> class Issue ( Base ) : <EOL> timestamp = db . DateTimeProperty ( ) <EOL> title = db . StringProperty ( required = False ) <EOL> description = db . TextProperty ( required = False ) <EOL> priority = db . IntegerProperty ( ) <EOL> raw = db . StringProperty ( ) <EOL> domain = db . StringProperty ( ) <EOL> query = db . StringProperty ( ) <EOL> protocol = db . StringProperty ( ) <EOL> project = db . ReferenceProperty ( Project , required = False ) <EOL> creator = db . ReferenceProperty ( User , required = False , collection_name = \"<STR_LIT>\" ) <EOL> assigned = db . ReferenceProperty ( User , required = False , collection_name = \"<STR_LIT>\" ) <EOL> status = db . StringProperty ( ) <EOL> number = db . IntegerProperty ( ) <EOL> def get_absolute_url ( self ) : <EOL> return reverse ( \"<STR_LIT>\" , args = [ self . number , ] ) <EOL> def get_log_set ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . log_set . order ( \"<STR_LIT>\" ) <EOL>", "answer": "def get_comment_set ( self ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> __version__ = '<STR_LIT>' <EOL>", "answer": "version = __version__"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import curses <EOL> import errno <EOL> import os <EOL> import pydoc <EOL> import subprocess <EOL> import sys <EOL> import shlex <EOL> from bpython . _py3compat import py3 <EOL> def get_pager_command ( default = '<STR_LIT>' ) : <EOL> command = shlex . split ( os . environ . get ( '<STR_LIT>' , default ) ) <EOL> return command <EOL> def page_internal ( data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if hasattr ( pydoc , '<STR_LIT>' ) : <EOL> pydoc . ttypager ( data ) <EOL> else : <EOL> sys . stdout . write ( data ) <EOL> def page ( data , use_internal = False ) : <EOL> command = get_pager_command ( ) <EOL> if not command or use_internal : <EOL> page_internal ( data ) <EOL> else : <EOL>", "answer": "curses . endwin ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> card = balanced . Card . fetch ( card_href ) <EOL> card_hold = card . hold ( <EOL>", "answer": "amount = <NUM_LIT> ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> import logging <EOL> import logging . config <EOL> import yaml <EOL> from helion_configurationprocessor . cp . model . v2_0 . HlmPaths import HlmPaths <EOL> from helion_configurationprocessor . cp . model . v2_0 . CloudModel import CloudModel <EOL> from helion_configurationprocessor . cp . model . v2_0 import ServerState <EOL> from helion_configurationprocessor . cp . model . BuilderPlugin import BuilderPlugin <EOL> from helion_configurationprocessor . cp . model . BuilderPlugin import ArtifactMode <EOL> from helion_configurationprocessor . cp . model . CPLogging import CPLogging as KenLog <EOL> LOG = logging . getLogger ( __name__ ) <EOL> class ServerInfoBuilder ( BuilderPlugin ) : <EOL> def __init__ ( self , instructions , models , controllers ) : <EOL> super ( ServerInfoBuilder , self ) . __init__ ( <EOL> <NUM_LIT> , instructions , models , controllers , <EOL> '<STR_LIT>' ) <EOL> LOG . info ( '<STR_LIT>' % KenLog . fcn ( ) ) <EOL> self . cloud_desc = self . _models [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> self . _file_path = HlmPaths . get_output_path ( self . _instructions , self . cloud_desc ) <EOL> self . _cloud_model = self . _models [ '<STR_LIT>' ] <EOL> self . _cloud_version = CloudModel . version ( self . _cloud_model , self . _version ) <EOL> self . _cloud_internal = CloudModel . internal ( self . _cloud_model ) <EOL> HlmPaths . make_path ( self . _file_path ) <EOL> def build ( self ) : <EOL> LOG . info ( '<STR_LIT>' % KenLog . fcn ( ) ) <EOL> servers = CloudModel . get ( self . _cloud_internal , '<STR_LIT>' ) <EOL> server_info = { } <EOL> for server in servers : <EOL> server_info [ server [ '<STR_LIT:id>' ] ] = { } <EOL> data = server_info [ server [ '<STR_LIT:id>' ] ] <EOL> data [ '<STR_LIT:state>' ] = server [ '<STR_LIT:state>' ] <EOL> if server [ '<STR_LIT:state>' ] == ServerState . ALLOCATED : <EOL> data [ '<STR_LIT>' ] = server [ '<STR_LIT>' ] <EOL> data [ '<STR_LIT>' ] = server [ '<STR_LIT>' ] <EOL> net_info = { } <EOL> for if_name , if_data in server [ '<STR_LIT>' ] . iteritems ( ) : <EOL> net_info [ if_name ] = { } <EOL> for net_name , net_data in if_data [ '<STR_LIT>' ] . iteritems ( ) : <EOL> net_info [ if_name ] [ net_name ] = { '<STR_LIT>' : net_data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : net_data . get ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : net_data . get ( '<STR_LIT>' , True ) } <EOL> data [ '<STR_LIT>' ] = net_info <EOL>", "answer": "filename = \"<STR_LIT>\" % ("}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys <EOL> import imp <EOL> import errno <EOL> import os <EOL> from u2fval import default_settings <EOL> import logging <EOL> import logging . config <EOL> __all__ = [ <EOL> '<STR_LIT>' <EOL> ] <EOL> SETTINGS_FILE = os . getenv ( '<STR_LIT>' , os . path . join ( <EOL> '<STR_LIT>' ) ) <EOL> LOG_CONFIG_FILE = os . path . join ( os . path . dirname ( os . path . abspath ( SETTINGS_FILE ) ) , <EOL> '<STR_LIT>' ) <EOL> VALUES = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL>", "answer": "def parse ( conf , settings = { } ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import argparse <EOL> import logging <EOL> from collections import namedtuple <EOL> from . import placeholder <EOL> logger = logging . getLogger ( ) <EOL> ShortenerSettings = namedtuple ( '<STR_LIT>' , [ <EOL> '<STR_LIT:name>' , <EOL> '<STR_LIT>' <EOL> ] ) <EOL> Settings = namedtuple ( '<STR_LIT>' , [ <EOL> '<STR_LIT:source>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT:strict>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] ) <EOL> def default_settings ( ) : <EOL> return Settings ( <EOL> verbose = False , <EOL> strict = True , <EOL> force = False , <EOL> source = '<STR_LIT:src>' , <EOL> destination = '<STR_LIT:target>' , <EOL> templates = '<STR_LIT>' , <EOL> images = '<STR_LIT>' , <EOL> right_to_left = [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> pattern = '<STR_LIT>' , <EOL> shortener = { } , <EOL> exclusive = None , <EOL> default_locale = '<STR_LIT>' , <EOL> workers_pool = <NUM_LIT:10> , <EOL>", "answer": "local_images = '<STR_LIT>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import datetime , time , sys , threading , random , subprocess , os , json , signal , api , platform <EOL> class Backups : <EOL> def __init__ ( self , wrapper ) : <EOL> self . wrapper = wrapper <EOL> self . config = wrapper . config <EOL> self . log = wrapper . log <EOL> self . api = api . API ( wrapper , \"<STR_LIT>\" , internal = True ) <EOL> self . interval = <NUM_LIT:0> <EOL> self . time = time . time ( ) <EOL> self . backups = [ ] <EOL> self . api . registerEvent ( \"<STR_LIT>\" , self . onTick ) <EOL> def broadcast ( self , message ) : <EOL> self . api . minecraft . broadcast ( message , irc = False ) <EOL> def console ( self , msg ) : <EOL> self . api . minecraft . console ( msg ) <EOL> def onTick ( self , payload ) : <EOL> self . interval += <NUM_LIT:1> <EOL> if not self . config [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] : return <EOL> if time . time ( ) - self . time > self . config [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] : <EOL> self . time = time . time ( ) <EOL> if not os . path . exists ( self . config [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] ) : <EOL> os . mkdir ( self . config [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] ) <EOL> if len ( self . backups ) == <NUM_LIT:0> and os . path . exists ( self . config [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] + \"<STR_LIT>\" ) : <EOL> with open ( self . config [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] + \"<STR_LIT>\" , \"<STR_LIT:r>\" ) as f : <EOL> try : self . backups = json . loads ( f . read ( ) ) <EOL> except : <EOL>", "answer": "self . log . error ( \"<STR_LIT>\" )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import pytest <EOL>", "answer": "@ pytest . yield_fixture ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> PREFIX = '<STR_LIT>' <EOL> FILES = '<STR_LIT>' <EOL> INDEXES = [ '<STR_LIT>' ] <EOL>", "answer": "PRE_LOAD = [ ( '<STR_LIT>' , '<STR_LIT>' ) ] "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from rexpro . exceptions import RexProConnectionException <EOL> from rexpro . messages import ErrorResponse <EOL> from contextlib import contextmanager <EOL> from hashlib import md5 <EOL> from Queue import Queue <EOL> import struct <EOL> from socket import socket <EOL> from textwrap import dedent <EOL> from rexpro import exceptions <EOL> from rexpro import messages <EOL> from rexpro import utils <EOL> class RexProSocket ( socket ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def send_message ( self , msg ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . send ( msg . serialize ( ) ) <EOL> def get_response ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> msg_version = self . recv ( <NUM_LIT:1> ) <EOL> if not msg_version : <EOL> raise exceptions . RexProConnectionException ( '<STR_LIT>' ) <EOL> if bytearray ( [ msg_version ] ) [ <NUM_LIT:0> ] != <NUM_LIT:1> : <EOL> raise exceptions . RexProConnectionException ( '<STR_LIT>' . format ( ) ) <EOL> serializer_type = self . recv ( <NUM_LIT:1> ) <EOL> if bytearray ( serializer_type ) [ <NUM_LIT:0> ] != <NUM_LIT:0> : <EOL> raise exceptions . RexProConnectionException ( '<STR_LIT>' . format ( ) ) <EOL> self . recv ( <NUM_LIT:4> ) <EOL> msg_type = self . recv ( <NUM_LIT:1> ) <EOL> msg_type = bytearray ( msg_type ) [ <NUM_LIT:0> ] <EOL> msg_len = struct . unpack ( '<STR_LIT>' , self . recv ( <NUM_LIT:4> ) ) [ <NUM_LIT:0> ] <EOL> response = '<STR_LIT>' <EOL> while len ( response ) < msg_len : <EOL> response += self . recv ( msg_len ) <EOL> MessageTypes = messages . MessageTypes <EOL> type_map = { <EOL> MessageTypes . ERROR : messages . ErrorResponse , <EOL> MessageTypes . SESSION_RESPONSE : messages . SessionResponse , <EOL> MessageTypes . SCRIPT_RESPONSE : messages . MsgPackScriptResponse <EOL> } <EOL> if msg_type not in type_map : <EOL> raise exceptions . RexProConnectionException ( \"<STR_LIT>\" . format ( msg_type ) ) <EOL> return type_map [ msg_type ] . deserialize ( response ) <EOL> class RexProConnectionPool ( object ) : <EOL> def __init__ ( self , host , port , size ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . host = host <EOL> self . port = port <EOL> self . size = size <EOL> self . pool = Queue ( ) <EOL> for i in range ( size ) : <EOL> self . pool . put ( self . _new_conn ( ) ) <EOL> def _new_conn ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> conn = RexProSocket ( ) <EOL> conn . connect ( ( self . host , self . port ) ) <EOL> return conn <EOL> def get ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . pool . empty ( ) : <EOL> return self . _new_conn ( ) <EOL> return self . pool . get ( ) <EOL> def put ( self , conn ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . pool . qsize ( ) >= self . size : <EOL> conn . close ( ) <EOL> return <EOL> self . pool . put ( conn ) <EOL> @ contextmanager <EOL> def contextual_connection ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> conn = self . get ( ) <EOL> yield conn <EOL> self . put ( conn ) <EOL> def __del__ ( self ) : <EOL> while not self . pool . empty ( ) : <EOL> self . pool . get ( ) . close ( ) <EOL> class RexProConnection ( object ) : <EOL> def __init__ ( self , host , port , graph_name , graph_obj_name = '<STR_LIT:g>' , username = '<STR_LIT>' , password = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . host = host <EOL> self . port = port <EOL> self . graph_name = graph_name <EOL> self . username = username <EOL> self . password = password <EOL> self . graph_features = None <EOL> self . _conn = RexProSocket ( ) <EOL> self . _conn . connect ( ( self . host , self . port ) ) <EOL> self . _in_transaction = False <EOL> self . _session_key = None <EOL> self . _open_session ( ) <EOL> def _open_session ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _conn . send_message ( <EOL> messages . SessionRequest ( <EOL> username = self . username , <EOL> password = self . password , <EOL> graph_name = self . graph_name <EOL> ) <EOL> ) <EOL> response = self . _conn . get_response ( ) <EOL> if isinstance ( response , ErrorResponse ) : <EOL> raise RexProConnectionException ( response . message ) <EOL> self . _session_key = response . session_key <EOL> self . graph_features = self . execute ( '<STR_LIT>' ) <EOL> def open_transaction ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _in_transaction : <EOL> raise exceptions . RexProScriptException ( \"<STR_LIT>\" ) <EOL> self . execute ( <EOL> script = '<STR_LIT>' , <EOL> isolate = False <EOL> ) <EOL> self . _in_transaction = True <EOL> def close_transaction ( self , success = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . _in_transaction : <EOL> raise exceptions . RexProScriptException ( \"<STR_LIT>\" ) <EOL> self . execute ( <EOL> script = '<STR_LIT>' . format ( '<STR_LIT>' if success else '<STR_LIT>' ) , <EOL> isolate = False <EOL> ) <EOL> self . _in_transaction = False <EOL> def close ( self ) : <EOL> self . _conn . send_message ( <EOL> messages . SessionRequest ( <EOL> session_key = self . _session_key , <EOL> graph_name = self . graph_name , <EOL> kill_session = True <EOL> ) <EOL> ) <EOL> response = self . _conn . get_response ( ) <EOL> if isinstance ( response , ErrorResponse ) : <EOL> raise RexProConnectionException ( response . message ) <EOL> @ contextmanager <EOL> def transaction ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . open_transaction ( ) <EOL> yield <EOL> self . close_transaction ( ) <EOL> def execute ( self , script , params = { } , isolate = True , transaction = True , pretty = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _conn . send_message ( <EOL>", "answer": "messages . ScriptRequest ("}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import logging <EOL> import os <EOL> import runpy <EOL> import shutil <EOL> import sys <EOL> import textwrap <EOL> import argparse <EOL> import config <EOL> from path import path <EOL> import utils <EOL> if sys . platform == '<STR_LIT:win32>' : <EOL> GLOBAL_CONFIG_FILE = '<STR_LIT>' <EOL> else : <EOL> GLOBAL_CONFIG_FILE = '<STR_LIT>' <EOL> MISSING_GAE_SDK_MSG = \"<STR_LIT>\" \"<STR_LIT>\" <EOL> class Action ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = None <EOL> description = None <EOL> epilog = None <EOL> def __init__ ( self , manager , name ) : <EOL> self . manager = manager <EOL> self . name = name <EOL> self . logger = logging . getLogger ( name ) <EOL> def __call__ ( self , argv ) : <EOL> raise NotImplementedError ( ) <EOL> def get_config_section ( self ) : <EOL> sections = [ self . manager . app , '<STR_LIT>' ] <EOL> return [ '<STR_LIT>' % ( s , self . name ) for s in sections if s ] <EOL> def error ( self , message , status = <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . logger . error ( message ) <EOL> sys . exit ( status ) <EOL> def run_hooks ( self , import_names , args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> hooks = [ ] <EOL> for import_name in import_names : <EOL> hook = utils . import_string ( import_name , True ) <EOL> if hook is None : <EOL>", "answer": "self . error ( '<STR_LIT>' % import_name )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = - <NUM_LIT:1>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import division , absolute_import <EOL> import sys <EOL> import traceback <EOL> from zope . interface import implementer <EOL> from twisted . python . compat import _PY3 <EOL> from twisted . python . failure import Failure <EOL> from twisted . trial . unittest import SynchronousTestCase , PyUnitResultAdapter <EOL> from twisted . trial . itrial import IReporter , ITestCase <EOL> import unittest as pyunit <EOL> class TestPyUnitTestCase ( SynchronousTestCase ) : <EOL> class PyUnitTest ( pyunit . TestCase ) : <EOL> def test_pass ( self ) : <EOL> pass <EOL> def setUp ( self ) : <EOL> self . original = self . PyUnitTest ( '<STR_LIT>' ) <EOL> self . test = ITestCase ( self . original ) <EOL> def test_callable ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . assertTrue ( callable ( self . test ) , <EOL> \"<STR_LIT>\" % ( self . test , ) ) <EOL> if _PY3 : <EOL> del TestPyUnitTestCase <EOL> class TestPyUnitResult ( SynchronousTestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class ErrorTest ( SynchronousTestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ran = False <EOL> def test_foo ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . ran = True <EOL> <NUM_LIT:1> / <NUM_LIT:0> <EOL> def test_dontUseAdapterWhenReporterProvidesIReporter ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ implementer ( IReporter ) <EOL> class StubReporter ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> self . errors = [ ] <EOL> self . failures = [ ] <EOL> def startTest ( self , test ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def stopTest ( self , test ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def addError ( self , test , error ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . errors . append ( error ) <EOL> test = self . ErrorTest ( \"<STR_LIT>\" ) <EOL> result = StubReporter ( ) <EOL> test . run ( result ) <EOL> self . assertIsInstance ( result . errors [ <NUM_LIT:0> ] , Failure ) <EOL> def test_success ( self ) : <EOL> class SuccessTest ( SynchronousTestCase ) : <EOL> ran = False <EOL> def test_foo ( s ) : <EOL> s . ran = True <EOL> test = SuccessTest ( '<STR_LIT>' ) <EOL> result = pyunit . TestResult ( ) <EOL> test . run ( result ) <EOL> self . failUnless ( test . ran ) <EOL> self . assertEqual ( <NUM_LIT:1> , result . testsRun ) <EOL> self . failUnless ( result . wasSuccessful ( ) ) <EOL> def test_failure ( self ) : <EOL> class FailureTest ( SynchronousTestCase ) : <EOL> ran = False <EOL> def test_foo ( s ) : <EOL> s . ran = True <EOL> s . fail ( '<STR_LIT>' ) <EOL> test = FailureTest ( '<STR_LIT>' ) <EOL> result = pyunit . TestResult ( ) <EOL> test . run ( result ) <EOL> self . failUnless ( test . ran ) <EOL> self . assertEqual ( <NUM_LIT:1> , result . testsRun ) <EOL> self . assertEqual ( <NUM_LIT:1> , len ( result . failures ) ) <EOL> self . failIf ( result . wasSuccessful ( ) ) <EOL> def test_error ( self ) : <EOL> test = self . ErrorTest ( '<STR_LIT>' ) <EOL> result = pyunit . TestResult ( ) <EOL> test . run ( result ) <EOL> self . failUnless ( test . ran ) <EOL> self . assertEqual ( <NUM_LIT:1> , result . testsRun ) <EOL> self . assertEqual ( <NUM_LIT:1> , len ( result . errors ) ) <EOL> self . failIf ( result . wasSuccessful ( ) ) <EOL> def test_setUpError ( self ) : <EOL> class ErrorTest ( SynchronousTestCase ) : <EOL> ran = False <EOL> def setUp ( self ) : <EOL> <NUM_LIT:1> / <NUM_LIT:0> <EOL> def test_foo ( s ) : <EOL> s . ran = True <EOL> test = ErrorTest ( '<STR_LIT>' ) <EOL> result = pyunit . TestResult ( ) <EOL> test . run ( result ) <EOL> self . failIf ( test . ran ) <EOL> self . assertEqual ( <NUM_LIT:1> , result . testsRun ) <EOL> self . assertEqual ( <NUM_LIT:1> , len ( result . errors ) ) <EOL> self . failIf ( result . wasSuccessful ( ) ) <EOL> def test_tracebackFromFailure ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> <NUM_LIT:1> / <NUM_LIT:0> <EOL> except ZeroDivisionError : <EOL> exc_info = sys . exc_info ( ) <EOL> f = Failure ( ) <EOL> pyresult = pyunit . TestResult ( ) <EOL> result = PyUnitResultAdapter ( pyresult ) <EOL> result . addError ( self , f ) <EOL> self . assertEqual ( pyresult . errors [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] , <EOL> '<STR_LIT>' . join ( traceback . format_exception ( * exc_info ) ) ) <EOL> def test_traceback ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class ErrorTest ( SynchronousTestCase ) : <EOL> exc_info = None <EOL> def test_foo ( self ) : <EOL> try : <EOL> <NUM_LIT:1> / <NUM_LIT:0> <EOL> except ZeroDivisionError : <EOL> self . exc_info = sys . exc_info ( ) <EOL> raise <EOL> test = ErrorTest ( '<STR_LIT>' ) <EOL> result = pyunit . TestResult ( ) <EOL> test . run ( result ) <EOL> expected_stack = '<STR_LIT>' . join ( traceback . format_tb ( test . exc_info [ <NUM_LIT:2> ] ) ) <EOL> observed_stack = '<STR_LIT:\\n>' . join ( result . errors [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] . splitlines ( ) [ : - <NUM_LIT:1> ] ) <EOL> self . assertEqual ( expected_stack . strip ( ) , <EOL>", "answer": "observed_stack [ - len ( expected_stack ) : ] . strip ( ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from sellar import SellarProblem , SellarProblemWithDeriv <EOL>", "answer": "from branin import BraninProblem"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from os_client_config import cloud_config <EOL> from os_client_config import config <EOL> from os_client_config import exceptions <EOL> from os_client_config . tests import base <EOL> import fixtures <EOL> class TestEnviron ( base . TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( TestEnviron , self ) . setUp ( ) <EOL> self . useFixture ( <EOL> fixtures . EnvironmentVariable ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> self . useFixture ( <EOL> fixtures . EnvironmentVariable ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> self . useFixture ( <EOL> fixtures . EnvironmentVariable ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> self . useFixture ( <EOL> fixtures . EnvironmentVariable ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> self . useFixture ( <EOL> fixtures . EnvironmentVariable ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> def test_get_one_cloud ( self ) : <EOL> c = config . OpenStackConfig ( config_files = [ self . cloud_yaml ] , <EOL> vendor_files = [ self . vendor_yaml ] ) <EOL> self . assertIsInstance ( c . get_one_cloud ( ) , cloud_config . CloudConfig ) <EOL> def test_no_fallthrough ( self ) : <EOL> c = config . OpenStackConfig ( config_files = [ self . cloud_yaml ] , <EOL> vendor_files = [ self . vendor_yaml ] ) <EOL> self . assertRaises ( <EOL> exceptions . OpenStackConfigException , c . get_one_cloud , '<STR_LIT>' ) <EOL> def test_envvar_name_override ( self ) : <EOL> self . useFixture ( <EOL> fixtures . EnvironmentVariable ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> c = config . OpenStackConfig ( config_files = [ self . cloud_yaml ] , <EOL> vendor_files = [ self . vendor_yaml ] ) <EOL> cc = c . get_one_cloud ( '<STR_LIT>' ) <EOL>", "answer": "self . _assert_cloud_details ( cc )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import json <EOL> import os <EOL> import tempfile <EOL> import unittest <EOL> from zipfile import ZipFile <EOL> import shutil <EOL> from nordicsemi . dfu . package import Package <EOL> class TestPackage ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . work_directory = tempfile . mkdtemp ( prefix = \"<STR_LIT>\" ) <EOL> def tearDown ( self ) : <EOL> shutil . rmtree ( self . work_directory , ignore_errors = True ) <EOL> def test_generate_package_application ( self ) : <EOL> self . p = Package ( <EOL> dev_type = <NUM_LIT:1> , <EOL> dev_rev = <NUM_LIT:2> , <EOL> app_version = <NUM_LIT:100> , <EOL> sd_req = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> app_fw = \"<STR_LIT>\" <EOL> ) <EOL> pkg_name = \"<STR_LIT>\" <EOL> self . p . generate_package ( pkg_name , preserve_work_directory = False ) <EOL> expected_zip_content = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> with ZipFile ( pkg_name , '<STR_LIT:r>' ) as pkg : <EOL> infolist = pkg . infolist ( ) <EOL> for file_information in infolist : <EOL> self . assertTrue ( file_information . filename in expected_zip_content ) <EOL> self . assertGreater ( file_information . file_size , <NUM_LIT:0> ) <EOL> pkg . extractall ( self . work_directory ) <EOL> with open ( os . path . join ( self . work_directory , '<STR_LIT>' ) , '<STR_LIT:r>' ) as f : <EOL> _json = json . load ( f ) <EOL> self . assertEqual ( u'<STR_LIT>' , _json [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( u'<STR_LIT>' , _json [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( u'<STR_LIT>' not in _json [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( u'<STR_LIT>' not in _json [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( u'<STR_LIT>' not in _json [ '<STR_LIT>' ] ) <EOL> def test_generate_package_sd_bl ( self ) : <EOL> self . p = Package ( dev_type = <NUM_LIT:1> , <EOL> dev_rev = <NUM_LIT:2> , <EOL> app_version = <NUM_LIT:100> , <EOL> sd_req = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> softdevice_fw = \"<STR_LIT>\" , <EOL> bootloader_fw = \"<STR_LIT>\" ) <EOL> pkg_name = \"<STR_LIT>\" <EOL> self . p . generate_package ( pkg_name , preserve_work_directory = False ) <EOL> expected_zip_content = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> with ZipFile ( pkg_name , '<STR_LIT:r>' ) as pkg : <EOL> infolist = pkg . infolist ( ) <EOL> for file_information in infolist : <EOL> self . assertTrue ( file_information . filename in expected_zip_content ) <EOL> self . assertGreater ( file_information . file_size , <NUM_LIT:0> ) <EOL> pkg . extractall ( self . work_directory ) <EOL> with open ( os . path . join ( self . work_directory , '<STR_LIT>' ) , '<STR_LIT:r>' ) as f : <EOL> _json = json . load ( f ) <EOL> self . assertEqual ( u'<STR_LIT>' , _json [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( u'<STR_LIT>' , _json [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> def test_unpack_package_a ( self ) : <EOL> self . p = Package ( dev_type = <NUM_LIT:1> , <EOL> dev_rev = <NUM_LIT:2> , <EOL> app_version = <NUM_LIT:100> , <EOL>", "answer": "sd_req = [ <NUM_LIT> , <NUM_LIT> ] ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals , print_function , division <EOL> __author__ = \"<STR_LIT>\" <EOL> try : <EOL> import unittest2 as unittest <EOL> except ImportError : <EOL> import unittest <EOL> from ezodf . xmlns import etree , CN <EOL> from ezodf . base import GenericWrapper <EOL> from ezodf . text import Paragraph , Span , Heading , NumberedParagraph , Hyperlink <EOL> SPANDATA = '<STR_LIT>' '<STR_LIT>' <EOL> SPANDATA_SPC = '<STR_LIT>' '<STR_LIT>' <EOL> SPANDATA_BRK = '<STR_LIT>' '<STR_LIT>' <EOL> SPANDATA_TAB = '<STR_LIT>' '<STR_LIT>' <EOL> SPANDATA_ALL = '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' <EOL> class TestSpan ( unittest . TestCase ) : <EOL> def test_bare_init ( self ) : <EOL> span = Span ( ) <EOL> self . assertTrue ( isinstance ( span , GenericWrapper ) ) <EOL> self . assertEqual ( span . xmlnode . tag , CN ( '<STR_LIT>' ) ) <EOL> def test_init_xmlroot ( self ) : <EOL> node = etree . Element ( CN ( '<STR_LIT>' ) , test = \"<STR_LIT>\" ) <EOL> span = Span ( xmlnode = node ) <EOL> self . assertTrue ( isinstance ( span , GenericWrapper ) ) <EOL> self . assertEqual ( span . xmlnode . tag , CN ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( span . xmlnode . get ( '<STR_LIT:test>' ) , \"<STR_LIT>\" ) <EOL> def test_init_XML ( self ) : <EOL> node = etree . XML ( SPANDATA ) <EOL> span = Span ( xmlnode = node ) <EOL> self . assertTrue ( isinstance ( span , GenericWrapper ) ) <EOL> self . assertEqual ( span . xmlnode . tag , CN ( '<STR_LIT>' ) ) <EOL> def test_textlen ( self ) : <EOL> span = Span ( xmlnode = etree . XML ( SPANDATA ) ) <EOL> self . assertEqual ( span . textlen , <NUM_LIT:8> ) <EOL> def test_textlen_with_spaces ( self ) : <EOL> span = Span ( xmlnode = etree . XML ( SPANDATA_SPC ) ) <EOL> self . assertEqual ( span . textlen , <NUM_LIT:12> ) <EOL> def test_textlen_with_line_break ( self ) : <EOL> span = Span ( xmlnode = etree . XML ( SPANDATA_BRK ) ) <EOL> self . assertEqual ( span . textlen , <NUM_LIT:11> ) <EOL> def test_textlen_with_tab ( self ) : <EOL> span = Span ( xmlnode = etree . XML ( SPANDATA_TAB ) ) <EOL> self . assertEqual ( span . textlen , <NUM_LIT:11> ) <EOL> def test_textlen_with_all ( self ) : <EOL> span = Span ( xmlnode = etree . XML ( SPANDATA_ALL ) ) <EOL> self . assertEqual ( span . textlen , <NUM_LIT> ) <EOL> def test_plaintext ( self ) : <EOL> span = Span ( xmlnode = etree . XML ( SPANDATA ) ) <EOL> self . assertEqual ( span . plaintext ( ) , '<STR_LIT>' ) <EOL> def test_plaintext_with_spaces ( self ) : <EOL> span = Span ( xmlnode = etree . XML ( SPANDATA_SPC ) ) <EOL> self . assertEqual ( span . plaintext ( ) , '<STR_LIT>' ) <EOL> def test_plaintext_with_line_break ( self ) : <EOL> span = Span ( xmlnode = etree . XML ( SPANDATA_BRK ) ) <EOL> self . assertEqual ( span . plaintext ( ) , '<STR_LIT>' ) <EOL> def test_plaintext_with_tab ( self ) : <EOL> span = Span ( xmlnode = etree . XML ( SPANDATA_TAB ) ) <EOL> self . assertEqual ( span . plaintext ( ) , '<STR_LIT>' ) <EOL> def test_plaintext_with_all ( self ) : <EOL> span = Span ( xmlnode = etree . XML ( SPANDATA_ALL ) ) <EOL> self . assertEqual ( span . plaintext ( ) , '<STR_LIT>' ) <EOL> def test_get_style_name ( self ) : <EOL> span = Span ( xmlnode = etree . XML ( SPANDATA ) ) <EOL> self . assertEqual ( span . style_name , '<STR_LIT>' ) <EOL> def test_set_style_name ( self ) : <EOL> span = Span ( xmlnode = etree . XML ( SPANDATA ) ) <EOL> span . style_name = \"<STR_LIT>\" <EOL> self . assertEqual ( span . style_name , '<STR_LIT>' ) <EOL> def test_append_text ( self ) : <EOL> txt = \"<STR_LIT>\" <EOL> span = Span ( text = txt ) <EOL> self . assertEqual ( span . text , txt ) <EOL> self . assertEqual ( span . plaintext ( ) , txt ) <EOL> def test_append_text_2 ( self ) : <EOL> txt = \"<STR_LIT>\" <EOL> span = Span ( text = txt ) <EOL> self . assertEqual ( span . text , \"<STR_LIT>\" ) <EOL> self . assertEqual ( span [ <NUM_LIT:0> ] . TAG , CN ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( span [ <NUM_LIT:0> ] . tail , \"<STR_LIT>\" ) <EOL> self . assertEqual ( span . plaintext ( ) , txt ) <EOL> def test_append_text_3 ( self ) : <EOL> txt = \"<STR_LIT>\" <EOL> span = Span ( text = txt ) <EOL> self . assertEqual ( span . text , \"<STR_LIT>\" ) <EOL> self . assertEqual ( span [ <NUM_LIT:0> ] . TAG , CN ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( span [ <NUM_LIT:0> ] . tail , \"<STR_LIT>\" ) <EOL> self . assertEqual ( span [ <NUM_LIT:1> ] . TAG , CN ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( span [ <NUM_LIT:1> ] . tail , \"<STR_LIT:U+0020>\" ) <EOL> self . assertEqual ( span [ <NUM_LIT:2> ] . TAG , CN ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( span [ <NUM_LIT:2> ] . tail , None ) <EOL> self . assertEqual ( span [ <NUM_LIT:3> ] . TAG , CN ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( span [ <NUM_LIT:3> ] . tail , \"<STR_LIT:U+0020>\" ) <EOL> self . assertEqual ( span [ <NUM_LIT:4> ] . TAG , CN ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( span [ <NUM_LIT:4> ] . count , <NUM_LIT:3> ) <EOL> self . assertEqual ( span . plaintext ( ) , txt ) <EOL> def test_append_text_4 ( self ) : <EOL> span = Span ( text = \"<STR_LIT>\" ) <EOL> span . append_text ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( span . text , \"<STR_LIT>\" ) <EOL> self . assertEqual ( span [ <NUM_LIT:0> ] . TAG , CN ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( span [ <NUM_LIT:0> ] . tail , \"<STR_LIT>\" ) <EOL> DATA1 = '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' <EOL> class TestParagraph ( unittest . TestCase ) : <EOL> def test_bare_init ( self ) : <EOL> p = Paragraph ( ) <EOL> self . assertTrue ( isinstance ( p , GenericWrapper ) ) <EOL> self . assertEqual ( p . xmlnode . tag , CN ( '<STR_LIT>' ) ) <EOL> def test_init_xmlroot ( self ) : <EOL> node = etree . Element ( CN ( '<STR_LIT>' ) , test = \"<STR_LIT>\" ) <EOL> p = Paragraph ( xmlnode = node ) <EOL> self . assertTrue ( isinstance ( p , GenericWrapper ) ) <EOL> self . assertEqual ( p . xmlnode . tag , CN ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( p . xmlnode . get ( '<STR_LIT:test>' ) , \"<STR_LIT>\" ) <EOL> def test_cond_style_name ( self ) : <EOL> p = Paragraph ( ) <EOL> p . cond_style_name = \"<STR_LIT>\" <EOL> self . assertEqual ( p . cond_style_name , \"<STR_LIT>\" ) <EOL> self . assertIsNotNone ( p . xmlnode . get ( CN ( '<STR_LIT>' ) ) ) <EOL> def test_ID ( self ) : <EOL> p = Paragraph ( ) <EOL> p . ID = \"<STR_LIT>\" <EOL> self . assertEqual ( p . ID , \"<STR_LIT>\" ) <EOL> self . assertIsNotNone ( p . xmlnode . get ( CN ( '<STR_LIT>' ) ) ) <EOL> class TestNumberedParagraph ( unittest . TestCase ) : <EOL> def test_init_1 ( self ) : <EOL> np = NumberedParagraph ( ) <EOL> self . assertEqual ( np . xmlnode . tag , CN ( '<STR_LIT>' ) ) <EOL> def test_init_type_error ( self ) : <EOL> with self . assertRaises ( TypeError ) : <EOL> np = NumberedParagraph ( '<STR_LIT:text>' ) <EOL> def test_paragraph_content ( self ) : <EOL> np = NumberedParagraph ( Paragraph ( '<STR_LIT:text>' ) ) <EOL> res = np . content <EOL> self . assertEqual ( res . plaintext ( ) , '<STR_LIT:text>' ) <EOL> def test_heading_content ( self ) : <EOL> np = NumberedParagraph ( Heading ( '<STR_LIT:text>' ) ) <EOL> res = np . content <EOL> self . assertEqual ( res . plaintext ( ) , '<STR_LIT:text>' ) <EOL> def test_no_content ( self ) : <EOL> np = NumberedParagraph ( ) <EOL> newp = np . content <EOL> self . assertEqual ( newp . kind , '<STR_LIT>' ) <EOL> newp . append_text ( '<STR_LIT:text>' ) <EOL> self . assertEqual ( np . content . plaintext ( ) , '<STR_LIT:text>' ) <EOL> def test_level_0 ( self ) : <EOL> np = NumberedParagraph ( ) <EOL> np . level = <NUM_LIT:0> <EOL> self . assertEqual ( np . level , <NUM_LIT:1> ) <EOL> def test_level_1 ( self ) : <EOL> np = NumberedParagraph ( ) <EOL> np . level = '<STR_LIT:1>' <EOL> self . assertEqual ( np . level , <NUM_LIT:1> ) <EOL> def test_level_2 ( self ) : <EOL> np = NumberedParagraph ( ) <EOL>", "answer": "np . level = <NUM_LIT>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import hashlib <EOL> __author__ = '<STR_LIT>' <EOL>", "answer": "def calc_checksum ( filename ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import unicode_literals <EOL> import functools <EOL> import re <EOL> from threading import local <EOL> from django . http import Http404 <EOL> from django . core . exceptions import ImproperlyConfigured , ViewDoesNotExist <EOL> from django . utils . datastructures import MultiValueDict <EOL> from django . utils . encoding import force_str , force_text , iri_to_uri <EOL> from django . utils . functional import memoize , lazy <EOL> from django . utils . http import urlquote <EOL> from django . utils . importlib import import_module <EOL> from django . utils . module_loading import module_has_submodule <EOL> from django . utils . regex_helper import normalize <EOL> from django . utils import six <EOL> from django . utils . translation import get_language <EOL> _resolver_cache = { } <EOL> _ns_resolver_cache = { } <EOL> _callable_cache = { } <EOL> _prefixes = local ( ) <EOL> _urlconfs = local ( ) <EOL> class ResolverMatch ( object ) : <EOL> def __init__ ( self , func , args , kwargs , url_name = None , app_name = None , namespaces = None ) : <EOL> self . func = func <EOL> self . args = args <EOL> self . kwargs = kwargs <EOL> self . app_name = app_name <EOL> if namespaces : <EOL> self . namespaces = [ x for x in namespaces if x ] <EOL> else : <EOL> self . namespaces = [ ] <EOL> if not url_name : <EOL> if not hasattr ( func , '<STR_LIT>' ) : <EOL> url_name = '<STR_LIT:.>' . join ( [ func . __class__ . __module__ , func . __class__ . __name__ ] ) <EOL> else : <EOL> url_name = '<STR_LIT:.>' . join ( [ func . __module__ , func . __name__ ] ) <EOL> self . url_name = url_name <EOL> @ property <EOL> def namespace ( self ) : <EOL> return '<STR_LIT::>' . join ( self . namespaces ) <EOL> @ property <EOL> def view_name ( self ) : <EOL> return '<STR_LIT::>' . join ( [ x for x in [ self . namespace , self . url_name ] if x ] ) <EOL> def __getitem__ ( self , index ) : <EOL> return ( self . func , self . args , self . kwargs ) [ index ] <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( <EOL> self . func , self . args , self . kwargs , self . url_name , self . app_name , self . namespace ) <EOL> class Resolver404 ( Http404 ) : <EOL> pass <EOL> class NoReverseMatch ( Exception ) : <EOL> pass <EOL> def get_callable ( lookup_view , can_fail = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not callable ( lookup_view ) : <EOL> mod_name , func_name = get_mod_func ( lookup_view ) <EOL> if func_name == '<STR_LIT>' : <EOL> return lookup_view <EOL> try : <EOL> mod = import_module ( mod_name ) <EOL> except ImportError : <EOL> parentmod , submod = get_mod_func ( mod_name ) <EOL> if ( not can_fail and submod != '<STR_LIT>' and <EOL> not module_has_submodule ( import_module ( parentmod ) , submod ) ) : <EOL> raise ViewDoesNotExist ( <EOL> \"<STR_LIT>\" % <EOL> ( lookup_view , mod_name ) ) <EOL> if not can_fail : <EOL> raise <EOL> else : <EOL> try : <EOL> lookup_view = getattr ( mod , func_name ) <EOL> if not callable ( lookup_view ) : <EOL> raise ViewDoesNotExist ( <EOL> \"<STR_LIT>\" % <EOL> ( mod_name , func_name ) ) <EOL> except AttributeError : <EOL> if not can_fail : <EOL> raise ViewDoesNotExist ( <EOL> \"<STR_LIT>\" % <EOL> ( lookup_view , mod_name ) ) <EOL> return lookup_view <EOL> get_callable = memoize ( get_callable , _callable_cache , <NUM_LIT:1> ) <EOL> def get_resolver ( urlconf ) : <EOL> if urlconf is None : <EOL> from django . conf import settings <EOL> urlconf = settings . ROOT_URLCONF <EOL> return RegexURLResolver ( r'<STR_LIT>' , urlconf ) <EOL> get_resolver = memoize ( get_resolver , _resolver_cache , <NUM_LIT:1> ) <EOL> def get_ns_resolver ( ns_pattern , resolver ) : <EOL> ns_resolver = RegexURLResolver ( ns_pattern , <EOL> resolver . url_patterns ) <EOL> return RegexURLResolver ( r'<STR_LIT>' , [ ns_resolver ] ) <EOL> get_ns_resolver = memoize ( get_ns_resolver , _ns_resolver_cache , <NUM_LIT:2> ) <EOL> def get_mod_func ( callback ) : <EOL> try : <EOL> dot = callback . rindex ( '<STR_LIT:.>' ) <EOL> except ValueError : <EOL> return callback , '<STR_LIT>' <EOL> return callback [ : dot ] , callback [ dot + <NUM_LIT:1> : ] <EOL> class LocaleRegexProvider ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , regex ) : <EOL> self . _regex = regex <EOL> self . _regex_dict = { } <EOL> @ property <EOL> def regex ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> language_code = get_language ( ) <EOL> if language_code not in self . _regex_dict : <EOL> if isinstance ( self . _regex , six . string_types ) : <EOL> regex = self . _regex <EOL> else : <EOL> regex = force_text ( self . _regex ) <EOL> try : <EOL> compiled_regex = re . compile ( regex , re . UNICODE ) <EOL> except re . error as e : <EOL> raise ImproperlyConfigured ( <EOL> '<STR_LIT>' % <EOL> ( regex , six . text_type ( e ) ) ) <EOL> self . _regex_dict [ language_code ] = compiled_regex <EOL> return self . _regex_dict [ language_code ] <EOL> class RegexURLPattern ( LocaleRegexProvider ) : <EOL> def __init__ ( self , regex , callback , default_args = None , name = None ) : <EOL> LocaleRegexProvider . __init__ ( self , regex ) <EOL> if callable ( callback ) : <EOL> self . _callback = callback <EOL> else : <EOL> self . _callback = None <EOL> self . _callback_str = callback <EOL> self . default_args = default_args or { } <EOL> self . name = name <EOL> def __repr__ ( self ) : <EOL> return force_str ( '<STR_LIT>' % ( self . __class__ . __name__ , self . name , self . regex . pattern ) ) <EOL> def add_prefix ( self , prefix ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not prefix or not hasattr ( self , '<STR_LIT>' ) : <EOL> return <EOL> self . _callback_str = prefix + '<STR_LIT:.>' + self . _callback_str <EOL> def resolve ( self , path ) : <EOL> match = self . regex . search ( path ) <EOL> if match : <EOL> kwargs = match . groupdict ( ) <EOL> if kwargs : <EOL> args = ( ) <EOL> else : <EOL> args = match . groups ( ) <EOL> kwargs . update ( self . default_args ) <EOL> return ResolverMatch ( self . callback , args , kwargs , self . name ) <EOL> @ property <EOL> def callback ( self ) : <EOL> if self . _callback is not None : <EOL> return self . _callback <EOL> self . _callback = get_callable ( self . _callback_str ) <EOL> return self . _callback <EOL> class RegexURLResolver ( LocaleRegexProvider ) : <EOL> def __init__ ( self , regex , urlconf_name , default_kwargs = None , app_name = None , namespace = None ) : <EOL> LocaleRegexProvider . __init__ ( self , regex ) <EOL> self . urlconf_name = urlconf_name <EOL> if not isinstance ( urlconf_name , six . string_types ) : <EOL> self . _urlconf_module = self . urlconf_name <EOL> self . callback = None <EOL> self . default_kwargs = default_kwargs or { } <EOL> self . namespace = namespace <EOL> self . app_name = app_name <EOL> self . _reverse_dict = { } <EOL> self . _namespace_dict = { } <EOL> self . _app_dict = { } <EOL> self . _callback_strs = set ( ) <EOL> self . _populated = False <EOL> def __repr__ ( self ) : <EOL> if isinstance ( self . urlconf_name , list ) and len ( self . urlconf_name ) : <EOL> urlconf_repr = '<STR_LIT>' % self . urlconf_name [ <NUM_LIT:0> ] . __class__ . __name__ <EOL> else : <EOL> urlconf_repr = repr ( self . urlconf_name ) <EOL> return str ( '<STR_LIT>' ) % ( <EOL> self . __class__ . __name__ , urlconf_repr , self . app_name , <EOL> self . namespace , self . regex . pattern ) <EOL> def _populate ( self ) : <EOL> lookups = MultiValueDict ( ) <EOL> namespaces = { } <EOL> apps = { } <EOL> language_code = get_language ( ) <EOL> for pattern in reversed ( self . url_patterns ) : <EOL> if hasattr ( pattern , '<STR_LIT>' ) : <EOL> self . _callback_strs . add ( pattern . _callback_str ) <EOL> elif hasattr ( pattern , '<STR_LIT>' ) : <EOL> callback = pattern . _callback <EOL> if isinstance ( callback , functools . partial ) : <EOL> callback = callback . func <EOL> if not hasattr ( callback , '<STR_LIT>' ) : <EOL> lookup_str = callback . __module__ + \"<STR_LIT:.>\" + callback . __class__ . __name__ <EOL> else : <EOL> lookup_str = callback . __module__ + \"<STR_LIT:.>\" + callback . __name__ <EOL> self . _callback_strs . add ( lookup_str ) <EOL> p_pattern = pattern . regex . pattern <EOL> if p_pattern . startswith ( '<STR_LIT>' ) : <EOL> p_pattern = p_pattern [ <NUM_LIT:1> : ] <EOL> if isinstance ( pattern , RegexURLResolver ) : <EOL> if pattern . namespace : <EOL> namespaces [ pattern . namespace ] = ( p_pattern , pattern ) <EOL> if pattern . app_name : <EOL> apps . setdefault ( pattern . app_name , [ ] ) . append ( pattern . namespace ) <EOL> else : <EOL> parent = normalize ( pattern . regex . pattern ) <EOL> for name in pattern . reverse_dict : <EOL> for matches , pat , defaults in pattern . reverse_dict . getlist ( name ) : <EOL> new_matches = [ ] <EOL> for piece , p_args in parent : <EOL> new_matches . extend ( [ ( piece + suffix , p_args + args ) for ( suffix , args ) in matches ] ) <EOL> lookups . appendlist ( name , ( new_matches , p_pattern + pat , dict ( defaults , ** pattern . default_kwargs ) ) ) <EOL> for namespace , ( prefix , sub_pattern ) in pattern . namespace_dict . items ( ) : <EOL> namespaces [ namespace ] = ( p_pattern + prefix , sub_pattern ) <EOL> for app_name , namespace_list in pattern . app_dict . items ( ) : <EOL> apps . setdefault ( app_name , [ ] ) . extend ( namespace_list ) <EOL> self . _callback_strs . update ( pattern . _callback_strs ) <EOL> else : <EOL> bits = normalize ( p_pattern ) <EOL> lookups . appendlist ( pattern . callback , ( bits , p_pattern , pattern . default_args ) ) <EOL> if pattern . name is not None : <EOL>", "answer": "lookups . appendlist ( pattern . name , ( bits , p_pattern , pattern . default_args ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import pybde <EOL> from dfvfs import dependencies <EOL> from dfvfs . file_io import file_object_io <EOL> from dfvfs . lib import bde <EOL>", "answer": "from dfvfs . lib import errors"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from unittest import TestCase <EOL> from testfixtures import TempDirectory <EOL> from nose . tools import eq_ <EOL> from . . hook import default_before_hook <EOL> from . . hook import default_after_hook <EOL> from . . hook import hook <EOL> from ... config import Config <EOL> class TestHooks ( TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . temp_directory = TempDirectory ( ) <EOL> config = Config ( ) <EOL> config . etl [ '<STR_LIT>' ] = self . temp_directory . path <EOL> def tearDown ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . temp_directory . cleanup ( ) <EOL> @ staticmethod <EOL> def test_default_before_hook_simple ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> args , kwargs = default_before_hook ( <NUM_LIT:1> , '<STR_LIT:2>' , three = <NUM_LIT:3> ) <EOL> eq_ ( args , ( <NUM_LIT:1> , '<STR_LIT:2>' ) ) <EOL> eq_ ( kwargs , { '<STR_LIT>' : <NUM_LIT:3> } ) <EOL> @ staticmethod <EOL> def test_default_before_hook_no_params ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> args , kwargs = default_before_hook ( ) <EOL> eq_ ( args , ( ) ) <EOL> eq_ ( kwargs , { } ) <EOL> @ staticmethod <EOL> def test_default_before_hook_only_args ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> args , kwargs = default_before_hook ( <NUM_LIT:1> , '<STR_LIT:2>' ) <EOL> eq_ ( args , ( <NUM_LIT:1> , '<STR_LIT:2>' ) ) <EOL> eq_ ( kwargs , { } ) <EOL> @ staticmethod <EOL> def test_default_before_hook_only_kwargs ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> args , kwargs = default_before_hook ( one = <NUM_LIT:1> , two = '<STR_LIT:2>' ) <EOL> eq_ ( args , ( ) ) <EOL> eq_ ( kwargs , { '<STR_LIT>' : <NUM_LIT:1> , '<STR_LIT>' : '<STR_LIT:2>' } ) <EOL> @ staticmethod <EOL> def test_default_after_hook_simple ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = default_after_hook ( '<STR_LIT:test>' ) <EOL> eq_ ( result , '<STR_LIT:test>' ) <EOL> def test_config_not_found_default_hooks ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> hook_file = '<STR_LIT:\\n>' . join ( [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] ) <EOL> self . temp_directory . write ( '<STR_LIT>' , hook_file ) <EOL> config = Config ( ) <EOL>", "answer": "del config . etl [ '<STR_LIT>' ]"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import requests <EOL> import netrc <EOL> import valor <EOL> session = requests . Session ( ) <EOL> session . auth = ( '<STR_LIT>' , netrc . netrc ( ) . hosts [ '<STR_LIT>' ] [ <NUM_LIT:2> ] ) <EOL> session . headers [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL>", "answer": "schema = valor . Schema . from_file ( '<STR_LIT>' )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django import template <EOL> from django . utils . safestring import mark_safe <EOL> from expedient . common . permissions . shortcuts import has_permission <EOL> from django . contrib . auth . models import User <EOL> register = template . Library ( ) <EOL> @ register . filter <EOL> def is_super_user ( user ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> isSuperUser = False <EOL>", "answer": "if ( has_permission ( user , User , \"<STR_LIT>\" ) ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import datetime <EOL> import json <EOL> import logging <EOL> import time <EOL> from ryu . services . protocols . bgp . rtconf . base import ConfWithId <EOL> _STATS_LOGGER = logging . getLogger ( '<STR_LIT>' ) <EOL> DEFAULT_LOG_LEVEL = logging . INFO <EOL> RESOURCE_ID = '<STR_LIT>' <EOL> RESOURCE_NAME = '<STR_LIT>' <EOL> TIMESTAMP = '<STR_LIT>' <EOL> LOG_LEVEL = '<STR_LIT>' <EOL> STATS_RESOURCE = '<STR_LIT>' <EOL> STATS_SOURCE = '<STR_LIT>' <EOL> REMOTE_ROUTES = '<STR_LIT>' <EOL> LOCAL_ROUTES = '<STR_LIT>' <EOL> UPDATE_MSG_IN = '<STR_LIT>' <EOL> UPDATE_MSG_OUT = '<STR_LIT>' <EOL> TOTAL_MSG_IN = '<STR_LIT>' <EOL> TOTAL_MSG_OUT = '<STR_LIT>' <EOL>", "answer": "FMS_EST_TRANS = '<STR_LIT>'"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import unittest <EOL> from hazelcast . core import Address , Member <EOL> from hazelcast . util import get_possible_addresses <EOL> class AddressTest ( unittest . TestCase ) : <EOL> def test_no_given_address ( self ) : <EOL>", "answer": "addresses = get_possible_addresses ( [ ] )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . template . base import Node <EOL> from inspect import getargspec <EOL> from functools import partial <EOL> from . parse_bits import parse_bits <EOL> def simple_block_tag ( register , takes_context = None , name = None ) : <EOL> def dec ( func ) : <EOL> params , varargs , varkw , defaults = getargspec ( func ) <EOL> class SimpleNode ( Node ) : <EOL> def __init__ ( self , nodelist , takes_context , args , kwargs ) : <EOL> self . nodelist = nodelist <EOL> self . takes_context = takes_context <EOL> self . args = args <EOL> self . kwargs = kwargs <EOL>", "answer": "def get_resolved_arguments ( self , context ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from setuptools import setup , find_packages <EOL> from cyclops import __version__ <EOL> mysql_requires = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> tests_require = mysql_requires + [ <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> import csv <EOL> import os . path <EOL> from pyon . core . registry import getextends , isenum <EOL> from pyon . public import RT , OT <EOL> import interface . objects <EOL> class ObjectGenerator ( object ) : <EOL> @ staticmethod <EOL> def get_extends ( obj_class ) : <EOL> parents = [ parent for parent in obj_class . __mro__ if parent . __name__ not in { '<STR_LIT>' , '<STR_LIT:object>' , obj_class . __name__ } ] <EOL> return parents <EOL> def export_objects ( self , filename = None ) : <EOL> sub_types = { } <EOL> for obj_type in OT . keys ( ) : <EOL> ot_class = getattr ( interface . objects , obj_type ) <EOL> base_type = ot_class . __mro__ [ <NUM_LIT:1> ] . __name__ <EOL> sub_types . setdefault ( base_type , set ( ) ) . add ( obj_type ) <EOL> res_rows = [ ] <EOL> for obj_type in sorted ( OT . keys ( ) ) : <EOL> is_leaf = str ( not bool ( sub_types . get ( obj_type , None ) ) ) <EOL> ot_class = getattr ( interface . objects , obj_type ) <EOL> if not hasattr ( ot_class , \"<STR_LIT>\" ) : <EOL> continue <EOL> base_types_list = [ bc . __name__ for bc in reversed ( self . get_extends ( ot_class ) ) ] <EOL> base_type = base_types_list [ - <NUM_LIT:1> ] if base_types_list else \"<STR_LIT>\" <EOL> base_types = \"<STR_LIT:/>\" . join ( base_types_list [ : - <NUM_LIT:1> ] ) <EOL> oschema = ot_class . _schema <EOL> if obj_type in RT : <EOL> group = \"<STR_LIT>\" <EOL> elif isenum ( obj_type ) : <EOL> group = \"<STR_LIT>\" <EOL> elif \"<STR_LIT>\" in oschema and \"<STR_LIT>\" in oschema : <EOL> group = \"<STR_LIT>\" <EOL> else : <EOL> group = \"<STR_LIT:object>\" <EOL> res_rows . append ( [ \"<STR_LIT:type>\" , base_types , base_type , obj_type , \"<STR_LIT>\" , group , is_leaf , \"<STR_LIT:True>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , ot_class . _class_info . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT:\\\\>\" , \"<STR_LIT>\" ) . strip ( ) , \"<STR_LIT>\" ] ) <EOL> if group == \"<STR_LIT>\" or group == \"<STR_LIT:object>\" : <EOL> res_rows . append ( [ group , base_types , base_type , obj_type , \"<STR_LIT>\" , \"<STR_LIT>\" , is_leaf , \"<STR_LIT:True>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> for att in sorted ( oschema . keys ( ) ) : <EOL> if group == \"<STR_LIT>\" and att in { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:name>\" , \"<STR_LIT:description>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } : <EOL> continue <EOL> att_obj = oschema [ att ] <EOL> ot , odef , odeco , odesc = att_obj [ \"<STR_LIT:type>\" ] , att_obj [ \"<STR_LIT:default>\" ] , att_obj [ \"<STR_LIT>\" ] , att_obj [ \"<STR_LIT:description>\" ] <EOL> if group == \"<STR_LIT>\" and att == \"<STR_LIT:name>\" : <EOL> odesc = \"<STR_LIT>\" <EOL> att_def = obj_type <EOL> leaf_attr = True <EOL> for base_class in self . get_extends ( ot_class ) : <EOL> if hasattr ( base_class , \"<STR_LIT>\" ) and att in base_class . _schema : <EOL> att_def = base_class . __name__ <EOL> leaf_attr = False <EOL> is_internal = \"<STR_LIT>\" <EOL> attr_desc = odesc . replace ( \"<STR_LIT:\\\\>\" , \"<STR_LIT>\" ) . strip ( ) <EOL> if \"<STR_LIT>\" in attr_desc : <EOL> is_internal = \"<STR_LIT>\" <EOL> res_rows . append ( [ group , base_types , base_type , obj_type , att , ot , is_leaf , leaf_attr , att_def , odef , attr_desc , is_internal ] ) <EOL> if not filename : <EOL> csvfile_name = os . path . join ( \"<STR_LIT>\" , '<STR_LIT>' ) <EOL> try : <EOL> os . unlink ( csvfile_name ) <EOL> except : <EOL> pass <EOL> else : <EOL>", "answer": "csvfile_name = filename"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from hashlib import sha256 <EOL> from prob18 import raw_xor <EOL> from prob33 import group5_p , intToBytes , mypow <EOL> from random import randrange <EOL> def myhmac ( hash_function , message , key ) : <EOL> blocksize = hash_function ( ) . block_size ; <EOL> if ( len ( key ) > blocksize ) : <EOL> key = hash_function ( key ) . digest ( ) <EOL> if ( len ( key ) < blocksize ) : <EOL> key += ( b'<STR_LIT:\\x00>' * ( blocksize - len ( key ) ) ) ; <EOL> opad = raw_xor ( b'<STR_LIT>' * blocksize , key ) ; <EOL> ipad = raw_xor ( b'<STR_LIT>' * blocksize , key ) ; <EOL> return hash_function ( opad + hash_function ( ipad + message ) . digest ( ) ) . digest ( ) ; <EOL> SRP_p = group5_p <EOL> SRP_g = <NUM_LIT:2> ; <EOL> SRP_k = <NUM_LIT:3> ; <EOL> I = b'<STR_LIT>' <EOL> P = b'<STR_LIT>' <EOL> def SRP_init ( ) : <EOL> state = { \"<STR_LIT:p>\" : SRP_p , <EOL> \"<STR_LIT:g>\" : SRP_g , <EOL> \"<STR_LIT:k>\" : SRP_k , <EOL>", "answer": "\"<STR_LIT:I>\" : I ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import datetime <EOL> from testcases import common <EOL> class TestCase ( common . TestCase ) : <EOL>", "answer": "def testBacktestingLog1 ( self ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . db import models <EOL> class SurveyType ( models . Model ) : <EOL> slug = models . CharField ( max_length = <NUM_LIT:100> , unique = True ) <EOL> class Meta : <EOL> app_label = '<STR_LIT>' <EOL>", "answer": "def __unicode__ ( self ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import datetime <EOL> from googleads import dfp <EOL> ORDER_ID = '<STR_LIT>' <EOL> def main ( client , order_id ) : <EOL> line_item_service = client . GetService ( '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> three_days_ago = datetime . date . today ( ) - datetime . timedelta ( days = <NUM_LIT:3> ) <EOL> values = [ { <EOL> '<STR_LIT:key>' : '<STR_LIT>' , <EOL> '<STR_LIT:value>' : { <EOL>", "answer": "'<STR_LIT>' : '<STR_LIT>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . http import HttpResponseRedirect <EOL> from django . template import RequestContext <EOL> from ionyweb . website . rendering . utils import render_view <EOL>", "answer": "def index_view ( request , page_app ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import pytest <EOL> from comport . content . models import ChartBlock <EOL> from comport . department . models import Extractor <EOL> from . factories import DepartmentFactory <EOL> import uuid <EOL> @ pytest . mark . usefixtures ( '<STR_LIT>' ) <EOL> class TestExtractors : <EOL> def test_extractors_from_department_and_password ( self ) : <EOL> department = DepartmentFactory ( ) <EOL> department . save ( ) <EOL> password = str ( uuid . uuid4 ( ) ) <EOL> extractor , envs = Extractor . from_department_and_password ( department = department , password = password ) <EOL> assert department == extractor . departments [ <NUM_LIT:0> ] <EOL> assert extractor . check_password ( password ) is True <EOL> assert password in envs <EOL> def test_get_extractor_from_department ( self ) : <EOL> department = DepartmentFactory ( ) <EOL> department . save ( ) <EOL> assert ( \"<STR_LIT:U+0020>\" in department . name ) is True <EOL> password = str ( uuid . uuid4 ( ) ) <EOL> extractor , envs = Extractor . from_department_and_password ( department = department , password = password ) <EOL> extractor . save ( ) <EOL> assert department . get_extractor ( ) == extractor <EOL> assert ( \"<STR_LIT:U+0020>\" in extractor . username ) is False <EOL> def test_regen_extractor_envs ( self ) : <EOL> department = DepartmentFactory ( ) <EOL> department . save ( ) <EOL> password = str ( uuid . uuid4 ( ) ) <EOL> extractor , envs = Extractor . from_department_and_password ( department = department , password = password ) <EOL> extractor . save ( ) <EOL> new_password = str ( uuid . uuid4 ( ) ) <EOL> extractor . set_password ( new_password ) <EOL> assert extractor . check_password ( new_password ) is True <EOL> assert new_password in extractor . generate_envs ( new_password ) <EOL> def test_get_extractor_from_department_without_extractor ( self ) : <EOL> department = DepartmentFactory ( ) <EOL> department . save ( ) <EOL> assert department . get_extractor ( ) == None <EOL> def test_get_complaint_blocks ( self ) : <EOL> '''<STR_LIT>''' <EOL> department = DepartmentFactory ( ) <EOL> department . save ( ) <EOL> complaint_intro = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_bm = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_bya = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_byat = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_bdis = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_bpre = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_od = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_bde = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_bof = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> department . chart_blocks . append ( complaint_intro ) <EOL> department . chart_blocks . append ( complaint_bm ) <EOL> department . chart_blocks . append ( complaint_bya ) <EOL> department . chart_blocks . append ( complaint_byat ) <EOL> department . chart_blocks . append ( complaint_bdis ) <EOL> department . chart_blocks . append ( complaint_bpre ) <EOL> department . chart_blocks . append ( complaint_od ) <EOL> department . chart_blocks . append ( complaint_bde ) <EOL> department . chart_blocks . append ( complaint_bof ) <EOL> department . save ( ) <EOL> complaint_blocks = department . get_complaint_blocks ( ) <EOL> assert complaint_blocks [ '<STR_LIT>' ] == complaint_intro <EOL> assert complaint_blocks [ '<STR_LIT>' ] == complaint_bm <EOL> assert complaint_blocks [ '<STR_LIT>' ] [ <NUM_LIT:0> ] == complaint_bya <EOL> assert complaint_blocks [ '<STR_LIT>' ] [ <NUM_LIT:1> ] == complaint_byat <EOL> assert complaint_blocks [ '<STR_LIT>' ] [ <NUM_LIT:2> ] == complaint_bdis <EOL> assert complaint_blocks [ '<STR_LIT>' ] [ <NUM_LIT:3> ] == complaint_bpre <EOL> assert complaint_blocks [ '<STR_LIT>' ] [ <NUM_LIT:4> ] == complaint_od <EOL> assert complaint_blocks [ '<STR_LIT>' ] [ <NUM_LIT:5> ] == complaint_bde <EOL> assert complaint_blocks [ '<STR_LIT>' ] [ <NUM_LIT:6> ] == complaint_bof <EOL> def test_get_uof_blocks ( self ) : <EOL> '''<STR_LIT>''' <EOL> department = DepartmentFactory ( ) <EOL>", "answer": "department . save ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> import simplejson as json <EOL> except ImportError : <EOL> import json <EOL> from bigml . resourcehandler import ResourceHandler <EOL> from bigml . resourcehandler import ( check_resource_type , get_resource_type , <EOL> check_resource , <EOL> get_anomaly_score_id , get_anomaly_id ) <EOL> from bigml . constants import ( ANOMALY_SCORE_PATH , ANOMALY_PATH , <EOL> TINY_RESOURCE ) <EOL> class AnomalyScoreHandler ( ResourceHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . anomaly_score_url = self . url + ANOMALY_SCORE_PATH <EOL> def create_anomaly_score ( self , anomaly , input_data = None , <EOL> args = None , wait_time = <NUM_LIT:3> , retries = <NUM_LIT:10> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> anomaly_id = None <EOL> resource_type = get_resource_type ( anomaly ) <EOL> if resource_type == ANOMALY_PATH : <EOL> anomaly_id = get_anomaly_id ( anomaly ) <EOL> check_resource ( anomaly_id , <EOL> query_string = TINY_RESOURCE , <EOL> wait_time = wait_time , retries = retries , <EOL> raise_on_error = True , api = self ) <EOL> else : <EOL> raise Exception ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % resource_type ) <EOL> if input_data is None : <EOL> input_data = { } <EOL> create_args = { } <EOL> if args is not None : <EOL> create_args . update ( args ) <EOL> create_args . update ( { <EOL> \"<STR_LIT>\" : input_data } ) <EOL> create_args . update ( { <EOL> \"<STR_LIT>\" : anomaly_id } ) <EOL> body = json . dumps ( create_args ) <EOL> return self . _create ( self . anomaly_score_url , body , <EOL> verify = self . verify ) <EOL> def get_anomaly_score ( self , anomaly_score ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> check_resource_type ( anomaly_score , ANOMALY_SCORE_PATH , <EOL> message = \"<STR_LIT>\" ) <EOL> anomaly_score_id = get_anomaly_score_id ( anomaly_score ) <EOL> if anomaly_score_id : <EOL> return self . _get ( \"<STR_LIT>\" % ( self . url , anomaly_score_id ) ) <EOL> def list_anomaly_scores ( self , query_string = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "return self . _list ( self . anomaly_score_url , query_string )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from combi . _python_toolbox import cute_testing <EOL> from combi import * <EOL> def test_chain_spaces ( ) : <EOL> chain_space = ChainSpace ( ( range ( <NUM_LIT:3> ) , '<STR_LIT>' , range ( <NUM_LIT> , <NUM_LIT> , - <NUM_LIT:1> ) ) ) <EOL> assert tuple ( chain_space ) == ( <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> , '<STR_LIT:m>' , '<STR_LIT:e>' , '<STR_LIT:o>' , '<STR_LIT:w>' , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:20> ) <EOL> assert len ( chain_space ) == chain_space . length == <NUM_LIT:10> <EOL> assert bool ( chain_space ) is True <EOL> for i , item in enumerate ( chain_space ) : <EOL>", "answer": "assert chain_space [ i ] == item"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import errno <EOL> import os <EOL> import os . path <EOL> import re <EOL> import tempfile <EOL> import time <EOL> import logging <EOL> import pwd <EOL> import shutil <EOL> import urllib2 <EOL> from bitarray import bitarray <EOL> try : <EOL> import psutil <EOL> except ImportError : <EOL> psutil = None <EOL> try : <EOL> import fdsend <EOL> except ImportError : <EOL> fdsend = None <EOL> from ganeti import utils <EOL> from ganeti import constants <EOL> from ganeti import errors <EOL> from ganeti import serializer <EOL> from ganeti import objects <EOL> from ganeti import uidpool <EOL> from ganeti import ssconf <EOL> from ganeti import netutils <EOL> from ganeti import pathutils <EOL> from ganeti . hypervisor import hv_base <EOL> from ganeti . utils import wrapper as utils_wrapper <EOL> from ganeti . hypervisor . hv_kvm . monitor import QmpConnection , QmpMessage , MonitorSocket <EOL> from ganeti . hypervisor . hv_kvm . netdev import OpenTap <EOL> _KVM_NETWORK_SCRIPT = pathutils . CONF_DIR + \"<STR_LIT>\" <EOL> _KVM_START_PAUSED_FLAG = \"<STR_LIT>\" <EOL> _SPICE_ADDITIONAL_PARAMS = frozenset ( [ <EOL> constants . HV_KVM_SPICE_IP_VERSION , <EOL> constants . HV_KVM_SPICE_PASSWORD_FILE , <EOL> constants . HV_KVM_SPICE_LOSSLESS_IMG_COMPR , <EOL> constants . HV_KVM_SPICE_JPEG_IMG_COMPR , <EOL> constants . HV_KVM_SPICE_ZLIB_GLZ_IMG_COMPR , <EOL> constants . HV_KVM_SPICE_STREAMING_VIDEO_DETECTION , <EOL> constants . HV_KVM_SPICE_USE_TLS , <EOL> ] ) <EOL> _KVM_NICS_RUNTIME_INDEX = <NUM_LIT:1> <EOL> _KVM_DISKS_RUNTIME_INDEX = <NUM_LIT:3> <EOL> _DEVICE_RUNTIME_INDEX = { <EOL> constants . HOTPLUG_TARGET_DISK : _KVM_DISKS_RUNTIME_INDEX , <EOL> constants . HOTPLUG_TARGET_NIC : _KVM_NICS_RUNTIME_INDEX <EOL> } <EOL> _FIND_RUNTIME_ENTRY = { <EOL> constants . HOTPLUG_TARGET_NIC : <EOL> lambda nic , kvm_nics : [ n for n in kvm_nics if n . uuid == nic . uuid ] , <EOL> constants . HOTPLUG_TARGET_DISK : <EOL> lambda disk , kvm_disks : [ ( d , l , u ) for ( d , l , u ) in kvm_disks <EOL> if d . uuid == disk . uuid ] <EOL> } <EOL> _RUNTIME_DEVICE = { <EOL> constants . HOTPLUG_TARGET_NIC : lambda d : d , <EOL> constants . HOTPLUG_TARGET_DISK : lambda ( d , e , _ ) : d <EOL> } <EOL> _RUNTIME_ENTRY = { <EOL> constants . HOTPLUG_TARGET_NIC : lambda d , e : d , <EOL> constants . HOTPLUG_TARGET_DISK : lambda d , e : ( d , e [ <NUM_LIT:0> ] , e [ <NUM_LIT:1> ] ) <EOL> } <EOL> _DEVICE_TYPE = { <EOL> constants . HOTPLUG_TARGET_NIC : lambda hvp : hvp [ constants . HV_NIC_TYPE ] , <EOL> constants . HOTPLUG_TARGET_DISK : lambda hvp : hvp [ constants . HV_DISK_TYPE ] , <EOL> } <EOL> _DEVICE_DRIVER = { <EOL> constants . HOTPLUG_TARGET_NIC : <EOL> lambda ht : \"<STR_LIT>\" if ht == constants . HT_NIC_PARAVIRTUAL else ht , <EOL> constants . HOTPLUG_TARGET_DISK : <EOL> lambda ht : \"<STR_LIT>\" if ht == constants . HT_DISK_PARAVIRTUAL else ht , <EOL> } <EOL> _DEVICE_BUS = { <EOL> constants . HOTPLUG_TARGET_NIC : <EOL> lambda _ : _PCI_BUS , <EOL> constants . HOTPLUG_TARGET_DISK : <EOL> lambda ht : _SCSI_BUS if ht in constants . HT_SCSI_DEVICE_TYPES else _PCI_BUS <EOL> } <EOL> _HOTPLUGGABLE_DEVICE_TYPES = { <EOL> constants . HOTPLUG_TARGET_NIC : [ <EOL> constants . HT_NIC_E1000 , <EOL> constants . HT_NIC_I82551 , <EOL> constants . HT_NIC_I8259ER , <EOL> constants . HT_NIC_I85557B , <EOL> constants . HT_NIC_NE2K_PCI , <EOL> constants . HT_NIC_PARAVIRTUAL , <EOL> constants . HT_NIC_PCNET , <EOL> constants . HT_NIC_RTL8139 , <EOL> ] , <EOL> constants . HOTPLUG_TARGET_DISK : [ <EOL> constants . HT_DISK_PARAVIRTUAL , <EOL> constants . HT_DISK_SCSI_BLOCK , <EOL> constants . HT_DISK_SCSI_GENERIC , <EOL> constants . HT_DISK_SCSI_HD , <EOL> constants . HT_DISK_SCSI_CD , <EOL> ] <EOL> } <EOL> _PCI_BUS = \"<STR_LIT>\" <EOL> _SCSI_BUS = \"<STR_LIT>\" <EOL> _MIGRATION_CAPS_DELIM = \"<STR_LIT::>\" <EOL> def _with_qmp ( fn ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def wrapper ( self , instance , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not getattr ( self , \"<STR_LIT>\" , None ) : <EOL> filename = self . _InstanceQmpMonitor ( instance . name ) <EOL> self . qmp = QmpConnection ( filename ) <EOL> return fn ( self , instance , * args , ** kwargs ) <EOL> return wrapper <EOL> def _GetDriveURI ( disk , link , uri ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> access_mode = disk . params . get ( constants . LDP_ACCESS , <EOL> constants . DISK_KERNELSPACE ) <EOL> if ( uri and access_mode == constants . DISK_USERSPACE ) : <EOL> drive_uri = uri <EOL> else : <EOL> drive_uri = link <EOL> return drive_uri <EOL> def _GenerateDeviceKVMId ( dev_type , dev ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return \"<STR_LIT>\" % ( dev_type . lower ( ) , dev . uuid . rsplit ( \"<STR_LIT:->\" , <NUM_LIT:2> ) [ <NUM_LIT:0> ] ) <EOL> def _GenerateDeviceHVInfoStr ( hvinfo ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> d = dict ( hvinfo ) <EOL> hvinfo_str = d . pop ( \"<STR_LIT>\" ) <EOL> for k , v in d . items ( ) : <EOL> hvinfo_str += \"<STR_LIT>\" % ( k , v ) <EOL> return hvinfo_str <EOL> def _GenerateDeviceHVInfo ( dev_type , kvm_devid , hv_dev_type , bus_slots ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> driver = _DEVICE_DRIVER [ dev_type ] ( hv_dev_type ) <EOL> bus = _DEVICE_BUS [ dev_type ] ( hv_dev_type ) <EOL> slots = bus_slots [ bus ] <EOL> slot = utils . GetFreeSlot ( slots , reserve = True ) <EOL> hvinfo = { <EOL> \"<STR_LIT>\" : driver , <EOL> \"<STR_LIT:id>\" : kvm_devid , <EOL> \"<STR_LIT>\" : bus , <EOL> } <EOL> if bus == _PCI_BUS : <EOL> hvinfo . update ( { <EOL> \"<STR_LIT>\" : hex ( slot ) , <EOL> } ) <EOL> elif bus == _SCSI_BUS : <EOL> hvinfo . update ( { <EOL> \"<STR_LIT>\" : <NUM_LIT:0> , <EOL> \"<STR_LIT>\" : slot , <EOL> \"<STR_LIT>\" : <NUM_LIT:0> , <EOL> } ) <EOL> return hvinfo <EOL> def _GetExistingDeviceInfo ( dev_type , device , runtime ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> index = _DEVICE_RUNTIME_INDEX [ dev_type ] <EOL> found = _FIND_RUNTIME_ENTRY [ dev_type ] ( device , runtime [ index ] ) <EOL> if not found : <EOL> raise errors . HotplugError ( \"<STR_LIT>\" % <EOL> ( dev_type , device . uuid ) ) <EOL> return found [ <NUM_LIT:0> ] <EOL> def _UpgradeSerializedRuntime ( serialized_runtime ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> loaded_runtime = serializer . Load ( serialized_runtime ) <EOL> kvm_cmd , serialized_nics , hvparams = loaded_runtime [ : <NUM_LIT:3> ] <EOL> if len ( loaded_runtime ) >= <NUM_LIT:4> : <EOL> serialized_disks = loaded_runtime [ <NUM_LIT:3> ] <EOL> else : <EOL> serialized_disks = [ ] <EOL> def update_hvinfo ( dev , dev_type ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if \"<STR_LIT>\" not in dev : <EOL> dev [ \"<STR_LIT>\" ] = { } <EOL> uuid = dev [ \"<STR_LIT>\" ] <EOL> if \"<STR_LIT>\" in dev : <EOL> dev [ \"<STR_LIT>\" ] [ \"<STR_LIT:id>\" ] = \"<STR_LIT>\" % ( dev_type . lower ( ) , <EOL> uuid . split ( \"<STR_LIT:->\" ) [ <NUM_LIT:0> ] , <EOL> \"<STR_LIT>\" , <EOL> dev [ \"<STR_LIT>\" ] ) <EOL> dev [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] = hex ( dev [ \"<STR_LIT>\" ] ) <EOL> dev [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] = _PCI_BUS <EOL> del dev [ \"<STR_LIT>\" ] <EOL> for nic in serialized_nics : <EOL> if \"<STR_LIT>\" not in nic : <EOL> nic [ \"<STR_LIT>\" ] = utils . NewUUID ( ) <EOL> update_hvinfo ( nic , constants . HOTPLUG_TARGET_NIC ) <EOL> for disk_entry in serialized_disks : <EOL> update_hvinfo ( disk_entry [ <NUM_LIT:0> ] , constants . HOTPLUG_TARGET_DISK ) <EOL> return kvm_cmd , serialized_nics , hvparams , serialized_disks <EOL> def _AnalyzeSerializedRuntime ( serialized_runtime ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> kvm_cmd , serialized_nics , hvparams , serialized_disks = _UpgradeSerializedRuntime ( serialized_runtime ) <EOL> kvm_nics = [ objects . NIC . FromDict ( snic ) for snic in serialized_nics ] <EOL> kvm_disks = [ ( objects . Disk . FromDict ( sdisk ) , link , uri ) <EOL> for sdisk , link , uri in serialized_disks ] <EOL> return ( kvm_cmd , kvm_nics , hvparams , kvm_disks ) <EOL> class HeadRequest ( urllib2 . Request ) : <EOL> def get_method ( self ) : <EOL> return \"<STR_LIT>\" <EOL> def _CheckUrl ( url ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> urllib2 . urlopen ( HeadRequest ( url ) ) <EOL> return True <EOL> except urllib2 . URLError : <EOL> return False <EOL> class KVMHypervisor ( hv_base . BaseHypervisor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> CAN_MIGRATE = True <EOL> _ROOT_DIR = pathutils . RUN_DIR + \"<STR_LIT>\" <EOL> _PIDS_DIR = _ROOT_DIR + \"<STR_LIT>\" <EOL> _UIDS_DIR = _ROOT_DIR + \"<STR_LIT>\" <EOL> _CTRL_DIR = _ROOT_DIR + \"<STR_LIT>\" <EOL> _CONF_DIR = _ROOT_DIR + \"<STR_LIT>\" <EOL> _NICS_DIR = _ROOT_DIR + \"<STR_LIT>\" <EOL> _KEYMAP_DIR = _ROOT_DIR + \"<STR_LIT>\" <EOL> _CHROOT_DIR = _ROOT_DIR + \"<STR_LIT>\" <EOL> _CHROOT_QUARANTINE_DIR = _ROOT_DIR + \"<STR_LIT>\" <EOL> _DIRS = [ _ROOT_DIR , _PIDS_DIR , _UIDS_DIR , _CTRL_DIR , _CONF_DIR , _NICS_DIR , <EOL> _CHROOT_DIR , _CHROOT_QUARANTINE_DIR , _KEYMAP_DIR ] <EOL> PARAMETERS = { <EOL> constants . HV_KVM_PATH : hv_base . REQ_FILE_CHECK , <EOL> constants . HV_KERNEL_PATH : hv_base . OPT_FILE_CHECK , <EOL> constants . HV_INITRD_PATH : hv_base . OPT_FILE_CHECK , <EOL> constants . HV_ROOT_PATH : hv_base . NO_CHECK , <EOL> constants . HV_KERNEL_ARGS : hv_base . NO_CHECK , <EOL> constants . HV_ACPI : hv_base . NO_CHECK , <EOL> constants . HV_SERIAL_CONSOLE : hv_base . NO_CHECK , <EOL> constants . HV_SERIAL_SPEED : hv_base . NO_CHECK , <EOL> constants . HV_VNC_BIND_ADDRESS : hv_base . NO_CHECK , <EOL> constants . HV_VNC_TLS : hv_base . NO_CHECK , <EOL> constants . HV_VNC_X509 : hv_base . OPT_DIR_CHECK , <EOL> constants . HV_VNC_X509_VERIFY : hv_base . NO_CHECK , <EOL> constants . HV_VNC_PASSWORD_FILE : hv_base . OPT_FILE_CHECK , <EOL> constants . HV_KVM_SPICE_BIND : hv_base . NO_CHECK , <EOL> constants . HV_KVM_SPICE_IP_VERSION : <EOL> ( False , lambda x : ( x == constants . IFACE_NO_IP_VERSION_SPECIFIED or <EOL> x in constants . VALID_IP_VERSIONS ) , <EOL> \"<STR_LIT>\" , <EOL> None , None ) , <EOL> constants . HV_KVM_SPICE_PASSWORD_FILE : hv_base . OPT_FILE_CHECK , <EOL> constants . HV_KVM_SPICE_LOSSLESS_IMG_COMPR : <EOL> hv_base . ParamInSet ( <EOL> False , constants . HT_KVM_SPICE_VALID_LOSSLESS_IMG_COMPR_OPTIONS ) , <EOL> constants . HV_KVM_SPICE_JPEG_IMG_COMPR : <EOL> hv_base . ParamInSet ( <EOL> False , constants . HT_KVM_SPICE_VALID_LOSSY_IMG_COMPR_OPTIONS ) , <EOL> constants . HV_KVM_SPICE_ZLIB_GLZ_IMG_COMPR : <EOL> hv_base . ParamInSet ( <EOL> False , constants . HT_KVM_SPICE_VALID_LOSSY_IMG_COMPR_OPTIONS ) , <EOL> constants . HV_KVM_SPICE_STREAMING_VIDEO_DETECTION : <EOL> hv_base . ParamInSet ( <EOL> False , constants . HT_KVM_SPICE_VALID_VIDEO_STREAM_DETECTION_OPTIONS ) , <EOL> constants . HV_KVM_SPICE_AUDIO_COMPR : hv_base . NO_CHECK , <EOL> constants . HV_KVM_SPICE_USE_TLS : hv_base . NO_CHECK , <EOL> constants . HV_KVM_SPICE_TLS_CIPHERS : hv_base . NO_CHECK , <EOL> constants . HV_KVM_SPICE_USE_VDAGENT : hv_base . NO_CHECK , <EOL> constants . HV_KVM_FLOPPY_IMAGE_PATH : hv_base . OPT_FILE_CHECK , <EOL> constants . HV_CDROM_IMAGE_PATH : hv_base . OPT_FILE_OR_URL_CHECK , <EOL> constants . HV_KVM_CDROM2_IMAGE_PATH : hv_base . OPT_FILE_OR_URL_CHECK , <EOL> constants . HV_BOOT_ORDER : <EOL> hv_base . ParamInSet ( True , constants . HT_KVM_VALID_BO_TYPES ) , <EOL> constants . HV_NIC_TYPE : <EOL> hv_base . ParamInSet ( True , constants . HT_KVM_VALID_NIC_TYPES ) , <EOL> constants . HV_DISK_TYPE : <EOL> hv_base . ParamInSet ( True , constants . HT_KVM_VALID_DISK_TYPES ) , <EOL> constants . HV_KVM_SCSI_CONTROLLER_TYPE : <EOL> hv_base . ParamInSet ( True , constants . HT_KVM_VALID_SCSI_CONTROLLER_TYPES ) , <EOL> constants . HV_KVM_CDROM_DISK_TYPE : <EOL> hv_base . ParamInSet ( False , constants . HT_KVM_VALID_DISK_TYPES ) , <EOL> constants . HV_USB_MOUSE : <EOL> hv_base . ParamInSet ( False , constants . HT_KVM_VALID_MOUSE_TYPES ) , <EOL> constants . HV_KEYMAP : hv_base . NO_CHECK , <EOL> constants . HV_MIGRATION_PORT : hv_base . REQ_NET_PORT_CHECK , <EOL> constants . HV_MIGRATION_BANDWIDTH : hv_base . REQ_NONNEGATIVE_INT_CHECK , <EOL> constants . HV_MIGRATION_DOWNTIME : hv_base . REQ_NONNEGATIVE_INT_CHECK , <EOL> constants . HV_MIGRATION_MODE : hv_base . MIGRATION_MODE_CHECK , <EOL> constants . HV_USE_LOCALTIME : hv_base . NO_CHECK , <EOL> constants . HV_DISK_CACHE : <EOL> hv_base . ParamInSet ( True , constants . HT_VALID_CACHE_TYPES ) , <EOL> constants . HV_KVM_DISK_AIO : <EOL> hv_base . ParamInSet ( False , constants . HT_KVM_VALID_AIO_TYPES ) , <EOL> constants . HV_SECURITY_MODEL : <EOL> hv_base . ParamInSet ( True , constants . HT_KVM_VALID_SM_TYPES ) , <EOL> constants . HV_SECURITY_DOMAIN : hv_base . NO_CHECK , <EOL> constants . HV_KVM_FLAG : <EOL> hv_base . ParamInSet ( False , constants . HT_KVM_FLAG_VALUES ) , <EOL> constants . HV_VHOST_NET : hv_base . NO_CHECK , <EOL> constants . HV_VIRTIO_NET_QUEUES : hv_base . OPT_VIRTIO_NET_QUEUES_CHECK , <EOL> constants . HV_KVM_USE_CHROOT : hv_base . NO_CHECK , <EOL> constants . HV_KVM_USER_SHUTDOWN : hv_base . NO_CHECK , <EOL> constants . HV_MEM_PATH : hv_base . OPT_DIR_CHECK , <EOL> constants . HV_REBOOT_BEHAVIOR : <EOL> hv_base . ParamInSet ( True , constants . REBOOT_BEHAVIORS ) , <EOL> constants . HV_CPU_MASK : hv_base . OPT_MULTI_CPU_MASK_CHECK , <EOL> constants . HV_WORKER_CPU_MASK : hv_base . OPT_MULTI_CPU_MASK_CHECK , <EOL> constants . HV_CPU_TYPE : hv_base . NO_CHECK , <EOL> constants . HV_CPU_CORES : hv_base . OPT_NONNEGATIVE_INT_CHECK , <EOL> constants . HV_CPU_THREADS : hv_base . OPT_NONNEGATIVE_INT_CHECK , <EOL> constants . HV_CPU_SOCKETS : hv_base . OPT_NONNEGATIVE_INT_CHECK , <EOL> constants . HV_SOUNDHW : hv_base . NO_CHECK , <EOL> constants . HV_USB_DEVICES : hv_base . NO_CHECK , <EOL> constants . HV_VGA : hv_base . NO_CHECK , <EOL> constants . HV_KVM_EXTRA : hv_base . NO_CHECK , <EOL> constants . HV_KVM_MACHINE_VERSION : hv_base . NO_CHECK , <EOL> constants . HV_KVM_MIGRATION_CAPS : hv_base . NO_CHECK , <EOL> constants . HV_KVM_PCI_RESERVATIONS : <EOL> ( False , lambda x : ( x >= <NUM_LIT:0> and x <= constants . QEMU_PCI_SLOTS ) , <EOL> \"<STR_LIT>\" % <EOL> constants . QEMU_PCI_SLOTS , <EOL> None , None ) , <EOL> constants . HV_VNET_HDR : hv_base . NO_CHECK , <EOL> } <EOL> _VIRTIO = \"<STR_LIT>\" <EOL> _VIRTIO_NET_PCI = \"<STR_LIT>\" <EOL> _VIRTIO_BLK_PCI = \"<STR_LIT>\" <EOL> _MIGRATION_STATUS_RE = re . compile ( r\"<STR_LIT>\" , <EOL> re . M | re . I ) <EOL> _MIGRATION_PROGRESS_RE = re . compile ( r\"<STR_LIT>\" <EOL> r\"<STR_LIT>\" <EOL> r\"<STR_LIT>\" , re . I ) <EOL> _MIGRATION_INFO_MAX_BAD_ANSWERS = <NUM_LIT:5> <EOL> _MIGRATION_INFO_RETRY_DELAY = <NUM_LIT:2> <EOL> _VERSION_RE = re . compile ( r\"<STR_LIT>\" ) <EOL> _CPU_INFO_RE = re . compile ( r\"<STR_LIT>\" , re . I ) <EOL> _CPU_INFO_CMD = \"<STR_LIT>\" <EOL> _CONT_CMD = \"<STR_LIT>\" <EOL> _DEFAULT_MACHINE_VERSION_RE = re . compile ( r\"<STR_LIT>\" , re . M ) <EOL> _CHECK_MACHINE_VERSION_RE = staticmethod ( lambda x : re . compile ( r\"<STR_LIT>\" % x , re . M ) ) <EOL> _QMP_RE = re . compile ( r\"<STR_LIT>\" , re . M ) <EOL> _SPICE_RE = re . compile ( r\"<STR_LIT>\" , re . M ) <EOL> _VHOST_RE = re . compile ( r\"<STR_LIT>\" , re . M ) <EOL> _VIRTIO_NET_QUEUES_RE = re . compile ( r\"<STR_LIT>\" , re . M ) <EOL> _ENABLE_KVM_RE = re . compile ( r\"<STR_LIT>\" , re . M ) <EOL> _DISABLE_KVM_RE = re . compile ( r\"<STR_LIT>\" , re . M ) <EOL> _NETDEV_RE = re . compile ( r\"<STR_LIT>\" , re . M ) <EOL> _DISPLAY_RE = re . compile ( r\"<STR_LIT>\" , re . M ) <EOL> _MACHINE_RE = re . compile ( r\"<STR_LIT>\" , re . M ) <EOL> _DEVICE_DRIVER_SUPPORTED = staticmethod ( lambda drv , devlist : <EOL> re . compile ( r\"<STR_LIT>\" % drv , re . M ) . search ( devlist ) ) <EOL> _BOOT_RE = re . compile ( r\"<STR_LIT>\" , re . M | re . S ) <EOL> _UUID_RE = re . compile ( r\"<STR_LIT>\" , re . M ) <EOL> _INFO_VERSION_RE = re . compile ( r'<STR_LIT>' , re . M ) <EOL> _INFO_VERSION_CMD = \"<STR_LIT>\" <EOL> _DEFAULT_PCI_RESERVATIONS = \"<STR_LIT>\" <EOL> _DEFAULT_SCSI_RESERVATIONS = \"<STR_LIT>\" <EOL> ANCILLARY_FILES = [ <EOL> _KVM_NETWORK_SCRIPT , <EOL> ] <EOL> ANCILLARY_FILES_OPT = [ <EOL> _KVM_NETWORK_SCRIPT , <EOL> ] <EOL> _KVMOPT_HELP = \"<STR_LIT>\" <EOL> _KVMOPT_MLIST = \"<STR_LIT>\" <EOL> _KVMOPT_DEVICELIST = \"<STR_LIT>\" <EOL> _KVMOPTS_CMDS = { <EOL> _KVMOPT_HELP : ( [ \"<STR_LIT>\" ] , False ) , <EOL> _KVMOPT_MLIST : ( [ \"<STR_LIT>\" , \"<STR_LIT:?>\" ] , False ) , <EOL> _KVMOPT_DEVICELIST : ( [ \"<STR_LIT>\" , \"<STR_LIT:?>\" ] , True ) , <EOL> } <EOL> def __init__ ( self ) : <EOL> hv_base . BaseHypervisor . __init__ ( self ) <EOL> dirs = [ ( dname , constants . RUN_DIRS_MODE ) for dname in self . _DIRS ] <EOL> utils . EnsureDirs ( dirs ) <EOL> self . qmp = None <EOL> @ staticmethod <EOL> def VersionsSafeForMigration ( src , target ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return True <EOL> @ classmethod <EOL> def _InstancePidFile ( cls , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return utils . PathJoin ( cls . _PIDS_DIR , instance_name ) <EOL> @ classmethod <EOL> def _InstanceUidFile ( cls , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return utils . PathJoin ( cls . _UIDS_DIR , instance_name ) <EOL> @ classmethod <EOL> def _InstancePidInfo ( cls , pid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> alive = utils . IsProcessAlive ( pid ) <EOL> if not alive : <EOL> raise errors . HypervisorError ( \"<STR_LIT>\" % pid ) <EOL> cmdline_file = utils . PathJoin ( \"<STR_LIT>\" , str ( pid ) , \"<STR_LIT>\" ) <EOL> try : <EOL> cmdline = utils . ReadFile ( cmdline_file ) <EOL> except EnvironmentError , err : <EOL> raise errors . HypervisorError ( \"<STR_LIT>\" % <EOL> ( pid , err ) ) <EOL> instance = None <EOL> memory = <NUM_LIT:0> <EOL> vcpus = <NUM_LIT:0> <EOL> arg_list = cmdline . split ( \"<STR_LIT:\\x00>\" ) <EOL> while arg_list : <EOL> arg = arg_list . pop ( <NUM_LIT:0> ) <EOL> if arg == \"<STR_LIT>\" : <EOL> instance = arg_list . pop ( <NUM_LIT:0> ) <EOL> elif arg == \"<STR_LIT>\" : <EOL> memory = int ( arg_list . pop ( <NUM_LIT:0> ) ) <EOL> elif arg == \"<STR_LIT>\" : <EOL> vcpus = int ( arg_list . pop ( <NUM_LIT:0> ) . split ( \"<STR_LIT:U+002C>\" ) [ <NUM_LIT:0> ] ) <EOL> if instance is None : <EOL> raise errors . HypervisorError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % pid ) <EOL> return ( instance , memory , vcpus ) <EOL> @ classmethod <EOL> def _InstancePidAlive ( cls , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pidfile = cls . _InstancePidFile ( instance_name ) <EOL> pid = utils . ReadPidFile ( pidfile ) <EOL> alive = False <EOL> try : <EOL> cmd_instance = cls . _InstancePidInfo ( pid ) [ <NUM_LIT:0> ] <EOL> alive = ( cmd_instance == instance_name ) <EOL> except errors . HypervisorError : <EOL> pass <EOL> return ( pidfile , pid , alive ) <EOL> @ classmethod <EOL> def _CheckDown ( cls , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> alive = cls . _InstancePidAlive ( instance_name ) [ <NUM_LIT:2> ] <EOL> if alive : <EOL> raise errors . HypervisorError ( \"<STR_LIT>\" % <EOL> ( instance_name , \"<STR_LIT>\" ) ) <EOL> @ classmethod <EOL> def _InstanceMonitor ( cls , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return utils . PathJoin ( cls . _CTRL_DIR , \"<STR_LIT>\" % instance_name ) <EOL> @ classmethod <EOL> def _InstanceSerial ( cls , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return utils . PathJoin ( cls . _CTRL_DIR , \"<STR_LIT>\" % instance_name ) <EOL> @ classmethod <EOL> def _InstanceQmpMonitor ( cls , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return utils . PathJoin ( cls . _CTRL_DIR , \"<STR_LIT>\" % instance_name ) <EOL> @ classmethod <EOL> def _InstanceKvmdMonitor ( cls , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return utils . PathJoin ( cls . _CTRL_DIR , \"<STR_LIT>\" % instance_name ) <EOL> @ classmethod <EOL> def _InstanceShutdownMonitor ( cls , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return utils . PathJoin ( cls . _CTRL_DIR , \"<STR_LIT>\" % instance_name ) <EOL> @ staticmethod <EOL> def _SocatUnixConsoleParams ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if constants . SOCAT_USE_ESCAPE : <EOL> return \"<STR_LIT>\" % constants . SOCAT_ESCAPE_CODE <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> @ classmethod <EOL> def _InstanceKVMRuntime ( cls , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return utils . PathJoin ( cls . _CONF_DIR , \"<STR_LIT>\" % instance_name ) <EOL> @ classmethod <EOL> def _InstanceChrootDir ( cls , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return utils . PathJoin ( cls . _CHROOT_DIR , instance_name ) <EOL> @ classmethod <EOL> def _InstanceNICDir ( cls , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return utils . PathJoin ( cls . _NICS_DIR , instance_name ) <EOL> @ classmethod <EOL> def _InstanceNICFile ( cls , instance_name , seq ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return utils . PathJoin ( cls . _InstanceNICDir ( instance_name ) , str ( seq ) ) <EOL> @ classmethod <EOL> def _InstanceKeymapFile ( cls , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return utils . PathJoin ( cls . _KEYMAP_DIR , instance_name ) <EOL> @ classmethod <EOL> def _TryReadUidFile ( cls , uid_file ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if os . path . exists ( uid_file ) : <EOL> try : <EOL> uid = int ( utils . ReadOneLineFile ( uid_file ) ) <EOL> return uid <EOL> except EnvironmentError : <EOL> logging . warning ( \"<STR_LIT>\" , exc_info = True ) <EOL> except ( TypeError , ValueError ) : <EOL> logging . warning ( \"<STR_LIT>\" , exc_info = True ) <EOL> return None <EOL> @ classmethod <EOL> def _RemoveInstanceRuntimeFiles ( cls , pidfile , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> utils . RemoveFile ( pidfile ) <EOL> utils . RemoveFile ( cls . _InstanceMonitor ( instance_name ) ) <EOL> utils . RemoveFile ( cls . _InstanceSerial ( instance_name ) ) <EOL> utils . RemoveFile ( cls . _InstanceQmpMonitor ( instance_name ) ) <EOL> utils . RemoveFile ( cls . _InstanceKVMRuntime ( instance_name ) ) <EOL> utils . RemoveFile ( cls . _InstanceKeymapFile ( instance_name ) ) <EOL> uid_file = cls . _InstanceUidFile ( instance_name ) <EOL> uid = cls . _TryReadUidFile ( uid_file ) <EOL> utils . RemoveFile ( uid_file ) <EOL> if uid is not None : <EOL> uidpool . ReleaseUid ( uid ) <EOL> try : <EOL> shutil . rmtree ( cls . _InstanceNICDir ( instance_name ) ) <EOL> except OSError , err : <EOL> if err . errno != errno . ENOENT : <EOL> raise <EOL> try : <EOL> chroot_dir = cls . _InstanceChrootDir ( instance_name ) <EOL> utils . RemoveDir ( chroot_dir ) <EOL> except OSError , err : <EOL> if err . errno == errno . ENOTEMPTY : <EOL> new_chroot_dir = tempfile . mkdtemp ( dir = cls . _CHROOT_QUARANTINE_DIR , <EOL> prefix = \"<STR_LIT>\" % <EOL> ( instance_name , <EOL> utils . TimestampForFilename ( ) ) ) <EOL> logging . warning ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> instance_name , new_chroot_dir ) <EOL> utils . RenameFile ( chroot_dir , new_chroot_dir ) <EOL> else : <EOL> raise <EOL> @ staticmethod <EOL> def _ConfigureNIC ( instance , seq , nic , tap ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> hv_base . ConfigureNIC ( [ pathutils . KVM_IFUP , tap ] , instance , seq , nic , tap ) <EOL> @ classmethod <EOL> def _SetProcessAffinity ( cls , process_id , cpus ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if psutil is None : <EOL> raise errors . HypervisorError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> target_process = psutil . Process ( process_id ) <EOL> if cpus == constants . CPU_PINNING_OFF : <EOL> target_process . set_cpu_affinity ( range ( psutil . cpu_count ( ) ) ) <EOL> else : <EOL> target_process . set_cpu_affinity ( cpus ) <EOL> for p in target_process . get_children ( recursive = True ) : <EOL> p . set_cpu_affinity ( cpus ) <EOL> @ classmethod <EOL> def _AssignCpuAffinity ( cls , cpu_mask , worker_cpu_mask , process_id , <EOL> thread_dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> worker_cpu_list = utils . ParseCpuMask ( worker_cpu_mask ) <EOL> cls . _SetProcessAffinity ( process_id , worker_cpu_list ) <EOL> cpu_list = utils . ParseMultiCpuMask ( cpu_mask ) <EOL> if len ( cpu_list ) == <NUM_LIT:1> : <EOL> all_cpu_mapping = cpu_list [ <NUM_LIT:0> ] <EOL> if all_cpu_mapping != constants . CPU_PINNING_OFF : <EOL> for vcpu in thread_dict : <EOL> cls . _SetProcessAffinity ( thread_dict [ vcpu ] , all_cpu_mapping ) <EOL> else : <EOL> assert len ( thread_dict ) == len ( cpu_list ) <EOL> for i , vcpu in enumerate ( cpu_list ) : <EOL> cls . _SetProcessAffinity ( thread_dict [ i ] , vcpu ) <EOL> def _GetVcpuThreadIds ( self , instance_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = { } <EOL> output = self . _CallMonitorCommand ( instance_name , self . _CPU_INFO_CMD ) <EOL> for line in output . stdout . splitlines ( ) : <EOL> match = self . _CPU_INFO_RE . search ( line ) <EOL> if not match : <EOL> continue <EOL> grp = map ( int , match . groups ( ) ) <EOL> result [ grp [ <NUM_LIT:0> ] ] = grp [ <NUM_LIT:1> ] <EOL> return result <EOL> def _ExecuteCpuAffinity ( self , instance_name , cpu_mask , worker_cpu_mask ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _ , pid , _ = self . _InstancePidAlive ( instance_name ) <EOL> thread_dict = self . _GetVcpuThreadIds ( instance_name ) <EOL> self . _AssignCpuAffinity ( cpu_mask , worker_cpu_mask , pid , thread_dict ) <EOL> def ListInstances ( self , hvparams = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = [ ] <EOL> for name in os . listdir ( self . _PIDS_DIR ) : <EOL> if self . _InstancePidAlive ( name ) [ <NUM_LIT:2> ] : <EOL> result . append ( name ) <EOL> return result <EOL> @ classmethod <EOL> def _IsUserShutdown ( cls , instance_name ) : <EOL> return os . path . exists ( cls . _InstanceShutdownMonitor ( instance_name ) ) <EOL> @ classmethod <EOL> def _ClearUserShutdown ( cls , instance_name ) : <EOL> utils . RemoveFile ( cls . _InstanceShutdownMonitor ( instance_name ) ) <EOL> def GetInstanceInfo ( self , instance_name , hvparams = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _ , pid , alive = self . _InstancePidAlive ( instance_name ) <EOL> if not alive : <EOL> if self . _IsUserShutdown ( instance_name ) : <EOL> return ( instance_name , - <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , hv_base . HvInstanceState . SHUTDOWN , <NUM_LIT:0> ) <EOL> else : <EOL> return None <EOL> _ , memory , vcpus = self . _InstancePidInfo ( pid ) <EOL> istat = hv_base . HvInstanceState . RUNNING <EOL> times = <NUM_LIT:0> <EOL> try : <EOL> qmp = QmpConnection ( self . _InstanceQmpMonitor ( instance_name ) ) <EOL> qmp . connect ( ) <EOL> vcpus = len ( qmp . Execute ( \"<STR_LIT>\" ) ) <EOL> mem_bytes = qmp . Execute ( \"<STR_LIT>\" ) [ qmp . ACTUAL_KEY ] <EOL> memory = mem_bytes / <NUM_LIT> <EOL> except errors . HypervisorError : <EOL> pass <EOL> return ( instance_name , pid , memory , vcpus , istat , times ) <EOL> def GetAllInstancesInfo ( self , hvparams = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> data = [ ] <EOL> for name in os . listdir ( self . _PIDS_DIR ) : <EOL> try : <EOL> info = self . GetInstanceInfo ( name ) <EOL> except errors . HypervisorError : <EOL> continue <EOL> if info : <EOL> data . append ( info ) <EOL> return data <EOL> def _GenerateKVMBlockDevicesOptions ( self , up_hvp , kvm_disks , <EOL> kvmhelp , devlist ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> kernel_path = up_hvp [ constants . HV_KERNEL_PATH ] <EOL> if kernel_path : <EOL> boot_disk = False <EOL> else : <EOL> boot_disk = up_hvp [ constants . HV_BOOT_ORDER ] == constants . HT_BO_DISK <EOL> needs_boot_flag = self . _BOOT_RE . search ( kvmhelp ) <EOL> dev_opts = [ ] <EOL> disk_type = up_hvp [ constants . HV_DISK_TYPE ] <EOL> if disk_type == constants . HT_DISK_PARAVIRTUAL : <EOL> driver = self . _VIRTIO_BLK_PCI <EOL> iface = self . _VIRTIO <EOL> else : <EOL> driver = iface = disk_type <EOL> if self . _DEVICE_DRIVER_SUPPORTED ( driver , devlist ) : <EOL> if_val = \"<STR_LIT>\" <EOL> device_driver = driver <EOL> else : <EOL> if_val = \"<STR_LIT>\" % iface <EOL> device_driver = None <EOL> aio_mode = up_hvp [ constants . HV_KVM_DISK_AIO ] <EOL> if aio_mode == constants . HT_KVM_AIO_NATIVE : <EOL> aio_val = \"<STR_LIT>\" % aio_mode <EOL> else : <EOL> aio_val = \"<STR_LIT>\" <EOL> disk_cache = up_hvp [ constants . HV_DISK_CACHE ] <EOL> for cfdev , link_name , uri in kvm_disks : <EOL> if cfdev . dev_type in constants . DTS_EXT_MIRROR : <EOL> if disk_cache != \"<STR_LIT:none>\" : <EOL> logging . warning ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> disk_cache ) <EOL> cache_val = \"<STR_LIT>\" <EOL> elif disk_cache != constants . HT_CACHE_DEFAULT : <EOL> cache_val = \"<STR_LIT>\" % disk_cache <EOL> else : <EOL> cache_val = \"<STR_LIT>\" <EOL> if cfdev . mode != constants . DISK_RDWR : <EOL> raise errors . HypervisorError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> boot_val = \"<STR_LIT>\" <EOL> if boot_disk : <EOL> dev_opts . extend ( [ \"<STR_LIT>\" , \"<STR_LIT:c>\" ] ) <EOL> boot_disk = False <EOL> if needs_boot_flag and disk_type != constants . HT_DISK_IDE : <EOL> boot_val = \"<STR_LIT>\" <EOL> drive_uri = _GetDriveURI ( cfdev , link_name , uri ) <EOL> drive_val = \"<STR_LIT>\" % ( drive_uri , if_val , boot_val , cache_val , aio_val ) <EOL> if device_driver is not None : <EOL> kvm_devid = cfdev . hvinfo [ \"<STR_LIT:id>\" ] <EOL> drive_val += \"<STR_LIT>\" % kvm_devid <EOL> dev_val = _GenerateDeviceHVInfoStr ( cfdev . hvinfo ) <EOL> dev_val += \"<STR_LIT>\" % kvm_devid <EOL> dev_opts . extend ( [ \"<STR_LIT>\" , dev_val ] ) <EOL> dev_opts . extend ( [ \"<STR_LIT>\" , drive_val ] ) <EOL> return dev_opts <EOL> @ staticmethod <EOL> def _CdromOption ( kvm_cmd , cdrom_disk_type , cdrom_image , cdrom_boot , <EOL> needs_boot_flag ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if utils . IsUrl ( cdrom_image ) and not _CheckUrl ( cdrom_image ) : <EOL> raise errors . HypervisorError ( \"<STR_LIT>\" % <EOL> cdrom_image ) <EOL> if utils . IsUrl ( cdrom_image ) : <EOL> options = \"<STR_LIT>\" <EOL> else : <EOL> options = \"<STR_LIT>\" <EOL> if cdrom_boot : <EOL> if_val = \"<STR_LIT>\" + constants . HT_DISK_IDE <EOL> elif cdrom_disk_type == constants . HT_DISK_PARAVIRTUAL : <EOL> if_val = \"<STR_LIT>\" <EOL> else : <EOL> if_val = \"<STR_LIT>\" + cdrom_disk_type <EOL> boot_val = \"<STR_LIT>\" <EOL> if cdrom_boot : <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , \"<STR_LIT:d>\" ] ) <EOL> if needs_boot_flag : <EOL> boot_val = \"<STR_LIT>\" <EOL> drive_val = \"<STR_LIT>\" % ( cdrom_image , options , if_val , boot_val ) <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , drive_val ] ) <EOL> def _GenerateKVMRuntime ( self , instance , block_devices , startup_paused , <EOL> kvmhelp ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> hvp = instance . hvparams <EOL> self . ValidateParameters ( hvp ) <EOL> pidfile = self . _InstancePidFile ( instance . name ) <EOL> kvm = hvp [ constants . HV_KVM_PATH ] <EOL> kvm_cmd = [ kvm ] <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , instance . name ] ) <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , instance . beparams [ constants . BE_MAXMEM ] ] ) <EOL> smp_list = [ \"<STR_LIT:%s>\" % instance . beparams [ constants . BE_VCPUS ] ] <EOL> if hvp [ constants . HV_CPU_CORES ] : <EOL> smp_list . append ( \"<STR_LIT>\" % hvp [ constants . HV_CPU_CORES ] ) <EOL> if hvp [ constants . HV_CPU_THREADS ] : <EOL> smp_list . append ( \"<STR_LIT>\" % hvp [ constants . HV_CPU_THREADS ] ) <EOL> if hvp [ constants . HV_CPU_SOCKETS ] : <EOL> smp_list . append ( \"<STR_LIT>\" % hvp [ constants . HV_CPU_SOCKETS ] ) <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , \"<STR_LIT:U+002C>\" . join ( smp_list ) ] ) <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , pidfile ] ) <EOL> bus_slots = self . _GetBusSlots ( hvp ) <EOL> if hvp [ constants . HV_SOUNDHW ] : <EOL> soundhw = hvp [ constants . HV_SOUNDHW ] <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , soundhw ] ) <EOL> if hvp [ constants . HV_DISK_TYPE ] in constants . HT_SCSI_DEVICE_TYPES : <EOL> kvm_cmd . extend ( [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" % hvp [ constants . HV_KVM_SCSI_CONTROLLER_TYPE ] <EOL> ] ) <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" ] ) <EOL> if not instance . hvparams [ constants . HV_ACPI ] : <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" ] ) <EOL> if instance . hvparams [ constants . HV_REBOOT_BEHAVIOR ] == constants . INSTANCE_REBOOT_EXIT : <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" ] ) <EOL> mversion = hvp [ constants . HV_KVM_MACHINE_VERSION ] <EOL> if not mversion : <EOL> mversion = self . _GetDefaultMachineVersion ( kvm ) <EOL> if self . _MACHINE_RE . search ( kvmhelp ) : <EOL> if ( hvp [ constants . HV_KVM_FLAG ] == constants . HT_KVM_ENABLED ) : <EOL> specprop = \"<STR_LIT>\" <EOL> else : <EOL> specprop = \"<STR_LIT>\" <EOL> machinespec = \"<STR_LIT>\" % ( mversion , specprop ) <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , machinespec ] ) <EOL> else : <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , mversion ] ) <EOL> if ( hvp [ constants . HV_KVM_FLAG ] == constants . HT_KVM_ENABLED and <EOL> self . _ENABLE_KVM_RE . search ( kvmhelp ) ) : <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" ] ) <EOL> elif ( hvp [ constants . HV_KVM_FLAG ] == constants . HT_KVM_DISABLED and <EOL> self . _DISABLE_KVM_RE . search ( kvmhelp ) ) : <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" ] ) <EOL> kernel_path = hvp [ constants . HV_KERNEL_PATH ] <EOL> if kernel_path : <EOL> boot_cdrom = boot_floppy = boot_network = False <EOL> else : <EOL> boot_cdrom = hvp [ constants . HV_BOOT_ORDER ] == constants . HT_BO_CDROM <EOL> boot_floppy = hvp [ constants . HV_BOOT_ORDER ] == constants . HT_BO_FLOPPY <EOL> boot_network = hvp [ constants . HV_BOOT_ORDER ] == constants . HT_BO_NETWORK <EOL> if startup_paused : <EOL> kvm_cmd . extend ( [ _KVM_START_PAUSED_FLAG ] ) <EOL> if boot_network : <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , \"<STR_LIT:n>\" ] ) <EOL> disk_type = hvp [ constants . HV_DISK_TYPE ] <EOL> cdrom_disk_type = hvp [ constants . HV_KVM_CDROM_DISK_TYPE ] <EOL> if not cdrom_disk_type : <EOL> cdrom_disk_type = disk_type <EOL> cdrom_image1 = hvp [ constants . HV_CDROM_IMAGE_PATH ] <EOL> if cdrom_image1 : <EOL> needs_boot_flag = self . _BOOT_RE . search ( kvmhelp ) <EOL> self . _CdromOption ( kvm_cmd , cdrom_disk_type , cdrom_image1 , boot_cdrom , <EOL> needs_boot_flag ) <EOL> cdrom_image2 = hvp [ constants . HV_KVM_CDROM2_IMAGE_PATH ] <EOL> if cdrom_image2 : <EOL> self . _CdromOption ( kvm_cmd , cdrom_disk_type , cdrom_image2 , False , False ) <EOL> floppy_image = hvp [ constants . HV_KVM_FLOPPY_IMAGE_PATH ] <EOL> if floppy_image : <EOL> options = \"<STR_LIT>\" <EOL> if boot_floppy : <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , \"<STR_LIT:a>\" ] ) <EOL> options = \"<STR_LIT>\" % options <EOL> if_val = \"<STR_LIT>\" <EOL> options = \"<STR_LIT>\" % ( options , if_val ) <EOL> drive_val = \"<STR_LIT>\" % ( floppy_image , options ) <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , drive_val ] ) <EOL> if kernel_path : <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , kernel_path ] ) <EOL> initrd_path = hvp [ constants . HV_INITRD_PATH ] <EOL> if initrd_path : <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , initrd_path ] ) <EOL> root_append = [ \"<STR_LIT>\" % hvp [ constants . HV_ROOT_PATH ] , <EOL> hvp [ constants . HV_KERNEL_ARGS ] ] <EOL> if hvp [ constants . HV_SERIAL_CONSOLE ] : <EOL> serial_speed = hvp [ constants . HV_SERIAL_SPEED ] <EOL> root_append . append ( \"<STR_LIT>\" % serial_speed ) <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , \"<STR_LIT:U+0020>\" . join ( root_append ) ] ) <EOL> mem_path = hvp [ constants . HV_MEM_PATH ] <EOL> if mem_path : <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , mem_path , \"<STR_LIT>\" ] ) <EOL> monitor_dev = ( \"<STR_LIT>\" % <EOL> self . _InstanceMonitor ( instance . name ) ) <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , monitor_dev ] ) <EOL> if hvp [ constants . HV_SERIAL_CONSOLE ] : <EOL> serial_dev = ( \"<STR_LIT>\" % <EOL> self . _InstanceSerial ( instance . name ) ) <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , serial_dev ] ) <EOL> else : <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , \"<STR_LIT:none>\" ] ) <EOL> mouse_type = hvp [ constants . HV_USB_MOUSE ] <EOL> vnc_bind_address = hvp [ constants . HV_VNC_BIND_ADDRESS ] <EOL> spice_bind = hvp [ constants . HV_KVM_SPICE_BIND ] <EOL> spice_ip_version = None <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" ] ) <EOL> if mouse_type : <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , mouse_type ] ) <EOL> elif vnc_bind_address : <EOL> kvm_cmd . extend ( [ \"<STR_LIT>\" , constants . HT_MOUSE_TABLET ] ) <EOL> if vnc_bind_address : <EOL> if netutils . IsValidInterface ( vnc_bind_address ) : <EOL> if_addresses = netutils . GetInterfaceIpAddresses ( vnc_bind_address ) <EOL> if_ip4_addresses = if_addresses [ constants . IP4_VERSION ] <EOL> if len ( if_ip4_addresses ) < <NUM_LIT:1> : <EOL> logging . error ( \"<STR_LIT>\" , <EOL> vnc_bind_address ) <EOL> else : <EOL> vnc_bind_address = if_ip4_addresses [ <NUM_LIT:0> ] <EOL> if netutils . IP4Address . IsValid ( vnc_bind_address ) : <EOL> if instance . network_port > constants . VNC_BASE_PORT : <EOL>", "answer": "display = instance . network_port - constants . VNC_BASE_PORT"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> from setuptools import setup <EOL> from setuptools import find_packages <EOL> except ImportError : <EOL> raise ImportError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> version = __import__ ( '<STR_LIT>' ) . __version__ <EOL> packages = find_packages ( where = \"<STR_LIT:.>\" , exclude = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , ) ) <EOL> requires = [ ] <EOL> with open ( '<STR_LIT>' , '<STR_LIT:r>' ) as reqfile : <EOL> for line in reqfile : <EOL> requires . append ( line . strip ( ) ) <EOL> classifiers = ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) <EOL> keywords = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> long_description = \"<STR_LIT>\" <EOL> config = { <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:version>\" : version , <EOL> \"<STR_LIT:description>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : long_description , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:url>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : '<STR_LIT>' % version , <EOL> \"<STR_LIT>\" : packages , <EOL> \"<STR_LIT>\" : requires , <EOL> \"<STR_LIT>\" : classifiers , <EOL> \"<STR_LIT>\" : keywords , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : [ ] , <EOL> } <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL>", "answer": "setup ( ** config ) "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Tangible ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import division <EOL> import numpy as np <EOL> from acoustics . standards . iso_tr_25417_2007 import ( REFERENCE_PRESSURE , <EOL> sound_pressure_level , <EOL> equivalent_sound_pressure_level , <EOL> peak_sound_pressure , <EOL> peak_sound_pressure_level , <EOL> REFERENCE_SOUND_EXPOSURE , <EOL> sound_exposure , <EOL> sound_exposure_level , <EOL> REFERENCE_POWER , <EOL> sound_power_level , <EOL> sound_energy , <EOL> REFERENCE_ENERGY , <EOL> sound_energy_level , <EOL> sound_intensity , <EOL> time_averaged_sound_intensity , <EOL> REFERENCE_INTENSITY , <EOL> time_averaged_sound_intensity_level , <EOL> normal_time_averaged_sound_intensity , <EOL> normal_time_averaged_sound_intensity_level , <EOL> ) <EOL> from acoustics . standards . iso_1996_1_2003 import composite_rating_level <EOL> def _leq ( levels , time ) : <EOL> levels = np . asarray ( levels ) <EOL> return <NUM_LIT> * np . log10 ( ( <NUM_LIT:1.0> / time ) * np . sum ( <NUM_LIT> ** ( levels / <NUM_LIT> ) ) ) <EOL> def leq ( levels , int_time = <NUM_LIT:1.0> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> levels = np . asarray ( levels ) <EOL>", "answer": "time = levels . size * int_time"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import requests <EOL>", "answer": "import json"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> from setuptools import setup , find_packages <EOL> def read ( fname ) : <EOL> return open ( os . path . join ( os . path . dirname ( __file__ ) , fname ) ) . read ( ) <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> description = '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> long_description = read ( '<STR_LIT>' ) , <EOL> packages = find_packages ( exclude = [ '<STR_LIT:test>' , '<STR_LIT>' ] ) , <EOL> keywords = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> url = '<STR_LIT>' , <EOL> license = '<STR_LIT>' , <EOL>", "answer": ") "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from errors import OperationError , TimeoutExpiredError , MissingCapabilityError <EOL> from rpc import RPC , RPCReply , RPCError , RaiseMode <EOL> from retrieve import Get , GetConfig , GetReply , Dispatch <EOL> from edit import EditConfig , CopyConfig , DeleteConfig , Validate , Commit , DiscardChanges <EOL> from session import CloseSession , KillSession <EOL> from lock import Lock , Unlock , LockContext <EOL> from flowmon import PoweroffMachine , RebootMachine <EOL> __all__ = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import time <EOL> import io <EOL> import threading <EOL> import picamera <EOL> class Camera ( object ) : <EOL> thread = None <EOL> frame = None <EOL> last_access = <NUM_LIT:0> <EOL> def initialize ( self ) : <EOL> if Camera . thread is None : <EOL> Camera . thread = threading . Thread ( target = self . _thread ) <EOL> Camera . thread . start ( ) <EOL> while self . frame is None : <EOL> time . sleep ( <NUM_LIT:0> ) <EOL> def get_frame ( self ) : <EOL> Camera . last_access = time . time ( ) <EOL> self . initialize ( ) <EOL> return self . frame <EOL> @ classmethod <EOL> def _thread ( cls ) : <EOL> with picamera . PiCamera ( ) as camera : <EOL> camera . resolution = ( <NUM_LIT> , <NUM_LIT> ) <EOL> camera . hflip = True <EOL> camera . vflip = True <EOL> camera . start_preview ( ) <EOL> time . sleep ( <NUM_LIT:2> ) <EOL> stream = io . BytesIO ( ) <EOL> for foo in camera . capture_continuous ( stream , '<STR_LIT>' , <EOL>", "answer": "use_video_port = True ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from cachebot . models import ManyModel <EOL> from cachebot . tests . base_tests import BasicCacheTests , RelatedCacheTests <EOL>", "answer": "class BasicManyToManyCacheTests ( BasicCacheTests ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . contrib . admin . decorators import register <EOL> from django . contrib . admin . filters import ( <EOL> AllValuesFieldListFilter , BooleanFieldListFilter , ChoicesFieldListFilter , <EOL> DateFieldListFilter , FieldListFilter , ListFilter , RelatedFieldListFilter , <EOL>", "answer": "RelatedOnlyFieldListFilter , SimpleListFilter ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . delete_column ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> db . add_column ( '<STR_LIT>' , '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = '<STR_LIT>' , max_length = <NUM_LIT:1000> , blank = True ) , keep_default = False ) <EOL> def backwards ( self , orm ) : <EOL> db . add_column ( '<STR_LIT>' , '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = '<STR_LIT>' , max_length = <NUM_LIT:1000> , unique = True , blank = True ) , keep_default = False ) <EOL> db . delete_column ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:password>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:username>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:date>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL>", "answer": "'<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL>", "answer": "from . . import __version__ as version"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import pytz <EOL> from django . utils . translation import ugettext as _ <EOL> from corehq . apps . reports . filters . base import BaseSingleOptionFilter <EOL> from custom . fri . models import PROFILE_A , PROFILE_B , PROFILE_C , PROFILE_D , PROFILE_E , PROFILE_F , PROFILE_G , PROFILE_H , PROFILE_DESC <EOL> from custom . fri . api import get_interactive_participants <EOL> from datetime import datetime , date , timedelta <EOL> from dimagi . utils . parsing import json_format_date <EOL> class InteractiveParticipantFilter ( BaseSingleOptionFilter ) : <EOL> slug = \"<STR_LIT>\" <EOL> label = _ ( \"<STR_LIT>\" ) <EOL> @ property <EOL> def options ( self ) : <EOL> cases = get_interactive_participants ( self . domain ) <EOL> return [ ( case . get_id , case . name ) for case in cases ] <EOL> class RiskProfileFilter ( BaseSingleOptionFilter ) : <EOL> slug = \"<STR_LIT>\" <EOL> label = _ ( \"<STR_LIT>\" ) <EOL> default_text = _ ( \"<STR_LIT>\" ) <EOL> @ property <EOL> def options ( self ) : <EOL> return [ <EOL> ( PROFILE_A , PROFILE_DESC [ PROFILE_A ] ) , <EOL> ( PROFILE_B , PROFILE_DESC [ PROFILE_B ] ) , <EOL> ( PROFILE_C , PROFILE_DESC [ PROFILE_C ] ) , <EOL> ( PROFILE_D , PROFILE_DESC [ PROFILE_D ] ) , <EOL> ( PROFILE_E , PROFILE_DESC [ PROFILE_E ] ) , <EOL> ( PROFILE_F , PROFILE_DESC [ PROFILE_F ] ) , <EOL> ( PROFILE_G , PROFILE_DESC [ PROFILE_G ] ) , <EOL> ( PROFILE_H , PROFILE_DESC [ PROFILE_H ] ) , <EOL> ] <EOL> class SurveyDateSelector ( BaseSingleOptionFilter ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> slug = \"<STR_LIT>\" <EOL> label = _ ( \"<STR_LIT>\" ) <EOL> default_text = _ ( \"<STR_LIT>\" ) <EOL> @ classmethod <EOL> def get_value ( cls , * args , ** kwargs ) : <EOL> default = json_format_date ( cls . get_date_choices ( ) [ - <NUM_LIT:1> ] ) <EOL> return super ( SurveyDateSelector , cls ) . get_value ( * args , ** kwargs ) or default <EOL> @ classmethod <EOL> def get_date_choices ( cls ) : <EOL> next_date = date ( <NUM_LIT> , <NUM_LIT:3> , <NUM_LIT> ) <EOL> last_date = pytz . utc . localize ( datetime . utcnow ( ) ) <EOL> last_date = last_date . astimezone ( pytz . timezone ( \"<STR_LIT>\" ) ) <EOL> last_date = last_date . date ( ) <EOL> dates = [ ] <EOL> while next_date <= last_date : <EOL> dates . append ( next_date ) <EOL>", "answer": "next_date += timedelta ( days = <NUM_LIT:7> )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import , division , print_function , unicode_literals <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> import demo <EOL> import pi3d <EOL> DISPLAY = pi3d . Display . create ( x = <NUM_LIT:100> , y = <NUM_LIT:100> ) <EOL> shader = pi3d . Shader ( \"<STR_LIT>\" ) <EOL> tex = pi3d . Texture ( \"<STR_LIT>\" ) <EOL> box = pi3d . Cuboid ( w = <NUM_LIT:100> , h = <NUM_LIT:100> , d = <NUM_LIT:100> , x = <NUM_LIT:0> , y = <NUM_LIT:0> , z = <NUM_LIT> ) <EOL> box . set_draw_details ( shader , [ tex ] ) <EOL> tm = <NUM_LIT:0.0> <EOL> dt = <NUM_LIT> <EOL> sc = <NUM_LIT:0.0> <EOL> ds = <NUM_LIT> <EOL> mykeys = pi3d . Keyboard ( ) <EOL> ASPECT = DISPLAY . width / DISPLAY . height <EOL> camera1 = pi3d . Camera ( ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ) , ( <NUM_LIT:0> , <NUM_LIT:0> , - <NUM_LIT:0.1> ) , ( <NUM_LIT:1> , <NUM_LIT:1000> , <NUM_LIT> , ASPECT ) , is_3d = True ) <EOL>", "answer": "camera2 = pi3d . Camera ( is_3d = False )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL> import logging <EOL> import redis <EOL> import time <EOL> from contextlib import contextmanager <EOL> from random import random <EOL> from . container import Container <EOL> class UnableToGetLock ( Exception ) : <EOL> pass <EOL> class _Redis ( object ) : <EOL> def __init__ ( self , app , options ) : <EOL> self . app = app <EOL> self . redis = redis . from_url ( app . config [ '<STR_LIT>' ] ) <EOL> self . logger = logging . getLogger ( app . name + '<STR_LIT>' ) <EOL> def __getattr__ ( self , name ) : <EOL>", "answer": "return getattr ( self . redis , name )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import six <EOL> from django . core . cache import cache <EOL> from django . core . exceptions import ImproperlyConfigured <EOL> from . conf import settings <EOL> class Device ( object ) : <EOL> def __init__ ( self , <EOL> width = settings . RESPONSIVE_DEFAULT_WIDTH , <EOL> height = settings . RESPONSIVE_DEFAULT_HEIGHT , <EOL> pixel_ratio = settings . RESPONSIVE_DEFAULT_PIXEL_RATIO ) : <EOL> self . width = int ( width ) <EOL> self . height = int ( height ) <EOL> self . pixel_ratio = float ( pixel_ratio ) <EOL> self . matched = [ ] <EOL> self . cache_key = '<STR_LIT>' % { <EOL> '<STR_LIT>' : settings . RESPONSIVE_CACHE_PREFIX , <EOL> '<STR_LIT:width>' : self . width , <EOL> '<STR_LIT>' : self . height , <EOL> '<STR_LIT>' : self . pixel_ratio <EOL> } <EOL> matches = cache . get ( self . cache_key , None ) <EOL> if not matches : <EOL> matches = self . match_media_queries ( ) <EOL> cache . set ( self . cache_key , matches , settings . RESPONSIVE_CACHE_DURATION ) <EOL> for name , value in six . iteritems ( matches ) : <EOL> setattr ( self , '<STR_LIT>' % name , value ) <EOL> if value is True : <EOL> self . matched . append ( name ) <EOL> def match_media_queries ( self ) : <EOL> matches = { } <EOL> media_queries = self . get_media_queries ( ) <EOL> for alias , config in six . iteritems ( media_queries ) : <EOL> yesno = [ ] <EOL> if config [ '<STR_LIT>' ] : <EOL> yesno . append ( self . width >= config [ '<STR_LIT>' ] ) <EOL> if config [ '<STR_LIT>' ] : <EOL> yesno . append ( self . width <= config [ '<STR_LIT>' ] ) <EOL> if config [ '<STR_LIT>' ] : <EOL> yesno . append ( self . height >= config [ '<STR_LIT>' ] ) <EOL> if config [ '<STR_LIT>' ] : <EOL> yesno . append ( self . height <= config [ '<STR_LIT>' ] ) <EOL> if config [ '<STR_LIT>' ] : <EOL> yesno . append ( self . pixel_ratio == config [ '<STR_LIT>' ] ) <EOL> matches [ alias ] = all ( yesno ) <EOL> return matches <EOL> @ staticmethod <EOL> def get_media_queries ( ) : <EOL> media_queries = settings . RESPONSIVE_MEDIA_QUERIES <EOL> for name , config in six . iteritems ( media_queries ) : <EOL> for attr in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if attr not in config : <EOL> config [ attr ] = None <EOL> elif config [ attr ] is not None : <EOL> try : <EOL> config [ attr ] = int ( config [ attr ] ) if attr != '<STR_LIT>' else float ( config [ attr ] ) <EOL> except ValueError : <EOL>", "answer": "raise ImproperlyConfigured ("}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import numpy as np <EOL> import theano <EOL> import theano . tensor as T <EOL> import lasagne as nn <EOL> import data <EOL> import load <EOL> import nn_plankton <EOL> import dihedral <EOL> import tmp_dnn <EOL> import tta <EOL> patch_sizes = [ ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) ] <EOL> augmentation_params = { <EOL> '<STR_LIT>' : ( <NUM_LIT:1> / <NUM_LIT> , <NUM_LIT> ) , <EOL> '<STR_LIT>' : ( <NUM_LIT:0> , <NUM_LIT> ) , <EOL> '<STR_LIT>' : ( - <NUM_LIT:20> , <NUM_LIT:20> ) , <EOL> '<STR_LIT>' : ( - <NUM_LIT:10> , <NUM_LIT:10> ) , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> batch_size = <NUM_LIT> // <NUM_LIT:4> <EOL> chunk_size = <NUM_LIT> // <NUM_LIT:4> <EOL> num_chunks_train = <NUM_LIT> <EOL> momentum = <NUM_LIT> <EOL> learning_rate_schedule = { <EOL> <NUM_LIT:0> : <NUM_LIT> , <EOL> <NUM_LIT> : <NUM_LIT> , <EOL> <NUM_LIT> : <NUM_LIT> , <EOL> } <EOL> validate_every = <NUM_LIT:20> <EOL> save_every = <NUM_LIT:20> <EOL> def estimate_scale ( img ) : <EOL> return np . maximum ( img . shape [ <NUM_LIT:0> ] , img . shape [ <NUM_LIT:1> ] ) / <NUM_LIT> <EOL> scale_factors = [ estimate_scale , <NUM_LIT> ] <EOL> augmentation_transforms_test = tta . build_quasirandom_transforms ( <NUM_LIT> , ** { <EOL> '<STR_LIT>' : ( <NUM_LIT:1> / <NUM_LIT> , <NUM_LIT> ) , <EOL> '<STR_LIT>' : ( <NUM_LIT:0> , <NUM_LIT> ) , <EOL> '<STR_LIT>' : ( - <NUM_LIT:10> , <NUM_LIT:10> ) , <EOL> '<STR_LIT>' : ( - <NUM_LIT:8> , <NUM_LIT:8> ) , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } ) <EOL> data_loader = load . ZmuvMultiscaleDataLoader ( scale_factors = scale_factors , num_chunks_train = num_chunks_train , <EOL> patch_sizes = patch_sizes , chunk_size = chunk_size , augmentation_params = augmentation_params , <EOL> augmentation_transforms_test = augmentation_transforms_test ) <EOL> Conv2DLayer = tmp_dnn . Conv2DDNNLayer <EOL> MaxPool2DLayer = tmp_dnn . MaxPool2DDNNLayer <EOL> def build_model ( ) : <EOL> l0_variable = nn . layers . InputLayer ( ( batch_size , <NUM_LIT:1> , patch_sizes [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] , patch_sizes [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ) ) <EOL> l0c = dihedral . CyclicSliceLayer ( l0_variable ) <EOL> l1a = Conv2DLayer ( l0c , num_filters = <NUM_LIT:32> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l1b = Conv2DLayer ( l1a , num_filters = <NUM_LIT:32> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l1 = MaxPool2DLayer ( l1b , ds = ( <NUM_LIT:3> , <NUM_LIT:3> ) , strides = ( <NUM_LIT:2> , <NUM_LIT:2> ) ) <EOL> l2a = Conv2DLayer ( l1 , num_filters = <NUM_LIT:64> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l2b = Conv2DLayer ( l2a , num_filters = <NUM_LIT:64> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l2 = MaxPool2DLayer ( l2b , ds = ( <NUM_LIT:3> , <NUM_LIT:3> ) , strides = ( <NUM_LIT:2> , <NUM_LIT:2> ) ) <EOL> l3a = Conv2DLayer ( l2 , num_filters = <NUM_LIT> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l3b = Conv2DLayer ( l3a , num_filters = <NUM_LIT> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l3c = Conv2DLayer ( l3b , num_filters = <NUM_LIT> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l3 = MaxPool2DLayer ( l3c , ds = ( <NUM_LIT:3> , <NUM_LIT:3> ) , strides = ( <NUM_LIT:2> , <NUM_LIT:2> ) ) <EOL> l4a = Conv2DLayer ( l3 , num_filters = <NUM_LIT> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l4b = Conv2DLayer ( l4a , num_filters = <NUM_LIT> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l4c = Conv2DLayer ( l4b , num_filters = <NUM_LIT> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l4 = MaxPool2DLayer ( l4c , ds = ( <NUM_LIT:3> , <NUM_LIT:3> ) , strides = ( <NUM_LIT:2> , <NUM_LIT:2> ) ) <EOL> l4f = nn . layers . flatten ( l4 ) <EOL> l5 = nn . layers . DenseLayer ( nn . layers . dropout ( l4f , p = <NUM_LIT:0.5> ) , num_units = <NUM_LIT> , W = nn_plankton . Orthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l5r = dihedral . CyclicRollLayer ( l5 ) <EOL> l6 = nn . layers . DenseLayer ( nn . layers . dropout ( l5r , p = <NUM_LIT:0.5> ) , num_units = <NUM_LIT> , W = nn_plankton . Orthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l_variable = dihedral . CyclicPoolLayer ( l6 , pool_function = nn_plankton . rms ) <EOL> l0_fixed = nn . layers . InputLayer ( ( batch_size , <NUM_LIT:1> , patch_sizes [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , patch_sizes [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] ) ) <EOL> l0c = dihedral . CyclicSliceLayer ( l0_fixed ) <EOL> l1a = Conv2DLayer ( l0c , num_filters = <NUM_LIT:16> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l1b = Conv2DLayer ( l1a , num_filters = <NUM_LIT:16> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l1 = MaxPool2DLayer ( l1b , ds = ( <NUM_LIT:3> , <NUM_LIT:3> ) , strides = ( <NUM_LIT:2> , <NUM_LIT:2> ) ) <EOL> l2a = Conv2DLayer ( l1 , num_filters = <NUM_LIT:32> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l2b = Conv2DLayer ( l2a , num_filters = <NUM_LIT:32> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l2 = MaxPool2DLayer ( l2b , ds = ( <NUM_LIT:3> , <NUM_LIT:3> ) , strides = ( <NUM_LIT:2> , <NUM_LIT:2> ) ) <EOL> l3a = Conv2DLayer ( l2 , num_filters = <NUM_LIT:64> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l3b = Conv2DLayer ( l3a , num_filters = <NUM_LIT:64> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l3c = Conv2DLayer ( l3b , num_filters = <NUM_LIT:64> , filter_size = ( <NUM_LIT:3> , <NUM_LIT:3> ) , border_mode = \"<STR_LIT>\" , W = nn_plankton . Conv2DOrthogonal ( <NUM_LIT:1.0> ) , b = nn . init . Constant ( <NUM_LIT:0.1> ) ) <EOL> l3 = MaxPool2DLayer ( l3c , ds = ( <NUM_LIT:3> , <NUM_LIT:3> ) , strides = ( <NUM_LIT:2> , <NUM_LIT:2> ) ) <EOL>", "answer": "l3f = nn . layers . flatten ( l3 )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from browser import window <EOL> import javascript <EOL> date = javascript . JSConstructor ( window . Date ) <EOL> _STRUCT_TM_ITEMS = <NUM_LIT:9> <EOL> def _get_day_of_year ( arg ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ml = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:30> , <NUM_LIT> , <NUM_LIT:30> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:30> , <NUM_LIT> , <NUM_LIT:30> , <NUM_LIT> ] <EOL> if arg [ <NUM_LIT:0> ] % <NUM_LIT:4> == <NUM_LIT:0> : <EOL> ml [ <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> i = <NUM_LIT:1> <EOL> yday = <NUM_LIT:0> <EOL> while i < arg [ <NUM_LIT:1> ] : <EOL> yday += ml [ i - <NUM_LIT:1> ] <EOL> i += <NUM_LIT:1> <EOL> yday += arg [ <NUM_LIT:2> ] <EOL> return yday <EOL> def _get_week_of_year ( arg ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> d1 = date ( arg [ <NUM_LIT:0> ] , arg [ <NUM_LIT:1> ] - <NUM_LIT:1> , arg [ <NUM_LIT:2> ] ) <EOL> d0 = date ( arg [ <NUM_LIT:0> ] , <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> firstday = d0 . getDay ( ) <EOL> if firstday == <NUM_LIT:0> : firstday = <NUM_LIT:7> <EOL> firstweek = <NUM_LIT:8> - firstday <EOL> doy = arg [ <NUM_LIT:7> ] <EOL> if firstday != <NUM_LIT:1> : <EOL> doy = doy - firstweek <EOL> if doy % <NUM_LIT:7> == <NUM_LIT:0> : <EOL> week_number = doy // <NUM_LIT:7> <EOL> else : <EOL> week_number = doy // <NUM_LIT:7> + <NUM_LIT:1> <EOL> return week_number <EOL> def _check_struct_time ( t ) : <EOL> mm = t [ <NUM_LIT:1> ] <EOL> if mm == <NUM_LIT:0> : mm = <NUM_LIT:1> <EOL> if - <NUM_LIT:1> > mm > <NUM_LIT> : raise ValueError ( \"<STR_LIT>\" ) <EOL> dd = t [ <NUM_LIT:2> ] <EOL> if dd == <NUM_LIT:0> : dd = <NUM_LIT:1> <EOL> if - <NUM_LIT:1> > dd > <NUM_LIT:32> : raise ValueError ( \"<STR_LIT>\" ) <EOL> hh = t [ <NUM_LIT:3> ] <EOL> if - <NUM_LIT:1> > hh > <NUM_LIT> : raise ValueError ( \"<STR_LIT>\" ) <EOL> minu = t [ <NUM_LIT:4> ] <EOL> if - <NUM_LIT:1> > minu > <NUM_LIT> : raise ValueError ( \"<STR_LIT>\" ) <EOL> ss = t [ <NUM_LIT:5> ] <EOL> if - <NUM_LIT:1> > ss > <NUM_LIT> : raise ValueError ( \"<STR_LIT>\" ) <EOL> wd = t [ <NUM_LIT:6> ] % <NUM_LIT:7> <EOL> if wd < - <NUM_LIT:2> : raise ValueError ( \"<STR_LIT>\" ) <EOL> dy = t [ <NUM_LIT:7> ] <EOL> if dy == <NUM_LIT:0> : dy = <NUM_LIT:1> <EOL> if - <NUM_LIT:1> > dy > <NUM_LIT> : raise ValueError ( \"<STR_LIT>\" ) <EOL> return t [ <NUM_LIT:0> ] , mm , dd , hh , minu , ss , wd , dy , t [ - <NUM_LIT:1> ] <EOL> def _is_dst ( secs = None ) : <EOL> \"<STR_LIT>\" <EOL> d = date ( ) <EOL> if secs is not None : <EOL> d = date ( secs * <NUM_LIT:1000> ) <EOL> jan = date ( d . getFullYear ( ) , <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> jul = date ( d . getFullYear ( ) , <NUM_LIT:6> , <NUM_LIT:1> ) <EOL> dst = int ( d . getTimezoneOffset ( ) < max ( abs ( jan . getTimezoneOffset ( ) ) , abs ( jul . getTimezoneOffset ( ) ) ) ) <EOL> return dst <EOL> def _get_tzname ( ) : <EOL> \"<STR_LIT>\" <EOL> d = date ( ) <EOL> d = d . toTimeString ( ) <EOL> try : <EOL> d = d . split ( '<STR_LIT:(>' ) [ <NUM_LIT:1> ] . split ( '<STR_LIT:)>' ) [ <NUM_LIT:0> ] <EOL> return ( d , '<STR_LIT>' ) <EOL> except : <EOL> return ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def _set_altzone ( ) : <EOL> d = date ( ) <EOL> jan = date ( d . getFullYear ( ) , <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> jul = date ( d . getFullYear ( ) , <NUM_LIT:6> , <NUM_LIT:1> ) <EOL> result = timezone - ( jan . getTimezoneOffset ( ) - jul . getTimezoneOffset ( ) ) * <NUM_LIT> <EOL> return result <EOL> def _check_input ( t ) : <EOL> if t and isinstance ( t , struct_time ) and len ( t . args ) == <NUM_LIT:9> : <EOL> t = t . args <EOL> elif t and isinstance ( t , tuple ) and len ( t ) == <NUM_LIT:9> : <EOL> t = t <EOL> elif t and isinstance ( t , struct_time ) and len ( t . args ) != <NUM_LIT:9> : <EOL> raise TypeError ( \"<STR_LIT>\" . format ( len ( t . args ) ) ) <EOL> elif t and isinstance ( t , tuple ) and len ( t ) != <NUM_LIT:9> : <EOL> raise TypeError ( \"<STR_LIT>\" . format ( len ( t . args ) ) ) <EOL> elif t and not isinstance ( t , ( tuple , struct_time ) ) : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> else : <EOL> t = localtime ( ) . args <EOL> return t <EOL> daylight = _is_dst ( ) <EOL> timezone = date ( ) . getTimezoneOffset ( ) * <NUM_LIT> <EOL> tzname = _get_tzname ( ) <EOL> altzone = _set_altzone ( ) if daylight else timezone <EOL> def asctime ( t = None ) : <EOL> weekdays = { <NUM_LIT:0> : \"<STR_LIT>\" , <NUM_LIT:1> : \"<STR_LIT>\" , <NUM_LIT:2> : \"<STR_LIT>\" , <NUM_LIT:3> : \"<STR_LIT>\" , <EOL> <NUM_LIT:4> : \"<STR_LIT>\" , <NUM_LIT:5> : \"<STR_LIT>\" , <NUM_LIT:6> : \"<STR_LIT>\" } <EOL> months = { <NUM_LIT:1> : '<STR_LIT>' , <NUM_LIT:2> : '<STR_LIT>' , <NUM_LIT:3> : '<STR_LIT>' , <NUM_LIT:4> : '<STR_LIT>' , <NUM_LIT:5> : '<STR_LIT>' , <NUM_LIT:6> : '<STR_LIT>' , <EOL> <NUM_LIT:7> : '<STR_LIT>' , <NUM_LIT:8> : '<STR_LIT>' , <NUM_LIT:9> : '<STR_LIT>' , <NUM_LIT:10> : '<STR_LIT>' , <NUM_LIT:11> : '<STR_LIT>' , <NUM_LIT:12> : '<STR_LIT>' } <EOL> t = _check_input ( t ) <EOL> t = _check_struct_time ( t ) <EOL> result = \"<STR_LIT>\" % ( <EOL> weekdays [ t [ <NUM_LIT:6> ] ] , months [ t [ <NUM_LIT:1> ] ] , t [ <NUM_LIT:2> ] , t [ <NUM_LIT:3> ] , t [ <NUM_LIT:4> ] , t [ <NUM_LIT:5> ] , t [ <NUM_LIT:0> ] ) <EOL> return result <EOL> def ctime ( timestamp = None ) : <EOL> if timestamp is None : <EOL> timestamp = date ( ) . getTime ( ) / <NUM_LIT> <EOL> d = date ( <NUM_LIT:0> ) <EOL> d . setUTCSeconds ( timestamp ) <EOL> jan = date ( d . getFullYear ( ) , <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> jul = date ( d . getFullYear ( ) , <NUM_LIT:6> , <NUM_LIT:1> ) <EOL> dst = int ( d . getTimezoneOffset ( ) < max ( jan . getTimezoneOffset ( ) , jul . getTimezoneOffset ( ) ) ) <EOL> d = date ( <NUM_LIT:0> ) <EOL> d . setUTCSeconds ( timestamp + ( <NUM_LIT:1> + dst ) * <NUM_LIT> ) <EOL>", "answer": "weekdays = { <NUM_LIT:1> : \"<STR_LIT>\" , <NUM_LIT:2> : \"<STR_LIT>\" , <NUM_LIT:3> : \"<STR_LIT>\" , <NUM_LIT:4> : \"<STR_LIT>\" ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . mfreadnam import parsenamefile <EOL> from . util_array import Util3d , Util2d , Transient2d , read1d <EOL> from . util_list import MfList <EOL>", "answer": "from . binaryfile import BinaryHeader , HeadFile , UcnFile , CellBudgetFile"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys , os <EOL>", "answer": "from _pwuid_cffi import ffi , lib"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import print_function , unicode_literals , absolute_import <EOL> class Event ( object ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , console , input ) : <EOL> pass <EOL> def __repr__ ( self ) : <EOL> '''<STR_LIT>''' <EOL> if self . type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> chr = self . char <EOL> if ord ( chr ) < ord ( \"<STR_LIT:A>\" ) : <EOL> chr = \"<STR_LIT:?>\" <EOL> s = \"<STR_LIT>\" % ( self . type , chr , ord ( self . char ) , self . keysym , self . keycode , self . keycode , <EOL> self . state , self . keyinfo ) <EOL> elif self . type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> s = '<STR_LIT>' % ( self . type , self . x , self . y , self . state ) <EOL> elif self . type == '<STR_LIT>' : <EOL> s = '<STR_LIT>' % ( self . type , self . width , self . height ) <EOL> elif self . type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL>", "answer": "s = self . type"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . core . management . base import BaseCommand <EOL> from ... models import set_cached_snippet , Snippet <EOL>", "answer": "class Command ( BaseCommand ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> import mimetypes <EOL> mimetypes . add_type ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> mimetypes . add_type ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> from zope . structuredtext import stx2html <EOL> from pyramid . response import Response <EOL> from pyramid . httpexceptions import HTTPFound <EOL> from pyramid . view import render_view_to_response <EOL> from pyramid . view import view_config <EOL> from virginia . models import File <EOL> from virginia . models import Directory <EOL> @ view_config ( context = File ) <EOL> def file_view ( context , request ) : <EOL> dirname , filename = os . path . split ( context . path ) <EOL> name , ext = os . path . splitext ( filename ) <EOL> result = render_view_to_response ( context , request , ext ) <EOL> return result <EOL> @ view_config ( context = Directory ) <EOL> def directory_view ( context , request ) : <EOL> path_info = request . environ [ '<STR_LIT>' ] <EOL> if not path_info . endswith ( '<STR_LIT:/>' ) : <EOL> response = HTTPFound ( location = path_info + '<STR_LIT:/>' ) <EOL> return response <EOL> defaults = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> for name in defaults : <EOL> try : <EOL> index = context [ name ] <EOL> except KeyError : <EOL>", "answer": "continue"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from mako import exceptions , ast , util , filters <EOL> import re <EOL> class Node ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , source , lineno , pos , filename ) : <EOL> self . source = source <EOL> self . lineno = lineno <EOL> self . pos = pos <EOL> self . filename = filename <EOL> @ property <EOL> def exception_kwargs ( self ) : <EOL> return { '<STR_LIT:source>' : self . source , '<STR_LIT>' : self . lineno , <EOL> '<STR_LIT>' : self . pos , '<STR_LIT:filename>' : self . filename } <EOL> def get_children ( self ) : <EOL> return [ ] <EOL> def accept_visitor ( self , visitor ) : <EOL> def traverse ( node ) : <EOL> for n in node . get_children ( ) : <EOL> n . accept_visitor ( visitor ) <EOL> method = getattr ( visitor , \"<STR_LIT>\" + self . __class__ . __name__ , traverse ) <EOL> method ( self ) <EOL> class TemplateNode ( Node ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , filename ) : <EOL> super ( TemplateNode , self ) . __init__ ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:0> , filename ) <EOL> self . nodes = [ ] <EOL> self . page_attributes = { } <EOL> def get_children ( self ) : <EOL> return self . nodes <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( <EOL> util . sorted_dict_repr ( self . page_attributes ) , <EOL> self . nodes ) <EOL> class ControlLine ( Node ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , keyword , isend , text , ** kwargs ) : <EOL> super ( ControlLine , self ) . __init__ ( ** kwargs ) <EOL> self . text = text <EOL> self . keyword = keyword <EOL> self . isend = isend <EOL> self . is_primary = keyword in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> if self . isend : <EOL> self . _declared_identifiers = [ ] <EOL> self . _undeclared_identifiers = [ ] <EOL> else : <EOL> code = ast . PythonFragment ( text , ** self . exception_kwargs ) <EOL> self . _declared_identifiers = code . declared_identifiers <EOL> self . _undeclared_identifiers = code . undeclared_identifiers <EOL> def declared_identifiers ( self ) : <EOL> return self . _declared_identifiers <EOL> def undeclared_identifiers ( self ) : <EOL> return self . _undeclared_identifiers <EOL> def is_ternary ( self , keyword ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return keyword in { <EOL> '<STR_LIT>' : set ( [ '<STR_LIT>' , '<STR_LIT>' ] ) , <EOL> '<STR_LIT>' : set ( [ '<STR_LIT>' , '<STR_LIT>' ] ) , <EOL> '<STR_LIT>' : set ( [ '<STR_LIT>' ] ) <EOL> } . get ( self . keyword , [ ] ) <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( <EOL> self . keyword , <EOL> self . text , <EOL> self . isend , <EOL> ( self . lineno , self . pos ) <EOL> ) <EOL> class Text ( Node ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , content , ** kwargs ) : <EOL> super ( Text , self ) . __init__ ( ** kwargs ) <EOL> self . content = content <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . content , ( self . lineno , self . pos ) ) <EOL> class Code ( Node ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , text , ismodule , ** kwargs ) : <EOL> super ( Code , self ) . __init__ ( ** kwargs ) <EOL> self . text = text <EOL> self . ismodule = ismodule <EOL> self . code = ast . PythonCode ( text , ** self . exception_kwargs ) <EOL> def declared_identifiers ( self ) : <EOL> return self . code . declared_identifiers <EOL> def undeclared_identifiers ( self ) : <EOL> return self . code . undeclared_identifiers <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( <EOL> self . text , <EOL> self . ismodule , <EOL> ( self . lineno , self . pos ) <EOL> ) <EOL> class Comment ( Node ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , text , ** kwargs ) : <EOL> super ( Comment , self ) . __init__ ( ** kwargs ) <EOL> self . text = text <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . text , ( self . lineno , self . pos ) ) <EOL> class Expression ( Node ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , text , escapes , ** kwargs ) : <EOL> super ( Expression , self ) . __init__ ( ** kwargs ) <EOL> self . text = text <EOL> self . escapes = escapes <EOL> self . escapes_code = ast . ArgumentList ( escapes , ** self . exception_kwargs ) <EOL> self . code = ast . PythonCode ( text , ** self . exception_kwargs ) <EOL> def declared_identifiers ( self ) : <EOL> return [ ] <EOL> def undeclared_identifiers ( self ) : <EOL> return self . code . undeclared_identifiers . union ( <EOL> self . escapes_code . undeclared_identifiers . difference ( <EOL> set ( filters . DEFAULT_ESCAPES . keys ( ) ) <EOL> ) <EOL> ) . difference ( self . code . declared_identifiers ) <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( <EOL> self . text , <EOL> self . escapes_code . args , <EOL> ( self . lineno , self . pos ) <EOL> ) <EOL> class _TagMeta ( type ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _classmap = { } <EOL> def __init__ ( cls , clsname , bases , dict ) : <EOL> if cls . __keyword__ is not None : <EOL> cls . _classmap [ cls . __keyword__ ] = cls <EOL> super ( _TagMeta , cls ) . __init__ ( clsname , bases , dict ) <EOL> def __call__ ( cls , keyword , attributes , ** kwargs ) : <EOL> if \"<STR_LIT::>\" in keyword : <EOL> ns , defname = keyword . split ( '<STR_LIT::>' ) <EOL> return type . __call__ ( CallNamespaceTag , ns , defname , <EOL> attributes , ** kwargs ) <EOL> try : <EOL> cls = _TagMeta . _classmap [ keyword ] <EOL> except KeyError : <EOL> raise exceptions . CompileException ( <EOL> \"<STR_LIT>\" % keyword , <EOL> source = kwargs [ '<STR_LIT:source>' ] , <EOL> lineno = kwargs [ '<STR_LIT>' ] , <EOL> pos = kwargs [ '<STR_LIT>' ] , <EOL> filename = kwargs [ '<STR_LIT:filename>' ] <EOL> ) <EOL> return type . __call__ ( cls , keyword , attributes , ** kwargs ) <EOL> class Tag ( Node ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import textwrap <EOL> import itertools <EOL> from ganeti . cli import * <EOL> from ganeti import constants <EOL> from ganeti import opcodes <EOL> from ganeti import utils <EOL> from ganeti import errors <EOL> from ganeti import objects <EOL> _LIST_DEF_FIELDS = [ \"<STR_LIT:name>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> def _HandleReservedIPs ( ips ) : <EOL> if ips is None : <EOL> return None <EOL> elif not ips : <EOL> return [ ] <EOL> else : <EOL> return utils . UnescapeAndSplit ( ips , sep = \"<STR_LIT:U+002C>\" ) <EOL> def AddNetwork ( opts , args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ( network_name , ) = args <EOL> if opts . network is None : <EOL> raise errors . OpPrereqError ( \"<STR_LIT>\" , <EOL> errors . ECODE_INVAL ) <EOL> if opts . tags is not None : <EOL> tags = opts . tags . split ( \"<STR_LIT:U+002C>\" ) <EOL> else : <EOL> tags = [ ] <EOL> reserved_ips = _HandleReservedIPs ( opts . add_reserved_ips ) <EOL> op = opcodes . OpNetworkAdd ( network_name = network_name , <EOL> gateway = opts . gateway , <EOL> network = opts . network , <EOL> gateway6 = opts . gateway6 , <EOL> network6 = opts . network6 , <EOL> mac_prefix = opts . mac_prefix , <EOL> add_reserved_ips = reserved_ips , <EOL> conflicts_check = opts . conflicts_check , <EOL> tags = tags ) <EOL> SubmitOrSend ( op , opts ) <EOL> def _GetDefaultGroups ( cl , groups ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if groups : <EOL> return groups <EOL> return list ( itertools . chain ( * cl . QueryGroups ( [ ] , [ \"<STR_LIT>\" ] , False ) ) ) <EOL> def ConnectNetwork ( opts , args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cl = GetClient ( ) <EOL> network = args [ <NUM_LIT:0> ] <EOL> nicparams = objects . FillDict ( constants . NICC_DEFAULTS , opts . nicparams ) <EOL> groups = _GetDefaultGroups ( cl , args [ <NUM_LIT:1> : ] ) <EOL> for group in groups : <EOL> op = opcodes . OpNetworkConnect ( group_name = group , <EOL> network_name = network , <EOL> network_mode = nicparams [ constants . NIC_MODE ] , <EOL> network_link = nicparams [ constants . NIC_LINK ] , <EOL> network_vlan = nicparams [ constants . NIC_VLAN ] , <EOL> conflicts_check = opts . conflicts_check ) <EOL> SubmitOpCode ( op , opts = opts , cl = cl ) <EOL> def DisconnectNetwork ( opts , args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cl = GetClient ( ) <EOL> ( network , ) = args [ : <NUM_LIT:1> ] <EOL> groups = _GetDefaultGroups ( cl , args [ <NUM_LIT:1> : ] ) <EOL> for group in groups : <EOL> op = opcodes . OpNetworkDisconnect ( group_name = group , <EOL> network_name = network ) <EOL> SubmitOpCode ( op , opts = opts , cl = cl ) <EOL> def ListNetworks ( opts , args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> desired_fields = ParseFields ( opts . output , _LIST_DEF_FIELDS ) <EOL> fmtoverride = { <EOL> \"<STR_LIT>\" : <EOL> ( lambda data : <EOL> utils . CommaJoin ( \"<STR_LIT>\" % ( name , mode , link , vlan ) <EOL> for ( name , mode , link , vlan ) in data ) , <EOL>", "answer": "False ) ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from datetime import datetime <EOL> from uuid import uuid4 <EOL> from googleads import adwords <EOL> from googleads import errors <EOL> FEED_NAME = '<STR_LIT>' % uuid4 ( ) <EOL> ADGROUPS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> def CreateAdsWithCustomizations ( client , adgroup_ids , feed_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> adgroup_ad_service = client . GetService ( '<STR_LIT>' ) <EOL> text_ad = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' % feed_name , <EOL> '<STR_LIT>' : '<STR_LIT>' % feed_name , <EOL> '<STR_LIT>' : '<STR_LIT>' % feed_name , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> operations = [ { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : adgroup , <EOL> '<STR_LIT>' : text_ad <EOL> } <EOL> } for adgroup in adgroup_ids ] <EOL> response = adgroup_ad_service . mutate ( operations ) <EOL> if response and '<STR_LIT:value>' in response : <EOL> for ad in response [ '<STR_LIT:value>' ] : <EOL> print ( '<STR_LIT>' <EOL> % ( ad [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] , ad [ '<STR_LIT>' ] [ '<STR_LIT>' ] , ad [ '<STR_LIT:status>' ] ) ) <EOL> else : <EOL> raise errors . GoogleAdsError ( '<STR_LIT>' ) <EOL> def CreateCustomizerFeed ( client , feed_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ad_customizer_feed_service = client . GetService ( '<STR_LIT>' ) <EOL> customizer_feed = { <EOL> '<STR_LIT>' : feed_name , <EOL> '<STR_LIT>' : [ <EOL> { '<STR_LIT:type>' : '<STR_LIT>' , '<STR_LIT:name>' : '<STR_LIT:Name>' } , <EOL> { '<STR_LIT:type>' : '<STR_LIT>' , '<STR_LIT:name>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:type>' : '<STR_LIT>' , '<STR_LIT:name>' : '<STR_LIT>' } <EOL> ] <EOL> } <EOL> feed_service_operation = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : customizer_feed <EOL> } <EOL> response = ad_customizer_feed_service . mutate ( [ feed_service_operation ] ) <EOL> if response and '<STR_LIT:value>' in response : <EOL> feed = response [ '<STR_LIT:value>' ] [ <NUM_LIT:0> ] <EOL> feed_data = { <EOL> '<STR_LIT>' : feed [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : feed [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:id>' ] , <EOL> '<STR_LIT>' : feed [ '<STR_LIT>' ] [ <NUM_LIT:1> ] [ '<STR_LIT:id>' ] , <EOL> '<STR_LIT>' : feed [ '<STR_LIT>' ] [ <NUM_LIT:2> ] [ '<STR_LIT:id>' ] <EOL> } <EOL> print ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) % ( feed [ '<STR_LIT>' ] , feed [ '<STR_LIT>' ] , feed_data [ '<STR_LIT>' ] , <EOL>", "answer": "feed_data [ '<STR_LIT>' ] , feed_data [ '<STR_LIT>' ] )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import hy <EOL> import imp <EOL> import sys <EOL>", "answer": "if len ( sys . argv ) > <NUM_LIT:1> :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import copy <EOL> from datetime import datetime <EOL> import time <EOL> from neutron_lib import constants <EOL> from oslo_config import cfg <EOL> from oslo_utils import uuidutils <EOL> from webob import exc <EOL> from neutron . api . v2 import attributes <EOL> from neutron . common import constants as n_const <EOL> from neutron import context <EOL> from neutron . db import agents_db <EOL> from neutron . db import db_base_plugin_v2 <EOL> from neutron . extensions import agent <EOL> from neutron . tests . common import helpers <EOL> from neutron . tests import tools <EOL> from neutron . tests . unit . api . v2 import test_base <EOL> from neutron . tests . unit . db import test_db_base_plugin_v2 <EOL> _uuid = uuidutils . generate_uuid <EOL> _get_path = test_base . _get_path <EOL> L3_HOSTA = '<STR_LIT>' <EOL> DHCP_HOSTA = '<STR_LIT>' <EOL> L3_HOSTB = '<STR_LIT>' <EOL> DHCP_HOSTC = '<STR_LIT>' <EOL> LBAAS_HOSTA = '<STR_LIT>' <EOL> LBAAS_HOSTB = '<STR_LIT>' <EOL> class AgentTestExtensionManager ( object ) : <EOL> def get_resources ( self ) : <EOL> attributes . RESOURCE_ATTRIBUTE_MAP . update ( <EOL> agent . RESOURCE_ATTRIBUTE_MAP ) <EOL> return agent . Agent . get_resources ( ) <EOL> def get_actions ( self ) : <EOL> return [ ] <EOL> def get_request_extensions ( self ) : <EOL> return [ ] <EOL> class TestAgentPlugin ( db_base_plugin_v2 . NeutronDbPluginV2 , <EOL> agents_db . AgentDbMixin ) : <EOL> supported_extension_aliases = [ \"<STR_LIT>\" ] <EOL> class AgentDBTestMixIn ( object ) : <EOL> def _list_agents ( self , expected_res_status = None , <EOL> neutron_context = None , <EOL> query_string = None ) : <EOL> agent_res = self . _list ( '<STR_LIT>' , <EOL> neutron_context = neutron_context , <EOL> query_params = query_string ) <EOL> if expected_res_status : <EOL> self . assertEqual ( expected_res_status , agent_res . status_int ) <EOL> return agent_res <EOL> def _register_agent_states ( self , lbaas_agents = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> l3_hosta = helpers . _get_l3_agent_dict ( <EOL> L3_HOSTA , n_const . L3_AGENT_MODE_LEGACY ) <EOL> l3_hostb = helpers . _get_l3_agent_dict ( <EOL> L3_HOSTB , n_const . L3_AGENT_MODE_LEGACY ) <EOL> dhcp_hosta = helpers . _get_dhcp_agent_dict ( DHCP_HOSTA ) <EOL> dhcp_hostc = helpers . _get_dhcp_agent_dict ( DHCP_HOSTC ) <EOL> helpers . register_l3_agent ( host = L3_HOSTA ) <EOL> helpers . register_l3_agent ( host = L3_HOSTB ) <EOL> helpers . register_dhcp_agent ( host = DHCP_HOSTA ) <EOL> helpers . register_dhcp_agent ( host = DHCP_HOSTC ) <EOL> res = [ l3_hosta , l3_hostb , dhcp_hosta , dhcp_hostc ] <EOL> if lbaas_agents : <EOL> lbaas_hosta = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:host>' : LBAAS_HOSTA , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { '<STR_LIT>' : [ '<STR_LIT>' ] } , <EOL> '<STR_LIT>' : constants . AGENT_TYPE_LOADBALANCER } <EOL> lbaas_hostb = copy . deepcopy ( lbaas_hosta ) <EOL> lbaas_hostb [ '<STR_LIT:host>' ] = LBAAS_HOSTB <EOL> callback = agents_db . AgentExtRpcCallback ( ) <EOL> callback . report_state ( <EOL> self . adminContext , <EOL> agent_state = { '<STR_LIT>' : lbaas_hosta } , <EOL> time = datetime . utcnow ( ) . strftime ( constants . ISO8601_TIME_FORMAT ) ) <EOL> callback . report_state ( <EOL> self . adminContext , <EOL> agent_state = { '<STR_LIT>' : lbaas_hostb } , <EOL> time = datetime . utcnow ( ) . strftime ( constants . ISO8601_TIME_FORMAT ) ) <EOL> res += [ lbaas_hosta , lbaas_hostb ] <EOL> return res <EOL> def _register_dvr_agents ( self ) : <EOL> dvr_snat_agent = helpers . register_l3_agent ( <EOL> host = L3_HOSTA , agent_mode = n_const . L3_AGENT_MODE_DVR_SNAT ) <EOL> dvr_agent = helpers . register_l3_agent ( <EOL> host = L3_HOSTB , agent_mode = n_const . L3_AGENT_MODE_DVR ) <EOL> return [ dvr_snat_agent , dvr_agent ] <EOL> def _register_l3_agent ( self , host ) : <EOL> helpers . register_l3_agent ( host ) <EOL> class AgentDBTestCase ( AgentDBTestMixIn , <EOL> test_db_base_plugin_v2 . NeutronDbPluginV2TestCase ) : <EOL> fmt = '<STR_LIT>' <EOL> def setUp ( self ) : <EOL> plugin = '<STR_LIT>' <EOL> cfg . CONF . set_default ( '<STR_LIT>' , True ) <EOL> self . useFixture ( tools . AttributeMapMemento ( ) ) <EOL> ext_mgr = AgentTestExtensionManager ( ) <EOL> super ( AgentDBTestCase , self ) . setUp ( plugin = plugin , ext_mgr = ext_mgr ) <EOL> self . adminContext = context . get_admin_context ( ) <EOL> def test_create_agent ( self ) : <EOL> data = { '<STR_LIT>' : { } } <EOL> _req = self . new_create_request ( '<STR_LIT>' , data , self . fmt ) <EOL> _req . environ [ '<STR_LIT>' ] = context . Context ( <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> res = _req . get_response ( self . ext_api ) <EOL> self . assertEqual ( exc . HTTPBadRequest . code , res . status_int ) <EOL> def test_list_agent ( self ) : <EOL> agents = self . _register_agent_states ( ) <EOL> res = self . _list ( '<STR_LIT>' ) <EOL> self . assertEqual ( len ( agents ) , len ( res [ '<STR_LIT>' ] ) ) <EOL> def test_show_agent ( self ) : <EOL> self . _register_agent_states ( ) <EOL> agents = self . _list_agents ( <EOL> query_string = '<STR_LIT>' ) <EOL> self . assertEqual ( <NUM_LIT:2> , len ( agents [ '<STR_LIT>' ] ) ) <EOL> agent = self . _show ( '<STR_LIT>' , agents [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:id>' ] ) <EOL> self . assertEqual ( '<STR_LIT>' , agent [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL>", "answer": "def test_update_agent ( self ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from telegrambot . bot_views . generic . base import TemplateCommandView <EOL> from django . core . exceptions import ImproperlyConfigured , ObjectDoesNotExist , FieldError <EOL> class DetailCommandView ( TemplateCommandView ) : <EOL> model = None <EOL> queryset = None <EOL> context_object_name = None <EOL> slug_field = '<STR_LIT>' <EOL> def __init__ ( self , slug = None ) : <EOL> self . slug = slug <EOL> def get_slug_field ( self , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . slug_field <EOL> def get_queryset ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . queryset is None : <EOL> if self . model : <EOL> return self . model . _default_manager . all ( ) <EOL> else : <EOL> raise ImproperlyConfigured ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % { <EOL> '<STR_LIT>' : self . __class__ . __name__ <EOL> } <EOL> ) <EOL> return self . queryset . all ( ) <EOL> def get_slug ( self , ** kwargs ) : <EOL> return self . slug <EOL> def get_context ( self , bot , update , ** kwargs ) : <EOL> queryset = self . get_queryset ( ) <EOL> if not self . slug_field : <EOL> raise AttributeError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> % self . __class__ . __name__ ) <EOL> slug_field = self . get_slug_field ( ** kwargs ) <EOL> slug = self . get_slug ( ** kwargs ) <EOL> if slug : <EOL> try : <EOL> object = queryset . get ( ** { slug_field : slug } ) <EOL> except FieldError : <EOL> raise FieldError ( \"<STR_LIT>\" % slug_field ) <EOL> except ObjectDoesNotExist : <EOL> object = None <EOL> else : <EOL> object = None <EOL> context = { '<STR_LIT>' : object } <EOL> if self . context_object_name : <EOL> context [ self . context_object_name ] = object <EOL>", "answer": "return context "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import pickle <EOL> from cStringIO import StringIO <EOL> from test import test_support <EOL> from test . pickletester import ( AbstractPickleTests , <EOL> AbstractPickleModuleTests , <EOL> AbstractPersistentPicklerTests , <EOL> AbstractPicklerUnpicklerObjectTests , <EOL> BigmemPickleTests ) <EOL> class PickleTests ( AbstractPickleTests , AbstractPickleModuleTests ) : <EOL> def dumps ( self , arg , proto = <NUM_LIT:0> , fast = <NUM_LIT:0> ) : <EOL> return pickle . dumps ( arg , proto ) <EOL> def loads ( self , buf ) : <EOL> return pickle . loads ( buf ) <EOL> module = pickle <EOL> error = KeyError <EOL> class PicklerTests ( AbstractPickleTests ) : <EOL>", "answer": "error = KeyError"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> try : <EOL> import asyncio <EOL> except ImportError : <EOL> import trollius as asyncio <EOL> from acouchbase . asyncio_iops import IOPS <EOL> from acouchbase . iterator import AView , AN1QLRequest <EOL> from couchbase . async . bucket import AsyncBucket <EOL> from couchbase . experimental import enabled_or_raise ; enabled_or_raise ( ) <EOL> class Bucket ( AsyncBucket ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> loop = asyncio . get_event_loop ( ) <EOL> super ( Bucket , self ) . __init__ ( IOPS ( loop ) , * args , ** kwargs ) <EOL> self . _loop = loop <EOL> cft = asyncio . Future ( loop = loop ) <EOL> def ftresult ( err ) : <EOL> if err : <EOL> cft . set_exception ( err ) <EOL> else : <EOL> cft . set_result ( True ) <EOL> self . _cft = cft <EOL> self . _conncb = ftresult <EOL> def _meth_factory ( meth , name ) : <EOL> def ret ( self , * args , ** kwargs ) : <EOL> rv = meth ( self , * args , ** kwargs ) <EOL> ft = asyncio . Future ( ) <EOL> def on_ok ( res ) : <EOL> ft . set_result ( res ) <EOL> rv . clear_callbacks ( ) <EOL> def on_err ( res , excls , excval , exctb ) : <EOL> err = excls ( excval ) <EOL> ft . set_exception ( err ) <EOL> rv . clear_callbacks ( ) <EOL> rv . set_callbacks ( on_ok , on_err ) <EOL> return ft <EOL> return ret <EOL> def query ( self , * args , ** kwargs ) : <EOL>", "answer": "if \"<STR_LIT>\" not in kwargs :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> import StringIO <EOL> USER_AGENT = '<STR_LIT>' <EOL> class Error ( Exception ) : <EOL> pass <EOL> class UnparsableUrlObject ( Error ) : <EOL> pass <EOL> class ContentLengthRequired ( Error ) : <EOL> pass <EOL> class HttpResponse ( object ) : <EOL> def __init__ ( self , body = None , status = None , reason = None , headers = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if body : <EOL> if hasattr ( body , '<STR_LIT>' ) : <EOL> self . _body = body <EOL> else : <EOL> self . _body = StringIO . StringIO ( body ) <EOL> else : <EOL> self . _body = None <EOL> if status is not None : <EOL> self . status = int ( status ) <EOL> else : <EOL> self . status = None <EOL> self . reason = reason <EOL> self . _headers = headers or { } <EOL> def getheader ( self , name , default = None ) : <EOL> if name in self . _headers : <EOL> return self . _headers [ name ] <EOL>", "answer": "else :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import binascii <EOL> import json <EOL> import os <EOL> from Crypto . Cipher import AES <EOL> from keen import Padding <EOL> __author__ = '<STR_LIT>' <EOL> OLD_BLOCK_SIZE = <NUM_LIT:32> <EOL> def pad_aes256 ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( s ) % AES . block_size == <NUM_LIT:0> : <EOL> return s <EOL> return Padding . appendPadding ( s , blocksize = AES . block_size ) <EOL> def unpad_aes256 ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not s : <EOL> return s <EOL> try : <EOL> return Padding . removePadding ( s , blocksize = AES . block_size ) <EOL> except AssertionError : <EOL> return s <EOL> def old_pad ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( s ) % OLD_BLOCK_SIZE == <NUM_LIT:0> : <EOL> return s <EOL> return Padding . appendPadding ( s , blocksize = OLD_BLOCK_SIZE ) <EOL> def old_unpad ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not s : <EOL> return s <EOL> try : <EOL> return Padding . removePadding ( s , blocksize = OLD_BLOCK_SIZE ) <EOL> except AssertionError : <EOL> return s <EOL> def encode_aes256 ( key , plaintext ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( key ) != <NUM_LIT:64> : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> iv = os . urandom ( AES . block_size ) <EOL> cipher = AES . new ( binascii . unhexlify ( key . encode ( '<STR_LIT:ascii>' ) ) , mode = AES . MODE_CBC , IV = iv ) <EOL> ciphertext = cipher . encrypt ( pad_aes256 ( plaintext ) ) <EOL>", "answer": "iv_plus_encrypted = binascii . hexlify ( iv ) + binascii . hexlify ( ciphertext )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import random <EOL> import threading <EOL> from oslo_utils import reflection <EOL> from oslo_utils import timeutils <EOL> import six <EOL> from taskflow . engines . worker_based import protocol as pr <EOL> from taskflow import logging <EOL> from taskflow . utils import kombu_utils as ku <EOL> LOG = logging . getLogger ( __name__ ) <EOL> class TopicWorker ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _NO_IDENTITY = object ( ) <EOL> def __init__ ( self , topic , tasks , identity = _NO_IDENTITY ) : <EOL> self . tasks = [ ] <EOL> for task in tasks : <EOL> if not isinstance ( task , six . string_types ) : <EOL> task = reflection . get_class_name ( task ) <EOL> self . tasks . append ( task ) <EOL> self . topic = topic <EOL> self . identity = identity <EOL> self . last_seen = None <EOL> def performs ( self , task ) : <EOL> if not isinstance ( task , six . string_types ) : <EOL> task = reflection . get_class_name ( task ) <EOL> return task in self . tasks <EOL> def __eq__ ( self , other ) : <EOL> if not isinstance ( other , TopicWorker ) : <EOL> return NotImplemented <EOL> if len ( other . tasks ) != len ( self . tasks ) : <EOL> return False <EOL> if other . topic != self . topic : <EOL> return False <EOL> for task in other . tasks : <EOL> if not self . performs ( task ) : <EOL> return False <EOL> if self . _NO_IDENTITY in ( self . identity , other . identity ) : <EOL> return True <EOL> else : <EOL> return other . identity == self . identity <EOL> def __repr__ ( self ) : <EOL> r = reflection . get_class_name ( self , fully_qualified = False ) <EOL> if self . identity is not self . _NO_IDENTITY : <EOL> r += \"<STR_LIT>\" % ( self . identity , <EOL> self . tasks , self . topic ) <EOL> else : <EOL> r += \"<STR_LIT>\" % ( self . tasks , self . topic ) <EOL> return r <EOL> class ProxyWorkerFinder ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , uuid , proxy , topics , <EOL> beat_periodicity = pr . NOTIFY_PERIOD , <EOL> worker_expiry = pr . EXPIRES_AFTER ) : <EOL> self . _cond = threading . Condition ( ) <EOL> self . _proxy = proxy <EOL> self . _topics = topics <EOL> self . _workers = { } <EOL> self . _uuid = uuid <EOL> self . _seen_workers = <NUM_LIT:0> <EOL> self . _messages_processed = <NUM_LIT:0> <EOL> self . _messages_published = <NUM_LIT:0> <EOL> self . _worker_expiry = worker_expiry <EOL> self . _watch = timeutils . StopWatch ( duration = beat_periodicity ) <EOL> @ property <EOL> def total_workers ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return len ( self . _workers ) <EOL> def wait_for_workers ( self , workers = <NUM_LIT:1> , timeout = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if workers <= <NUM_LIT:0> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> watch = timeutils . StopWatch ( duration = timeout ) <EOL> watch . start ( ) <EOL> with self . _cond : <EOL> while self . total_workers < workers : <EOL> if watch . expired ( ) : <EOL> return max ( <NUM_LIT:0> , workers - self . total_workers ) <EOL> self . _cond . wait ( watch . leftover ( return_none = True ) ) <EOL> return <NUM_LIT:0> <EOL> @ staticmethod <EOL> def _match_worker ( task , available_workers ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( available_workers ) == <NUM_LIT:1> : <EOL> return available_workers [ <NUM_LIT:0> ] <EOL> else : <EOL> return random . choice ( available_workers ) <EOL> @ property <EOL> def messages_processed ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _messages_processed <EOL> def _next_worker ( self , topic , tasks , temporary = False ) : <EOL> if not temporary : <EOL> w = TopicWorker ( topic , tasks , identity = self . _seen_workers ) <EOL> self . _seen_workers += <NUM_LIT:1> <EOL> return w <EOL> else : <EOL> return TopicWorker ( topic , tasks ) <EOL> def maybe_publish ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _messages_published == <NUM_LIT:0> : <EOL> self . _proxy . publish ( pr . Notify ( ) , <EOL> self . _topics , reply_to = self . _uuid ) <EOL>", "answer": "self . _messages_published += <NUM_LIT:1>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from netaddr import IPAddress , IPNetwork <EOL> def test_ip_v4_to_ipv6_mapped ( ) : <EOL> ip = IPAddress ( '<STR_LIT>' ) . ipv6 ( ) <EOL> assert ip == IPAddress ( '<STR_LIT>' ) <EOL> assert ip . is_ipv4_mapped ( ) <EOL> assert not ip . is_ipv4_compat ( ) <EOL> def test_ip_v4_to_ipv4 ( ) : <EOL> assert IPAddress ( '<STR_LIT>' ) . ipv4 ( ) == IPAddress ( '<STR_LIT>' ) <EOL> def test_ip_v4_to_ipv6_compatible ( ) : <EOL>", "answer": "assert IPAddress ( '<STR_LIT>' ) . ipv6 ( ipv4_compatible = True ) == IPAddress ( '<STR_LIT>' )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys <EOL> from itertools import ifilter , izip <EOL> from functools import partial <EOL> from operator import itemgetter <EOL> import numpy as np <EOL> from nucio import fileIterator , lineItemIterator <EOL> MAPQ_THRESH = <NUM_LIT:30> <EOL> name = itemgetter ( <NUM_LIT:0> ) <EOL> seq = itemgetter ( <NUM_LIT:2> ) <EOL> qual = itemgetter ( <NUM_LIT:3> ) <EOL> status = itemgetter ( <NUM_LIT:4> ) <EOL> ascore = itemgetter ( <NUM_LIT:5> ) <EOL> aqual = lambda r : int ( itemgetter ( <NUM_LIT:6> ) ( r ) ) <EOL> ref = itemgetter ( <NUM_LIT:7> ) <EOL> pos = lambda r : int ( itemgetter ( <NUM_LIT:8> ) ( r ) ) <EOL> strand = itemgetter ( <NUM_LIT:9> ) <EOL> if not len ( sys . argv ) == <NUM_LIT:3> : <EOL> sys . exit ( \"<STR_LIT>\" ) <EOL> names_eq = lambda name1 , name2 : name1 . split ( \"<STR_LIT:/>\" ) [ <NUM_LIT:0> ] == name2 . split ( \"<STR_LIT:/>\" ) [ <NUM_LIT:0> ] <EOL> filenames = sys . argv [ <NUM_LIT:1> : <NUM_LIT:3> ] <EOL> headfilt = lambda x : not x . startswith ( \"<STR_LIT:#>\" ) <EOL> filt_lii = partial ( lineItemIterator , filter_func = headfilt ) <EOL> filt_fits = map ( lambda fn : fileIterator ( fn , filt_lii ) , filenames ) <EOL> failrepeat = <NUM_LIT:0> <EOL> failmapq = <NUM_LIT:0> <EOL> failsameref = <NUM_LIT:0> <EOL> total = <NUM_LIT:0> <EOL> passed = <NUM_LIT:0> <EOL> insertNotRF = [ ] <EOL> insertRF = [ ] <EOL> for read1 , read2 in izip ( * filt_fits ) : <EOL> total += <NUM_LIT:1> <EOL> if not names_eq ( name ( read1 ) , name ( read2 ) ) : <EOL> sys . exit ( \"<STR_LIT>\" % ( name ( read1 ) , name ( read2 ) ) ) <EOL> if not status ( read1 ) == \"<STR_LIT>\" or not status ( read2 ) == \"<STR_LIT>\" : <EOL> failrepeat += <NUM_LIT:1> <EOL> continue <EOL> if not aqual ( read1 ) >= MAPQ_THRESH or not aqual ( read2 ) >= MAPQ_THRESH : <EOL> failmapq += <NUM_LIT:1> <EOL> continue <EOL> if ref ( read1 ) == ref ( read2 ) : <EOL> failsameref += <NUM_LIT:1> <EOL> if not ( strand ( read1 ) == \"<STR_LIT:R>\" and strand ( read2 ) == \"<STR_LIT:F>\" ) : <EOL> insertNotRF . append ( pos ( read2 ) - pos ( read1 ) ) <EOL> else : <EOL> insertRF . append ( pos ( read2 ) - pos ( read1 ) ) <EOL> continue <EOL> print \"<STR_LIT:\\n>\" . join ( map ( \"<STR_LIT:\\t>\" . join , [ read1 , read2 ] ) ) <EOL> passed += <NUM_LIT:1> <EOL> with open ( \"<STR_LIT>\" , \"<STR_LIT:w>\" ) as ofh : <EOL> ofh . write ( \"<STR_LIT>\" ) <EOL> ofh . write ( \"<STR_LIT>\" % failrepeat ) <EOL> ofh . write ( \"<STR_LIT>\" % ( MAPQ_THRESH , failmapq ) ) <EOL> ofh . write ( \"<STR_LIT>\" % failsameref ) <EOL> ofh . write ( \"<STR_LIT>\" % ( passed , total , float ( passed ) / total ) ) <EOL> ofh . write ( \"<STR_LIT>\" ) <EOL> h = np . histogram ( insertNotRF , bins = <NUM_LIT:1000> ) <EOL> for v , b in zip ( * h ) : <EOL> ofh . write ( \"<STR_LIT>\" % ( b , v ) ) <EOL> ofh . write ( \"<STR_LIT>\" ) <EOL>", "answer": "ofh . write ( \"<STR_LIT>\" )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys <EOL> try : <EOL> from gevent import monkey <EOL> monkey . patch_all ( ) <EOL> except ImportError : <EOL> sys . exit ( '<STR_LIT>' ) <EOL> import os <EOL> import time <EOL> import datetime <EOL> import logging <EOL> from logging . config import fileConfig <EOL> from optparse import make_option <EOL> from psycopg2 . pool import ThreadedConnectionPool <EOL> import gevent <EOL> from django . core . management . base import BaseCommand <EOL> from django . conf import settings <EOL> from utils . pid import Pid <EOL> from crawler import tasks <EOL> from crawler import auth <EOL> from mturk . main . models import Crawl , RequesterProfile <EOL> log = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> option_list = BaseCommand . option_list + ( <EOL> make_option ( '<STR_LIT>' , dest = '<STR_LIT>' , type = '<STR_LIT:int>' , default = <NUM_LIT:3> , <EOL> help = '<STR_LIT>' ) , <EOL> make_option ( '<STR_LIT>' , dest = '<STR_LIT>' , metavar = '<STR_LIT>' , <EOL> help = '<STR_LIT>' ) , <EOL> make_option ( '<STR_LIT>' , dest = '<STR_LIT>' , action = '<STR_LIT:store_true>' , <EOL> help = '<STR_LIT>' ) , <EOL> make_option ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> help = '<STR_LIT>' ) , <EOL> make_option ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> help = '<STR_LIT>' ) , <EOL> ) <EOL> def setup_logging ( self , conf_fname ) : <EOL> \"<STR_LIT>\" <EOL> fileConfig ( conf_fname ) <EOL> if not os . path . isfile ( conf_fname ) : <EOL> raise IOError ( '<STR_LIT>' % conf_fname ) <EOL> log . info ( '<STR_LIT>' , conf_fname ) <EOL> def setup_debug ( self ) : <EOL> from crawler . debug import debug_listen <EOL>", "answer": "debug_listen ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Intangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL> class Migration ( migrations . Migration ) : <EOL>", "answer": "dependencies = ["}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Intangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import json <EOL> import pymongo <EOL> from flask import request , abort , json <EOL> from flask . ext import restful <EOL> from flask . ext . restful import reqparse <EOL> from flask_rest_service import app , api , mongo <EOL> from bson . objectid import ObjectId <EOL> from bson . code import Code <EOL> class ProductsList ( restful . Resource ) : <EOL> def get ( self ) : <EOL> limit = request . args . get ( '<STR_LIT>' , default = <NUM_LIT:50> , type = int ) <EOL> skip = request . args . get ( '<STR_LIT>' , default = <NUM_LIT:0> , type = int ) <EOL> count = request . args . get ( '<STR_LIT:count>' , default = <NUM_LIT:0> , type = int ) <EOL> short = request . args . get ( '<STR_LIT>' , default = <NUM_LIT:0> , type = int ) <EOL> query = request . args . get ( '<STR_LIT:q>' ) <EOL> data = dict ( ( key , { '<STR_LIT>' : request . args . get ( key ) , '<STR_LIT>' : '<STR_LIT>' } ) for key in request . args . keys ( ) ) <EOL> if request . args . get ( '<STR_LIT>' ) : <EOL> del data [ '<STR_LIT>' ] <EOL> if request . args . get ( '<STR_LIT>' ) : <EOL> del data [ '<STR_LIT>' ] <EOL> if request . args . get ( '<STR_LIT:count>' ) : <EOL> del data [ '<STR_LIT:count>' ] <EOL> if request . args . get ( '<STR_LIT>' ) : <EOL> del data [ '<STR_LIT>' ] <EOL> if request . args . get ( '<STR_LIT:q>' ) : <EOL> del data [ '<STR_LIT:q>' ] <EOL> fieldsNeeded = { '<STR_LIT:code>' : <NUM_LIT:1> , '<STR_LIT>' : <NUM_LIT:1> , '<STR_LIT>' : <NUM_LIT:1> } <EOL> if request . args . get ( '<STR_LIT>' ) and short == <NUM_LIT:1> : <EOL> if request . args . get ( '<STR_LIT:count>' ) and count == <NUM_LIT:1> and not request . args . get ( '<STR_LIT:q>' ) : <EOL> return mongo . db . products . find ( data , fieldsNeeded ) . count ( ) <EOL> elif not request . args . get ( '<STR_LIT:count>' ) and not request . args . get ( '<STR_LIT:q>' ) : <EOL> return mongo . db . products . find ( data , fieldsNeeded ) . sort ( '<STR_LIT>' , pymongo . DESCENDING ) . skip ( skip ) . limit ( limit ) <EOL> elif request . args . get ( '<STR_LIT:count>' ) and count == <NUM_LIT:1> and request . args . get ( '<STR_LIT:q>' ) : <EOL> return mongo . db . products . find ( { \"<STR_LIT>\" : { \"<STR_LIT>\" : query } } , fieldsNeeded ) . count ( ) <EOL> else : <EOL> return mongo . db . products . find ( { \"<STR_LIT>\" : { \"<STR_LIT>\" : query } } , fieldsNeeded ) . sort ( '<STR_LIT>' , pymongo . DESCENDING ) . skip ( skip ) . limit ( limit ) <EOL> else : <EOL> if request . args . get ( '<STR_LIT:count>' ) and count == <NUM_LIT:1> and not request . args . get ( '<STR_LIT:q>' ) : <EOL> return mongo . db . products . find ( data ) . count ( ) <EOL> elif not request . args . get ( '<STR_LIT:count>' ) and not request . args . get ( '<STR_LIT:q>' ) : <EOL> return mongo . db . products . find ( data ) . sort ( '<STR_LIT>' , pymongo . DESCENDING ) . skip ( skip ) . limit ( limit ) <EOL> elif request . args . get ( '<STR_LIT:count>' ) and count == <NUM_LIT:1> and request . args . get ( '<STR_LIT:q>' ) : <EOL> return mongo . db . products . find ( { \"<STR_LIT>\" : { \"<STR_LIT>\" : query } } ) . count ( ) <EOL> else : <EOL> return mongo . db . products . find ( { \"<STR_LIT>\" : { \"<STR_LIT>\" : query } } ) . sort ( '<STR_LIT>' , pymongo . DESCENDING ) . skip ( skip ) . limit ( limit ) <EOL> class ProductsStats ( restful . Resource ) : <EOL> def get ( self ) : <EOL> map = Code ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> reduce = Code ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> listRes = [ ] <EOL> result = mongo . db . products . map_reduce ( map , reduce , \"<STR_LIT>\" ) <EOL> for doc in result . find ( ) : <EOL> res = { } <EOL> res [ '<STR_LIT>' ] = doc [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> res [ '<STR_LIT>' ] = doc [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> res [ '<STR_LIT:count>' ] = doc [ '<STR_LIT:value>' ] [ '<STR_LIT:count>' ] <EOL> res [ '<STR_LIT>' ] = doc [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> res [ '<STR_LIT>' ] = doc [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> res [ '<STR_LIT>' ] = doc [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> res [ '<STR_LIT>' ] = doc [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> listRes . append ( res ) <EOL> return listRes <EOL> class ProductId ( restful . Resource ) : <EOL> def get ( self , barcode ) : <EOL> return mongo . db . products . find_one ( { \"<STR_LIT:code>\" : barcode } ) <EOL> class ProductsBrands ( restful . Resource ) : <EOL> def get ( self ) : <EOL> count = request . args . get ( '<STR_LIT:count>' , default = <NUM_LIT:0> , type = int ) <EOL> query = request . args . get ( '<STR_LIT>' ) <EOL> if request . args . get ( '<STR_LIT>' ) : <EOL> map = Code ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> reduce = Code ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> result = mongo . db . products . map_reduce ( map , reduce , \"<STR_LIT>\" ) <EOL> res = [ ] <EOL> for doc in result . find ( { \"<STR_LIT>\" : { '<STR_LIT>' : query , '<STR_LIT>' : '<STR_LIT>' } } ) : <EOL> res . append ( doc [ '<STR_LIT>' ] ) <EOL> if request . args . get ( '<STR_LIT:count>' ) and count == <NUM_LIT:1> : <EOL> return len ( res ) <EOL> else : <EOL> return res <EOL> else : <EOL> if request . args . get ( '<STR_LIT:count>' ) and count == <NUM_LIT:1> : <EOL> return len ( mongo . db . products . distinct ( '<STR_LIT>' ) ) <EOL> else : <EOL> return mongo . db . products . distinct ( '<STR_LIT>' ) <EOL> class ProductsCategories ( restful . Resource ) : <EOL> def get ( self ) : <EOL> count = request . args . get ( '<STR_LIT:count>' , default = <NUM_LIT:0> , type = int ) <EOL> query = request . args . get ( '<STR_LIT>' ) <EOL> if request . args . get ( '<STR_LIT>' ) : <EOL> map = Code ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> reduce = Code ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL>", "answer": "result = mongo . db . products . map_reduce ( map , reduce , \"<STR_LIT>\" )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> from django . test import SimpleTestCase , TestCase <EOL> from corehq . apps . receiverwrapper import submit_form_locally <EOL> from corehq . util . test_utils import TestFileMixin <EOL> from corehq . form_processor . interfaces . processor import FormProcessorInterface <EOL> from corehq . form_processor . tests . utils import run_with_all_backends <EOL> from corehq . form_processor . utils import convert_xform_to_json <EOL> from phonelog . models import UserEntry , DeviceReportEntry , UserErrorEntry , ForceCloseEntry <EOL> from phonelog . utils import _get_logs <EOL> class DeviceLogTest ( TestCase , TestFileMixin ) : <EOL> file_path = ( '<STR_LIT:data>' , '<STR_LIT>' ) <EOL> root = os . path . dirname ( __file__ ) <EOL> def setUp ( self ) : <EOL> self . interface = FormProcessorInterface ( ) <EOL> def tearDown ( self ) : <EOL> DeviceReportEntry . objects . all ( ) . delete ( ) <EOL> UserEntry . objects . all ( ) . delete ( ) <EOL> UserErrorEntry . objects . all ( ) . delete ( ) <EOL> ForceCloseEntry . objects . all ( ) . delete ( ) <EOL> def assert_properties_equal ( self , obj , expected ) : <EOL> for prop , value in expected : <EOL> actual = getattr ( obj , prop ) <EOL>", "answer": "msg = ( \"<STR_LIT>\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> from twisted . internet import reactor <EOL> from twisted . trial import unittest <EOL> from twisted . internet . defer import waitForDeferred , deferredGenerator , Deferred <EOL> from twisted . internet import defer <EOL> def getThing ( ) : <EOL> d = Deferred ( ) <EOL> reactor . callLater ( <NUM_LIT:0> , d . callback , \"<STR_LIT>\" ) <EOL> return d <EOL> def getOwie ( ) : <EOL> d = Deferred ( ) <EOL> def CRAP ( ) : <EOL> d . errback ( ZeroDivisionError ( '<STR_LIT>' ) ) <EOL> reactor . callLater ( <NUM_LIT:0> , CRAP ) <EOL> return d <EOL> class TerminalException ( Exception ) : <EOL> pass <EOL> class BaseDefgenTests : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testBasics ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _genBasics ( ) . addCallback ( self . assertEqual , '<STR_LIT>' ) <EOL> def testBuggy ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . assertFailure ( self . _genBuggy ( ) , ZeroDivisionError ) <EOL> def testNothing ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _genNothing ( ) . addCallback ( self . assertEqual , None ) <EOL> def testHandledTerminalFailure ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _genHandledTerminalFailure ( ) . addCallback ( self . assertEqual , None ) <EOL> def testHandledTerminalAsyncFailure ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> d = defer . Deferred ( ) <EOL> deferredGeneratorResultDeferred = self . _genHandledTerminalAsyncFailure ( d ) <EOL> d . errback ( TerminalException ( \"<STR_LIT>\" ) ) <EOL> return deferredGeneratorResultDeferred . addCallback ( <EOL> self . assertEqual , None ) <EOL> def testStackUsage ( self ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL> from django . db import IntegrityError , transaction <EOL> from django . utils import timezone <EOL> from rest_framework import serializers <EOL> from rest_framework . response import Response <EOL> from sentry . api . base import DocSection <EOL> from sentry . api . bases . project import ProjectEndpoint <EOL> from sentry . api . fields . user import UserField <EOL> from sentry . api . serializers import serialize <EOL> from sentry . models import Activity , Release <EOL> from sentry . utils . apidocs import scenario , attach_scenarios <EOL> @ scenario ( '<STR_LIT>' ) <EOL> def create_new_release_scenario ( runner ) : <EOL> runner . request ( <EOL> method = '<STR_LIT:POST>' , <EOL> path = '<STR_LIT>' % ( <EOL> runner . org . slug , runner . default_project . slug ) , <EOL> data = { <EOL> '<STR_LIT:version>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> ) <EOL> @ scenario ( '<STR_LIT>' ) <EOL> def list_releases_scenario ( runner ) : <EOL> runner . request ( <EOL> method = '<STR_LIT:GET>' , <EOL> path = '<STR_LIT>' % ( <EOL> runner . org . slug , runner . default_project . slug ) <EOL> ) <EOL> class ReleaseSerializer ( serializers . Serializer ) : <EOL> version = serializers . RegexField ( r'<STR_LIT>' , max_length = <NUM_LIT:64> , required = True ) <EOL> ref = serializers . CharField ( max_length = <NUM_LIT:64> , required = False ) <EOL> url = serializers . URLField ( required = False ) <EOL> owner = UserField ( required = False ) <EOL> dateStarted = serializers . DateTimeField ( required = False ) <EOL> dateReleased = serializers . DateTimeField ( required = False ) <EOL> class ProjectReleasesEndpoint ( ProjectEndpoint ) : <EOL> doc_section = DocSection . RELEASES <EOL> @ attach_scenarios ( [ list_releases_scenario ] ) <EOL> def get ( self , request , project ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> query = request . GET . get ( '<STR_LIT>' ) <EOL> queryset = Release . objects . filter ( <EOL> project = project , <EOL> ) . select_related ( '<STR_LIT>' ) <EOL> if query : <EOL> queryset = queryset . filter ( <EOL>", "answer": "version__istartswith = query ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from forms import Form <EOL> from airy . core . exceptions import ValidationError <EOL> from airy . utils . encoding import StrAndUnicode <EOL> from airy . utils . safestring import mark_safe <EOL> from airy . utils . translation import ugettext as _ <EOL> from fields import IntegerField , BooleanField <EOL> from widgets import Media , HiddenInput <EOL> from util import ErrorList <EOL> __all__ = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> TOTAL_FORM_COUNT = '<STR_LIT>' <EOL> INITIAL_FORM_COUNT = '<STR_LIT>' <EOL> MAX_NUM_FORM_COUNT = '<STR_LIT>' <EOL> ORDERING_FIELD_NAME = '<STR_LIT>' <EOL> DELETION_FIELD_NAME = '<STR_LIT>' <EOL> class ManagementForm ( Form ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . base_fields [ TOTAL_FORM_COUNT ] = IntegerField ( widget = HiddenInput ) <EOL> self . base_fields [ INITIAL_FORM_COUNT ] = IntegerField ( widget = HiddenInput ) <EOL> self . base_fields [ MAX_NUM_FORM_COUNT ] = IntegerField ( required = False , widget = HiddenInput ) <EOL> super ( ManagementForm , self ) . __init__ ( * args , ** kwargs ) <EOL> class BaseFormSet ( StrAndUnicode ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , data = None , files = None , auto_id = '<STR_LIT>' , prefix = None , <EOL> initial = None , error_class = ErrorList ) : <EOL> self . is_bound = data is not None or files is not None <EOL> self . prefix = prefix or self . get_default_prefix ( ) <EOL> self . auto_id = auto_id <EOL> self . data = data or { } <EOL> self . files = files or { } <EOL> self . initial = initial <EOL> self . error_class = error_class <EOL> self . _errors = None <EOL> self . _non_form_errors = None <EOL> self . _construct_forms ( ) <EOL> def __unicode__ ( self ) : <EOL> return self . as_table ( ) <EOL> def __iter__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return iter ( self . forms ) <EOL> def __getitem__ ( self , index ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return list ( self ) [ index ] <EOL> def __len__ ( self ) : <EOL> return len ( self . forms ) <EOL> def _management_form ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . is_bound : <EOL> form = ManagementForm ( self . data , auto_id = self . auto_id , prefix = self . prefix ) <EOL> if not form . is_valid ( ) : <EOL> raise ValidationError ( '<STR_LIT>' ) <EOL> else : <EOL> form = ManagementForm ( auto_id = self . auto_id , prefix = self . prefix , initial = { <EOL> TOTAL_FORM_COUNT : self . total_form_count ( ) , <EOL> INITIAL_FORM_COUNT : self . initial_form_count ( ) , <EOL> MAX_NUM_FORM_COUNT : self . max_num <EOL> } ) <EOL> return form <EOL> management_form = property ( _management_form ) <EOL> def total_form_count ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . is_bound : <EOL> return self . management_form . cleaned_data [ TOTAL_FORM_COUNT ] <EOL> else : <EOL> initial_forms = self . initial_form_count ( ) <EOL> total_forms = initial_forms + self . extra <EOL> if initial_forms > self . max_num >= <NUM_LIT:0> : <EOL> total_forms = initial_forms <EOL> elif total_forms > self . max_num >= <NUM_LIT:0> : <EOL> total_forms = self . max_num <EOL> return total_forms <EOL> def initial_form_count ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . is_bound : <EOL> return self . management_form . cleaned_data [ INITIAL_FORM_COUNT ] <EOL> else : <EOL> initial_forms = self . initial and len ( self . initial ) or <NUM_LIT:0> <EOL> if initial_forms > self . max_num >= <NUM_LIT:0> : <EOL> initial_forms = self . max_num <EOL> return initial_forms <EOL> def _construct_forms ( self ) : <EOL> self . forms = [ ] <EOL> for i in xrange ( self . total_form_count ( ) ) : <EOL> self . forms . append ( self . _construct_form ( i ) ) <EOL> def _construct_form ( self , i , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> defaults = { '<STR_LIT>' : self . auto_id , '<STR_LIT>' : self . add_prefix ( i ) } <EOL> if self . is_bound : <EOL> defaults [ '<STR_LIT:data>' ] = self . data <EOL> defaults [ '<STR_LIT>' ] = self . files <EOL> if self . initial : <EOL> try : <EOL> defaults [ '<STR_LIT>' ] = self . initial [ i ] <EOL> except IndexError : <EOL> pass <EOL> if i >= self . initial_form_count ( ) : <EOL> defaults [ '<STR_LIT>' ] = True <EOL> defaults . update ( kwargs ) <EOL> form = self . form ( ** defaults ) <EOL> self . add_fields ( form , i ) <EOL> return form <EOL> def _get_initial_forms ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . forms [ : self . initial_form_count ( ) ] <EOL> initial_forms = property ( _get_initial_forms ) <EOL> def _get_extra_forms ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . forms [ self . initial_form_count ( ) : ] <EOL> extra_forms = property ( _get_extra_forms ) <EOL> def _get_empty_form ( self , ** kwargs ) : <EOL> defaults = { <EOL> '<STR_LIT>' : self . auto_id , <EOL> '<STR_LIT>' : self . add_prefix ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : True , <EOL> } <EOL> defaults . update ( kwargs ) <EOL> form = self . form ( ** defaults ) <EOL> self . add_fields ( form , None ) <EOL> return form <EOL> empty_form = property ( _get_empty_form ) <EOL> def _get_cleaned_data ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . is_valid ( ) : <EOL> raise AttributeError ( \"<STR_LIT>\" % self . __class__ . __name__ ) <EOL> return [ form . cleaned_data for form in self . forms ] <EOL> cleaned_data = property ( _get_cleaned_data ) <EOL> def _get_deleted_forms ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . is_valid ( ) or not self . can_delete : <EOL> raise AttributeError ( \"<STR_LIT>\" % self . __class__ . __name__ ) <EOL> if not hasattr ( self , '<STR_LIT>' ) : <EOL> self . _deleted_form_indexes = [ ] <EOL> for i in range ( <NUM_LIT:0> , self . total_form_count ( ) ) : <EOL> form = self . forms [ i ] <EOL> if i >= self . initial_form_count ( ) and not form . has_changed ( ) : <EOL> continue <EOL> if self . _should_delete_form ( form ) : <EOL> self . _deleted_form_indexes . append ( i ) <EOL> return [ self . forms [ i ] for i in self . _deleted_form_indexes ] <EOL> deleted_forms = property ( _get_deleted_forms ) <EOL> def _get_ordered_forms ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . is_valid ( ) or not self . can_order : <EOL> raise AttributeError ( \"<STR_LIT>\" % self . __class__ . __name__ ) <EOL> if not hasattr ( self , '<STR_LIT>' ) : <EOL> self . _ordering = [ ] <EOL> for i in range ( <NUM_LIT:0> , self . total_form_count ( ) ) : <EOL> form = self . forms [ i ] <EOL> if i >= self . initial_form_count ( ) and not form . has_changed ( ) : <EOL> continue <EOL> if self . can_delete and self . _should_delete_form ( form ) : <EOL> continue <EOL> self . _ordering . append ( ( i , form . cleaned_data [ ORDERING_FIELD_NAME ] ) ) <EOL> def compare_ordering_key ( k ) : <EOL> if k [ <NUM_LIT:1> ] is None : <EOL> return ( <NUM_LIT:1> , <NUM_LIT:0> ) <EOL> return ( <NUM_LIT:0> , k [ <NUM_LIT:1> ] ) <EOL> self . _ordering . sort ( key = compare_ordering_key ) <EOL> return [ self . forms [ i [ <NUM_LIT:0> ] ] for i in self . _ordering ] <EOL> ordered_forms = property ( _get_ordered_forms ) <EOL> def get_default_prefix ( cls ) : <EOL> return '<STR_LIT>' <EOL> get_default_prefix = classmethod ( get_default_prefix ) <EOL> def non_form_errors ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _non_form_errors is not None : <EOL> return self . _non_form_errors <EOL> return self . error_class ( ) <EOL> def _get_errors ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _errors is None : <EOL> self . full_clean ( ) <EOL> return self . _errors <EOL> errors = property ( _get_errors ) <EOL> def _should_delete_form ( self , form ) : <EOL> field = form . fields [ DELETION_FIELD_NAME ] <EOL> raw_value = form . _raw_value ( DELETION_FIELD_NAME ) <EOL> should_delete = field . clean ( raw_value ) <EOL> return should_delete <EOL> def is_valid ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . is_bound : <EOL> return False <EOL> forms_valid = True <EOL> err = self . errors <EOL> for i in range ( <NUM_LIT:0> , self . total_form_count ( ) ) : <EOL> form = self . forms [ i ] <EOL> if self . can_delete : <EOL> if self . _should_delete_form ( form ) : <EOL> continue <EOL> if bool ( self . errors [ i ] ) : <EOL> forms_valid = False <EOL> return forms_valid and not bool ( self . non_form_errors ( ) ) <EOL> def full_clean ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _errors = [ ] <EOL> if not self . is_bound : <EOL> return <EOL> for i in range ( <NUM_LIT:0> , self . total_form_count ( ) ) : <EOL> form = self . forms [ i ] <EOL> self . _errors . append ( form . errors ) <EOL> try : <EOL> self . clean ( ) <EOL> except ValidationError , e : <EOL> self . _non_form_errors = self . error_class ( e . messages ) <EOL> def clean ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> def add_fields ( self , form , index ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . can_order : <EOL> if index is not None and index < self . initial_form_count ( ) : <EOL> form . fields [ ORDERING_FIELD_NAME ] = IntegerField ( label = _ ( u'<STR_LIT>' ) , initial = index + <NUM_LIT:1> , required = False ) <EOL> else : <EOL> form . fields [ ORDERING_FIELD_NAME ] = IntegerField ( label = _ ( u'<STR_LIT>' ) , required = False ) <EOL>", "answer": "if self . can_delete :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = <NUM_LIT:9>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import arrayfire as af <EOL> from arrayfire import ParallelRange <EOL> import array as host <EOL> from . import _util <EOL> def simple_index ( verbose = False ) : <EOL> display_func = _util . display_func ( verbose ) <EOL> print_func = _util . print_func ( verbose ) <EOL> a = af . randu ( <NUM_LIT:5> , <NUM_LIT:5> ) <EOL> display_func ( a ) <EOL> b = af . Array ( a ) <EOL> display_func ( b ) <EOL> c = a . copy ( ) <EOL> display_func ( c ) <EOL> display_func ( a [ <NUM_LIT:0> , <NUM_LIT:0> ] ) <EOL> display_func ( a [ <NUM_LIT:0> ] ) <EOL> display_func ( a [ : ] ) <EOL> display_func ( a [ : , : ] ) <EOL> display_func ( a [ <NUM_LIT:0> : <NUM_LIT:3> , ] ) <EOL> display_func ( a [ - <NUM_LIT:2> : - <NUM_LIT:1> , - <NUM_LIT:1> ] ) <EOL> display_func ( a [ <NUM_LIT:0> : <NUM_LIT:5> ] ) <EOL> display_func ( a [ <NUM_LIT:0> : <NUM_LIT:5> : <NUM_LIT:2> ] ) <EOL> idx = af . Array ( host . array ( '<STR_LIT:i>' , [ <NUM_LIT:0> , <NUM_LIT:3> , <NUM_LIT:2> ] ) ) <EOL> display_func ( idx ) <EOL> aa = a [ idx ] <EOL> display_func ( aa ) <EOL> a [ <NUM_LIT:0> ] = <NUM_LIT:1> <EOL> display_func ( a ) <EOL>", "answer": "a [ <NUM_LIT:0> ] = af . randu ( <NUM_LIT:1> , <NUM_LIT:5> )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL> from __future__ import division <EOL> from __future__ import print_function <EOL> import unittest <EOL> from ddp . messages . server . result_message import ResultMessage <EOL> from ddp . messages . server . result_message_parser import ResultMessageParser <EOL> class ResultMessageParserTestCase ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . parser = ResultMessageParser ( ) <EOL> self . id = '<STR_LIT:id>' <EOL> self . error = '<STR_LIT:error>' <EOL> self . result = { '<STR_LIT:result>' : [ True , <NUM_LIT:1.0> ] } <EOL> def test_with_error ( self ) : <EOL> message = self . parser . parse ( { '<STR_LIT>' : '<STR_LIT:result>' , '<STR_LIT:id>' : self . id , <EOL> '<STR_LIT:error>' : self . error } ) <EOL> self . assertEqual ( message , ResultMessage ( self . id , error = self . error ) ) <EOL> def test_with_result ( self ) : <EOL> message = self . parser . parse ( { '<STR_LIT>' : '<STR_LIT:result>' , '<STR_LIT:id>' : self . id , <EOL> '<STR_LIT:result>' : self . result } ) <EOL> self . assertEqual ( message , ResultMessage ( self . id , result = self . result ) ) <EOL>", "answer": "def test_with_error_with_result ( self ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import setuptools <EOL>", "answer": "setuptools . setup ("}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import unittest , sys <EOL> from lxml . tests . common_imports import make_doctest <EOL> def test_suite ( ) : <EOL> suite = unittest . TestSuite ( ) <EOL> if sys . version_info >= ( <NUM_LIT:2> , <NUM_LIT:4> ) : <EOL> suite . addTests ( [ make_doctest ( '<STR_LIT>' ) ] ) <EOL> return suite <EOL>", "answer": "if __name__ == '<STR_LIT:__main__>' :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from math import pi <EOL> import pytest <EOL> from shapely . geometry import LineString , Point <EOL> from shapely . wkt import dumps <EOL> @ pytest . fixture ( scope = \"<STR_LIT>\" ) <EOL> def pipi ( ) : <EOL> return Point ( ( pi , - pi ) ) <EOL> @ pytest . fixture ( scope = \"<STR_LIT>\" ) <EOL> def pipi4 ( ) : <EOL> return Point ( ( pi * <NUM_LIT:4> , - pi * <NUM_LIT:4> ) ) <EOL> def test_wkt ( pipi ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert pipi . wkt == \"<STR_LIT>\" . format ( pi , - pi ) <EOL>", "answer": "def test_wkt ( pipi4 ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from south . utils import datetime_utils as datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . add_column ( u'<STR_LIT>' , '<STR_LIT>' , <EOL> self . gf ( '<STR_LIT>' ) ( <EOL> default = <NUM_LIT:1> ) , <EOL> keep_default = False ) <EOL> def backwards ( self , orm ) : <EOL> db . delete_column ( u'<STR_LIT>' , '<STR_LIT>' ) <EOL> models = { <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT:host>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : u\"<STR_LIT>\" } ) , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : u\"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT:status>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:4>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL>", "answer": "u'<STR_LIT>' : {"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . db import connections <EOL> from django . test import TestCase <EOL> class IsMariaDBTests ( TestCase ) : <EOL> def test_connections ( self ) : <EOL> for alias in connections : <EOL> connection = connections [ alias ] <EOL> if not hasattr ( connection , '<STR_LIT>' ) : <EOL> continue <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL> version = cursor . fetchone ( ) [ <NUM_LIT:0> ] <EOL>", "answer": "is_mariadb = ( '<STR_LIT>' in version )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import ctypes <EOL> import os <EOL> try : <EOL> file <EOL> except NameError : <EOL> import io <EOL> file = io . BufferedReader <EOL> import numpy as np <EOL> import quantities as pq <EOL> from neo . io . baseio import BaseIO <EOL> from neo . core import Segment , AnalogSignal , SpikeTrain , EventArray <EOL> ns_OK = <NUM_LIT:0> <EOL> ns_LIBERROR = - <NUM_LIT:1> <EOL> ns_TYPEERROR = - <NUM_LIT:2> <EOL> ns_FILEERROR = - <NUM_LIT:3> <EOL> ns_BADFILE = - <NUM_LIT:4> <EOL> ns_BADENTITY = - <NUM_LIT:5> <EOL> ns_BADSOURCE = - <NUM_LIT:6> <EOL> ns_BADINDEX = - <NUM_LIT:7> <EOL> class NeuroshareError ( Exception ) : <EOL> def __init__ ( self , lib , errno ) : <EOL> self . lib = lib <EOL> self . errno = errno <EOL> pszMsgBuffer = ctypes . create_string_buffer ( <NUM_LIT> ) <EOL> self . lib . ns_GetLastErrorMsg ( pszMsgBuffer , ctypes . c_uint32 ( <NUM_LIT> ) ) <EOL> errstr = '<STR_LIT>' . format ( errno , pszMsgBuffer . value ) <EOL> Exception . __init__ ( self , errstr ) <EOL> class DllWithError ( ) : <EOL> def __init__ ( self , lib ) : <EOL> self . lib = lib <EOL> def __getattr__ ( self , attr ) : <EOL> f = getattr ( self . lib , attr ) <EOL> return self . decorate_with_error ( f ) <EOL> def decorate_with_error ( self , f ) : <EOL> def func_with_error ( * args ) : <EOL> errno = f ( * args ) <EOL> if errno != ns_OK : <EOL> raise NeuroshareError ( self . lib , errno ) <EOL> return errno <EOL> return func_with_error <EOL> class NeurosharectypesIO ( BaseIO ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> is_readable = True <EOL> is_writable = False <EOL> supported_objects = [ Segment , AnalogSignal , EventArray , SpikeTrain ] <EOL> readable_objects = [ Segment ] <EOL> writeable_objects = [ ] <EOL> has_header = False <EOL> is_streameable = False <EOL> read_params = { Segment : [ ] } <EOL> write_params = None <EOL> name = '<STR_LIT>' <EOL> extensions = [ ] <EOL> mode = '<STR_LIT:file>' <EOL> def __init__ ( self , filename = '<STR_LIT>' , dllname = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> BaseIO . __init__ ( self ) <EOL> self . dllname = dllname <EOL> self . filename = filename <EOL> def read_segment ( self , import_neuroshare_segment = True , <EOL> lazy = False , cascade = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> seg = Segment ( file_origin = os . path . basename ( self . filename ) , ) <EOL> if sys . platform . startswith ( '<STR_LIT>' ) : <EOL> neuroshare = ctypes . windll . LoadLibrary ( self . dllname ) <EOL> elif sys . platform . startswith ( '<STR_LIT>' ) : <EOL> neuroshare = ctypes . cdll . LoadLibrary ( self . dllname ) <EOL> neuroshare = DllWithError ( neuroshare ) <EOL> info = ns_LIBRARYINFO ( ) <EOL> neuroshare . ns_GetLibraryInfo ( ctypes . byref ( info ) , ctypes . sizeof ( info ) ) <EOL> seg . annotate ( neuroshare_version = str ( info . dwAPIVersionMaj ) + '<STR_LIT:.>' + str ( info . dwAPIVersionMin ) ) <EOL> if not cascade : <EOL> return seg <EOL> hFile = ctypes . c_uint32 ( <NUM_LIT:0> ) <EOL> neuroshare . ns_OpenFile ( ctypes . c_char_p ( self . filename ) , ctypes . byref ( hFile ) ) <EOL> fileinfo = ns_FILEINFO ( ) <EOL> neuroshare . ns_GetFileInfo ( hFile , ctypes . byref ( fileinfo ) , ctypes . sizeof ( fileinfo ) ) <EOL> for dwEntityID in range ( fileinfo . dwEntityCount ) : <EOL> entityInfo = ns_ENTITYINFO ( ) <EOL> neuroshare . ns_GetEntityInfo ( hFile , dwEntityID , ctypes . byref ( entityInfo ) , ctypes . sizeof ( entityInfo ) ) <EOL> if entity_types [ entityInfo . dwEntityType ] == '<STR_LIT>' : <EOL> pEventInfo = ns_EVENTINFO ( ) <EOL> neuroshare . ns_GetEventInfo ( hFile , dwEntityID , ctypes . byref ( pEventInfo ) , ctypes . sizeof ( pEventInfo ) ) <EOL> if pEventInfo . dwEventType == <NUM_LIT:0> : <EOL> pData = ctypes . create_string_buffer ( pEventInfo . dwMaxDataLength ) <EOL> elif pEventInfo . dwEventType == <NUM_LIT:1> : <EOL> pData = ctypes . create_string_buffer ( pEventInfo . dwMaxDataLength ) <EOL> elif pEventInfo . dwEventType == <NUM_LIT:2> : <EOL> pData = ctypes . c_byte ( <NUM_LIT:0> ) <EOL> elif pEventInfo . dwEventType == <NUM_LIT:3> : <EOL> pData = ctypes . c_int16 ( <NUM_LIT:0> ) <EOL> elif pEventInfo . dwEventType == <NUM_LIT:4> : <EOL> pData = ctypes . c_int32 ( <NUM_LIT:0> ) <EOL> pdTimeStamp = ctypes . c_double ( <NUM_LIT:0.> ) <EOL> pdwDataRetSize = ctypes . c_uint32 ( <NUM_LIT:0> ) <EOL> ea = EventArray ( name = str ( entityInfo . szEntityLabel ) , ) <EOL> if not lazy : <EOL> times = [ ] <EOL> labels = [ ] <EOL> for dwIndex in range ( entityInfo . dwItemCount ) : <EOL> neuroshare . ns_GetEventData ( hFile , dwEntityID , dwIndex , <EOL>", "answer": "ctypes . byref ( pdTimeStamp ) , ctypes . byref ( pData ) ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from openaps . uses . use import Use <EOL> from openaps . uses . registry import Registry <EOL> from openaps . glucose . convert import Convert as GlucoseConvert <EOL> import json <EOL> import argparse <EOL> def set_config ( args , device ) : <EOL> return device <EOL> def display_device ( device ) : <EOL> return '<STR_LIT>' <EOL> use = Registry ( ) <EOL> class ConvertInput ( Use ) : <EOL> def get_params ( self , args ) : <EOL> return dict ( input = args . input , to = args . to ) <EOL> def configure_app ( self , app , parser ) : <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , default = '<STR_LIT>' , choices = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> parser . add_argument ( '<STR_LIT:input>' , default = '<STR_LIT:->' ) <EOL> def get_program ( self , args ) : <EOL> params = self . get_params ( args ) <EOL> program = json . load ( argparse . FileType ( '<STR_LIT:r>' ) ( params . get ( '<STR_LIT:input>' ) ) ) <EOL> return program <EOL> CONVERTERS = { '<STR_LIT>' : GlucoseConvert . mg_dl_to_mmol_l <EOL> , '<STR_LIT>' : GlucoseConvert . mmol_l_to_mg_dl } <EOL> def set_converter ( self , args ) : <EOL> params = self . get_params ( args ) <EOL> converters = self . CONVERTERS <EOL> self . units = params . get ( '<STR_LIT:to>' ) <EOL> self . to_unit = converters . get ( self . units ) <EOL> def convert ( self , program ) : <EOL> raise NotImplementedError ( ) <EOL> def main ( self , args , app ) : <EOL> self . set_converter ( args ) <EOL> program = self . get_program ( args ) <EOL> results = self . convert ( program ) <EOL> return results <EOL> @ use ( ) <EOL> class bg_targets ( ConvertInput ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def convert ( self , bg_targets ) : <EOL> assert bg_targets [ '<STR_LIT>' ] in [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> if bg_targets [ '<STR_LIT>' ] != self . units : <EOL> for target in bg_targets [ '<STR_LIT>' ] : <EOL> target [ '<STR_LIT>' ] = self . to_unit ( target [ '<STR_LIT>' ] ) <EOL> target [ '<STR_LIT>' ] = self . to_unit ( target [ '<STR_LIT>' ] ) <EOL> bg_targets [ '<STR_LIT>' ] = bg_targets [ '<STR_LIT>' ] <EOL> bg_targets [ '<STR_LIT>' ] = self . units <EOL> return bg_targets <EOL> @ use ( ) <EOL> class insulin_sensitivities ( ConvertInput ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def convert ( self , insulin_sensitivities ) : <EOL> assert insulin_sensitivities [ '<STR_LIT>' ] in [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> if insulin_sensitivities [ '<STR_LIT>' ] != self . units : <EOL> for sens in insulin_sensitivities [ '<STR_LIT>' ] : <EOL> sens [ '<STR_LIT>' ] = self . to_unit ( sens [ '<STR_LIT>' ] ) <EOL> insulin_sensitivities [ '<STR_LIT>' ] = insulin_sensitivities [ '<STR_LIT>' ] <EOL> insulin_sensitivities [ '<STR_LIT>' ] = self . units <EOL>", "answer": "return insulin_sensitivities"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import dbus <EOL> EXPIRES_DEFAULT = - <NUM_LIT:1> <EOL> EXPIRES_NEVER = <NUM_LIT:0> <EOL> URGENCY_LOW = <NUM_LIT:0> <EOL> URGENCY_NORMAL = <NUM_LIT:1> <EOL> URGENCY_CRITICAL = <NUM_LIT:2> <EOL> urgency_levels = [ URGENCY_LOW , URGENCY_NORMAL , URGENCY_CRITICAL ] <EOL> initted = False <EOL> appname = \"<STR_LIT>\" <EOL> _have_mainloop = False <EOL> class UninittedError ( RuntimeError ) : <EOL> pass <EOL> class UninittedDbusObj ( object ) : <EOL> def __getattr__ ( self , name ) : <EOL> raise UninittedError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> dbus_iface = UninittedDbusObj ( ) <EOL> def init ( app_name , mainloop = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> global appname , initted , dbus_iface , _have_mainloop <EOL> if mainloop == '<STR_LIT>' : <EOL> from dbus . mainloop . glib import DBusGMainLoop <EOL> mainloop = DBusGMainLoop ( ) <EOL> elif mainloop == '<STR_LIT>' : <EOL> from dbus . mainloop . qt import DBusQtMainLoop <EOL> mainloop = DBusQtMainLoop ( set_as_default = True ) <EOL> bus = dbus . SessionBus ( mainloop = mainloop ) <EOL> dbus_obj = bus . get_object ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> dbus_iface = dbus . Interface ( dbus_obj , <EOL> dbus_interface = '<STR_LIT>' ) <EOL> appname = app_name <EOL> initted = True <EOL> if mainloop or dbus . get_default_main_loop ( ) : <EOL> _have_mainloop = True <EOL> dbus_iface . connect_to_signal ( '<STR_LIT>' , _action_callback ) <EOL> dbus_iface . connect_to_signal ( '<STR_LIT>' , _closed_callback ) <EOL> return True <EOL> def is_initted ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return initted <EOL> def get_app_name ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return appname <EOL> def uninit ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> global initted , dbus_iface , _have_mainloop <EOL> initted = False <EOL> _have_mainloop = False <EOL> dbus_iface = UninittedDbusObj ( ) <EOL> def get_server_caps ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return [ str ( x ) for x in dbus_iface . GetCapabilities ( ) ] <EOL> def get_server_info ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> res = dbus_iface . GetServerInformation ( ) <EOL> return { '<STR_LIT:name>' : str ( res [ <NUM_LIT:0> ] ) , <EOL> '<STR_LIT>' : str ( res [ <NUM_LIT:1> ] ) , <EOL> '<STR_LIT:version>' : str ( res [ <NUM_LIT:2> ] ) , <EOL> '<STR_LIT>' : str ( res [ <NUM_LIT:3> ] ) , <EOL> } <EOL> notifications_registry = { } <EOL> def _action_callback ( nid , action ) : <EOL> nid , action = int ( nid ) , str ( action ) <EOL> n = notifications_registry [ nid ] <EOL> n . _action_callback ( action ) <EOL> def _closed_callback ( nid , reason ) : <EOL> nid , reason = int ( nid ) , int ( reason ) <EOL> n = notifications_registry [ nid ] <EOL>", "answer": "n . _closed_callback ( n )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import requests <EOL> import simplejson as json <EOL> from datetime import datetime , timedelta <EOL> from calendar import timegm <EOL> import os <EOL> class APIClient ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , base_url , api_key = \"<STR_LIT>\" , email_address = \"<STR_LIT>\" ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . base_url = base_url <EOL> self . email_address = email_address <EOL> self . no_org_uris = [ ] <EOL> self . org_id = None <EOL> if api_key and email_address : <EOL> self . authorization = \"<STR_LIT>\" % ( email_address , api_key ) <EOL> else : <EOL> self . authorization = None <EOL> self . schema = self . _request ( '<STR_LIT>' ) <EOL> self . schema_uri_by_name = { e [ '<STR_LIT:name>' ] : k <EOL> for k , e in self . schema . iteritems ( ) } <EOL> self . no_org_uris = [ self . schema_uri_by_name [ '<STR_LIT>' ] ] <EOL> for name in self . schema_uri_by_name : <EOL> if hasattr ( APIClient , name ) : <EOL> continue <EOL> def make_function ( name ) : <EOL> fn = lambda obj , ** args : obj . _request ( name = name , ** args ) <EOL> endpoint = self . _get_endpoint_by_name ( name ) <EOL> fn . __doc__ = endpoint [ '<STR_LIT:description>' ] <EOL> fn . __name__ = str ( endpoint [ '<STR_LIT:name>' ] ) <EOL> return fn <EOL> setattr ( APIClient , name , make_function ( name ) ) <EOL> def _get_endpoint_by_name ( self , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> uri = self . schema_uri_by_name [ name ] <EOL> endpoint = self . schema [ uri ] <EOL> endpoint [ '<STR_LIT>' ] = uri <EOL> return endpoint <EOL> def get_schema ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . schema <EOL> def describe ( self , what ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if what in self . schema_uri_by_name : <EOL> endpoint = self . _get_endpoint_by_name ( what ) <EOL> uri = endpoint [ '<STR_LIT>' ] <EOL> elif what in self . schema : <EOL> uri = what <EOL> endpoint = self . schema [ what ] <EOL> else : <EOL> print \"<STR_LIT>\" % what <EOL> return <EOL> print endpoint [ '<STR_LIT:name>' ] <EOL> print uri <EOL> print endpoint [ '<STR_LIT:description>' ] <EOL> def set_organization_id ( self , org_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> orgs = self . get_organizations ( ) <EOL> orgs_by_id = { org [ '<STR_LIT:id>' ] : org <EOL> for org in orgs } <EOL> if org_id not in orgs_by_id : <EOL> msg = \"<STR_LIT>\" % ( <EOL> self . email_address , org_id <EOL> ) <EOL> raise RuntimeError ( msg ) <EOL> self . org_id = org_id <EOL> def _request ( <EOL> self , uri = None , name = None , method = None , payload = None , headers = None , <EOL> params = None <EOL> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if uri is None and name is not None : <EOL> uri = self . schema_uri_by_name [ name ] <EOL> if method is None and name . startswith ( '<STR_LIT>' ) : <EOL> method = '<STR_LIT>' <EOL> if method is None : <EOL> if payload is not None : <EOL> method = '<STR_LIT>' <EOL> else : <EOL> method = '<STR_LIT>' <EOL> method = method . lower ( ) <EOL> if headers is None : <EOL> headers = { } <EOL> if self . authorization : <EOL> headers [ '<STR_LIT>' ] = self . authorization <EOL> if params is None : <EOL> params = { } <EOL> if payload is None : <EOL> payload = { } <EOL> if self . org_id and uri not in self . no_org_uris : <EOL> if method == '<STR_LIT>' : <EOL> if '<STR_LIT>' not in params : <EOL> params [ '<STR_LIT>' ] = self . org_id <EOL> else : <EOL> if '<STR_LIT>' not in payload : <EOL> payload [ '<STR_LIT>' ] = self . org_id <EOL>", "answer": "if payload :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> def assert_nearly_equal ( left , right , precision = <NUM_LIT:7> , message = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> condition = round ( abs ( left - right ) , precision ) == <NUM_LIT:0> <EOL> if message is not None : <EOL> assert condition , message <EOL>", "answer": "else :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from HTMLParser import HTMLParser <EOL> from collections import deque <EOL> version = '<STR_LIT>' <EOL> DATA = <NUM_LIT:1> <EOL> META = <NUM_LIT:2> <EOL> COMMENT = <NUM_LIT:3> <EOL> PI = <NUM_LIT:4> <EOL> CODE = <NUM_LIT:5> <EOL> AMP = <NUM_LIT:6> <EOL> class Attribute ( dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __getitem__ ( self , key ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . get ( key , '<STR_LIT>' ) <EOL> def __str__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> data = '<STR_LIT>' <EOL> for key , value in self . items ( ) : <EOL> pair = '<STR_LIT>' % ( key , value ) <EOL> data = data + pair <EOL> return data <EOL> class Root ( list ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , name = None , attr = { } ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> self . name = name <EOL> self . attr = Attribute ( attr ) <EOL> list . __init__ ( self ) <EOL> __repr__ = object . __repr__ <EOL> def __str__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> html = '<STR_LIT>' <EOL> for ind in self : <EOL> html = '<STR_LIT>' % ( html , ind ) <EOL> return html <EOL> def sail ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for indi in self [ : ] : <EOL> for indj in indi . sail ( ) : <EOL> yield ( indj ) <EOL> yield ( indi ) <EOL> def index ( self , item ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> count = <NUM_LIT:0> <EOL> for ind in self : <EOL> if ind is item : return count <EOL> count = count + <NUM_LIT:1> <EOL> raise ValueError <EOL> def remove ( self , item ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> index = self . index ( item ) <EOL> del self [ index ] <EOL> def find ( self , name , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for ind in self . sail ( ) : <EOL> if ind . name == name : <EOL> for key , value in args : <EOL> if ind . attr [ key ] != value : <EOL> break <EOL> else : <EOL> yield ( ind ) <EOL> def find_with_root ( self , name , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for root , ind in self . sail_with_root ( ) : <EOL> if ind . name == name : <EOL> for key , value in args : <EOL> if ind . attr [ key ] != value : <EOL> break <EOL> else : <EOL> yield ( root , ind ) <EOL> def byid ( self , id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . take ( '<STR_LIT:id>' , id ) <EOL> def take ( self , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> seq = self . match ( * args ) <EOL> try : <EOL> item = seq . next ( ) <EOL> except StopIteration : <EOL> return None <EOL> else : <EOL> return item <EOL> def take_with_root ( self , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> seq = self . match_with_root ( * args ) <EOL> try : <EOL> item = seq . next ( ) <EOL> except StopIteration : <EOL> return None <EOL> else : <EOL> return item <EOL> pass <EOL> def match ( self , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for ind in self . sail ( ) : <EOL> for key , value in args : <EOL> if ind . attr [ key ] != value : <EOL> break <EOL> else : <EOL> yield ( ind ) <EOL> def match_with_root ( self , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for root , ind in self . sail_with_root ( ) : <EOL> for key , value in args : <EOL> if ind . attr [ key ] != value : <EOL> break <EOL> else : <EOL> yield ( root , ind ) <EOL> def join ( self , delim , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> data = '<STR_LIT>' <EOL> for ind in self . sail ( ) : <EOL> if ind . name in args : <EOL> data = '<STR_LIT>' % ( data , delim , ind ) <EOL> return data <EOL> def fst ( self , name , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> seq = self . find ( name , * args ) <EOL> try : <EOL> item = seq . next ( ) <EOL> except StopIteration : <EOL> return None <EOL> else : <EOL> return item <EOL> def fst_with_root ( self , name , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> seq = self . find_with_root ( name , * args ) <EOL> try : <EOL> item = seq . next ( ) <EOL> except StopIteration : <EOL> return None <EOL> else : <EOL> return item <EOL> def text ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . join ( '<STR_LIT>' , DATA ) <EOL> def write ( self , filename ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fd = open ( filename , '<STR_LIT:w>' ) <EOL> fd . write ( self ) <EOL> fd . close ( ) <EOL> def sail_with_root ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for indi in self [ : ] : <EOL> for indj in indi . sail_with_root ( ) : <EOL> yield ( indj ) <EOL> yield ( ( self , indi ) ) <EOL> def walk ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for ind in self . sail ( ) : <EOL> yield ( ind , ind . name , ind . attr ) <EOL> def walk_with_root ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for root , ind in self . sail_with_root ( ) : <EOL> yield ( ( root , root . name , root . attr ) , <EOL> ( ind , ind . name , ind . attr ) ) <EOL> def insert_after ( self , y , k ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ind = self . index ( y ) <EOL> self . insert ( ind + <NUM_LIT:1> , k ) <EOL> def insert_before ( self , y , k ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ind = self . index ( y ) <EOL> self . insert ( ind , k ) <EOL> class Tag ( Root ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , name , attr = { } ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Root . __init__ ( self , name , attr ) <EOL> def __str__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> html = '<STR_LIT>' % ( self . name , self . attr ) <EOL> for ind in self : <EOL> html = '<STR_LIT>' % ( html , ind ) <EOL> html = html + '<STR_LIT>' % self . name <EOL> return html <EOL> class Data ( Root ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Root . __init__ ( self , DATA ) <EOL> self . data = data <EOL> def __str__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . data <EOL> def text ( self ) : <EOL> return self . data <EOL> class XTag ( Root ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , name , attr = { } ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Root . __init__ ( self , name , attr ) <EOL> def __str__ ( self ) : <EOL> html = '<STR_LIT>' % ( self . name , self . attr ) <EOL> return html <EOL> class Meta ( Root ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> def __init__ ( self , data ) : <EOL> Root . __init__ ( self , META ) <EOL> self . data = data <EOL> def __str__ ( self ) : <EOL> html = '<STR_LIT>' % self . data <EOL> return html <EOL> class Code ( Root ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> def __init__ ( self , data ) : <EOL> Root . __init__ ( self , CODE ) <EOL> self . data = data <EOL> def __str__ ( self ) : <EOL> html = '<STR_LIT>' % self . data <EOL> return html <EOL> class Amp ( Root ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> def __init__ ( self , data ) : <EOL> Root . __init__ ( self , AMP ) <EOL> self . data = data <EOL> def __str__ ( self ) : <EOL> html = '<STR_LIT>' % self . data <EOL> return html <EOL> class Pi ( Root ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> def __init__ ( self , data ) : <EOL> Root . __init__ ( self , PI ) <EOL> self . data = data <EOL> def __str__ ( self ) : <EOL> html = '<STR_LIT>' % self . data <EOL> return html <EOL> class Comment ( Root ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> def __init__ ( self , data ) : <EOL> Root . __init__ ( self , COMMENT ) <EOL> self . data = data <EOL> def __str__ ( self ) : <EOL> html = '<STR_LIT>' % self . data <EOL> return html <EOL> class Tree ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . outmost = Root ( '<STR_LIT>' ) <EOL> self . stack = deque ( ) <EOL> self . stack . append ( self . outmost ) <EOL> def clear ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . outmost = Root ( '<STR_LIT>' ) <EOL> self . stack . clear ( ) <EOL> self . stack . append ( self . outmost ) <EOL> def last ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . stack [ - <NUM_LIT:1> ] <EOL> def nest ( self , name , attr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> item = Tag ( name , attr ) <EOL> pointer = self . stack . pop ( ) <EOL> pointer . append ( item ) <EOL> self . stack . append ( pointer ) <EOL> self . stack . append ( item ) <EOL> def dnest ( self , data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> top = self . last ( ) <EOL> item = Data ( data ) <EOL> top . append ( item ) <EOL> def xnest ( self , name , attr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> top = self . last ( ) <EOL> item = XTag ( name , attr ) <EOL> top . append ( item ) <EOL> def ynest ( self , data ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> top = self . last ( ) <EOL> item = Meta ( data ) <EOL> top . append ( item ) <EOL> def mnest ( self , data ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> top = self . last ( ) <EOL> item = Comment ( data ) <EOL> top . append ( item ) <EOL> def cnest ( self , data ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> top = self . last ( ) <EOL> item = Code ( data ) <EOL> top . append ( item ) <EOL> def rnest ( self , data ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> top = self . last ( ) <EOL> item = Amp ( data ) <EOL> top . append ( item ) <EOL> def inest ( self , data ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> top = self . last ( ) <EOL> item = Pi ( data ) <EOL> top . append ( item ) <EOL> def enclose ( self , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> count = <NUM_LIT:0> <EOL> for ind in reversed ( self . stack ) : <EOL> count = count + <NUM_LIT:1> <EOL> if ind . name == name : <EOL> break <EOL> else : <EOL> count = <NUM_LIT:0> <EOL> for i in xrange ( <NUM_LIT:0> , count ) : <EOL> self . stack . pop ( ) <EOL> class Html ( HTMLParser ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> HTMLParser . __init__ ( self ) <EOL> self . struct = Tree ( ) <EOL> def fromfile ( self , filename ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fd = open ( fname , '<STR_LIT:r>' ) <EOL> data = fd . read ( ) <EOL> fd . close ( ) <EOL> return self . feed ( data ) <EOL> def feed ( self , data ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> self . struct . clear ( ) <EOL> HTMLParser . feed ( self , data ) <EOL> return self . struct . outmost <EOL> def handle_starttag ( self , name , attr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . struct . nest ( name , attr ) <EOL> pass <EOL> def handle_startendtag ( self , name , attr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "self . struct . xnest ( name , attr )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from pprint import pprint <EOL> import rasterio <EOL>", "answer": "import numpy as np"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from . exceptions import * <EOL> from . utils import * <EOL> import logging <EOL> import time <EOL> from datetime import datetime <EOL> class Alias ( object ) : <EOL> def __init__ ( self , name = None , extra_settings = { } ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not name : <EOL> raise MissingArgument ( '<STR_LIT>' ) <EOL> self . name = parse_date_pattern ( name ) <EOL> self . actions = [ ] <EOL> self . client = None <EOL> self . extra_settings = extra_settings <EOL> self . loggit = logging . getLogger ( '<STR_LIT>' ) <EOL> def add ( self , ilo ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> verify_index_list ( ilo ) <EOL> if not self . client : <EOL> self . client = ilo . client <EOL> ilo . empty_list_check ( ) <EOL> for index in ilo . working_list ( ) : <EOL> self . loggit . debug ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' . format ( index , self . name , self . extra_settings ) <EOL>", "answer": ")"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import re <EOL> import warnings <EOL> try : <EOL> from unittest2 import TestCase as BaseTestCase <EOL> except ImportError : <EOL> from unittest import TestCase as BaseTestCase <EOL> try : <EOL> from datadiff . tools import assert_equal as datadiff_assert_equal <EOL> except ImportError : <EOL> datadiff_assert_equal = None <EOL> try : <EOL> from nose import tools <EOL> except ImportError : <EOL> tools = type ( '<STR_LIT>' , ( object , ) , { '<STR_LIT>' : [ ] } ) <EOL> from tddspry . utils import * <EOL> __all__ = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> class BaseTestCaseMetaclass ( type ) : <EOL> def __new__ ( cls , name , bases , attrs ) : <EOL> for base in bases : <EOL> for base_name in dir ( base ) : <EOL> base_value = getattr ( base , base_name ) <EOL> if not callable ( base_value ) or not base_name . startswith ( '<STR_LIT>' ) : <EOL> continue <EOL> if not base_name in attrs : <EOL> attrs . update ( { base_name : base_value } ) <EOL> for attr_name , attr_value in attrs . items ( ) : <EOL> if not attr_name . startswith ( '<STR_LIT>' ) or attr_name == '<STR_LIT>' : <EOL> continue <EOL> if attr_name [ <NUM_LIT:6> ] == '<STR_LIT:_>' : <EOL> new_name = underscore_to_camelcase ( attr_name ) <EOL> else : <EOL> new_name = camelcase_to_underscore ( attr_name ) <EOL> if not new_name in attrs : <EOL> attrs [ new_name ] = attr_value <EOL> for attr in tools . __all__ : <EOL> attrs . update ( { attr : getattr ( tools , attr ) } ) <EOL> attrs [ attr ] = staticmethod ( attrs [ attr ] ) <EOL> if datadiff_assert_equal : <EOL> key = attrs . get ( '<STR_LIT>' , False ) and '<STR_LIT>' or '<STR_LIT>' <EOL> attrs . update ( { key : datadiff_assert_equal } ) <EOL> attrs [ key ] = staticmethod ( attrs [ key ] ) <EOL> elif attrs . get ( '<STR_LIT>' , False ) : <EOL> warnings . warn ( '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' ) <EOL> return type . __new__ ( cls , name , bases , attrs ) <EOL> class TestCaseMetaclass ( BaseTestCaseMetaclass ) : <EOL> def __new__ ( cls , name , bases , attrs ) : <EOL> for attr_name , attr_value in attrs . items ( ) : <EOL> if attr_name == '<STR_LIT>' and not '<STR_LIT>' in attrs : <EOL> attrs [ '<STR_LIT>' ] = attr_value <EOL> if attr_name == '<STR_LIT>' and not '<STR_LIT>' in attrs : <EOL> attrs [ '<STR_LIT>' ] = attr_value <EOL> return super ( TestCaseMetaclass , cls ) . __new__ ( cls , name , bases , attrs ) <EOL> class TestCase ( BaseTestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __metaclass__ = TestCaseMetaclass <EOL> def assert_not_unicode ( self , first , second , message = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . assert_not_equal ( unicode ( first ) , unicode ( second ) , message ) <EOL>", "answer": "def assert_unicode ( self , first , second , message = None ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys <EOL> import unittest <EOL> from StringIO import StringIO <EOL> class CrashMailTests ( unittest . TestCase ) : <EOL> def _getTargetClass ( self ) : <EOL> from superlance . crashmail import CrashMail <EOL> return CrashMail <EOL> def _makeOne ( self , * opts ) : <EOL> return self . _getTargetClass ( ) ( * opts ) <EOL> def setUp ( self ) : <EOL> import tempfile <EOL> self . tempdir = tempfile . mkdtemp ( ) <EOL> def tearDown ( self ) : <EOL> import shutil <EOL> shutil . rmtree ( self . tempdir ) <EOL> def _makeOnePopulated ( self , programs , any , response = None ) : <EOL> import os <EOL> sendmail = '<STR_LIT>' % os . path . join ( self . tempdir , '<STR_LIT>' ) <EOL> email = '<STR_LIT>' <EOL> header = '<STR_LIT>' <EOL> prog = self . _makeOne ( programs , any , email , sendmail , header ) <EOL> prog . stdin = StringIO ( ) <EOL> prog . stdout = StringIO ( ) <EOL> prog . stderr = StringIO ( ) <EOL> return prog <EOL> def test_runforever_not_process_state_exited ( self ) : <EOL> programs = { '<STR_LIT:foo>' : <NUM_LIT:0> , '<STR_LIT:bar>' : <NUM_LIT:0> , '<STR_LIT>' : <NUM_LIT:0> } <EOL> groups = { } <EOL> any = None <EOL> prog = self . _makeOnePopulated ( programs , any ) <EOL> prog . stdin . write ( '<STR_LIT>' ) <EOL> prog . stdin . seek ( <NUM_LIT:0> ) <EOL> prog . runforever ( test = True ) <EOL> self . assertEqual ( prog . stderr . getvalue ( ) , '<STR_LIT>' ) <EOL> def test_runforever_expected_exit ( self ) : <EOL> programs = [ '<STR_LIT:foo>' ] <EOL> any = None <EOL> prog = self . _makeOnePopulated ( programs , any ) <EOL> payload = ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> prog . stdin . write ( <EOL> '<STR_LIT>' % len ( payload ) ) <EOL> prog . stdin . write ( payload ) <EOL> prog . stdin . seek ( <NUM_LIT:0> ) <EOL> prog . runforever ( test = True ) <EOL> self . assertEqual ( prog . stderr . getvalue ( ) , '<STR_LIT>' ) <EOL> def test_runforever_unexpected_exit ( self ) : <EOL> programs = [ '<STR_LIT:foo>' ] <EOL> any = None <EOL> prog = self . _makeOnePopulated ( programs , any ) <EOL> payload = ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> prog . stdin . write ( <EOL> '<STR_LIT>' % len ( payload ) ) <EOL> prog . stdin . write ( payload ) <EOL> prog . stdin . seek ( <NUM_LIT:0> ) <EOL> prog . runforever ( test = True ) <EOL> output = prog . stderr . getvalue ( ) <EOL> lines = output . split ( '<STR_LIT:\\n>' ) <EOL> self . assertEqual ( lines [ <NUM_LIT:0> ] , '<STR_LIT>' ) <EOL> self . assertEqual ( lines [ <NUM_LIT:1> ] , '<STR_LIT>' ) <EOL> self . assertEqual ( lines [ <NUM_LIT:2> ] , '<STR_LIT>' ) <EOL> self . assertEqual ( lines [ <NUM_LIT:3> ] , '<STR_LIT>' ) <EOL> self . failUnless ( '<STR_LIT>' in lines [ <NUM_LIT:4> ] ) <EOL> self . assertEqual ( lines [ <NUM_LIT:5> ] , '<STR_LIT>' ) <EOL> self . failUnless ( <EOL>", "answer": "'<STR_LIT>' in lines [ <NUM_LIT:6> ] )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import with_statement <EOL> import unicodedata <EOL> import re <EOL> import os . path <EOL> from functools import wraps <EOL> from flask import session , url_for , redirect , request , flash <EOL> from simblin . lib import markdown2 <EOL> def static ( filename ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> filepath = os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT>' , filename ) <EOL> last_modification = '<STR_LIT>' % os . path . getmtime ( filepath ) <EOL> return url_for ( '<STR_LIT>' , filename = filename ) + '<STR_LIT:?>' + last_modification <EOL> def login_required ( f ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ wraps ( f ) <EOL> def decorated_function ( * args , ** kwargs ) : <EOL> if not session . get ( '<STR_LIT>' ) : <EOL> flash ( '<STR_LIT>' , '<STR_LIT:error>' ) <EOL> return redirect ( url_for ( '<STR_LIT>' , next = request . url ) ) <EOL> return f ( * args , ** kwargs ) <EOL> return decorated_function <EOL> def normalize ( string ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> string = unicodedata . normalize ( \"<STR_LIT>\" , unicode ( string ) ) . encode ( <EOL> \"<STR_LIT:ascii>\" , \"<STR_LIT:ignore>\" ) <EOL> string = re . sub ( r\"<STR_LIT>\" , \"<STR_LIT:U+0020>\" , string ) <EOL> string = \"<STR_LIT:->\" . join ( string . lower ( ) . strip ( ) . split ( ) ) <EOL> return string <EOL> def normalize_tags ( string ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> tags = string . split ( '<STR_LIT:U+002C>' ) <EOL> result = [ ] <EOL> for tag in tags : <EOL> normalized = normalize ( tag ) <EOL> if normalized and not normalized in result : <EOL> result . append ( normalized ) <EOL> return result <EOL> def convert_markup ( string ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "return markdown2 . markdown ( string ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import numpy as np <EOL> from numpy . testing import assert_almost_equal <EOL> from menpo . math import eigenvalue_decomposition , pca , ipca <EOL> cov_matrix = np . array ( [ [ <NUM_LIT:3> , <NUM_LIT:1> ] , [ <NUM_LIT:1> , <NUM_LIT:3> ] ] ) <EOL> large_samples_data_matrix = np . array ( [ [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT:0.5> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT:1.0> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] ] ) <EOL> centered_eigenvectors_s = np . array ( [ [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ - <NUM_LIT> , <NUM_LIT> ] ] ) <EOL> non_centered_eigenvectors_s = np . array ( [ [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ - <NUM_LIT> , <NUM_LIT> ] ] ) <EOL> mean_vector_s = np . array ( [ <NUM_LIT> , <NUM_LIT> ] ) <EOL> eigenvalues_no_centre_s = np . array ( [ <NUM_LIT> , <NUM_LIT> ] ) <EOL> eigenvalues_centered_s = np . array ( [ <NUM_LIT> , <NUM_LIT> ] ) <EOL> centered_eigenvectors_f = np . array ( [ [ - <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , - <NUM_LIT> , <NUM_LIT> , <EOL> - <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> - <NUM_LIT> ] ] ) <EOL> non_centered_eigenvectors_f = np . array ( <EOL> [ [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] , <EOL> [ - <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , - <NUM_LIT> , <NUM_LIT> , <EOL> - <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , - <NUM_LIT> ] ] ) <EOL> mean_vector_f = np . array ( [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:1.> ] ) <EOL> eigenvalues_no_centre_f = np . array ( [ <NUM_LIT> , <NUM_LIT> ] ) <EOL> eigenvalues_centered_f = np . array ( [ <NUM_LIT> ] ) <EOL> def pcd_samples_nocentre_test ( ) : <EOL> output = pca ( large_samples_data_matrix , centre = False ) <EOL> eigenvectors , eigenvalues , mean_vector = output <EOL> assert_almost_equal ( eigenvalues , eigenvalues_no_centre_s ) <EOL> assert_almost_equal ( eigenvectors , non_centered_eigenvectors_s ) <EOL> assert_almost_equal ( mean_vector , [ <NUM_LIT:0.0> , <NUM_LIT:0.0> ] ) <EOL> def pcd_samples_yescentre_test ( ) : <EOL> output = pca ( large_samples_data_matrix , centre = True ) <EOL> eigenvectors , eigenvalues , mean_vector = output <EOL> assert_almost_equal ( eigenvalues , eigenvalues_centered_s ) <EOL> assert_almost_equal ( eigenvectors , centered_eigenvectors_s ) <EOL> assert_almost_equal ( mean_vector , mean_vector_s ) <EOL> def pcd_features_nocentre_test ( ) : <EOL> output = pca ( large_samples_data_matrix . T , centre = False ) <EOL> eigenvectors , eigenvalues , mean_vector = output <EOL> assert_almost_equal ( eigenvalues , eigenvalues_no_centre_f ) <EOL> assert_almost_equal ( eigenvectors , non_centered_eigenvectors_f ) <EOL> assert_almost_equal ( mean_vector , np . zeros ( <NUM_LIT:10> ) ) <EOL> def pcd_features_nocentre_inplace_test ( ) : <EOL> output = pca ( large_samples_data_matrix . T . copy ( ) , centre = False , <EOL> inplace = True ) <EOL> eigenvectors , eigenvalues , mean_vector = output <EOL> assert_almost_equal ( eigenvalues , eigenvalues_no_centre_f ) <EOL> assert_almost_equal ( eigenvectors , non_centered_eigenvectors_f ) <EOL> assert_almost_equal ( mean_vector , np . zeros ( <NUM_LIT:10> ) ) <EOL> def pcd_features_yescentre_test ( ) : <EOL> output = pca ( large_samples_data_matrix . T , centre = True ) <EOL> eigenvectors , eigenvalues , mean_vector = output <EOL> assert_almost_equal ( eigenvalues , eigenvalues_centered_f ) <EOL> assert_almost_equal ( eigenvectors , centered_eigenvectors_f ) <EOL> assert_almost_equal ( mean_vector , mean_vector_f ) <EOL> def eigenvalue_decomposition_default_epsilon_test ( ) : <EOL> pos_eigenvectors , pos_eigenvalues = eigenvalue_decomposition ( cov_matrix ) <EOL> assert_almost_equal ( pos_eigenvalues , [ <NUM_LIT> , <NUM_LIT> ] ) <EOL> sqrt_one_over_2 = np . sqrt ( <NUM_LIT> ) / <NUM_LIT> <EOL> assert_almost_equal ( pos_eigenvectors , [ [ sqrt_one_over_2 , - sqrt_one_over_2 ] , <EOL> [ sqrt_one_over_2 , sqrt_one_over_2 ] ] ) <EOL> def eigenvalue_decomposition_large_epsilon_test ( ) : <EOL> pos_eigenvectors , pos_eigenvalues = eigenvalue_decomposition ( cov_matrix , <EOL> eps = <NUM_LIT:0.5> ) <EOL> assert_almost_equal ( pos_eigenvalues , [ <NUM_LIT> ] ) <EOL> sqrt_one_over_2 = np . sqrt ( <NUM_LIT> ) / <NUM_LIT> <EOL> assert_almost_equal ( pos_eigenvectors , <EOL> [ [ sqrt_one_over_2 ] , [ sqrt_one_over_2 ] ] ) <EOL> def ipca_samples_yescentre_test ( ) : <EOL>", "answer": "n_a = large_samples_data_matrix . shape [ <NUM_LIT:0> ] / <NUM_LIT:2>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import urllib <EOL> import tempfile <EOL> from lookups import Lookup <EOL> from core import GsxObject , GsxError <EOL> REASON_CODES = ( <EOL> ( '<STR_LIT:A>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT:B>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT:C>' , '<STR_LIT>' ) , <EOL>", "answer": "( '<STR_LIT:D>' , '<STR_LIT>' ) ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import platform <EOL>", "answer": "print type ( platform . python_implementation ( ) ) "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import cPickle as pickle <EOL> import numpy as np <EOL> import theano <EOL> from sparse_coding . sparse_coding_gammatone import gammatone_matrix , erb_space <EOL> def gen_phone ( mdl ) : <EOL> X = theano . tensor . dmatrix ( '<STR_LIT:X>' ) <EOL> P = theano . tensor . dmatrix ( '<STR_LIT:P>' ) <EOL> y = mdl . fprop ( [ X , P ] ) <EOL> predict = theano . function ( [ X , P ] , y ) <EOL> resolution = <NUM_LIT> <EOL> step = <NUM_LIT:64> <EOL> b = <NUM_LIT> <EOL> n_channels = <NUM_LIT:64> <EOL> D_multi = np . r_ [ tuple ( gammatone_matrix ( b , fc , resolution , step ) for <EOL> fc in erb_space ( <NUM_LIT> , <NUM_LIT> , n_channels ) ) ] <EOL> phones = np . load ( '<STR_LIT>' ) <EOL> X = np . asmatrix ( ( len ( phones ) , np . zeros ( <NUM_LIT> ) ) ) <EOL> phone_code = np . asmatrix ( ( len ( phones ) , np . zeros ( <NUM_LIT:3> * <NUM_LIT> ) ) ) <EOL> for pi , p in enumerate ( phones ) : <EOL>", "answer": "phone_code [ pi , [ p [ <NUM_LIT:0> ] , p [ <NUM_LIT:1> ] + <NUM_LIT> , p [ <NUM_LIT:2> ] + <NUM_LIT:2> * <NUM_LIT> ] ] = <NUM_LIT:1>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from kaa import bot <EOL> from urllib import quote <EOL> import json <EOL>", "answer": "import requests"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from simpleapi import Namespace <EOL> class MyAPI ( Namespace ) : <EOL> __authentication__ = lambda ns , key : key == \"<STR_LIT>\" <EOL> def add ( self , a , b ) : <EOL> return a + b <EOL> add . published = True <EOL> add . constraints = lambda ns , key , value : int ( value ) <EOL> def test ( self ) : <EOL> self . error ( u'<STR_LIT>' ) <EOL>", "answer": "test . published = True "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os . path <EOL> from sfmigration . common . softwarefactory import SFRedmineMigrator <EOL> from sfmigration . common import utils <EOL> from sfmigration . issues . github import GithubImporter <EOL> logger = utils . logger <EOL> def get_values ( config_file = '<STR_LIT>' ) : <EOL> if not os . path . isfile ( config_file ) : <EOL> logger . error ( \"<STR_LIT>\" ) <EOL> raise <EOL> source_github = { '<STR_LIT:username>' : '<STR_LIT>' , <EOL> '<STR_LIT:password>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' } <EOL> for key in source_github . iterkeys ( ) : <EOL> source_github [ key ] = utils . get_config_value ( config_file , <EOL> '<STR_LIT>' , key ) <EOL> dest_redmine = { '<STR_LIT:username>' : '<STR_LIT>' , '<STR_LIT:password>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : '<STR_LIT>' , '<STR_LIT:url>' : '<STR_LIT>' , '<STR_LIT:name>' : '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : [ ] ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> from urlparse import urlparse <EOL> except ImportError : <EOL> from urllib . parse import urlparse <EOL> __version__ = '<STR_LIT>' <EOL> __author__ = '<STR_LIT>' <EOL> __all__ = ( '<STR_LIT>' , ) <EOL> def turbolinks ( app ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from flask import request , session <EOL> app . wsgi_app = TurbolinksMiddleware ( app . wsgi_app ) <EOL> @ app . after_request <EOL> def turbolinks_response ( response ) : <EOL> referrer = request . headers . get ( '<STR_LIT>' ) <EOL> if not referrer : <EOL> return response <EOL> method = request . cookies . get ( '<STR_LIT>' , None ) <EOL> if not method or method != request . method : <EOL> response . set_cookie ( '<STR_LIT>' , request . method ) <EOL> if '<STR_LIT>' in response . headers : <EOL> loc = response . headers [ '<STR_LIT>' ] <EOL> session [ '<STR_LIT>' ] = loc <EOL> if referrer and not same_origin ( loc , referrer ) : <EOL> response . status_code = <NUM_LIT:200> <EOL> response . data = ( <EOL> '<STR_LIT>' <EOL> ) % loc <EOL> else : <EOL> if '<STR_LIT>' in session : <EOL> loc = session . pop ( '<STR_LIT>' ) <EOL> response . headers [ '<STR_LIT>' ] = loc <EOL> return response <EOL> return app <EOL> class TurbolinksMiddleware ( object ) : <EOL> def __init__ ( self , app ) : <EOL> self . app = app <EOL> def __call__ ( self , environ , start_response ) : <EOL> referrer = environ . get ( '<STR_LIT>' ) <EOL> if referrer : <EOL> environ [ '<STR_LIT>' ] = referrer <EOL> return self . app ( environ , start_response ) <EOL> def same_origin ( current_uri , redirect_uri ) : <EOL> parsed_uri = urlparse ( current_uri ) <EOL>", "answer": "if not parsed_uri . scheme :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from distutils . core import setup <EOL>", "answer": "from catkin_pkg . python_setup import generate_distutils_setup"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> from pants_test . projects . base_project_integration_test import ProjectIntegrationTest <EOL> class ExamplesIntegrationTest ( ProjectIntegrationTest ) : <EOL> def tests_examples ( self ) : <EOL> pants_run = self . pants_test ( [ '<STR_LIT>' ] ) <EOL>", "answer": "self . assert_success ( pants_run ) "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> import sublime <EOL> import sublime_plugin <EOL> try : <EOL> from . helpers import BaseBlockCommand <EOL> except ValueError : <EOL> from helpers import BaseBlockCommand <EOL> ORDER_LIST_PATTERN = re . compile ( r\"<STR_LIT>\" ) <EOL> UNORDER_LIST_PATTERN = re . compile ( r\"<STR_LIT>\" ) <EOL> EMPTY_LIST_PATTERN = re . compile ( r\"<STR_LIT>\" ) <EOL> NONLIST_PATTERN = re . compile ( r\"<STR_LIT>\" ) <EOL> ROMAN_PATTERN = re . compile ( r\"<STR_LIT>\" , <EOL> re . IGNORECASE ) <EOL> ROMAN_MAP = ( ( '<STR_LIT:M>' , <NUM_LIT:1000> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:D>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:C>' , <NUM_LIT:100> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:L>' , <NUM_LIT:50> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:X>' , <NUM_LIT:10> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT:9> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT:5> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT:4> ) , <EOL> ( '<STR_LIT:I>' , <NUM_LIT:1> ) ) <EOL> class RomanError ( Exception ) : pass <EOL> class NotIntegerError ( RomanError ) : pass <EOL> class InvalidRomanNumeralError ( RomanError ) : pass <EOL> def to_roman ( n ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not ( <NUM_LIT:0> < n < <NUM_LIT> ) : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> result = \"<STR_LIT>\" <EOL> for numeral , integer in ROMAN_MAP : <EOL> while n >= integer : <EOL> result += numeral <EOL> n -= integer <EOL> return result <EOL> def from_roman ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = <NUM_LIT:0> <EOL> index = <NUM_LIT:0> <EOL> for numeral , integer in ROMAN_MAP : <EOL> while s [ index : index + len ( numeral ) ] == numeral : <EOL> result += integer <EOL> index += len ( numeral ) <EOL> return result <EOL> class SmartListCommand ( BaseBlockCommand ) : <EOL> def run ( self , edit ) : <EOL> def update_ordered_list ( lines ) : <EOL> new_lines = [ ] <EOL> next_num = None <EOL> kind = lambda a : a <EOL> for line in lines : <EOL> match = ORDER_LIST_PATTERN . match ( line ) <EOL> if not match : <EOL> new_lines . append ( line ) <EOL> continue <EOL> new_line = match . group ( <NUM_LIT:1> ) + ( kind ( next_num ) or match . group ( <NUM_LIT:2> ) ) + match . group ( <NUM_LIT:3> ) + match . group ( <NUM_LIT:4> ) <EOL> new_lines . append ( new_line ) <EOL> if not next_num : <EOL> try : <EOL> next_num = int ( match . group ( <NUM_LIT:2> ) ) <EOL> kind = str <EOL> except ValueError : <EOL> next_num = ord ( match . group ( <NUM_LIT:2> ) ) <EOL> kind = chr <EOL> next_num += <NUM_LIT:1> <EOL> return new_lines <EOL> def update_roman_list ( lines ) : <EOL> new_lines = [ ] <EOL> next_num = None <EOL> kind = lambda a : a <EOL> for line in lines : <EOL> match = ROMAN_PATTERN . match ( line ) <EOL> if not match : <EOL> new_lines . append ( line ) <EOL> continue <EOL> new_line = match . group ( <NUM_LIT:1> ) + ( kind ( next_num ) or match . group ( <NUM_LIT:2> ) ) + match . group ( <NUM_LIT:3> ) + match . group ( <NUM_LIT:4> ) <EOL> new_lines . append ( new_line ) <EOL> if not next_num : <EOL> actual = match . group ( <NUM_LIT:2> ) <EOL> next_num = from_roman ( actual . upper ( ) ) <EOL> if actual == actual . lower ( ) : <EOL> kind = lambda a : to_roman ( a ) . lower ( ) <EOL> else : <EOL> kind = to_roman <EOL> next_num += <NUM_LIT:1> <EOL> return new_lines <EOL> for region in self . view . sel ( ) : <EOL> line_region = self . view . line ( region ) <EOL> before_point_region = sublime . Region ( line_region . a , <EOL> region . a ) <EOL> before_point_content = self . view . substr ( before_point_region ) <EOL> folded = False <EOL> for i in self . view . folded_regions ( ) : <EOL> if i . contains ( before_point_region ) : <EOL> self . view . insert ( edit , region . a , '<STR_LIT:\\n>' ) <EOL> folded = True <EOL> if folded : <EOL> break <EOL> match = EMPTY_LIST_PATTERN . match ( before_point_content ) <EOL> if match : <EOL> insert_text = match . group ( <NUM_LIT:1> ) + re . sub ( r'<STR_LIT>' , '<STR_LIT:U+0020>' , str ( match . group ( <NUM_LIT:2> ) ) ) + match . group ( <NUM_LIT:3> ) <EOL> self . view . erase ( edit , before_point_region ) <EOL> self . view . insert ( edit , line_region . a , insert_text ) <EOL> break <EOL> match = ROMAN_PATTERN . match ( before_point_content ) <EOL> if match : <EOL> actual = match . group ( <NUM_LIT:2> ) <EOL> next_num = to_roman ( from_roman ( actual . upper ( ) ) + <NUM_LIT:1> ) <EOL> if actual == actual . lower ( ) : <EOL> next_num = next_num . lower ( ) <EOL> insert_text = match . group ( <NUM_LIT:1> ) + next_num + match . group ( <NUM_LIT:3> ) <EOL> self . view . insert ( edit , region . a , \"<STR_LIT:\\n>\" + insert_text ) <EOL> pos = self . view . sel ( ) [ <NUM_LIT:0> ] . a <EOL> region , lines , indent = self . get_block_bounds ( ) <EOL> new_list = update_roman_list ( lines ) <EOL> self . view . replace ( edit , region , '<STR_LIT:\\n>' . join ( new_list ) + '<STR_LIT:\\n>' ) <EOL> self . view . sel ( ) . clear ( ) <EOL> self . view . sel ( ) . add ( sublime . Region ( pos , pos ) ) <EOL> self . view . show ( pos ) <EOL> break <EOL> match = ORDER_LIST_PATTERN . match ( before_point_content ) <EOL> if match : <EOL>", "answer": "try :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import print_function <EOL> __author__ = '<STR_LIT>' <EOL> from pybrain . rl . environments import EpisodicTask <EOL> from pybrain . rl . environments . ode . sensors import SpecificBodyPositionSensor <EOL> from scipy import tanh , zeros , array , random , sqrt , asarray <EOL> class CCRLTask ( EpisodicTask ) : <EOL> def __init__ ( self , env ) : <EOL> EpisodicTask . __init__ ( self , env ) <EOL> self . maxPower = <NUM_LIT> <EOL> self . reward_history = [ ] <EOL> self . count = <NUM_LIT:0> <EOL> self . epiLen = <NUM_LIT> <EOL> self . incLearn = <NUM_LIT:0> <EOL> self . env . FricMu = <NUM_LIT> <EOL> self . env . dt = <NUM_LIT> <EOL> self . sensor_limits = [ ] <EOL> for i in range ( self . env . actLen ) : <EOL> self . sensor_limits . append ( ( self . env . cLowList [ i ] , self . env . cHighList [ i ] ) ) <EOL> for i in range ( self . env . actLen ) : <EOL> self . sensor_limits . append ( ( - <NUM_LIT:20> , <NUM_LIT:20> ) ) <EOL> self . actor_limits = [ ( - <NUM_LIT:1> , <NUM_LIT:1> ) ] * env . actLen <EOL> self . oldAction = zeros ( env . actLen , float ) <EOL> self . dist = zeros ( <NUM_LIT:9> , float ) <EOL> self . dif = array ( [ <NUM_LIT:0.0> , <NUM_LIT:0.0> , <NUM_LIT:0.0> ] ) <EOL> self . target = array ( [ - <NUM_LIT> , <NUM_LIT> , - <NUM_LIT> ] ) <EOL> self . grepRew = <NUM_LIT:0.0> <EOL> self . tableFlag = <NUM_LIT:0.0> <EOL> self . env . addSensor ( SpecificBodyPositionSensor ( [ '<STR_LIT>' ] , \"<STR_LIT>\" ) ) <EOL> self . env . addSensor ( SpecificBodyPositionSensor ( [ '<STR_LIT>' ] , \"<STR_LIT>\" ) ) <EOL> self . env . addSensor ( SpecificBodyPositionSensor ( [ '<STR_LIT>' ] , \"<STR_LIT>\" ) ) <EOL> self . env . addSensor ( SpecificBodyPositionSensor ( [ '<STR_LIT>' ] , \"<STR_LIT>\" ) ) <EOL> self . env . obsLen = len ( self . env . getSensors ( ) ) <EOL> for i in range ( self . env . obsLen - <NUM_LIT:2> * self . env . actLen ) : <EOL> self . sensor_limits . append ( ( - <NUM_LIT:4> , <NUM_LIT:4> ) ) <EOL> self . actor_limits = None <EOL> def getObservation ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> sensors = self . env . getSensors ( ) <EOL> for i in range ( <NUM_LIT:3> ) : <EOL> self . dist [ i ] = ( ( sensors [ self . env . obsLen - <NUM_LIT:9> + i ] + sensors [ self . env . obsLen - <NUM_LIT:6> + i ] + sensors [ self . env . obsLen - <NUM_LIT:3> + i ] ) / <NUM_LIT> - ( sensors [ self . env . obsLen - <NUM_LIT:12> + i ] + self . dif [ i ] ) ) * <NUM_LIT> <EOL> for i in range ( <NUM_LIT:3> ) : <EOL> self . dist [ i + <NUM_LIT:3> ] = ( sensors [ self . env . obsLen - <NUM_LIT:3> + i ] - sensors [ self . env . obsLen - <NUM_LIT:6> + i ] ) * <NUM_LIT> <EOL> for i in range ( <NUM_LIT:3> ) : <EOL> self . dist [ i + <NUM_LIT:6> ] = ( ( sensors [ self . env . obsLen - <NUM_LIT:3> + i ] + sensors [ self . env . obsLen - <NUM_LIT:6> + i ] ) / <NUM_LIT> - sensors [ self . env . obsLen - <NUM_LIT:9> + i ] ) * <NUM_LIT> <EOL> if self . sensor_limits : <EOL> sensors = self . normalize ( sensors ) <EOL> sens = [ ] <EOL> for i in range ( self . env . obsLen - <NUM_LIT:12> ) : <EOL> sens . append ( sensors [ i ] ) <EOL> for i in range ( <NUM_LIT:9> ) : <EOL> sens . append ( self . dist [ i ] ) <EOL> for i in self . oldAction : <EOL> sens . append ( i ) <EOL> return sens <EOL> def performAction ( self , action ) : <EOL> self . oldAction = action <EOL> if abs ( abs ( self . dist [ : <NUM_LIT:3> ] ) . sum ( ) ) < <NUM_LIT> : action [ <NUM_LIT:15> ] = <NUM_LIT:1.0> <EOL> else : action [ <NUM_LIT:15> ] = - <NUM_LIT:1.0> <EOL> isJoints = array ( self . env . getSensorByName ( '<STR_LIT>' ) ) <EOL>", "answer": "isSpeeds = array ( self . env . getSensorByName ( '<STR_LIT>' ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from pyface . qt import QtGui , QtCore <EOL> from traits . api import Float , Any , Str , Trait <EOL> from traitsui . editors . api import RangeEditor <EOL> from traitsui . qt4 . editor import Editor <EOL> from traitsui . qt4 . extra . range_slider import RangeSlider <EOL> class _BoundsEditor ( Editor ) : <EOL> evaluate = Any <EOL> min = Any <EOL> max = Any <EOL> low = Any <EOL> high = Any <EOL> format = Str <EOL> def init ( self , parent ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> factory = self . factory <EOL> if not factory . low_name : <EOL> self . low = factory . low <EOL> if not factory . high_name : <EOL> self . high = factory . high <EOL> self . max = factory . max <EOL> self . min = factory . min <EOL> self . format = factory . format <EOL> self . evaluate = factory . evaluate <EOL> self . sync_value ( factory . evaluate_name , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . sync_value ( factory . low_name , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . sync_value ( factory . high_name , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . control = QtGui . QWidget ( ) <EOL> panel = QtGui . QHBoxLayout ( self . control ) <EOL> panel . setContentsMargins ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> self . _label_lo = QtGui . QLineEdit ( self . format % self . low ) <EOL> QtCore . QObject . connect ( self . _label_lo , QtCore . SIGNAL ( '<STR_LIT>' ) , <EOL> self . update_low_on_enter ) <EOL> panel . addWidget ( self . _label_lo ) <EOL> sh = self . _label_lo . sizeHint ( ) <EOL> sh . setWidth ( sh . width ( ) / <NUM_LIT:2> ) <EOL> self . _label_lo . setMaximumSize ( sh ) <EOL> self . control . slider = slider = RangeSlider ( QtCore . Qt . Horizontal ) <EOL> slider . setTracking ( factory . auto_set ) <EOL> slider . setMinimum ( <NUM_LIT:0> ) <EOL> slider . setMaximum ( <NUM_LIT> ) <EOL> slider . setPageStep ( <NUM_LIT:1000> ) <EOL> slider . setSingleStep ( <NUM_LIT:100> ) <EOL> slider . setLow ( self . _convert_to_slider ( self . low ) ) <EOL> slider . setHigh ( self . _convert_to_slider ( self . high ) ) <EOL> QtCore . QObject . connect ( slider , QtCore . SIGNAL ( '<STR_LIT>' ) , <EOL> self . update_object_on_scroll ) <EOL> panel . addWidget ( slider ) <EOL> self . _label_hi = QtGui . QLineEdit ( self . format % self . high ) <EOL> QtCore . QObject . connect ( self . _label_hi , QtCore . SIGNAL ( '<STR_LIT>' ) , <EOL> self . update_high_on_enter ) <EOL> panel . addWidget ( self . _label_hi ) <EOL> sh = self . _label_hi . sizeHint ( ) <EOL> sh . setWidth ( sh . width ( ) / <NUM_LIT:2> ) <EOL> self . _label_hi . setMaximumSize ( sh ) <EOL> self . set_tooltip ( slider ) <EOL> self . set_tooltip ( self . _label_lo ) <EOL> self . set_tooltip ( self . _label_hi ) <EOL> def update_low_on_enter ( self ) : <EOL> try : <EOL> try : <EOL> low = eval ( unicode ( self . _label_lo . text ( ) ) . strip ( ) ) <EOL> if self . evaluate is not None : <EOL> low = self . evaluate ( low ) <EOL> except Exception as ex : <EOL> low = self . low <EOL> self . _label_lo . setText ( self . format % self . low ) <EOL> if not self . factory . is_float : <EOL> low = int ( low ) <EOL> if low > self . high : <EOL> low = self . high - self . _step_size ( ) <EOL> self . _label_lo . setText ( self . format % low ) <EOL> self . control . slider . setLow ( self . _convert_to_slider ( low ) ) <EOL> self . low = low <EOL> except : <EOL> pass <EOL> def update_high_on_enter ( self ) : <EOL> try : <EOL> try : <EOL> high = eval ( unicode ( self . _label_hi . text ( ) ) . strip ( ) ) <EOL> if self . evaluate is not None : <EOL> high = self . evaluate ( high ) <EOL> except : <EOL> high = self . high <EOL> self . _label_hi . setText ( self . format % self . high ) <EOL> if not self . factory . is_float : <EOL> high = int ( high ) <EOL> if high < self . low : <EOL> high = self . low + self . _step_size ( ) <EOL> self . _label_hi . setText ( self . format % high ) <EOL> self . control . slider . setHigh ( self . _convert_to_slider ( high ) ) <EOL> self . high = high <EOL> except : <EOL> pass <EOL> def update_object_on_scroll ( self , pos ) : <EOL> low = self . _convert_from_slider ( self . control . slider . low ( ) ) <EOL> high = self . _convert_from_slider ( self . control . slider . high ( ) ) <EOL> if self . factory . is_float : <EOL> self . low = low <EOL> self . high = high <EOL> else : <EOL> self . low = int ( low ) <EOL> self . high = int ( high ) <EOL> self . control . slider . setLow ( self . _convert_to_slider ( low ) ) <EOL> self . control . slider . setHigh ( self . _convert_to_slider ( high ) ) <EOL> def update_editor ( self ) : <EOL> return <EOL> def _check_max_and_min ( self ) : <EOL> if self . max is None : <EOL> self . max = self . high <EOL> if self . min is None : <EOL> self . min = self . low <EOL> def _step_size ( self ) : <EOL> slider_delta = self . control . slider . maximum ( ) - self . control . slider . minimum ( ) <EOL> range_delta = self . max - self . min <EOL> return float ( range_delta ) / slider_delta <EOL> def _convert_from_slider ( self , slider_val ) : <EOL> self . _check_max_and_min ( ) <EOL> return self . min + slider_val * self . _step_size ( ) <EOL> def _convert_to_slider ( self , value ) : <EOL> self . _check_max_and_min ( ) <EOL> return self . control . slider . minimum ( ) + ( value - self . min ) / self . _step_size ( ) <EOL> def _low_changed ( self , low ) : <EOL> if self . control is None : <EOL> return <EOL> if self . _label_lo is not None : <EOL> self . _label_lo . setText ( self . format % low ) <EOL> self . control . slider . setLow ( self . _convert_to_slider ( low ) ) <EOL> def _high_changed ( self , high ) : <EOL> if self . control is None : <EOL> return <EOL>", "answer": "if self . _label_hi is not None :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from lux . core import LuxCommand <EOL> class Command ( LuxCommand ) : <EOL> help = \"<STR_LIT>\" <EOL> def run ( self , options , ** params ) : <EOL> cache = self . app . cache_server <EOL> result = cache . clear ( ) <EOL> self . write ( '<STR_LIT>' % result ) <EOL>", "answer": "return result "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import threading <EOL> import socket <EOL> import sys <EOL> from hyper import HTTP20Connection <EOL> from hyper . compat import ssl <EOL> from hyper . http11 . connection import HTTP11Connection <EOL> from hpack . hpack import Encoder <EOL> from hpack . huffman import HuffmanEncoder <EOL> from hpack . huffman_constants import ( <EOL> REQUEST_CODES , REQUEST_CODES_LENGTH <EOL> ) <EOL> from hyper . tls import NPN_PROTOCOL <EOL> class SocketServerThread ( threading . Thread ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , <EOL> socket_handler , <EOL> host = '<STR_LIT:localhost>' , <EOL> ready_event = None , <EOL> h2 = True , <EOL> secure = True ) : <EOL> threading . Thread . __init__ ( self ) <EOL> self . socket_handler = socket_handler <EOL> self . host = host <EOL> self . secure = secure <EOL> self . ready_event = ready_event <EOL> self . daemon = True <EOL> if self . secure : <EOL> self . cxt = ssl . SSLContext ( ssl . PROTOCOL_SSLv23 ) <EOL> if ssl . HAS_NPN and h2 : <EOL> self . cxt . set_npn_protocols ( [ NPN_PROTOCOL ] ) <EOL> self . cxt . load_cert_chain ( certfile = '<STR_LIT>' , <EOL> keyfile = '<STR_LIT>' ) <EOL> def _start_server ( self ) : <EOL> sock = socket . socket ( ) <EOL> if sys . platform != '<STR_LIT:win32>' : <EOL> sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , <NUM_LIT:1> ) <EOL> if self . secure : <EOL> sock = self . cxt . wrap_socket ( sock , server_side = True ) <EOL> sock . bind ( ( self . host , <NUM_LIT:0> ) ) <EOL> self . port = sock . getsockname ( ) [ <NUM_LIT:1> ] <EOL> sock . listen ( <NUM_LIT:1> ) <EOL> if self . ready_event : <EOL> self . ready_event . set ( ) <EOL> self . socket_handler ( sock ) <EOL> sock . close ( ) <EOL> def _wrap_socket ( self , sock ) : <EOL> raise NotImplementedError ( ) <EOL> def run ( self ) : <EOL> self . server = self . _start_server ( ) <EOL> class SocketLevelTest ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def set_up ( self , secure = True , proxy = False ) : <EOL> self . host = None <EOL> self . port = None <EOL> self . secure = secure if not proxy else False <EOL> self . proxy = proxy <EOL> self . server_thread = None <EOL> def _start_server ( self , socket_handler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ready_event = threading . Event ( ) <EOL> self . server_thread = SocketServerThread ( <EOL> socket_handler = socket_handler , <EOL> ready_event = ready_event , <EOL> h2 = self . h2 , <EOL> secure = self . secure <EOL> ) <EOL> self . server_thread . start ( ) <EOL> ready_event . wait ( ) <EOL> self . host = self . server_thread . host <EOL> self . port = self . server_thread . port <EOL> self . secure = self . server_thread . secure <EOL> def get_connection ( self ) : <EOL> if self . h2 : <EOL> if not self . proxy : <EOL> return HTTP20Connection ( self . host , self . port , self . secure ) <EOL> else : <EOL> return HTTP20Connection ( '<STR_LIT>' , secure = self . secure , <EOL> proxy_host = self . host , <EOL> proxy_port = self . port ) <EOL> else : <EOL> if not self . proxy : <EOL> return HTTP11Connection ( self . host , self . port , self . secure ) <EOL> else : <EOL> return HTTP11Connection ( '<STR_LIT>' , secure = self . secure , <EOL> proxy_host = self . host , <EOL> proxy_port = self . port ) <EOL> def get_encoder ( self ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> __version__ = \"<STR_LIT>\" <EOL> __docformat__ = \"<STR_LIT>\" <EOL> import os <EOL>", "answer": "from distutils . core import setup"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL> from django . conf . urls import patterns <EOL>", "answer": "from . views import empty_view"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> def gt ( value , threshold ) : <EOL> return float ( value ) > float ( threshold ) <EOL>", "answer": "def lt ( value , threshold ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> LOG_LEVEL = \"<STR_LIT>\" <EOL> LOG_FILE = \"<STR_LIT>\" <EOL> SQLALCHEMY_DATABASE_URI = '<STR_LIT>' <EOL> SQLALCHEMY_POOL_SIZE = <NUM_LIT:50> <EOL> SQLALCHEMY_MAX_OVERFLOW = <NUM_LIT:15> <EOL> ENVIRONMENT = '<STR_LIT>' <EOL> USE_ROUTE53 = False <EOL> FQDN = '<STR_LIT>' <EOL>", "answer": "API_PORT = '<STR_LIT>'"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> __author__ = '<STR_LIT>' <EOL> import rethinkdb as r <EOL> class Pair ( object ) : <EOL> def __init__ ( self , timestamp1 , timestamp2 , direction ) : <EOL> self . timestamp1 = timestamp1 <EOL> self . timestamp2 = timestamp2 <EOL> self . direction = direction <EOL> def makeit_dict ( obj ) : <EOL> if isinstance ( obj , set ) : <EOL> return list ( obj ) <EOL> return obj . __dict__ <EOL> class MapperUtil ( ) : <EOL> @ staticmethod <EOL> def add_pair ( timestamp1 , timestamp2 , direction ) : <EOL> conn = r . connect ( \"<STR_LIT:localhost>\" , <NUM_LIT> ) <EOL> r . db ( '<STR_LIT:test>' ) . table ( \"<STR_LIT>\" ) . insert ( [ <EOL> { \"<STR_LIT>\" : timestamp1 , <EOL> \"<STR_LIT>\" : timestamp2 , <EOL> \"<STR_LIT>\" : direction <EOL> } <EOL>", "answer": "] ) . run ( conn )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __pyjamas__ import get_main_frame , doc , JS <EOL> sNextHashId = <NUM_LIT:0> <EOL> def getNextHashId ( ) : <EOL> global sNextHashId <EOL> sNextHashId += <NUM_LIT:1> <EOL> return sNextHashId <EOL> def getHashCode ( o ) : <EOL> JS ( \"\"\"<STR_LIT>\"\"\" ) <EOL> def getModuleName ( ) : <EOL> import os <EOL>", "answer": "import sys"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . conf . urls import patterns , include , url <EOL> from django . contrib . staticfiles . urls import staticfiles_urlpatterns <EOL> from django . views . generic import TemplateView <EOL> from django . contrib import admin <EOL> admin . autodiscover ( ) <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , TemplateView . as_view ( template_name = '<STR_LIT>' ) , <EOL> name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , TemplateView . as_view ( template_name = '<STR_LIT>' ) , <EOL> name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , include ( admin . site . urls ) ) , <EOL>", "answer": ")"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import numpy as np <EOL> from ... util . linalg import pdinv <EOL> from . posterior import Posterior <EOL> from . import LatentFunctionInference <EOL> log_2_pi = np . log ( <NUM_LIT:2> * np . pi ) <EOL> class VarGauss ( LatentFunctionInference ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , alpha , beta ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . alpha , self . beta = alpha , beta <EOL> def inference ( self , kern , X , likelihood , Y , mean_function = None , Y_metadata = None , Z = None ) : <EOL> if mean_function is not None : <EOL> raise NotImplementedError <EOL> num_data , output_dim = Y . shape <EOL> assert output_dim == <NUM_LIT:1> , \"<STR_LIT>\" <EOL> K = kern . K ( X ) <EOL> m = K . dot ( self . alpha ) <EOL> KB = K * self . beta [ : , None ] <EOL> BKB = KB * self . beta [ None , : ] <EOL> A = np . eye ( num_data ) + BKB <EOL> Ai , LA , _ , Alogdet = pdinv ( A ) <EOL> Sigma = np . diag ( self . beta ** - <NUM_LIT:2> ) - Ai / self . beta [ : , None ] / self . beta [ None , : ] <EOL> var = np . diag ( Sigma ) . reshape ( - <NUM_LIT:1> , <NUM_LIT:1> ) <EOL> F , dF_dm , dF_dv , dF_dthetaL = likelihood . variational_expectations ( Y , m , var , Y_metadata = Y_metadata ) <EOL> if dF_dthetaL is not None : <EOL> dL_dthetaL = dF_dthetaL . sum ( <NUM_LIT:1> ) . sum ( <NUM_LIT:1> ) <EOL> else : <EOL> dL_dthetaL = np . array ( [ ] ) <EOL> dF_da = np . dot ( K , dF_dm ) <EOL> SigmaB = Sigma * self . beta <EOL> dF_db = - <NUM_LIT:2> * np . sum ( Sigma ** <NUM_LIT:2> * ( dF_dv * self . beta ) , <NUM_LIT:0> ) <EOL> KL = <NUM_LIT:0.5> * ( Alogdet + np . trace ( Ai ) - num_data + np . sum ( m * self . alpha ) ) <EOL> dKL_da = m <EOL> A_A2 = Ai - Ai . dot ( Ai ) <EOL> dKL_db = np . diag ( np . dot ( KB . T , A_A2 ) ) <EOL>", "answer": "log_marginal = F . sum ( ) - KL"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import collections <EOL> import datetime <EOL> import random <EOL> import pretend <EOL> import pytest <EOL> from warehouse . legacy . api import xmlrpc <EOL> from warehouse . packaging . interfaces import IDownloadStatService <EOL> from warehouse . packaging . models import Classifier <EOL> from ... . common . db . accounts import UserFactory <EOL> from ... . common . db . packaging import ( <EOL> ProjectFactory , ReleaseFactory , FileFactory , RoleFactory , <EOL> JournalEntryFactory , <EOL> ) <EOL>", "answer": "class TestSearch :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import print_function <EOL>", "answer": "import os"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from lib . base import DockerBasePythonAction <EOL> __all__ = [ <EOL> '<STR_LIT>' <EOL> ] <EOL> class DockerPullImageAction ( DockerBasePythonAction ) : <EOL> def run ( self , repo , tag = None , insecure_registry = False , <EOL> auth_username_override = None , auth_password_override = None ) : <EOL> auth_override = ( auth_username_override and auth_password_override ) <EOL> if auth_override : <EOL> auth_config = { } <EOL> auth_config [ '<STR_LIT:username>' ] = auth_username_override <EOL> auth_config [ '<STR_LIT:password>' ] = auth_password_override <EOL> return self . wrapper . pull ( repo = repo , tag = tag , insecure_registry = insecure_registry , <EOL> auth_config = auth_config ) <EOL> else : <EOL>", "answer": "return self . wrapper . pull ( repo = repo , tag = tag , insecure_registry = insecure_registry ) "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> from geopy . compat import py3k <EOL> if not py3k : <EOL> NUMBER_TYPES = ( int , long , float ) <EOL> else : <EOL> NUMBER_TYPES = ( int , float ) <EOL> try : <EOL> from decimal import Decimal <EOL> NUMBER_TYPES = NUMBER_TYPES + ( Decimal , ) <EOL> except ImportError : <EOL> pass <EOL> __version__ = \"<STR_LIT>\" <EOL> class NullHandler ( logging . Handler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def emit ( self , record ) : <EOL> pass <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> logger . setLevel ( logging . CRITICAL ) <EOL>", "answer": "def pairwise ( seq ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> import sqlite3 <EOL> def main ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> db_dir = os . path . join ( \"<STR_LIT:..>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> eve_db_file = os . path . join ( db_dir , \"<STR_LIT>\" ) <EOL> system_jumps_file = os . path . join ( db_dir , \"<STR_LIT>\" ) <EOL> system_description_file = os . path . join ( db_dir , \"<STR_LIT>\" ) <EOL> with sqlite3 . connect ( eve_db_file ) as sql_con : <EOL> cursor = sql_con . cursor ( ) <EOL> result = cursor . execute ( '<STR_LIT>' ) <EOL> with open ( system_jumps_file , \"<STR_LIT:w>\" ) as f_out : <EOL> for row in result . fetchall ( ) : <EOL> f_out . write ( \"<STR_LIT>\" . format ( row [ <NUM_LIT:0> ] , row [ <NUM_LIT:1> ] ) ) <EOL> result = cursor . execute ( '<STR_LIT>' ) <EOL> with open ( system_description_file , \"<STR_LIT:w>\" ) as f_out : <EOL> for row in result . fetchall ( ) : <EOL> region_id = row [ <NUM_LIT:0> ] <EOL> system_id = row [ <NUM_LIT:1> ] <EOL> system_name = row [ <NUM_LIT:2> ] <EOL> security = float ( row [ <NUM_LIT:3> ] ) <EOL> query = cursor . execute ( <EOL> '<STR_LIT>' , <EOL> ( region_id , ) <EOL> ) <EOL> system_class = query . fetchone ( ) <EOL> if system_class : <EOL> system_class = system_class [ <NUM_LIT:0> ] <EOL> else : <EOL> query = cursor . execute ( <EOL> '<STR_LIT>' , <EOL> ( system_id , ) <EOL> ) <EOL> system_class = query . fetchone ( ) <EOL>", "answer": "if system_class :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT>''' <EOL> import sys <EOL> import os <EOL> from ngsutils . bed import BedFile <EOL> from ngsutils . support import revcomp <EOL> import pysam <EOL> def bed_tofasta ( bed , ref_fasta , min_size = <NUM_LIT:50> , stranded = True , include_name = False , out = sys . stdout ) : <EOL> if not os . path . exists ( '<STR_LIT>' % ref_fasta ) : <EOL> pysam . faidx ( ref_fasta ) <EOL> fasta = pysam . Fastafile ( ref_fasta ) <EOL> refs = set ( ) <EOL> with open ( '<STR_LIT>' % ref_fasta ) as f : <EOL> for line in f : <EOL> refs . add ( line . split ( '<STR_LIT:\\t>' ) [ <NUM_LIT:0> ] . strip ( ) ) <EOL> name = '<STR_LIT>' <EOL> for region in bed : <EOL> if include_name : <EOL> name = '<STR_LIT>' % ( region . name . strip ( ) ) <EOL> if region . end - region . start >= min_size and region . chrom in refs : <EOL> seq = fasta . fetch ( region . chrom , region . start , region . end ) <EOL> if stranded and region . strand : <EOL> if region . strand == '<STR_LIT:->' : <EOL> seq = revcomp ( seq ) <EOL> out . write ( '<STR_LIT>' % ( name , region . chrom , region . start , region . end , region . strand , seq ) ) <EOL> else : <EOL> out . write ( '<STR_LIT>' % ( name , region . chrom , region . start , region . end , seq ) ) <EOL> fasta . close ( ) <EOL> def usage ( ) : <EOL> print __doc__ <EOL> print \"\"\"<STR_LIT>\"\"\" <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL> min_size = <NUM_LIT:50> <EOL> bed = None <EOL> ref = None <EOL> stranded = True <EOL> include_name = False <EOL> last = None <EOL> for arg in sys . argv [ <NUM_LIT:1> : ] : <EOL> if last == '<STR_LIT>' : <EOL> min_size = int ( arg ) <EOL> last = None <EOL>", "answer": "elif arg in [ '<STR_LIT>' ] :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> import sys <EOL> import struct <EOL> import datetime <EOL> import unittest <EOL> import subprocess <EOL> from test import test_support <EOL> from collections import Hashable <EOL> IS_64BIT = ( struct . calcsize ( '<STR_LIT:l>' ) == <NUM_LIT:8> ) <EOL> class HashEqualityTestCase ( unittest . TestCase ) : <EOL> def same_hash ( self , * objlist ) : <EOL> hashed = map ( hash , objlist ) <EOL> for h in hashed [ <NUM_LIT:1> : ] : <EOL> if h != hashed [ <NUM_LIT:0> ] : <EOL> self . fail ( \"<STR_LIT>\" % ( objlist , ) ) <EOL> def test_numeric_literals ( self ) : <EOL> self . same_hash ( <NUM_LIT:1> , <NUM_LIT:1> L , <NUM_LIT:1.0> , <NUM_LIT:1.0> + <NUM_LIT> ) <EOL> self . same_hash ( <NUM_LIT:0> , <NUM_LIT:0> L , <NUM_LIT:0.0> , <NUM_LIT:0.0> + <NUM_LIT> ) <EOL> self . same_hash ( - <NUM_LIT:1> , - <NUM_LIT:1> L , - <NUM_LIT:1.0> , - <NUM_LIT:1.0> + <NUM_LIT> ) <EOL> self . same_hash ( - <NUM_LIT:2> , - <NUM_LIT:2> L , - <NUM_LIT> , - <NUM_LIT> + <NUM_LIT> ) <EOL> def test_coerced_integers ( self ) : <EOL> self . same_hash ( int ( <NUM_LIT:1> ) , long ( <NUM_LIT:1> ) , float ( <NUM_LIT:1> ) , complex ( <NUM_LIT:1> ) , <EOL> int ( '<STR_LIT:1>' ) , float ( '<STR_LIT:1.0>' ) ) <EOL> self . same_hash ( int ( - <NUM_LIT:2> ** <NUM_LIT> ) , long ( - <NUM_LIT:2> ** <NUM_LIT> ) , float ( - <NUM_LIT:2> ** <NUM_LIT> ) ) <EOL> self . same_hash ( int ( <NUM_LIT:1> - <NUM_LIT:2> ** <NUM_LIT> ) , long ( <NUM_LIT:1> - <NUM_LIT:2> ** <NUM_LIT> ) , float ( <NUM_LIT:1> - <NUM_LIT:2> ** <NUM_LIT> ) ) <EOL> self . same_hash ( int ( <NUM_LIT:2> ** <NUM_LIT> - <NUM_LIT:1> ) , long ( <NUM_LIT:2> ** <NUM_LIT> - <NUM_LIT:1> ) , float ( <NUM_LIT:2> ** <NUM_LIT> - <NUM_LIT:1> ) ) <EOL> self . same_hash ( int ( <NUM_LIT:2> ** <NUM_LIT> ) , long ( <NUM_LIT:2> ** <NUM_LIT> ) , float ( <NUM_LIT:2> ** <NUM_LIT> ) ) <EOL> self . same_hash ( int ( - <NUM_LIT:2> ** <NUM_LIT> ) , long ( - <NUM_LIT:2> ** <NUM_LIT> ) , float ( - <NUM_LIT:2> ** <NUM_LIT> ) ) <EOL> self . same_hash ( int ( <NUM_LIT:1> - <NUM_LIT:2> ** <NUM_LIT> ) , long ( <NUM_LIT:1> - <NUM_LIT:2> ** <NUM_LIT> ) ) <EOL> self . same_hash ( int ( <NUM_LIT:2> ** <NUM_LIT> - <NUM_LIT:1> ) , long ( <NUM_LIT:2> ** <NUM_LIT> - <NUM_LIT:1> ) ) <EOL> self . same_hash ( long ( <NUM_LIT:2> ** <NUM_LIT> ) , float ( <NUM_LIT:2> ** <NUM_LIT> ) ) <EOL> def test_coerced_floats ( self ) : <EOL> self . same_hash ( long ( <NUM_LIT> ) , float ( <NUM_LIT> ) ) <EOL> self . same_hash ( float ( <NUM_LIT:0.5> ) , complex ( <NUM_LIT:0.5> , <NUM_LIT:0.0> ) ) <EOL> _default_hash = object . __hash__ <EOL> class DefaultHash ( object ) : pass <EOL> _FIXED_HASH_VALUE = <NUM_LIT> <EOL> class FixedHash ( object ) : <EOL> def __hash__ ( self ) : <EOL> return _FIXED_HASH_VALUE <EOL> class OnlyEquality ( object ) : <EOL> def __eq__ ( self , other ) : <EOL> return self is other <EOL> __hash__ = None <EOL> del OnlyEquality . __hash__ <EOL> class OnlyInequality ( object ) : <EOL> def __ne__ ( self , other ) : <EOL> return self is not other <EOL> class OnlyCmp ( object ) : <EOL> def __cmp__ ( self , other ) : <EOL> return cmp ( id ( self ) , id ( other ) ) <EOL> __hash__ = None <EOL> del OnlyCmp . __hash__ <EOL> class InheritedHashWithEquality ( FixedHash , OnlyEquality ) : pass <EOL> class InheritedHashWithInequality ( FixedHash , OnlyInequality ) : pass <EOL>", "answer": "class InheritedHashWithCmp ( FixedHash , OnlyCmp ) : pass"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from scrapy . exceptions import DropItem <EOL> from scrapy_sci . status import Status , Reader <EOL> class DuplicatesPipeline ( object ) : <EOL> def __init__ ( self ) : <EOL> self . ids_seen = set ( ) <EOL> status = Status ( ) <EOL> for classifier in status . classifiers . keys ( ) : <EOL> for rf in status . classifiers [ classifier ] [ '<STR_LIT>' ] : <EOL> json = Reader . read_reviewed ( rf ) <EOL>", "answer": "self . ids_seen . add ( json [ '<STR_LIT>' ] )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import unittest <EOL> import datetime <EOL> from libcloud . utils . py3 import httplib <EOL> from libcloud . compute . drivers . gce import ( GCENodeDriver , API_VERSION , <EOL> timestamp_to_datetime , <EOL> GCEAddress , GCEBackendService , <EOL> GCEFirewall , GCEForwardingRule , <EOL> GCEHealthCheck , GCENetwork , <EOL> GCENodeImage , GCERoute , <EOL> GCETargetHttpProxy , GCEUrlMap , <EOL> GCEZone ) <EOL> from libcloud . common . google import ( GoogleBaseAuthConnection , <EOL> ResourceNotFoundError , ResourceExistsError , <EOL> InvalidRequestError , GoogleBaseError ) <EOL> from libcloud . test . common . test_google import GoogleAuthMockHttp , GoogleTestCase <EOL> from libcloud . compute . base import Node , StorageVolume <EOL> from libcloud . test import MockHttpTestCase <EOL> from libcloud . test . compute import TestCaseMixin <EOL> from libcloud . test . file_fixtures import ComputeFileFixtures <EOL> from libcloud . test . secrets import GCE_PARAMS , GCE_KEYWORD_PARAMS <EOL> class GCENodeDriverTest ( GoogleTestCase , TestCaseMixin ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> GCEZone . _now = lambda x : datetime . datetime ( <NUM_LIT> , <NUM_LIT:6> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> datacenter = '<STR_LIT>' <EOL> def setUp ( self ) : <EOL> GCEMockHttp . test = self <EOL> GCENodeDriver . connectionCls . conn_classes = ( GCEMockHttp , GCEMockHttp ) <EOL> GoogleBaseAuthConnection . conn_classes = ( GoogleAuthMockHttp , <EOL> GoogleAuthMockHttp ) <EOL> GCEMockHttp . type = None <EOL> kwargs = GCE_KEYWORD_PARAMS . copy ( ) <EOL> kwargs [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> kwargs [ '<STR_LIT>' ] = self . datacenter <EOL> self . driver = GCENodeDriver ( * GCE_PARAMS , ** kwargs ) <EOL> def test_default_scopes ( self ) : <EOL> self . assertEqual ( self . driver . scopes , None ) <EOL> def test_timestamp_to_datetime ( self ) : <EOL> timestamp1 = '<STR_LIT>' <EOL> datetime1 = datetime . datetime ( <NUM_LIT> , <NUM_LIT:6> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:5> , <NUM_LIT> ) <EOL> self . assertEqual ( timestamp_to_datetime ( timestamp1 ) , datetime1 ) <EOL> timestamp2 = '<STR_LIT>' <EOL> datetime2 = datetime . datetime ( <NUM_LIT> , <NUM_LIT:6> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:15> ) <EOL> self . assertEqual ( timestamp_to_datetime ( timestamp2 ) , datetime2 ) <EOL> def test_get_object_by_kind ( self ) : <EOL> obj = self . driver . _get_object_by_kind ( None ) <EOL> self . assertIsNone ( obj ) <EOL> obj = self . driver . _get_object_by_kind ( '<STR_LIT>' ) <EOL> self . assertIsNone ( obj ) <EOL> obj = self . driver . _get_object_by_kind ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> self . assertEqual ( obj . name , '<STR_LIT>' ) <EOL> def test_get_region_from_zone ( self ) : <EOL> zone1 = self . driver . ex_get_zone ( '<STR_LIT>' ) <EOL> expected_region1 = '<STR_LIT>' <EOL> region1 = self . driver . _get_region_from_zone ( zone1 ) <EOL> self . assertEqual ( region1 . name , expected_region1 ) <EOL> zone2 = self . driver . ex_get_zone ( '<STR_LIT>' ) <EOL> expected_region2 = '<STR_LIT>' <EOL> region2 = self . driver . _get_region_from_zone ( zone2 ) <EOL> self . assertEqual ( region2 . name , expected_region2 ) <EOL> def test_find_zone_or_region ( self ) : <EOL> zone1 = self . driver . _find_zone_or_region ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> self . assertEqual ( zone1 . name , '<STR_LIT>' ) <EOL> zone2 = self . driver . _find_zone_or_region ( <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertEqual ( zone2 . name , '<STR_LIT>' ) <EOL> region = self . driver . _find_zone_or_region ( '<STR_LIT>' , <EOL> '<STR_LIT>' , region = True ) <EOL> self . assertEqual ( region . name , '<STR_LIT>' ) <EOL> def test_match_images ( self ) : <EOL> project = '<STR_LIT>' <EOL> image = self . driver . _match_images ( project , '<STR_LIT>' ) <EOL> self . assertEqual ( image . name , '<STR_LIT>' ) <EOL> image = self . driver . _match_images ( project , '<STR_LIT>' ) <EOL> self . assertEqual ( image . name , '<STR_LIT>' ) <EOL> def test_ex_get_serial_output ( self ) : <EOL> self . assertRaises ( ValueError , self . driver . ex_get_serial_output , '<STR_LIT:foo>' ) <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertTrue ( self . driver . ex_get_serial_output ( node ) , <EOL> '<STR_LIT>' ) <EOL> def test_ex_list ( self ) : <EOL> d = self . driver <EOL> for list_fn in ( d . ex_list_addresses , <EOL> d . ex_list_backendservices , <EOL> d . ex_list_disktypes , <EOL> d . ex_list_firewalls , <EOL> d . ex_list_forwarding_rules , <EOL> d . ex_list_healthchecks , <EOL> d . ex_list_networks , <EOL> d . ex_list_project_images , <EOL> d . ex_list_regions , <EOL> d . ex_list_routes , <EOL> d . ex_list_snapshots , <EOL> d . ex_list_targethttpproxies , <EOL> d . ex_list_targetinstances , <EOL> d . ex_list_targetpools , <EOL> d . ex_list_urlmaps , <EOL> d . ex_list_zones , <EOL> d . list_images , <EOL> d . list_locations , <EOL> d . list_nodes , <EOL> d . list_sizes , <EOL> d . list_volumes ) : <EOL> full_list = [ item . name for item in list_fn ( ) ] <EOL> li = d . ex_list ( list_fn ) <EOL> iter_list = [ item . name for sublist in li for item in sublist ] <EOL> self . assertEqual ( full_list , iter_list ) <EOL> list_fn = d . ex_list_regions <EOL> for count , sublist in zip ( ( <NUM_LIT:2> , <NUM_LIT:1> ) , d . ex_list ( list_fn ) . page ( <NUM_LIT:2> ) ) : <EOL> self . assertTrue ( len ( sublist ) == count ) <EOL> for sublist in d . ex_list ( list_fn ) . filter ( '<STR_LIT>' ) : <EOL> self . assertTrue ( len ( sublist ) == <NUM_LIT:1> ) <EOL> self . assertEqual ( sublist [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> def test_ex_list_addresses ( self ) : <EOL> address_list = self . driver . ex_list_addresses ( ) <EOL> address_list_all = self . driver . ex_list_addresses ( '<STR_LIT:all>' ) <EOL> address_list_uc1 = self . driver . ex_list_addresses ( '<STR_LIT>' ) <EOL> address_list_global = self . driver . ex_list_addresses ( '<STR_LIT>' ) <EOL> self . assertEqual ( len ( address_list ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( len ( address_list_all ) , <NUM_LIT:5> ) <EOL> self . assertEqual ( len ( address_list_global ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( address_list [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> self . assertEqual ( address_list_uc1 [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> self . assertEqual ( address_list_global [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> names = [ a . name for a in address_list_all ] <EOL> self . assertTrue ( '<STR_LIT>' in names ) <EOL> def test_ex_list_backendservices ( self ) : <EOL> self . backendservices_mock = '<STR_LIT>' <EOL> backendservices_list = self . driver . ex_list_backendservices ( ) <EOL> self . assertListEqual ( backendservices_list , [ ] ) <EOL> self . backendservices_mock = '<STR_LIT>' <EOL> backendservices_list = self . driver . ex_list_backendservices ( ) <EOL> web_service = backendservices_list [ <NUM_LIT:0> ] <EOL> self . assertEqual ( web_service . name , '<STR_LIT>' ) <EOL> self . assertEqual ( len ( web_service . healthchecks ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( web_service . backends ) , <NUM_LIT:2> ) <EOL> def test_ex_list_healthchecks ( self ) : <EOL> healthchecks = self . driver . ex_list_healthchecks ( ) <EOL> self . assertEqual ( len ( healthchecks ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( healthchecks [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> def test_ex_list_firewalls ( self ) : <EOL> firewalls = self . driver . ex_list_firewalls ( ) <EOL> self . assertEqual ( len ( firewalls ) , <NUM_LIT:5> ) <EOL> self . assertEqual ( firewalls [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> def test_ex_list_forwarding_rules ( self ) : <EOL> forwarding_rules = self . driver . ex_list_forwarding_rules ( ) <EOL> forwarding_rules_all = self . driver . ex_list_forwarding_rules ( '<STR_LIT:all>' ) <EOL> forwarding_rules_uc1 = self . driver . ex_list_forwarding_rules ( <EOL> '<STR_LIT>' ) <EOL> self . assertEqual ( len ( forwarding_rules ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( len ( forwarding_rules_all ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( forwarding_rules [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> self . assertEqual ( forwarding_rules_uc1 [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> names = [ f . name for f in forwarding_rules_all ] <EOL> self . assertTrue ( '<STR_LIT>' in names ) <EOL> def test_ex_list_forwarding_rules_global ( self ) : <EOL> forwarding_rules = self . driver . ex_list_forwarding_rules ( global_rules = True ) <EOL> self . assertEqual ( len ( forwarding_rules ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( forwarding_rules [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> names = [ f . name for f in forwarding_rules ] <EOL> self . assertListEqual ( names , [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def test_list_images ( self ) : <EOL> local_images = self . driver . list_images ( ) <EOL> all_deprecated_images = self . driver . list_images ( ex_include_deprecated = True ) <EOL> debian_images = self . driver . list_images ( ex_project = '<STR_LIT>' ) <EOL> local_plus_deb = self . driver . list_images ( [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> self . assertEqual ( len ( local_images ) , <NUM_LIT> ) <EOL> self . assertEqual ( len ( all_deprecated_images ) , <NUM_LIT> ) <EOL> self . assertEqual ( len ( debian_images ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( len ( local_plus_deb ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( local_images [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> self . assertEqual ( debian_images [ <NUM_LIT:1> ] . name , '<STR_LIT>' ) <EOL> def test_list_locations ( self ) : <EOL> locations = self . driver . list_locations ( ) <EOL> self . assertEqual ( len ( locations ) , <NUM_LIT:6> ) <EOL> self . assertEqual ( locations [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> def test_ex_list_routes ( self ) : <EOL> routes = self . driver . ex_list_routes ( ) <EOL> self . assertEqual ( len ( routes ) , <NUM_LIT:3> ) <EOL> self . assertTrue ( '<STR_LIT>' in [ route . name for route in routes ] ) <EOL> def test_ex_list_networks ( self ) : <EOL> networks = self . driver . ex_list_networks ( ) <EOL> self . assertEqual ( len ( networks ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( networks [ <NUM_LIT:0> ] . name , '<STR_LIT:default>' ) <EOL> def test_list_nodes ( self ) : <EOL> nodes = self . driver . list_nodes ( ) <EOL> nodes_all = self . driver . list_nodes ( ex_zone = '<STR_LIT:all>' ) <EOL> nodes_uc1a = self . driver . list_nodes ( ex_zone = '<STR_LIT>' ) <EOL> self . assertEqual ( len ( nodes ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( nodes_all ) , <NUM_LIT:8> ) <EOL> self . assertEqual ( len ( nodes_uc1a ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( nodes [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> self . assertEqual ( nodes_uc1a [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> names = [ n . name for n in nodes_all ] <EOL> self . assertTrue ( '<STR_LIT>' in names ) <EOL> def test_ex_list_regions ( self ) : <EOL> regions = self . driver . ex_list_regions ( ) <EOL> self . assertEqual ( len ( regions ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( regions [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> def test_ex_list_snapshots ( self ) : <EOL> snapshots = self . driver . ex_list_snapshots ( ) <EOL> self . assertEqual ( len ( snapshots ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( snapshots [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> def test_ex_list_targethttpproxies ( self ) : <EOL> target_proxies = self . driver . ex_list_targethttpproxies ( ) <EOL> self . assertEqual ( len ( target_proxies ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( target_proxies [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> names = [ t . name for t in target_proxies ] <EOL> self . assertListEqual ( names , [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def test_ex_list_targetinstances ( self ) : <EOL> target_instances = self . driver . ex_list_targetinstances ( ) <EOL> target_instances_all = self . driver . ex_list_targetinstances ( '<STR_LIT:all>' ) <EOL> target_instances_uc1 = self . driver . ex_list_targetinstances ( '<STR_LIT>' ) <EOL> self . assertEqual ( len ( target_instances ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( len ( target_instances_all ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( len ( target_instances_uc1 ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( target_instances [ <NUM_LIT:0> ] . name , '<STR_LIT:hello>' ) <EOL> self . assertEqual ( target_instances_uc1 [ <NUM_LIT:0> ] . name , '<STR_LIT:hello>' ) <EOL> names = [ t . name for t in target_instances_all ] <EOL> self . assertTrue ( '<STR_LIT>' in names ) <EOL> def test_ex_list_targetpools ( self ) : <EOL> target_pools = self . driver . ex_list_targetpools ( ) <EOL> target_pools_all = self . driver . ex_list_targetpools ( '<STR_LIT:all>' ) <EOL> target_pools_uc1 = self . driver . ex_list_targetpools ( '<STR_LIT>' ) <EOL> self . assertEqual ( len ( target_pools ) , <NUM_LIT:4> ) <EOL> self . assertEqual ( len ( target_pools_all ) , <NUM_LIT:5> ) <EOL> self . assertEqual ( len ( target_pools_uc1 ) , <NUM_LIT:4> ) <EOL> self . assertEqual ( target_pools [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> self . assertEqual ( target_pools_uc1 [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> names = [ t . name for t in target_pools_all ] <EOL> self . assertTrue ( '<STR_LIT>' in names ) <EOL> def test_list_sizes ( self ) : <EOL> sizes = self . driver . list_sizes ( ) <EOL> sizes_all = self . driver . list_sizes ( '<STR_LIT:all>' ) <EOL> self . assertEqual ( len ( sizes ) , <NUM_LIT> ) <EOL> self . assertEqual ( len ( sizes_all ) , <NUM_LIT:100> ) <EOL> self . assertEqual ( sizes [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> self . assertEqual ( sizes [ <NUM_LIT:0> ] . extra [ '<STR_LIT>' ] . name , '<STR_LIT>' ) <EOL> names = [ s . name for s in sizes_all ] <EOL> self . assertEqual ( names . count ( '<STR_LIT>' ) , <NUM_LIT:5> ) <EOL> def test_ex_get_license ( self ) : <EOL> license = self . driver . ex_get_license ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertEqual ( license . name , '<STR_LIT>' ) <EOL> self . assertTrue ( license . charges_use_fee ) <EOL> def test_list_disktypes ( self ) : <EOL> disktypes = self . driver . ex_list_disktypes ( ) <EOL> disktypes_all = self . driver . ex_list_disktypes ( '<STR_LIT:all>' ) <EOL> disktypes_uc1a = self . driver . ex_list_disktypes ( '<STR_LIT>' ) <EOL> self . assertEqual ( len ( disktypes ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( len ( disktypes_all ) , <NUM_LIT:9> ) <EOL> self . assertEqual ( len ( disktypes_uc1a ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( disktypes [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> self . assertEqual ( disktypes_uc1a [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> names = [ v . name for v in disktypes_all ] <EOL> self . assertTrue ( '<STR_LIT>' in names ) <EOL> self . assertTrue ( '<STR_LIT>' in names ) <EOL> def test_ex_list_urlmaps ( self ) : <EOL> urlmaps_list = self . driver . ex_list_urlmaps ( ) <EOL> web_map = urlmaps_list [ <NUM_LIT:0> ] <EOL> self . assertEqual ( web_map . name , '<STR_LIT>' ) <EOL> self . assertEqual ( len ( web_map . host_rules ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( len ( web_map . path_matchers ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( len ( web_map . tests ) , <NUM_LIT:0> ) <EOL> def test_list_volumes ( self ) : <EOL> volumes = self . driver . list_volumes ( ) <EOL> volumes_all = self . driver . list_volumes ( '<STR_LIT:all>' ) <EOL> volumes_uc1a = self . driver . list_volumes ( '<STR_LIT>' ) <EOL> self . assertEqual ( len ( volumes ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( len ( volumes_all ) , <NUM_LIT:10> ) <EOL> self . assertEqual ( len ( volumes_uc1a ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( volumes [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> self . assertEqual ( volumes_uc1a [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> names = [ v . name for v in volumes_all ] <EOL> self . assertTrue ( '<STR_LIT>' in names ) <EOL> def test_ex_list_zones ( self ) : <EOL> zones = self . driver . ex_list_zones ( ) <EOL> self . assertEqual ( len ( zones ) , <NUM_LIT:6> ) <EOL> self . assertEqual ( zones [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> def test_ex_create_address_global ( self ) : <EOL> address_name = '<STR_LIT>' <EOL> address = self . driver . ex_create_address ( address_name , '<STR_LIT>' ) <EOL> self . assertTrue ( isinstance ( address , GCEAddress ) ) <EOL> self . assertEqual ( address . name , address_name ) <EOL> self . assertEqual ( address . region , '<STR_LIT>' ) <EOL> def test_ex_create_address ( self ) : <EOL> address_name = '<STR_LIT>' <EOL> address = self . driver . ex_create_address ( address_name ) <EOL> self . assertTrue ( isinstance ( address , GCEAddress ) ) <EOL> self . assertEqual ( address . name , address_name ) <EOL> def test_ex_create_backendservice ( self ) : <EOL> backendservice_name = '<STR_LIT>' <EOL> backendservice = self . driver . ex_create_backendservice ( <EOL> name = backendservice_name , <EOL> healthchecks = [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( isinstance ( backendservice , GCEBackendService ) ) <EOL> self . assertEqual ( backendservice . name , backendservice_name ) <EOL> def test_ex_create_healthcheck ( self ) : <EOL> healthcheck_name = '<STR_LIT>' <EOL> kwargs = { '<STR_LIT:host>' : '<STR_LIT>' , <EOL> '<STR_LIT:path>' : '<STR_LIT>' , <EOL> '<STR_LIT:port>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:10> , <EOL> '<STR_LIT>' : <NUM_LIT:10> , <EOL> '<STR_LIT>' : <NUM_LIT:4> , <EOL> '<STR_LIT>' : <NUM_LIT:3> , <EOL> '<STR_LIT:description>' : '<STR_LIT>' } <EOL> hc = self . driver . ex_create_healthcheck ( healthcheck_name , ** kwargs ) <EOL> self . assertTrue ( isinstance ( hc , GCEHealthCheck ) ) <EOL> self . assertEqual ( hc . name , healthcheck_name ) <EOL> self . assertEqual ( hc . path , '<STR_LIT>' ) <EOL> self . assertEqual ( hc . port , <NUM_LIT> ) <EOL> self . assertEqual ( hc . interval , <NUM_LIT:10> ) <EOL> self . assertEqual ( hc . extra [ '<STR_LIT:host>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( hc . extra [ '<STR_LIT:description>' ] , '<STR_LIT>' ) <EOL> def test_ex_create_image ( self ) : <EOL> volume = self . driver . ex_get_volume ( '<STR_LIT>' ) <EOL> image = self . driver . ex_create_image ( '<STR_LIT>' , volume ) <EOL> self . assertTrue ( isinstance ( image , GCENodeImage ) ) <EOL> self . assertTrue ( image . name . startswith ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( image . extra [ '<STR_LIT:description>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( image . extra [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> def test_ex_create_firewall ( self ) : <EOL> firewall_name = '<STR_LIT>' <EOL> allowed = [ { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : [ '<STR_LIT>' ] } ] <EOL> source_tags = [ '<STR_LIT>' ] <EOL> firewall = self . driver . ex_create_firewall ( firewall_name , allowed , <EOL> source_tags = source_tags ) <EOL> self . assertTrue ( isinstance ( firewall , GCEFirewall ) ) <EOL> self . assertEqual ( firewall . name , firewall_name ) <EOL> def test_ex_create_forwarding_rule ( self ) : <EOL> fwr_name = '<STR_LIT>' <EOL> targetpool = '<STR_LIT>' <EOL> region = '<STR_LIT>' <EOL> address = '<STR_LIT>' <EOL> port_range = '<STR_LIT>' <EOL> description = '<STR_LIT>' <EOL> fwr = self . driver . ex_create_forwarding_rule ( fwr_name , targetpool , <EOL> region = region , <EOL> address = address , <EOL> port_range = port_range , <EOL> description = description ) <EOL> self . assertTrue ( isinstance ( fwr , GCEForwardingRule ) ) <EOL> self . assertEqual ( fwr . name , fwr_name ) <EOL> self . assertEqual ( fwr . region . name , region ) <EOL> self . assertEqual ( fwr . protocol , '<STR_LIT>' ) <EOL> self . assertEqual ( fwr . extra [ '<STR_LIT>' ] , port_range ) <EOL> self . assertEqual ( fwr . extra [ '<STR_LIT:description>' ] , description ) <EOL> def test_ex_create_forwarding_rule_global ( self ) : <EOL> fwr_name = '<STR_LIT>' <EOL> target_name = '<STR_LIT>' <EOL> address = '<STR_LIT>' <EOL> port_range = '<STR_LIT>' <EOL> description = '<STR_LIT>' <EOL> for target in ( target_name , <EOL> self . driver . ex_get_targethttpproxy ( target_name ) ) : <EOL> fwr = self . driver . ex_create_forwarding_rule ( fwr_name , target , <EOL> global_rule = True , <EOL> address = address , <EOL> port_range = port_range , <EOL> description = description ) <EOL> self . assertTrue ( isinstance ( fwr , GCEForwardingRule ) ) <EOL> self . assertEqual ( fwr . name , fwr_name ) <EOL> self . assertEqual ( fwr . extra [ '<STR_LIT>' ] , port_range ) <EOL> self . assertEqual ( fwr . extra [ '<STR_LIT:description>' ] , description ) <EOL> def test_ex_create_forwarding_rule_targetpool_keyword ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fwr_name = '<STR_LIT>' <EOL> targetpool = '<STR_LIT>' <EOL> region = '<STR_LIT>' <EOL> address = self . driver . ex_get_address ( '<STR_LIT>' ) <EOL> port_range = '<STR_LIT>' <EOL> description = '<STR_LIT>' <EOL> fwr = self . driver . ex_create_forwarding_rule ( fwr_name , <EOL> targetpool = targetpool , <EOL> region = region , <EOL> address = address , <EOL> port_range = port_range , <EOL> description = description ) <EOL> self . assertTrue ( isinstance ( fwr , GCEForwardingRule ) ) <EOL> self . assertEqual ( fwr . name , fwr_name ) <EOL> self . assertEqual ( fwr . region . name , region ) <EOL> self . assertEqual ( fwr . protocol , '<STR_LIT>' ) <EOL> self . assertEqual ( fwr . extra [ '<STR_LIT>' ] , port_range ) <EOL> self . assertEqual ( fwr . extra [ '<STR_LIT:description>' ] , description ) <EOL> def test_ex_create_route ( self ) : <EOL> route_name = '<STR_LIT>' <EOL> dest_range = '<STR_LIT>' <EOL> priority = <NUM_LIT:1000> <EOL> route = self . driver . ex_create_route ( route_name , dest_range ) <EOL> self . assertTrue ( isinstance ( route , GCERoute ) ) <EOL> self . assertEqual ( route . name , route_name ) <EOL> self . assertEqual ( route . priority , priority ) <EOL> self . assertTrue ( \"<STR_LIT>\" in route . tags ) <EOL> self . assertTrue ( route . extra [ '<STR_LIT>' ] . endswith ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( route . dest_range , dest_range ) <EOL> def test_ex_create_network ( self ) : <EOL> network_name = '<STR_LIT>' <EOL> cidr = '<STR_LIT>' <EOL> network = self . driver . ex_create_network ( network_name , cidr ) <EOL> self . assertTrue ( isinstance ( network , GCENetwork ) ) <EOL> self . assertEqual ( network . name , network_name ) <EOL> self . assertEqual ( network . cidr , cidr ) <EOL> def test_ex_set_machine_type_notstopped ( self ) : <EOL> zone = '<STR_LIT>' <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' , zone ) <EOL> self . assertRaises ( GoogleBaseError , self . driver . ex_set_machine_type , <EOL> node , '<STR_LIT>' ) <EOL> def test_ex_set_machine_type_invalid ( self ) : <EOL> zone = '<STR_LIT>' <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' , zone ) <EOL> self . assertRaises ( InvalidRequestError , self . driver . ex_set_machine_type , <EOL> node , '<STR_LIT>' ) <EOL> def test_ex_set_machine_type ( self ) : <EOL> zone = '<STR_LIT>' <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' , zone ) <EOL> self . assertEqual ( node . size , '<STR_LIT>' ) <EOL> self . assertEqual ( node . extra [ '<STR_LIT:status>' ] , '<STR_LIT>' ) <EOL> self . assertTrue ( self . driver . ex_set_machine_type ( node , '<STR_LIT>' ) ) <EOL> def test_ex_node_start ( self ) : <EOL> zone = '<STR_LIT>' <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' , zone ) <EOL> self . assertTrue ( self . driver . ex_start_node ( node ) ) <EOL> def test_ex_node_stop ( self ) : <EOL> zone = '<STR_LIT>' <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' , zone ) <EOL> self . assertTrue ( self . driver . ex_stop_node ( node ) ) <EOL> zone = '<STR_LIT>' <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' , zone ) <EOL> self . assertTrue ( self . driver . ex_stop_node ( node ) ) <EOL> def test_create_node_req ( self ) : <EOL> image = self . driver . ex_get_image ( '<STR_LIT>' ) <EOL> size = self . driver . ex_get_size ( '<STR_LIT>' ) <EOL> location = self . driver . zone <EOL> network = self . driver . ex_get_network ( '<STR_LIT:default>' ) <EOL> tags = [ '<STR_LIT>' ] <EOL> metadata = [ { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } ] <EOL> boot_disk = self . driver . ex_get_volume ( '<STR_LIT>' ) <EOL> node_request , node_data = self . driver . _create_node_req ( '<STR_LIT>' , size , <EOL> image , location , <EOL> network , tags , <EOL> metadata , <EOL> boot_disk ) <EOL> self . assertEqual ( node_request , '<STR_LIT>' % location . name ) <EOL> self . assertEqual ( node_data [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:key>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( node_data [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT:0> ] , '<STR_LIT>' ) <EOL> self . assertEqual ( node_data [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> self . assertTrue ( node_data [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] ) <EOL> self . assertIsInstance ( node_data [ '<STR_LIT>' ] , list ) <EOL> self . assertIsInstance ( node_data [ '<STR_LIT>' ] [ <NUM_LIT:0> ] , dict ) <EOL> self . assertEqual ( node_data [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:email>' ] , '<STR_LIT:default>' ) <EOL> self . assertIsInstance ( node_data [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , list ) <EOL> self . assertEqual ( len ( node_data [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] ) , <NUM_LIT:1> ) <EOL> def test_create_node_network_opts ( self ) : <EOL> node_name = '<STR_LIT>' <EOL> size = self . driver . ex_get_size ( '<STR_LIT>' ) <EOL> image = self . driver . ex_get_image ( '<STR_LIT>' ) <EOL> zone = self . driver . ex_get_zone ( '<STR_LIT>' ) <EOL> network = self . driver . ex_get_network ( '<STR_LIT>' ) <EOL> address = self . driver . ex_get_address ( '<STR_LIT>' ) <EOL> ex_nic_gce_struct = [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ <EOL> { <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" <EOL> } <EOL> ] <EOL> } <EOL> ] <EOL> node = self . driver . create_node ( node_name , size , image ) <EOL> self . assertEqual ( node . extra [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ \"<STR_LIT:name>\" ] , '<STR_LIT>' ) <EOL> node = self . driver . create_node ( node_name , size , image , location = zone , <EOL> ex_network = network ) <EOL> self . assertEqual ( node . extra [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ \"<STR_LIT:name>\" ] , '<STR_LIT>' ) <EOL> node = self . driver . create_node ( node_name , size , image , location = zone , <EOL> ex_nic_gce_struct = ex_nic_gce_struct ) <EOL> self . assertEqual ( node . extra [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ \"<STR_LIT:name>\" ] , '<STR_LIT>' ) <EOL> self . assertRaises ( ValueError , self . driver . create_node , node_name , <EOL> size , image , location = zone , external_ip = address , <EOL> ex_nic_gce_struct = ex_nic_gce_struct ) <EOL> self . assertRaises ( ValueError , self . driver . create_node , node_name , <EOL> size , image , location = zone , ex_network = network , <EOL> ex_nic_gce_struct = ex_nic_gce_struct ) <EOL> def test_create_node_disk_opts ( self ) : <EOL> node_name = '<STR_LIT>' <EOL> size = self . driver . ex_get_size ( '<STR_LIT>' ) <EOL> image = self . driver . ex_get_image ( '<STR_LIT>' ) <EOL> boot_disk = self . driver . ex_get_volume ( '<STR_LIT>' ) <EOL> disk_type = self . driver . ex_get_disktype ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> DEMO_BASE_NAME = \"<STR_LIT>\" <EOL> gce_disk_struct = [ <EOL> { <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : '<STR_LIT>' % DEMO_BASE_NAME , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : '<STR_LIT>' % DEMO_BASE_NAME , <EOL> \"<STR_LIT>\" : image . extra [ '<STR_LIT>' ] <EOL> } , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT>\" : True <EOL> } , <EOL> { <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : '<STR_LIT>' % DEMO_BASE_NAME , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : disk_type . extra [ '<STR_LIT>' ] <EOL> } , <EOL> \"<STR_LIT>\" : True <EOL> } <EOL> ] <EOL> self . assertRaises ( ValueError , self . driver . create_node , node_name , <EOL> size , None ) <EOL> node = self . driver . create_node ( node_name , size , image ) <EOL> self . assertTrue ( isinstance ( node , Node ) ) <EOL> node = self . driver . create_node ( node_name , size , None , <EOL> ex_boot_disk = boot_disk ) <EOL> self . assertTrue ( isinstance ( node , Node ) ) <EOL> node = self . driver . create_node ( node_name , size , None , <EOL> ex_disks_gce_struct = gce_disk_struct ) <EOL> self . assertTrue ( isinstance ( node , Node ) ) <EOL> self . assertRaises ( ValueError , self . driver . create_node , node_name , <EOL> size , None , ex_boot_disk = boot_disk , <EOL> ex_disks_gce_struct = gce_disk_struct ) <EOL> def test_create_node ( self ) : <EOL> node_name = '<STR_LIT>' <EOL> image = self . driver . ex_get_image ( '<STR_LIT>' ) <EOL> size = self . driver . ex_get_size ( '<STR_LIT>' ) <EOL> node = self . driver . create_node ( node_name , size , image ) <EOL> self . assertTrue ( isinstance ( node , Node ) ) <EOL> self . assertEqual ( node . name , node_name ) <EOL> def test_create_node_image_family ( self ) : <EOL> node_name = '<STR_LIT>' <EOL> size = self . driver . ex_get_size ( '<STR_LIT>' ) <EOL> node = self . driver . create_node ( node_name , size , image = None , <EOL> ex_image_family = '<STR_LIT>' ) <EOL> self . assertTrue ( isinstance ( node , Node ) ) <EOL> self . assertEqual ( node . name , node_name ) <EOL> image = self . driver . ex_get_image ( '<STR_LIT>' ) <EOL> self . assertRaises ( ValueError , self . driver . create_node , node_name , <EOL> size , image , ex_image_family = '<STR_LIT>' ) <EOL> def test_create_node_req_with_serviceaccounts ( self ) : <EOL> image = self . driver . ex_get_image ( '<STR_LIT>' ) <EOL> size = self . driver . ex_get_size ( '<STR_LIT>' ) <EOL> location = self . driver . zone <EOL> network = self . driver . ex_get_network ( '<STR_LIT:default>' ) <EOL> ex_sa = [ { '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] } ] <EOL> node_request , node_data = self . driver . _create_node_req ( '<STR_LIT>' , size , <EOL> image , location , <EOL> network , <EOL> ex_service_accounts = ex_sa ) <EOL> self . assertIsInstance ( node_data [ '<STR_LIT>' ] , list ) <EOL> self . assertIsInstance ( node_data [ '<STR_LIT>' ] [ <NUM_LIT:0> ] , dict ) <EOL> self . assertEqual ( node_data [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:email>' ] , '<STR_LIT:default>' ) <EOL> self . assertIsInstance ( node_data [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , list ) <EOL> self . assertEqual ( len ( node_data [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] ) , <NUM_LIT:3> ) <EOL> self . assertTrue ( '<STR_LIT>' <EOL> in node_data [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( '<STR_LIT>' <EOL> in node_data [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] ) <EOL> def test_format_metadata ( self ) : <EOL> in_md = [ { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } , { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } ] <EOL> out_md = self . driver . _format_metadata ( '<STR_LIT>' , in_md ) <EOL> self . assertTrue ( '<STR_LIT>' in out_md ) <EOL> self . assertEqual ( out_md [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertTrue ( '<STR_LIT>' in out_md ) <EOL> self . assertEqual ( len ( out_md [ '<STR_LIT>' ] ) , <NUM_LIT:2> ) <EOL> self . assertTrue ( out_md [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:key>' ] in [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> self . assertTrue ( out_md [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:value>' ] in [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> in_md = [ { '<STR_LIT>' : '<STR_LIT>' } , { '<STR_LIT>' : '<STR_LIT>' } ] <EOL> out_md = self . driver . _format_metadata ( '<STR_LIT>' , in_md ) <EOL> self . assertTrue ( '<STR_LIT>' in out_md ) <EOL> self . assertEqual ( out_md [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertTrue ( '<STR_LIT>' in out_md ) <EOL> self . assertEqual ( len ( out_md [ '<STR_LIT>' ] ) , <NUM_LIT:2> ) <EOL> self . assertTrue ( out_md [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:key>' ] in [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> self . assertTrue ( out_md [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:value>' ] in [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> in_md = { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } <EOL> out_md = self . driver . _format_metadata ( '<STR_LIT>' , in_md ) <EOL> self . assertTrue ( '<STR_LIT>' in out_md ) <EOL> self . assertEqual ( out_md [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertTrue ( '<STR_LIT>' in out_md ) <EOL> self . assertEqual ( len ( out_md [ '<STR_LIT>' ] ) , <NUM_LIT:1> , out_md ) <EOL> self . assertEqual ( out_md [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:key>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( out_md [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:value>' ] , '<STR_LIT>' ) <EOL> in_md = { '<STR_LIT>' : '<STR_LIT>' } <EOL> out_md = self . driver . _format_metadata ( '<STR_LIT>' , in_md ) <EOL> self . assertTrue ( '<STR_LIT>' in out_md ) <EOL> self . assertEqual ( out_md [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertTrue ( '<STR_LIT>' in out_md ) <EOL> self . assertEqual ( len ( out_md [ '<STR_LIT>' ] ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( out_md [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:key>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( out_md [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:value>' ] , '<STR_LIT>' ) <EOL> in_md = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } <EOL> out_md = self . driver . _format_metadata ( '<STR_LIT>' , in_md ) <EOL> self . assertTrue ( '<STR_LIT>' in out_md ) <EOL> self . assertEqual ( out_md [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertTrue ( '<STR_LIT>' in out_md ) <EOL> self . assertEqual ( len ( out_md [ '<STR_LIT>' ] ) , <NUM_LIT:3> ) <EOL> keys = [ x [ '<STR_LIT:key>' ] for x in out_md [ '<STR_LIT>' ] ] <EOL> vals = [ x [ '<STR_LIT:value>' ] for x in out_md [ '<STR_LIT>' ] ] <EOL> keys . sort ( ) <EOL> vals . sort ( ) <EOL> self . assertEqual ( keys , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> self . assertEqual ( vals , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> in_md = { '<STR_LIT>' : [ { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } ] } <EOL> out_md = self . driver . _format_metadata ( '<STR_LIT>' , in_md ) <EOL> self . assertTrue ( '<STR_LIT>' in out_md ) <EOL> self . assertEqual ( out_md [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertTrue ( '<STR_LIT>' in out_md ) <EOL> self . assertEqual ( len ( out_md [ '<STR_LIT>' ] ) , <NUM_LIT:2> ) <EOL> self . assertTrue ( out_md [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:key>' ] in [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> self . assertTrue ( out_md [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:value>' ] in [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> in_md = { '<STR_LIT>' : '<STR_LIT:foo>' } <EOL> self . assertRaises ( ValueError , self . driver . _format_metadata , '<STR_LIT>' , in_md ) <EOL> in_md = { '<STR_LIT>' : { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } } <EOL> self . assertRaises ( ValueError , self . driver . _format_metadata , '<STR_LIT>' , in_md ) <EOL> in_md = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> self . assertRaises ( ValueError , self . driver . _format_metadata , '<STR_LIT>' , in_md ) <EOL> def test_create_node_with_metadata ( self ) : <EOL> node_name = '<STR_LIT>' <EOL> image = self . driver . ex_get_image ( '<STR_LIT>' ) <EOL> size = self . driver . ex_get_size ( '<STR_LIT>' ) <EOL> zone = self . driver . ex_get_zone ( '<STR_LIT>' ) <EOL> md = [ { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } , { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } ] <EOL> request , data = self . driver . _create_node_req ( node_name , size , image , <EOL> zone , metadata = md ) <EOL> self . assertTrue ( '<STR_LIT>' in data [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( len ( data [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) , <NUM_LIT:2> ) <EOL> md = { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } <EOL> request , data = self . driver . _create_node_req ( node_name , size , image , <EOL> zone , metadata = md ) <EOL> self . assertTrue ( '<STR_LIT>' in data [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( len ( data [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) , <NUM_LIT:1> ) <EOL> md = { '<STR_LIT>' : [ { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } ] } <EOL> request , data = self . driver . _create_node_req ( node_name , size , image , <EOL> zone , metadata = md ) <EOL> self . assertTrue ( '<STR_LIT>' in data [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( len ( data [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( data [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:key>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( data [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:value>' ] , '<STR_LIT>' ) <EOL> def test_create_node_existing ( self ) : <EOL> node_name = '<STR_LIT>' <EOL> image = self . driver . ex_get_image ( '<STR_LIT>' ) <EOL> size = self . driver . ex_get_size ( '<STR_LIT>' , zone = '<STR_LIT>' ) <EOL> self . assertRaises ( ResourceExistsError , self . driver . create_node , <EOL> node_name , size , image , location = '<STR_LIT>' ) <EOL> def test_ex_create_multiple_nodes ( self ) : <EOL> base_name = '<STR_LIT>' <EOL> image = self . driver . ex_get_image ( '<STR_LIT>' ) <EOL> size = self . driver . ex_get_size ( '<STR_LIT>' ) <EOL> number = <NUM_LIT:2> <EOL> nodes = self . driver . ex_create_multiple_nodes ( base_name , size , image , <EOL> number ) <EOL> self . assertEqual ( len ( nodes ) , <NUM_LIT:2> ) <EOL> self . assertTrue ( isinstance ( nodes [ <NUM_LIT:0> ] , Node ) ) <EOL> self . assertTrue ( isinstance ( nodes [ <NUM_LIT:1> ] , Node ) ) <EOL> self . assertEqual ( nodes [ <NUM_LIT:0> ] . name , '<STR_LIT>' % base_name ) <EOL> self . assertEqual ( nodes [ <NUM_LIT:1> ] . name , '<STR_LIT>' % base_name ) <EOL> def test_ex_create_multiple_nodes_image_family ( self ) : <EOL> base_name = '<STR_LIT>' <EOL> image = None <EOL> size = self . driver . ex_get_size ( '<STR_LIT>' ) <EOL> number = <NUM_LIT:2> <EOL> nodes = self . driver . ex_create_multiple_nodes ( base_name , size , image , <EOL> number , ex_image_family = '<STR_LIT>' ) <EOL> self . assertEqual ( len ( nodes ) , <NUM_LIT:2> ) <EOL> self . assertTrue ( isinstance ( nodes [ <NUM_LIT:0> ] , Node ) ) <EOL> self . assertTrue ( isinstance ( nodes [ <NUM_LIT:1> ] , Node ) ) <EOL> self . assertEqual ( nodes [ <NUM_LIT:0> ] . name , '<STR_LIT>' % base_name ) <EOL> self . assertEqual ( nodes [ <NUM_LIT:1> ] . name , '<STR_LIT>' % base_name ) <EOL> image = self . driver . ex_get_image ( '<STR_LIT>' ) <EOL> self . assertRaises ( ValueError , self . driver . ex_create_multiple_nodes , <EOL> base_name , size , image , number , ex_image_family = '<STR_LIT>' ) <EOL> def test_ex_create_targethttpproxy ( self ) : <EOL> proxy_name = '<STR_LIT>' <EOL> urlmap_name = '<STR_LIT>' <EOL> for urlmap in ( urlmap_name , self . driver . ex_get_urlmap ( urlmap_name ) ) : <EOL> proxy = self . driver . ex_create_targethttpproxy ( proxy_name , urlmap ) <EOL> self . assertTrue ( isinstance ( proxy , GCETargetHttpProxy ) ) <EOL> self . assertEqual ( proxy_name , proxy . name ) <EOL> def test_ex_create_targetinstance ( self ) : <EOL> targetinstance_name = '<STR_LIT>' <EOL> zone = '<STR_LIT>' <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' , zone ) <EOL> targetinstance = self . driver . ex_create_targetinstance ( <EOL> targetinstance_name , zone = zone , node = node ) <EOL> self . assertEqual ( targetinstance . name , targetinstance_name ) <EOL> self . assertEqual ( targetinstance . zone . name , zone ) <EOL> def test_ex_create_targetpool ( self ) : <EOL> targetpool_name = '<STR_LIT>' <EOL> region = '<STR_LIT>' <EOL> healthchecks = [ '<STR_LIT>' ] <EOL> node1 = self . driver . ex_get_node ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> node2 = self . driver . ex_get_node ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> nodes = [ node1 , node2 ] <EOL> targetpool = self . driver . ex_create_targetpool ( <EOL> targetpool_name , region = region , healthchecks = healthchecks , <EOL> nodes = nodes ) <EOL> self . assertEqual ( targetpool . name , targetpool_name ) <EOL> self . assertEqual ( len ( targetpool . nodes ) , len ( nodes ) ) <EOL> self . assertEqual ( targetpool . region . name , region ) <EOL> def test_ex_create_targetpool_session_affinity ( self ) : <EOL> targetpool_name = '<STR_LIT>' <EOL> region = '<STR_LIT>' <EOL> session_affinity = '<STR_LIT>' <EOL> targetpool = self . driver . ex_create_targetpool ( <EOL> targetpool_name , region = region , <EOL> session_affinity = session_affinity ) <EOL> self . assertEqual ( targetpool . name , targetpool_name ) <EOL> self . assertEqual ( targetpool . extra . get ( '<STR_LIT>' ) , <EOL> session_affinity ) <EOL> def test_ex_create_urlmap ( self ) : <EOL> urlmap_name = '<STR_LIT>' <EOL> for service in ( '<STR_LIT>' , <EOL> self . driver . ex_get_backendservice ( '<STR_LIT>' ) ) : <EOL> urlmap = self . driver . ex_create_urlmap ( urlmap_name , service ) <EOL> self . assertTrue ( isinstance ( urlmap , GCEUrlMap ) ) <EOL> self . assertEqual ( urlmap_name , urlmap . name ) <EOL> def test_create_volume_image_family ( self ) : <EOL> volume_name = '<STR_LIT>' <EOL> size = <NUM_LIT:10> <EOL> volume = self . driver . create_volume ( size , volume_name , <EOL> ex_image_family = '<STR_LIT>' ) <EOL> self . assertTrue ( isinstance ( volume , StorageVolume ) ) <EOL> self . assertEqual ( volume . name , volume_name ) <EOL> image = self . driver . ex_get_image ( '<STR_LIT>' ) <EOL> self . assertRaises ( ValueError , self . driver . create_volume , size , <EOL> volume_name , image = image , <EOL> ex_image_family = '<STR_LIT>' ) <EOL> def test_ex_create_volume_snapshot ( self ) : <EOL> snapshot_name = '<STR_LIT>' <EOL> volume = self . driver . ex_get_volume ( '<STR_LIT>' ) <EOL> snapshot = volume . snapshot ( snapshot_name ) <EOL> self . assertEqual ( snapshot . name , snapshot_name ) <EOL> self . assertEqual ( snapshot . size , '<STR_LIT>' ) <EOL> def test_create_volume_ssd ( self ) : <EOL> volume_name = '<STR_LIT>' <EOL> size = <NUM_LIT:10> <EOL> volume = self . driver . create_volume ( size , volume_name , <EOL> ex_disk_type = '<STR_LIT>' ) <EOL> self . assertTrue ( isinstance ( volume , StorageVolume ) ) <EOL> self . assertEqual ( volume . extra [ '<STR_LIT:type>' ] , '<STR_LIT>' ) <EOL> def test_create_volume ( self ) : <EOL> volume_name = '<STR_LIT>' <EOL> size = <NUM_LIT:10> <EOL> volume = self . driver . create_volume ( size , volume_name ) <EOL> self . assertTrue ( isinstance ( volume , StorageVolume ) ) <EOL> self . assertEqual ( volume . name , volume_name ) <EOL> def test_ex_update_healthcheck ( self ) : <EOL> healthcheck_name = '<STR_LIT>' <EOL> healthcheck = self . driver . ex_get_healthcheck ( healthcheck_name ) <EOL> healthcheck . port = <NUM_LIT> <EOL> healthcheck2 = self . driver . ex_update_healthcheck ( healthcheck ) <EOL> self . assertTrue ( isinstance ( healthcheck2 , GCEHealthCheck ) ) <EOL> def test_ex_update_firewall ( self ) : <EOL> firewall_name = '<STR_LIT>' <EOL> firewall = self . driver . ex_get_firewall ( firewall_name ) <EOL> firewall . source_ranges = [ '<STR_LIT>' ] <EOL> firewall . source_tags = [ '<STR_LIT>' , '<STR_LIT:test>' ] <EOL> firewall2 = self . driver . ex_update_firewall ( firewall ) <EOL> self . assertTrue ( isinstance ( firewall2 , GCEFirewall ) ) <EOL> def test_ex_targetpool_gethealth ( self ) : <EOL> targetpool = self . driver . ex_get_targetpool ( '<STR_LIT>' ) <EOL> health = targetpool . get_health ( '<STR_LIT>' ) <EOL> self . assertEqual ( len ( health ) , <NUM_LIT:1> ) <EOL> self . assertTrue ( '<STR_LIT>' in health [ <NUM_LIT:0> ] ) <EOL> self . assertTrue ( '<STR_LIT>' in health [ <NUM_LIT:0> ] ) <EOL> self . assertEqual ( health [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> def test_ex_targetpool_with_backup_pool ( self ) : <EOL> targetpool = self . driver . ex_get_targetpool ( '<STR_LIT>' ) <EOL> self . assertTrue ( '<STR_LIT>' in targetpool . extra ) <EOL> self . assertTrue ( '<STR_LIT>' in targetpool . extra ) <EOL> def test_ex_targetpool_setbackup ( self ) : <EOL> targetpool = self . driver . ex_get_targetpool ( '<STR_LIT>' ) <EOL> backup_targetpool = self . driver . ex_get_targetpool ( '<STR_LIT>' ) <EOL> self . assertTrue ( targetpool . set_backup_targetpool ( backup_targetpool , <EOL> <NUM_LIT:0.1> ) ) <EOL> def test_ex_targetpool_remove_add_node ( self ) : <EOL> targetpool = self . driver . ex_get_targetpool ( '<STR_LIT>' ) <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> remove_node = self . driver . ex_targetpool_remove_node ( targetpool , node ) <EOL> self . assertTrue ( remove_node ) <EOL> self . assertEqual ( len ( targetpool . nodes ) , <NUM_LIT:1> ) <EOL> add_node = self . driver . ex_targetpool_add_node ( targetpool , node . extra [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( add_node ) <EOL> self . assertEqual ( len ( targetpool . nodes ) , <NUM_LIT:2> ) <EOL> remove_node = self . driver . ex_targetpool_remove_node ( targetpool , node . extra [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( remove_node ) <EOL> self . assertEqual ( len ( targetpool . nodes ) , <NUM_LIT:1> ) <EOL> add_node = self . driver . ex_targetpool_add_node ( targetpool , node ) <EOL> self . assertTrue ( add_node ) <EOL> self . assertEqual ( len ( targetpool . nodes ) , <NUM_LIT:2> ) <EOL> add_node = self . driver . ex_targetpool_add_node ( targetpool , node . extra [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( add_node ) <EOL> self . assertEqual ( len ( targetpool . nodes ) , <NUM_LIT:2> ) <EOL> def test_ex_targetpool_remove_add_healthcheck ( self ) : <EOL> targetpool = self . driver . ex_get_targetpool ( '<STR_LIT>' ) <EOL> healthcheck = self . driver . ex_get_healthcheck ( <EOL> '<STR_LIT>' ) <EOL> remove_healthcheck = self . driver . ex_targetpool_remove_healthcheck ( <EOL> targetpool , healthcheck ) <EOL> self . assertTrue ( remove_healthcheck ) <EOL> self . assertEqual ( len ( targetpool . healthchecks ) , <NUM_LIT:0> ) <EOL> add_healthcheck = self . driver . ex_targetpool_add_healthcheck ( <EOL> targetpool , healthcheck ) <EOL> self . assertTrue ( add_healthcheck ) <EOL> self . assertEqual ( len ( targetpool . healthchecks ) , <NUM_LIT:1> ) <EOL> def test_reboot_node ( self ) : <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' ) <EOL> reboot = self . driver . reboot_node ( node ) <EOL> self . assertTrue ( reboot ) <EOL> def test_ex_set_node_tags ( self ) : <EOL> new_tags = [ '<STR_LIT>' ] <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' ) <EOL> set_tags = self . driver . ex_set_node_tags ( node , new_tags ) <EOL> self . assertTrue ( set_tags ) <EOL> def test_attach_volume_invalid_usecase ( self ) : <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' ) <EOL> self . assertRaises ( ValueError , self . driver . attach_volume , node , None ) <EOL> self . assertRaises ( ValueError , self . driver . attach_volume , node , None , <EOL> ex_source = '<STR_LIT>' , device = None ) <EOL> def test_attach_volume ( self ) : <EOL> volume = self . driver . ex_get_volume ( '<STR_LIT>' ) <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' ) <EOL> attach = volume . attach ( node ) <EOL> self . assertTrue ( attach ) <EOL> def test_detach_volume ( self ) : <EOL> volume = self . driver . ex_get_volume ( '<STR_LIT>' ) <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' ) <EOL> detach = volume . detach ( ) <EOL> self . assertFalse ( detach ) <EOL> detach = self . driver . detach_volume ( volume , node ) <EOL> self . assertTrue ( detach ) <EOL> def test_ex_destroy_address_global ( self ) : <EOL> address = self . driver . ex_get_address ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertEqual ( address . name , '<STR_LIT>' ) <EOL> self . assertEqual ( address . region , '<STR_LIT>' ) <EOL> destroyed = address . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_ex_destroy_address ( self ) : <EOL> address = self . driver . ex_get_address ( '<STR_LIT>' ) <EOL> destroyed = address . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_ex_destroy_backendservice ( self ) : <EOL> backendservice = self . driver . ex_get_backendservice ( '<STR_LIT>' ) <EOL> destroyed = backendservice . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_ex_destroy_healthcheck ( self ) : <EOL> hc = self . driver . ex_get_healthcheck ( '<STR_LIT>' ) <EOL> destroyed = hc . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_ex_delete_image ( self ) : <EOL> self . assertRaises ( ResourceNotFoundError , <EOL> self . driver . ex_get_image , '<STR_LIT>' ) <EOL> self . assertRaises ( ResourceNotFoundError , <EOL> self . driver . ex_delete_image , '<STR_LIT>' ) <EOL> image = self . driver . ex_get_image ( '<STR_LIT>' ) <EOL> deleted = self . driver . ex_delete_image ( image ) <EOL> self . assertTrue ( deleted ) <EOL> def test_ex_deprecate_image ( self ) : <EOL> dep_ts = '<STR_LIT>' <EOL> obs_ts = '<STR_LIT>' <EOL> del_ts = '<STR_LIT>' <EOL> image = self . driver . ex_get_image ( '<STR_LIT>' ) <EOL> deprecated = image . deprecate ( '<STR_LIT>' , '<STR_LIT>' , <EOL> deprecated = dep_ts , <EOL> obsolete = obs_ts , <EOL> deleted = del_ts ) <EOL> self . assertTrue ( deprecated ) <EOL> self . assertEqual ( image . extra [ '<STR_LIT>' ] [ '<STR_LIT>' ] , dep_ts ) <EOL> self . assertEqual ( image . extra [ '<STR_LIT>' ] [ '<STR_LIT>' ] , obs_ts ) <EOL> self . assertEqual ( image . extra [ '<STR_LIT>' ] [ '<STR_LIT>' ] , del_ts ) <EOL> def test_ex_destroy_firewall ( self ) : <EOL> firewall = self . driver . ex_get_firewall ( '<STR_LIT>' ) <EOL> destroyed = firewall . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_ex_destroy_forwarding_rule ( self ) : <EOL> fwr = self . driver . ex_get_forwarding_rule ( '<STR_LIT>' ) <EOL> destroyed = fwr . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_ex_destroy_forwarding_rule_global ( self ) : <EOL> fwr = self . driver . ex_get_forwarding_rule ( '<STR_LIT>' , global_rule = True ) <EOL> destroyed = fwr . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_ex_destroy_route ( self ) : <EOL> route = self . driver . ex_get_route ( '<STR_LIT>' ) <EOL> destroyed = route . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_ex_destroy_network ( self ) : <EOL> network = self . driver . ex_get_network ( '<STR_LIT>' ) <EOL> destroyed = network . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_destroy_node ( self ) : <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' ) <EOL> destroyed = node . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_ex_destroy_multiple_nodes ( self ) : <EOL> nodes = [ ] <EOL> nodes . append ( self . driver . ex_get_node ( '<STR_LIT>' ) ) <EOL> nodes . append ( self . driver . ex_get_node ( '<STR_LIT>' ) ) <EOL> destroyed = self . driver . ex_destroy_multiple_nodes ( nodes ) <EOL> for d in destroyed : <EOL> self . assertTrue ( d ) <EOL> def test_destroy_targethttpproxy ( self ) : <EOL> proxy = self . driver . ex_get_targethttpproxy ( '<STR_LIT>' ) <EOL> destroyed = proxy . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_destroy_targetinstance ( self ) : <EOL> targetinstance = self . driver . ex_get_targetinstance ( '<STR_LIT>' ) <EOL> self . assertEqual ( targetinstance . name , '<STR_LIT>' ) <EOL> destroyed = targetinstance . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_destroy_targetpool ( self ) : <EOL> targetpool = self . driver . ex_get_targetpool ( '<STR_LIT>' ) <EOL> destroyed = targetpool . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_destroy_urlmap ( self ) : <EOL> urlmap = self . driver . ex_get_urlmap ( '<STR_LIT>' ) <EOL> destroyed = urlmap . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_destroy_volume ( self ) : <EOL> disk = self . driver . ex_get_volume ( '<STR_LIT>' ) <EOL> destroyed = disk . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_ex_set_volume_auto_delete ( self ) : <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' ) <EOL> volume = node . extra [ '<STR_LIT>' ] <EOL> auto_delete = self . driver . ex_set_volume_auto_delete ( <EOL> volume , node ) <EOL> self . assertTrue ( auto_delete ) <EOL> def test_destroy_volume_snapshot ( self ) : <EOL> snapshot = self . driver . ex_get_snapshot ( '<STR_LIT>' ) <EOL> destroyed = snapshot . destroy ( ) <EOL> self . assertTrue ( destroyed ) <EOL> def test_ex_get_address_global ( self ) : <EOL> address_name = '<STR_LIT>' <EOL> address = self . driver . ex_get_address ( address_name , '<STR_LIT>' ) <EOL> self . assertEqual ( address . name , address_name ) <EOL> self . assertEqual ( address . address , '<STR_LIT>' ) <EOL> self . assertEqual ( address . region , '<STR_LIT>' ) <EOL> self . assertEqual ( address . extra [ '<STR_LIT:status>' ] , '<STR_LIT>' ) <EOL> def test_ex_get_address ( self ) : <EOL> address_name = '<STR_LIT>' <EOL> address = self . driver . ex_get_address ( address_name ) <EOL> self . assertEqual ( address . name , address_name ) <EOL> self . assertEqual ( address . address , '<STR_LIT>' ) <EOL> self . assertEqual ( address . region . name , '<STR_LIT>' ) <EOL> self . assertEqual ( address . extra [ '<STR_LIT:status>' ] , '<STR_LIT>' ) <EOL> def test_ex_get_backendservice ( self ) : <EOL> web_service = self . driver . ex_get_backendservice ( '<STR_LIT>' ) <EOL> self . assertEqual ( web_service . name , '<STR_LIT>' ) <EOL> self . assertEqual ( web_service . protocol , '<STR_LIT>' ) <EOL> self . assertEqual ( web_service . port , <NUM_LIT> ) <EOL> self . assertEqual ( web_service . timeout , <NUM_LIT:30> ) <EOL> self . assertEqual ( web_service . healthchecks [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> self . assertEqual ( len ( web_service . healthchecks ) , <NUM_LIT:1> ) <EOL> backends = web_service . backends <EOL> self . assertEqual ( len ( backends ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( backends [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( backends [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , <NUM_LIT:100> ) <EOL> self . assertEqual ( backends [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , <NUM_LIT:1.0> ) <EOL> web_service = self . driver . ex_get_backendservice ( '<STR_LIT>' ) <EOL> self . assertEqual ( web_service . name , '<STR_LIT>' ) <EOL> self . assertEqual ( web_service . healthchecks [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> self . assertEqual ( len ( web_service . healthchecks ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( web_service . backends ) , <NUM_LIT:0> ) <EOL> def test_ex_get_healthcheck ( self ) : <EOL> healthcheck_name = '<STR_LIT>' <EOL> healthcheck = self . driver . ex_get_healthcheck ( healthcheck_name ) <EOL> self . assertEqual ( healthcheck . name , healthcheck_name ) <EOL> self . assertEqual ( healthcheck . port , <NUM_LIT> ) <EOL> self . assertEqual ( healthcheck . path , '<STR_LIT>' ) <EOL> def test_ex_get_firewall ( self ) : <EOL> firewall_name = '<STR_LIT>' <EOL> firewall = self . driver . ex_get_firewall ( firewall_name ) <EOL> self . assertEqual ( firewall . name , firewall_name ) <EOL> self . assertEqual ( firewall . network . name , '<STR_LIT:default>' ) <EOL> self . assertEqual ( firewall . source_tags , [ '<STR_LIT>' ] ) <EOL> def test_ex_get_forwarding_rule ( self ) : <EOL> fwr_name = '<STR_LIT>' <EOL> fwr = self . driver . ex_get_forwarding_rule ( fwr_name ) <EOL> self . assertEqual ( fwr . name , fwr_name ) <EOL> self . assertEqual ( fwr . extra [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( fwr . targetpool . name , '<STR_LIT>' ) <EOL> self . assertEqual ( fwr . protocol , '<STR_LIT>' ) <EOL> def test_ex_get_forwarding_rule_global ( self ) : <EOL> fwr_name = '<STR_LIT>' <EOL> fwr = self . driver . ex_get_forwarding_rule ( fwr_name , global_rule = True ) <EOL> self . assertEqual ( fwr . name , fwr_name ) <EOL> self . assertEqual ( fwr . extra [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( fwr . targetpool . name , '<STR_LIT>' ) <EOL> self . assertEqual ( fwr . protocol , '<STR_LIT>' ) <EOL> self . assertEqual ( fwr . address , '<STR_LIT>' ) <EOL> self . assertEqual ( fwr . targetpool . name , '<STR_LIT>' ) <EOL> def test_ex_get_image_license ( self ) : <EOL> image = self . driver . ex_get_image ( '<STR_LIT>' ) <EOL> self . assertTrue ( '<STR_LIT>' in image . extra ) <EOL> self . assertEqual ( image . extra [ '<STR_LIT>' ] [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> self . assertTrue ( image . extra [ '<STR_LIT>' ] [ <NUM_LIT:0> ] . charges_use_fee ) <EOL> def test_ex_get_image ( self ) : <EOL> partial_name = '<STR_LIT>' <EOL> image = self . driver . ex_get_image ( partial_name ) <EOL> self . assertEqual ( image . name , '<STR_LIT>' ) <EOL> self . assertTrue ( image . extra [ '<STR_LIT:description>' ] . startswith ( '<STR_LIT>' ) ) <EOL> partial_name = '<STR_LIT>' <EOL> image = self . driver . ex_get_image ( partial_name ) <EOL> self . assertEqual ( image . name , '<STR_LIT>' ) <EOL> self . assertTrue ( image . extra [ '<STR_LIT:description>' ] . startswith ( '<STR_LIT>' ) ) <EOL> partial_name = '<STR_LIT>' <EOL> image = self . driver . ex_get_image ( partial_name , [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( image . name , '<STR_LIT>' ) <EOL> partial_name = '<STR_LIT>' <EOL> self . assertRaises ( ResourceNotFoundError , self . driver . ex_get_image , <EOL> partial_name , '<STR_LIT>' , <EOL> ex_standard_projects = False ) <EOL> def test_ex_get_image_from_family ( self ) : <EOL> family = '<STR_LIT>' <EOL> description = '<STR_LIT>' <EOL> image = self . driver . ex_get_image_from_family ( family ) <EOL> self . assertEqual ( image . name , '<STR_LIT>' ) <EOL> self . assertEqual ( image . extra [ '<STR_LIT:description>' ] , description ) <EOL> self . assertEqual ( image . extra [ '<STR_LIT>' ] , family ) <EOL> url = ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> image = self . driver . ex_get_image_from_family ( url ) <EOL> self . assertEqual ( image . name , '<STR_LIT>' ) <EOL> self . assertEqual ( image . extra [ '<STR_LIT:description>' ] , description ) <EOL> self . assertEqual ( image . extra [ '<STR_LIT>' ] , family ) <EOL> project_list = [ '<STR_LIT>' ] <EOL> image = self . driver . ex_get_image_from_family ( family , ex_project_list = project_list , ex_standard_projects = False ) <EOL> self . assertEqual ( image . name , '<STR_LIT>' ) <EOL> self . assertEqual ( image . extra [ '<STR_LIT:description>' ] , description ) <EOL> self . assertEqual ( image . extra [ '<STR_LIT>' ] , family ) <EOL> self . assertRaises ( ResourceNotFoundError , self . driver . ex_get_image_from_family , '<STR_LIT>' ) <EOL> def test_ex_copy_image ( self ) : <EOL> name = '<STR_LIT>' <EOL> url = '<STR_LIT>' <EOL> description = '<STR_LIT>' <EOL> family = '<STR_LIT>' <EOL> image = self . driver . ex_copy_image ( name , url , description = description , <EOL> family = family ) <EOL> self . assertTrue ( image . name . startswith ( name ) ) <EOL> self . assertEqual ( image . extra [ '<STR_LIT:description>' ] , description ) <EOL> self . assertEqual ( image . extra [ '<STR_LIT>' ] , family ) <EOL> def test_ex_get_route ( self ) : <EOL> route_name = '<STR_LIT>' <EOL> route = self . driver . ex_get_route ( route_name ) <EOL> self . assertEqual ( route . name , route_name ) <EOL> self . assertEqual ( route . dest_range , '<STR_LIT>' ) <EOL> self . assertEqual ( route . priority , <NUM_LIT:1000> ) <EOL> def test_ex_get_network ( self ) : <EOL> network_name = '<STR_LIT>' <EOL> network = self . driver . ex_get_network ( network_name ) <EOL> self . assertEqual ( network . name , network_name ) <EOL> self . assertEqual ( network . cidr , '<STR_LIT>' ) <EOL> self . assertEqual ( network . extra [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( network . extra [ '<STR_LIT:description>' ] , '<STR_LIT>' ) <EOL> def test_ex_get_node ( self ) : <EOL> node_name = '<STR_LIT>' <EOL> zone = '<STR_LIT>' <EOL> node = self . driver . ex_get_node ( node_name , zone ) <EOL> self . assertEqual ( node . name , node_name ) <EOL> self . assertEqual ( node . size , '<STR_LIT>' ) <EOL> removed_node = '<STR_LIT>' <EOL> self . assertRaises ( ResourceNotFoundError , self . driver . ex_get_node , <EOL> removed_node , '<STR_LIT>' ) <EOL> missing_node = '<STR_LIT>' <EOL> self . assertRaises ( ResourceNotFoundError , self . driver . ex_get_node , <EOL> missing_node , '<STR_LIT:all>' ) <EOL> def test_ex_get_project ( self ) : <EOL> project = self . driver . ex_get_project ( ) <EOL> self . assertEqual ( project . name , '<STR_LIT>' ) <EOL> networks_quota = project . quotas [ <NUM_LIT:1> ] <EOL> self . assertEqual ( networks_quota [ '<STR_LIT>' ] , <NUM_LIT:3> ) <EOL> self . assertEqual ( networks_quota [ '<STR_LIT>' ] , <NUM_LIT:5> ) <EOL> self . assertEqual ( networks_quota [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertTrue ( '<STR_LIT>' in project . extra [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( '<STR_LIT>' in project . extra [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( '<STR_LIT>' in project . extra ) <EOL> self . assertTrue ( '<STR_LIT>' in project . extra [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( project . extra [ '<STR_LIT>' ] [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> def test_ex_add_access_config ( self ) : <EOL> self . assertRaises ( ValueError , self . driver . ex_add_access_config , <EOL> '<STR_LIT>' , '<STR_LIT:name>' , '<STR_LIT>' ) <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertTrue ( self . driver . ex_add_access_config ( node , '<STR_LIT:foo>' , '<STR_LIT:bar>' ) ) <EOL> def test_ex_delete_access_config ( self ) : <EOL> self . assertRaises ( ValueError , self . driver . ex_add_access_config , <EOL> '<STR_LIT>' , '<STR_LIT:name>' , '<STR_LIT>' ) <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertTrue ( self . driver . ex_delete_access_config ( node , '<STR_LIT:foo>' , '<STR_LIT:bar>' ) ) <EOL> def test_ex_set_usage_export_bucket ( self ) : <EOL> self . assertRaises ( ValueError , <EOL> self . driver . ex_set_usage_export_bucket , '<STR_LIT:foo>' ) <EOL> bucket_name = '<STR_LIT>' <EOL> self . driver . ex_set_usage_export_bucket ( bucket_name ) <EOL> bucket_name = '<STR_LIT>' <EOL> self . driver . ex_set_usage_export_bucket ( bucket_name ) <EOL> def test__set_project_metadata ( self ) : <EOL> self . assertEqual ( len ( self . driver . _set_project_metadata ( None , False , \"<STR_LIT>\" ) ) , <NUM_LIT:0> ) <EOL> md = self . driver . _set_project_metadata ( None , False , \"<STR_LIT>\" ) <EOL> self . assertEqual ( len ( md ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( md [ <NUM_LIT:0> ] [ '<STR_LIT:key>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( md [ <NUM_LIT:0> ] [ '<STR_LIT:value>' ] , '<STR_LIT>' ) <EOL> md = self . driver . _set_project_metadata ( None , True , \"<STR_LIT>\" ) <EOL> self . assertEqual ( len ( md ) , <NUM_LIT:0> ) <EOL> gce_md = { '<STR_LIT>' : [ { '<STR_LIT:key>' : '<STR_LIT:foo>' , '<STR_LIT:value>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } ] } <EOL> md = self . driver . _set_project_metadata ( gce_md , False , \"<STR_LIT>\" ) <EOL> self . assertEqual ( len ( md ) , <NUM_LIT:2> , str ( md ) ) <EOL> sshKeys = \"<STR_LIT>\" <EOL> count = <NUM_LIT:0> <EOL> for d in md : <EOL> if d [ '<STR_LIT:key>' ] == '<STR_LIT>' : <EOL> count += <NUM_LIT:1> <EOL> sshKeys = d [ '<STR_LIT:value>' ] <EOL> self . assertEqual ( sshKeys , '<STR_LIT>' ) <EOL> self . assertEqual ( count , <NUM_LIT:1> ) <EOL> gce_md = { '<STR_LIT>' : [ { '<STR_LIT:key>' : '<STR_LIT:foo>' , '<STR_LIT:value>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } ] } <EOL> md = self . driver . _set_project_metadata ( gce_md , True , \"<STR_LIT>\" ) <EOL> self . assertEqual ( len ( md ) , <NUM_LIT:2> , str ( md ) ) <EOL> sshKeys = \"<STR_LIT>\" <EOL> count = <NUM_LIT:0> <EOL> for d in md : <EOL> if d [ '<STR_LIT:key>' ] == '<STR_LIT>' : <EOL> count += <NUM_LIT:1> <EOL> sshKeys = d [ '<STR_LIT:value>' ] <EOL> self . assertEqual ( sshKeys , '<STR_LIT>' ) <EOL> self . assertEqual ( count , <NUM_LIT:1> ) <EOL> gce_md = { '<STR_LIT>' : [ { '<STR_LIT:key>' : '<STR_LIT:foo>' , '<STR_LIT:value>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } ] } <EOL> md = self . driver . _set_project_metadata ( gce_md , True , \"<STR_LIT>\" ) <EOL> self . assertEqual ( len ( md ) , <NUM_LIT:2> , str ( md ) ) <EOL> sshKeys = \"<STR_LIT>\" <EOL> count = <NUM_LIT:0> <EOL> for d in md : <EOL> if d [ '<STR_LIT:key>' ] == '<STR_LIT>' : <EOL> count += <NUM_LIT:1> <EOL> sshKeys = d [ '<STR_LIT:value>' ] <EOL> self . assertEqual ( sshKeys , '<STR_LIT>' ) <EOL> self . assertEqual ( count , <NUM_LIT:0> ) <EOL> def test_ex_set_common_instance_metadata ( self ) : <EOL> self . assertRaises ( ValueError , <EOL> self . driver . ex_set_common_instance_metadata , <EOL> [ '<STR_LIT>' , '<STR_LIT:type>' ] ) <EOL> pydict = { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : <NUM_LIT:1> } <EOL> self . driver . ex_set_common_instance_metadata ( pydict ) <EOL> bad_gcedict = { '<STR_LIT>' : '<STR_LIT:foo>' } <EOL> self . assertRaises ( ValueError , <EOL> self . driver . ex_set_common_instance_metadata , <EOL> bad_gcedict ) <EOL> gcedict = { '<STR_LIT>' : [ { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } ] } <EOL> self . driver . ex_set_common_instance_metadata ( gcedict ) <EOL> def test_ex_set_node_metadata ( self ) : <EOL> node = self . driver . ex_get_node ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertRaises ( ValueError , self . driver . ex_set_node_metadata , <EOL> node , [ '<STR_LIT>' , '<STR_LIT:type>' ] ) <EOL> pydict = { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : <NUM_LIT:1> } <EOL> self . driver . ex_set_node_metadata ( node , pydict ) <EOL> bad_gcedict = { '<STR_LIT>' : '<STR_LIT:foo>' } <EOL> self . assertRaises ( ValueError , self . driver . ex_set_node_metadata , <EOL> node , bad_gcedict ) <EOL> gcedict = { '<STR_LIT>' : [ { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } ] } <EOL> self . driver . ex_set_node_metadata ( node , gcedict ) <EOL> def test_ex_get_region ( self ) : <EOL> region_name = '<STR_LIT>' <EOL> region = self . driver . ex_get_region ( region_name ) <EOL> self . assertEqual ( region . name , region_name ) <EOL> self . assertEqual ( region . status , '<STR_LIT>' ) <EOL> self . assertEqual ( region . zones [ <NUM_LIT:0> ] . name , '<STR_LIT>' ) <EOL> def test_ex_get_size ( self ) : <EOL> size_name = '<STR_LIT>' <EOL> size = self . driver . ex_get_size ( size_name ) <EOL> self . assertEqual ( size . name , size_name ) <EOL> self . assertEqual ( size . extra [ '<STR_LIT>' ] . name , '<STR_LIT>' ) <EOL> self . assertEqual ( size . disk , <NUM_LIT:10> ) <EOL> self . assertEqual ( size . ram , <NUM_LIT> ) <EOL> self . assertEqual ( size . extra [ '<STR_LIT>' ] , <NUM_LIT:1> ) <EOL> def test_ex_get_targethttpproxy ( self ) : <EOL> targethttpproxy_name = '<STR_LIT>' <EOL> targethttpproxy = self . driver . ex_get_targethttpproxy ( <EOL> targethttpproxy_name ) <EOL> self . assertEqual ( targethttpproxy . name , targethttpproxy_name ) <EOL> self . assertEqual ( targethttpproxy . urlmap . name , '<STR_LIT>' ) <EOL> def test_ex_get_targetinstance ( self ) : <EOL> targetinstance_name = '<STR_LIT>' <EOL> targetinstance = self . driver . ex_get_targetinstance ( targetinstance_name ) <EOL> self . assertEqual ( targetinstance . name , targetinstance_name ) <EOL> self . assertEqual ( targetinstance . zone . name , '<STR_LIT>' ) <EOL> def test_ex_get_targetpool ( self ) : <EOL> targetpool_name = '<STR_LIT>' <EOL> targetpool = self . driver . ex_get_targetpool ( targetpool_name ) <EOL> self . assertEqual ( targetpool . name , targetpool_name ) <EOL> self . assertEqual ( len ( targetpool . nodes ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( targetpool . region . name , '<STR_LIT>' ) <EOL> def test_ex_get_snapshot ( self ) : <EOL> snapshot_name = '<STR_LIT>' <EOL> snapshot = self . driver . ex_get_snapshot ( snapshot_name ) <EOL> self . assertEqual ( snapshot . name , snapshot_name ) <EOL> self . assertEqual ( snapshot . size , '<STR_LIT>' ) <EOL> self . assertEqual ( snapshot . status , '<STR_LIT>' ) <EOL> def test_ex_get_urlmap ( self ) : <EOL> urlmap_name = '<STR_LIT>' <EOL> urlmap = self . driver . ex_get_urlmap ( urlmap_name ) <EOL> self . assertEqual ( urlmap . name , urlmap_name ) <EOL> self . assertEqual ( urlmap . default_service . name , '<STR_LIT>' ) <EOL> def test_ex_get_volume ( self ) : <EOL> volume_name = '<STR_LIT>' <EOL> volume = self . driver . ex_get_volume ( volume_name ) <EOL> self . assertEqual ( volume . name , volume_name ) <EOL> self . assertEqual ( volume . size , '<STR_LIT>' ) <EOL> self . assertEqual ( volume . extra [ '<STR_LIT:status>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( volume . extra [ '<STR_LIT:type>' ] , '<STR_LIT>' ) <EOL> def test_ex_get_disktype ( self ) : <EOL> disktype_name = '<STR_LIT>' <EOL> disktype_zone = '<STR_LIT>' <EOL> disktype = self . driver . ex_get_disktype ( disktype_name , disktype_zone ) <EOL> self . assertEqual ( disktype . name , disktype_name ) <EOL> self . assertEqual ( disktype . zone . name , disktype_zone ) <EOL> self . assertEqual ( disktype . extra [ '<STR_LIT:description>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( disktype . extra [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( disktype . extra [ '<STR_LIT>' ] , '<STR_LIT:100>' ) <EOL> def test_ex_get_zone ( self ) : <EOL> zone_name = '<STR_LIT>' <EOL> zone = self . driver . ex_get_zone ( zone_name ) <EOL> self . assertEqual ( zone . name , zone_name ) <EOL> self . assertFalse ( zone . time_until_mw ) <EOL> self . assertFalse ( zone . next_mw_duration ) <EOL> zone_no_mw = self . driver . ex_get_zone ( '<STR_LIT>' ) <EOL> self . assertEqual ( zone_no_mw . time_until_mw , None ) <EOL> class GCEMockHttp ( MockHttpTestCase ) : <EOL> fixtures = ComputeFileFixtures ( '<STR_LIT>' ) <EOL> json_hdr = { '<STR_LIT>' : '<STR_LIT>' } <EOL> def _get_method_name ( self , type , use_param , qs , path ) : <EOL> api_path = '<STR_LIT>' % API_VERSION <EOL> project_path = '<STR_LIT>' % GCE_KEYWORD_PARAMS [ '<STR_LIT>' ] <EOL> path = path . replace ( api_path , '<STR_LIT>' ) <EOL> path = path . replace ( project_path , '<STR_LIT>' ) <EOL> if not path : <EOL> path = '<STR_LIT>' <EOL> method_name = super ( GCEMockHttp , self ) . _get_method_name ( type , <EOL> use_param , <EOL> qs , path ) <EOL> return method_name <EOL> def _setUsageExportBucket ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT:POST>' : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _zones_us_central1_a_instances_custom_node ( self , method , url , body , header ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _zones_us_central1_a_instances_node_name_setMachineType ( self , method , url , body , header ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _zones_us_central1_a_operations_operation_setMachineType_notstopped ( self , method , url , body , header ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _zones_us_central1_a_instances_custom_node_setMachineType ( self , method , url , body , header ) : <EOL> body = { <EOL> \"<STR_LIT:error>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:message>\" : \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> } <EOL> ] , <EOL> \"<STR_LIT:code>\" : <NUM_LIT> , <EOL> \"<STR_LIT:message>\" : \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> } <EOL> } <EOL> return ( httplib . BAD_REQUEST , body , self . json_hdr , httplib . responses [ httplib . BAD_REQUEST ] ) <EOL> def _zones_us_central1_a_instances_stopped_node_setMachineType ( self , method , url , body , header ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _zones_us_central1_a_operations_operation_setMachineType ( self , method , url , body , header ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _zones_us_central1_a_operations_operation_startnode ( self , method , url , body , header ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _zones_us_central1_a_instances_stopped_node_start ( self , method , url , body , header ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _zones_us_central1_a_instances_stopped_node_stop ( self , method , url , body , header ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _zones_us_central1_a_instances_stopped_node ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _zones_us_central1_a_operations_operation_stopnode ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _zones_us_central1_a_instances_node_name_stop ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _zones_us_central1_a_instances_node_name_setMetadata ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _setCommonInstanceMetadata ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT:POST>' : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _aggregated_addresses ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _aggregated_diskTypes ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _aggregated_disks ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _aggregated_forwardingRules ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _aggregated_instances ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _aggregated_machineTypes ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _aggregated_targetInstances ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _aggregated_targetPools ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_backendServices ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT:POST>' : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> else : <EOL> backend_name = getattr ( self . test , '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> body = self . fixtures . load ( '<STR_LIT>' % <EOL> backend_name ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_backendServices_no_backends ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_backendServices_web_service ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT>' : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> else : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_forwardingRules ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT:POST>' : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> else : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_forwardingRules_http_rule ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT>' : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> else : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_httpHealthChecks ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT:POST>' : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> else : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_httpHealthChecks_default_health_check ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_httpHealthChecks_basic_check ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_httpHealthChecks_libcloud_lb_demo_healthcheck ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_httpHealthChecks_lchealthcheck ( self , method , url , body , <EOL> headers ) : <EOL> if method == '<STR_LIT>' : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> elif method == '<STR_LIT>' : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> else : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_firewalls ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT:POST>' : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> else : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_firewalls_lcfirewall ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT>' : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> elif method == '<STR_LIT>' : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> else : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_images ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT:POST>' : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> else : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_images_debian_7_wheezy_v20131120 ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_images_debian_7_wheezy_v20131014_deprecate ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_images_family_coreos ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . NOT_FOUND , body , self . json_hdr , <EOL> httplib . responses [ httplib . NOT_FOUND ] ) <EOL> def _global_images_family_nofamily ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . NOT_FOUND , body , self . json_hdr , <EOL> httplib . responses [ httplib . NOT_FOUND ] ) <EOL> def _global_routes ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT:POST>' : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> else : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_networks ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT:POST>' : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> else : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_networks_default ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_networks_libcloud_demo_network ( self , method , url , body , <EOL> headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_networks_libcloud_demo_europe_network ( self , method , url , body , <EOL> headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_routes_lcdemoroute ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT>' : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> else : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_networks_lcnetwork ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT>' : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> else : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_snapshots ( self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_snapshots_lcsnapshot ( self , method , url , body , headers ) : <EOL> if method == '<STR_LIT>' : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> else : <EOL> body = self . fixtures . load ( '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_setUsageExportBucket ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_setCommonInstanceMetadata ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_backendServices_post ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_backendServices_web_service_delete ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_forwardingRules_http_rule_delete ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_forwardingRules_post ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_httpHealthChecks_lchealthcheck_delete ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_images_debian7_delete ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_httpHealthChecks_lchealthcheck_put ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_httpHealthChecks_post ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_firewalls_lcfirewall_delete ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_firewalls_lcfirewall_put ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_firewalls_post ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_routes_lcdemoroute_delete ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_networks_lcnetwork_delete ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_routes_post ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_networks_post ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL> def _global_operations_operation_global_snapshots_lcsnapshot_delete ( <EOL> self , method , url , body , headers ) : <EOL> body = self . fixtures . load ( <EOL> '<STR_LIT>' ) <EOL> return ( httplib . OK , body , self . json_hdr , httplib . responses [ httplib . OK ] ) <EOL>", "answer": "def _global_operations_operation_global_image_post ("}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import re <EOL> import inspect <EOL> import cPickle as pickle <EOL> from jasmin . protocols . cli . managers import PersistableManager , Session <EOL> from jasmin . protocols . cli . filtersm import MTFILTERS <EOL> from jasmin . routing . jasminApi import MTInterceptorScript <EOL> from jasmin . routing . Interceptors import ( DefaultInterceptor , StaticMTInterceptor ) <EOL> MTINTERCEPTORS = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> MTInterceptorKeyMap = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:type>' : '<STR_LIT:type>' } <EOL> class InvalidScriptSyntax ( Exception ) : <EOL> pass <EOL> def validate_typed_script ( script ) : <EOL> '<STR_LIT>' <EOL> m = re . match ( r'<STR_LIT>' , script , re . I ) <EOL> if not m : <EOL> raise InvalidScriptSyntax ( '<STR_LIT>' ) <EOL> else : <EOL> language = m . group ( <NUM_LIT:1> ) . lower ( ) <EOL> script_path = m . group ( <NUM_LIT:2> ) <EOL> return language , script_path <EOL> def MTInterceptorBuild ( fCallback ) : <EOL> '''<STR_LIT>''' <EOL> def parse_args_and_call_with_instance ( self , * args , ** kwargs ) : <EOL> cmd = args [ <NUM_LIT:0> ] <EOL> arg = args [ <NUM_LIT:1> ] <EOL> if cmd is None : <EOL> return self . protocol . sendData ( ) <EOL> if cmd == '<STR_LIT>' : <EOL> if len ( self . sessBuffer ) - <NUM_LIT:2> < len ( self . protocol . sessionCompletitions ) : <EOL> return self . protocol . sendData ( '<STR_LIT>' % '<STR_LIT:U+002CU+0020>' . join ( <EOL> self . protocol . sessionCompletitions ) ) <EOL> interceptor = { } <EOL> for key , value in self . sessBuffer . iteritems ( ) : <EOL> if key not in [ '<STR_LIT>' , '<STR_LIT:type>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> interceptor [ key ] = value <EOL> try : <EOL> InterceptorInstance = self . sessBuffer [ '<STR_LIT>' ] ( ** interceptor ) <EOL> return fCallback ( self , self . sessBuffer [ '<STR_LIT>' ] , InterceptorInstance ) <EOL> except Exception , e : <EOL> return self . protocol . sendData ( '<STR_LIT>' % str ( e ) ) <EOL> else : <EOL> ia = [ ] <EOL> if '<STR_LIT>' in self . sessBuffer : <EOL> ia = self . sessBuffer [ '<STR_LIT>' ] <EOL> if cmd not in MTInterceptorKeyMap and cmd not in ia : <EOL> return self . protocol . sendData ( '<STR_LIT>' % cmd ) <EOL> if cmd == '<STR_LIT:type>' : <EOL> _type = None <EOL> for interceptor in MTINTERCEPTORS : <EOL> if arg . lower ( ) == interceptor . lower ( ) : <EOL> _type = interceptor <EOL> break <EOL> if _type is None : <EOL> return self . protocol . sendData ( <EOL> '<STR_LIT>' % ( <EOL> arg , '<STR_LIT:U+002CU+0020>' . join ( MTINTERCEPTORS ) ) ) <EOL> elif _type == '<STR_LIT>' : <EOL> self . sessBuffer [ '<STR_LIT>' ] = <NUM_LIT:0> <EOL> if '<STR_LIT>' in self . sessBuffer : <EOL> self . sessBuffer = { '<STR_LIT>' : self . sessBuffer [ '<STR_LIT>' ] } <EOL> else : <EOL> self . sessBuffer = { } <EOL> self . sessBuffer [ '<STR_LIT:type>' ] = _type <EOL> self . sessBuffer [ '<STR_LIT>' ] = globals ( ) [ _type ] <EOL> InterceptorClassArgs = inspect . getargspec ( self . sessBuffer [ '<STR_LIT>' ] . __init__ ) . args <EOL> if '<STR_LIT>' in InterceptorClassArgs : <EOL> InterceptorClassArgs . remove ( '<STR_LIT>' ) <EOL> self . sessBuffer [ '<STR_LIT>' ] = InterceptorClassArgs <EOL> if len ( InterceptorClassArgs ) > <NUM_LIT:0> : <EOL> self . protocol . sessionCompletitions = MTInterceptorKeyMap . keys ( ) + InterceptorClassArgs <EOL> return self . protocol . sendData ( <EOL> '<STR_LIT>' % ( <EOL> self . sessBuffer [ '<STR_LIT>' ] , '<STR_LIT:U+002CU+0020>' . join ( InterceptorClassArgs ) ) ) <EOL> else : <EOL> if cmd == '<STR_LIT>' : <EOL> if ( arg != '<STR_LIT:0>' and '<STR_LIT:type>' in self . sessBuffer <EOL> and self . sessBuffer [ '<STR_LIT:type>' ] == '<STR_LIT>' ) : <EOL> self . sessBuffer [ '<STR_LIT>' ] = <NUM_LIT:0> <EOL> return self . protocol . sendData ( <EOL> '<STR_LIT>' ) <EOL> elif ( arg == '<STR_LIT:0>' and '<STR_LIT:type>' in self . sessBuffer and <EOL> self . sessBuffer [ '<STR_LIT:type>' ] != '<STR_LIT>' ) : <EOL> return self . protocol . sendData ( <EOL> '<STR_LIT>' ) <EOL> elif not arg . isdigit ( ) or int ( arg ) < <NUM_LIT:0> : <EOL> return self . protocol . sendData ( '<STR_LIT>' ) <EOL> else : <EOL> arg = int ( arg ) <EOL> if cmd == '<STR_LIT>' : <EOL> try : <EOL> stype , script_path = validate_typed_script ( arg ) <EOL> if stype == '<STR_LIT>' : <EOL> with open ( script_path , '<STR_LIT:r>' ) as content_file : <EOL> pyCode = content_file . read ( ) <EOL> compile ( pyCode , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> raise NotImplementedError ( \"<STR_LIT>\" ) <EOL> except IOError , e : <EOL> return self . protocol . sendData ( '<STR_LIT>' % str ( e ) ) <EOL> except SyntaxError , e : <EOL> return self . protocol . sendData ( '<STR_LIT>' % str ( e ) ) <EOL> except Exception , e : <EOL> return self . protocol . sendData ( '<STR_LIT:%s>' % str ( e ) ) <EOL> else : <EOL> arg = MTInterceptorScript ( pyCode ) <EOL> if cmd == '<STR_LIT>' : <EOL> FIDs = arg . split ( '<STR_LIT:;>' ) <EOL> arg = [ ] <EOL> for fid in FIDs : <EOL> if fid not in self . protocol . managers [ '<STR_LIT>' ] . filters : <EOL> return self . protocol . sendData ( '<STR_LIT>' % ( fid ) ) <EOL> else : <EOL> _Filter = self . protocol . managers [ '<STR_LIT>' ] . filters [ fid ] <EOL> if _Filter . __class__ . __name__ not in MTFILTERS : <EOL> return self . protocol . sendData ( <EOL> '<STR_LIT>' % ( <EOL> _Filter . __class__ . __name__ , fid <EOL> ) <EOL> ) <EOL> else : <EOL> arg . append ( _Filter ) <EOL> if cmd not in ia : <EOL> InterceptorKey = MTInterceptorKeyMap [ cmd ] <EOL> else : <EOL> InterceptorKey = cmd <EOL> self . sessBuffer [ InterceptorKey ] = arg <EOL> return self . protocol . sendData ( ) <EOL> return parse_args_and_call_with_instance <EOL> class MTInterceptorExist ( object ) : <EOL> '<STR_LIT>' <EOL> def __init__ ( self , order_key ) : <EOL> self . order_key = order_key <EOL> def __call__ ( self , fCallback ) : <EOL> order_key = self . order_key <EOL>", "answer": "def exist_mtinterceptor_and_call ( self , * args , ** kwargs ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> from xml . etree . cElementTree import iterparse <EOL> except ImportError : <EOL> from xml . etree . ElementTree import iterparse <EOL> from ... . compat import ifilter <EOL> from ... . compat import BytesIO as StringIO <EOL> from . . cell import Cell , coordinate_from_string <EOL> from . . worksheet import Worksheet <EOL> def _get_xml_iter ( xml_source ) : <EOL>", "answer": "if not hasattr ( xml_source , '<STR_LIT:name>' ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from ctypes import * <EOL> import unittest <EOL> class VarSizeTest ( unittest . TestCase ) : <EOL> def test_resize ( self ) : <EOL> class X ( Structure ) : <EOL> _fields_ = [ ( \"<STR_LIT>\" , c_int ) , <EOL> ( \"<STR_LIT>\" , c_int * <NUM_LIT:1> ) ] <EOL> self . assertEqual ( sizeof ( X ) , sizeof ( c_int ) * <NUM_LIT:2> ) <EOL> x = X ( ) <EOL> x . item = <NUM_LIT> <EOL> x . array [ <NUM_LIT:0> ] = <NUM_LIT:100> <EOL> self . assertEqual ( sizeof ( x ) , sizeof ( c_int ) * <NUM_LIT:2> ) <EOL> new_size = sizeof ( X ) + sizeof ( c_int ) * <NUM_LIT:1> <EOL> resize ( x , new_size ) <EOL> self . assertEqual ( sizeof ( x ) , new_size ) <EOL> self . assertEqual ( ( x . item , x . array [ <NUM_LIT:0> ] ) , ( <NUM_LIT> , <NUM_LIT:100> ) ) <EOL> new_size = sizeof ( X ) + sizeof ( c_int ) * <NUM_LIT:9> <EOL> resize ( x , new_size ) <EOL> self . assertEqual ( sizeof ( x ) , new_size ) <EOL> self . assertEqual ( ( x . item , x . array [ <NUM_LIT:0> ] ) , ( <NUM_LIT> , <NUM_LIT:100> ) ) <EOL> new_size = sizeof ( X ) + sizeof ( c_int ) * <NUM_LIT:1> <EOL> resize ( x , new_size ) <EOL> self . assertEqual ( sizeof ( x ) , new_size ) <EOL>", "answer": "self . assertEqual ( ( x . item , x . array [ <NUM_LIT:0> ] ) , ( <NUM_LIT> , <NUM_LIT:100> ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> class Solution : <EOL> def uniquePaths ( self , m , n ) : <EOL> if m < n : <EOL> return self . uniquePaths ( n , m ) <EOL> ways = [ <NUM_LIT:1> ] * n <EOL> for i in xrange ( <NUM_LIT:1> , m ) : <EOL> for j in xrange ( <NUM_LIT:1> , n ) : <EOL>", "answer": "ways [ j ] += ways [ j - <NUM_LIT:1> ]"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> import random <EOL> import time <EOL> try : <EOL> from hashlib import md5 <EOL> except ImportError : <EOL> from md5 import md5 <EOL> from backends . base import KeyError <EOL> class SessionException ( Exception ) : pass <EOL> class NValue ( object ) : pass <EOL> getpid = hasattr ( os , '<STR_LIT>' ) and os . getpid or ( lambda : '<STR_LIT>' ) <EOL> def _get_id ( ) : <EOL> return md5 ( <EOL> md5 ( \"<STR_LIT>\" % ( time . time ( ) , id ( { } ) , random . random ( ) , <EOL> getpid ( ) ) ) . hexdigest ( ) , <EOL> ) . hexdigest ( ) <EOL> class SessionCookie ( object ) : <EOL> default_expiry_time = None <EOL> default_domain = '<STR_LIT>' <EOL> default_secure = False <EOL> default_path = '<STR_LIT:/>' <EOL> default_cookie_id = '<STR_LIT>' <EOL> def __init__ ( self , session ) : <EOL> self . session = session <EOL> self . domain = self . default_domain <EOL> self . path = self . default_path <EOL> self . secure = self . default_secure <EOL> self . expiry_time = self . default_expiry_time <EOL> self . cookie_id = self . default_cookie_id <EOL> def save ( self ) : <EOL> self . expiry_time = self . expiry_time or self . session . expiry_time <EOL> from cache import Serial <EOL> class Session ( dict ) : <EOL> force = False <EOL> def __init__ ( self , key = None , storage_type = '<STR_LIT:file>' , options = None , expiry_time = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> , <EOL> serial_cls = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dict . __init__ ( self ) <EOL> self . _old_value = { } <EOL> self . _storage_type = storage_type <EOL> self . _options = options or { } <EOL> self . _storage_cls = self . __get_storage ( ) <EOL> self . _storage = None <EOL> self . _accessed_time = None <EOL> self . expiry_time = expiry_time <EOL> self . key = key <EOL> self . deleted = False <EOL> self . cookie = SessionCookie ( self ) <EOL> self . _serial_cls = serial_cls or Serial <EOL> self . serial_obj = self . _serial_cls ( ) <EOL> self . load ( self . key ) <EOL> def __get_storage ( self ) : <EOL> modname = '<STR_LIT>' % self . _storage_type <EOL> mod = __import__ ( modname , fromlist = [ '<STR_LIT:*>' ] ) <EOL> _class = getattr ( mod , '<STR_LIT>' , None ) <EOL> return _class <EOL> def _set_remember ( self , v ) : <EOL> self [ '<STR_LIT>' ] = v <EOL> def _get_remember ( self ) : <EOL> return self . get ( '<STR_LIT>' , False ) <EOL> remember = property ( _get_remember , _set_remember ) <EOL> @ property <EOL> def storage ( self ) : <EOL> if not self . _storage : <EOL> self . _storage = self . _storage_cls ( self , self . _options ) <EOL> return self . _storage <EOL> def load ( self , key = None ) : <EOL> self . deleted = False <EOL> self . clear ( ) <EOL> self . key = key <EOL> if not self . key : <EOL>", "answer": "return"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from collections import defaultdict <EOL> import numpy as np <EOL> from pgmpy . base import UndirectedGraph <EOL> from pgmpy . factors import factor_product <EOL> from pgmpy . extern . six . moves import filter , range , zip <EOL> class ClusterGraph ( UndirectedGraph ) : <EOL> r\"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , ebunch = None ) : <EOL> super ( ClusterGraph , self ) . __init__ ( ) <EOL> if ebunch : <EOL> self . add_edges_from ( ebunch ) <EOL> self . factors = [ ] <EOL> def add_node ( self , node , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( node , ( list , set , tuple ) ) : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> node = tuple ( node ) <EOL> super ( ClusterGraph , self ) . add_node ( node , ** kwargs ) <EOL> def add_nodes_from ( self , nodes , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for node in nodes : <EOL> self . add_node ( node , ** kwargs ) <EOL> def add_edge ( self , u , v , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> set_u = set ( u ) <EOL> set_v = set ( v ) <EOL> if set_u . isdisjoint ( set_v ) : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> super ( ClusterGraph , self ) . add_edge ( u , v ) <EOL> def add_factors ( self , * factors ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for factor in factors : <EOL> factor_scope = set ( factor . scope ( ) ) <EOL> nodes = [ set ( node ) for node in self . nodes ( ) ] <EOL> if factor_scope not in nodes : <EOL> raise ValueError ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> self . factors . append ( factor ) <EOL> def get_factors ( self , node = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if node is None : <EOL> return self . factors <EOL> else : <EOL> nodes = [ set ( n ) for n in self . nodes ( ) ] <EOL> if set ( node ) not in nodes : <EOL>", "answer": "raise ValueError ( '<STR_LIT>' )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> class blank ( object ) : <EOL> def __init__ ( self ) : <EOL> object . __init__ ( self ) <EOL> deployment_settings = blank ( ) <EOL> deployment_settings . web2py = blank ( ) <EOL> deployment_settings . web2py . port = <NUM_LIT> <EOL> deployment_settings . database = blank ( ) <EOL> deployment_settings . database . db_type = \"<STR_LIT>\" <EOL> deployment_settings . database . host = \"<STR_LIT:localhost>\" <EOL> deployment_settings . database . port = None <EOL> deployment_settings . database . database = \"<STR_LIT>\" <EOL>", "answer": "deployment_settings . database . username = \"<STR_LIT>\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> import json <EOL> except ImportError : <EOL> import simplejson as json <EOL> from flask import current_app <EOL> from werkzeug import url_encode <EOL> try : <EOL>", "answer": "from flaskext . babel import gettext as _"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django_services import service <EOL> from . import models <EOL>", "answer": "class BindService ( service . CRUDService ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from distutils . core import setup <EOL>", "answer": "from Cython . Build import cythonize"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> import sys <EOL> import unittest <EOL> from doctest import DocTestFinder , DocTestRunner , TestResults <EOL> if sys . version [ <NUM_LIT:0> ] == '<STR_LIT:2>' : <EOL> from . _paramtestpy2 import ParametricTestCase <EOL> else : <EOL> from . _paramtestpy3 import ParametricTestCase <EOL> def count_failures ( runner ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return [ TestResults ( f , t ) for f , t in list ( runner . _name2ft . values ( ) ) if f > <NUM_LIT:0> ] <EOL> class IPython2PythonConverter ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> self . rps1 = re . compile ( r'<STR_LIT>' ) <EOL> self . rps2 = re . compile ( r'<STR_LIT>' ) <EOL> self . rout = re . compile ( r'<STR_LIT>' ) <EOL> self . pyps1 = '<STR_LIT>' <EOL> self . pyps2 = '<STR_LIT>' <EOL> self . rpyps1 = re . compile ( '<STR_LIT>' % self . pyps1 ) <EOL> self . rpyps2 = re . compile ( '<STR_LIT>' % self . pyps2 ) <EOL> def __call__ ( self , ds ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from . import globalipapp <EOL> pyps1 = '<STR_LIT>' <EOL> pyps2 = '<STR_LIT>' <EOL> pyout = '<STR_LIT>' <EOL> dnew = ds <EOL> dnew = self . rps1 . sub ( pyps1 , dnew ) <EOL> dnew = self . rps2 . sub ( pyps2 , dnew ) <EOL> dnew = self . rout . sub ( pyout , dnew ) <EOL> ip = globalipapp . get_ipython ( ) <EOL> out = [ ] <EOL> newline = out . append <EOL> for line in dnew . splitlines ( ) : <EOL> mps1 = self . rpyps1 . match ( line ) <EOL> if mps1 is not None : <EOL> prompt , text = mps1 . groups ( ) <EOL> newline ( prompt + ip . prefilter ( text , False ) ) <EOL> continue <EOL> mps2 = self . rpyps2 . match ( line ) <EOL> if mps2 is not None : <EOL> prompt , text = mps2 . groups ( ) <EOL> newline ( prompt + ip . prefilter ( text , True ) ) <EOL>", "answer": "continue"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> import os <EOL> import re <EOL> import six <EOL> from six . moves import ( <EOL> configparser , <EOL> filter , <EOL> reload_module , <EOL> ) <EOL> from staticconf import config , errors <EOL> __all__ = [ <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from zerotest . cli import CLI <EOL> class AttributeDict ( object ) : <EOL> def __init__ ( self , ** kwargs ) : <EOL> self . __dict__ = kwargs <EOL> def test_verify_parse_result ( ) : <EOL> cli = CLI ( ) <EOL> cli . _parse_result = AttributeDict ( url = '<STR_LIT>' ) <EOL> assert not cli . verify_parse_result ( ) <EOL> cli . _parse_result = AttributeDict ( url = '<STR_LIT>' ) <EOL>", "answer": "assert cli . verify_parse_result ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Tangible ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import mock <EOL> import unittest <EOL> import uuid <EOL> def fake_id ( prefix ) : <EOL> entropy = '<STR_LIT>' . join ( [ a for a in str ( uuid . uuid4 ( ) ) if a . isalnum ( ) ] ) <EOL> return '<STR_LIT>' . format ( prefix , entropy ) <EOL> class APITestCase ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( APITestCase , self ) . setUp ( ) <EOL> self . requestor_patcher = mock . patch ( '<STR_LIT>' ) <EOL> requestor_class_mock = self . requestor_patcher . start ( ) <EOL> self . requestor_mock = requestor_class_mock . return_value <EOL> def mock_response ( self , res ) : <EOL> self . requestor_mock . request = mock . Mock ( return_value = ( res , '<STR_LIT>' ) ) <EOL> class TestData ( object ) : <EOL> @ classmethod <EOL> def file_upload_response ( cls ) : <EOL> return { <EOL> '<STR_LIT:id>' : fake_id ( '<STR_LIT:file>' ) , <EOL> '<STR_LIT:object>' : '<STR_LIT:file>' , <EOL> } <EOL> @ classmethod <EOL> def evaluation_response ( cls ) : <EOL> return { <EOL> '<STR_LIT:id>' : fake_id ( '<STR_LIT:file>' ) , <EOL> '<STR_LIT:object>' : '<STR_LIT>' , <EOL>", "answer": "} "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> __date__ = '<STR_LIT>' <EOL> __version__ = '<STR_LIT>' <EOL> __rights__ = '<STR_LIT>' <EOL> import sys <EOL> import pytest <EOL> def _filter ( fn , iterable ) : <EOL> pass <EOL> def _map ( fn , iterable ) : <EOL> pass <EOL> def test_filter ( ) : <EOL> seq = [ <NUM_LIT:1> , - <NUM_LIT:2> , <NUM_LIT:3> , - <NUM_LIT:4> ] <EOL> assert ( filter ( lambda x : x > <NUM_LIT:0> , seq ) == _filter ( lambda x : x > <NUM_LIT:0> , seq ) ) <EOL> def test_map ( ) : <EOL> seq = '<STR_LIT>' <EOL> assert ( map ( lambda x : x . upper ( ) , seq ) == _map ( lambda x : x . upper ( ) , seq ) ) <EOL>", "answer": "def main ( ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import logging <EOL> import cgi <EOL> import sys <EOL> import traceback <EOL> import hashlib <EOL> import os <EOL> from functools import wraps <EOL> import webapp2 <EOL> from webapp2_extras import sessions , json , auth , i18n <EOL> from jinja2 . runtime import TemplateNotFound <EOL> import settings <EOL> import utils <EOL> from handlers import jinja_environment <EOL> def get_json_error ( code , key = None , message = None ) : <EOL> logging . debug ( json . encode ( get_error ( code , key = key , message = message ) ) ) <EOL>", "answer": "return json . encode ( get_error ( code , key = key , message = message ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "__author__ = '<STR_LIT>'"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function , division , absolute_import , unicode_literals <EOL> import sys <EOL> from RPLCD import CharLCD <EOL> try : <EOL> range = xrange <EOL> except NameError : <EOL> pass <EOL> try : <EOL> safe_input = raw_input <EOL> except NameError : <EOL> safe_input = input <EOL> try : <EOL> unichr = unichr <EOL> except NameError : <EOL> unichr = chr <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> if len ( sys . argv ) != <NUM_LIT:3> : <EOL> print ( '<STR_LIT>' % sys . argv [ <NUM_LIT:0> ] ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> rows , cols = int ( sys . argv [ <NUM_LIT:1> ] ) , int ( sys . argv [ <NUM_LIT:2> ] ) <EOL> lcd = CharLCD ( cols = cols , rows = rows ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' ) <EOL> page = <NUM_LIT:0> <EOL> chars = rows * cols <EOL> try : <EOL> while True : <EOL> offset = page * chars <EOL> start = offset <EOL> end = offset + chars <EOL> lcd . clear ( ) <EOL>", "answer": "for i in range ( offset , offset + chars ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import unittest <EOL> from polynomial import Polynomial <EOL> from ff import GF256int <EOL> class TestGFPoly ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def test_add ( self ) : <EOL> one = Polynomial ( map ( GF256int , ( <NUM_LIT:8> , <NUM_LIT:3> , <NUM_LIT:5> , <NUM_LIT:1> ) ) ) <EOL> two = Polynomial ( map ( GF256int , ( <NUM_LIT:5> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:6> , <NUM_LIT:8> ) ) ) <EOL> r = one + two <EOL> self . assertEqual ( r . coefficients , ( <NUM_LIT:5> , <NUM_LIT:3> , <NUM_LIT:9> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:9> ) ) <EOL> def test_sub ( self ) : <EOL> one = Polynomial ( map ( GF256int , ( <NUM_LIT:8> , <NUM_LIT:3> , <NUM_LIT:5> , <NUM_LIT:1> ) ) ) <EOL> two = Polynomial ( map ( GF256int , ( <NUM_LIT:5> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:6> , <NUM_LIT:8> ) ) ) <EOL> r = one - two <EOL> self . assertEqual ( r . coefficients , ( <NUM_LIT:5> , <NUM_LIT:3> , <NUM_LIT:9> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:9> ) ) <EOL> def test_mul ( self ) : <EOL> one = Polynomial ( map ( GF256int , ( <NUM_LIT:8> , <NUM_LIT:3> , <NUM_LIT:5> , <NUM_LIT:1> ) ) ) <EOL> two = Polynomial ( map ( GF256int , ( <NUM_LIT:5> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:6> , <NUM_LIT:8> ) ) ) <EOL> r = one * two <EOL> self . assertEqual ( r . coefficients , ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:7> , <NUM_LIT> , <NUM_LIT:8> ) ) <EOL> def test_div ( self ) : <EOL> one = Polynomial ( map ( GF256int , ( <NUM_LIT:8> , <NUM_LIT:3> , <NUM_LIT:5> , <NUM_LIT:1> ) ) ) <EOL> two = Polynomial ( map ( GF256int , ( <NUM_LIT:5> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:6> , <NUM_LIT:8> ) ) ) <EOL> q , r = divmod ( two , one ) <EOL> self . assertEqual ( q . coefficients , ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT:11> ) ) <EOL> self . assertEqual ( r . coefficients , ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT:3> ) ) <EOL> self . assertEqual ( q * one + r , two ) <EOL> def test_div_scalar ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> numbers = map ( GF256int , ( <NUM_LIT:5> , <NUM_LIT:20> , <NUM_LIT:50> , <NUM_LIT:100> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:4> , <NUM_LIT:5> , <NUM_LIT:2> ) ) <EOL> scalar = GF256int ( <NUM_LIT> ) <EOL> poly = Polynomial ( numbers ) <EOL> scalarpoly = Polynomial ( x0 = scalar ) <EOL> self . assertEqual ( <EOL> ( poly // scalarpoly ) . coefficients , <EOL> tuple ( map ( lambda x : x / scalar , numbers ) ) <EOL> ) <EOL> def test_div_scalar2 ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> a = Polynomial ( map ( GF256int , ( <NUM_LIT:5> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:6> , <NUM_LIT:8> ) ) ) <EOL> scalar = GF256int ( <NUM_LIT:50> ) <EOL> self . assertEqual ( <EOL> a * Polynomial ( x0 = scalar ) , <EOL> a // Polynomial ( x0 = scalar . inverse ( ) ) <EOL> ) <EOL> class TestPolynomial ( unittest . TestCase ) : <EOL> def test_add_1 ( self ) : <EOL> one = Polynomial ( ( <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:7> , <NUM_LIT:3> ) ) <EOL> two = Polynomial ( ( <NUM_LIT:5> , <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:2> ) ) <EOL> r = one + two <EOL> self . assertEqual ( r . coefficients , ( <NUM_LIT:7> , <NUM_LIT:6> , <NUM_LIT:11> , <NUM_LIT:5> ) ) <EOL> def test_add_2 ( self ) : <EOL> one = Polynomial ( ( <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:7> , <NUM_LIT:3> , <NUM_LIT:5> , <NUM_LIT:2> ) ) <EOL> two = Polynomial ( ( <NUM_LIT:5> , <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:2> ) ) <EOL> r = one + two <EOL> self . assertEqual ( r . coefficients , ( <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:12> , <NUM_LIT:5> , <NUM_LIT:9> , <NUM_LIT:4> ) ) <EOL> def test_add_3 ( self ) : <EOL> one = Polynomial ( ( <NUM_LIT:7> , <NUM_LIT:3> , <NUM_LIT:5> , <NUM_LIT:2> ) ) <EOL> two = Polynomial ( ( <NUM_LIT:6> , <NUM_LIT:8> , <NUM_LIT:5> , <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:2> ) ) <EOL> r = one + two <EOL> self . assertEqual ( r . coefficients , ( <NUM_LIT:6> , <NUM_LIT:8> , <NUM_LIT:12> , <NUM_LIT:5> , <NUM_LIT:9> , <NUM_LIT:4> ) ) <EOL> def test_mul_1 ( self ) : <EOL> one = Polynomial ( ( <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:7> , <NUM_LIT:3> ) ) <EOL> two = Polynomial ( ( <NUM_LIT:5> , <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:2> ) ) <EOL> r = one * two <EOL> self . assertEqual ( r . coefficients , <EOL> ( <NUM_LIT:10> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:6> ) ) <EOL> def test_div_1 ( self ) : <EOL> one = Polynomial ( ( <NUM_LIT:1> , <NUM_LIT:4> , <NUM_LIT:0> , <NUM_LIT:3> ) ) <EOL> two = Polynomial ( ( <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> ) ) <EOL> q , r = divmod ( one , two ) <EOL> self . assertEqual ( q , one // two ) <EOL> self . assertEqual ( r , one % two ) <EOL> self . assertEqual ( q . coefficients , ( <NUM_LIT:1> , <NUM_LIT:4> ) ) <EOL> self . assertEqual ( r . coefficients , ( - <NUM_LIT:1> , - <NUM_LIT:1> ) ) <EOL> def test_div_2 ( self ) : <EOL> one = Polynomial ( ( <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:1> ) ) <EOL> two = Polynomial ( ( <NUM_LIT:1> , <NUM_LIT:0> , - <NUM_LIT:1> ) ) <EOL> q , r = divmod ( one , two ) <EOL> self . assertEqual ( q , one // two ) <EOL> self . assertEqual ( r , one % two ) <EOL>", "answer": "self . assertEqual ( q . coefficients , ( <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:4> ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL> import json <EOL> from mkdocs import utils <EOL> try : <EOL> from html . parser import HTMLParser <EOL> except ImportError : <EOL> from HTMLParser import HTMLParser <EOL> class SearchIndex ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> self . _entries = [ ] <EOL> def _find_toc_by_id ( self , toc , id_ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for toc_item in toc : <EOL> if toc_item . url [ <NUM_LIT:1> : ] == id_ : <EOL> return toc_item <EOL> toc_item_r = self . _find_toc_by_id ( toc_item . children , id_ ) <EOL> if toc_item_r is not None : <EOL> return toc_item_r <EOL> def _add_entry ( self , title , text , loc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _entries . append ( { <EOL> '<STR_LIT:title>' : title , <EOL> '<STR_LIT:text>' : utils . text_type ( text . strip ( ) . encode ( '<STR_LIT:utf-8>' ) , encoding = '<STR_LIT:utf-8>' ) , <EOL> '<STR_LIT:location>' : loc <EOL> } ) <EOL> def add_entry_from_context ( self , page , content , toc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> parser = ContentParser ( ) <EOL> parser . feed ( content ) <EOL> parser . close ( ) <EOL> abs_url = page . abs_url <EOL> self . _add_entry ( <EOL> title = page . title , <EOL> text = self . strip_tags ( content ) . rstrip ( '<STR_LIT:\\n>' ) , <EOL> loc = abs_url <EOL> ) <EOL> for section in parser . data : <EOL> self . create_entry_for_section ( section , toc , abs_url ) <EOL> def create_entry_for_section ( self , section , toc , abs_url ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from optparse import make_option <EOL> from django . core . management . base import BaseCommand , CommandError <EOL>", "answer": "from olympia . lib . crypto . tasks import unsign_addons"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import networkx as nx <EOL> G = nx . complete_graph ( <NUM_LIT:5> ) <EOL>", "answer": "A = nx . nx_agraph . to_agraph ( G )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from hazelcast . serialization . bits import * <EOL> from hazelcast . protocol . client_message import ClientMessage <EOL> from hazelcast . protocol . custom_codec import * <EOL> from hazelcast . util import ImmutableLazyDataList <EOL> from hazelcast . protocol . codec . map_message_type import * <EOL> REQUEST_TYPE = MAP_EXECUTEONALLKEYS <EOL> RESPONSE_TYPE = <NUM_LIT> <EOL> RETRYABLE = False <EOL> def calculate_size ( name , entry_processor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> data_size = <NUM_LIT:0> <EOL>", "answer": "data_size += calculate_size_str ( name )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pystache import TemplateSpec <EOL> class TemplatePartial ( TemplateSpec ) : <EOL> def __init__ ( self , renderer ) : <EOL> self . renderer = renderer <EOL> def _context_get ( self , key ) : <EOL> return self . renderer . context . get ( key ) <EOL> def title ( self ) : <EOL> return \"<STR_LIT>\" <EOL>", "answer": "def title_bars ( self ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys <EOL> sys . path . append ( '<STR_LIT>' ) <EOL> import unittest <EOL> import numpy as np <EOL> import pandas as pd <EOL> from sklearn import linear_model <EOL> from ramp . estimators import ( Probabilities , <EOL> BinaryProbabilities , <EOL> wrap_sklearn_like_estimator ) <EOL> from ramp import shortcuts <EOL> from ramp . tests . test_features import make_data <EOL>", "answer": "class DummyProbEstimator ( object ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT>''' <EOL> import logging <EOL> import os <EOL> from mc_states import saltapi <EOL> from mc_states . grains . makina_grains import _is_docker <EOL> _errmsg = saltapi . _errmsg <EOL> __name = '<STR_LIT>' <EOL> log = logging . getLogger ( __name__ ) <EOL> VT = '<STR_LIT>' <EOL> PREFIX = '<STR_LIT>' . format ( VT ) <EOL> def vt ( ) : <EOL> return __salt__ [ '<STR_LIT>' ] ( VT ) <EOL> def is_docker ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return _is_docker ( ) <EOL> def vt_default_settings ( cloudSettings , imgSettings ) : <EOL> '''<STR_LIT>''' <EOL> _s = __salt__ <EOL> vmSettings = _s [ '<STR_LIT>' ] ( <EOL> _s [ '<STR_LIT>' ] ( cloudSettings , imgSettings ) , { <EOL> '<STR_LIT>' : VT , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : { } , <EOL> '<STR_LIT>' : { } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:source>' : <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' } , <EOL> '<STR_LIT>' : { } , <EOL> '<STR_LIT>' : { } , <EOL> '<STR_LIT>' : { } , <EOL> '<STR_LIT>' : { } , <EOL> '<STR_LIT>' : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : False , <EOL> '<STR_LIT:source>' : ( <EOL> '<STR_LIT>' <EOL> ) <EOL> } , <EOL> '<STR_LIT>' : { } } , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> } , <EOL> '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' } } ) <EOL>", "answer": "return vmSettings"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import ClientConstants as CC <EOL> import ClientFiles <EOL> import HydrusConstants as HC <EOL> import HydrusData <EOL> import HydrusGlobals <EOL> import HydrusServerResources <EOL> import os <EOL> from twisted . web . static import File as FileResource <EOL> local_booru_css = FileResource ( os . path . join ( HC . STATIC_DIR , '<STR_LIT>' ) , defaultType = '<STR_LIT>' ) <EOL> class HydrusResourceCommandBooru ( HydrusServerResources . HydrusResourceCommand ) : <EOL> def _recordDataUsage ( self , request ) : <EOL> path = request . path [ <NUM_LIT:1> : ] <EOL> if request . method == '<STR_LIT:GET>' : method = HC . GET <EOL> else : method = HC . POST <EOL> if ( HC . LOCAL_BOORU , method , path ) in HC . BANDWIDTH_CONSUMING_REQUESTS : <EOL> num_bytes = request . hydrus_request_data_usage <EOL> HydrusGlobals . client_controller . pub ( '<STR_LIT>' , { CC . LOCAL_BOORU_SERVICE_KEY : [ HydrusData . ServiceUpdate ( HC . SERVICE_UPDATE_REQUEST_MADE , num_bytes ) ] } ) <EOL> def _callbackCheckRestrictions ( self , request ) : <EOL> self . _checkServerBusy ( ) <EOL> self . _checkUserAgent ( request ) <EOL> self . _domain . CheckValid ( request . getClientIP ( ) ) <EOL> return request <EOL> class HydrusResourceCommandBooruFile ( HydrusResourceCommandBooru ) : <EOL> def _threadDoGETJob ( self , request ) : <EOL> share_key = request . hydrus_args [ '<STR_LIT>' ] <EOL> hash = request . hydrus_args [ '<STR_LIT>' ] <EOL> local_booru_manager = HydrusGlobals . client_controller . GetManager ( '<STR_LIT>' ) <EOL> local_booru_manager . CheckFileAuthorised ( share_key , hash ) <EOL> client_files_manager = HydrusGlobals . client_controller . GetClientFilesManager ( ) <EOL> path = client_files_manager . GetFilePath ( hash ) <EOL> response_context = HydrusServerResources . ResponseContext ( <NUM_LIT:200> , path = path ) <EOL> return response_context <EOL> class HydrusResourceCommandBooruGallery ( HydrusResourceCommandBooru ) : <EOL> def _threadDoGETJob ( self , request ) : <EOL> share_key = request . hydrus_args [ '<STR_LIT>' ] <EOL> local_booru_manager = HydrusGlobals . client_controller . GetManager ( '<STR_LIT>' ) <EOL> local_booru_manager . CheckShareAuthorised ( share_key ) <EOL> ( name , text , timeout , media_results ) = local_booru_manager . GetGalleryInfo ( share_key ) <EOL> body = '''<STR_LIT>''' <EOL> if name == '<STR_LIT>' : body += '''<STR_LIT>''' <EOL> else : body += '''<STR_LIT>''' + name + '''<STR_LIT>''' <EOL> body += '''<STR_LIT>''' <EOL> ( thumbnail_width , thumbnail_height ) = HC . options [ '<STR_LIT>' ] <EOL> body += '''<STR_LIT>''' + str ( thumbnail_width ) + '''<STR_LIT>''' + str ( thumbnail_height ) + '''<STR_LIT>''' <EOL> body += '''<STR_LIT>''' <EOL> body += '''<STR_LIT>''' + HydrusData . ConvertTimestampToPrettyExpires ( timeout ) + '''<STR_LIT>''' <EOL> if name != '<STR_LIT>' : body += '''<STR_LIT>''' + name + '''<STR_LIT>''' <EOL> if text != '<STR_LIT>' : <EOL> newline = '''<STR_LIT>''' <EOL> body += '''<STR_LIT>''' + text . replace ( os . linesep , newline ) . replace ( '<STR_LIT:\\n>' , newline ) + '''<STR_LIT>''' <EOL> body += '''<STR_LIT>''' <EOL> for media_result in media_results : <EOL> hash = media_result . GetHash ( ) <EOL> mime = media_result . GetMime ( ) <EOL> body += '''<STR_LIT>''' + share_key . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' + hash . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' + share_key . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' + hash . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' <EOL> body += '''<STR_LIT>''' <EOL> response_context = HydrusServerResources . ResponseContext ( <NUM_LIT:200> , mime = HC . TEXT_HTML , body = body ) <EOL> return response_context <EOL> class HydrusResourceCommandBooruPage ( HydrusResourceCommandBooru ) : <EOL> def _threadDoGETJob ( self , request ) : <EOL> share_key = request . hydrus_args [ '<STR_LIT>' ] <EOL> hash = request . hydrus_args [ '<STR_LIT>' ] <EOL> local_booru_manager = HydrusGlobals . client_controller . GetManager ( '<STR_LIT>' ) <EOL> local_booru_manager . CheckFileAuthorised ( share_key , hash ) <EOL> ( name , text , timeout , media_result ) = local_booru_manager . GetPageInfo ( share_key , hash ) <EOL> body = '''<STR_LIT>''' <EOL> if name == '<STR_LIT>' : body += '''<STR_LIT>''' <EOL> else : body += '''<STR_LIT>''' + name + '''<STR_LIT>''' <EOL> body += '''<STR_LIT>''' <EOL> body += '''<STR_LIT>''' <EOL> body += '''<STR_LIT>''' + HydrusData . ConvertTimestampToPrettyExpires ( timeout ) + '''<STR_LIT>''' <EOL> if name != '<STR_LIT>' : body += '''<STR_LIT>''' + name + '''<STR_LIT>''' <EOL> if text != '<STR_LIT>' : <EOL> newline = '''<STR_LIT>''' <EOL> body += '''<STR_LIT>''' + text . replace ( os . linesep , newline ) . replace ( '<STR_LIT:\\n>' , newline ) + '''<STR_LIT>''' <EOL> body += '''<STR_LIT>''' <EOL> mime = media_result . GetMime ( ) <EOL> if mime in HC . IMAGES : <EOL> ( width , height ) = media_result . GetResolution ( ) <EOL> body += '''<STR_LIT>''' + str ( width ) + '''<STR_LIT>''' + str ( height ) + '''<STR_LIT>''' + share_key . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' + hash . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' <EOL> elif mime in HC . VIDEO : <EOL> ( width , height ) = media_result . GetResolution ( ) <EOL> body += '''<STR_LIT>''' + str ( width ) + '''<STR_LIT>''' + str ( height ) + '''<STR_LIT>''' + share_key . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' + hash . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' + share_key . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' + hash . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' + HC . mime_string_lookup [ mime ] + '''<STR_LIT>''' <EOL> elif mime == HC . APPLICATION_FLASH : <EOL> ( width , height ) = media_result . GetResolution ( ) <EOL> body += '''<STR_LIT>''' + str ( width ) + '''<STR_LIT>''' + str ( height ) + '''<STR_LIT>''' + share_key . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' + hash . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' + share_key . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' + hash . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' + HC . mime_string_lookup [ mime ] + '''<STR_LIT>''' <EOL> else : <EOL> body += '''<STR_LIT>''' + share_key . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' + hash . encode ( '<STR_LIT>' ) + '''<STR_LIT>''' + HC . mime_string_lookup [ mime ] + '''<STR_LIT>''' <EOL> body += '''<STR_LIT>''' <EOL> response_context = HydrusServerResources . ResponseContext ( <NUM_LIT:200> , mime = HC . TEXT_HTML , body = body ) <EOL> return response_context <EOL> class HydrusResourceCommandBooruThumbnail ( HydrusResourceCommandBooru ) : <EOL> def _threadDoGETJob ( self , request ) : <EOL> share_key = request . hydrus_args [ '<STR_LIT>' ] <EOL> hash = request . hydrus_args [ '<STR_LIT>' ] <EOL> local_booru_manager = HydrusGlobals . client_controller . GetManager ( '<STR_LIT>' ) <EOL> local_booru_manager . CheckFileAuthorised ( share_key , hash ) <EOL> media_result = local_booru_manager . GetMediaResult ( share_key , hash ) <EOL> mime = media_result . GetMime ( ) <EOL> if mime in HC . MIMES_WITH_THUMBNAILS : path = ClientFiles . GetThumbnailPath ( hash , full_size = False ) <EOL> elif mime in HC . AUDIO : path = os . path . join ( HC . STATIC_DIR , '<STR_LIT>' ) <EOL> elif mime == HC . APPLICATION_PDF : path = os . path . join ( HC . STATIC_DIR , '<STR_LIT>' ) <EOL> else : path = os . path . join ( HC . STATIC_DIR , '<STR_LIT>' ) <EOL> response_context = HydrusServerResources . ResponseContext ( <NUM_LIT:200> , path = path ) <EOL> return response_context <EOL> class HydrusResourceCommandLocalFile ( HydrusServerResources . HydrusResourceCommand ) : <EOL> def _threadDoGETJob ( self , request ) : <EOL> hash = request . hydrus_args [ '<STR_LIT>' ] <EOL> client_files_manager = HydrusGlobals . client_controller . GetClientFilesManager ( ) <EOL> path = client_files_manager . GetFilePath ( hash ) <EOL>", "answer": "response_context = HydrusServerResources . ResponseContext ( <NUM_LIT:200> , path = path )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> import sys <EOL> runPath = os . path . dirname ( os . path . realpath ( __file__ ) ) <EOL>", "answer": "sys . path . append ( os . path . join ( runPath , \"<STR_LIT:..>\" ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import unittest <EOL> from datetime import datetime , timedelta <EOL> from rx import Observable <EOL> from rx . testing import TestScheduler , ReactiveTest , is_prime , MockDisposable <EOL> from rx . disposables import Disposable , SerialDisposable <EOL> from rx . subjects import Subject <EOL> on_next = ReactiveTest . on_next <EOL> on_completed = ReactiveTest . on_completed <EOL> on_error = ReactiveTest . on_error <EOL> subscribe = ReactiveTest . subscribe <EOL> subscribed = ReactiveTest . subscribed <EOL> disposed = ReactiveTest . disposed <EOL> created = ReactiveTest . created <EOL> class RxException ( Exception ) : <EOL> pass <EOL> def _raise ( ex ) : <EOL> raise RxException ( ex ) <EOL> class TestTimeInterval ( unittest . TestCase ) : <EOL> def test_interval_timespan_basic ( self ) : <EOL> scheduler = TestScheduler ( ) <EOL>", "answer": "def create ( ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> from Tkinter import Frame , Button , Label , Text , Scrollbar , Canvas , Wm , READABLE <EOL> from mininet . log import setLogLevel <EOL> from mininet . topolib import TreeNet <EOL> from mininet . term import makeTerms , cleanUpScreens <EOL> from mininet . util import quietRun <EOL> class Console ( Frame ) : <EOL> \"<STR_LIT>\" <EOL> def __init__ ( self , parent , net , node , height = <NUM_LIT:10> , width = <NUM_LIT:32> , title = '<STR_LIT>' ) : <EOL> Frame . __init__ ( self , parent ) <EOL> self . net = net <EOL> self . node = node <EOL> self . prompt = node . name + '<STR_LIT>' <EOL> self . height , self . width , self . title = height , width , title <EOL> self . buttonStyle = { '<STR_LIT>' : '<STR_LIT>' } <EOL> self . textStyle = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:width>' : self . width , <EOL> '<STR_LIT>' : self . height , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> self . text = self . makeWidgets ( ) <EOL> self . bindEvents ( ) <EOL> self . sendCmd ( '<STR_LIT>' ) <EOL> self . outputHook = None <EOL> def makeWidgets ( self ) : <EOL> \"<STR_LIT>\" <EOL> def newTerm ( net = self . net , node = self . node , title = self . title ) : <EOL> \"<STR_LIT>\" <EOL> net . terms += makeTerms ( [ node ] , title ) <EOL> label = Button ( self , text = self . node . name , command = newTerm , <EOL> ** self . buttonStyle ) <EOL> label . pack ( side = '<STR_LIT>' , fill = '<STR_LIT:x>' ) <EOL> text = Text ( self , wrap = '<STR_LIT>' , ** self . textStyle ) <EOL> ybar = Scrollbar ( self , orient = '<STR_LIT>' , width = <NUM_LIT:7> , <EOL> command = text . yview ) <EOL> text . configure ( yscrollcommand = ybar . set ) <EOL> text . pack ( side = '<STR_LIT:left>' , expand = True , fill = '<STR_LIT>' ) <EOL> ybar . pack ( side = '<STR_LIT:right>' , fill = '<STR_LIT:y>' ) <EOL> return text <EOL> def bindEvents ( self ) : <EOL> \"<STR_LIT>\" <EOL> self . text . bind ( '<STR_LIT>' , self . handleReturn ) <EOL> self . text . bind ( '<STR_LIT>' , self . handleInt ) <EOL> self . text . bind ( '<STR_LIT>' , self . handleKey ) <EOL> self . tk . createfilehandler ( self . node . stdout , READABLE , <EOL> self . handleReadable ) <EOL> ignoreChars = re . compile ( r'<STR_LIT>' ) <EOL> def append ( self , text ) : <EOL> \"<STR_LIT>\" <EOL> text = self . ignoreChars . sub ( '<STR_LIT>' , text ) <EOL> self . text . insert ( '<STR_LIT:end>' , text ) <EOL> self . text . mark_set ( '<STR_LIT>' , '<STR_LIT:end>' ) <EOL> self . text . see ( '<STR_LIT>' ) <EOL> outputHook = lambda x , y : True <EOL> if self . outputHook : <EOL> outputHook = self . outputHook <EOL> outputHook ( self , text ) <EOL> def handleKey ( self , event ) : <EOL> \"<STR_LIT>\" <EOL> char = event . char <EOL> if self . node . waiting : <EOL> self . node . write ( char ) <EOL> def handleReturn ( self , event ) : <EOL> \"<STR_LIT>\" <EOL> cmd = self . text . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if self . node . waiting : <EOL> self . node . write ( event . char ) <EOL> return <EOL> pos = cmd . find ( self . prompt ) <EOL> if pos >= <NUM_LIT:0> : <EOL> cmd = cmd [ pos + len ( self . prompt ) : ] <EOL> self . sendCmd ( cmd ) <EOL> def handleInt ( self , _event = None ) : <EOL> \"<STR_LIT>\" <EOL> self . node . sendInt ( ) <EOL> def sendCmd ( self , cmd ) : <EOL> \"<STR_LIT>\" <EOL> if not self . node . waiting : <EOL> self . node . sendCmd ( cmd ) <EOL> def handleReadable ( self , _fds , timeoutms = None ) : <EOL> \"<STR_LIT>\" <EOL> data = self . node . monitor ( timeoutms ) <EOL> self . append ( data ) <EOL> if not self . node . waiting : <EOL> self . append ( self . prompt ) <EOL> def waiting ( self ) : <EOL> \"<STR_LIT>\" <EOL> return self . node . waiting <EOL> def waitOutput ( self ) : <EOL> \"<STR_LIT>\" <EOL> while self . node . waiting : <EOL> self . handleReadable ( self , timeoutms = <NUM_LIT:1000> ) <EOL> self . update ( ) <EOL> def clear ( self ) : <EOL> \"<STR_LIT>\" <EOL> self . text . delete ( '<STR_LIT:1.0>' , '<STR_LIT:end>' ) <EOL> class Graph ( Frame ) : <EOL> \"<STR_LIT>\" <EOL> def __init__ ( self , parent = None , bg = '<STR_LIT>' , gheight = <NUM_LIT:200> , gwidth = <NUM_LIT> , <EOL> barwidth = <NUM_LIT:10> , ymax = <NUM_LIT> , ) : <EOL> Frame . __init__ ( self , parent ) <EOL> self . bg = bg <EOL> self . gheight = gheight <EOL> self . gwidth = gwidth <EOL> self . barwidth = barwidth <EOL> self . ymax = float ( ymax ) <EOL> self . xpos = <NUM_LIT:0> <EOL> self . title , self . scale , self . graph = self . createWidgets ( ) <EOL> self . updateScrollRegions ( ) <EOL> self . yview ( '<STR_LIT>' , '<STR_LIT:1.0>' ) <EOL> def createScale ( self ) : <EOL> \"<STR_LIT>\" <EOL> height = float ( self . gheight ) <EOL> width = <NUM_LIT> <EOL> ymax = self . ymax <EOL> scale = Canvas ( self , width = width , height = height , <EOL> background = self . bg ) <EOL> opts = { '<STR_LIT>' : '<STR_LIT>' } <EOL> scale . create_line ( width - <NUM_LIT:1> , height , width - <NUM_LIT:1> , <NUM_LIT:0> , ** opts ) <EOL> for y in range ( <NUM_LIT:0> , int ( ymax + <NUM_LIT:1> ) ) : <EOL> ypos = height * ( <NUM_LIT:1> - float ( y ) / ymax ) <EOL> scale . create_line ( width , ypos , width - <NUM_LIT:10> , ypos , ** opts ) <EOL> scale . create_text ( <NUM_LIT:10> , ypos , text = str ( y ) , ** opts ) <EOL> return scale <EOL> def updateScrollRegions ( self ) : <EOL> \"<STR_LIT>\" <EOL> ofs = <NUM_LIT:20> <EOL> height = self . gheight + ofs <EOL> self . graph . configure ( scrollregion = ( <NUM_LIT:0> , - ofs , <EOL> self . xpos * self . barwidth , height ) ) <EOL> self . scale . configure ( scrollregion = ( <NUM_LIT:0> , - ofs , <NUM_LIT:0> , height ) ) <EOL> def yview ( self , * args ) : <EOL> \"<STR_LIT>\" <EOL> self . graph . yview ( * args ) <EOL> self . scale . yview ( * args ) <EOL> def createWidgets ( self ) : <EOL> \"<STR_LIT>\" <EOL> title = Label ( self , text = '<STR_LIT>' , bg = self . bg ) <EOL> width = self . gwidth <EOL> height = self . gheight <EOL> scale = self . createScale ( ) <EOL> graph = Canvas ( self , width = width , height = height , background = self . bg ) <EOL> xbar = Scrollbar ( self , orient = '<STR_LIT>' , command = graph . xview ) <EOL> ybar = Scrollbar ( self , orient = '<STR_LIT>' , command = self . yview ) <EOL> graph . configure ( xscrollcommand = xbar . set , yscrollcommand = ybar . set , <EOL> scrollregion = ( <NUM_LIT:0> , <NUM_LIT:0> , width , height ) ) <EOL> scale . configure ( yscrollcommand = ybar . set ) <EOL> title . grid ( row = <NUM_LIT:0> , columnspan = <NUM_LIT:3> , sticky = '<STR_LIT>' ) <EOL> scale . grid ( row = <NUM_LIT:1> , column = <NUM_LIT:0> , sticky = '<STR_LIT>' ) <EOL> graph . grid ( row = <NUM_LIT:1> , column = <NUM_LIT:1> , sticky = '<STR_LIT>' ) <EOL> ybar . grid ( row = <NUM_LIT:1> , column = <NUM_LIT:2> , sticky = '<STR_LIT>' ) <EOL> xbar . grid ( row = <NUM_LIT:2> , column = <NUM_LIT:0> , columnspan = <NUM_LIT:2> , sticky = '<STR_LIT>' ) <EOL> self . rowconfigure ( <NUM_LIT:1> , weight = <NUM_LIT:1> ) <EOL> self . columnconfigure ( <NUM_LIT:1> , weight = <NUM_LIT:1> ) <EOL> return title , scale , graph <EOL> def addBar ( self , yval ) : <EOL> \"<STR_LIT>\" <EOL> percent = yval / self . ymax <EOL> c = self . graph <EOL> x0 = self . xpos * self . barwidth <EOL> x1 = x0 + self . barwidth <EOL> y0 = self . gheight <EOL> y1 = ( <NUM_LIT:1> - percent ) * self . gheight <EOL> c . create_rectangle ( x0 , y0 , x1 , y1 , fill = '<STR_LIT>' ) <EOL> self . xpos += <NUM_LIT:1> <EOL> self . updateScrollRegions ( ) <EOL> self . graph . xview ( '<STR_LIT>' , '<STR_LIT:1.0>' ) <EOL> def clear ( self ) : <EOL> \"<STR_LIT>\" <EOL> self . graph . delete ( '<STR_LIT:all>' ) <EOL> self . xpos = <NUM_LIT:0> <EOL> def test ( self ) : <EOL> \"<STR_LIT>\" <EOL> ms = <NUM_LIT:1000> <EOL> if self . xpos < <NUM_LIT:10> : <EOL> self . addBar ( self . xpos / <NUM_LIT:10> * self . ymax ) <EOL> self . after ( ms , self . test ) <EOL> def setTitle ( self , text ) : <EOL> \"<STR_LIT>\" <EOL> self . title . configure ( text = text , font = '<STR_LIT>' ) <EOL> class ConsoleApp ( Frame ) : <EOL> \"<STR_LIT>\" <EOL> menuStyle = { '<STR_LIT>' : '<STR_LIT>' } <EOL> def __init__ ( self , net , parent = None , width = <NUM_LIT:4> ) : <EOL> Frame . __init__ ( self , parent ) <EOL> self . top = self . winfo_toplevel ( ) <EOL> self . top . title ( '<STR_LIT>' ) <EOL> self . net = net <EOL> self . menubar = self . createMenuBar ( ) <EOL> cframe = self . cframe = Frame ( self ) <EOL> self . consoles = { } <EOL> titles = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> for name in titles : <EOL> nodes = getattr ( net , name ) <EOL> frame , consoles = self . createConsoles ( <EOL> cframe , nodes , width , titles [ name ] ) <EOL> self . consoles [ name ] = Object ( frame = frame , consoles = consoles ) <EOL> self . selected = None <EOL> self . select ( '<STR_LIT>' ) <EOL> self . cframe . pack ( expand = True , fill = '<STR_LIT>' ) <EOL> cleanUpScreens ( ) <EOL> Wm . wm_protocol ( self . top , name = '<STR_LIT>' , func = self . quit ) <EOL> graph = Graph ( cframe ) <EOL> self . consoles [ '<STR_LIT>' ] = Object ( frame = graph , consoles = [ graph ] ) <EOL> self . graph = graph <EOL> self . graphVisible = False <EOL> self . updates = <NUM_LIT:0> <EOL> self . hostCount = len ( self . consoles [ '<STR_LIT>' ] . consoles ) <EOL> self . bw = <NUM_LIT:0> <EOL> self . pack ( expand = True , fill = '<STR_LIT>' ) <EOL> def updateGraph ( self , _console , output ) : <EOL> \"<STR_LIT>\" <EOL> m = re . search ( r'<STR_LIT>' , output ) <EOL> if not m : <EOL> return <EOL> val , units = float ( m . group ( <NUM_LIT:1> ) ) , m . group ( <NUM_LIT:2> ) <EOL> if units [ <NUM_LIT:0> ] == '<STR_LIT:M>' : <EOL> val *= <NUM_LIT:10> ** - <NUM_LIT:3> <EOL> elif units [ <NUM_LIT:0> ] == '<STR_LIT>' : <EOL> val *= <NUM_LIT:10> ** - <NUM_LIT:6> <EOL> elif units [ <NUM_LIT:0> ] == '<STR_LIT:b>' : <EOL> val *= <NUM_LIT:10> ** - <NUM_LIT:9> <EOL> self . updates += <NUM_LIT:1> <EOL> self . bw += val <EOL> if self . updates >= self . hostCount : <EOL> self . graph . addBar ( self . bw ) <EOL> self . bw = <NUM_LIT:0> <EOL>", "answer": "self . updates = <NUM_LIT:0>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import xml_models <EOL> from saasu_client import DEFAULT_GET_URL <EOL> from saasu_client . models . base import BaseModel , CollectionField <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> class ServiceInvoiceItem ( BaseModel ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from seqdb import SequenceDB , BasicSeqInfoDict <EOL> from annotation import AnnotationDB , TranslationAnnot , TranslationAnnotSlice <EOL> import classutil <EOL> import sequence <EOL> import UserDict <EOL> class SeqTranslator ( sequence . SequenceBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , db , id , reversePath = None ) : <EOL> self . id = id <EOL> sequence . SequenceBase . __init__ ( self ) <EOL> if reversePath : <EOL> self . orientation = - <NUM_LIT:1> <EOL> self . start = - len ( self ) <EOL> self . stop = <NUM_LIT:0> <EOL> self . _reverse = reversePath <EOL> if self . id not in self . db . seqDB : <EOL> raise KeyError ( '<STR_LIT>' % ( self . id , self . db ) ) <EOL> def __getitem__ ( self , k ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> start = k . start <EOL> if start is None : <EOL> start = self . start <EOL> stop = k . stop <EOL> if stop is None : <EOL> stop = self . stop <EOL> annoID = self . _get_anno_id ( start ) <EOL> a = self . db . annodb [ annoID ] <EOL> s = a . sequence <EOL> return a [ ( start - s . start ) / <NUM_LIT:3> : ( stop - s . start ) / <NUM_LIT:3> ] <EOL> def absolute_slice ( self , start , stop ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if start < <NUM_LIT:0> : <EOL> return ( - self ) [ start : stop ] <EOL> else : <EOL> return self [ start : stop ] <EOL> def __len__ ( self ) : <EOL> return self . db . seqInfoDict [ self . id ] . length <EOL> def __neg__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> return self . _reverse <EOL> except AttributeError : <EOL> self . _reverse = self . __class__ ( self . db , self . id , <EOL> reversePath = self ) <EOL> return self . _reverse <EOL> def _get_anno_id ( self , start ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . orientation > <NUM_LIT:0> : <EOL> return '<STR_LIT>' % ( self . id , start % <NUM_LIT:3> ) <EOL> else : <EOL>", "answer": "return '<STR_LIT>' % ( self . id , ( - start ) % <NUM_LIT:3> )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import functools <EOL> from nailgun import consts <EOL> from nailgun . test . base import EnvironmentManager <EOL> from nailgun . test . performance import base <EOL> class NodeGroupOperationsLoadTest ( base . BaseUnitLoadTestCase ) : <EOL> class NameGenerator ( object ) : <EOL> def __init__ ( self , base_name ) : <EOL> self . base_name = base_name <EOL> self . counter = <NUM_LIT:0> <EOL> @ property <EOL> def next_name ( self ) : <EOL> self . counter += <NUM_LIT:1> <EOL> return '<STR_LIT>' . format ( self . base_name , self . counter ) <EOL> @ property <EOL> def name ( self ) : <EOL> return '<STR_LIT>' . format ( self . base_name , self . counter ) <EOL> @ classmethod <EOL> def setUpClass ( cls ) : <EOL>", "answer": "super ( NodeGroupOperationsLoadTest , cls ) . setUpClass ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from distutils . command . build import build as _build <EOL> from distutils . command . sdist import sdist as _sdist <EOL> from distutils . core import Command <EOL> import os , sys , re , subprocess , errno <EOL> versionfile_source = None <EOL> versionfile_build = None <EOL> tag_prefix = None <EOL> parentdir_prefix = None <EOL> VCS = None <EOL> LONG_VERSION_PY = { } <EOL> def run_command ( commands , args , cwd = None , verbose = False , hide_stderr = False ) : <EOL> assert isinstance ( commands , list ) <EOL> p = None <EOL> for c in commands : <EOL> try : <EOL> p = subprocess . Popen ( [ c ] + args , cwd = cwd , stdout = subprocess . PIPE , <EOL> stderr = ( subprocess . PIPE if hide_stderr <EOL> else None ) ) <EOL> break <EOL> except EnvironmentError : <EOL> e = sys . exc_info ( ) [ <NUM_LIT:1> ] <EOL> if e . errno == errno . ENOENT : <EOL> continue <EOL> if verbose : <EOL> print ( \"<STR_LIT>\" % args [ <NUM_LIT:0> ] ) <EOL> print ( e ) <EOL> return None <EOL> else : <EOL> if verbose : <EOL> print ( \"<STR_LIT>\" % ( commands , ) ) <EOL> return None <EOL> stdout = p . communicate ( ) [ <NUM_LIT:0> ] . strip ( ) <EOL> if sys . version >= '<STR_LIT:3>' : <EOL> stdout = stdout . decode ( ) <EOL> if p . returncode != <NUM_LIT:0> : <EOL> if verbose : <EOL> print ( \"<STR_LIT>\" % args [ <NUM_LIT:0> ] ) <EOL> return None <EOL> return stdout <EOL> LONG_VERSION_PY [ '<STR_LIT>' ] = '''<STR_LIT>''' <EOL> def git_get_keywords ( versionfile_abs ) : <EOL> keywords = { } <EOL> try : <EOL> f = open ( versionfile_abs , \"<STR_LIT:r>\" ) <EOL> for line in f . readlines ( ) : <EOL> if line . strip ( ) . startswith ( \"<STR_LIT>\" ) : <EOL> mo = re . search ( r'<STR_LIT>' , line ) <EOL> if mo : <EOL> keywords [ \"<STR_LIT>\" ] = mo . group ( <NUM_LIT:1> ) <EOL> if line . strip ( ) . startswith ( \"<STR_LIT>\" ) : <EOL> mo = re . search ( r'<STR_LIT>' , line ) <EOL> if mo : <EOL> keywords [ \"<STR_LIT>\" ] = mo . group ( <NUM_LIT:1> ) <EOL> f . close ( ) <EOL> except EnvironmentError : <EOL> pass <EOL> return keywords <EOL> def git_versions_from_keywords ( keywords , tag_prefix , verbose = False ) : <EOL> if not keywords : <EOL> return { } <EOL> refnames = keywords [ \"<STR_LIT>\" ] . strip ( ) <EOL> if refnames . startswith ( \"<STR_LIT>\" ) : <EOL> if verbose : <EOL> print ( \"<STR_LIT>\" ) <EOL> return { } <EOL> refs = set ( [ r . strip ( ) for r in refnames . strip ( \"<STR_LIT>\" ) . split ( \"<STR_LIT:U+002C>\" ) ] ) <EOL> TAG = \"<STR_LIT>\" <EOL> tags = set ( [ r [ len ( TAG ) : ] for r in refs if r . startswith ( TAG ) ] ) <EOL> if not tags : <EOL> tags = set ( [ r for r in refs if re . search ( r'<STR_LIT>' , r ) ] ) <EOL> if verbose : <EOL> print ( \"<STR_LIT>\" % \"<STR_LIT:U+002C>\" . join ( refs - tags ) ) <EOL> if verbose : <EOL> print ( \"<STR_LIT>\" % \"<STR_LIT:U+002C>\" . join ( sorted ( tags ) ) ) <EOL> for ref in sorted ( tags ) : <EOL> if ref . startswith ( tag_prefix ) : <EOL> r = ref [ len ( tag_prefix ) : ] <EOL> if verbose : <EOL> print ( \"<STR_LIT>\" % r ) <EOL> return { \"<STR_LIT:version>\" : r , <EOL> \"<STR_LIT>\" : keywords [ \"<STR_LIT>\" ] . strip ( ) } <EOL> if verbose : <EOL> print ( \"<STR_LIT>\" ) <EOL> return { \"<STR_LIT:version>\" : keywords [ \"<STR_LIT>\" ] . strip ( ) , <EOL> \"<STR_LIT>\" : keywords [ \"<STR_LIT>\" ] . strip ( ) } <EOL> def git_versions_from_vcs ( tag_prefix , root , verbose = False ) : <EOL> if not os . path . exists ( os . path . join ( root , \"<STR_LIT>\" ) ) : <EOL> if verbose : <EOL> print ( \"<STR_LIT>\" % root ) <EOL> return { } <EOL> GITS = [ \"<STR_LIT>\" ] <EOL> if sys . platform == \"<STR_LIT:win32>\" : <EOL> GITS = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> stdout = run_command ( GITS , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> cwd = root ) <EOL> if stdout is None : <EOL> return { } <EOL> if not stdout . startswith ( tag_prefix ) : <EOL> if verbose : <EOL> print ( \"<STR_LIT>\" % ( stdout , tag_prefix ) ) <EOL> return { } <EOL> tag = stdout [ len ( tag_prefix ) : ] <EOL> stdout = run_command ( GITS , [ \"<STR_LIT>\" , \"<STR_LIT>\" ] , cwd = root ) <EOL> if stdout is None : <EOL> return { } <EOL> full = stdout . strip ( ) <EOL> if tag . endswith ( \"<STR_LIT>\" ) : <EOL> full += \"<STR_LIT>\" <EOL> return { \"<STR_LIT:version>\" : tag , \"<STR_LIT>\" : full } <EOL> def do_vcs_install ( manifest_in , versionfile_source , ipy ) : <EOL> GITS = [ \"<STR_LIT>\" ] <EOL> if sys . platform == \"<STR_LIT:win32>\" : <EOL> GITS = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> files = [ manifest_in , versionfile_source ] <EOL> if ipy : <EOL> files . append ( ipy ) <EOL> try : <EOL> me = __file__ <EOL> if me . endswith ( \"<STR_LIT>\" ) or me . endswith ( \"<STR_LIT>\" ) : <EOL> me = os . path . splitext ( me ) [ <NUM_LIT:0> ] + \"<STR_LIT>\" <EOL> versioneer_file = os . path . relpath ( me ) <EOL> except NameError : <EOL> versioneer_file = \"<STR_LIT>\" <EOL> files . append ( versioneer_file ) <EOL> present = False <EOL> try : <EOL> f = open ( \"<STR_LIT>\" , \"<STR_LIT:r>\" ) <EOL> for line in f . readlines ( ) : <EOL> if line . strip ( ) . startswith ( versionfile_source ) : <EOL> if \"<STR_LIT>\" in line . strip ( ) . split ( ) [ <NUM_LIT:1> : ] : <EOL> present = True <EOL> f . close ( ) <EOL> except EnvironmentError : <EOL> pass <EOL> if not present : <EOL> f = open ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> f . write ( \"<STR_LIT>\" % versionfile_source ) <EOL> f . close ( ) <EOL> files . append ( \"<STR_LIT>\" ) <EOL> run_command ( GITS , [ \"<STR_LIT>\" , \"<STR_LIT>\" ] + files ) <EOL> def versions_from_parentdir ( parentdir_prefix , root , verbose = False ) : <EOL> dirname = os . path . basename ( root ) <EOL> if not dirname . startswith ( parentdir_prefix ) : <EOL> if verbose : <EOL> print ( \"<STR_LIT>\" % <EOL> ( root , dirname , parentdir_prefix ) ) <EOL> return None <EOL> return { \"<STR_LIT:version>\" : dirname [ len ( parentdir_prefix ) : ] , \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> SHORT_VERSION_PY = \"\"\"<STR_LIT>\"\"\" <EOL> DEFAULT = { \"<STR_LIT:version>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> def versions_from_file ( filename ) : <EOL> versions = { } <EOL> try : <EOL> with open ( filename ) as f : <EOL> for line in f . readlines ( ) : <EOL> mo = re . match ( \"<STR_LIT>\" , line ) <EOL> if mo : <EOL> versions [ \"<STR_LIT:version>\" ] = mo . group ( <NUM_LIT:1> ) <EOL> mo = re . match ( \"<STR_LIT>\" , line ) <EOL> if mo : <EOL> versions [ \"<STR_LIT>\" ] = mo . group ( <NUM_LIT:1> ) <EOL> except EnvironmentError : <EOL> return { } <EOL> return versions <EOL> def write_to_version_file ( filename , versions ) : <EOL> with open ( filename , \"<STR_LIT:w>\" ) as f : <EOL> f . write ( SHORT_VERSION_PY % versions ) <EOL> print ( \"<STR_LIT>\" % ( filename , versions [ \"<STR_LIT:version>\" ] ) ) <EOL> def get_root ( ) : <EOL> try : <EOL> return os . path . dirname ( os . path . abspath ( __file__ ) ) <EOL> except NameError : <EOL> return os . path . dirname ( os . path . abspath ( sys . argv [ <NUM_LIT:0> ] ) ) <EOL> def vcs_function ( vcs , suffix ) : <EOL> return getattr ( sys . modules [ __name__ ] , '<STR_LIT>' % ( vcs , suffix ) , None ) <EOL> def get_versions ( default = DEFAULT , verbose = False ) : <EOL> assert versionfile_source is not None , \"<STR_LIT>\" <EOL> assert tag_prefix is not None , \"<STR_LIT>\" <EOL> assert parentdir_prefix is not None , \"<STR_LIT>\" <EOL> assert VCS is not None , \"<STR_LIT>\" <EOL> root = get_root ( ) <EOL> versionfile_abs = os . path . join ( root , versionfile_source ) <EOL> get_keywords_f = vcs_function ( VCS , \"<STR_LIT>\" ) <EOL> versions_from_keywords_f = vcs_function ( VCS , \"<STR_LIT>\" ) <EOL> if get_keywords_f and versions_from_keywords_f : <EOL> vcs_keywords = get_keywords_f ( versionfile_abs ) <EOL> ver = versions_from_keywords_f ( vcs_keywords , tag_prefix ) <EOL> if ver : <EOL> if verbose : print ( \"<STR_LIT>\" % ver ) <EOL> return ver <EOL> ver = versions_from_file ( versionfile_abs ) <EOL> if ver : <EOL> if verbose : print ( \"<STR_LIT>\" % ( versionfile_abs , ver ) ) <EOL> return ver <EOL> versions_from_vcs_f = vcs_function ( VCS , \"<STR_LIT>\" ) <EOL> if versions_from_vcs_f : <EOL> ver = versions_from_vcs_f ( tag_prefix , root , verbose ) <EOL> if ver : <EOL> if verbose : print ( \"<STR_LIT>\" % ver ) <EOL> return ver <EOL> ver = versions_from_parentdir ( parentdir_prefix , root , verbose ) <EOL> if ver : <EOL> if verbose : print ( \"<STR_LIT>\" % ver ) <EOL> return ver <EOL> if verbose : print ( \"<STR_LIT>\" % default ) <EOL> return default <EOL> def get_version ( verbose = False ) : <EOL> return get_versions ( verbose = verbose ) [ \"<STR_LIT:version>\" ] <EOL> class cmd_version ( Command ) : <EOL> description = \"<STR_LIT>\" <EOL> user_options = [ ] <EOL> boolean_options = [ ] <EOL> def initialize_options ( self ) : <EOL> pass <EOL> def finalize_options ( self ) : <EOL> pass <EOL> def run ( self ) : <EOL> ver = get_version ( verbose = True ) <EOL> print ( \"<STR_LIT>\" % ver ) <EOL> class cmd_build ( _build ) : <EOL> def run ( self ) : <EOL> versions = get_versions ( verbose = True ) <EOL> _build . run ( self ) <EOL> if versionfile_build : <EOL> target_versionfile = os . path . join ( self . build_lib , versionfile_build ) <EOL> print ( \"<STR_LIT>\" % target_versionfile ) <EOL> os . unlink ( target_versionfile ) <EOL> with open ( target_versionfile , \"<STR_LIT:w>\" ) as f : <EOL> f . write ( SHORT_VERSION_PY % versions ) <EOL> if '<STR_LIT>' in sys . modules : <EOL> from cx_Freeze . dist import build_exe as _build_exe <EOL> class cmd_build_exe ( _build_exe ) : <EOL> def run ( self ) : <EOL> versions = get_versions ( verbose = True ) <EOL> target_versionfile = versionfile_source <EOL> print ( \"<STR_LIT>\" % target_versionfile ) <EOL> os . unlink ( target_versionfile ) <EOL> with open ( target_versionfile , \"<STR_LIT:w>\" ) as f : <EOL> f . write ( SHORT_VERSION_PY % versions ) <EOL> _build_exe . run ( self ) <EOL> os . unlink ( target_versionfile ) <EOL> with open ( versionfile_source , \"<STR_LIT:w>\" ) as f : <EOL> assert VCS is not None , \"<STR_LIT>\" <EOL> LONG = LONG_VERSION_PY [ VCS ] <EOL> f . write ( LONG % { \"<STR_LIT>\" : \"<STR_LIT:$>\" , <EOL> \"<STR_LIT>\" : tag_prefix , <EOL> \"<STR_LIT>\" : parentdir_prefix , <EOL> \"<STR_LIT>\" : versionfile_source , <EOL> } ) <EOL> class cmd_sdist ( _sdist ) : <EOL> def run ( self ) : <EOL> versions = get_versions ( verbose = True ) <EOL> self . _versioneer_generated_versions = versions <EOL> self . distribution . metadata . version = versions [ \"<STR_LIT:version>\" ] <EOL> return _sdist . run ( self ) <EOL> def make_release_tree ( self , base_dir , files ) : <EOL> _sdist . make_release_tree ( self , base_dir , files ) <EOL> target_versionfile = os . path . join ( base_dir , versionfile_source ) <EOL>", "answer": "print ( \"<STR_LIT>\" % target_versionfile )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from troposphere import Template , Ref , Output , Parameter <EOL> from troposphere . dynamodb import ( Key , AttributeDefinition , <EOL> ProvisionedThroughput , Projection ) <EOL> from troposphere . dynamodb import Table , GlobalSecondaryIndex <EOL> template = Template ( ) <EOL> template . add_description ( \"<STR_LIT>\" <EOL> \"<STR_LIT:index>\" ) <EOL> readunits = template . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Default = \"<STR_LIT>\" , <EOL> MinValue = \"<STR_LIT:5>\" , <EOL> MaxValue = \"<STR_LIT>\" , <EOL> ConstraintDescription = \"<STR_LIT>\" <EOL> ) ) <EOL> writeunits = template . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL>", "answer": "Type = \"<STR_LIT>\" ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import re <EOL> import random <EOL> from faker import data <EOL> rand = lambda x : random . choice ( x . split ( ) ) <EOL> numerify = lambda x : \"<STR_LIT>\" . join ( [ re . sub ( r\"<STR_LIT:#>\" , str ( random . randint ( <NUM_LIT:0> , <NUM_LIT:9> ) ) , i ) for i in x ] ) <EOL>", "answer": "letterify = lambda x : \"<STR_LIT>\" . join ( [ re . sub ( r\"<STR_LIT>\" , random . choice ( [ chr ( i ) for i in range ( ord ( '<STR_LIT:A>' ) , ord ( '<STR_LIT>' ) + <NUM_LIT:1> ) ] ) , y ) for y in x ] )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os . path <EOL> import csv <EOL> import copy <EOL> import numpy <EOL> import condor <EOL> import borg <EOL> logger = borg . get_logger ( __name__ , default_level = \"<STR_LIT>\" ) <EOL> def infer_distributions ( run_data , model_name , instance , exclude ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> filtered_data = copy . deepcopy ( run_data ) <EOL> filtered_runs = filter ( lambda r : r . solver != exclude , filtered_data . run_lists [ instance ] ) <EOL> filtered_data . run_lists [ instance ] = filtered_runs <EOL> model = borg . experiments . common . train_model ( model_name , filtered_data , bins = <NUM_LIT:8> ) <EOL> ( M , S , B ) = model . log_masses . shape <EOL> n = sorted ( filtered_data . run_lists ) . index ( instance ) <EOL> true = run_data . to_bins_array ( run_data . solver_names , B = <NUM_LIT:8> ) [ n ] . astype ( float ) <EOL> true /= numpy . sum ( true , axis = - <NUM_LIT:1> ) [ : , None ] + <NUM_LIT> <EOL> observed = filtered_data . to_bins_array ( run_data . solver_names , B = <NUM_LIT:8> ) [ n ] . astype ( float ) <EOL> observed /= numpy . sum ( observed , axis = - <NUM_LIT:1> ) [ : , None ] + <NUM_LIT> <EOL> mask = model . names == instance <EOL> log_predicted_all = model . log_weights [ mask ] [ : , None , None ] + model . log_masses [ mask , : , : ] <EOL> predicted = numpy . sum ( numpy . exp ( log_predicted_all ) , axis = <NUM_LIT:0> ) <EOL> predicted /= numpy . sum ( predicted , axis = - <NUM_LIT:1> ) [ ... , None ] <EOL> def yield_rows ( ) : <EOL> for s in xrange ( S ) : <EOL> solver_name = run_data . solver_names [ s ] <EOL> for b in xrange ( B ) : <EOL> yield ( model_name , instance , solver_name , b , predicted [ s , b ] ) <EOL> yield ( \"<STR_LIT>\" , instance , solver_name , b , observed [ s , b ] ) <EOL> yield ( \"<STR_LIT:true>\" , instance , solver_name , b , true [ s , b ] ) <EOL> return list ( yield_rows ( ) ) <EOL> @ borg . annotations ( <EOL> out_path = ( \"<STR_LIT>\" ) , <EOL> bundle = ( \"<STR_LIT>\" , \"<STR_LIT>\" , None , os . path . abspath ) , <EOL> experiments = ( \"<STR_LIT>\" , \"<STR_LIT>\" , None , borg . util . load_json ) , <EOL> workers = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:w>\" , int ) , <EOL> local = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ) <EOL> def main ( out_path , bundle , experiments , workers = <NUM_LIT:0> , local = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def yield_jobs ( ) : <EOL> run_data = borg . storage . RunData . from_bundle ( bundle ) <EOL> for experiment in experiments : <EOL> yield ( <EOL> infer_distributions , <EOL> [ <EOL> run_data , <EOL> experiment [ \"<STR_LIT>\" ] , <EOL> experiment [ \"<STR_LIT>\" ] , <EOL> experiment [ \"<STR_LIT>\" ] , <EOL> ] , <EOL> ) <EOL> with open ( out_path , \"<STR_LIT:w>\" ) as out_file : <EOL> writer = csv . writer ( out_file ) <EOL>", "answer": "writer . writerow ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import itertools <EOL> import inspect <EOL> from . core import GroupMixin , Command <EOL> from . errors import CommandError <EOL> class HelpFormatter : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , show_hidden = False , show_check_failure = False , width = <NUM_LIT> ) : <EOL> self . width = width <EOL> self . show_hidden = show_hidden <EOL> self . show_check_failure = show_check_failure <EOL> def has_subcommands ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return isinstance ( self . command , GroupMixin ) <EOL> def is_bot ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . command is self . context . bot <EOL> def is_cog ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return not self . is_bot ( ) and not isinstance ( self . command , Command ) <EOL> def shorten ( self , text ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( text ) > self . width : <EOL> return text [ : self . width - <NUM_LIT:3> ] + '<STR_LIT>' <EOL> return text <EOL> @ property <EOL> def max_name_size ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> commands = self . command . commands if not self . is_cog ( ) else self . context . bot . commands <EOL> if commands : <EOL> return max ( map ( lambda c : len ( c . name ) , commands . values ( ) ) ) <EOL> return <NUM_LIT:0> <EOL> except AttributeError : <EOL> return len ( self . command . name ) <EOL> @ property <EOL> def clean_prefix ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> user = self . context . bot . user <EOL> return self . context . prefix . replace ( user . mention , '<STR_LIT:@>' + user . name ) <EOL> def get_qualified_command_name ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> entries = [ ] <EOL> command = self . command <EOL> while command . parent is not None : <EOL> command = command . parent <EOL> entries . append ( command . name ) <EOL> return '<STR_LIT:U+0020>' . join ( reversed ( entries ) ) <EOL> def get_command_signature ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = [ ] <EOL> prefix = self . clean_prefix <EOL> qualified = self . get_qualified_command_name ( ) <EOL> cmd = self . command <EOL> if len ( cmd . aliases ) > <NUM_LIT:0> : <EOL> aliases = '<STR_LIT:|>' . join ( cmd . aliases ) <EOL> fmt = '<STR_LIT>' <EOL> if qualified : <EOL> fmt = '<STR_LIT>' <EOL> result . append ( fmt . format ( prefix , cmd , aliases , qualified ) ) <EOL> else : <EOL> name = prefix + cmd . name if not qualified else prefix + qualified + '<STR_LIT:U+0020>' + cmd . name <EOL> result . append ( name ) <EOL> params = cmd . clean_params <EOL> if len ( params ) > <NUM_LIT:0> : <EOL> for name , param in params . items ( ) : <EOL>", "answer": "if param . default is not param . empty :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from sys import getrecursionlimit , setrecursionlimit <EOL> def accessibility ( graph ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> recursionlimit = getrecursionlimit ( ) <EOL> setrecursionlimit ( max ( len ( graph . nodes ( ) ) * <NUM_LIT:2> , recursionlimit ) ) <EOL> accessibility = { } <EOL> for each in graph : <EOL> access = { } <EOL> _dfs ( graph , access , <NUM_LIT:1> , each ) <EOL> accessibility [ each ] = list ( access . keys ( ) ) <EOL> setrecursionlimit ( recursionlimit ) <EOL> return accessibility <EOL> def mutual_accessibility ( graph ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> recursionlimit = getrecursionlimit ( ) <EOL> setrecursionlimit ( max ( len ( graph . nodes ( ) ) * <NUM_LIT:2> , recursionlimit ) ) <EOL> mutual_access = { } <EOL> stack = [ ] <EOL> low = { } <EOL> def visit ( node ) : <EOL> if node in low : <EOL> return <EOL> num = len ( low ) <EOL> low [ node ] = num <EOL> stack_pos = len ( stack ) <EOL> stack . append ( node ) <EOL> for successor in graph . neighbors ( node ) : <EOL> visit ( successor ) <EOL> low [ node ] = min ( low [ node ] , low [ successor ] ) <EOL> if num == low [ node ] : <EOL> component = stack [ stack_pos : ] <EOL> del stack [ stack_pos : ] <EOL> component . sort ( ) <EOL> for each in component : <EOL> mutual_access [ each ] = component <EOL> for item in component : <EOL> low [ item ] = len ( graph ) <EOL> for node in graph : <EOL> visit ( node ) <EOL> setrecursionlimit ( recursionlimit ) <EOL> return mutual_access <EOL> def connected_components ( graph ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> recursionlimit = getrecursionlimit ( ) <EOL> setrecursionlimit ( max ( len ( graph . nodes ( ) ) * <NUM_LIT:2> , recursionlimit ) ) <EOL> visited = { } <EOL> count = <NUM_LIT:1> <EOL> for each in graph : <EOL> if ( each not in visited ) : <EOL> _dfs ( graph , visited , count , each ) <EOL> count = count + <NUM_LIT:1> <EOL> setrecursionlimit ( recursionlimit ) <EOL> return visited <EOL> def _dfs ( graph , visited , count , node ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> visited [ node ] = count <EOL> for each in graph [ node ] : <EOL> if ( each not in visited ) : <EOL> _dfs ( graph , visited , count , each ) <EOL> def cut_edges ( graph ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> recursionlimit = getrecursionlimit ( ) <EOL> setrecursionlimit ( max ( len ( graph . nodes ( ) ) * <NUM_LIT:2> , recursionlimit ) ) <EOL> if '<STR_LIT>' == graph . __class__ . __name__ : <EOL> return _cut_hyperedges ( graph ) <EOL> pre = { } <EOL> low = { } <EOL> spanning_tree = { } <EOL> reply = [ ] <EOL> pre [ None ] = <NUM_LIT:0> <EOL> for each in graph : <EOL> if ( each not in pre ) : <EOL> spanning_tree [ each ] = None <EOL> _cut_dfs ( graph , spanning_tree , pre , low , reply , each ) <EOL> setrecursionlimit ( recursionlimit ) <EOL> return reply <EOL> def _cut_hyperedges ( hypergraph ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> edges_ = cut_nodes ( hypergraph . graph ) <EOL> edges = [ ] <EOL> for each in edges_ : <EOL> if ( each [ <NUM_LIT:1> ] == '<STR_LIT:h>' ) : <EOL> edges . append ( each [ <NUM_LIT:0> ] ) <EOL> return edges <EOL> def cut_nodes ( graph ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> recursionlimit = getrecursionlimit ( ) <EOL> setrecursionlimit ( max ( len ( graph . nodes ( ) ) * <NUM_LIT:2> , recursionlimit ) ) <EOL> if '<STR_LIT>' == graph . __class__ . __name__ : <EOL> return _cut_hypernodes ( graph ) <EOL> pre = { } <EOL> low = { } <EOL> reply = { } <EOL> spanning_tree = { } <EOL> pre [ None ] = <NUM_LIT:0> <EOL> for each in graph : <EOL> if ( each not in pre ) : <EOL> spanning_tree [ each ] = None <EOL> _cut_dfs ( graph , spanning_tree , pre , low , [ ] , each ) <EOL> for each in graph : <EOL> if ( spanning_tree [ each ] is not None ) : <EOL> for other in graph [ each ] : <EOL> if ( low [ other ] >= pre [ each ] and spanning_tree [ other ] == each ) : <EOL> reply [ each ] = <NUM_LIT:1> <EOL> else : <EOL> children = <NUM_LIT:0> <EOL> for other in graph : <EOL> if ( spanning_tree [ other ] == each ) : <EOL> children = children + <NUM_LIT:1> <EOL> if ( children >= <NUM_LIT:2> ) : <EOL> reply [ each ] = <NUM_LIT:1> <EOL> setrecursionlimit ( recursionlimit ) <EOL> return list ( reply . keys ( ) ) <EOL> def _cut_hypernodes ( hypergraph ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> nodes_ = cut_nodes ( hypergraph . graph ) <EOL> nodes = [ ] <EOL> for each in nodes_ : <EOL> if ( each [ <NUM_LIT:1> ] == '<STR_LIT:n>' ) : <EOL>", "answer": "nodes . append ( each [ <NUM_LIT:0> ] )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> PANEL = '<STR_LIT>' <EOL>", "answer": "PANEL_DASHBOARD = '<STR_LIT>'"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from twisted . words . xish import domish <EOL> from twisted . python import log <EOL>", "answer": "from wokkel . xmppim import AvailablePresence"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL>", "answer": "from . import tokens"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . contrib . admin import site <EOL> from django . contrib . auth . decorators import login_required <EOL> from django . core . urlresolvers import reverse <EOL> from django . db . models import get_model <EOL> from django . forms . models import modelform_factory <EOL> from django . http import HttpResponseRedirect , HttpResponseForbidden <EOL> from django . shortcuts import render_to_response <EOL> from django . template . context import RequestContext <EOL> from django . template . loader import get_template <EOL> from django . template import TemplateDoesNotExist <EOL> from django . utils . translation import ugettext as _ <EOL> from django . views . decorators . cache import never_cache <EOL> from django . utils . importlib import import_module <EOL> from django . conf import settings <EOL> from django . forms import CharField <EOL> from django . contrib import messages <EOL> from forms import DeleteRequestForm , FrontendAdminModelForm <EOL> EXCLUDES = getattr ( settings , '<STR_LIT>' , { } ) <EOL> FIELDS = getattr ( settings , '<STR_LIT>' , { } ) <EOL> FORMS = getattr ( settings , '<STR_LIT>' , { } ) <EOL> def import_function ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> a = s . split ( '<STR_LIT:.>' ) <EOL> j = lambda x : '<STR_LIT:.>' . join ( x ) <EOL> return getattr ( import_module ( j ( a [ : - <NUM_LIT:1> ] ) ) , a [ - <NUM_LIT:1> ] ) <EOL> def check_permission ( request , mode_name , app_label , model_name ) : <EOL> '''<STR_LIT>''' <EOL> p = '<STR_LIT>' % ( app_label , mode_name , model_name ) <EOL> return request . user . is_active and request . user . has_perm ( p ) <EOL> def _get_instance ( request , mode_name , app_label , model_name , instance_id = None , <EOL> form = None , <EOL> form_fields = None , <EOL> form_exclude = None ) : <EOL> '''<STR_LIT>''' <EOL> if not check_permission ( request , mode_name , app_label , model_name ) : <EOL> return HttpResponseForbidden ( '<STR_LIT>' ) <EOL>", "answer": "try :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import abc <EOL> import os <EOL> import random <EOL> import re <EOL> import shutil <EOL> import socket <EOL> import ssl <EOL> import subprocess <EOL> import sys <EOL> import tempfile <EOL> import types <EOL> import uuid <EOL> from oslo_concurrency import processutils as utils <EOL> import six <EOL> from proliantutils import exception <EOL> from proliantutils . ilo import common <EOL> from proliantutils import log <EOL> if six . PY3 : <EOL> def b ( x ) : <EOL> return bytes ( x , '<STR_LIT:ascii>' ) <EOL> else : <EOL> def b ( x ) : <EOL> return x <EOL> LOG = log . get_logger ( __name__ ) <EOL> SUPPORTED_FIRMWARE_UPDATE_COMPONENTS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> RAW_FIRMWARE_EXTNS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def check_firmware_update_component ( func ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ six . wraps ( func ) <EOL> def wrapper ( self , filename , component_type ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> component_type = component_type and component_type . lower ( ) <EOL> if ( component_type not in SUPPORTED_FIRMWARE_UPDATE_COMPONENTS ) : <EOL> msg = ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % <EOL> { '<STR_LIT>' : component_type } ) <EOL> LOG . error ( self . _ ( msg ) ) <EOL> raise exception . InvalidInputError ( msg ) <EOL> return func ( self , filename , component_type ) <EOL> return wrapper <EOL> @ six . add_metaclass ( abc . ABCMeta ) <EOL> class FirmwareImageControllerBase ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , fw_file ) : <EOL> self . fw_file = fw_file <EOL> file_name , file_ext_with_dot = common . get_filename_and_extension_of ( <EOL> fw_file ) <EOL> self . fw_filename = file_name <EOL> self . fw_file_ext = file_ext_with_dot <EOL> class FirmwareImageUploader ( FirmwareImageControllerBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> HTTP_UPLOAD_HEADER = ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def upload_file_to ( self , addressinfo , timeout ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . hostname , self . port = addressinfo <EOL> self . timeout = timeout <EOL> filename = self . fw_file <EOL> firmware = open ( filename , '<STR_LIT:rb>' ) . read ( ) <EOL> boundary = b ( '<STR_LIT>' + <EOL> str ( random . randint ( <NUM_LIT> , <NUM_LIT> ) ) + '<STR_LIT:z>' ) <EOL> while boundary in firmware : <EOL> boundary = b ( '<STR_LIT>' + <EOL> str ( random . randint ( <NUM_LIT> , <NUM_LIT> ) ) + '<STR_LIT:z>' ) <EOL> parts = [ <EOL> b ( \"<STR_LIT>\" ) + boundary + <EOL> b ( \"\"\"<STR_LIT>\"\"\" <EOL> \"\"\"<STR_LIT>\"\"\" ) , <EOL> b ( \"<STR_LIT>\" ) + boundary + <EOL> b ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) + <EOL> b ( filename ) + <EOL> b ( '''<STR_LIT>''' ) , <EOL> firmware , <EOL> b ( \"<STR_LIT>\" ) + boundary + b ( \"<STR_LIT>\" ) , <EOL> ] <EOL> total_bytes = sum ( [ len ( x ) for x in parts ] ) <EOL> sock = self . _get_socket ( ) <EOL> sock . write ( b ( self . HTTP_UPLOAD_HEADER % <EOL> ( total_bytes , boundary . decode ( '<STR_LIT:ascii>' ) ) ) ) <EOL> for part in parts : <EOL> sock . write ( part ) <EOL> data = '<STR_LIT>' <EOL> try : <EOL> while True : <EOL> d = sock . read ( ) <EOL> data += d . decode ( '<STR_LIT>' ) <EOL> if not d : <EOL> break <EOL> except socket . sslerror : <EOL> e = sys . exc_info ( ) [ <NUM_LIT:1> ] <EOL> if not data : <EOL> raise exception . IloConnectionError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % { '<STR_LIT>' : self . hostname , <EOL> '<STR_LIT:port>' : self . port , '<STR_LIT:error>' : str ( e ) } ) <EOL> cookie_match = re . search ( '<STR_LIT>' , data ) <EOL> if not cookie_match : <EOL> raise exception . IloError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % filename ) <EOL> return cookie_match . group ( <NUM_LIT:1> ) <EOL> def _get_socket ( self , sslversion = ssl . PROTOCOL_TLSv1 ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> err = None <EOL> sock = None <EOL> try : <EOL> for res in socket . getaddrinfo ( <EOL> self . hostname , self . port , <NUM_LIT:0> , socket . SOCK_STREAM ) : <EOL> af , socktype , proto , canonname , sa = res <EOL> try : <EOL> sock = socket . socket ( af , socktype , proto ) <EOL> sock . settimeout ( self . timeout ) <EOL> sock . connect ( sa ) <EOL> except socket . timeout : <EOL> if sock is not None : <EOL> sock . close ( ) <EOL> err = exception . IloConnectionError ( <EOL> \"<STR_LIT>\" <EOL> % { '<STR_LIT>' : self . hostname , '<STR_LIT:port>' : self . port } ) <EOL> except socket . error : <EOL> if sock is not None : <EOL> sock . close ( ) <EOL> e = sys . exc_info ( ) [ <NUM_LIT:1> ] <EOL> err = exception . IloConnectionError ( <EOL> \"<STR_LIT>\" <EOL> % { '<STR_LIT>' : self . hostname , '<STR_LIT:port>' : self . port , <EOL> '<STR_LIT:error>' : str ( e ) } ) <EOL> except Exception : <EOL> raise exception . IloConnectionError ( <EOL> \"<STR_LIT>\" % self . hostname ) <EOL> if err is not None : <EOL> raise err <EOL> try : <EOL> return ssl . wrap_socket ( sock , ssl_version = sslversion ) <EOL> except socket . sslerror : <EOL> e = sys . exc_info ( ) [ <NUM_LIT:1> ] <EOL> msg = ( getattr ( e , '<STR_LIT>' , None ) or <EOL> getattr ( e , '<STR_LIT:message>' , None ) ) <EOL> if ( '<STR_LIT>' in msg ) and ( <EOL> sslversion == ssl . PROTOCOL_TLSv1 ) : <EOL> return self . _get_socket ( ssl . PROTOCOL_SSLv3 ) <EOL> raise exception . IloConnectionError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % { '<STR_LIT>' : self . hostname , '<STR_LIT:port>' : self . port , <EOL> '<STR_LIT:error>' : str ( e ) } ) <EOL> class FirmwareImageExtractor ( FirmwareImageControllerBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def extract ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> target_file = self . fw_file <EOL> common . add_exec_permission_to ( target_file ) <EOL> temp_dir = tempfile . mkdtemp ( ) <EOL> extract_path = os . path . join ( temp_dir , self . fw_filename ) <EOL> try : <EOL> self . _do_extract ( target_file , extract_path ) <EOL> except exception . ImageExtractionFailed : <EOL> shutil . rmtree ( temp_dir , ignore_errors = True ) <EOL> raise <EOL> firmware_file_path = _get_firmware_file_in_new_path ( extract_path ) <EOL> shutil . rmtree ( temp_dir , ignore_errors = True ) <EOL> if not firmware_file_path : <EOL> raise exception . InvalidInputError ( <EOL> \"<STR_LIT>\" % target_file ) <EOL> return firmware_file_path , True <EOL>", "answer": "def get_fw_extractor ( fw_file ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from sellmo . core import chaining <EOL> from sellmo . apps . customer . routines import customer_from_request <EOL> from sellmo . apps . customer . models import Contactable , Customer <EOL> from . routines import completed_order_from_request <EOL> @ chaining . link ( customer_from_request , takes_result = True ) <EOL> def _customer_from_request ( customer , request , ** kwargs ) : <EOL> order = completed_order_from_request ( request ) <EOL>", "answer": "if order is not None :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL> from wtforms import Form <EOL> from wtforms import RadioField <EOL> from wtforms import IntegerField <EOL> from wtforms import validators <EOL> from billy . db import tables <EOL> from billy . api . utils import MINIMUM_AMOUNT <EOL> class EnumRadioField ( RadioField ) : <EOL> def __init__ ( self , enum_type , ** kwargs ) : <EOL> super ( EnumRadioField , self ) . __init__ ( <EOL> coerce = self . _value_to_enum , <EOL> ** kwargs <EOL> ) <EOL> self . enum_type = enum_type <EOL> self . choices = [ <EOL> ( enum . value . lower ( ) , enum . description ) for enum in self . enum_type <EOL> ] <EOL> def _value_to_enum ( self , key ) : <EOL> if key is None : <EOL> return key <EOL> return self . enum_type . from_string ( key . upper ( ) ) <EOL> def pre_validate ( self , form ) : <EOL> for enum in self . enum_type : <EOL> if self . data == enum : <EOL> break <EOL> else : <EOL> raise ValueError ( <EOL> self . gettext ( '<STR_LIT>' ) <EOL> . format ( <EOL> self . enum_type . __name__ , <EOL> list ( self . enum_type . values ( ) ) , <EOL> ) <EOL> ) <EOL> class PlanCreateForm ( Form ) : <EOL> plan_type = EnumRadioField ( <EOL> enum_type = tables . PlanType , <EOL>", "answer": "label = '<STR_LIT>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from corehq . pillows . core import DATE_FORMATS_STRING , DATE_FORMATS_ARR <EOL> from corehq . pillows . mappings import NULL_VALUE <EOL> from corehq . util . elastic import es_index <EOL> XFORM_INDEX = es_index ( \"<STR_LIT>\" ) <EOL> XFORM_MAPPING = { <EOL> \"<STR_LIT>\" : False , <EOL> \"<STR_LIT>\" : DATE_FORMATS_ARR , <EOL> '<STR_LIT>' : False , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : '<STR_LIT>' , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> '<STR_LIT>' : { '<STR_LIT:type>' : '<STR_LIT:string>' } , <EOL> '<STR_LIT>' : { \"<STR_LIT:type>\" : \"<STR_LIT:date>\" , \"<STR_LIT>\" : DATE_FORMATS_STRING } , <EOL> '<STR_LIT>' : { '<STR_LIT:type>' : '<STR_LIT:string>' , \"<STR_LIT:index>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : NULL_VALUE } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : { \"<STR_LIT:type>\" : \"<STR_LIT:string>\" , \"<STR_LIT:index>\" : \"<STR_LIT>\" } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT:type>\" : \"<STR_LIT:string>\" , \"<STR_LIT:index>\" : \"<STR_LIT>\" } <EOL> } <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : { \"<STR_LIT:type>\" : \"<STR_LIT:string>\" , \"<STR_LIT:index>\" : \"<STR_LIT>\" } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT:type>\" : \"<STR_LIT:string>\" , \"<STR_LIT:index>\" : \"<STR_LIT>\" } <EOL> } <EOL> } , <EOL> '<STR_LIT>' : { \"<STR_LIT:type>\" : \"<STR_LIT:string>\" } , <EOL> '<STR_LIT>' : { \"<STR_LIT:type>\" : \"<STR_LIT:string>\" } , <EOL> \"<STR_LIT:path>\" : { \"<STR_LIT:type>\" : \"<STR_LIT:string>\" , \"<STR_LIT:index>\" : \"<STR_LIT>\" } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT:type>\" : \"<STR_LIT>\" } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT:type>\" : \"<STR_LIT:string>\" , \"<STR_LIT:index>\" : \"<STR_LIT>\" } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT:type>\" : \"<STR_LIT:string>\" , \"<STR_LIT:index>\" : \"<STR_LIT>\" } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT:type>\" : \"<STR_LIT:date>\" , <EOL> \"<STR_LIT>\" : DATE_FORMATS_STRING <EOL> } , <EOL> '<STR_LIT>' : { \"<STR_LIT:type>\" : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : { \"<STR_LIT:type>\" : \"<STR_LIT>\" } , <EOL> \"<STR_LIT>\" : { \"<STR_LIT:type>\" : \"<STR_LIT:string>\" , \"<STR_LIT:index>\" : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT:type>' : '<STR_LIT:object>' <EOL> } , <EOL> '<STR_LIT>' : { '<STR_LIT:index>' : '<STR_LIT>' , '<STR_LIT:type>' : '<STR_LIT:string>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:index>' : '<STR_LIT>' , '<STR_LIT:type>' : '<STR_LIT:string>' } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : { <EOL>", "answer": "'<STR_LIT>' : { \"<STR_LIT:type>\" : \"<STR_LIT:string>\" , \"<STR_LIT:index>\" : \"<STR_LIT>\" } ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Static ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL>", "answer": "result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL> from itertools import chain <EOL> from openpyxl . descriptors . serialisable import Serialisable <EOL> from openpyxl . descriptors import ( <EOL> MinMax , <EOL> Typed , <EOL> String , <EOL> Strict , <EOL> ) <EOL> from openpyxl . worksheet import Worksheet <EOL> from openpyxl . utils import ( <EOL> get_column_letter , <EOL> range_to_tuple , <EOL> quote_sheetname <EOL> ) <EOL> class DummyWorksheet : <EOL> def __init__ ( self , title ) : <EOL> self . title = title <EOL> class Reference ( Strict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> min_row = MinMax ( min = <NUM_LIT:1> , max = <NUM_LIT> , expected_type = int ) <EOL> max_row = MinMax ( min = <NUM_LIT:1> , max = <NUM_LIT> , expected_type = int ) <EOL> min_col = MinMax ( min = <NUM_LIT:1> , max = <NUM_LIT> , expected_type = int ) <EOL> max_col = MinMax ( min = <NUM_LIT:1> , max = <NUM_LIT> , expected_type = int ) <EOL> range_string = String ( allow_none = True ) <EOL> def __init__ ( self , <EOL> worksheet = None , <EOL> min_col = None , <EOL> min_row = None , <EOL> max_col = None , <EOL> max_row = None , <EOL> range_string = None <EOL> ) : <EOL> if range_string is not None : <EOL> sheetname , boundaries = range_to_tuple ( range_string ) <EOL> min_col , min_row , max_col , max_row = boundaries <EOL> worksheet = DummyWorksheet ( sheetname ) <EOL> self . worksheet = worksheet <EOL> self . min_col = min_col <EOL> self . min_row = min_row <EOL> if max_col is None : <EOL> max_col = min_col <EOL> self . max_col = max_col <EOL> if max_row is None : <EOL> max_row = min_row <EOL>", "answer": "self . max_row = max_row"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sublime <EOL> import json <EOL> from os . path import dirname , realpath <EOL> from . . completions import CompletionList <EOL> from . . inline_documentation import Documentation <EOL> from . . import utils <EOL> COMPLETION_FILES = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> DOC_STYLES = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> completions = { } <EOL> cgi = { } <EOL> def get_tags ( view , prefix , position , info ) : <EOL> completion_list = completions [ info [ \"<STR_LIT>\" ] + \"<STR_LIT>\" ] <EOL> return CompletionList ( completion_list , <NUM_LIT:0> , False ) <EOL> def get_tag_attributes ( view , prefix , position , info ) : <EOL> if not info [ \"<STR_LIT>\" ] : <EOL> return None <EOL> if info [ \"<STR_LIT>\" ] : <EOL> info [ \"<STR_LIT>\" ] = ( \"<STR_LIT::>\" if info [ \"<STR_LIT>\" ] == \"<STR_LIT>\" else \"<STR_LIT>\" ) + info [ \"<STR_LIT>\" ] <EOL> if info [ \"<STR_LIT>\" ] : <EOL> if ( info [ \"<STR_LIT>\" ] in completions [ info [ \"<STR_LIT>\" ] + \"<STR_LIT>\" ] <EOL> and info [ \"<STR_LIT>\" ] in completions [ info [ \"<STR_LIT>\" ] + \"<STR_LIT>\" ] [ info [ \"<STR_LIT>\" ] ] ) : <EOL> completion_list = completions [ info [ \"<STR_LIT>\" ] + \"<STR_LIT>\" ] [ info [ \"<STR_LIT>\" ] ] [ info [ \"<STR_LIT>\" ] ] <EOL> return CompletionList ( completion_list , <NUM_LIT:0> , False ) <EOL> return None <EOL> prefix_start = position - len ( prefix ) <EOL> ch = view . substr ( prefix_start - <NUM_LIT:1> ) <EOL> if ch in [ \"<STR_LIT:U+0020>\" , \"<STR_LIT:\\t>\" , \"<STR_LIT:\\n>\" ] : <EOL> completion_list = completions [ info [ \"<STR_LIT>\" ] + \"<STR_LIT>\" ] . get ( info [ \"<STR_LIT>\" ] , None ) <EOL> return CompletionList ( completion_list , <NUM_LIT:0> , False ) <EOL> return None <EOL> def get_script_completions ( view , prefix , position , info ) : <EOL> completion_list = [ ] <EOL> completion_list . extend ( completions [ info [ \"<STR_LIT>\" ] + \"<STR_LIT>\" ] ) <EOL> completion_list . extend ( completions [ info [ \"<STR_LIT>\" ] + \"<STR_LIT>\" ] ) <EOL> return CompletionList ( completion_list , <NUM_LIT:0> , False ) <EOL> def get_dot_completions ( view , prefix , position , info ) : <EOL> if len ( info [ \"<STR_LIT>\" ] ) == <NUM_LIT:1> and info [ \"<STR_LIT>\" ] [ <NUM_LIT:0> ] . name == \"<STR_LIT>\" : <EOL> return CompletionList ( completions [ \"<STR_LIT>\" ] , <NUM_LIT:1> , True ) <EOL> completion_list = completions [ info [ \"<STR_LIT>\" ] + \"<STR_LIT>\" ] <EOL> return CompletionList ( completion_list , <NUM_LIT:0> , False ) <EOL> def get_inline_documentation ( view , position ) : <EOL> if view . match_selector ( position , \"<STR_LIT>\" ) : <EOL> word = view . word ( position ) <EOL> dot_context = utils . get_dot_context ( view , word . begin ( ) - <NUM_LIT:1> ) <EOL> if len ( dot_context ) == <NUM_LIT:1> and dot_context [ <NUM_LIT:0> ] . name == \"<STR_LIT>\" : <EOL> key = \"<STR_LIT>\" + view . substr ( word ) . lower ( ) <EOL> if key in cgi : <EOL> doc = dict ( DOC_STYLES ) <EOL> doc . update ( cgi [ key ] ) <EOL> return Documentation ( doc , None , <NUM_LIT:1> ) <EOL> return None <EOL> def load_completions ( ) : <EOL> global completions , cgi <EOL> completions_data = { filename : load_json_data ( filename ) for filename in COMPLETION_FILES } <EOL> for dialect in [ \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> completions [ dialect + \"<STR_LIT>\" ] = [ ] <EOL> completions [ dialect + \"<STR_LIT>\" ] = [ ] <EOL> completions [ dialect + \"<STR_LIT>\" ] = { } <EOL> completions [ dialect + \"<STR_LIT>\" ] = { } <EOL> for tag_name in sorted ( completions_data [ dialect + \"<STR_LIT>\" ] . keys ( ) ) : <EOL> if isinstance ( completions_data [ dialect + \"<STR_LIT>\" ] [ tag_name ] , list ) : <EOL> completions_data [ dialect + \"<STR_LIT>\" ] [ tag_name ] = { \"<STR_LIT>\" : completions_data [ dialect + \"<STR_LIT>\" ] [ tag_name ] , \"<STR_LIT>\" : { } } <EOL> tag_attributes = completions_data [ dialect + \"<STR_LIT>\" ] [ tag_name ] [ \"<STR_LIT>\" ] <EOL> completions [ dialect + \"<STR_LIT>\" ] . append ( make_tag_completion ( tag_name , dialect , tag_attributes [ <NUM_LIT:0> ] ) ) <EOL> completions [ dialect + \"<STR_LIT>\" ] . append ( make_tag_completion ( tag_name [ ( <NUM_LIT:1> if dialect == \"<STR_LIT>\" else <NUM_LIT:2> ) : ] , dialect , tag_attributes [ <NUM_LIT:0> ] ) ) <EOL> completions [ dialect + \"<STR_LIT>\" ] [ tag_name ] = [ ( a + '<STR_LIT>' , a + '<STR_LIT>' ) for a in tag_attributes [ <NUM_LIT:0> ] ] <EOL> completions [ dialect + \"<STR_LIT>\" ] [ tag_name ] . extend ( [ ( a + '<STR_LIT>' , a + '<STR_LIT>' ) for a in tag_attributes [ <NUM_LIT:1> ] ] ) <EOL> tag_attribute_values = completions_data [ dialect + \"<STR_LIT>\" ] [ tag_name ] [ \"<STR_LIT>\" ] <EOL> completions [ dialect + \"<STR_LIT>\" ] [ tag_name ] = { } <EOL> for attribute_name in sorted ( tag_attribute_values . keys ( ) ) : <EOL> completions [ dialect + \"<STR_LIT>\" ] [ tag_name ] [ attribute_name ] = [ ( v + '<STR_LIT:\\t>' + attribute_name , v ) for v in tag_attribute_values [ attribute_name ] ] <EOL> completions [ dialect + \"<STR_LIT>\" ] = [ ( funct + '<STR_LIT>' + dialect + '<STR_LIT:)>' , funct + completions_data [ dialect + \"<STR_LIT>\" ] [ funct ] ) for funct in sorted ( completions_data [ dialect + \"<STR_LIT>\" ] . keys ( ) ) ] <EOL> mem_func_comp = [ ] <EOL> for member_function_type in sorted ( completions_data [ dialect + \"<STR_LIT>\" ] . keys ( ) ) : <EOL> for funct in sorted ( completions_data [ dialect + \"<STR_LIT>\" ] [ member_function_type ] . keys ( ) ) : <EOL> mem_func_comp . append ( ( funct + '<STR_LIT:\\t>' + member_function_type + '<STR_LIT>' + dialect + '<STR_LIT:)>' , funct + completions_data [ dialect + \"<STR_LIT>\" ] [ member_function_type ] [ funct ] ) ) <EOL> completions [ dialect + \"<STR_LIT>\" ] = mem_func_comp <EOL> cgi = load_json_data ( \"<STR_LIT>\" ) <EOL>", "answer": "completions [ \"<STR_LIT>\" ] = [ ( scope_variable . split ( \"<STR_LIT:.>\" ) . pop ( ) . upper ( ) + \"<STR_LIT>\" , scope_variable . split ( \"<STR_LIT:.>\" ) . pop ( ) . upper ( ) ) for scope_variable in sorted ( cgi . keys ( ) ) ]"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import unittest <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> import GafferScene <EOL> import GafferSceneTest <EOL> class SceneTimeWarpTest ( GafferSceneTest . SceneTestCase ) : <EOL> def testConstruct ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ \"<STR_LIT:n>\" ] = GafferScene . SceneTimeWarp ( ) <EOL> self . assertEqual ( s [ \"<STR_LIT:n>\" ] [ \"<STR_LIT>\" ] . getValue ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( s [ \"<STR_LIT:n>\" ] [ \"<STR_LIT>\" ] . getValue ( ) , <NUM_LIT:0> ) <EOL> def testRunTimeTyped ( self ) : <EOL> n = GafferScene . SceneTimeWarp ( ) <EOL> self . failUnless ( n . isInstanceOf ( GafferScene . SceneTimeWarp . staticTypeId ( ) ) ) <EOL> self . failUnless ( n . isInstanceOf ( GafferScene . SceneContextProcessor . staticTypeId ( ) ) ) <EOL> self . failUnless ( n . isInstanceOf ( GafferScene . SceneProcessor . staticTypeId ( ) ) ) <EOL>", "answer": "self . failUnless ( n . isInstanceOf ( GafferScene . SceneNode . staticTypeId ( ) ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from coapthon . utils import parse_blockwise <EOL> from coapthon import defines <EOL> from coapthon . messages . option import Option <EOL> __author__ = '<STR_LIT>' <EOL> __version__ = \"<STR_LIT>\" <EOL> class Message ( object ) : <EOL> def __init__ ( self ) : <EOL> self . _type = None <EOL> self . _mid = None <EOL> self . _token = None <EOL> self . _options = [ ] <EOL> self . _payload = None <EOL> self . _destination = None <EOL> self . _source = None <EOL> self . _code = None <EOL> self . _acknowledged = None <EOL> self . _rejected = None <EOL> self . _timeouted = None <EOL> self . _cancelled = None <EOL> self . _duplicated = None <EOL> self . _timestamp = None <EOL> self . _version = <NUM_LIT:1> <EOL> @ property <EOL> def version ( self ) : <EOL> return self . _version <EOL> @ version . setter <EOL> def version ( self , v ) : <EOL> if not isinstance ( v , int ) or v != <NUM_LIT:1> : <EOL> raise AttributeError <EOL> self . _version = v <EOL> @ property <EOL> def type ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _type <EOL> @ type . setter <EOL> def type ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value not in defines . Types . values ( ) : <EOL> raise AttributeError <EOL> self . _type = value <EOL> @ property <EOL> def mid ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _mid <EOL> @ mid . setter <EOL> def mid ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( value , int ) or value > <NUM_LIT> : <EOL> raise AttributeError <EOL> self . _mid = value <EOL> @ mid . deleter <EOL> def mid ( self ) : <EOL> self . _mid = None <EOL> @ property <EOL> def token ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _token <EOL> @ token . setter <EOL> def token ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( value , str ) : <EOL> value = str ( value ) <EOL> if len ( value ) > <NUM_LIT> : <EOL> raise AttributeError <EOL> self . _token = value <EOL> @ token . deleter <EOL> def token ( self ) : <EOL> self . _token = None <EOL> @ property <EOL> def options ( self ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> return self . _options <EOL> @ options . setter <EOL> def options ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value is None : <EOL> value = [ ] <EOL> assert isinstance ( value , list ) <EOL> self . _options = value <EOL> @ property <EOL> def payload ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _payload <EOL> @ payload . setter <EOL> def payload ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( value , tuple ) : <EOL> content_type , payload = value <EOL> self . content_type = content_type <EOL> self . _payload = payload <EOL> else : <EOL> self . _payload = value <EOL> @ property <EOL> def destination ( self ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> return self . _destination <EOL> @ destination . setter <EOL> def destination ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value is not None and ( not isinstance ( value , tuple ) or len ( value ) ) != <NUM_LIT:2> : <EOL> raise AttributeError <EOL> self . _destination = value <EOL> @ property <EOL> def source ( self ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> return self . _source <EOL> @ source . setter <EOL> def source ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( value , tuple ) or len ( value ) != <NUM_LIT:2> : <EOL> raise AttributeError <EOL> self . _source = value <EOL> @ property <EOL> def code ( self ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> return self . _code <EOL> @ code . setter <EOL> def code ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value not in defines . Codes . LIST . keys ( ) and value is not None : <EOL> raise AttributeError <EOL> self . _code = value <EOL> @ property <EOL> def acknowledged ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _acknowledged <EOL> @ acknowledged . setter <EOL> def acknowledged ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert ( isinstance ( value , bool ) ) <EOL> self . _acknowledged = value <EOL> if value : <EOL> self . _timeouted = False <EOL> self . _rejected = False <EOL> self . _cancelled = False <EOL> @ property <EOL> def rejected ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _rejected <EOL> @ rejected . setter <EOL> def rejected ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert ( isinstance ( value , bool ) ) <EOL> self . _rejected = value <EOL> if value : <EOL> self . _timeouted = False <EOL> self . _acknowledged = False <EOL> self . _cancelled = True <EOL> @ property <EOL> def timeouted ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _timeouted <EOL> @ timeouted . setter <EOL> def timeouted ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert ( isinstance ( value , bool ) ) <EOL> self . _timeouted = value <EOL> if value : <EOL> self . _acknowledged = False <EOL> self . _rejected = False <EOL> self . _cancelled = True <EOL> @ property <EOL> def duplicated ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _duplicated <EOL> @ duplicated . setter <EOL> def duplicated ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert ( isinstance ( value , bool ) ) <EOL> self . _duplicated = value <EOL> @ property <EOL> def timestamp ( self ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> return self . _timestamp <EOL> @ timestamp . setter <EOL> def timestamp ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _timestamp = value <EOL> def _already_in ( self , option ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for opt in self . _options : <EOL> if option . number == opt . number : <EOL> return True <EOL> return False <EOL> def add_option ( self , option ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert isinstance ( option , Option ) <EOL> repeatable = defines . OptionRegistry . LIST [ option . number ] . repeatable <EOL> if not repeatable : <EOL> ret = self . _already_in ( option ) <EOL> if ret : <EOL> raise TypeError ( \"<STR_LIT>\" , option . name ) <EOL> else : <EOL> self . _options . append ( option ) <EOL> else : <EOL> self . _options . append ( option ) <EOL> def del_option ( self , option ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert isinstance ( option , Option ) <EOL> while option in list ( self . _options ) : <EOL> self . _options . remove ( option ) <EOL> def del_option_by_name ( self , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for o in list ( self . _options ) : <EOL> assert isinstance ( o , Option ) <EOL> if o . name == name : <EOL> self . _options . remove ( o ) <EOL> def del_option_by_number ( self , number ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for o in list ( self . _options ) : <EOL> assert isinstance ( o , Option ) <EOL> if o . number == number : <EOL> self . _options . remove ( o ) <EOL> @ property <EOL> def etag ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> value = [ ] <EOL> for option in self . options : <EOL> if option . number == defines . OptionRegistry . ETAG . number : <EOL> value . append ( option . value ) <EOL> return value <EOL> @ etag . setter <EOL> def etag ( self , etag ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "if not isinstance ( etag , list ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import abc <EOL> from . context_manager_type_type import ContextManagerTypeType <EOL> class ContextManagerType ( abc . ABCMeta ) : <EOL> '''<STR_LIT>''' <EOL> __metaclass__ = ContextManagerTypeType <EOL> def __new__ ( mcls , name , bases , namespace ) : <EOL> '''<STR_LIT>''' <EOL> if '<STR_LIT>' in namespace : <EOL> from . context_manager import ContextManager <EOL> manage_context = namespace [ '<STR_LIT>' ] <EOL> if '<STR_LIT>' in namespace : <EOL> raise Exception ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) <EOL>", "answer": "if '<STR_LIT>' in namespace :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import numpy as np <EOL> from math import * <EOL> import pybrain . rl . environments <EOL> from pybrain . utilities import one_to_n <EOL> from environment import Environment <EOL> class BalanceTask ( pybrain . rl . environments . EpisodicTask ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> max_tilt = np . pi / <NUM_LIT> <EOL> nactions = <NUM_LIT:9> <EOL> def __init__ ( self , butt_disturbance_amplitude = <NUM_LIT> , only_steer = False , <EOL> max_time = <NUM_LIT> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( BalanceTask , self ) . __init__ ( Environment ( ) ) <EOL> self . _butt_disturbance_amplitude = butt_disturbance_amplitude <EOL> self . only_steer = only_steer <EOL> self . max_time = max_time <EOL> self . t = <NUM_LIT:0> <EOL> @ property <EOL> def indim ( self ) : <EOL> return <NUM_LIT:1> <EOL> @ property <EOL> def outdim ( self ) : <EOL> return <NUM_LIT:5> <EOL> def reset ( self ) : <EOL> super ( BalanceTask , self ) . reset ( ) <EOL> self . t = <NUM_LIT:0> <EOL> def performAction ( self , action ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . t += <NUM_LIT:1> <EOL> assert round ( action [ <NUM_LIT:0> ] ) == action [ <NUM_LIT:0> ] <EOL> if self . only_steer : <EOL> T = <NUM_LIT:2> * ( action [ <NUM_LIT:0> ] / <NUM_LIT> - <NUM_LIT:1.0> ) <EOL> d = <NUM_LIT:0.> <EOL> else : <EOL> torque_selector = np . floor ( action [ <NUM_LIT:0> ] / <NUM_LIT> ) - <NUM_LIT:1.0> <EOL> T = <NUM_LIT:2> * torque_selector <EOL> p = <NUM_LIT> * np . random . rand ( ) - <NUM_LIT:1.0> <EOL> disp_selector = action [ <NUM_LIT:0> ] % <NUM_LIT:3> - <NUM_LIT:1.0> <EOL> d = <NUM_LIT> * disp_selector + self . _butt_disturbance_amplitude * p <EOL> super ( BalanceTask , self ) . performAction ( [ T , d ] ) <EOL> def getObservation ( self ) : <EOL> ( theta , thetad , omega , omegad , omegadd , <EOL> xf , yf , xb , yb , psi , psig ) = self . env . getSensors ( ) <EOL> return self . env . getSensors ( ) [ <NUM_LIT:0> : <NUM_LIT:5> ] <EOL> def isFinished ( self ) : <EOL> if np . abs ( self . env . getTilt ( ) ) > self . max_tilt : <EOL> return True <EOL> elapsed_time = self . env . time_step * self . t <EOL> if elapsed_time > self . max_time : <EOL> print '<STR_LIT>' , self . t , elapsed_time <EOL> return True <EOL> return False <EOL> def getReward ( self ) : <EOL> if np . abs ( self . env . getTilt ( ) ) > self . max_tilt : <EOL> return - <NUM_LIT:1.0> <EOL> return <NUM_LIT:0.0> <EOL> class LinearFATileCoding3456BalanceTask ( BalanceTask ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> theta_bounds = np . array ( <EOL> [ - <NUM_LIT:0.5> * np . pi , - <NUM_LIT:1.0> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT:1.0> , <NUM_LIT:0.5> * np . pi ] ) <EOL> thetad_bounds = np . array ( <EOL> [ - np . inf , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , np . inf ] ) <EOL> omega_bounds = np . array ( <EOL> [ - BalanceTask . max_tilt , - <NUM_LIT> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> , <EOL> BalanceTask . max_tilt ] ) <EOL> omegad_bounds = np . array ( <EOL> [ - np . inf , - <NUM_LIT:0.5> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT:0.5> , np . inf ] ) <EOL> omegadd_bounds = np . array ( <EOL> [ - np . inf , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , np . inf ] ) <EOL> nbins_across_dims = [ <EOL> len ( theta_bounds ) - <NUM_LIT:1> , <EOL> len ( thetad_bounds ) - <NUM_LIT:1> , <EOL> len ( omega_bounds ) - <NUM_LIT:1> , <EOL> len ( omegad_bounds ) - <NUM_LIT:1> , <EOL> len ( omegadd_bounds ) - <NUM_LIT:1> ] <EOL> magic_array = np . cumprod ( [ <NUM_LIT:1> ] + nbins_across_dims ) [ : - <NUM_LIT:1> ] <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( LinearFATileCoding3456BalanceTask , self ) . __init__ ( * args , ** kwargs ) <EOL> self . bin_count = np . zeros ( self . outdim ) <EOL> @ property <EOL> def outdim ( self ) : <EOL> return <NUM_LIT> <EOL> def getBin ( self , theta , thetad , omega , omegad , omegadd ) : <EOL> bin_indices = [ <EOL> np . digitize ( [ theta ] , self . theta_bounds ) [ <NUM_LIT:0> ] - <NUM_LIT:1> , <EOL> np . digitize ( [ thetad ] , self . thetad_bounds ) [ <NUM_LIT:0> ] - <NUM_LIT:1> , <EOL> np . digitize ( [ omega ] , self . omega_bounds ) [ <NUM_LIT:0> ] - <NUM_LIT:1> , <EOL> np . digitize ( [ omegad ] , self . omegad_bounds ) [ <NUM_LIT:0> ] - <NUM_LIT:1> , <EOL> np . digitize ( [ omegadd ] , self . omegadd_bounds ) [ <NUM_LIT:0> ] - <NUM_LIT:1> , <EOL> ] <EOL> linear_index = np . dot ( self . magic_array , bin_indices ) <EOL> if linear_index > self . outdim : <EOL> print self . isFinished ( ) <EOL> print self . env . getTilt ( ) <EOL> print np . abs ( self . env . getTilt ( ) ) <EOL> print self . max_tilt <EOL> print np . abs ( self . env . getTilt ( ) ) > self . max_tilt <EOL> print self . env . getSensors ( ) [ <NUM_LIT:0> : <NUM_LIT:5> ] <EOL> print self . magic_array <EOL> print bin_index_for_each_dim <EOL> print linear_index <EOL> return linear_index <EOL> def getBinIndices ( self , linear_index ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return linear_index / self . magic_array % self . nbins_across_dims <EOL> def getObservation ( self ) : <EOL> ( theta , thetad , omega , omegad , omegadd , <EOL> xf , yf , xb , yb , psi , psig ) = self . env . getSensors ( ) <EOL> state = one_to_n ( self . getBin ( theta , thetad , omega , omegad , omegadd ) , <EOL> self . outdim ) <EOL> self . bin_count += state <EOL> return state <EOL> class LSPIBalanceTask ( BalanceTask ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ property <EOL> def outdim ( self ) : <EOL> return <NUM_LIT> <EOL> def getPhi ( self , theta , thetad , omega , omegad , omegadd ) : <EOL> return np . array ( [ <EOL> <NUM_LIT:1> , omega , omegad , omega ** <NUM_LIT:2> , omegad ** <NUM_LIT:2> , omega * omegad , <EOL> theta , thetad , theta ** <NUM_LIT:2> , thetad ** <NUM_LIT:2> , theta * thetad , <EOL> omega * theta , omega * theta ** <NUM_LIT:2> , omega ** <NUM_LIT:2> * theta , <EOL> ] ) <EOL> def getObservation ( self ) : <EOL> ( theta , thetad , omega , omegad , omegadd , <EOL> xf , yf , xb , yb , psi , psig ) = self . env . getSensors ( ) <EOL> return self . getPhi ( theta , thetad , omega , omegad , omegadd ) <EOL> class LinearFATileCoding3456GoToTask ( BalanceTask ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> theta_bounds = np . array ( <EOL> [ - <NUM_LIT:0.5> * np . pi , - <NUM_LIT:1.0> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT:1.0> , <NUM_LIT:0.5> * np . pi ] ) <EOL> thetad_bounds = np . array ( <EOL> [ - np . inf , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , np . inf ] ) <EOL> omega_bounds = np . array ( <EOL> [ - BalanceTask . max_tilt , - <NUM_LIT> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> , <EOL> BalanceTask . max_tilt ] ) <EOL> omegad_bounds = np . array ( <EOL> [ - np . inf , - <NUM_LIT:0.5> , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT:0.5> , np . inf ] ) <EOL> omegadd_bounds = np . array ( <EOL> [ - np . inf , - <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT> , np . inf ] ) <EOL> nbins_across_dims = [ <EOL> len ( theta_bounds ) - <NUM_LIT:1> , <EOL> len ( thetad_bounds ) - <NUM_LIT:1> , <EOL> len ( omega_bounds ) - <NUM_LIT:1> , <EOL> len ( omegad_bounds ) - <NUM_LIT:1> , <EOL> len ( omegadd_bounds ) - <NUM_LIT:1> ] <EOL> magic_array = np . cumprod ( [ <NUM_LIT:1> ] + nbins_across_dims ) [ : - <NUM_LIT:1> ] <EOL> @ property <EOL> def outdim ( self ) : <EOL> return <NUM_LIT> <EOL> def getBin ( self , theta , thetad , omega , omegad , omegadd ) : <EOL>", "answer": "bin_indices = ["}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django import forms <EOL> class PrintRequestForm ( forms . Form ) : <EOL> STATUS_CHOICES = ( <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ) <EOL> HOLD_CHOICES = ( <EOL> ( \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ) , <EOL> ) <EOL> entry_994442820 = forms . CharField ( label = \"<STR_LIT>\" , widget = forms . HiddenInput ) <EOL> entry_621323238 = forms . CharField ( label = \"<STR_LIT>\" , widget = forms . HiddenInput ) <EOL> entry_1696606454 = forms . CharField ( label = \"<STR_LIT>\" , <EOL> required = True ) <EOL> entry_699468619 = forms . ChoiceField ( label = \"<STR_LIT>\" , <EOL> required = True , <EOL> choices = STATUS_CHOICES ) <EOL> entry_571937374 = forms . CharField ( label = \"<STR_LIT>\" , <EOL> widget = forms . TextInput ( <EOL> attrs = { '<STR_LIT:size>' : '<STR_LIT>' } ) , <EOL> required = True , <EOL> help_text = '<STR_LIT>' ) <EOL> entry_700519383 = forms . EmailField ( label = \"<STR_LIT>\" , <EOL> required = True ) <EOL>", "answer": "entry_1104324905 = forms . CharField ( label = \"<STR_LIT>\" , widget = forms . HiddenInput )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = <NUM_LIT:8>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from flask import render_template , Blueprint , Markup <EOL> def gist ( gist_id , ** kwargs ) : <EOL> script_url = '<STR_LIT>' . format ( gist_id ) <EOL> return Markup ( render_template ( '<STR_LIT>' , script_url = script_url ) ) <EOL>", "answer": "class Gist ( object ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> class Solution : <EOL> def trailingZeroes ( self , n ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cnt = <NUM_LIT:0> <EOL> while n : <EOL>", "answer": "n /= <NUM_LIT:5>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = ResourceContainer ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL>", "answer": "result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from celery . task import task <EOL> from celery . execute import send_task <EOL> from celery . log import get_default_logger <EOL>", "answer": "log = get_default_logger ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import abc <EOL> import copy <EOL> from oslo_utils import reflection <EOL> import six <EOL> from six . moves import map as compat_map <EOL> from six . moves import reduce as compat_reduce <EOL> from taskflow import atom <EOL> from taskflow import logging <EOL> from taskflow . types import notifier <EOL> from taskflow . utils import misc <EOL> LOG = logging . getLogger ( __name__ ) <EOL> REVERT_RESULT = '<STR_LIT:result>' <EOL> REVERT_FLOW_FAILURES = '<STR_LIT>' <EOL> EVENT_UPDATE_PROGRESS = '<STR_LIT>' <EOL> @ six . add_metaclass ( abc . ABCMeta ) <EOL> class Task ( atom . Atom ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> TASK_EVENTS = ( EVENT_UPDATE_PROGRESS , ) <EOL> def __init__ ( self , name = None , provides = None , requires = None , <EOL> auto_extract = True , rebind = None , inject = None , <EOL> ignore_list = None , revert_rebind = None , revert_requires = None ) : <EOL> if name is None : <EOL> name = reflection . get_class_name ( self ) <EOL> super ( Task , self ) . __init__ ( name , provides = provides , requires = requires , <EOL> auto_extract = auto_extract , rebind = rebind , <EOL> inject = inject , revert_rebind = revert_rebind , <EOL> revert_requires = revert_requires ) <EOL> self . _notifier = notifier . RestrictedNotifier ( self . TASK_EVENTS ) <EOL> @ property <EOL> def notifier ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _notifier <EOL> def copy ( self , retain_listeners = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c = copy . copy ( self ) <EOL> c . _notifier = self . _notifier . copy ( ) <EOL> if not retain_listeners : <EOL> c . _notifier . reset ( ) <EOL> return c <EOL> def update_progress ( self , progress ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def on_clamped ( ) : <EOL> LOG . warn ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , progress ) <EOL> cleaned_progress = misc . clamp ( progress , <NUM_LIT:0.0> , <NUM_LIT:1.0> , <EOL> on_clamped = on_clamped ) <EOL> self . _notifier . notify ( EVENT_UPDATE_PROGRESS , <EOL> { '<STR_LIT>' : cleaned_progress } ) <EOL> class FunctorTask ( Task ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , execute , name = None , provides = None , <EOL> requires = None , auto_extract = True , rebind = None , revert = None , <EOL> version = None , inject = None ) : <EOL> if not six . callable ( execute ) : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> if revert is not None : <EOL> if not six . callable ( revert ) : <EOL>", "answer": "raise ValueError ( \"<STR_LIT>\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import numpy as np <EOL> from gym import utils <EOL> from gym . envs . mujoco import mujoco_env <EOL> class InvertedDoublePendulumEnv ( mujoco_env . MujocoEnv , utils . EzPickle ) : <EOL> def __init__ ( self ) : <EOL> mujoco_env . MujocoEnv . __init__ ( self , '<STR_LIT>' , <NUM_LIT:5> ) <EOL> utils . EzPickle . __init__ ( self ) <EOL> self . finalize ( ) <EOL> def _step ( self , action ) : <EOL>", "answer": "self . do_simulation ( action , self . frame_skip )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import codecs <EOL> import zlib <EOL> def zlib_encode ( input , errors = '<STR_LIT:strict>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert errors == '<STR_LIT:strict>' <EOL> output = zlib . compress ( input ) <EOL> return ( output , len ( input ) ) <EOL> def zlib_decode ( input , errors = '<STR_LIT:strict>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert errors == '<STR_LIT:strict>' <EOL> output = zlib . decompress ( input ) <EOL>", "answer": "return ( output , len ( input ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = - <NUM_LIT:1>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import floppyforms as forms <EOL> import datetime <EOL> from django . conf import settings <EOL> from django . contrib . staticfiles . templatetags . staticfiles import static <EOL> from tinymce . widgets import TinyMCE <EOL> class DatePicker ( forms . TextInput ) : <EOL> template_name = '<STR_LIT>' <EOL> format = \"<STR_LIT>\" <EOL> def render ( self , name , value , attrs = None ) : <EOL> if isinstance ( value , datetime . date ) : <EOL> value = value . strftime ( self . format ) <EOL> return super ( DatePicker , self ) . render ( name , value , attrs ) <EOL> class Media : <EOL> css = { <EOL> '<STR_LIT:all>' : ( '<STR_LIT>' , ) <EOL> } <EOL> class DateTimePicker ( forms . TextInput ) : <EOL> template_name = '<STR_LIT>' <EOL> format = \"<STR_LIT>\" <EOL> def render ( self , name , value , attrs = None ) : <EOL> if isinstance ( value , datetime . datetime ) : <EOL> value = value . strftime ( self . format ) <EOL> return super ( DateTimePicker , self ) . render ( name , value , attrs ) <EOL> class Media : <EOL> css = { <EOL> '<STR_LIT:all>' : ( '<STR_LIT>' , ) <EOL> } <EOL> class SlugWidget ( forms . widgets . SlugInput ) : <EOL> template_name = '<STR_LIT>' <EOL> def __init__ ( self , prepopulated_from , attrs = None ) : <EOL> self . prepopulated_from = prepopulated_from <EOL> super ( SlugWidget , self ) . __init__ ( attrs ) <EOL> def get_context_data ( self ) : <EOL> context = super ( SlugWidget , self ) . get_context_data ( ) <EOL> context [ '<STR_LIT>' ] = '<STR_LIT>' % self . prepopulated_from <EOL> return context <EOL> class Media : <EOL> js = ( '<STR_LIT>' , ) <EOL> class TinyMCELargeTable ( TinyMCE ) : <EOL> def render ( self , name , value , attrs = None ) : <EOL> return u'<STR_LIT>' % super ( TinyMCELargeTable , self ) . render ( name , value , attrs ) <EOL> class TinyMCESimple ( TinyMCE ) : <EOL> def __init__ ( self , content_language = None , attrs = None , mce_attrs = None ) : <EOL> compiled_attrs = { '<STR_LIT>' : '<STR_LIT>' } <EOL> if attrs is not None : <EOL> compiled_attrs . update ( attrs ) <EOL> super ( TinyMCE , self ) . __init__ ( compiled_attrs ) <EOL> if mce_attrs is None : <EOL> mce_attrs = { '<STR_LIT>' : '<STR_LIT>' } <EOL> self . mce_attrs = mce_attrs <EOL> if content_language is None : <EOL> content_language = mce_attrs . get ( '<STR_LIT>' , None ) <EOL> self . content_language = content_language <EOL> class Slider ( forms . RangeInput ) : <EOL> min = <NUM_LIT:1> <EOL> max = <NUM_LIT> <EOL> step = <NUM_LIT:1> <EOL> template_name = '<STR_LIT>' <EOL> class Media : <EOL> css = { <EOL> '<STR_LIT:all>' : ( <EOL> '<STR_LIT>' , <EOL> ) <EOL> } <EOL> class TemplateThemeSelectWidget ( forms . widgets . RadioSelect ) : <EOL>", "answer": "template_name = '<STR_LIT>' "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT>''' <EOL> from lux . core import Parameter , LuxExtension <EOL> from . backends import TokenBackend , SessionBackend <EOL> from . views import Authorization , ComingSoon <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] <EOL>", "answer": "class Extension ( LuxExtension ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys <EOL>", "answer": "from random import choice"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> try : <EOL> import pkg_resources <EOL> pkg_resources . declare_namespace ( __name__ ) <EOL>", "answer": "except ImportError :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import uuid <EOL> from datetime import datetime <EOL> from flask import current_app <EOL> from manager_rest import models , storage_manager <EOL> from manager_rest . blueprints_manager import tasks , BlueprintsManager <EOL> import manager_rest . manager_exceptions <EOL> import manager_rest . workflow_client as wf_client <EOL> from dsl_parser import constants <EOL> from handlers import ( DeploymentUpdateNodeHandler , <EOL> DeploymentUpdateNodeInstanceHandler ) <EOL> from validator import StepValidator <EOL> from utils import extract_ids <EOL> from constants import STATE , CHANGE_TYPE <EOL> class DeploymentUpdateManager ( object ) : <EOL> def __init__ ( self ) : <EOL> self . sm = storage_manager . get_storage_manager ( ) <EOL> self . workflow_client = wf_client . get_workflow_client ( ) <EOL> self . _node_handler = DeploymentUpdateNodeHandler ( ) <EOL> self . _node_instance_handler = DeploymentUpdateNodeInstanceHandler ( ) <EOL> self . _step_validator = StepValidator ( ) <EOL> def get_deployment_update ( self , deployment_update_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . sm . get_deployment_update ( deployment_update_id ) <EOL> def deployment_updates_list ( self , include = None , filters = None , <EOL> pagination = None , sort = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . sm . deployment_updates_list ( include = include , <EOL> filters = filters , <EOL> pagination = pagination , <EOL> sort = sort ) <EOL> def stage_deployment_update ( self , deployment_id , staged_blueprint ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _validate_no_active_updates_per_deployment ( deployment_id ) <EOL> deployment_update = models . DeploymentUpdate ( deployment_id , <EOL> staged_blueprint ) <EOL> self . sm . put_deployment_update ( deployment_update ) <EOL> return deployment_update <EOL> def create_deployment_update_step ( self , deployment_update_id , <EOL> operation , entity_type , entity_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> step = models . DeploymentUpdateStep ( operation , <EOL> entity_type , <EOL> entity_id ) <EOL> dep_update = self . get_deployment_update ( deployment_update_id ) <EOL> self . _step_validator . validate ( dep_update , step ) <EOL> self . sm . put_deployment_update_step ( deployment_update_id , step ) <EOL> return step <EOL> def commit_deployment_update ( self , deployment_update_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dep_update = self . get_deployment_update ( deployment_update_id ) <EOL> dep_update . state = STATE . COMMITTING <EOL> self . sm . update_deployment_update ( dep_update ) <EOL> modified_entity_ids , depup_nodes = self . _node_handler . handle ( dep_update ) <EOL> node_instance_changes = self . _extract_changes ( dep_update , <EOL> depup_nodes ) <EOL> depup_node_instances = self . _node_instance_handler . handle ( dep_update , <EOL> node_instance_changes ) <EOL> dep_update . deployment_update_nodes = depup_nodes <EOL> dep_update . deployment_update_node_instances = depup_node_instances <EOL> dep_update . modified_entity_ids = modified_entity_ids . to_dict ( ) <EOL> self . sm . update_deployment_update ( dep_update ) <EOL> self . _execute_update_workflow ( dep_update , <EOL> depup_node_instances , <EOL> modified_entity_ids . to_dict ( ) ) <EOL> return models . DeploymentUpdate ( deployment_update_id , <EOL> dep_update . blueprint ) <EOL> def _validate_no_active_updates_per_deployment ( self , deployment_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> existing_updates = self . deployment_updates_list ( filters = { <EOL> '<STR_LIT>' : deployment_id <EOL> } ) . items <EOL> active_update = next ( iter ( <EOL> [ u for u in existing_updates <EOL> if u . state != STATE . COMMITTED ] ) , None ) <EOL> if active_update : <EOL> raise manager_rest . manager_exceptions . ConflictError ( <EOL> '<STR_LIT>' <EOL> . format ( active_update . id ) <EOL> ) <EOL> def _extract_changes ( self , dep_update , raw_nodes ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> deployment_id_filter = { '<STR_LIT>' : dep_update . deployment_id } <EOL> raw_node_instances = [ instance . to_dict ( ) for instance in <EOL> self . sm . get_node_instances ( filters = deployment_id_filter ) . items ] <EOL> return tasks . modify_deployment ( <EOL> nodes = raw_nodes , <EOL> previous_node_instances = raw_node_instances , <EOL> modified_nodes = ( ) <EOL> ) <EOL> def _execute_update_workflow ( self , <EOL> dep_update , <EOL> node_instances , <EOL> modified_entity_ids ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> added_instances = node_instances [ CHANGE_TYPE . ADDED_AND_RELATED ] <EOL> extended_instances = node_instances [ CHANGE_TYPE . EXTENDED_AND_RELATED ] <EOL> reduced_instances = node_instances [ CHANGE_TYPE . REDUCED_AND_RELATED ] <EOL> removed_instances = node_instances [ CHANGE_TYPE . REMOVED_AND_RELATED ] <EOL> instance_ids = { <EOL> '<STR_LIT>' : dep_update . id , <EOL> '<STR_LIT>' : <EOL> extract_ids ( added_instances . get ( CHANGE_TYPE . AFFECTED ) ) , <EOL> '<STR_LIT>' : <EOL> extract_ids ( added_instances . get ( CHANGE_TYPE . RELATED ) ) , <EOL> '<STR_LIT>' : modified_entity_ids , <EOL> '<STR_LIT>' : <EOL> extract_ids ( extended_instances . get ( CHANGE_TYPE . AFFECTED ) ) , <EOL> '<STR_LIT>' : <EOL> extract_ids ( extended_instances . get ( CHANGE_TYPE . RELATED ) ) , <EOL> '<STR_LIT>' : <EOL> extract_ids ( reduced_instances . get ( CHANGE_TYPE . AFFECTED ) ) , <EOL> '<STR_LIT>' : <EOL> extract_ids ( reduced_instances . get ( CHANGE_TYPE . RELATED ) ) , <EOL> '<STR_LIT>' : <EOL> extract_ids ( removed_instances . get ( CHANGE_TYPE . AFFECTED ) ) , <EOL> '<STR_LIT>' : <EOL> extract_ids ( removed_instances . get ( CHANGE_TYPE . RELATED ) ) <EOL> } <EOL> return self . execute_workflow ( deployment_id = dep_update . deployment_id , <EOL> workflow_id = '<STR_LIT>' , <EOL> parameters = instance_ids ) <EOL> def finalize_commit ( self , deployment_update_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dep_update = self . get_deployment_update ( deployment_update_id ) <EOL> self . _node_instance_handler . finalize ( dep_update ) <EOL> self . _node_handler . finalize ( dep_update ) <EOL> dep_update . state = STATE . COMMITTED <EOL> self . sm . update_deployment_update ( dep_update ) <EOL> return models . DeploymentUpdate ( deployment_update_id , <EOL> dep_update . blueprint ) <EOL> def execute_workflow ( self , <EOL> deployment_id , <EOL> workflow_id , <EOL> parameters = None , <EOL> allow_custom_parameters = False , <EOL> force = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> deployment = self . sm . get_deployment ( deployment_id ) <EOL> blueprint = self . sm . get_blueprint ( deployment . blueprint_id ) <EOL> if workflow_id not in deployment . workflows : <EOL> raise manager_rest . manager_exceptions . NonexistentWorkflowError ( <EOL> '<STR_LIT>' . format ( <EOL> workflow_id , deployment_id ) ) <EOL> workflow = deployment . workflows [ workflow_id ] <EOL> execution_parameters = BlueprintsManager . _merge_and_validate_execution_parameters ( <EOL> workflow , workflow_id , parameters , allow_custom_parameters ) <EOL> execution_id = str ( uuid . uuid4 ( ) ) <EOL> new_execution = models . Execution ( <EOL> id = execution_id , <EOL> status = models . Execution . PENDING , <EOL> created_at = str ( datetime . now ( ) ) , <EOL> blueprint_id = deployment . blueprint_id , <EOL> workflow_id = workflow_id , <EOL> deployment_id = deployment_id , <EOL> error = '<STR_LIT>' , <EOL> parameters = BlueprintsManager . _get_only_user_execution_parameters ( <EOL> execution_parameters ) , <EOL> is_system_workflow = False ) <EOL> self . sm . put_execution ( new_execution . id , new_execution ) <EOL> workflow_plugins = blueprint . plan [ <EOL> constants . WORKFLOW_PLUGINS_TO_INSTALL ] <EOL> self . workflow_client . execute_workflow ( <EOL> workflow_id , <EOL> workflow , <EOL> workflow_plugins = workflow_plugins , <EOL> blueprint_id = deployment . blueprint_id , <EOL>", "answer": "deployment_id = deployment_id ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os , sys <EOL> sys . path . insert ( <EOL> <NUM_LIT:0> , <EOL> os . path . normpath ( <EOL> os . path . join ( <EOL> os . path . dirname ( os . path . abspath ( __file__ ) ) , <EOL> \"<STR_LIT:..>\" <EOL> ) <EOL> ) <EOL> ) <EOL> from test_common import ( <EOL> my_print , <EOL> setup , <EOL> createSearchMode , <EOL> compareWithCPython , <EOL> withPythonPathChange <EOL> ) <EOL> python_version = setup ( needs_io_encoding = True ) <EOL> search_mode = createSearchMode ( ) <EOL> extra_options = os . environ . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for filename in sorted ( os . listdir ( '<STR_LIT:.>' ) ) : <EOL> if not os . path . isdir ( filename ) or filename . endswith ( \"<STR_LIT>\" ) or filename . endswith ( \"<STR_LIT>\" ) : <EOL> continue <EOL> filename = os . path . relpath ( filename ) <EOL> expected_errors = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ] <EOL> if python_version < \"<STR_LIT>\" : <EOL> expected_errors . append ( \"<STR_LIT>\" ) <EOL> if filename not in expected_errors : <EOL> extra_flags = [ \"<STR_LIT>\" ] <EOL> else : <EOL> extra_flags = [ \"<STR_LIT>\" ] <EOL> if filename in ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> extra_flags . append ( \"<STR_LIT>\" ) <EOL> extra_flags . append ( \"<STR_LIT>\" ) <EOL> extra_flags . append ( \"<STR_LIT>\" ) <EOL> extra_flags . append ( \"<STR_LIT>\" ) <EOL> if filename != \"<STR_LIT>\" : <EOL> extra_flags . append ( \"<STR_LIT>\" ) <EOL> else : <EOL> extra_flags . append ( \"<STR_LIT>\" ) <EOL> if filename == \"<STR_LIT>\" : <EOL> os . environ [ \"<STR_LIT>\" ] = extra_options + \"<STR_LIT>\" % ( <EOL> os . path . abspath ( filename ) <EOL> ) <EOL> elif filename == \"<STR_LIT>\" : <EOL> if python_version < '<STR_LIT:3>' : <EOL> os . environ [ \"<STR_LIT>\" ] = extra_options + \"<STR_LIT>\" % ( <EOL> os . path . abspath ( filename ) <EOL> ) <EOL> else : <EOL> os . environ [ \"<STR_LIT>\" ] = extra_options + \"<STR_LIT>\" % ( <EOL> os . path . abspath ( filename ) <EOL> ) <EOL> extra_flags . append ( \"<STR_LIT>\" ) <EOL> else : <EOL> os . environ [ \"<STR_LIT>\" ] = extra_options <EOL> active = search_mode . consider ( <EOL> dirname = None , <EOL> filename = filename <EOL> ) <EOL> if active : <EOL> my_print ( \"<STR_LIT>\" , filename ) <EOL> for filename_main in os . listdir ( filename ) : <EOL> if filename_main . endswith ( \"<STR_LIT>\" ) : <EOL> break <EOL> if filename_main . endswith ( \"<STR_LIT>\" ) : <EOL> break <EOL> else : <EOL> sys . exit ( <EOL> \"\"\"<STR_LIT>\"\"\" % ( <EOL> filename <EOL> ) <EOL> ) <EOL> extra_python_path = [ <EOL>", "answer": "os . path . abspath ( os . path . join ( filename , entry ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from cloudcafe . glance . common . constants import Messages <EOL> from cloudroast . glance . fixtures import ImagesFixture <EOL> class JsonSchemaOperationsSmoke ( ImagesFixture ) : <EOL> def test_get_images_schema ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> resp = self . images . client . get_images_schema ( ) <EOL> self . assertEqual ( <EOL>", "answer": "resp . status_code , <NUM_LIT:200> ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL> import veriloggen . core . vtypes as vtypes <EOL> import veriloggen . core . module as module <EOL> def mkMultiplierCore ( index , lwidth = <NUM_LIT:32> , rwidth = <NUM_LIT:32> , lsigned = True , rsigned = True , depth = <NUM_LIT:6> ) : <EOL> retwidth = lwidth + rwidth <EOL> m = module . Module ( '<STR_LIT>' % index ) <EOL> clk = m . Input ( '<STR_LIT>' ) <EOL> update = m . Input ( '<STR_LIT>' ) <EOL> a = m . Input ( '<STR_LIT:a>' , lwidth ) <EOL> b = m . Input ( '<STR_LIT:b>' , rwidth ) <EOL> c = m . Output ( '<STR_LIT:c>' , retwidth ) <EOL> _a = m . Reg ( '<STR_LIT>' , lwidth , signed = lsigned ) <EOL> _b = m . Reg ( '<STR_LIT>' , rwidth , signed = rsigned ) <EOL> tmpval = [ m . Reg ( '<STR_LIT>' % i , retwidth , signed = True ) for i in range ( depth - <NUM_LIT:1> ) ] <EOL> rslt = m . Wire ( '<STR_LIT>' , retwidth , signed = True ) <EOL> __a = _a <EOL> __b = _b <EOL> if not lsigned : <EOL> __a = vtypes . SystemTask ( '<STR_LIT>' , vtypes . Cat ( vtypes . Int ( <NUM_LIT:0> , width = <NUM_LIT:1> ) , _a ) ) <EOL> if not rsigned : <EOL> __b = vtypes . SystemTask ( '<STR_LIT>' , vtypes . Cat ( vtypes . Int ( <NUM_LIT:0> , width = <NUM_LIT:1> ) , _b ) ) <EOL> m . Assign ( rslt ( __a * __b ) ) <EOL> m . Assign ( c ( tmpval [ depth - <NUM_LIT:2> ] ) ) <EOL> m . Always ( vtypes . Posedge ( clk ) ) ( <EOL> vtypes . If ( update ) ( <EOL> _a ( a ) , <EOL> _b ( b ) , <EOL> tmpval [ <NUM_LIT:0> ] ( rslt ) , <EOL> [ tmpval [ i ] ( tmpval [ i - <NUM_LIT:1> ] ) for i in range ( <NUM_LIT:1> , depth - <NUM_LIT:1> ) ] <EOL> ) ) <EOL> return m <EOL> def mkMultiplier ( index , lwidth = <NUM_LIT:32> , rwidth = <NUM_LIT:32> , lsigned = True , rsigned = True , depth = <NUM_LIT:6> ) : <EOL> if lwidth < <NUM_LIT:0> : raise ValueError ( \"<STR_LIT>\" ) <EOL> if rwidth < <NUM_LIT:0> : raise ValueError ( \"<STR_LIT>\" ) <EOL> if depth < <NUM_LIT:2> : raise ValueError ( \"<STR_LIT>\" ) <EOL> retwidth = lwidth + rwidth <EOL> mult = mkMultiplierCore ( index , lwidth , rwidth , lsigned , rsigned , depth ) <EOL> m = module . Module ( '<STR_LIT>' % index ) <EOL> clk = m . Input ( '<STR_LIT>' ) <EOL> rst = m . Input ( '<STR_LIT>' ) <EOL> update = m . Input ( '<STR_LIT>' ) <EOL> enable = m . Input ( '<STR_LIT>' ) <EOL> valid = m . Output ( '<STR_LIT>' ) <EOL> a = m . Input ( '<STR_LIT:a>' , lwidth ) <EOL> b = m . Input ( '<STR_LIT:b>' , rwidth ) <EOL> c = m . Output ( '<STR_LIT:c>' , retwidth ) <EOL> valid_reg = [ m . Reg ( '<STR_LIT>' % i ) for i in range ( depth ) ] <EOL> m . Assign ( valid ( valid_reg [ depth - <NUM_LIT:1> ] ) ) <EOL> m . Always ( vtypes . Posedge ( clk ) ) ( <EOL> vtypes . If ( rst ) ( <EOL> [ valid_reg [ i ] ( <NUM_LIT:0> ) for i in range ( depth ) ] <EOL> ) . Else ( <EOL> vtypes . If ( update ) ( <EOL> valid_reg [ <NUM_LIT:0> ] ( enable ) , <EOL> [ valid_reg [ i ] ( valid_reg [ i - <NUM_LIT:1> ] ) for i in range ( <NUM_LIT:1> , depth ) ] <EOL> ) <EOL> ) ) <EOL> ports = [ ( '<STR_LIT>' , clk ) , ( '<STR_LIT>' , update ) , ( '<STR_LIT:a>' , a ) , ( '<STR_LIT:b>' , b ) , ( '<STR_LIT:c>' , c ) ] <EOL>", "answer": "m . Instance ( mult , '<STR_LIT>' , ports = ports )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT>''' <EOL> __version__ = '<STR_LIT>' <EOL> try : <EOL> from setuptools import setup <EOL> except : <EOL> from distutils . core import setup <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = __version__ , <EOL> description = '<STR_LIT>' , <EOL> keywords = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> url = '<STR_LIT>' , <EOL> license = '<STR_LIT>' , <EOL> packages = [ '<STR_LIT>' ] , <EOL> test_suite = '<STR_LIT>' , <EOL> classifiers = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> from st2common . bootstrap import aliasesregistrar <EOL> from st2tests import DbTestCase , fixturesloader <EOL> ALIASES_FIXTURE_PACK_PATH = os . path . join ( fixturesloader . get_fixtures_base_path ( ) , '<STR_LIT>' ) <EOL> ALIASES_FIXTURE_PATH = os . path . join ( ALIASES_FIXTURE_PACK_PATH , '<STR_LIT>' ) <EOL>", "answer": "class TestAliasRegistrar ( DbTestCase ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import datetime <EOL> from django . test import SimpleTestCase <EOL> from . test_data_source_config import get_sample_data_source <EOL> from . . sql import get_indicator_table <EOL> from . . views import process_url_params <EOL> class ParameterTest ( SimpleTestCase ) : <EOL> def setUp ( self ) : <EOL> config = get_sample_data_source ( ) <EOL> self . columns = get_indicator_table ( config ) . columns <EOL> def test_no_parameters ( self ) : <EOL>", "answer": "params = process_url_params ( { } , self . columns )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import itertools <EOL> import matplotlib . pyplot as plt <EOL> import matplotlib . image as mpimg <EOL> from mpl_toolkits . mplot3d import Axes3D <EOL> from sklearn . preprocessing import StandardScaler <EOL> from sklearn . decomposition import PCA <EOL> from sklearn . pipeline import Pipeline <EOL> from sklearn . cluster import KMeans <EOL> import numpy as np <EOL> import scipy . io as sio <EOL> from ex7_pca import project_data , recover_data , display_data <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL>", "answer": "data = sio . loadmat ( '<STR_LIT>' )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import socket , traceback , threading , queue <EOL> from . log import log <EOL> class Interop : <EOL> def __init__ ( self , on_recv , on_connect , on_not_connected ) : <EOL> self . readWorker = None <EOL> self . readWorkerStopEvent = None <EOL> self . readBuffer = bytes ( ) <EOL> self . socket = None <EOL> self . on_connect = on_connect <EOL> self . on_recv = on_recv <EOL> self . on_not_connected = on_not_connected <EOL> self . sendWorker = None <EOL> self . sendQueue = queue . Queue ( ) <EOL> self . sendDataEvent = None <EOL> self . sendWorkerStopEvent = None <EOL> def isConnected ( self ) : <EOL> isConnected = self . socket != None <EOL> return isConnected <EOL> def connect ( self ) : <EOL> try : <EOL> host = \"<STR_LIT:localhost>\" <EOL> port = <NUM_LIT> <EOL> log ( ) . info ( \"<STR_LIT>\" % ( host , port ) ) <EOL> tmpSocket = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> tmpSocket . connect ( ( host , port ) ) <EOL> except OSError : <EOL> log ( ) . info ( \"<STR_LIT>\" % ( host , port ) ) <EOL> tmpSocket . close ( ) <EOL> return <EOL> self . socket = tmpSocket <EOL> self . startPullMessages ( ) <EOL> self . startSendMessages ( ) <EOL> self . on_connect ( ) <EOL> log ( ) . info ( \"<STR_LIT>\" ) <EOL> def send ( self , type , msg ) : <EOL> if not self . isConnected ( ) : <EOL> self . on_not_connected ( ) <EOL> if not self . isConnected ( ) : <EOL> return <EOL> self . sendQueue . put ( ( type , msg ) , True ) <EOL> self . sendDataEvent . set ( ) <EOL> def startSendMessages ( self ) : <EOL> self . sendDataEvent = threading . Event ( ) <EOL> self . sendWorkerStopEvent = threading . Event ( ) <EOL> self . sendWorker = threading . Thread ( target = self . sendMessages ) <EOL> self . sendWorker . daemon = True <EOL> self . sendWorker . start ( ) <EOL> def sendMessages ( self ) : <EOL> try : <EOL> while not self . sendWorkerStopEvent . is_set ( ) : <EOL> while not self . sendQueue . empty ( ) : <EOL> msgTupple = self . sendQueue . get_nowait ( ) <EOL> type = msgTupple [ <NUM_LIT:0> ] <EOL> msg = msgTupple [ <NUM_LIT:1> ] <EOL> msgInBytes = bytes ( type + \"<STR_LIT:\\n>\" + str ( len ( msg ) ) + \"<STR_LIT:\\n>\" + msg , \"<STR_LIT>\" ) <EOL> self . socket . sendall ( msgInBytes ) <EOL> self . sendDataEvent . wait ( ) <EOL> self . sendDataEvent . clear ( ) <EOL> except : <EOL> self . disconnect ( ) <EOL> def stopSendMessages ( self ) : <EOL> self . sendWorkerStopEvent . set ( ) <EOL> self . sendDataEvent . set ( ) <EOL> def startPullMessages ( self ) : <EOL> self . readWorkerStopEvent = threading . Event ( ) <EOL> self . readWorker = threading . Thread ( target = self . pullMessages ) <EOL> self . readWorker . daemon = True <EOL> self . readWorker . start ( ) <EOL> def stopPullMessages ( self ) : <EOL>", "answer": "self . readWorkerStopEvent . set ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL> from __future__ import print_function <EOL> import os <EOL> import click <EOL> import traceback <EOL> from types import GeneratorType <EOL> from prompt_toolkit import AbortAction <EOL> from prompt_toolkit import Application <EOL> from prompt_toolkit import CommandLineInterface <EOL> from prompt_toolkit . enums import DEFAULT_BUFFER <EOL> from prompt_toolkit . filters import Always , HasFocus , IsDone <EOL> from prompt_toolkit . layout . processors import HighlightMatchingBracketProcessor , ConditionalProcessor <EOL> from prompt_toolkit . buffer import Buffer <EOL> from prompt_toolkit . interface import AcceptAction <EOL> from prompt_toolkit . shortcuts import create_prompt_layout <EOL> from prompt_toolkit . shortcuts import create_eventloop <EOL> from prompt_toolkit . history import FileHistory <EOL> from . client import DockerClient <EOL> from . client import DockerPermissionException <EOL> from . client import DockerTimeoutException <EOL> from . client import DockerSslException <EOL> from . completer import DockerCompleter <EOL> from . lexer import CommandLexer <EOL> from . formatter import format_data <EOL> from . formatter import output_stream <EOL> from . config import write_default_config , read_config <EOL> from . style import style_factory <EOL> from . keys import get_key_manager <EOL> from . toolbar import create_toolbar_handler <EOL> from . options import OptionError <EOL> from . logger import create_logger <EOL> from . __init__ import __version__ <EOL> click . disable_unicode_literals_warning = True <EOL> class WharfeeCli ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dcli = None <EOL> keyword_completer = None <EOL> handler = None <EOL> saved_less_opts = None <EOL> config = None <EOL> config_template = '<STR_LIT>' <EOL> config_name = '<STR_LIT>' <EOL> def __init__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . config = self . read_configuration ( ) <EOL> self . theme = self . config [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> log_file = self . config [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> log_level = self . config [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> self . logger = create_logger ( __name__ , log_file , log_level ) <EOL> self . handler = DockerClient ( <EOL> self . config [ '<STR_LIT>' ] . as_int ( '<STR_LIT>' ) , <EOL> self . clear , <EOL> self . set_completer_options ) <EOL> self . completer = DockerCompleter ( <EOL> long_option_names = self . get_long_options ( ) , <EOL> fuzzy = self . get_fuzzy_match ( ) ) <EOL> self . set_completer_options ( ) <EOL> self . saved_less_opts = self . set_less_opts ( ) <EOL> def read_configuration ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> default_config = os . path . join ( <EOL> self . get_package_path ( ) , self . config_template ) <EOL> write_default_config ( default_config , self . config_name ) <EOL> return read_config ( self . config_name , default_config ) <EOL> def get_package_path ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from wharfee import __file__ as package_root <EOL> return os . path . dirname ( package_root ) <EOL> def set_less_opts ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> opts = os . environ . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> os . environ [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> return opts <EOL> def revert_less_opts ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> os . environ [ '<STR_LIT>' ] = self . saved_less_opts <EOL> def write_config_file ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . config . write ( ) <EOL> def clear ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> click . clear ( ) <EOL> def set_completer_options ( self , cons = True , runs = True , imgs = True , vols = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if cons : <EOL> cs = self . handler . containers ( all = True ) <EOL> if cs and len ( cs ) > <NUM_LIT:0> and isinstance ( cs [ <NUM_LIT:0> ] , dict ) : <EOL> containers = [ name for c in cs for name in c [ '<STR_LIT>' ] ] <EOL> self . completer . set_containers ( containers ) <EOL> if runs : <EOL> cs = self . handler . containers ( ) <EOL> if cs and len ( cs ) > <NUM_LIT:0> and isinstance ( cs [ <NUM_LIT:0> ] , dict ) : <EOL> running = [ name for c in cs for name in c [ '<STR_LIT>' ] ] <EOL> self . completer . set_running ( running ) <EOL> if imgs : <EOL> def format_tagged ( tagname , img_id ) : <EOL> if tagname == '<STR_LIT>' : <EOL> return img_id [ : <NUM_LIT:11> ] <EOL> return tagname <EOL> def parse_image_name ( tag , img_id ) : <EOL> if '<STR_LIT::>' in tag : <EOL> result = tag . split ( '<STR_LIT::>' , <NUM_LIT:2> ) [ <NUM_LIT:0> ] <EOL> else : <EOL> result = tag <EOL> if result == '<STR_LIT>' : <EOL> result = img_id [ : <NUM_LIT:11> ] <EOL> return result <EOL> ims = self . handler . images ( ) <EOL> if ims and len ( ims ) > <NUM_LIT:0> and isinstance ( ims [ <NUM_LIT:0> ] , dict ) : <EOL> images = set ( [ ] ) <EOL> tagged = set ( [ ] ) <EOL> for im in ims : <EOL> repo_tag = '<STR_LIT>' . format ( im [ '<STR_LIT>' ] , im [ '<STR_LIT>' ] ) <EOL> images . add ( parse_image_name ( repo_tag , im [ '<STR_LIT>' ] ) ) <EOL> tagged . add ( format_tagged ( repo_tag , im [ '<STR_LIT>' ] ) ) <EOL> self . completer . set_images ( images ) <EOL> self . completer . set_tagged ( tagged ) <EOL> if vols : <EOL> vs = self . handler . volume_ls ( quiet = True ) <EOL> self . completer . set_volumes ( vs ) <EOL> def set_fuzzy_match ( self , is_fuzzy ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . config [ '<STR_LIT>' ] [ '<STR_LIT>' ] = is_fuzzy <EOL> self . completer . set_fuzzy_match ( is_fuzzy ) <EOL> def get_fuzzy_match ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . config [ '<STR_LIT>' ] . as_bool ( '<STR_LIT>' ) <EOL> def set_long_options ( self , is_long ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . config [ '<STR_LIT>' ] [ '<STR_LIT>' ] = is_long <EOL> self . completer . set_long_options ( is_long ) <EOL> def get_long_options ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . config [ '<STR_LIT>' ] . as_bool ( '<STR_LIT>' ) <EOL> def refresh_completions ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . set_completer_options ( self . handler . is_refresh_containers , <EOL> self . handler . is_refresh_running , <EOL> self . handler . is_refresh_images , <EOL> self . handler . is_refresh_volumes ) <EOL> def run_cli ( self ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL> from scraper . scraper_test import ScraperTest <EOL> class ModelTest ( ScraperTest ) : <EOL> def test_scraper_get_scrape_elems ( self ) : <EOL> self . assertEqual ( len ( self . scraper . get_scrape_elems ( ) ) , <NUM_LIT:4> ) <EOL> def test_scraper_get_mandatory_scrape_elems ( self ) : <EOL>", "answer": "self . assertEqual ( len ( self . scraper . get_mandatory_scrape_elems ( ) ) , <NUM_LIT:3> ) "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> __all__ = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import pytest <EOL> raise SystemExit ( pytest . main ( ) ) <EOL>", "answer": "from _pytest . config import ("}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . _version import get_versions <EOL>", "answer": "__version__ = get_versions ( ) [ '<STR_LIT:version>' ]"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> revision = '<STR_LIT>' <EOL> down_revision = '<STR_LIT>' <EOL> from alembic import op <EOL> def upgrade ( ) : <EOL>", "answer": "op . create_index ( op . f ( '<STR_LIT>' ) ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os . path <EOL> from django . conf import settings <EOL> from django . test import TransactionTestCase <EOL> from panda import solr <EOL> from panda . exceptions import DataUploadNotDeletable <EOL>", "answer": "from panda . models import Dataset , DataUpload"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> def f ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print \"<STR_LIT:f>\" <EOL> return <NUM_LIT:2> <EOL> print f . __call__ ( ) <EOL> print f . __doc__ <EOL> print f . func_doc <EOL> def g ( ) : <EOL> print \"<STR_LIT:g>\" <EOL> return <NUM_LIT:3> <EOL> print g . __doc__ <EOL> print type ( f ) . __call__ ( f ) <EOL> print type ( f ) . __call__ ( g ) <EOL> print f . __name__ , f . func_name <EOL> f . __name__ = \"<STR_LIT>\" <EOL> print f . __name__ , f . func_name <EOL> f . func_name = \"<STR_LIT:f>\" <EOL> print f . __name__ , f . func_name <EOL> print bool ( f ) <EOL> def func_with_defaults ( a , b = <NUM_LIT:1> ) : <EOL> print a , b <EOL> func_with_defaults ( <NUM_LIT:0> ) <EOL> print type ( func_with_defaults . func_code ) <EOL> print func_with_defaults . func_defaults <EOL> print func_with_defaults . __defaults__ <EOL> try : <EOL> func_with_defaults . func_defaults = [ <NUM_LIT:2> ] <EOL> except TypeError as e : <EOL> print e <EOL> def func_without_defaults ( ) : <EOL> pass <EOL> print repr ( func_without_defaults . __defaults__ ) <EOL>", "answer": "print func_without_defaults . func_globals == globals ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pygraph . classes . digraph import digraph <EOL> from pygraph . classes . exceptions import InvalidGraphType <EOL> from pygraph . classes . graph import graph <EOL> from pygraph . classes . hypergraph import hypergraph <EOL> from xml . dom . minidom import Document , parseString <EOL> def write ( G ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> grxml = Document ( ) <EOL> if ( type ( G ) == graph ) : <EOL> grxmlr = grxml . createElement ( '<STR_LIT>' ) <EOL> elif ( type ( G ) == digraph ) : <EOL> grxmlr = grxml . createElement ( '<STR_LIT>' ) <EOL> elif ( type ( G ) == hypergraph ) : <EOL> return write_hypergraph ( G ) <EOL> else : <EOL> raise InvalidGraphType <EOL> grxml . appendChild ( grxmlr ) <EOL> for each_node in G . nodes ( ) : <EOL> node = grxml . createElement ( '<STR_LIT>' ) <EOL> node . setAttribute ( '<STR_LIT:id>' , str ( each_node ) ) <EOL> grxmlr . appendChild ( node ) <EOL> for each_attr in G . node_attributes ( each_node ) : <EOL> attr = grxml . createElement ( '<STR_LIT>' ) <EOL> attr . setAttribute ( '<STR_LIT>' , each_attr [ <NUM_LIT:0> ] ) <EOL> attr . setAttribute ( '<STR_LIT:value>' , each_attr [ <NUM_LIT:1> ] ) <EOL> node . appendChild ( attr ) <EOL> for edge_from , edge_to in G . edges ( ) : <EOL> edge = grxml . createElement ( '<STR_LIT>' ) <EOL> edge . setAttribute ( '<STR_LIT>' , str ( edge_from ) ) <EOL> edge . setAttribute ( '<STR_LIT:to>' , str ( edge_to ) ) <EOL> edge . setAttribute ( '<STR_LIT>' , str ( G . edge_weight ( ( edge_from , edge_to ) ) ) ) <EOL> edge . setAttribute ( '<STR_LIT:label>' , str ( G . edge_label ( ( edge_from , edge_to ) ) ) ) <EOL> grxmlr . appendChild ( edge ) <EOL> for attr_name , attr_value in G . edge_attributes ( ( edge_from , edge_to ) ) : <EOL> attr = grxml . createElement ( '<STR_LIT>' ) <EOL> attr . setAttribute ( '<STR_LIT>' , attr_name ) <EOL> attr . setAttribute ( '<STR_LIT:value>' , attr_value ) <EOL> edge . appendChild ( attr ) <EOL> return grxml . toprettyxml ( ) <EOL> def read ( string ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dom = parseString ( string ) <EOL> if dom . getElementsByTagName ( \"<STR_LIT>\" ) : <EOL> G = graph ( ) <EOL> elif dom . getElementsByTagName ( \"<STR_LIT>\" ) : <EOL> G = digraph ( ) <EOL> elif dom . getElementsByTagName ( \"<STR_LIT>\" ) : <EOL> return read_hypergraph ( string ) <EOL> else : <EOL> raise InvalidGraphType <EOL> for each_node in dom . getElementsByTagName ( \"<STR_LIT>\" ) : <EOL> G . add_node ( each_node . getAttribute ( '<STR_LIT:id>' ) ) <EOL> for each_attr in each_node . getElementsByTagName ( \"<STR_LIT>\" ) : <EOL> G . add_node_attribute ( each_node . getAttribute ( '<STR_LIT:id>' ) , <EOL> ( each_attr . getAttribute ( '<STR_LIT>' ) , <EOL> each_attr . getAttribute ( '<STR_LIT:value>' ) ) ) <EOL> for each_edge in dom . getElementsByTagName ( \"<STR_LIT>\" ) : <EOL> if ( not G . has_edge ( ( each_edge . getAttribute ( '<STR_LIT>' ) , each_edge . getAttribute ( '<STR_LIT:to>' ) ) ) ) : <EOL> G . add_edge ( ( each_edge . getAttribute ( '<STR_LIT>' ) , each_edge . getAttribute ( '<STR_LIT:to>' ) ) , wt = float ( each_edge . getAttribute ( '<STR_LIT>' ) ) , label = each_edge . getAttribute ( '<STR_LIT:label>' ) ) <EOL> for each_attr in each_edge . getElementsByTagName ( \"<STR_LIT>\" ) : <EOL> attr_tuple = ( each_attr . getAttribute ( '<STR_LIT>' ) , each_attr . getAttribute ( '<STR_LIT:value>' ) ) <EOL> if ( attr_tuple not in G . edge_attributes ( ( each_edge . getAttribute ( '<STR_LIT>' ) , each_edge . getAttribute ( '<STR_LIT:to>' ) ) ) ) : <EOL> G . add_edge_attribute ( ( each_edge . getAttribute ( '<STR_LIT>' ) , each_edge . getAttribute ( '<STR_LIT:to>' ) ) , attr_tuple ) <EOL> return G <EOL> def write_hypergraph ( hgr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> grxml = Document ( ) <EOL> grxmlr = grxml . createElement ( '<STR_LIT>' ) <EOL> grxml . appendChild ( grxmlr ) <EOL> nodes = hgr . nodes ( ) <EOL> hyperedges = hgr . hyperedges ( ) <EOL> for each_node in ( nodes + hyperedges ) : <EOL> if ( each_node in nodes ) : <EOL> node = grxml . createElement ( '<STR_LIT>' ) <EOL> else : <EOL> node = grxml . createElement ( '<STR_LIT>' ) <EOL> node . setAttribute ( '<STR_LIT:id>' , str ( each_node ) ) <EOL> grxmlr . appendChild ( node ) <EOL> if each_node in nodes : <EOL> for each_edge in hgr . links ( each_node ) : <EOL> edge = grxml . createElement ( '<STR_LIT>' ) <EOL> edge . setAttribute ( '<STR_LIT:to>' , str ( each_edge ) ) <EOL> node . appendChild ( edge ) <EOL> return grxml . toprettyxml ( ) <EOL> def read_hypergraph ( string ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> hgr = hypergraph ( ) <EOL> dom = parseString ( string ) <EOL> for each_node in dom . getElementsByTagName ( \"<STR_LIT>\" ) : <EOL> hgr . add_node ( each_node . getAttribute ( '<STR_LIT:id>' ) ) <EOL> for each_node in dom . getElementsByTagName ( \"<STR_LIT>\" ) : <EOL> hgr . add_hyperedge ( each_node . getAttribute ( '<STR_LIT:id>' ) ) <EOL>", "answer": "dom = parseString ( string )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> __author__ = '<STR_LIT>' <EOL> from pypet import Environment , Trajectory <EOL> from pypet . tests . testutils . ioutils import make_temp_dir , get_log_config <EOL> import os <EOL> import matplotlib . pyplot as plt <EOL> import numpy as np <EOL> import time <EOL> def job ( traj ) : <EOL> traj . f_ares ( '<STR_LIT>' , <NUM_LIT> , comment = '<STR_LIT>' ) <EOL> def get_runtime ( length ) : <EOL> filename = os . path . join ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> with Environment ( filename = filename , <EOL> log_levels = <NUM_LIT:50> , report_progress = ( <NUM_LIT> , '<STR_LIT>' , <NUM_LIT:50> ) , <EOL> overwrite_file = True , purge_duplicate_comments = False , <EOL> log_stdout = False , <EOL> multiproc = False , ncores = <NUM_LIT:2> , use_pool = True , <EOL> wrap_mode = '<STR_LIT>' , <EOL> summary_tables = False , small_overview_tables = False ) as env : <EOL> traj = env . v_traj <EOL> traj . par . f_apar ( '<STR_LIT:x>' , <NUM_LIT:0> , '<STR_LIT>' ) <EOL> traj . f_explore ( { '<STR_LIT:x>' : range ( length ) } ) <EOL> max_run = <NUM_LIT:1000> <EOL> for idx in range ( len ( traj ) ) : <EOL>", "answer": "if idx > max_run :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from __future__ import division <EOL> from __future__ import print_function <EOL>", "answer": "import phlsys_subprocess"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from south . utils import datetime_utils as datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . create_table ( u'<STR_LIT>' , ( <EOL> ( u'<STR_LIT:id>' , self . gf ( '<STR_LIT>' ) ( primary_key = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = datetime . datetime . now , blank = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = datetime . datetime . now , blank = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( to = orm [ '<STR_LIT>' ] ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( to = orm [ '<STR_LIT>' ] ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = <NUM_LIT:0> ) ) , <EOL> ) ) <EOL> db . send_create_signal ( u'<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> def backwards ( self , orm ) : <EOL> db . delete_table ( u'<STR_LIT>' ) <EOL> models = { <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : u\"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : u\"<STR_LIT>\" } ) , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) <EOL> } , <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:{}>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : u\"<STR_LIT>\" } ) , <EOL> '<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:to>' : u\"<STR_LIT>\" } ) , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:password>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:to>' : u\"<STR_LIT>\" } ) , <EOL> '<STR_LIT:username>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL>", "answer": "u'<STR_LIT>' : {"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import pyb <EOL> led = pyb . LED ( <NUM_LIT:1> ) <EOL> def blink_millis ( ) : <EOL> start = pyb . millis ( ) <EOL> led . on ( ) <EOL> while pyb . elapsed_millis ( start ) < <NUM_LIT:100> : <EOL> pass <EOL> led . off ( ) <EOL> while pyb . elapsed_millis ( start ) < <NUM_LIT:200> : <EOL> pass <EOL> led . on ( ) <EOL> while pyb . elapsed_millis ( start ) < <NUM_LIT> : <EOL> pass <EOL> led . off ( ) <EOL> while pyb . elapsed_millis ( start ) < <NUM_LIT:1000> : <EOL>", "answer": "pass"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . conf . urls import patterns , url , include <EOL> from haystack . views import search_view_factory , SearchView <EOL> from offers . feeds import OfferFeed , OfferAtomFeed <EOL> from offers . forms import OfferSearchForm <EOL> from . import views as offer_views <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , search_view_factory ( <EOL> view_class = SearchView , <EOL> form_class = OfferSearchForm , <EOL> template = '<STR_LIT>' , <EOL> results_per_page = <NUM_LIT:8> , <EOL> ) , <EOL> name = '<STR_LIT>' , <EOL> ) , <EOL> url ( r'<STR_LIT>' , OfferFeed ( ) , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , OfferAtomFeed ( ) , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> url ( <EOL> r'<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> name = \"<STR_LIT>\" <EOL> ) , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL>", "answer": "url ( r'<STR_LIT>' , '<STR_LIT>' , name = \"<STR_LIT>\" ) ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import division , print_function , unicode_literals <EOL> import os <EOL> assert os . environ [ '<STR_LIT>' ] <EOL> import sys <EOL> sys . path . insert ( <NUM_LIT:0> , '<STR_LIT>' ) <EOL> import pyglet <EOL> assert pyglet . mock_level == <NUM_LIT:1> <EOL> from cocos . director import director <EOL> from cocos . cocosnode import CocosNode <EOL> import cocos . actions as ac <EOL> fe = <NUM_LIT> <EOL> director . init ( ) <EOL> def pytest_generate_tests ( metafunc ) : <EOL> param_names = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> values = [ ( <NUM_LIT:0.0> , <NUM_LIT:0.0> ) , <EOL> ( <NUM_LIT:0.0> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT:0.0> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) <EOL> ] <EOL> scenarios = { } <EOL> for v in values : <EOL> name = '<STR_LIT:U+0020>' . join ( [ '<STR_LIT:%s>' % e for e in v ] ) <EOL> scenarios [ name ] = dict ( zip ( param_names , v ) ) <EOL> for k in scenarios : <EOL> metafunc . addcall ( id = k , funcargs = scenarios [ k ] ) <EOL> rec = [ ] <EOL> class UIntervalAction ( ac . IntervalAction ) : <EOL> def init ( self , name , duration ) : <EOL> rec . append ( ( name , '<STR_LIT>' ) ) <EOL> self . duration = duration <EOL> self . name = name <EOL> def start ( self ) : <EOL> rec . append ( ( self . name , '<STR_LIT:start>' ) ) <EOL> def step ( self , dt ) : <EOL> rec . append ( ( self . name , '<STR_LIT>' , dt ) ) <EOL> super ( UIntervalAction , self ) . step ( dt ) <EOL> def update ( self , fraction ) : <EOL> rec . append ( ( self . name , '<STR_LIT>' , fraction ) ) <EOL> def stop ( self ) : <EOL> rec . append ( ( self . name , '<STR_LIT>' ) ) <EOL> class Test_Sequence_IntervalAction : <EOL> def test_instantiation ( self , duration1 , duration2 ) : <EOL> global rec <EOL> name1 = '<STR_LIT:1>' <EOL> name2 = '<STR_LIT:2>' <EOL> a1 = UIntervalAction ( name1 , duration1 ) <EOL> assert isinstance ( a1 , ac . IntervalAction ) <EOL> assert a1 . duration == duration1 <EOL> a2 = UIntervalAction ( name2 , duration2 ) <EOL> rec = [ ] <EOL> composite = ac . sequence ( a1 , a2 ) <EOL> assert isinstance ( composite , ac . IntervalAction ) <EOL> assert composite . duration == ( duration1 + duration2 ) <EOL> assert len ( rec ) == <NUM_LIT:0> <EOL> def test_start ( self , duration1 , duration2 ) : <EOL> global rec <EOL> node = CocosNode ( ) <EOL> name1 = '<STR_LIT:1>' <EOL> name2 = '<STR_LIT:2>' <EOL> a1 = UIntervalAction ( name1 , duration1 ) <EOL> a2 = UIntervalAction ( name2 , duration2 ) <EOL> composite = ac . sequence ( a1 , a2 ) <EOL> rec = [ ] <EOL> node . do ( composite ) <EOL> print ( '<STR_LIT>' , rec ) <EOL> num = <NUM_LIT:0> <EOL> assert rec [ num ] == ( name1 , '<STR_LIT:start>' ) <EOL> if duration1 == <NUM_LIT:0.0> : <EOL> assert rec [ num + <NUM_LIT:1> ] == ( name1 , '<STR_LIT>' , <NUM_LIT:1.0> ) <EOL> assert rec [ num + <NUM_LIT:2> ] == ( name1 , '<STR_LIT>' ) <EOL> assert rec [ num + <NUM_LIT:3> ] == ( name2 , '<STR_LIT:start>' ) <EOL> num = num + <NUM_LIT:3> <EOL> assert len ( rec ) == num + <NUM_LIT:1> <EOL> def test_target_set ( self , duration1 , duration2 ) : <EOL> global rec , next_done <EOL> next_done = <NUM_LIT:0> <EOL> node = CocosNode ( ) <EOL> name1 = '<STR_LIT:1>' <EOL> name2 = '<STR_LIT:2>' <EOL> a1 = UIntervalAction ( name1 , duration1 ) <EOL> a2 = UIntervalAction ( name2 , duration2 ) <EOL> composite = ac . sequence ( a1 , a2 ) <EOL> rec = [ ] <EOL> a_copy = node . do ( composite ) <EOL> assert a_copy . one . target == node <EOL> assert a_copy . two . target == node <EOL> def test_update_below_duration1 ( self , duration1 , duration2 ) : <EOL> global rec <EOL> if duration1 == <NUM_LIT:0.0> : <EOL> return <EOL> node = CocosNode ( ) <EOL> name1 = '<STR_LIT:1>' <EOL> name2 = '<STR_LIT:2>' <EOL> a1 = UIntervalAction ( name1 , duration1 ) <EOL> a2 = UIntervalAction ( name2 , duration2 ) <EOL> composite = ac . sequence ( a1 , a2 ) <EOL> node . do ( composite ) <EOL> elapsed = <NUM_LIT:0.0> <EOL> for next_elapsed in [ duration1 * <NUM_LIT:0.5> , duration1 * <NUM_LIT> ] : <EOL> dt = next_elapsed - elapsed <EOL> rec = [ ] <EOL> node . _step ( dt ) <EOL> rec = [ e for e in rec if e [ <NUM_LIT:1> ] != '<STR_LIT>' ] <EOL> print ( rec ) <EOL> assert rec [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] == '<STR_LIT>' and abs ( rec [ <NUM_LIT:0> ] [ <NUM_LIT:2> ] - next_elapsed / duration1 ) < fe <EOL> assert len ( rec ) == <NUM_LIT:1> <EOL> elapsed = next_elapsed <EOL> def test_update_crossing_duration1_not_duration_at_1st_step ( self , duration1 , duration2 ) : <EOL> global rec <EOL> if duration2 == <NUM_LIT:0.0> : <EOL> return <EOL> node = CocosNode ( ) <EOL> name1 = '<STR_LIT:1>' <EOL> name2 = '<STR_LIT:2>' <EOL> a1 = UIntervalAction ( name1 , duration1 ) <EOL> a2 = UIntervalAction ( name2 , duration2 ) <EOL> composite = ac . sequence ( a1 , a2 ) <EOL> rec = [ ] <EOL> node . do ( composite ) <EOL> elapsed = <NUM_LIT:0.0> <EOL> next_elapsed = ( duration1 + duration2 ) / <NUM_LIT> <EOL> dt = next_elapsed - elapsed <EOL> node . _step ( dt ) <EOL> recx = [ e for e in rec if e [ <NUM_LIT:1> ] != '<STR_LIT>' ] <EOL> rec = [ e for e in recx if e [ <NUM_LIT:0> ] == name1 ] <EOL> print ( '<STR_LIT>' , rec ) <EOL> assert rec [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] == '<STR_LIT:start>' <EOL> assert rec [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] == '<STR_LIT>' and rec [ <NUM_LIT:1> ] [ <NUM_LIT:2> ] == <NUM_LIT:1.0> <EOL> assert rec [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] == '<STR_LIT>' <EOL> assert len ( rec ) == <NUM_LIT:3> <EOL> rec = [ e for e in recx if e [ <NUM_LIT:0> ] == name2 ] <EOL> print ( '<STR_LIT>' , rec ) <EOL> assert rec [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] == '<STR_LIT:start>' <EOL> assert rec [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] == '<STR_LIT>' <EOL> assert abs ( rec [ <NUM_LIT:1> ] [ <NUM_LIT:2> ] - ( next_elapsed - duration1 ) / duration2 ) < fe <EOL> assert len ( rec ) == <NUM_LIT:2> <EOL> def test_update_crossing_duration1_not_duration_not_at_1st_step ( self , duration1 , duration2 ) : <EOL> global rec <EOL> if duration1 == <NUM_LIT:0.0> or duration2 == <NUM_LIT:0.0> : <EOL> return <EOL> node = CocosNode ( ) <EOL> name1 = '<STR_LIT:1>' <EOL> name2 = '<STR_LIT:2>' <EOL> a1 = UIntervalAction ( name1 , duration1 ) <EOL> a2 = UIntervalAction ( name2 , duration2 ) <EOL> composite = ac . sequence ( a1 , a2 ) <EOL> rec = [ ] <EOL> node . do ( composite ) <EOL> elapsed = <NUM_LIT:0.0> <EOL> next_elapsed = duration1 / <NUM_LIT> <EOL> dt = next_elapsed - elapsed <EOL> node . _step ( dt ) <EOL> elapsed = next_elapsed <EOL> next_elapsed = ( duration1 + duration2 ) / <NUM_LIT> <EOL> dt = next_elapsed - elapsed <EOL> rec = [ ] <EOL> node . _step ( dt ) <EOL> recx = [ e for e in rec if e [ <NUM_LIT:1> ] != '<STR_LIT>' ] <EOL> rec = [ e for e in recx if e [ <NUM_LIT:0> ] == name1 ] <EOL> print ( '<STR_LIT>' , rec ) <EOL> assert rec [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] == '<STR_LIT>' and rec [ <NUM_LIT:0> ] [ <NUM_LIT:2> ] == <NUM_LIT:1.0> <EOL> assert rec [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] == '<STR_LIT>' <EOL> assert len ( rec ) == <NUM_LIT:2> <EOL> rec = [ e for e in recx if e [ <NUM_LIT:0> ] == name2 ] <EOL> print ( '<STR_LIT>' , rec ) <EOL> assert rec [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] == '<STR_LIT:start>' <EOL> assert rec [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] == '<STR_LIT>' <EOL> assert abs ( rec [ <NUM_LIT:1> ] [ <NUM_LIT:2> ] - ( next_elapsed - duration1 ) / duration2 ) < fe <EOL> assert len ( rec ) == <NUM_LIT:2> <EOL> def test_updating_above_duration1_below_duration ( self , duration1 , duration2 ) : <EOL> global rec <EOL> if duration2 == <NUM_LIT:0.0> : <EOL> return <EOL> node = CocosNode ( ) <EOL> name1 = '<STR_LIT:1>' <EOL> name2 = '<STR_LIT:2>' <EOL> a1 = UIntervalAction ( name1 , duration1 ) <EOL> a2 = UIntervalAction ( name2 , duration2 ) <EOL> composite = ac . sequence ( a1 , a2 ) <EOL> node . do ( composite ) <EOL> elapsed = <NUM_LIT:0.0> <EOL> next_elapsed = ( duration1 + duration2 ) / <NUM_LIT> <EOL> dt = next_elapsed - elapsed <EOL> node . _step ( dt ) <EOL> elapsed = next_elapsed <EOL> next_elapsed = ( next_elapsed + composite . duration ) / <NUM_LIT> <EOL> dt = next_elapsed - elapsed <EOL> rec = [ ] <EOL> node . _step ( dt ) <EOL> assert len ( [ e for e in rec if e [ <NUM_LIT:0> ] == name1 ] ) == <NUM_LIT:0> <EOL> rec = [ e for e in rec if e [ <NUM_LIT:1> ] != '<STR_LIT>' ] <EOL> print ( rec ) <EOL> assert rec [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] == '<STR_LIT>' <EOL> assert abs ( rec [ <NUM_LIT:0> ] [ <NUM_LIT:2> ] - ( next_elapsed - duration1 ) / duration2 ) < fe <EOL> assert len ( rec ) == <NUM_LIT:1> <EOL> def test_update_crossing_total_duration_at_1st_step ( self , duration1 , duration2 ) : <EOL> global rec <EOL> node = CocosNode ( ) <EOL> name1 = '<STR_LIT:1>' <EOL> name2 = '<STR_LIT:2>' <EOL> a1 = UIntervalAction ( name1 , duration1 ) <EOL> a2 = UIntervalAction ( name2 , duration2 ) <EOL> elapsed = <NUM_LIT:0.0> <EOL> rec = [ ] <EOL> composite = ac . sequence ( a1 , a2 ) <EOL> node . do ( composite ) <EOL> next_elapsed = duration1 + duration2 + fe <EOL> dt = next_elapsed - elapsed <EOL> node . _step ( dt ) <EOL> recx = [ e for e in rec if e [ <NUM_LIT:1> ] != '<STR_LIT>' ] <EOL> rec = [ e for e in recx if e [ <NUM_LIT:0> ] == name1 ] <EOL> print ( '<STR_LIT>' , rec ) <EOL> assert len ( rec ) == <NUM_LIT:3> <EOL> assert rec [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] == '<STR_LIT:start>' <EOL> assert rec [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] == '<STR_LIT>' and rec [ <NUM_LIT:1> ] [ <NUM_LIT:2> ] == <NUM_LIT:1.0> <EOL> assert rec [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] == '<STR_LIT>' <EOL> rec = [ e for e in recx if e [ <NUM_LIT:0> ] == name2 ] <EOL> print ( '<STR_LIT>' , rec ) <EOL> assert len ( rec ) == <NUM_LIT:3> <EOL> assert rec [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] == '<STR_LIT:start>' <EOL> assert rec [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] == '<STR_LIT>' and rec [ <NUM_LIT:1> ] [ <NUM_LIT:2> ] == <NUM_LIT:1.0> <EOL> assert rec [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] == '<STR_LIT>' <EOL> def test_test_receiving_stop_async_before_duration1 ( self , duration1 , duration2 ) : <EOL> global rec <EOL> if duration1 == <NUM_LIT:0.0> : <EOL> return <EOL> node = CocosNode ( ) <EOL> name1 = '<STR_LIT:1>' <EOL> name2 = '<STR_LIT:2>' <EOL> a1 = UIntervalAction ( name1 , duration1 ) <EOL> a2 = UIntervalAction ( name2 , duration2 ) <EOL> elapsed = <NUM_LIT:0.0> <EOL> rec = [ ] <EOL> composite = ac . sequence ( a1 , a2 ) <EOL>", "answer": "a_copy = node . do ( composite )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import warnings <EOL> from bento . compat . api import wraps <EOL> from bento . warnings import NoBentoInfoWarning <EOL> def disable_warning ( f ) : <EOL> def decorator_factory ( warning_class = UserWarning ) : <EOL> @ wraps ( f ) <EOL> def decorator ( * a , ** kw ) : <EOL> filters = warnings . filters [ : ] <EOL> warnings . simplefilter ( \"<STR_LIT:ignore>\" , warning_class ) <EOL> try : <EOL> return f ( * a , ** kw ) <EOL> finally : <EOL> warnings . filters = filters <EOL>", "answer": "return decorator"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> __author__ = \"\"\"<STR_LIT>\"\"\" <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> from os import getcwd <EOL> from os import sys <EOL> sys . path . append ( getcwd ( ) ) <EOL> from MOAL . helpers . display import Section <EOL> from MOAL . helpers . display import print_success <EOL> from MOAL . helpers . display import prnt <EOL> from MOAL . helpers . trials import run_trials <EOL>", "answer": "from MOAL . helpers . trials import test_speed"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> ROOT_URLCONF = '<STR_LIT>' <EOL> SECRET_KEY = '<STR_LIT>' <EOL> DATABASES = { <EOL> '<STR_LIT:default>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> } <EOL> INSTALLED_APPS = ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) <EOL> MIGRATION_MODULES = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> TEMPLATES = [ { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : ( <EOL> '<STR_LIT>' , <EOL> ) , <EOL>", "answer": "} ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from PyQt4 . QtCore import Qt <EOL> from PyQt4 . QtGui import QTableView , QAbstractItemView <EOL> class EditableTableView ( QTableView ) : <EOL> def keyPressEvent ( self , event ) : <EOL> if event . key ( ) == Qt . Key_Return and self . state ( ) != QAbstractItemView . EditingState : <EOL> selected = self . selectionModel ( ) . selectedIndexes ( ) <EOL>", "answer": "if selected :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import urllib <EOL> import sqlite3 <EOL> import datetime <EOL> import tweepy <EOL> from xml . dom . minidom import parseString <EOL> from settings import * <EOL> class Item : <EOL> title = \"<STR_LIT>\" <EOL> link = \"<STR_LIT>\" <EOL> class CustomUrlOpener ( urllib . FancyURLopener ) : <EOL> version = \"<STR_LIT>\" <EOL> def getFeedData ( ) : <EOL> urllib . _urlopener = CustomUrlOpener ( ) <EOL> feedRequest = urllib . urlopen ( HACKER_NEWS_RSS_URL ) <EOL> feedString = feedRequest . read ( ) <EOL> feedRequest . close ( ) <EOL> return parseString ( feedString ) <EOL> def iterateItems ( feedData ) : <EOL> results = [ ] <EOL> for element in feedData . getElementsByTagName ( \"<STR_LIT>\" ) : <EOL> item = Item ( ) <EOL> item . title = element . getElementsByTagName ( \"<STR_LIT:title>\" ) [ <NUM_LIT:0> ] . childNodes [ <NUM_LIT:0> ] . data <EOL> item . link = element . getElementsByTagName ( \"<STR_LIT>\" ) [ <NUM_LIT:0> ] . childNodes [ <NUM_LIT:0> ] . data <EOL> item . commentLink = element . getElementsByTagName ( \"<STR_LIT>\" ) [ <NUM_LIT:0> ] . childNodes [ <NUM_LIT:0> ] . data <EOL> results . append ( item ) <EOL> return results <EOL> def isSchemaThere ( conn ) : <EOL> cur = conn . cursor ( ) <EOL> cur . execute ( \"<STR_LIT>\" ) <EOL> if len ( cur . fetchall ( ) ) > <NUM_LIT:0> : <EOL> return True <EOL> return False <EOL> def createSchema ( conn ) : <EOL> cur = conn . cursor ( ) <EOL> cur . execute ( \"<STR_LIT>\" ) <EOL> def isNewLink ( item ) : <EOL> conn = sqlite3 . connect ( LOCAL_LINK_DB ) <EOL> if isSchemaThere ( conn ) == False : <EOL> createSchema ( conn ) <EOL> cur = conn . cursor ( ) <EOL> cur . execute ( \"<STR_LIT>\" , ( item . link , ) ) <EOL> isNew = len ( cur . fetchall ( ) ) == <NUM_LIT:0> <EOL> conn . commit ( ) <EOL> conn . close ( ) <EOL> return isNew <EOL> def insertLink ( item ) : <EOL> conn = sqlite3 . connect ( LOCAL_LINK_DB ) <EOL> cur = conn . cursor ( ) <EOL> cur . execute ( \"<STR_LIT>\" , ( item . title , item . link , ) ) <EOL> conn . commit ( ) <EOL> conn . close ( ) <EOL> def fixCommentLink ( link ) : <EOL> protocolEnd = <NUM_LIT:0> <EOL> if \"<STR_LIT>\" in link : <EOL> protocolEnd = link . index ( \"<STR_LIT>\" ) + len ( \"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" + link [ protocolEnd : ] <EOL> else : <EOL> return \"<STR_LIT>\" + link . lstrip ( \"<STR_LIT:/>\" ) <EOL> def getTweetText ( item ) : <EOL> maxTitleTextLength = TWITTER_MAX - ( TCO_SHORT_URL_LENGTH + len ( DIVIDER_TEXT ) ) <EOL> if item . link < > item . commentLink : <EOL> maxTitleTextLength -= ( len ( COMMENT_TEXT ) + TCO_SHORT_URL_LENGTH ) <EOL>", "answer": "tweetText = item . title . strip ( \"<STR_LIT>\" ) [ : maxTitleTextLength ] + DIVIDER_TEXT + item . link"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from copy import deepcopy <EOL> import json <EOL> import xml . etree . ElementTree as ET <EOL> from cafe . engine . models . base import AutoMarshallingModel <EOL> from cloudcafe . networking . lbaas . common . constants import Constants <EOL> class CreateHealthMonitor ( AutoMarshallingModel ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ROOT_TAG = '<STR_LIT>' <EOL> def __init__ ( self , type_ , tenant_id , delay , timeout , max_retries , <EOL>", "answer": "http_method = None , url_path = None , expected_codes = None ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = <NUM_LIT:9>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from novaclient . tests . unit . fixture_data import client <EOL> from novaclient . tests . unit . fixture_data import quotas as data <EOL> from novaclient . tests . unit import utils <EOL> from novaclient . tests . unit . v2 import fakes <EOL> class QuotaSetsTest ( utils . FixturedTestCase ) : <EOL> client_fixture_class = client . V1 <EOL>", "answer": "data_fixture_class = data . V1"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from . api import MatrixHttpApi , MatrixRequestError , MatrixUnexpectedResponse <EOL> from threading import Thread <EOL> import sys <EOL> class MatrixClient ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , base_url , token = None , valid_cert_check = True ) : <EOL> self . api = MatrixHttpApi ( base_url , token ) <EOL> self . api . validate_certificate ( valid_cert_check ) <EOL> self . listeners = [ ] <EOL> self . rooms = { <EOL> } <EOL> if token : <EOL> self . _sync ( ) <EOL> def register_with_password ( self , username , password , limit = <NUM_LIT:1> ) : <EOL> response = self . api . register ( <EOL> \"<STR_LIT>\" , user = username , password = password <EOL> ) <EOL> self . user_id = response [ \"<STR_LIT>\" ] <EOL> self . token = response [ \"<STR_LIT>\" ] <EOL> self . hs = response [ \"<STR_LIT>\" ] <EOL> self . api . token = self . token <EOL> self . _sync ( limit ) <EOL> return self . token <EOL> def login_with_password ( self , username , password , limit = <NUM_LIT:1> ) : <EOL> response = self . api . login ( <EOL> \"<STR_LIT>\" , user = username , password = password <EOL> ) <EOL> self . user_id = response [ \"<STR_LIT>\" ] <EOL> self . token = response [ \"<STR_LIT>\" ] <EOL> self . hs = response [ \"<STR_LIT>\" ] <EOL> self . api . token = self . token <EOL> self . _sync ( limit ) <EOL> return self . token <EOL> def create_room ( self , alias = None , is_public = False , invitees = ( ) ) : <EOL> response = self . api . create_room ( alias , is_public , invitees ) <EOL> return self . _mkroom ( response [ \"<STR_LIT>\" ] ) <EOL> def join_room ( self , room_id_or_alias ) : <EOL> response = self . api . join_room ( room_id_or_alias ) <EOL> room_id = ( <EOL> response [ \"<STR_LIT>\" ] if \"<STR_LIT>\" in response else room_id_or_alias <EOL> ) <EOL> return self . _mkroom ( room_id ) <EOL> def get_rooms ( self ) : <EOL> return self . rooms <EOL> def add_listener ( self , callback ) : <EOL> self . listeners . append ( callback ) <EOL> def listen_for_events ( self , timeout = <NUM_LIT> ) : <EOL> response = self . api . event_stream ( self . end , timeout ) <EOL> self . end = response [ \"<STR_LIT:end>\" ] <EOL> for chunk in response [ \"<STR_LIT>\" ] : <EOL> for listener in self . listeners : <EOL> listener ( chunk ) <EOL> if \"<STR_LIT>\" in chunk : <EOL> if chunk [ \"<STR_LIT>\" ] not in self . rooms : <EOL> self . _mkroom ( chunk [ \"<STR_LIT>\" ] ) <EOL> self . rooms [ chunk [ \"<STR_LIT>\" ] ] . events . append ( chunk ) <EOL> for listener in self . rooms [ chunk [ \"<STR_LIT>\" ] ] . listeners : <EOL> listener ( chunk ) <EOL> def listen_forever ( self , timeout = <NUM_LIT> ) : <EOL> while ( True ) : <EOL> self . listen_for_events ( timeout ) <EOL> def start_listener_thread ( self , timeout = <NUM_LIT> ) : <EOL> try : <EOL> thread = Thread ( target = self . listen_forever , args = ( timeout , ) ) <EOL> thread . daemon = True <EOL> thread . start ( ) <EOL> except : <EOL> e = sys . exc_info ( ) [ <NUM_LIT:0> ] <EOL> print ( \"<STR_LIT>\" + str ( e ) ) <EOL> def upload ( self , content , content_type ) : <EOL> try : <EOL> response = self . api . media_upload ( content , content_type ) <EOL> if \"<STR_LIT>\" in response : <EOL> return response [ \"<STR_LIT>\" ] <EOL> else : <EOL> raise MatrixUnexpectedResponse ( <EOL> \"<STR_LIT>\" <EOL> ) <EOL> except MatrixRequestError as e : <EOL> raise MatrixRequestError ( <EOL> code = e . code , <EOL> content = \"<STR_LIT>\" % e <EOL> ) <EOL> def _mkroom ( self , room_id ) : <EOL> self . rooms [ room_id ] = Room ( self , room_id ) <EOL> return self . rooms [ room_id ] <EOL> def _process_state_event ( self , state_event , current_room ) : <EOL>", "answer": "if \"<STR_LIT:type>\" not in state_event :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import copy <EOL> import uuid <EOL> import mock <EOL> import six <EOL> import yaml <EOL> from mistralclient . api . v2 import executions <EOL> from mistralclient . api . v2 import tasks <EOL> from mistralclient . api . v2 import workbooks <EOL> from mistralclient . api . v2 import workflows <EOL> from oslo_config import cfg <EOL> import st2tests . config as tests_config <EOL> tests_config . parse_args ( ) <EOL> cfg . CONF . set_override ( '<STR_LIT>' , <NUM_LIT:100> , group = '<STR_LIT>' ) <EOL> cfg . CONF . set_override ( '<STR_LIT>' , <NUM_LIT:200> , group = '<STR_LIT>' ) <EOL> cfg . CONF . set_override ( '<STR_LIT>' , <NUM_LIT:200> , group = '<STR_LIT>' ) <EOL> import st2common . bootstrap . runnersregistrar as runners_registrar <EOL> from st2actions . runners . localrunner import LocalShellRunner <EOL> from st2actions . runners . mistral . v2 import MistralRunner <EOL> from st2common . constants import action as action_constants <EOL> from st2common . models . api . action import ActionAPI <EOL> from st2common . models . db . liveaction import LiveActionDB <EOL> from st2common . persistence . action import Action <EOL> from st2common . persistence . liveaction import LiveAction <EOL> from st2common . services import action as action_service <EOL> from st2common . transport . liveaction import LiveActionPublisher <EOL> from st2common . transport . publishers import CUDPublisher <EOL> from st2tests import DbTestCase <EOL> from st2tests . fixturesloader import FixturesLoader <EOL> from tests . unit . base import MockLiveActionPublisher <EOL> TEST_FIXTURES = { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] , <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> } <EOL> PACK = '<STR_LIT>' <EOL> LOADER = FixturesLoader ( ) <EOL> FIXTURES = LOADER . load_fixtures ( fixtures_pack = PACK , fixtures_dict = TEST_FIXTURES ) <EOL> WB1_YAML_FILE_NAME = TEST_FIXTURES [ '<STR_LIT>' ] [ <NUM_LIT:1> ] <EOL> WB1_YAML_FILE_PATH = LOADER . get_fixture_file_path_abs ( PACK , '<STR_LIT>' , WB1_YAML_FILE_NAME ) <EOL> WB1_SPEC = FIXTURES [ '<STR_LIT>' ] [ WB1_YAML_FILE_NAME ] <EOL> WB1_YAML = yaml . safe_dump ( WB1_SPEC , default_flow_style = False ) <EOL> WB1_NAME = '<STR_LIT>' % ( PACK , WB1_YAML_FILE_NAME . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> WB1 = workbooks . Workbook ( None , { '<STR_LIT:name>' : WB1_NAME , '<STR_LIT>' : WB1_YAML } ) <EOL> WB1_MAIN_EXEC = { '<STR_LIT:id>' : str ( uuid . uuid4 ( ) ) , '<STR_LIT:state>' : '<STR_LIT>' } <EOL> WB1_MAIN_EXEC [ '<STR_LIT>' ] = WB1_NAME + '<STR_LIT>' <EOL> WB1_MAIN_EXEC_ERRORED = copy . deepcopy ( WB1_MAIN_EXEC ) <EOL> WB1_MAIN_EXEC_ERRORED [ '<STR_LIT:state>' ] = '<STR_LIT>' <EOL> WB1_MAIN_TASK1 = { '<STR_LIT:id>' : str ( uuid . uuid4 ( ) ) , '<STR_LIT:name>' : '<STR_LIT>' , '<STR_LIT:state>' : '<STR_LIT>' } <EOL> WB1_MAIN_TASKS = [ tasks . Task ( None , WB1_MAIN_TASK1 ) ] <EOL> WB1_MAIN_TASK_ID = WB1_MAIN_TASK1 [ '<STR_LIT:id>' ] <EOL> WB1_SUB1_EXEC = { '<STR_LIT:id>' : str ( uuid . uuid4 ( ) ) , '<STR_LIT:state>' : '<STR_LIT>' , '<STR_LIT>' : WB1_MAIN_TASK_ID } <EOL> WB1_SUB1_EXEC [ '<STR_LIT>' ] = WB1_NAME + '<STR_LIT>' <EOL> WB1_SUB1_EXEC_ERRORED = copy . deepcopy ( WB1_SUB1_EXEC ) <EOL> WB1_SUB1_EXEC_ERRORED [ '<STR_LIT:state>' ] = '<STR_LIT>' <EOL> WB1_SUB1_TASK1 = { '<STR_LIT:id>' : str ( uuid . uuid4 ( ) ) , '<STR_LIT:name>' : '<STR_LIT>' , '<STR_LIT:state>' : '<STR_LIT>' } <EOL> WB1_SUB1_TASK2 = { '<STR_LIT:id>' : str ( uuid . uuid4 ( ) ) , '<STR_LIT:name>' : '<STR_LIT>' , '<STR_LIT:state>' : '<STR_LIT>' } <EOL> WB1_SUB1_TASKS = [ tasks . Task ( None , WB1_SUB1_TASK1 ) , tasks . Task ( None , WB1_SUB1_TASK2 ) ] <EOL> WF1_YAML_FILE_NAME = TEST_FIXTURES [ '<STR_LIT>' ] [ <NUM_LIT:0> ] <EOL> WF1_YAML_FILE_PATH = LOADER . get_fixture_file_path_abs ( PACK , '<STR_LIT>' , WF1_YAML_FILE_NAME ) <EOL> WF1_SPEC = FIXTURES [ '<STR_LIT>' ] [ WF1_YAML_FILE_NAME ] <EOL> WF1_YAML = yaml . safe_dump ( WF1_SPEC , default_flow_style = False ) <EOL> WF1_NAME = '<STR_LIT>' % ( PACK , WF1_YAML_FILE_NAME . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> WF1 = workflows . Workflow ( None , { '<STR_LIT:name>' : WF1_NAME , '<STR_LIT>' : WF1_YAML } ) <EOL> WF1_EXEC = { '<STR_LIT:id>' : str ( uuid . uuid4 ( ) ) , '<STR_LIT:state>' : '<STR_LIT>' , '<STR_LIT>' : WF1_NAME } <EOL> WF1_EXEC_NOT_RERUNABLE = copy . deepcopy ( WF1_EXEC ) <EOL> WF1_EXEC_NOT_RERUNABLE [ '<STR_LIT:state>' ] = '<STR_LIT>' <EOL> WF1_TASK1 = { '<STR_LIT:id>' : str ( uuid . uuid4 ( ) ) , '<STR_LIT:name>' : '<STR_LIT>' , '<STR_LIT:state>' : '<STR_LIT>' } <EOL> WF1_TASK2 = { '<STR_LIT:id>' : str ( uuid . uuid4 ( ) ) , '<STR_LIT:name>' : '<STR_LIT>' , '<STR_LIT:state>' : '<STR_LIT>' } <EOL> WF1_TASKS = [ tasks . Task ( None , WF1_TASK1 ) , tasks . Task ( None , WF1_TASK2 ) ] <EOL> ACTION_PARAMS = { '<STR_LIT>' : '<STR_LIT>' } <EOL> NON_EMPTY_RESULT = '<STR_LIT>' <EOL> @ mock . patch . object ( LocalShellRunner , '<STR_LIT>' , mock . <EOL> MagicMock ( return_value = ( action_constants . LIVEACTION_STATUS_SUCCEEDED , <EOL> NON_EMPTY_RESULT , None ) ) ) <EOL> @ mock . patch . object ( CUDPublisher , '<STR_LIT>' , mock . MagicMock ( return_value = None ) ) <EOL> @ mock . patch . object ( CUDPublisher , '<STR_LIT>' , <EOL> mock . MagicMock ( side_effect = MockLiveActionPublisher . publish_create ) ) <EOL> @ mock . patch . object ( LiveActionPublisher , '<STR_LIT>' , <EOL> mock . MagicMock ( side_effect = MockLiveActionPublisher . publish_state ) ) <EOL> class MistralRunnerTest ( DbTestCase ) : <EOL> @ classmethod <EOL> def setUpClass ( cls ) : <EOL> super ( MistralRunnerTest , cls ) . setUpClass ( ) <EOL> runners_registrar . register_runner_types ( ) <EOL> for _ , fixture in six . iteritems ( FIXTURES [ '<STR_LIT>' ] ) : <EOL> instance = ActionAPI ( ** fixture ) <EOL> Action . add_or_update ( ActionAPI . to_model ( instance ) ) <EOL> def setUp ( self ) : <EOL> super ( MistralRunnerTest , self ) . setUp ( ) <EOL> cfg . CONF . set_override ( '<STR_LIT>' , '<STR_LIT>' , group = '<STR_LIT>' ) <EOL> @ mock . patch . object ( <EOL> workflows . WorkflowManager , '<STR_LIT:list>' , <EOL> mock . MagicMock ( return_value = [ ] ) ) <EOL> @ mock . patch . object ( <EOL> workflows . WorkflowManager , '<STR_LIT>' , <EOL> mock . MagicMock ( return_value = WF1 ) ) <EOL> @ mock . patch . object ( <EOL> workflows . WorkflowManager , '<STR_LIT>' , <EOL> mock . MagicMock ( return_value = [ WF1 ] ) ) <EOL> @ mock . patch . object ( <EOL> executions . ExecutionManager , '<STR_LIT>' , <EOL> mock . MagicMock ( return_value = executions . Execution ( None , WF1_EXEC ) ) ) <EOL> @ mock . patch . object ( <EOL> MistralRunner , '<STR_LIT>' , <EOL> mock . MagicMock ( <EOL> return_value = ( action_constants . LIVEACTION_STATUS_RUNNING , <EOL> { '<STR_LIT>' : [ ] } , <EOL> { '<STR_LIT>' : str ( uuid . uuid4 ( ) ) } ) <EOL> ) <EOL> ) <EOL> def test_resume_option ( self ) : <EOL> MistralRunner . entry_point = mock . PropertyMock ( return_value = WF1_YAML_FILE_PATH ) <EOL> liveaction1 = LiveActionDB ( action = WF1_NAME , parameters = ACTION_PARAMS ) <EOL> liveaction1 , execution1 = action_service . request ( liveaction1 ) <EOL> self . assertFalse ( MistralRunner . resume . called ) <EOL> context = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : execution1 . id , <EOL> '<STR_LIT>' : [ '<STR_LIT:x>' ] <EOL> } <EOL> } <EOL> liveaction2 = LiveActionDB ( action = WF1_NAME , parameters = ACTION_PARAMS , context = context ) <EOL> liveaction2 , execution2 = action_service . request ( liveaction2 ) <EOL> liveaction2 = LiveAction . get_by_id ( str ( liveaction2 . id ) ) <EOL> self . assertEqual ( liveaction2 . status , action_constants . LIVEACTION_STATUS_RUNNING ) <EOL> task_specs = { <EOL> '<STR_LIT:x>' : { <EOL> '<STR_LIT>' : False <EOL> } <EOL> } <EOL> MistralRunner . resume . assert_called_with ( ex_ref = execution1 , task_specs = task_specs ) <EOL> @ mock . patch . object ( <EOL> workflows . WorkflowManager , '<STR_LIT:list>' , <EOL> mock . MagicMock ( return_value = [ ] ) ) <EOL> @ mock . patch . object ( <EOL> workflows . WorkflowManager , '<STR_LIT>' , <EOL> mock . MagicMock ( return_value = WF1 ) ) <EOL> @ mock . patch . object ( <EOL> workflows . WorkflowManager , '<STR_LIT>' , <EOL> mock . MagicMock ( return_value = [ WF1 ] ) ) <EOL> @ mock . patch . object ( <EOL> executions . ExecutionManager , '<STR_LIT>' , <EOL> mock . MagicMock ( return_value = executions . Execution ( None , WF1_EXEC ) ) ) <EOL> @ mock . patch . object ( <EOL> MistralRunner , '<STR_LIT>' , <EOL> mock . MagicMock ( <EOL> return_value = ( action_constants . LIVEACTION_STATUS_RUNNING , <EOL> { '<STR_LIT>' : [ ] } , <EOL> { '<STR_LIT>' : str ( uuid . uuid4 ( ) ) } ) <EOL> ) <EOL> ) <EOL> def test_resume_option_reset_tasks ( self ) : <EOL> MistralRunner . entry_point = mock . PropertyMock ( return_value = WF1_YAML_FILE_PATH ) <EOL> liveaction1 = LiveActionDB ( action = WF1_NAME , parameters = ACTION_PARAMS ) <EOL> liveaction1 , execution1 = action_service . request ( liveaction1 ) <EOL> self . assertFalse ( MistralRunner . resume . called ) <EOL> context = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : execution1 . id , <EOL> '<STR_LIT>' : [ '<STR_LIT:x>' , '<STR_LIT:y>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT:y>' ] <EOL> } <EOL> } <EOL> liveaction2 = LiveActionDB ( action = WF1_NAME , parameters = ACTION_PARAMS , context = context ) <EOL> liveaction2 , execution2 = action_service . request ( liveaction2 ) <EOL> liveaction2 = LiveAction . get_by_id ( str ( liveaction2 . id ) ) <EOL> self . assertEqual ( liveaction2 . status , action_constants . LIVEACTION_STATUS_RUNNING ) <EOL> task_specs = { <EOL> '<STR_LIT:x>' : { <EOL> '<STR_LIT>' : False <EOL> } , <EOL> '<STR_LIT:y>' : { <EOL> '<STR_LIT>' : True <EOL> } <EOL> } <EOL> MistralRunner . resume . assert_called_with ( ex_ref = execution1 , task_specs = task_specs ) <EOL> @ mock . patch . object ( <EOL> workflows . WorkflowManager , '<STR_LIT:list>' , <EOL> mock . MagicMock ( return_value = [ ] ) ) <EOL> @ mock . patch . object ( <EOL> workflows . WorkflowManager , '<STR_LIT>' , <EOL> mock . MagicMock ( return_value = WF1 ) ) <EOL> @ mock . patch . object ( <EOL> workflows . WorkflowManager , '<STR_LIT>' , <EOL> mock . MagicMock ( return_value = [ WF1 ] ) ) <EOL> @ mock . patch . object ( <EOL> executions . ExecutionManager , '<STR_LIT>' , <EOL> mock . MagicMock ( return_value = executions . Execution ( None , WF1_EXEC_NOT_RERUNABLE ) ) ) <EOL> @ mock . patch . object ( <EOL> executions . ExecutionManager , '<STR_LIT>' , <EOL> mock . MagicMock ( return_value = executions . Execution ( None , WF1_EXEC_NOT_RERUNABLE ) ) ) <EOL> @ mock . patch . object ( <EOL> tasks . TaskManager , '<STR_LIT:list>' , <EOL> mock . MagicMock ( return_value = WF1_TASKS ) ) <EOL> def test_resume_workflow_not_in_rerunable_state ( self ) : <EOL> MistralRunner . entry_point = mock . PropertyMock ( return_value = WF1_YAML_FILE_PATH ) <EOL> liveaction1 = LiveActionDB ( action = WF1_NAME , parameters = ACTION_PARAMS ) <EOL> liveaction1 , execution1 = action_service . request ( liveaction1 ) <EOL> context = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : execution1 . id , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] <EOL> } <EOL> } <EOL> liveaction2 = LiveActionDB ( action = WF1_NAME , parameters = ACTION_PARAMS , context = context ) <EOL> liveaction2 , execution2 = action_service . request ( liveaction2 ) <EOL> liveaction2 = LiveAction . get_by_id ( str ( liveaction2 . id ) ) <EOL> self . assertEqual ( liveaction2 . status , action_constants . LIVEACTION_STATUS_FAILED ) <EOL> self . assertIn ( '<STR_LIT>' , liveaction2 . result . get ( '<STR_LIT:error>' ) ) <EOL> @ mock . patch . object ( <EOL> workflows . WorkflowManager , '<STR_LIT:list>' , <EOL>", "answer": "mock . MagicMock ( return_value = [ ] ) )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> import sys <EOL> import unittest <EOL> sys . path . append ( os . path . join ( os . path . dirname ( __file__ ) , \"<STR_LIT>\" ) ) <EOL> from conversation_table import ConversationTable <EOL> class StubConversation ( object ) : <EOL> pass <EOL> class TestConversationTable ( unittest . TestCase ) : <EOL> def test_add_get ( self ) : <EOL> table = ConversationTable ( ) <EOL> conversation = StubConversation ( ) <EOL> table . add_conversation ( \"<STR_LIT:127.0.0.1>\" , \"<STR_LIT>\" , conversation ) <EOL> self . assertEqual ( table . get_conversation ( \"<STR_LIT:127.0.0.1>\" , \"<STR_LIT>\" ) , <EOL> conversation ) <EOL> self . assertTrue ( table . lock . _RLock__count == <NUM_LIT:0> ) <EOL> def test_get_without_add ( self ) : <EOL> table = ConversationTable ( ) <EOL> self . assertIsNone ( table . get_conversation ( \"<STR_LIT:127.0.0.1>\" , \"<STR_LIT>\" ) ) <EOL> self . assertTrue ( table . lock . _RLock__count == <NUM_LIT:0> ) <EOL> def test_add_delete ( self ) : <EOL> table = ConversationTable ( ) <EOL> conversation = StubConversation ( ) <EOL>", "answer": "table . add_conversation ( \"<STR_LIT:127.0.0.1>\" , \"<STR_LIT>\" , conversation )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import tempfile <EOL> from ironic_lib import disk_utils <EOL> from ironic_lib import utils as ironic_utils <EOL> import mock <EOL> from oslo_config import cfg <EOL> from oslo_utils import fileutils <EOL> from oslo_utils import uuidutils <EOL> from ironic . common import dhcp_factory <EOL> from ironic . common import driver_factory <EOL> from ironic . common import exception <EOL> from ironic . common import keystone <EOL> from ironic . common import pxe_utils <EOL> from ironic . common import states <EOL> from ironic . common import utils <EOL> from ironic . conductor import task_manager <EOL> from ironic . conductor import utils as manager_utils <EOL> from ironic . drivers . modules import agent_base_vendor <EOL> from ironic . drivers . modules import agent_client <EOL> from ironic . drivers . modules import deploy_utils <EOL> from ironic . drivers . modules import fake <EOL> from ironic . drivers . modules import iscsi_deploy <EOL> from ironic . drivers . modules import pxe <EOL> from ironic . tests . unit . conductor import mgr_utils <EOL> from ironic . tests . unit . db import base as db_base <EOL> from ironic . tests . unit . db import utils as db_utils <EOL> from ironic . tests . unit . objects import utils as obj_utils <EOL> CONF = cfg . CONF <EOL> INST_INFO_DICT = db_utils . get_test_pxe_instance_info ( ) <EOL> DRV_INFO_DICT = db_utils . get_test_pxe_driver_info ( ) <EOL> DRV_INTERNAL_INFO_DICT = db_utils . get_test_pxe_driver_internal_info ( ) <EOL> class IscsiDeployPrivateMethodsTestCase ( db_base . DbTestCase ) : <EOL> def setUp ( self ) : <EOL> super ( IscsiDeployPrivateMethodsTestCase , self ) . setUp ( ) <EOL> n = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : INST_INFO_DICT , <EOL> '<STR_LIT>' : DRV_INFO_DICT , <EOL> '<STR_LIT>' : DRV_INTERNAL_INFO_DICT , <EOL> } <EOL> mgr_utils . mock_the_extension_manager ( driver = \"<STR_LIT>\" ) <EOL> self . node = obj_utils . create_test_node ( self . context , ** n ) <EOL> def test__save_disk_layout ( self ) : <EOL> info = dict ( INST_INFO_DICT ) <EOL> info [ '<STR_LIT>' ] = <NUM_LIT:10> <EOL> info [ '<STR_LIT>' ] = <NUM_LIT:0> <EOL> info [ '<STR_LIT>' ] = <NUM_LIT:10> <EOL> info [ '<STR_LIT>' ] = False <EOL> self . node . instance_info = info <EOL> iscsi_deploy . _save_disk_layout ( self . node , info ) <EOL> self . node . refresh ( ) <EOL> for param in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> self . assertEqual ( <EOL> info [ param ] , self . node . driver_internal_info [ '<STR_LIT>' ] [ param ] <EOL> ) <EOL> def test__get_image_dir_path ( self ) : <EOL> self . assertEqual ( os . path . join ( CONF . pxe . images_path , <EOL> self . node . uuid ) , <EOL> iscsi_deploy . _get_image_dir_path ( self . node . uuid ) ) <EOL> def test__get_image_file_path ( self ) : <EOL> self . assertEqual ( os . path . join ( CONF . pxe . images_path , <EOL> self . node . uuid , <EOL> '<STR_LIT>' ) , <EOL> iscsi_deploy . _get_image_file_path ( self . node . uuid ) ) <EOL> class IscsiDeployMethodsTestCase ( db_base . DbTestCase ) : <EOL> def setUp ( self ) : <EOL> super ( IscsiDeployMethodsTestCase , self ) . setUp ( ) <EOL> instance_info = dict ( INST_INFO_DICT ) <EOL> instance_info [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> n = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : instance_info , <EOL> '<STR_LIT>' : DRV_INFO_DICT , <EOL> '<STR_LIT>' : DRV_INTERNAL_INFO_DICT , <EOL> } <EOL> mgr_utils . mock_the_extension_manager ( driver = \"<STR_LIT>\" ) <EOL> self . node = obj_utils . create_test_node ( self . context , ** n ) <EOL> @ mock . patch . object ( disk_utils , '<STR_LIT>' , autospec = True ) <EOL> def test_check_image_size ( self , get_image_mb_mock ) : <EOL> get_image_mb_mock . return_value = <NUM_LIT:1000> <EOL> with task_manager . acquire ( self . context , self . node . uuid , <EOL> shared = False ) as task : <EOL> task . node . instance_info [ '<STR_LIT>' ] = <NUM_LIT:1> <EOL> iscsi_deploy . check_image_size ( task ) <EOL> get_image_mb_mock . assert_called_once_with ( <EOL> iscsi_deploy . _get_image_file_path ( task . node . uuid ) ) <EOL> @ mock . patch . object ( disk_utils , '<STR_LIT>' , autospec = True ) <EOL> def test_check_image_size_fails ( self , get_image_mb_mock ) : <EOL> get_image_mb_mock . return_value = <NUM_LIT> <EOL> with task_manager . acquire ( self . context , self . node . uuid , <EOL> shared = False ) as task : <EOL> task . node . instance_info [ '<STR_LIT>' ] = <NUM_LIT:1> <EOL> self . assertRaises ( exception . InstanceDeployFailure , <EOL> iscsi_deploy . check_image_size , <EOL> task ) <EOL> get_image_mb_mock . assert_called_once_with ( <EOL> iscsi_deploy . _get_image_file_path ( task . node . uuid ) ) <EOL> @ mock . patch . object ( deploy_utils , '<STR_LIT>' , autospec = True ) <EOL> def test_cache_instance_images_master_path ( self , mock_fetch_image ) : <EOL> temp_dir = tempfile . mkdtemp ( ) <EOL> self . config ( images_path = temp_dir , group = '<STR_LIT>' ) <EOL> self . config ( instance_master_path = os . path . join ( temp_dir , <EOL> '<STR_LIT>' ) , <EOL> group = '<STR_LIT>' ) <EOL> fileutils . ensure_tree ( CONF . pxe . instance_master_path ) <EOL> ( uuid , image_path ) = iscsi_deploy . cache_instance_image ( None , self . node ) <EOL> mock_fetch_image . assert_called_once_with ( None , <EOL> mock . ANY , <EOL> [ ( uuid , image_path ) ] , True ) <EOL> self . assertEqual ( '<STR_LIT>' , uuid ) <EOL> self . assertEqual ( os . path . join ( temp_dir , <EOL> self . node . uuid , <EOL> '<STR_LIT>' ) , <EOL> image_path ) <EOL> @ mock . patch . object ( ironic_utils , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( utils , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> def test_destroy_images ( self , mock_cache , mock_rmtree , mock_unlink ) : <EOL> self . config ( images_path = '<STR_LIT>' , group = '<STR_LIT>' ) <EOL> iscsi_deploy . destroy_images ( '<STR_LIT>' ) <EOL> mock_cache . return_value . clean_up . assert_called_once_with ( ) <EOL> mock_unlink . assert_called_once_with ( '<STR_LIT>' ) <EOL> mock_rmtree . assert_called_once_with ( '<STR_LIT>' ) <EOL> def _test_build_deploy_ramdisk_options ( self , mock_alnum , api_url , <EOL> expected_root_device = None , <EOL> expected_boot_option = '<STR_LIT>' , <EOL> expected_boot_mode = '<STR_LIT>' ) : <EOL> fake_key = '<STR_LIT>' <EOL> fake_disk = '<STR_LIT>' <EOL> self . config ( disk_devices = fake_disk , group = '<STR_LIT>' ) <EOL> mock_alnum . return_value = fake_key <EOL> expected_iqn = '<STR_LIT>' % self . node . uuid <EOL> expected_opts = { <EOL> '<STR_LIT>' : expected_iqn , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : self . node . uuid , <EOL> '<STR_LIT>' : fake_key , <EOL> '<STR_LIT>' : fake_disk , <EOL> '<STR_LIT>' : api_url , <EOL> '<STR_LIT>' : expected_boot_option , <EOL> '<STR_LIT>' : expected_boot_mode , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> } <EOL> if expected_root_device : <EOL> expected_opts [ '<STR_LIT>' ] = expected_root_device <EOL> opts = iscsi_deploy . build_deploy_ramdisk_options ( self . node ) <EOL> self . assertEqual ( expected_opts , opts ) <EOL> mock_alnum . assert_called_once_with ( <NUM_LIT:32> ) <EOL> self . assertIn ( '<STR_LIT>' , self . node . instance_info ) <EOL> @ mock . patch . object ( keystone , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( utils , '<STR_LIT>' , autospec = True ) <EOL> def test_build_deploy_ramdisk_options ( self , mock_alnum , mock_get_url ) : <EOL> fake_api_url = '<STR_LIT>' <EOL> self . config ( api_url = fake_api_url , group = '<STR_LIT>' ) <EOL> self . _test_build_deploy_ramdisk_options ( mock_alnum , fake_api_url ) <EOL> self . assertFalse ( mock_get_url . called ) <EOL> @ mock . patch . object ( keystone , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( utils , '<STR_LIT>' , autospec = True ) <EOL> def test_build_deploy_ramdisk_options_keystone ( self , mock_alnum , <EOL> mock_get_url ) : <EOL> fake_api_url = '<STR_LIT>' <EOL> mock_get_url . return_value = fake_api_url <EOL> self . _test_build_deploy_ramdisk_options ( mock_alnum , fake_api_url ) <EOL> mock_get_url . assert_called_once_with ( ) <EOL> @ mock . patch . object ( keystone , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( utils , '<STR_LIT>' , autospec = True ) <EOL> def test_build_deploy_ramdisk_options_root_device ( self , mock_alnum , <EOL> mock_get_url ) : <EOL> self . node . properties [ '<STR_LIT>' ] = { '<STR_LIT>' : <NUM_LIT> } <EOL> expected = '<STR_LIT>' <EOL> fake_api_url = '<STR_LIT>' <EOL> self . config ( api_url = fake_api_url , group = '<STR_LIT>' ) <EOL> self . _test_build_deploy_ramdisk_options ( mock_alnum , fake_api_url , <EOL> expected_root_device = expected ) <EOL> @ mock . patch . object ( keystone , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( utils , '<STR_LIT>' , autospec = True ) <EOL> def test_build_deploy_ramdisk_options_boot_option ( self , mock_alnum , <EOL> mock_get_url ) : <EOL> self . node . instance_info = { '<STR_LIT>' : '<STR_LIT>' } <EOL> expected = '<STR_LIT>' <EOL> fake_api_url = '<STR_LIT>' <EOL> self . config ( api_url = fake_api_url , group = '<STR_LIT>' ) <EOL> self . _test_build_deploy_ramdisk_options ( mock_alnum , fake_api_url , <EOL> expected_boot_option = expected ) <EOL> @ mock . patch . object ( keystone , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( utils , '<STR_LIT>' , autospec = True ) <EOL> def test_build_deploy_ramdisk_options_whole_disk_image ( self , mock_alnum , <EOL> mock_get_url ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . node . instance_info = { '<STR_LIT>' : '<STR_LIT>' } <EOL> dii = self . node . driver_internal_info <EOL> dii [ '<STR_LIT>' ] = True <EOL> self . node . driver_internal_info = dii <EOL> self . node . save ( ) <EOL> expected = '<STR_LIT>' <EOL> fake_api_url = '<STR_LIT>' <EOL> self . config ( api_url = fake_api_url , group = '<STR_LIT>' ) <EOL> self . _test_build_deploy_ramdisk_options ( mock_alnum , fake_api_url , <EOL> expected_boot_option = expected ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( manager_utils , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( deploy_utils , '<STR_LIT>' , autospec = True ) <EOL> def test_continue_deploy_fail ( self , deploy_mock , power_mock , <EOL> mock_image_cache , mock_disk_layout ) : <EOL> kwargs = { '<STR_LIT:address>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:key>' : '<STR_LIT>' } <EOL> deploy_mock . side_effect = iter ( [ <EOL> exception . InstanceDeployFailure ( \"<STR_LIT>\" ) ] ) <EOL> self . node . provision_state = states . DEPLOYWAIT <EOL> self . node . target_provision_state = states . ACTIVE <EOL> self . node . save ( ) <EOL> with task_manager . acquire ( self . context , self . node . uuid , <EOL> shared = False ) as task : <EOL> params = iscsi_deploy . get_deploy_info ( task . node , ** kwargs ) <EOL> self . assertRaises ( exception . InstanceDeployFailure , <EOL> iscsi_deploy . continue_deploy , <EOL> task , ** kwargs ) <EOL> self . assertEqual ( states . DEPLOYFAIL , task . node . provision_state ) <EOL> self . assertEqual ( states . ACTIVE , task . node . target_provision_state ) <EOL> self . assertIsNotNone ( task . node . last_error ) <EOL> deploy_mock . assert_called_once_with ( ** params ) <EOL> power_mock . assert_called_once_with ( task , states . POWER_OFF ) <EOL> mock_image_cache . assert_called_once_with ( ) <EOL> mock_image_cache . return_value . clean_up . assert_called_once_with ( ) <EOL> self . assertFalse ( mock_disk_layout . called ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( manager_utils , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( deploy_utils , '<STR_LIT>' , autospec = True ) <EOL> def test_continue_deploy_ramdisk_fails ( self , deploy_mock , power_mock , <EOL> mock_image_cache , mock_disk_layout ) : <EOL> kwargs = { '<STR_LIT:address>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:key>' : '<STR_LIT>' , <EOL> '<STR_LIT:error>' : '<STR_LIT>' } <EOL> self . node . provision_state = states . DEPLOYWAIT <EOL> self . node . target_provision_state = states . ACTIVE <EOL> self . node . save ( ) <EOL> with task_manager . acquire ( self . context , self . node . uuid , <EOL> shared = False ) as task : <EOL> self . assertRaises ( exception . InstanceDeployFailure , <EOL> iscsi_deploy . continue_deploy , <EOL> task , ** kwargs ) <EOL> self . assertIsNotNone ( task . node . last_error ) <EOL> self . assertEqual ( states . DEPLOYFAIL , task . node . provision_state ) <EOL> self . assertEqual ( states . ACTIVE , task . node . target_provision_state ) <EOL> power_mock . assert_called_once_with ( task , states . POWER_OFF ) <EOL> mock_image_cache . assert_called_once_with ( ) <EOL> mock_image_cache . return_value . clean_up . assert_called_once_with ( ) <EOL> self . assertFalse ( deploy_mock . called ) <EOL> self . assertFalse ( mock_disk_layout . called ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( manager_utils , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( deploy_utils , '<STR_LIT>' , autospec = True ) <EOL> def test_continue_deploy_fail_no_root_uuid_or_disk_id ( <EOL> self , deploy_mock , power_mock , mock_image_cache , mock_disk_layout ) : <EOL> kwargs = { '<STR_LIT:address>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:key>' : '<STR_LIT>' } <EOL> deploy_mock . return_value = { } <EOL> self . node . provision_state = states . DEPLOYWAIT <EOL> self . node . target_provision_state = states . ACTIVE <EOL> self . node . save ( ) <EOL> with task_manager . acquire ( self . context , self . node . uuid , <EOL> shared = False ) as task : <EOL> params = iscsi_deploy . get_deploy_info ( task . node , ** kwargs ) <EOL> self . assertRaises ( exception . InstanceDeployFailure , <EOL> iscsi_deploy . continue_deploy , <EOL> task , ** kwargs ) <EOL> self . assertEqual ( states . DEPLOYFAIL , task . node . provision_state ) <EOL> self . assertEqual ( states . ACTIVE , task . node . target_provision_state ) <EOL> self . assertIsNotNone ( task . node . last_error ) <EOL> deploy_mock . assert_called_once_with ( ** params ) <EOL> power_mock . assert_called_once_with ( task , states . POWER_OFF ) <EOL> mock_image_cache . assert_called_once_with ( ) <EOL> mock_image_cache . return_value . clean_up . assert_called_once_with ( ) <EOL> self . assertFalse ( mock_disk_layout . called ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( manager_utils , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( deploy_utils , '<STR_LIT>' , autospec = True ) <EOL> def test_continue_deploy_fail_empty_root_uuid ( <EOL> self , deploy_mock , power_mock , mock_image_cache , mock_disk_layout ) : <EOL> kwargs = { '<STR_LIT:address>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:key>' : '<STR_LIT>' } <EOL> deploy_mock . return_value = { '<STR_LIT>' : '<STR_LIT>' } <EOL> self . node . provision_state = states . DEPLOYWAIT <EOL> self . node . target_provision_state = states . ACTIVE <EOL> self . node . save ( ) <EOL> with task_manager . acquire ( self . context , self . node . uuid , <EOL> shared = False ) as task : <EOL> params = iscsi_deploy . get_deploy_info ( task . node , ** kwargs ) <EOL> self . assertRaises ( exception . InstanceDeployFailure , <EOL> iscsi_deploy . continue_deploy , <EOL> task , ** kwargs ) <EOL> self . assertEqual ( states . DEPLOYFAIL , task . node . provision_state ) <EOL> self . assertEqual ( states . ACTIVE , task . node . target_provision_state ) <EOL> self . assertIsNotNone ( task . node . last_error ) <EOL> deploy_mock . assert_called_once_with ( ** params ) <EOL> power_mock . assert_called_once_with ( task , states . POWER_OFF ) <EOL> mock_image_cache . assert_called_once_with ( ) <EOL> mock_image_cache . return_value . clean_up . assert_called_once_with ( ) <EOL> self . assertFalse ( mock_disk_layout . called ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( manager_utils , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( deploy_utils , '<STR_LIT>' , autospec = True ) <EOL> def test_continue_deploy ( self , deploy_mock , power_mock , mock_image_cache , <EOL> mock_deploy_info , mock_log , mock_disk_layout ) : <EOL> kwargs = { '<STR_LIT:address>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:key>' : '<STR_LIT>' } <EOL> self . node . provision_state = states . DEPLOYWAIT <EOL> self . node . target_provision_state = states . ACTIVE <EOL> self . node . save ( ) <EOL> mock_deploy_info . return_value = { <EOL> '<STR_LIT:address>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT>' : ( u'<STR_LIT>' <EOL> u'<STR_LIT>' ) , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT:1>' , <EOL> '<STR_LIT>' : u'<STR_LIT>' , <EOL> '<STR_LIT:port>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> } <EOL> log_params = mock_deploy_info . return_value . copy ( ) <EOL> log_params [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> expected_dict = { <EOL> '<STR_LIT>' : self . node . uuid , <EOL> '<STR_LIT>' : log_params , <EOL> } <EOL> uuid_dict_returned = { '<STR_LIT>' : '<STR_LIT>' } <EOL> deploy_mock . return_value = uuid_dict_returned <EOL> with task_manager . acquire ( self . context , self . node . uuid , <EOL> shared = False ) as task : <EOL> mock_log . isEnabledFor . return_value = True <EOL> retval = iscsi_deploy . continue_deploy ( task , ** kwargs ) <EOL> mock_log . debug . assert_called_once_with ( <EOL> mock . ANY , expected_dict ) <EOL> self . assertEqual ( states . DEPLOYWAIT , task . node . provision_state ) <EOL> self . assertEqual ( states . ACTIVE , task . node . target_provision_state ) <EOL> self . assertIsNone ( task . node . last_error ) <EOL> mock_image_cache . assert_called_once_with ( ) <EOL> mock_image_cache . return_value . clean_up . assert_called_once_with ( ) <EOL> self . assertEqual ( uuid_dict_returned , retval ) <EOL> mock_disk_layout . assert_called_once_with ( task . node , mock . ANY ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( manager_utils , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( deploy_utils , '<STR_LIT>' , autospec = True ) <EOL> def test_continue_deploy_whole_disk_image ( <EOL> self , deploy_mock , power_mock , mock_image_cache , mock_deploy_info , <EOL> mock_log ) : <EOL> kwargs = { '<STR_LIT:address>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:key>' : '<STR_LIT>' } <EOL> self . node . provision_state = states . DEPLOYWAIT <EOL> self . node . target_provision_state = states . ACTIVE <EOL> self . node . save ( ) <EOL> mock_deploy_info . return_value = { <EOL> '<STR_LIT:address>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : ( u'<STR_LIT>' <EOL> u'<STR_LIT>' ) , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT:1>' , <EOL> '<STR_LIT>' : u'<STR_LIT>' , <EOL> '<STR_LIT:port>' : '<STR_LIT>' , <EOL> } <EOL> log_params = mock_deploy_info . return_value . copy ( ) <EOL> expected_dict = { <EOL> '<STR_LIT>' : self . node . uuid , <EOL> '<STR_LIT>' : log_params , <EOL> } <EOL> uuid_dict_returned = { '<STR_LIT>' : '<STR_LIT>' } <EOL> deploy_mock . return_value = uuid_dict_returned <EOL> with task_manager . acquire ( self . context , self . node . uuid , <EOL> shared = False ) as task : <EOL> task . node . driver_internal_info [ '<STR_LIT>' ] = True <EOL> mock_log . isEnabledFor . return_value = True <EOL> retval = iscsi_deploy . continue_deploy ( task , ** kwargs ) <EOL> mock_log . debug . assert_called_once_with ( <EOL> mock . ANY , expected_dict ) <EOL> self . assertEqual ( states . DEPLOYWAIT , task . node . provision_state ) <EOL> self . assertEqual ( states . ACTIVE , task . node . target_provision_state ) <EOL> self . assertIsNone ( task . node . last_error ) <EOL> mock_image_cache . assert_called_once_with ( ) <EOL> mock_image_cache . return_value . clean_up . assert_called_once_with ( ) <EOL> self . assertEqual ( uuid_dict_returned , retval ) <EOL> def _test_get_deploy_info ( self , extra_instance_info = None ) : <EOL> if extra_instance_info is None : <EOL> extra_instance_info = { } <EOL> instance_info = self . node . instance_info <EOL> instance_info [ '<STR_LIT>' ] = '<STR_LIT:key>' <EOL> instance_info . update ( extra_instance_info ) <EOL> self . node . instance_info = instance_info <EOL> kwargs = { '<STR_LIT:address>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:key>' : '<STR_LIT:key>' } <EOL> ret_val = iscsi_deploy . get_deploy_info ( self . node , ** kwargs ) <EOL> self . assertEqual ( '<STR_LIT>' , ret_val [ '<STR_LIT:address>' ] ) <EOL> self . assertEqual ( '<STR_LIT>' , ret_val [ '<STR_LIT>' ] ) <EOL> return ret_val <EOL> def test_get_deploy_info_boot_option_default ( self ) : <EOL> ret_val = self . _test_get_deploy_info ( ) <EOL> self . assertEqual ( '<STR_LIT>' , ret_val [ '<STR_LIT>' ] ) <EOL> def test_get_deploy_info_netboot_specified ( self ) : <EOL> capabilities = { '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT>' } } <EOL> ret_val = self . _test_get_deploy_info ( extra_instance_info = capabilities ) <EOL> self . assertEqual ( '<STR_LIT>' , ret_val [ '<STR_LIT>' ] ) <EOL> def test_get_deploy_info_localboot ( self ) : <EOL> capabilities = { '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT>' } } <EOL> ret_val = self . _test_get_deploy_info ( extra_instance_info = capabilities ) <EOL> self . assertEqual ( '<STR_LIT>' , ret_val [ '<STR_LIT>' ] ) <EOL> def test_get_deploy_info_disk_label ( self ) : <EOL> capabilities = { '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT>' } } <EOL> ret_val = self . _test_get_deploy_info ( extra_instance_info = capabilities ) <EOL> self . assertEqual ( '<STR_LIT>' , ret_val [ '<STR_LIT>' ] ) <EOL> def test_get_deploy_info_not_specified ( self ) : <EOL> ret_val = self . _test_get_deploy_info ( ) <EOL> self . assertNotIn ( '<STR_LIT>' , ret_val ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , <EOL> autospec = True ) <EOL> def test_do_agent_iscsi_deploy_okay ( self , build_options_mock , <EOL> continue_deploy_mock ) : <EOL> build_options_mock . return_value = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> } <EOL> agent_client_mock = mock . MagicMock ( spec_set = agent_client . AgentClient ) <EOL> agent_client_mock . start_iscsi_target . return_value = { <EOL> '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : None } <EOL> driver_internal_info = { '<STR_LIT>' : '<STR_LIT>' } <EOL> self . node . driver_internal_info = driver_internal_info <EOL> self . node . save ( ) <EOL> uuid_dict_returned = { '<STR_LIT>' : '<STR_LIT>' } <EOL> continue_deploy_mock . return_value = uuid_dict_returned <EOL> with task_manager . acquire ( self . context , self . node . uuid , <EOL> shared = False ) as task : <EOL> ret_val = iscsi_deploy . do_agent_iscsi_deploy ( <EOL> task , agent_client_mock ) <EOL> build_options_mock . assert_called_once_with ( task . node ) <EOL> agent_client_mock . start_iscsi_target . assert_called_once_with ( <EOL> task . node , '<STR_LIT>' , <NUM_LIT> , wipe_disk_metadata = True ) <EOL> continue_deploy_mock . assert_called_once_with ( <EOL> task , error = None , iqn = '<STR_LIT>' , key = '<STR_LIT>' , <EOL> address = '<STR_LIT>' ) <EOL> self . assertEqual ( <EOL> '<STR_LIT>' , <EOL> task . node . driver_internal_info [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( ret_val , uuid_dict_returned ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , autospec = True ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , <EOL> autospec = True ) <EOL> def test_do_agent_iscsi_deploy_preserve_ephemeral ( self , build_options_mock , <EOL> continue_deploy_mock ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> build_options_mock . return_value = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> } <EOL> agent_client_mock = mock . MagicMock ( spec_set = agent_client . AgentClient ) <EOL> agent_client_mock . start_iscsi_target . return_value = { <EOL> '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : None } <EOL> driver_internal_info = { <EOL> '<STR_LIT>' : '<STR_LIT>' } <EOL> self . node . driver_internal_info = driver_internal_info <EOL> self . node . save ( ) <EOL> uuid_dict_returned = { '<STR_LIT>' : '<STR_LIT>' } <EOL> continue_deploy_mock . return_value = uuid_dict_returned <EOL> with task_manager . acquire ( self . context , self . node . uuid , <EOL> shared = False ) as task : <EOL> task . node . instance_info [ '<STR_LIT>' ] = True <EOL> iscsi_deploy . do_agent_iscsi_deploy ( <EOL> task , agent_client_mock ) <EOL> build_options_mock . assert_called_once_with ( task . node ) <EOL> agent_client_mock . start_iscsi_target . assert_called_once_with ( <EOL> task . node , '<STR_LIT>' , <NUM_LIT> , wipe_disk_metadata = False ) <EOL> @ mock . patch . object ( iscsi_deploy , '<STR_LIT>' , <EOL> autospec = True ) <EOL> def test_do_agent_iscsi_deploy_start_iscsi_failure ( self , <EOL> build_options_mock ) : <EOL> build_options_mock . return_value = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> } <EOL> agent_client_mock = mock . MagicMock ( spec_set = agent_client . AgentClient ) <EOL> agent_client_mock . start_iscsi_target . return_value = { <EOL> '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } <EOL> self . node . provision_state = states . DEPLOYING <EOL> self . node . target_provision_state = states . ACTIVE <EOL> self . node . save ( ) <EOL> with task_manager . acquire ( self . context , self . node . uuid , <EOL> shared = False ) as task : <EOL> self . assertRaises ( exception . InstanceDeployFailure , <EOL> iscsi_deploy . do_agent_iscsi_deploy , <EOL> task , agent_client_mock ) <EOL> build_options_mock . assert_called_once_with ( task . node ) <EOL> agent_client_mock . start_iscsi_target . assert_called_once_with ( <EOL> task . node , '<STR_LIT>' , <NUM_LIT> , wipe_disk_metadata = True ) <EOL> self . node . refresh ( ) <EOL> self . assertEqual ( states . DEPLOYFAIL , self . node . provision_state ) <EOL> self . assertEqual ( states . ACTIVE , self . node . target_provision_state ) <EOL> self . assertIsNotNone ( self . node . last_error ) <EOL> def test_validate_pass_bootloader_info_input ( self ) : <EOL> params = { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:address>' : '<STR_LIT>' , <EOL> '<STR_LIT:error>' : '<STR_LIT>' , '<STR_LIT:status>' : '<STR_LIT>' } <EOL> with task_manager . acquire ( self . context , self . node . uuid , <EOL> shared = False ) as task : <EOL> task . node . instance_info [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> iscsi_deploy . validate_pass_bootloader_info_input ( task , params ) <EOL> def test_validate_pass_bootloader_info_missing_status ( self ) : <EOL> params = { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:address>' : '<STR_LIT>' } <EOL>", "answer": "with task_manager . acquire ( self . context , self . node . uuid ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> from PySide . QtGui import * <EOL> from PySide . QtCore import * <EOL> from ui_Event import Ui_Event <EOL> '''<STR_LIT>''' <EOL> class EventWindow ( QDialog , Ui_Event ) : <EOL> def __init__ ( self , parent , eventId ) : <EOL> super ( EventWindow , self ) . __init__ ( parent ) <EOL> self . rent = parent <EOL> self . data = parent . eventData [ eventId ] <EOL> self . deckAssignment = [ ] <EOL> self . setupUi ( self ) <EOL> self . assignWidgets ( ) <EOL> self . setWindowTitle ( unicode ( \"<STR_LIT>\" % eventId ) ) <EOL> def savePressed ( self ) : <EOL> self . data [ \"<STR_LIT>\" ] = self . notesText . toPlainText ( ) <EOL> self . data [ \"<STR_LIT>\" ] = self . deckText . text ( ) <EOL> self . data [ \"<STR_LIT>\" ] = self . placeText . text ( ) <EOL>", "answer": "self . data [ \"<STR_LIT>\" ] = self . eventTypeText . text ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT:U+0020>''' <EOL> from __future__ import absolute_import <EOL> from __future__ import with_statement <EOL> import logging <EOL> import threading <EOL> from . import os_helper <EOL> if os_helper . isJython ( ) : <EOL> from com . ziclix . python . sql import zxJDBC <EOL> else : <EOL> from . . site_packages import pypyodbc <EOL> from . import conf <EOL> threadVar = threading . local ( ) <EOL> def closeConnection_jdbc ( ) : <EOL> logger = logging . getLogger ( __name__ ) <EOL> try : <EOL> _ = threadVar . connection <EOL> except : <EOL> threadVar . connection = None <EOL> if ( threadVar . connection is not None ) and ( threadVar . connection . closed == False ) : <EOL> threadVar . connection . close ( ) <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> threadVar . connection = None <EOL> def closeConnection_odbc ( ) : <EOL> logger = logging . getLogger ( __name__ ) <EOL> try : <EOL> _ = threadVar . connection <EOL> except : <EOL> threadVar . connection = None <EOL> if ( threadVar . connection is not None ) and ( threadVar . connection . connected ) : <EOL> threadVar . connection . close ( ) <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> threadVar . connection = None <EOL> def openConnection_jdbc ( ) : <EOL> logger = logging . getLogger ( __name__ ) <EOL> try : <EOL> _ = threadVar . connection <EOL> except : <EOL> threadVar . connection = None <EOL> if threadVar . connection is None : <EOL> logger . info ( '<STR_LIT>' ) <EOL> threadVar . connection = zxJDBC . connect ( conf . tera_url_jdbc , conf . tera_uid_jdbc , conf . tera_pwd_jdbc , conf . tera_driver_jdbc ) <EOL> logger . info ( '<STR_LIT>' , ( threadVar . connection , ) ) <EOL>", "answer": "return threadVar . connection"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import numpy as np <EOL> try : <EOL> from matplotlib import pyplot as pb <EOL> from matplotlib . patches import Polygon <EOL> from matplotlib . collections import PatchCollection <EOL> try : <EOL> __IPYTHON__ <EOL> pb . ion ( ) <EOL> except NameError : <EOL> pass <EOL> except : <EOL> pass <EOL> import re <EOL> def plot ( shape_records , facecolor = '<STR_LIT:w>' , edgecolor = '<STR_LIT:k>' , linewidths = <NUM_LIT> , ax = None , xlims = None , ylims = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ax is None : <EOL> fig = pb . figure ( ) <EOL> ax = fig . add_subplot ( <NUM_LIT> ) <EOL> for srec in shape_records : <EOL> points = np . vstack ( srec . shape . points ) <EOL> sparts = srec . shape . parts <EOL> par = list ( sparts ) + [ points . shape [ <NUM_LIT:0> ] ] <EOL> polygs = [ ] <EOL> for pj in range ( len ( sparts ) ) : <EOL> polygs . append ( Polygon ( points [ par [ pj ] : par [ pj + <NUM_LIT:1> ] ] ) ) <EOL> ax . add_collection ( PatchCollection ( polygs , facecolor = facecolor , edgecolor = edgecolor , linewidths = linewidths ) ) <EOL> _box = np . vstack ( [ srec . shape . bbox for srec in shape_records ] ) <EOL> minx , miny = np . min ( _box [ : , : <NUM_LIT:2> ] , <NUM_LIT:0> ) <EOL> maxx , maxy = np . max ( _box [ : , <NUM_LIT:2> : ] , <NUM_LIT:0> ) <EOL> if xlims is not None : <EOL> minx , maxx = xlims <EOL> if ylims is not None : <EOL> miny , maxy = ylims <EOL> ax . set_xlim ( minx , maxx ) <EOL> ax . set_ylim ( miny , maxy ) <EOL> def string_match ( sf , regex , field = <NUM_LIT:2> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> index = [ ] <EOL> shape_records = [ ] <EOL> for rec in enumerate ( sf . shapeRecords ( ) ) : <EOL> m = re . search ( regex , rec [ <NUM_LIT:1> ] . record [ field ] ) <EOL> if m is not None : <EOL> index . append ( rec [ <NUM_LIT:0> ] ) <EOL> shape_records . append ( rec [ <NUM_LIT:1> ] ) <EOL> return index , shape_records <EOL> def bbox_match ( sf , bbox , inside_only = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> A , B , C , D = bbox <EOL> index = [ ] <EOL> shape_records = [ ] <EOL> for rec in enumerate ( sf . shapeRecords ( ) ) : <EOL> a , b , c , d = rec [ <NUM_LIT:1> ] . shape . bbox <EOL> if inside_only : <EOL> if A <= a and B <= b and C >= c and D >= d : <EOL> index . append ( rec [ <NUM_LIT:0> ] ) <EOL> shape_records . append ( rec [ <NUM_LIT:1> ] ) <EOL> else : <EOL> cond1 = A <= a and B <= b and C >= a and D >= b <EOL> cond2 = A <= c and B <= d and C >= c and D >= d <EOL> cond3 = A <= a and D >= d and C >= a and B <= d <EOL> cond4 = A <= c and D >= b and C >= c and B <= b <EOL> cond5 = a <= C and b <= B and d >= D <EOL> cond6 = c <= A and b <= B and d >= D <EOL> cond7 = d <= B and a <= A and c >= C <EOL> cond8 = b <= D and a <= A and c >= C <EOL> if cond1 or cond2 or cond3 or cond4 or cond5 or cond6 or cond7 or cond8 : <EOL> index . append ( rec [ <NUM_LIT:0> ] ) <EOL> shape_records . append ( rec [ <NUM_LIT:1> ] ) <EOL> return index , shape_records <EOL> def plot_bbox ( sf , bbox , inside_only = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> index , shape_records = bbox_match ( sf , bbox , inside_only ) <EOL> A , B , C , D = bbox <EOL> plot ( shape_records , xlims = [ bbox [ <NUM_LIT:0> ] , bbox [ <NUM_LIT:2> ] ] , ylims = [ bbox [ <NUM_LIT:1> ] , bbox [ <NUM_LIT:3> ] ] ) <EOL> def plot_string_match ( sf , regex , field , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> index , shape_records = string_match ( sf , regex , field ) <EOL>", "answer": "plot ( shape_records , ** kwargs )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from twisted . python import log <EOL> from twisted . python . filepath import FilePath <EOL> from twisted . conch . error import ConchError <EOL> from twisted . conch . ssh import common , keys , userauth <EOL> from twisted . internet import defer , protocol , reactor <EOL> from twisted . conch . client . knownhosts import KnownHostsFile , ConsoleUI <EOL> from twisted . conch . client import agent <EOL> import os , sys , base64 , getpass <EOL> _open = open <EOL> def verifyHostKey ( transport , host , pubKey , fingerprint ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> actualHost = transport . factory . options [ '<STR_LIT:host>' ] <EOL> actualKey = keys . Key . fromString ( pubKey ) <EOL> kh = KnownHostsFile . fromPath ( FilePath ( <EOL> transport . factory . options [ '<STR_LIT>' ] <EOL> or os . path . expanduser ( \"<STR_LIT>\" ) <EOL> ) ) <EOL> ui = ConsoleUI ( lambda : _open ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> return kh . verifyHostKey ( ui , actualHost , host , actualKey ) <EOL> def isInKnownHosts ( host , pubKey , options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> keyType = common . getNS ( pubKey ) [ <NUM_LIT:0> ] <EOL> retVal = <NUM_LIT:0> <EOL> if not options [ '<STR_LIT>' ] and not os . path . exists ( os . path . expanduser ( '<STR_LIT>' ) ) : <EOL> print '<STR_LIT>' <EOL> os . mkdir ( os . path . expanduser ( '<STR_LIT>' ) ) <EOL> kh_file = options [ '<STR_LIT>' ] or '<STR_LIT>' <EOL> try : <EOL> known_hosts = open ( os . path . expanduser ( kh_file ) ) <EOL> except IOError : <EOL> return <NUM_LIT:0> <EOL> for line in known_hosts . xreadlines ( ) : <EOL> split = line . split ( ) <EOL> if len ( split ) < <NUM_LIT:3> : <EOL> continue <EOL> hosts , hostKeyType , encodedKey = split [ : <NUM_LIT:3> ] <EOL> if host not in hosts . split ( '<STR_LIT:U+002C>' ) : <EOL> continue <EOL> if hostKeyType != keyType : <EOL> continue <EOL> try : <EOL> decodedKey = base64 . decodestring ( encodedKey ) <EOL> except : <EOL> continue <EOL> if decodedKey == pubKey : <EOL> return <NUM_LIT:1> <EOL> else : <EOL> retVal = <NUM_LIT:2> <EOL> return retVal <EOL> class SSHUserAuthClient ( userauth . SSHUserAuthClient ) : <EOL> def __init__ ( self , user , options , * args ) : <EOL> userauth . SSHUserAuthClient . __init__ ( self , user , * args ) <EOL> self . keyAgent = None <EOL> self . options = options <EOL> self . usedFiles = [ ] <EOL> if not options . identitys : <EOL> options . identitys = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def serviceStarted ( self ) : <EOL> if '<STR_LIT>' in os . environ and not self . options [ '<STR_LIT>' ] : <EOL> log . msg ( '<STR_LIT>' ) <EOL> cc = protocol . ClientCreator ( reactor , agent . SSHAgentClient ) <EOL> d = cc . connectUNIX ( os . environ [ '<STR_LIT>' ] ) <EOL> d . addCallback ( self . _setAgent ) <EOL> d . addErrback ( self . _ebSetAgent ) <EOL> else : <EOL> userauth . SSHUserAuthClient . serviceStarted ( self ) <EOL> def serviceStopped ( self ) : <EOL> if self . keyAgent : <EOL> self . keyAgent . transport . loseConnection ( ) <EOL> self . keyAgent = None <EOL> def _setAgent ( self , a ) : <EOL> self . keyAgent = a <EOL> d = self . keyAgent . getPublicKeys ( ) <EOL> d . addBoth ( self . _ebSetAgent ) <EOL> return d <EOL> def _ebSetAgent ( self , f ) : <EOL> userauth . SSHUserAuthClient . serviceStarted ( self ) <EOL> def _getPassword ( self , prompt ) : <EOL> try : <EOL> oldout , oldin = sys . stdout , sys . stdin <EOL> sys . stdin = sys . stdout = open ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> p = getpass . getpass ( prompt ) <EOL> sys . stdout , sys . stdin = oldout , oldin <EOL> return p <EOL> except ( KeyboardInterrupt , IOError ) : <EOL> print <EOL> raise ConchError ( '<STR_LIT>' ) <EOL> def getPassword ( self , prompt = None ) : <EOL> if not prompt : <EOL> prompt = \"<STR_LIT>\" % ( self . user , self . transport . transport . getPeer ( ) . host ) <EOL> try : <EOL> p = self . _getPassword ( prompt ) <EOL> return defer . succeed ( p ) <EOL> except ConchError : <EOL> return defer . fail ( ) <EOL> def getPublicKey ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . keyAgent : <EOL> key = self . keyAgent . getPublicKey ( ) <EOL> if key is not None : <EOL> return key <EOL> files = [ x for x in self . options . identitys if x not in self . usedFiles ] <EOL> log . msg ( str ( self . options . identitys ) ) <EOL> log . msg ( str ( files ) ) <EOL> if not files : <EOL> return None <EOL> file = files [ <NUM_LIT:0> ] <EOL> log . msg ( file ) <EOL> self . usedFiles . append ( file ) <EOL> file = os . path . expanduser ( file ) <EOL> file += '<STR_LIT>' <EOL> if not os . path . exists ( file ) : <EOL> return self . getPublicKey ( ) <EOL> try : <EOL> return keys . Key . fromFile ( file ) <EOL> except keys . BadKeyError : <EOL> return self . getPublicKey ( ) <EOL> def signData ( self , publicKey , signData ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import argparse <EOL> import sqlite3 <EOL> from operator import itemgetter <EOL> import os <EOL> import sys <EOL> parser = argparse . ArgumentParser ( description = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , metavar = '<STR_LIT>' , help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , metavar = '<STR_LIT>' , default = False , type = str , nargs = '<STR_LIT:+>' , help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , metavar = '<STR_LIT>' , help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , action = '<STR_LIT:store_true>' , help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , metavar = '<STR_LIT>' , type = int , help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , metavar = '<STR_LIT>' , help = '<STR_LIT>' ) <EOL> args = parser . parse_args ( ) <EOL> conn = sqlite3 . connect ( args . database ) <EOL> conn . text_factory = str <EOL> cur = conn . cursor ( ) <EOL> if not args . tables : <EOL> cmd = cur . execute ( \"<STR_LIT>\" ) <EOL> tbls = [ t for t , in cmd . fetchall ( ) ] <EOL> else : <EOL> tbls = args . tables <EOL> print '<STR_LIT>' , tbls <EOL> for tbl in tbls : <EOL> try : <EOL> print '<STR_LIT>' , tbl <EOL> cmd = cur . execute ( \"<STR_LIT>\" . format ( args . base_on , tbl ) ) <EOL> vals = cmd . fetchall ( ) <EOL>", "answer": "vals = sorted ( vals , key = itemgetter ( <NUM_LIT:1> ) , reverse = args . descending )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import print_function <EOL> from __future__ import absolute_import <EOL> import unittest <EOL> import responses <EOL> import requests <EOL> from . requests_patch import patched_extract_cookies_to_jar <EOL> from terminalone import T1 <EOL> mock_credentials = { <EOL> '<STR_LIT:username>' : '<STR_LIT>' , <EOL> '<STR_LIT:password>' : '<STR_LIT:password>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> API_BASE = '<STR_LIT>' <EOL> requests . sessions . extract_cookies_to_jar = patched_extract_cookies_to_jar <EOL> requests . adapters . extract_cookies_to_jar = patched_extract_cookies_to_jar <EOL> class TestPermissions ( unittest . TestCase ) : <EOL> def setup ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with open ( '<STR_LIT>' ) as f : <EOL> fixture = f . read ( ) <EOL> responses . add ( responses . POST , '<STR_LIT>' , <EOL> body = fixture , <EOL> adding_headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> content_type = '<STR_LIT>' ) <EOL> self . t1 = T1 ( auth_method = '<STR_LIT>' , <EOL> api_base = API_BASE , <EOL> ** mock_credentials ) <EOL> @ responses . activate <EOL> def test_get_permissions ( self ) : <EOL> self . setup ( ) <EOL> with open ( '<STR_LIT>' ) as f : <EOL> fixture = f . read ( ) <EOL> responses . add ( responses . GET , <EOL> '<STR_LIT>' , <EOL> body = fixture , <EOL> content_type = '<STR_LIT>' , <EOL> match_querystring = True ) <EOL> p = self . t1 . get ( '<STR_LIT>' , <NUM_LIT> , child = '<STR_LIT>' ) <EOL>", "answer": "assert p . _type == '<STR_LIT>' , '<STR_LIT>' . format ( p . _type )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = <NUM_LIT:11> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from kay . routing import ( <EOL> ViewGroup , Rule <EOL> ) <EOL> view_groups = [ <EOL> ViewGroup ( <EOL> Rule ( '<STR_LIT>' , endpoint = '<STR_LIT>' , <EOL> view = ( '<STR_LIT>' , ( ) , { } ) ) , <EOL> Rule ( '<STR_LIT>' , endpoint = '<STR_LIT>' , <EOL> view = ( '<STR_LIT>' , ( ) , { } ) ) , <EOL> Rule ( '<STR_LIT>' , endpoint = '<STR_LIT>' , <EOL> view = '<STR_LIT>' ) , <EOL>", "answer": ")"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from io import BytesIO <EOL> import logging <EOL> import os <EOL> import re <EOL> import struct <EOL> import sys <EOL> from . compat import sysconfig , detect_encoding , ZipFile <EOL> from . resources import finder <EOL> from . util import ( FileOperator , get_export_entry , convert_path , <EOL> get_executable , in_venv ) <EOL> logger = logging . getLogger ( __name__ ) <EOL> _DEFAULT_MANIFEST = '''<STR_LIT>''' . strip ( ) <EOL> FIRST_LINE_RE = re . compile ( b'<STR_LIT>' ) <EOL> SCRIPT_TEMPLATE = '''<STR_LIT>''' <EOL> def _enquote_executable ( executable ) : <EOL> if '<STR_LIT:U+0020>' in executable : <EOL> if executable . startswith ( '<STR_LIT>' ) : <EOL> env , _executable = executable . split ( '<STR_LIT:U+0020>' , <NUM_LIT:1> ) <EOL> if '<STR_LIT:U+0020>' in _executable and not _executable . startswith ( '<STR_LIT:\">' ) : <EOL> executable = '<STR_LIT>' % ( env , _executable ) <EOL>", "answer": "else :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys , getopt , os <EOL> sys . path . append ( '<STR_LIT>' ) <EOL> import numpy as np <EOL> import matplotlib as mpl <EOL> import matplotlib . pyplot as plt <EOL> import pyfits <EOL> import exorings <EOL> import j1407 <EOL> from scipy . optimize import fmin <EOL> from scipy . interpolate import UnivariateSpline <EOL> from scipy . interpolate import interp1d <EOL> from matplotlib . patches import PathPatch <EOL> mpl . interactive ( True ) <EOL> mpl . rc ( '<STR_LIT:image>' , interpolation = '<STR_LIT>' , origin = '<STR_LIT>' , cmap = '<STR_LIT>' ) <EOL> mpl . rc ( '<STR_LIT>' , limits = ( - <NUM_LIT:7> , <NUM_LIT:7> ) ) <EOL> G = <NUM_LIT> <EOL> yr = <NUM_LIT> * <NUM_LIT> <EOL> msol = <NUM_LIT> <EOL> rsol = <NUM_LIT> <EOL> mjup = <NUM_LIT> <EOL> rjup = <NUM_LIT> <EOL> mearth = <NUM_LIT> <EOL> mmoon = <NUM_LIT> <EOL> au = <NUM_LIT> <EOL> pc = <NUM_LIT> <EOL> class switch ( object ) : <EOL> def __init__ ( self , value ) : <EOL> self . value = value <EOL> self . fall = False <EOL> def __iter__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> yield self . match <EOL> raise StopIteration <EOL> def match ( self , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . fall or not args : <EOL> return True <EOL> elif self . value in args : <EOL> self . fall = True <EOL> return True <EOL> else : <EOL> return False <EOL> def Ptoa ( P , m1 , m2 ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c = G / ( <NUM_LIT> * np . pi * np . pi ) <EOL> mu = ( m1 * msol ) + ( m2 * mjup ) <EOL> a3 = np . power ( P * yr , <NUM_LIT> ) * ( c * mu ) <EOL> return ( np . power ( a3 , <NUM_LIT:1.> / <NUM_LIT> ) / au ) <EOL> def vcirc ( m1 , m2 , a ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> mu = G * ( ( m1 * msol ) + ( m2 * mjup ) ) <EOL> vcirc = np . power ( ( mu / ( a * au ) ) , <NUM_LIT:0.5> ) <EOL> return ( vcirc ) <EOL> def ringfunc ( taun , * args ) : <EOL> '<STR_LIT>' <EOL> ( t , f , f_err , rad_ri , re , k , dst ) = args <EOL> strip , dummy , g = exorings . ellipse_strip ( rad_ri , exorings . y_to_tau ( taun ) , re [ <NUM_LIT:0> ] , re [ <NUM_LIT:1> ] , re [ <NUM_LIT:2> ] , re [ <NUM_LIT:3> ] , k , dst ) <EOL> ring_model = interp1d ( g [ <NUM_LIT:0> ] , g [ <NUM_LIT:1> ] , kind = '<STR_LIT>' ) <EOL> ring_model_phot = ring_model ( t ) <EOL> diff = f - ring_model_phot <EOL> chisq = np . sum ( np . power ( diff / f_err , <NUM_LIT:2> ) ) <EOL> red_chisq = chisq / diff . size <EOL> return red_chisq <EOL> def calc_ring_stats ( taun , t , f , f_err , rad_ri , re , k , dst , tmin , tmax ) : <EOL> '<STR_LIT>' <EOL> strip , dummy , g = exorings . ellipse_strip ( rad_ri , exorings . y_to_tau ( taun ) , re [ <NUM_LIT:0> ] , re [ <NUM_LIT:1> ] , re [ <NUM_LIT:2> ] , re [ <NUM_LIT:3> ] , k , dst ) <EOL> mask = ( t > tmin ) * ( t < tmax ) <EOL> t_sel = t [ mask ] <EOL> f_sel = f [ mask ] <EOL> f_err_sel = f_err [ mask ] <EOL> print '<STR_LIT>' % ( t_sel . size , tmin , tmax ) <EOL> ring_model = interp1d ( g [ <NUM_LIT:0> ] , g [ <NUM_LIT:1> ] , kind = '<STR_LIT>' ) <EOL> ring_model_phot = ring_model ( t_sel ) <EOL> diff = f_sel - ring_model_phot <EOL> chisq = np . sum ( np . power ( diff / f_err_sel , <NUM_LIT:2> ) ) <EOL> dof = diff . size - taun . size - <NUM_LIT:1> <EOL> red_chisq = chisq / dof <EOL> print '<STR_LIT>' % diff . size <EOL> print '<STR_LIT>' % taun . size <EOL> print '<STR_LIT>' % dof <EOL> print '<STR_LIT>' % chisq <EOL> print '<STR_LIT>' % red_chisq <EOL> BIC = chisq + ( taun . size ) * np . log ( diff . size ) <EOL> print '<STR_LIT>' % BIC <EOL> return red_chisq <EOL> nn = <NUM_LIT:1> <EOL> def costfunc ( x , * args ) : <EOL> ( y , dt , i_deg , phi_deg ) = x <EOL> ( grad_t , grad_mag_n , t0 ) = args <EOL> global nn <EOL> ( tmp , grad_disk_fit ) = exorings . ring_grad_line ( grad_t , y , dt , i_deg , phi_deg ) <EOL> rmintime = np . arange ( np . min ( grad_t ) , np . max ( grad_t ) , <NUM_LIT> ) <EOL> ( tmp , rminline ) = exorings . ring_grad_line ( rmintime , y , dt , i_deg , phi_deg ) <EOL> rmint = rmintime [ np . argmin ( rminline ) ] <EOL> delta = grad_disk_fit - grad_mag_n <EOL> delta [ np . where ( delta < <NUM_LIT:0> ) ] = - delta [ np . where ( delta < <NUM_LIT:0> ) ] * <NUM_LIT> <EOL> dean = np . abs ( rmint - t0 ) <EOL> cost = np . sum ( delta ) + ( dean * <NUM_LIT:20> ) <EOL> nn += <NUM_LIT:1> <EOL> return cost <EOL> def ind_ring ( ring , r ) : <EOL> '<STR_LIT>' <EOL> rdiff = ring - r <EOL> return np . argmin ( np . abs ( rdiff ) ) <EOL> def ind_ring_big ( ring , r ) : <EOL> '<STR_LIT>' <EOL> rdiff = ring - r <EOL> rdiff [ ( rdiff < <NUM_LIT:0> ) ] += <NUM_LIT> <EOL> return np . argmin ( rdiff ) <EOL> ( time , flux , flux_err ) = j1407 . j1407_photom_binned ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT> ) <EOL> rings_tmin = <NUM_LIT> - <NUM_LIT> <EOL> rings_tmax = <NUM_LIT> + <NUM_LIT> <EOL> print '<STR_LIT>' % ( rings_tmin , rings_tmax ) <EOL> goodp_rings = ( time > rings_tmin ) * ( time < rings_tmax ) <EOL> good_rings_npoints = goodp_rings . size <EOL> print '<STR_LIT>' % ( good_rings_npoints ) <EOL> ( grad_time , grad_mag , grad_mag_norm ) = j1407 . j1407_gradients ( '<STR_LIT>' ) <EOL> fitsin = '<STR_LIT>' <EOL> fitsout = '<STR_LIT>' <EOL> read_in_ring_parameters = False <EOL> read_in_disk_parameters = False <EOL> tx = <NUM_LIT> <EOL> vstar = - <NUM_LIT:1> <EOL> def print_help ( ) : <EOL> print '<STR_LIT>' <EOL> try : <EOL> opts , args = getopt . getopt ( sys . argv [ <NUM_LIT:1> : ] , \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> except getopt . GetoptError : <EOL> print_help ( ) <EOL> sys . exit ( <NUM_LIT:2> ) <EOL> for opt , arg in opts : <EOL> if opt == '<STR_LIT>' : <EOL> print_help ( ) <EOL> sys . exit ( ) <EOL> elif opt in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> fitsin_disk = arg <EOL> read_in_disk_parameters = True <EOL> elif opt in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> fitsin_ring = arg <EOL> read_in_ring_parameters = True <EOL> elif opt in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> fitsout = arg <EOL> elif opt in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> tx = np . array ( float ( arg ) ) <EOL> print '<STR_LIT>' , tx <EOL> elif opt in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> vstar = np . array ( float ( arg ) ) <EOL> print '<STR_LIT>' , fitsout <EOL> phi_deg = <NUM_LIT> <EOL> i_deg = <NUM_LIT> <EOL> dt = <NUM_LIT> <EOL> y = <NUM_LIT> <EOL> Rstar = <NUM_LIT> <EOL> Mstar = <NUM_LIT> <EOL> Rstar = <NUM_LIT> <EOL> Rstar = <NUM_LIT> <EOL> Mb = <NUM_LIT> <EOL> Pb = <NUM_LIT> <EOL> t_ecl = <NUM_LIT> <EOL> a = Ptoa ( Pb , Mstar , Mb ) <EOL> print '<STR_LIT>' % Mstar <EOL> print '<STR_LIT>' % Rstar <EOL> print '<STR_LIT>' % Mb <EOL> print '<STR_LIT>' % a <EOL> v = vcirc ( Mstar , Mb , a ) <EOL> if vstar > <NUM_LIT:0> : <EOL> v = vstar <EOL> print '<STR_LIT>' % v <EOL> print '<STR_LIT>' % ( v / <NUM_LIT> ) <EOL> dstar = ( Rstar * rsol * <NUM_LIT:2> / v ) / <NUM_LIT> <EOL> print '<STR_LIT>' % dstar <EOL> if read_in_ring_parameters : <EOL> print '<STR_LIT>' % fitsin_ring <EOL> ( resxx , taun_rings , rad_rings , xxxdstar ) = exorings . read_ring_fits ( fitsin_ring ) <EOL> else : <EOL> print \"<STR_LIT>\" <EOL> rad_rings = np . array ( [ <NUM_LIT> ] ) <EOL> taun_rings = np . array ( [ <NUM_LIT:0.0> ] ) <EOL> rad_rings = np . append ( rad_rings , ( <NUM_LIT> ) ) <EOL> taun_rings = np . append ( taun_rings , ( <NUM_LIT> ) ) <EOL> exorings . print_ring_tau ( rad_rings , exorings . y_to_tau ( taun_rings ) ) <EOL> if read_in_disk_parameters : <EOL> print '<STR_LIT>' % fitsin_disk <EOL> ( res , taun_ringsxx , rad_ringsxx , dstarxx ) = exorings . read_ring_fits ( fitsin_disk ) <EOL> else : <EOL> print '<STR_LIT>' <EOL> res = fmin ( costfunc , np . array ( [ y , dt , i_deg , phi_deg ] ) , maxiter = <NUM_LIT> , args = ( grad_time , grad_mag_norm , tx ) ) <EOL> kern = exorings . make_star_limbd ( <NUM_LIT> , <NUM_LIT> ) <EOL> ( ring_disk_fit , grad_disk_fit ) = exorings . ring_grad_line ( grad_time , res [ <NUM_LIT:0> ] , res [ <NUM_LIT:1> ] , res [ <NUM_LIT:2> ] , res [ <NUM_LIT:3> ] ) <EOL> samp_t = np . arange ( - <NUM_LIT:100> , <NUM_LIT:100> , <NUM_LIT> ) + <NUM_LIT> <EOL> ( samp_r , samp_g ) = exorings . ring_grad_line ( samp_t , res [ <NUM_LIT:0> ] , res [ <NUM_LIT:1> ] , res [ <NUM_LIT:2> ] , res [ <NUM_LIT:3> ] ) <EOL> hjd_minr = samp_t [ np . argmin ( samp_g ) ] <EOL> hjd_to_ring = interp1d ( samp_t , samp_r , kind = '<STR_LIT>' ) <EOL> ( rstart , rend ) = exorings . ring_mask_no_photometry ( kern , dstar , time , res [ <NUM_LIT:0> ] , res [ <NUM_LIT:1> ] , res [ <NUM_LIT:2> ] , res [ <NUM_LIT:3> ] ) <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' % res [ <NUM_LIT:0> ] <EOL> print '<STR_LIT>' % res [ <NUM_LIT:1> ] <EOL> print '<STR_LIT>' % res [ <NUM_LIT:2> ] <EOL> print '<STR_LIT>' % res [ <NUM_LIT:3> ] <EOL> print '<STR_LIT>' % hjd_minr <EOL> print '<STR_LIT>' % np . min ( samp_r ) <EOL> time0 = np . abs ( time - hjd_minr ) <EOL> time0_grad = np . abs ( grad_time - hjd_minr ) <EOL> flux_color = np . chararray ( ( time . shape ) ) <EOL> flux_color [ : ] = '<STR_LIT:b>' <EOL> flux_color [ ( time > hjd_minr ) ] = '<STR_LIT:r>' <EOL> flux_col = '<STR_LIT>' <EOL> for b in flux_color . tolist ( ) : <EOL> flux_col = str . join ( '<STR_LIT>' , ( flux_col , b ) ) <EOL> def plot_folded_phot ( f ) : <EOL> '<STR_LIT>' <EOL> h1 . scatter ( time0 , flux , c = flux_col , s = <NUM_LIT:20> , edgecolors = '<STR_LIT:none>' , zorder = - <NUM_LIT:20> ) <EOL> h1 . errorbar ( time0 , flux , flux_err , zorder = - <NUM_LIT:30> , ls = '<STR_LIT:none>' ) <EOL> fig_fold = plt . figure ( figsize = ( <NUM_LIT:16> , <NUM_LIT:6> ) ) <EOL> h1 = fig_fold . add_subplot ( <NUM_LIT> ) <EOL> plot_folded_phot ( fig_fold ) <EOL> strip , dummy , g = exorings . ellipse_strip ( rad_rings , exorings . y_to_tau ( taun_rings ) , res [ <NUM_LIT:0> ] , res [ <NUM_LIT:1> ] , res [ <NUM_LIT:2> ] , res [ <NUM_LIT:3> ] , kern , dstar ) <EOL> gt_abs = np . abs ( g [ <NUM_LIT:0> ] - hjd_minr ) <EOL> g1 = g [ <NUM_LIT:1> ] <EOL> gt_ingr = gt_abs [ ( g [ <NUM_LIT:0> ] <= hjd_minr ) ] <EOL> gt_egr = gt_abs [ ( g [ <NUM_LIT:0> ] > hjd_minr ) ] <EOL> g1_ingr = g1 [ ( g [ <NUM_LIT:0> ] <= hjd_minr ) ] <EOL> g1_egr = g1 [ ( g [ <NUM_LIT:0> ] > hjd_minr ) ] <EOL> h1 . plot ( np . abs ( g [ <NUM_LIT:0> ] - hjd_minr ) , g [ <NUM_LIT:1> ] ) <EOL> h1 . plot ( gt_ingr , g1_ingr , color = '<STR_LIT>' ) <EOL> h1 . plot ( gt_egr , g1_egr , color = '<STR_LIT>' ) <EOL> h1 . plot ( np . abs ( g [ <NUM_LIT:0> ] - hjd_minr ) , g [ <NUM_LIT:2> ] , color = '<STR_LIT>' ) <EOL> h1 . set_xlabel ( '<STR_LIT>' ) <EOL> h1 . set_ylabel ( '<STR_LIT>' ) <EOL> print \"<STR_LIT>\" <EOL> print \"<STR_LIT>\" <EOL> print \"<STR_LIT>\" <EOL> print \"<STR_LIT>\" <EOL> print \"<STR_LIT>\" <EOL> print \"<STR_LIT>\" <EOL> print \"<STR_LIT>\" <EOL> badring = <NUM_LIT:1> <EOL> def onclick ( event ) : <EOL> global rad_rings <EOL> global taun_rings <EOL> global badring <EOL> for case in switch ( event . key ) : <EOL> newt = event . xdata <EOL> newtau = event . ydata <EOL> print '<STR_LIT>' % newtau <EOL> if newtau > <NUM_LIT:1.0> : <EOL> newtau = <NUM_LIT:1.0> <EOL> if newtau < <NUM_LIT:0.0> : <EOL> newtau = <NUM_LIT> <EOL> newr = hjd_to_ring ( newt + hjd_minr ) <EOL> if case ( '<STR_LIT:r>' ) : <EOL> exorings . plot_tilt_faceon ( rad_rings , taun_rings , res , hjd_minr , dstar ) <EOL> break <EOL> if case ( '<STR_LIT:v>' ) : <EOL> exorings . plot_tilt_faceon_vect ( rad_rings , taun_rings , res , hjd_minr , rstart , rend , dstar ) <EOL> break <EOL> if case ( '<STR_LIT:a>' ) : <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' % ( newt , newr ) <EOL> bigr = np . append ( rad_rings , newr ) <EOL> bigtau = np . append ( taun_rings , exorings . tau_to_y ( newtau ) ) <EOL> sortedr = np . argsort ( bigr ) <EOL> rad_rings = bigr [ sortedr ] <EOL> taun_rings = bigtau [ sortedr ] <EOL> break <EOL> if case ( '<STR_LIT:d>' ) : <EOL> if rad_rings . size > <NUM_LIT:1> : <EOL> rsel_idx = ind_ring ( rad_rings , newr ) <EOL> rad_rings = np . delete ( rad_rings , rsel_idx ) <EOL> taun_rings = np . delete ( taun_rings , rsel_idx ) <EOL> break <EOL> if case ( '<STR_LIT:m>' ) : <EOL> rsel_idx = ind_ring ( rad_rings , newr ) <EOL> rad_rings [ rsel_idx ] = newr <EOL> taun_rings [ rsel_idx ] = exorings . tau_to_y ( newtau ) <EOL> break <EOL> if case ( '<STR_LIT:b>' ) : <EOL> badring *= - <NUM_LIT:1> <EOL> print badring <EOL> break <EOL> if case ( '<STR_LIT:o>' ) : <EOL> taun_rings = fmin ( ringfunc , taun_rings , maxiter = <NUM_LIT:1000> , args = ( time , flux , flux_err , rad_rings , res , kern , dstar ) ) <EOL>", "answer": "break"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . test import TestCase <EOL>", "answer": "from . . widgets import ColorPickerWidget"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Creature ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> import sys <EOL> import re <EOL> import json <EOL> class CheckProcs ( object ) : <EOL> myPid = <NUM_LIT:0> <EOL> state = \"<STR_LIT>\" <EOL> name = \"<STR_LIT>\" <EOL> pid = <NUM_LIT:0> <EOL> allProcs = [ ] <EOL> interestingProcs = [ ] <EOL> procDir = \"<STR_LIT>\" <EOL> debug = False <EOL> def __init__ ( self ) : <EOL> self . myPid = os . getpid ( ) <EOL> def setup ( self , debug = False , pidlist = False ) : <EOL> self . debug = debug <EOL> self . pidlist = pidlist <EOL> if debug is True : <EOL> print ( \"<STR_LIT>\" ) <EOL> self . allProcs = [ procs for procs in os . listdir ( self . procDir ) if procs . isdigit ( ) and <EOL> int ( procs ) != int ( self . myPid ) ] <EOL> def process ( self , criteria ) : <EOL> for p in self . allProcs : <EOL> try : <EOL> fh = open ( self . procDir + \"<STR_LIT:/>\" + p + \"<STR_LIT>\" ) <EOL> pInfo = fh . readline ( ) . split ( ) <EOL> cmdfh = open ( self . procDir + \"<STR_LIT:/>\" + p + \"<STR_LIT>\" ) <EOL> cmd = cmdfh . readline ( ) <EOL> pInfo [ <NUM_LIT:1> ] = cmd <EOL> except : <EOL> continue <EOL> finally : <EOL> cmdfh . close ( ) <EOL> fh . close ( ) <EOL> if criteria == '<STR_LIT:state>' : <EOL> if pInfo [ <NUM_LIT:2> ] == self . state : <EOL> self . interestingProcs . append ( pInfo ) <EOL> elif criteria == '<STR_LIT:name>' : <EOL> if re . search ( self . name , pInfo [ <NUM_LIT:1> ] ) : <EOL> self . interestingProcs . append ( pInfo ) <EOL> elif criteria == '<STR_LIT>' : <EOL> if pInfo [ <NUM_LIT:0> ] == self . pid : <EOL> self . interestingProcs . append ( pInfo ) <EOL> def byState ( self , state ) : <EOL> self . state = state <EOL> self . process ( criteria = '<STR_LIT:state>' ) <EOL> self . show ( ) <EOL> def byPid ( self , pid ) : <EOL> self . pid = pid <EOL> self . process ( criteria = '<STR_LIT>' ) <EOL> self . show ( ) <EOL> def byName ( self , name ) : <EOL> self . name = name <EOL> self . process ( criteria = '<STR_LIT:name>' ) <EOL> self . show ( ) <EOL> def run ( self , foo , criteria ) : <EOL> if foo == '<STR_LIT:state>' : <EOL> self . byState ( criteria ) <EOL> elif foo == '<STR_LIT:name>' : <EOL> self . byName ( criteria ) <EOL> elif foo == '<STR_LIT>' : <EOL> self . byPid ( criteria ) <EOL> def show ( self ) : <EOL> prettyOut = { } <EOL> if len ( self . interestingProcs ) > <NUM_LIT:0> : <EOL> for proc in self . interestingProcs : <EOL>", "answer": "prettyOut [ proc [ <NUM_LIT:0> ] ] = proc [ <NUM_LIT:1> ]"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . import sessions <EOL> def request ( method , url , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> session = sessions . Session ( ) <EOL> response = session . request ( method = method , url = url , ** kwargs ) <EOL> session . close ( ) <EOL> return response <EOL>", "answer": "def get ( url , ** kwargs ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Tangible ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = - <NUM_LIT:1>"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import numpy as np <EOL> from pandas import * <EOL> import pandas . core . sparse as spm <EOL> import pandas . compat as compat <EOL> reload ( spm ) <EOL> from pandas . core . sparse import * <EOL> N = <NUM_LIT> <EOL> arr1 = np . arange ( N ) <EOL> index = Index ( np . arange ( N ) ) <EOL> off = N // <NUM_LIT:10> <EOL> arr1 [ off : <NUM_LIT:2> * off ] = np . NaN <EOL> arr1 [ <NUM_LIT:4> * off : <NUM_LIT:5> * off ] = np . NaN <EOL> arr1 [ <NUM_LIT:8> * off : <NUM_LIT:9> * off ] = np . NaN <EOL> arr2 = np . arange ( N ) <EOL> arr2 [ <NUM_LIT:3> * off // <NUM_LIT:2> : <NUM_LIT:2> * off + off // <NUM_LIT:2> ] = np . NaN <EOL> arr2 [ <NUM_LIT:8> * off + off // <NUM_LIT:2> : <NUM_LIT:9> * off + off // <NUM_LIT:2> ] = np . NaN <EOL> s1 = SparseSeries ( arr1 , index = index ) <EOL> s2 = SparseSeries ( arr2 , index = index ) <EOL> is1 = SparseSeries ( arr1 , kind = '<STR_LIT>' , index = index ) <EOL> is2 = SparseSeries ( arr2 , kind = '<STR_LIT>' , index = index ) <EOL> s1_dense = s1 . to_dense ( ) <EOL> s2_dense = s2 . to_dense ( ) <EOL> if compat . is_platform_linux ( ) : <EOL> pth = '<STR_LIT>' <EOL> else : <EOL> pth = '<STR_LIT>' <EOL> dm = DataFrame . load ( pth ) <EOL> sdf = dm . to_sparse ( ) <EOL> def new_data_like ( sdf ) : <EOL> new_data = { } <EOL> for col , series in compat . iteritems ( sdf ) : <EOL> new_data [ col ] = SparseSeries ( np . random . randn ( len ( series . sp_values ) ) , <EOL> index = sdf . index , <EOL> sparse_index = series . sp_index , <EOL> fill_value = series . fill_value ) <EOL> return SparseDataFrame ( new_data ) <EOL> dwp = Panel . fromDict ( { '<STR_LIT:foo>' : dm } ) <EOL> lp = stack_sparse_frame ( sdf ) <EOL> swp = SparsePanel ( { '<STR_LIT:A>' : sdf } ) <EOL> swp = SparsePanel ( { '<STR_LIT:A>' : sdf , <EOL> '<STR_LIT:B>' : sdf , <EOL> '<STR_LIT:C>' : sdf , <EOL> '<STR_LIT:D>' : sdf } ) <EOL> y = sdf <EOL> x = SparsePanel ( { '<STR_LIT>' : sdf + new_data_like ( sdf ) / <NUM_LIT:10> , <EOL> '<STR_LIT>' : sdf + new_data_like ( sdf ) / <NUM_LIT:10> } ) <EOL> dense_y = sdf <EOL> dense_x = x . to_dense ( ) <EOL>", "answer": "dense_model = ols ( y = dense_y , x = dense_x )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import unittest <EOL> from ... compatibility import StringIO <EOL> from ... format import Format <EOL> class TestInitialisation ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . fh = StringIO ( ) <EOL> self . format = Format ( ) <EOL> self . format . _set_filehandle ( self . fh ) <EOL> def test_xml_declaration ( self ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = <NUM_LIT:8> <EOL>", "answer": "result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from homeassistant . components . thermostat import ThermostatDevice <EOL> from homeassistant . const import TEMP_CELSIUS , TEMP_FAHRENHEIT <EOL> def setup_platform ( hass , config , add_devices , discovery_info = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> add_devices ( [ <EOL> DemoThermostat ( \"<STR_LIT>\" , <NUM_LIT> , TEMP_CELSIUS , False , <NUM_LIT> , False ) , <EOL> DemoThermostat ( \"<STR_LIT>\" , <NUM_LIT> , TEMP_FAHRENHEIT , True , <NUM_LIT> , True ) , <EOL> ] ) <EOL> class DemoThermostat ( ThermostatDevice ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , name , target_temperature , unit_of_measurement , <EOL> away , current_temperature , is_fan_on ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _name = name <EOL> self . _target_temperature = target_temperature <EOL> self . _unit_of_measurement = unit_of_measurement <EOL> self . _away = away <EOL> self . _current_temperature = current_temperature <EOL> self . _is_fan_on = is_fan_on <EOL> @ property <EOL> def should_poll ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return False <EOL> @ property <EOL> def name ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _name <EOL> @ property <EOL> def unit_of_measurement ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _unit_of_measurement <EOL> @ property <EOL> def current_temperature ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _current_temperature <EOL> @ property <EOL> def target_temperature ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _target_temperature <EOL> @ property <EOL> def is_away_mode_on ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _away <EOL> @ property <EOL> def is_fan_on ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _is_fan_on <EOL> def set_temperature ( self , temperature ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _target_temperature = temperature <EOL> def turn_away_mode_on ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "self . _away = True"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL> import flask <EOL> from flask . ext . socketio import SocketIO <EOL> from gevent import monkey ; monkey . patch_all ( ) <EOL> from . config import config_value <EOL> from digits import utils <EOL> import digits . scheduler <EOL> app = flask . Flask ( __name__ ) <EOL> app . config [ '<STR_LIT>' ] = True <EOL> app . config [ '<STR_LIT>' ] = False <EOL> app . config [ '<STR_LIT>' ] = config_value ( '<STR_LIT>' ) <EOL> app . url_map . redirect_defaults = False <EOL> socketio = SocketIO ( app ) <EOL> scheduler = digits . scheduler . Scheduler ( config_value ( '<STR_LIT>' ) , True ) <EOL> app . jinja_env . globals [ '<STR_LIT>' ] = config_value ( '<STR_LIT>' ) <EOL> app . jinja_env . globals [ '<STR_LIT>' ] = digits . __version__ <EOL> app . jinja_env . filters [ '<STR_LIT>' ] = utils . time_filters . print_time <EOL> app . jinja_env . filters [ '<STR_LIT>' ] = utils . time_filters . print_time_diff <EOL> app . jinja_env . filters [ '<STR_LIT>' ] = utils . time_filters . print_time_since <EOL> app . jinja_env . filters [ '<STR_LIT>' ] = utils . sizeof_fmt <EOL> app . jinja_env . filters [ '<STR_LIT>' ] = utils . auth . has_permission <EOL> app . jinja_env . trim_blocks = True <EOL> app . jinja_env . lstrip_blocks = True <EOL> import digits . views <EOL> app . register_blueprint ( digits . views . blueprint ) <EOL> import digits . dataset . views <EOL> app . register_blueprint ( digits . dataset . views . blueprint , url_prefix = '<STR_LIT>' ) <EOL> import digits . dataset . images . views <EOL> app . register_blueprint ( digits . dataset . images . views . blueprint , url_prefix = '<STR_LIT>' ) <EOL> import digits . dataset . images . classification . views <EOL> app . register_blueprint ( digits . dataset . images . classification . views . blueprint , url_prefix = '<STR_LIT>' ) <EOL> import digits . dataset . images . generic . views <EOL> app . register_blueprint ( digits . dataset . images . generic . views . blueprint , url_prefix = '<STR_LIT>' ) <EOL> import digits . model . views <EOL> app . register_blueprint ( digits . model . views . blueprint , url_prefix = '<STR_LIT>' ) <EOL> import digits . model . images . views <EOL>", "answer": "app . register_blueprint ( digits . model . images . views . blueprint , url_prefix = '<STR_LIT>' )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys <EOL> import urllib <EOL> PY3 = sys . version_info [ <NUM_LIT:0> ] == <NUM_LIT:3> <EOL> if PY3 : <EOL> from urllib import parse as urlparse <EOL> def to_string ( s ) : <EOL> if isinstance ( s , str ) : <EOL> return s <EOL> return str ( s , '<STR_LIT>' ) <EOL> def to_wsgi_safe_string ( s ) : <EOL> return urlparse . quote ( to_string ( s ) ) <EOL> def from_wsgi_safe_string ( s ) : <EOL>", "answer": "return urlparse . unquote ( s )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from . base import Base <EOL> class Pep0257Formatter ( Base ) : <EOL> name = '<STR_LIT>' <EOL> def decorators ( self , attributes ) : <EOL> return '<STR_LIT>' <EOL> def extends ( self , attributes ) : <EOL> return '<STR_LIT>' <EOL>", "answer": "def arguments ( self , attributes ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from test . test_support import * <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> if None : raise TestFailed , '<STR_LIT>' <EOL> if <NUM_LIT:0> : raise TestFailed , '<STR_LIT>' <EOL> if <NUM_LIT:0> L : raise TestFailed , '<STR_LIT>' <EOL> if <NUM_LIT:0.0> : raise TestFailed , '<STR_LIT>' <EOL> if '<STR_LIT>' : raise TestFailed , '<STR_LIT>' <EOL> if not <NUM_LIT:1> : raise TestFailed , '<STR_LIT>' <EOL> if not <NUM_LIT:1> L : raise TestFailed , '<STR_LIT>' <EOL> if not <NUM_LIT:1.0> : raise TestFailed , '<STR_LIT>' <EOL> if not '<STR_LIT:x>' : raise TestFailed , '<STR_LIT>' <EOL> if not { '<STR_LIT:x>' : <NUM_LIT:1> } : raise TestFailed , '<STR_LIT>' <EOL> def f ( ) : pass <EOL> class C : pass <EOL> import sys <EOL> x = C ( ) <EOL> if not f : raise TestFailed , '<STR_LIT>' <EOL> if not C : raise TestFailed , '<STR_LIT>' <EOL> if not sys : raise TestFailed , '<STR_LIT>' <EOL> if not x : raise TestFailed , '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> if <NUM_LIT:0> or <NUM_LIT:0> : raise TestFailed , '<STR_LIT>' <EOL> if <NUM_LIT:1> and <NUM_LIT:1> : pass <EOL> else : raise TestFailed , '<STR_LIT>' <EOL> if not <NUM_LIT:1> : raise TestFailed , '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> if <NUM_LIT:0> < <NUM_LIT:1> <= <NUM_LIT:1> == <NUM_LIT:1> >= <NUM_LIT:1> > <NUM_LIT:0> != <NUM_LIT:1> : pass <EOL> else : raise TestFailed , '<STR_LIT>' <EOL> if <NUM_LIT:0> L < <NUM_LIT:1> L <= <NUM_LIT:1> L == <NUM_LIT:1> L >= <NUM_LIT:1> L > <NUM_LIT:0> L != <NUM_LIT:1> L : pass <EOL> else : raise TestFailed , '<STR_LIT>' <EOL> if <NUM_LIT:0.0> < <NUM_LIT:1.0> <= <NUM_LIT:1.0> == <NUM_LIT:1.0> >= <NUM_LIT:1.0> > <NUM_LIT:0.0> != <NUM_LIT:1.0> : pass <EOL> else : raise TestFailed , '<STR_LIT>' <EOL> if '<STR_LIT>' < '<STR_LIT:a>' <= '<STR_LIT:a>' == '<STR_LIT:a>' < '<STR_LIT:abc>' < '<STR_LIT>' < '<STR_LIT:b>' : pass <EOL> else : raise TestFailed , '<STR_LIT>' <EOL> if None is None : pass <EOL> else : raise TestFailed , '<STR_LIT>' <EOL> try : float ( '<STR_LIT>' ) <EOL> except ValueError : pass <EOL> else : raise TestFailed , \"<STR_LIT>\" <EOL> try : float ( '<STR_LIT>' ) <EOL> except ValueError : pass <EOL> else : raise TestFailed , \"<STR_LIT>\" <EOL> try : <NUM_LIT> / <NUM_LIT:0.0> <EOL> except ZeroDivisionError : pass <EOL> else : raise TestFailed , \"<STR_LIT>\" <EOL> try : <NUM_LIT> // <NUM_LIT:0.0> <EOL> except ZeroDivisionError : pass <EOL> else : raise TestFailed , \"<STR_LIT>\" <EOL> try : <NUM_LIT> % <NUM_LIT:0.0> <EOL> except ZeroDivisionError : pass <EOL> else : raise TestFailed , \"<STR_LIT>\" <EOL> try : <NUM_LIT:5> / <NUM_LIT:0> L <EOL> except ZeroDivisionError : pass <EOL> else : raise TestFailed , \"<STR_LIT>\" <EOL> try : <NUM_LIT:5> // <NUM_LIT:0> L <EOL> except ZeroDivisionError : pass <EOL> else : raise TestFailed , \"<STR_LIT>\" <EOL> try : <NUM_LIT:5> % <NUM_LIT:0> L <EOL> except ZeroDivisionError : pass <EOL> else : raise TestFailed , \"<STR_LIT>\" <EOL> print '<STR_LIT>' <EOL> if <NUM_LIT:0> != <NUM_LIT:0> L or <NUM_LIT:0> != <NUM_LIT:0.0> or <NUM_LIT:0> L != <NUM_LIT:0.0> : raise TestFailed , '<STR_LIT>' <EOL> if <NUM_LIT:1> != <NUM_LIT:1> L or <NUM_LIT:1> != <NUM_LIT:1.0> or <NUM_LIT:1> L != <NUM_LIT:1.0> : raise TestFailed , '<STR_LIT>' <EOL> if - <NUM_LIT:1> != - <NUM_LIT:1> L or - <NUM_LIT:1> != - <NUM_LIT:1.0> or - <NUM_LIT:1> L != - <NUM_LIT:1.0> : <EOL> raise TestFailed , '<STR_LIT>' <EOL> if int ( ) != <NUM_LIT:0> : raise TestFailed , '<STR_LIT>' <EOL> if long ( ) != <NUM_LIT:0> L : raise TestFailed , '<STR_LIT>' <EOL> if float ( ) != <NUM_LIT:0.0> : raise TestFailed , '<STR_LIT>' <EOL> if int ( <NUM_LIT> ) == <NUM_LIT:1> == int ( <NUM_LIT> ) and int ( - <NUM_LIT> ) == - <NUM_LIT:1> == int ( - <NUM_LIT> ) : pass <EOL> else : raise TestFailed , '<STR_LIT>' <EOL> if long ( <NUM_LIT> ) == <NUM_LIT:1> L == long ( <NUM_LIT> ) and long ( - <NUM_LIT> ) == - <NUM_LIT:1> L == long ( - <NUM_LIT> ) : pass <EOL> else : raise TestFailed , '<STR_LIT>' <EOL> if float ( <NUM_LIT:1> ) == <NUM_LIT:1.0> and float ( - <NUM_LIT:1> ) == - <NUM_LIT:1.0> and float ( <NUM_LIT:0> ) == <NUM_LIT:0.0> : pass <EOL> else : raise TestFailed , '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> a = <NUM_LIT> <EOL> b = <NUM_LIT> * <NUM_LIT:2> <EOL> if a is not b : raise TestFailed , '<STR_LIT>' <EOL> if <NUM_LIT:12> + <NUM_LIT> != <NUM_LIT> : raise TestFailed , '<STR_LIT>' <EOL> if <NUM_LIT:12> + ( - <NUM_LIT> ) != - <NUM_LIT:12> : raise TestFailed , '<STR_LIT>' <EOL> if ( - <NUM_LIT:12> ) + <NUM_LIT> != <NUM_LIT:12> : raise TestFailed , '<STR_LIT>' <EOL> if ( - <NUM_LIT:12> ) + ( - <NUM_LIT> ) != - <NUM_LIT> : raise TestFailed , '<STR_LIT>' <EOL> if not <NUM_LIT:12> < <NUM_LIT> : raise TestFailed , '<STR_LIT>' <EOL> if not - <NUM_LIT> < - <NUM_LIT:12> : raise TestFailed , '<STR_LIT>' <EOL> xsize , ysize , zsize = <NUM_LIT> , <NUM_LIT> , <NUM_LIT:4> <EOL> if not ( xsize * ysize * zsize == zsize * xsize * ysize == <NUM_LIT> ) : <EOL> raise TestFailed , '<STR_LIT>' <EOL> m = - sys . maxint - <NUM_LIT:1> <EOL> for divisor in <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:8> , <NUM_LIT:16> , <NUM_LIT:32> : <EOL> j = m // divisor <EOL> prod = divisor * j <EOL> if prod != m : <EOL> raise TestFailed , \"<STR_LIT>\" % ( divisor , j , prod , m ) <EOL> if type ( prod ) is not int : <EOL> raise TestFailed , ( \"<STR_LIT>\" % <EOL> type ( prod ) ) <EOL> for divisor in <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:8> , <NUM_LIT:16> , <NUM_LIT:32> : <EOL> j = m // divisor - <NUM_LIT:1> <EOL> prod = divisor * j <EOL> if type ( prod ) is not long : <EOL> raise TestFailed , ( \"<STR_LIT>\" % <EOL> ( prod , type ( prod ) ) ) <EOL> m = sys . maxint <EOL> for divisor in <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:8> , <NUM_LIT:16> , <NUM_LIT:32> : <EOL> j = m // divisor + <NUM_LIT:1> <EOL> prod = divisor * j <EOL> if type ( prod ) is not long : <EOL> raise TestFailed , ( \"<STR_LIT>\" % <EOL> ( prod , type ( prod ) ) ) <EOL> print '<STR_LIT>' <EOL> if <NUM_LIT:12> L + <NUM_LIT> L != <NUM_LIT> L : raise TestFailed , '<STR_LIT>' <EOL> if <NUM_LIT:12> L + ( - <NUM_LIT> L ) != - <NUM_LIT:12> L : raise TestFailed , '<STR_LIT>' <EOL> if ( - <NUM_LIT:12> L ) + <NUM_LIT> L != <NUM_LIT:12> L : raise TestFailed , '<STR_LIT>' <EOL> if ( - <NUM_LIT:12> L ) + ( - <NUM_LIT> L ) != - <NUM_LIT> L : raise TestFailed , '<STR_LIT>' <EOL> if not <NUM_LIT:12> L < <NUM_LIT> L : raise TestFailed , '<STR_LIT>' <EOL> if not - <NUM_LIT> L < - <NUM_LIT:12> L : raise TestFailed , '<STR_LIT>' <EOL> x = sys . maxint <EOL> if int ( long ( x ) ) != x : raise TestFailed , '<STR_LIT>' <EOL> try : y = int ( long ( x ) + <NUM_LIT:1> L ) <EOL> except OverflowError : raise TestFailed , '<STR_LIT>' <EOL> if not isinstance ( y , long ) : raise TestFailed , '<STR_LIT>' <EOL> x = - x <EOL>", "answer": "if int ( long ( x ) ) != x : raise TestFailed , '<STR_LIT>'"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> MAIL_SERVER = '<STR_LIT>' <EOL> MAIL_PORT = <NUM_LIT> <EOL> MAIL_USE_TLS = False <EOL> MAIL_USE_SSL = True <EOL>", "answer": "MAIL_USERNAME = '<STR_LIT>'"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from swgpy . object import * <EOL> from swgpy . command import BaseSwgCommand <EOL> from swgpy import ACTION <EOL> class PeaceCommand ( BaseSwgCommand ) : <EOL> def getCommandName ( self ) : <EOL> return '<STR_LIT>' <EOL> def run ( self ) : <EOL> actor = self . getActor ( ) <EOL> target = self . getTarget ( ) <EOL>", "answer": "if actor . hasState ( ACTION . COMBAT ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import , unicode_literals <EOL> from rest_framework import viewsets , serializers <EOL> from dbaas_credentials . models import Credential <EOL> from . environment import EnvironmentSerializer <EOL> from . integration_type import CredentialTypeSerializer <EOL> class IntegrationCredentialSerializer ( serializers . HyperlinkedModelSerializer ) : <EOL> environments = EnvironmentSerializer ( many = True , read_only = True ) <EOL> integration_type = CredentialTypeSerializer ( many = False , read_only = True ) <EOL> class Meta : <EOL> model = Credential <EOL> fields = ( '<STR_LIT:user>' , '<STR_LIT:password>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "class IntegrationCredentialAPI ( viewsets . ModelViewSet ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> from os import environ <EOL> from aminator . config import conf_action <EOL> from aminator . plugins . finalizer . tagging_base import TaggingBaseFinalizerPlugin <EOL> from aminator . util . linux import sanitize_metadata <EOL> __all__ = ( '<STR_LIT>' , ) <EOL> log = logging . getLogger ( __name__ ) <EOL> class TaggingEBSFinalizerPlugin ( TaggingBaseFinalizerPlugin ) : <EOL> _name = '<STR_LIT>' <EOL> def add_plugin_args ( self ) : <EOL> tagging = super ( TaggingEBSFinalizerPlugin , self ) . add_plugin_args ( ) <EOL> context = self . _config . context <EOL> tagging . add_argument ( '<STR_LIT>' , '<STR_LIT>' , dest = '<STR_LIT:name>' , action = conf_action ( context . ami ) , help = '<STR_LIT>' ) <EOL> def _set_metadata ( self ) : <EOL> super ( TaggingEBSFinalizerPlugin , self ) . _set_metadata ( ) <EOL> context = self . _config . context <EOL> config = self . _config . plugins [ self . full_name ] <EOL> metadata = context . package . attributes <EOL> ami_name = context . ami . get ( '<STR_LIT:name>' , None ) <EOL> if not ami_name : <EOL> ami_name = config . name_format . format ( ** metadata ) <EOL> context . ami . name = sanitize_metadata ( '<STR_LIT>' . format ( ami_name ) ) <EOL> def _snapshot_volume ( self ) : <EOL> log . info ( '<STR_LIT>' ) <EOL> if not self . _cloud . snapshot_volume ( ) : <EOL> return False <EOL> log . info ( '<STR_LIT>' ) <EOL> return True <EOL> def _register_image ( self , block_device_map = None , root_device = None ) : <EOL> log . info ( '<STR_LIT>' ) <EOL> config = self . _config . plugins [ self . full_name ] <EOL> if block_device_map is None : <EOL> block_device_map = config . default_block_device_map <EOL> if root_device is None : <EOL> root_device = config . default_root_device <EOL> if not self . _cloud . register_image ( block_device_map , root_device ) : <EOL> return False <EOL> log . info ( '<STR_LIT>' ) <EOL> return True <EOL> def finalize ( self ) : <EOL> log . info ( '<STR_LIT>' ) <EOL> self . _set_metadata ( ) <EOL> if not self . _snapshot_volume ( ) : <EOL> log . critical ( '<STR_LIT>' ) <EOL> return False <EOL> if not self . _register_image ( ) : <EOL> log . critical ( '<STR_LIT>' ) <EOL> return False <EOL> if not self . _add_tags ( [ '<STR_LIT>' , '<STR_LIT>' ] ) : <EOL> log . critical ( '<STR_LIT>' ) <EOL> return False <EOL> log . info ( '<STR_LIT>' ) <EOL> self . _log_ami_metadata ( ) <EOL> return True <EOL> def __enter__ ( self ) : <EOL> context = self . _config . context <EOL> environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL>", "answer": "if context . ami . get ( \"<STR_LIT:name>\" , None ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from . import alexa_io <EOL> '''<STR_LIT>''' <EOL> ResponseBuilder = alexa_io . ResponseBuilder <EOL> alexa = alexa_io . VoiceHandler ( ) <EOL>", "answer": "Request = alexa_io . Request "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL> from django . conf import settings <EOL> CASCADE_PLUGINS = getattr ( settings , '<STR_LIT>' , <EOL>", "answer": "( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) ) "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> print type ( Ellipsis ) <EOL>", "answer": "print type ( Ellipsis ) . __base__ "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import , print_function <EOL> class FakeTransport ( object ) : <EOL> _written = b\"<STR_LIT>\" <EOL> _open = True <EOL> def write ( self , msg ) : <EOL> if not self . _open : <EOL>", "answer": "raise Exception ( \"<STR_LIT>\" )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from vt_manager . communication . sfa . rspecs . elements . element import Element <EOL> class Interface ( Element ) : <EOL> fields = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from os import path <EOL> PROJECT_ROOT = path . dirname ( path . realpath ( __file__ ) ) <EOL> DISTRIBUTION_ROOT = path . split ( PROJECT_ROOT ) [ <NUM_LIT:0> ] <EOL> DEBUG = True <EOL> TEMPLATE_DEBUG = DEBUG <EOL> ADMINS = ( <EOL> ) <EOL> MANAGERS = ADMINS <EOL> DATABASES = { <EOL> '<STR_LIT:default>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : path . join ( DISTRIBUTION_ROOT , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> } <EOL> TIME_ZONE = '<STR_LIT>' <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> SITE_ID = <NUM_LIT:1> <EOL> USE_I18N = True <EOL> USE_L10N = True <EOL> MEDIA_ROOT = DISTRIBUTION_ROOT + '<STR_LIT>' <EOL> MEDIA_URL = '<STR_LIT>' <EOL> STATIC_ROOT = DISTRIBUTION_ROOT + '<STR_LIT>' <EOL> STATIC_URL = '<STR_LIT>' <EOL> ADMIN_MEDIA_PREFIX = '<STR_LIT>' <EOL> STATICFILES_DIRS = ( <EOL> ) <EOL> STATICFILES_FINDERS = ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) <EOL> SECRET_KEY = '<STR_LIT>' <EOL> TEMPLATE_LOADERS = ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) <EOL> MIDDLEWARE_CLASSES = ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATE_DIRS = ( <EOL> DISTRIBUTION_ROOT + '<STR_LIT>' , <EOL> ) <EOL> INSTALLED_APPS = ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": ")"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import unicode_literals <EOL> import logging <EOL> import sys <EOL> import threading <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> def black ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def red ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def green ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def yellow ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def blue ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def magenta ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def cyan ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def white ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def bright_black ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def bright_red ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def bright_green ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def bright_yellow ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def bright_blue ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def bright_magenta ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def bright_cyan ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> def bright_white ( s ) : <EOL> return \"<STR_LIT>\" . format ( s ) <EOL> class ColourFormatter ( logging . Formatter ) : <EOL> def format ( self , record ) : <EOL> s = super ( ColourFormatter , self ) . format ( record ) <EOL> if record . levelno == logging . CRITICAL : <EOL> return bright_red ( s ) <EOL>", "answer": "elif record . levelno == logging . ERROR :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from flask . ext . assets import ManageAssets <EOL>", "answer": "from flask . ext . script import Manager"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from users . tests . views import * <EOL>", "answer": "from users . tests . models import * "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . shortcuts import render <EOL> from django . utils . translation import ugettext as _ <EOL> from freenasUI . freeadmin . apppool import appPool <EOL>", "answer": "from freenasUI . freeadmin . views import JsonResp"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . test . simple import DjangoTestRunner , DjangoTestSuiteRunner <EOL> from noseachievements . plugin import AchievementsPlugin <EOL> from noseachievements . result import AchievementsTestResult <EOL> from noseachievements . runner import AchievementsTestRunner <EOL> class AchievementsDjangoTestResult ( AchievementsTestResult ) : <EOL> def stopTest ( self , test ) : <EOL> super ( AchievementsDjangoTestResult , self ) . stopTest ( test ) <EOL> if ( ( self . _runner . failfast and not self . wasSuccessful ( ) ) or <EOL> self . _runner . _keyboard_interrupt_intercepted ) : <EOL> self . stop ( ) <EOL> class AchievementsDjangoTestRunner ( DjangoTestRunner , AchievementsTestRunner ) : <EOL> _result_class = AchievementsDjangoTestResult <EOL> def _makeResult ( self ) : <EOL> result = super ( AchievementsDjangoTestRunner , self ) . _makeResult ( ) <EOL> result . _runner = self <EOL> return result <EOL> class AchievementsDjangoTestSuiteRunner ( DjangoTestSuiteRunner ) : <EOL> _runner_class = AchievementsDjangoTestRunner <EOL>", "answer": "def run_suite ( self , suite , ** kwargs ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> revision = '<STR_LIT>' <EOL> down_revision = '<STR_LIT>' <EOL>", "answer": "from alembic import op"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from south . utils import datetime_utils as datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . delete_column ( u'<STR_LIT>' , '<STR_LIT>' ) <EOL> def backwards ( self , orm ) : <EOL> db . add_column ( u'<STR_LIT>' , '<STR_LIT>' , <EOL> self . gf ( '<STR_LIT>' ) ( default = False ) , <EOL> keep_default = False ) <EOL> models = { <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : u\"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : u\"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : u\"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL>", "answer": "'<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys , os <EOL> import re <EOL> from pycopia import proctools <EOL> DOW = { <EOL> <NUM_LIT:0> : \"<STR_LIT>\" , <EOL> <NUM_LIT:1> : \"<STR_LIT>\" , <EOL> <NUM_LIT:2> : \"<STR_LIT>\" , <EOL> <NUM_LIT:3> : \"<STR_LIT>\" , <EOL> <NUM_LIT:4> : \"<STR_LIT>\" , <EOL> <NUM_LIT:5> : \"<STR_LIT>\" , <EOL> <NUM_LIT:6> : \"<STR_LIT>\" , <EOL> <NUM_LIT:7> : \"<STR_LIT>\" <EOL> } <EOL> MONTHS = { <EOL> <NUM_LIT:1> : \"<STR_LIT>\" , <EOL> <NUM_LIT:2> : \"<STR_LIT>\" , <EOL> <NUM_LIT:3> : \"<STR_LIT>\" , <EOL> <NUM_LIT:4> : \"<STR_LIT>\" , <EOL> <NUM_LIT:5> : \"<STR_LIT>\" , <EOL> <NUM_LIT:6> : \"<STR_LIT>\" , <EOL> <NUM_LIT:7> : \"<STR_LIT>\" , <EOL> <NUM_LIT:8> : \"<STR_LIT>\" , <EOL> <NUM_LIT:9> : \"<STR_LIT>\" , <EOL> <NUM_LIT:10> : \"<STR_LIT>\" , <EOL> <NUM_LIT:11> : \"<STR_LIT>\" , <EOL> <NUM_LIT:12> : \"<STR_LIT>\" , <EOL> } <EOL> class Comment ( object ) : <EOL> def __init__ ( self , text ) : <EOL> self . text = text <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . text , ) <EOL> def match ( self , pattern ) : <EOL> if re . match ( pattern , self . text ) : <EOL> return True <EOL> return False <EOL> class Variable ( object ) : <EOL> def __init__ ( self , name , value ) : <EOL> self . name = name <EOL> self . value = value <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % ( self . name , self . value ) <EOL> def match ( self , value = None , name = None ) : <EOL> nv = vv = False <EOL> if value : <EOL> if re . search ( value , self . value ) : <EOL> vv = True <EOL> else : <EOL> vv = False <EOL> if name : <EOL> if re . search ( name , self . name ) : <EOL> nv = True <EOL> else : <EOL> nv = False <EOL> if name and value : <EOL> return nv and vv <EOL> if name and not value : <EOL> return nv <EOL> if not name and value : <EOL> return vv <EOL> if not name and not value : <EOL> return False <EOL> class BlankLine ( object ) : <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" <EOL> def match ( self , pattern = None ) : <EOL> return False <EOL> class CrontabLine ( object ) : <EOL> def __init__ ( self , cmd , minute = None , hour = None , day_of_month = None , <EOL> month = None , day_of_week = None ) : <EOL> self . minute = Minutes ( minute ) <EOL> self . hour = Hours ( hour ) <EOL> self . day_of_month = DayOfMonth ( day_of_month ) <EOL> self . month = Month ( month ) <EOL> self . day_of_week = DayOfWeek ( day_of_week ) <EOL> self . command = cmd <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( <EOL> self . minute , <EOL> self . hour , <EOL> self . day_of_month , <EOL> self . month , <EOL> self . day_of_week , <EOL> self . command ) <EOL> def match ( self , command = None , minute = None , hour = None , day_of_month = None , <EOL> month = None , day_of_week = None ) : <EOL> if command : <EOL> if re . search ( command , self . command ) is None : <EOL> return False <EOL> for attr , check in ( ( self . minute , minute ) , ( self . hour , hour ) , <EOL> ( self . day_of_month , day_of_month ) , <EOL> ( self . month , month ) , ( self . day_of_week , day_of_week ) ) : <EOL> if check is not None : <EOL> checker = attr . new ( check ) <EOL> if checker != attr : <EOL> return False <EOL> return True <EOL> class Selection ( object ) : <EOL> def __init__ ( self , start , end ) : <EOL> self . start = start <EOL> self . end = end <EOL> class CrontabFile ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> BLANK_RE = re . compile ( r\"<STR_LIT>\" ) <EOL> VARIABLE_RE = re . compile ( r\"<STR_LIT>\" ) <EOL> COMMENT_RE = re . compile ( r\"<STR_LIT>\" ) <EOL> def __init__ ( self , text = None , filename = None , username = None ) : <EOL> self . filename = filename <EOL> self . username = username <EOL> if text : <EOL> self . _lines = self . parse ( text ) <EOL> else : <EOL>", "answer": "self . _lines = [ ]"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from . . builder import create_and_build , Builder <EOL> from . . utils import ( build_wedge_source , build_wedge_text_source , <EOL> build_agg_tooltip , derive_aggregation ) <EOL> from . . attributes import ColorAttr , CatAttr <EOL> from ... models . sources import ColumnDataSource <EOL> from ... models . glyphs import AnnularWedge , Text <EOL> from ... models . renderers import GlyphRenderer <EOL> from ... models . ranges import Range1d <EOL> from . . properties import Dimension <EOL> from ... core . properties import String , Instance , Float , Color , Either , List <EOL> def Donut ( data , label = '<STR_LIT:index>' , values = None , color = None , agg = None , <EOL> hover_tool = True , hover_text = None , plot_height = <NUM_LIT> , plot_width = <NUM_LIT> , <EOL> xgrid = False , ygrid = False , ** kw ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> kw [ '<STR_LIT:label>' ] = label <EOL> kw [ '<STR_LIT>' ] = values <EOL> kw [ '<STR_LIT>' ] = color <EOL> kw [ '<STR_LIT>' ] = xgrid <EOL> kw [ '<STR_LIT>' ] = ygrid <EOL> kw [ '<STR_LIT>' ] = plot_height <EOL> kw [ '<STR_LIT>' ] = plot_width <EOL> if agg is not None : <EOL> kw [ '<STR_LIT>' ] = agg <EOL> chart = create_and_build ( DonutBuilder , data , ** kw ) <EOL> chart . left [ <NUM_LIT:0> ] . visible = False <EOL> chart . below [ <NUM_LIT:0> ] . visible = False <EOL>", "answer": "values , agg = derive_aggregation ( dim_cols = label , agg_col = values , agg = agg )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from . tf_linear_regression import TfLinearRegression <EOL>", "answer": "__all__ = [ \"<STR_LIT>\" ] "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import logging <EOL> from memegen . settings import ProdConfig <EOL> from memegen . app import create_app <EOL> from memegen . domain import Text <EOL> def main ( ) : <EOL> logging . info ( \"<STR_LIT>\" ) <EOL> app = create_app ( ProdConfig ) <EOL> with app . app_context ( ) : <EOL> for template in app . template_service . all ( ) : <EOL> app . image_service . create ( template , Text ( \"<STR_LIT:_>\" ) ) <EOL> app . image_service . create ( template , Text ( \"<STR_LIT>\" ) ) <EOL> app . image_service . create ( template , template . sample_text ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL>", "answer": "main ( ) "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import sys <EOL> import unittest <EOL> from libcloud . common . types import LazyList <EOL> class TestLazyList ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( TestLazyList , self ) . setUp <EOL> self . _get_more_counter = <NUM_LIT:0> <EOL> def tearDown ( self ) : <EOL> super ( TestLazyList , self ) . tearDown <EOL> def test_init ( self ) : <EOL> data = [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> ] <EOL> ll = LazyList ( get_more = self . _get_more_exhausted ) <EOL> ll_list = list ( ll ) <EOL> self . assertEqual ( ll_list , data ) <EOL> def test_iterator ( self ) : <EOL> data = [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> ] <EOL> ll = LazyList ( get_more = self . _get_more_exhausted ) <EOL> for i , d in enumerate ( ll ) : <EOL> self . assertEqual ( d , data [ i ] ) <EOL> def test_empty_list ( self ) : <EOL> ll = LazyList ( get_more = self . _get_more_empty ) <EOL> self . assertEqual ( list ( ll ) , [ ] ) <EOL> self . assertEqual ( len ( ll ) , <NUM_LIT:0> ) <EOL> self . assertTrue ( <NUM_LIT:10> not in ll ) <EOL> def test_iterator_not_exhausted ( self ) : <EOL> data = [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> , <NUM_LIT:6> , <NUM_LIT:7> , <NUM_LIT:8> , <NUM_LIT:9> , <NUM_LIT:10> ] <EOL> ll = LazyList ( get_more = self . _get_more_not_exhausted ) <EOL> number_of_iterations = <NUM_LIT:0> <EOL> for i , d in enumerate ( ll ) : <EOL> self . assertEqual ( d , data [ i ] ) <EOL> number_of_iterations += <NUM_LIT:1> <EOL> self . assertEqual ( number_of_iterations , <NUM_LIT:10> ) <EOL> def test_len ( self ) : <EOL> ll = LazyList ( get_more = self . _get_more_not_exhausted ) <EOL> ll = LazyList ( get_more = self . _get_more_not_exhausted ) <EOL> self . assertEqual ( len ( ll ) , <NUM_LIT:10> ) <EOL> def test_contains ( self ) : <EOL> ll = LazyList ( get_more = self . _get_more_not_exhausted ) <EOL> self . assertTrue ( <NUM_LIT> not in ll ) <EOL> self . assertTrue ( <NUM_LIT:1> in ll ) <EOL> self . assertTrue ( <NUM_LIT:5> in ll ) <EOL> self . assertTrue ( <NUM_LIT:10> in ll ) <EOL> def test_indexing ( self ) : <EOL> ll = LazyList ( get_more = self . _get_more_not_exhausted ) <EOL> self . assertEqual ( ll [ <NUM_LIT:0> ] , <NUM_LIT:1> ) <EOL> self . assertEqual ( ll [ <NUM_LIT:9> ] , <NUM_LIT:10> ) <EOL> self . assertEqual ( ll [ - <NUM_LIT:1> ] , <NUM_LIT:10> ) <EOL> try : <EOL> ll [ <NUM_LIT:11> ] <EOL> except IndexError : <EOL> pass <EOL> else : <EOL> self . fail ( '<STR_LIT>' ) <EOL> def test_repr ( self ) : <EOL> ll1 = LazyList ( get_more = self . _get_more_empty ) <EOL> ll2 = LazyList ( get_more = self . _get_more_exhausted ) <EOL> ll3 = LazyList ( get_more = self . _get_more_not_exhausted ) <EOL> self . assertEqual ( repr ( ll1 ) , '<STR_LIT>' ) <EOL> self . assertEqual ( repr ( ll2 ) , '<STR_LIT>' ) <EOL> self . assertEqual ( repr ( ll3 ) , '<STR_LIT>' ) <EOL> def _get_more_empty ( self , last_key , value_dict ) : <EOL>", "answer": "return [ ] , None , True"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import platform <EOL> import re <EOL> from awscli . compat import urlopen , URLError <EOL> from awscli . customizations . codedeploy . systems import System , Ubuntu , Windows , RHEL <EOL> from socket import timeout <EOL> MAX_INSTANCE_NAME_LENGTH = <NUM_LIT:100> <EOL> MAX_TAGS_PER_INSTANCE = <NUM_LIT:10> <EOL> MAX_TAG_KEY_LENGTH = <NUM_LIT> <EOL> MAX_TAG_VALUE_LENGTH = <NUM_LIT> <EOL> INSTANCE_NAME_PATTERN = r'<STR_LIT>' <EOL> IAM_USER_ARN_PATTERN = r'<STR_LIT>' <EOL> INSTANCE_NAME_ARG = { <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : ( <EOL> '<STR_LIT>' <EOL> ) <EOL> } <EOL> IAM_USER_ARN_ARG = { <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : ( <EOL> '<STR_LIT>' <EOL> ) <EOL> } <EOL> def validate_region ( params , parsed_globals ) : <EOL> if parsed_globals . region : <EOL> params . region = parsed_globals . region <EOL> else : <EOL> params . region = params . session . get_config_variable ( '<STR_LIT>' ) <EOL> if not params . region : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> def validate_instance_name ( params ) : <EOL> if params . instance_name : <EOL> if not re . match ( INSTANCE_NAME_PATTERN , params . instance_name ) : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> if params . instance_name . startswith ( '<STR_LIT>' ) : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> if len ( params . instance_name ) > MAX_INSTANCE_NAME_LENGTH : <EOL> raise ValueError ( <EOL> '<STR_LIT>' . format ( <EOL> MAX_INSTANCE_NAME_LENGTH <EOL> ) <EOL> ) <EOL> def validate_tags ( params ) : <EOL> if params . tags : <EOL> if len ( params . tags ) > MAX_TAGS_PER_INSTANCE : <EOL> raise ValueError ( <EOL> '<STR_LIT>' . format ( <EOL> MAX_TAGS_PER_INSTANCE <EOL> ) <EOL> ) <EOL> for tag in params . tags : <EOL> if len ( tag [ '<STR_LIT>' ] ) > MAX_TAG_KEY_LENGTH : <EOL> raise ValueError ( <EOL> '<STR_LIT>' . format ( <EOL> MAX_TAG_KEY_LENGTH <EOL> ) <EOL> ) <EOL> if len ( tag [ '<STR_LIT>' ] ) > MAX_TAG_KEY_LENGTH : <EOL> raise ValueError ( <EOL> '<STR_LIT>' . format ( <EOL> MAX_TAG_VALUE_LENGTH <EOL> ) <EOL> ) <EOL> def validate_iam_user_arn ( params ) : <EOL> if params . iam_user_arn and not re . match ( IAM_USER_ARN_PATTERN , params . iam_user_arn ) : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> def validate_instance ( params ) : <EOL> if platform . system ( ) == '<STR_LIT>' : <EOL> if '<STR_LIT>' in platform . linux_distribution ( ) [ <NUM_LIT:0> ] : <EOL> params . system = Ubuntu ( params ) <EOL> if '<STR_LIT>' in platform . linux_distribution ( ) [ <NUM_LIT:0> ] : <EOL> params . system = RHEL ( params ) <EOL> elif platform . system ( ) == '<STR_LIT>' : <EOL> params . system = Windows ( params ) <EOL> if '<STR_LIT>' not in params : <EOL> raise RuntimeError ( <EOL> System . UNSUPPORTED_SYSTEM_MSG <EOL> ) <EOL> try : <EOL> urlopen ( '<STR_LIT>' , timeout = <NUM_LIT:1> ) <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> except ( URLError , timeout ) : <EOL> pass <EOL> def validate_s3_location ( params , arg_name ) : <EOL> arg_name = arg_name . replace ( '<STR_LIT:->' , '<STR_LIT:_>' ) <EOL> if arg_name in params : <EOL> s3_location = getattr ( params , arg_name ) <EOL> if s3_location : <EOL> matcher = re . match ( '<STR_LIT>' , str ( s3_location ) ) <EOL> if matcher : <EOL> params . bucket = matcher . group ( <NUM_LIT:1> ) <EOL> params . key = matcher . group ( <NUM_LIT:2> ) <EOL> else : <EOL> raise ValueError ( <EOL> '<STR_LIT>' <EOL>", "answer": "'<STR_LIT>' . format ("}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . conf import settings <EOL> from django . conf . urls import include , url <EOL> from rest_framework . authtoken import views <EOL> from ralph . admin import ralph_site as admin <EOL> from ralph . api import router <EOL> api_urls = list ( map ( lambda u : url ( r'<STR_LIT>' , include ( u ) ) , [ <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import glob <EOL> import shutil <EOL> def create_file ( path ) : <EOL> '''<STR_LIT>''' <EOL> with open ( path , '<STR_LIT:w>' ) as f : <EOL> f . write ( \"<STR_LIT>\" . format ( path ) ) <EOL> f . write ( \"<STR_LIT>\" ) <EOL> def delete_file ( path ) : <EOL> '''<STR_LIT>''' <EOL> os . remove ( path ) <EOL> def path_exists ( path ) : <EOL> '''<STR_LIT>''' <EOL> return os . path . exists ( path ) <EOL>", "answer": "def get_glob ( glob_path ) :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import absolute_import <EOL> from . about_dialog import AboutDialog <EOL> from . application_window import ApplicationWindow <EOL> from . beep import beep <EOL> from . clipboard import clipboard , Clipboard <EOL> from . confirmation_dialog import confirm , ConfirmationDialog <EOL> from . constant import OK , CANCEL , YES , NO <EOL> from . dialog import Dialog <EOL> from . directory_dialog import DirectoryDialog <EOL> from . file_dialog import FileDialog <EOL> from . filter import Filter <EOL> from . gui import GUI <EOL> from . heading_text import HeadingText <EOL> from . image_cache import ImageCache <EOL> from . image_resource import ImageResource <EOL> from . key_pressed_event import KeyPressedEvent <EOL> from . message_dialog import error , information , warning , MessageDialog <EOL> from . progress_dialog import ProgressDialog <EOL> from . python_editor import PythonEditor <EOL> from . python_shell import PythonShell <EOL> from . sorter import Sorter <EOL> from . splash_screen import SplashScreen <EOL> from . split_application_window import SplitApplicationWindow <EOL> from . split_dialog import SplitDialog <EOL> from . split_panel import SplitPanel <EOL> from . system_metrics import SystemMetrics <EOL> from . window import Window <EOL> from . widget import Widget <EOL> from traits . etsconfig . api import ETSConfig <EOL> if ETSConfig . toolkit == '<STR_LIT>' : <EOL> from . expandable_panel import ExpandablePanel <EOL> from . image_widget import ImageWidget <EOL> from . layered_panel import LayeredPanel <EOL> from . mdi_application_window import MDIApplicationWindow <EOL> from . mdi_window_menu import MDIWindowMenu <EOL>", "answer": "from . multi_toolbar_window import MultiToolbarWindow"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import socket <EOL> import sys <EOL> from oslo_config import cfg <EOL> from oslo_serialization import jsonutils <EOL> from oslo_utils import importutils <EOL> from neutron . common import config as common_config <EOL> from dragonflow . common import common_params <EOL> from dragonflow . common import exceptions as df_exceptions <EOL> cfg . CONF . register_opts ( common_params . df_opts , '<STR_LIT>' ) <EOL> db_tables = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> usage_str = \"<STR_LIT>\" \"<STR_LIT>\" \"<STR_LIT>\" \"<STR_LIT>\" \"<STR_LIT>\" \"<STR_LIT>\" \"<STR_LIT>\" <EOL> def print_tables ( ) : <EOL> print ( '<STR_LIT:U+0020>' ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' ) <EOL> for table in db_tables : <EOL> print table <EOL> print ( '<STR_LIT:U+0020>' ) <EOL> def print_table ( db_driver , table ) : <EOL> try : <EOL> keys = db_driver . get_all_keys ( table ) <EOL> except df_exceptions . DBKeyNotFound : <EOL> keys = [ ] <EOL> print ( '<STR_LIT:U+0020>' ) <EOL> print ( '<STR_LIT>' + table ) <EOL> print ( '<STR_LIT>' ) <EOL> for key in keys : <EOL> print key <EOL> print ( '<STR_LIT:U+0020>' ) <EOL> def print_whole_table ( db_driver , table ) : <EOL> try : <EOL> keys = db_driver . get_all_keys ( table ) <EOL> except df_exceptions . DBKeyNotFound : <EOL> print ( '<STR_LIT>' + table ) <EOL> return <EOL> print ( '<STR_LIT:U+0020>' ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' + table ) <EOL> print ( '<STR_LIT>' ) <EOL> for key in keys : <EOL> value = db_driver . get_key ( table , key ) <EOL> if value : <EOL> print ( '<STR_LIT>' + key + '<STR_LIT>' + value ) <EOL> print ( '<STR_LIT:U+0020>' ) <EOL> def print_key ( db_driver , table , key ) : <EOL> try : <EOL> value = db_driver . get_key ( table , key ) <EOL> except df_exceptions . DBKeyNotFound : <EOL> print ( '<STR_LIT>' + table ) <EOL> return <EOL> print ( '<STR_LIT:U+0020>' ) <EOL> print ( '<STR_LIT>' + table + '<STR_LIT>' + key ) <EOL> print ( '<STR_LIT>' ) <EOL> print value <EOL> print ( '<STR_LIT:U+0020>' ) <EOL> def bind_port_to_localhost ( db_driver , port_id ) : <EOL> lport_str = db_driver . get_key ( '<STR_LIT>' , port_id ) <EOL> lport = jsonutils . loads ( lport_str ) <EOL> chassis_name = socket . gethostname ( ) <EOL> lport [ '<STR_LIT>' ] = chassis_name <EOL> lport_json = jsonutils . dumps ( lport ) <EOL> db_driver . set_key ( '<STR_LIT>' , port_id , lport_json ) <EOL> def clean_whole_table ( db_driver , table ) : <EOL> try : <EOL> keys = db_driver . get_all_keys ( table ) <EOL> except df_exceptions . DBKeyNotFound : <EOL> print ( '<STR_LIT>' + table ) <EOL> return <EOL> for key in keys : <EOL> db_driver . delete_key ( table , key ) <EOL> print ( '<STR_LIT>' ) <EOL> def remove_record ( db_driver , table , key ) : <EOL> try : <EOL> db_driver . delete_key ( table , key ) <EOL> except df_exceptions . DBKeyNotFound : <EOL> print ( '<STR_LIT>' % ( key , table ) ) <EOL> def main ( ) : <EOL> if len ( sys . argv ) < <NUM_LIT:2> : <EOL> print usage_str <EOL> return <EOL> common_config . init ( [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> db_driver_class = importutils . import_class ( cfg . CONF . df . nb_db_class ) <EOL> db_driver = db_driver_class ( ) <EOL> db_driver . initialize ( db_ip = cfg . CONF . df . remote_db_ip , <EOL> db_port = cfg . CONF . df . remote_db_port , <EOL> config = cfg . CONF . df ) <EOL> action = sys . argv [ <NUM_LIT:1> ] <EOL> if action == '<STR_LIT>' : <EOL> if len ( sys . argv ) == <NUM_LIT:2> : <EOL> print_tables ( ) <EOL> return <EOL> table = sys . argv [ <NUM_LIT:2> ] <EOL> if table not in db_tables : <EOL> print \"<STR_LIT>\" <EOL> print db_tables <EOL> return <EOL> print_table ( db_driver , table ) <EOL> return <EOL> if action == '<STR_LIT>' : <EOL> if len ( sys . argv ) < <NUM_LIT:4> : <EOL> print \"<STR_LIT>\" <EOL> print usage_str <EOL> return <EOL> table = sys . argv [ <NUM_LIT:2> ] <EOL> if table not in db_tables : <EOL> print \"<STR_LIT>\" <EOL> print db_tables <EOL> return <EOL> key = sys . argv [ <NUM_LIT:3> ] <EOL> print_key ( db_driver , table , key ) <EOL> return <EOL> if action == '<STR_LIT>' : <EOL> for table in db_tables : <EOL> print_whole_table ( db_driver , table ) <EOL> return <EOL> if action == '<STR_LIT>' : <EOL> port_id = sys . argv [ <NUM_LIT:2> ] <EOL>", "answer": "bind_port_to_localhost ( db_driver , port_id )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import print_function <EOL> import os <EOL> import os . path <EOL> import sys <EOL> import string <EOL> import getopt <EOL> import re <EOL> import socket <EOL> import time <EOL> import threading <EOL> import io <EOL> import linecache <EOL> from code import InteractiveInterpreter <EOL> from platform import python_version , system <EOL> try : <EOL> from Tkinter import * <EOL> except ImportError : <EOL> print ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , file = sys . __stderr__ ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> import tkMessageBox <EOL> from idlelib . EditorWindow import EditorWindow , fixwordbreaks <EOL> from idlelib . FileList import FileList <EOL> from idlelib . ColorDelegator import ColorDelegator <EOL> from idlelib . UndoDelegator import UndoDelegator <EOL> from idlelib . OutputWindow import OutputWindow <EOL> from idlelib . configHandler import idleConf <EOL> from idlelib import rpc <EOL> from idlelib import Debugger <EOL> from idlelib import RemoteDebugger <EOL> from idlelib import macosxSupport <EOL> from idlelib import IOBinding <EOL> IDENTCHARS = string . ascii_letters + string . digits + \"<STR_LIT:_>\" <EOL> HOST = '<STR_LIT:127.0.0.1>' <EOL> PORT = <NUM_LIT:0> <EOL> try : <EOL> from signal import SIGTERM <EOL> except ImportError : <EOL> SIGTERM = <NUM_LIT:15> <EOL> warning_stream = sys . __stderr__ <EOL> import warnings <EOL> def idle_formatwarning ( message , category , filename , lineno , line = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> s = \"<STR_LIT>\" <EOL> s += '<STR_LIT>' % ( filename , lineno ) <EOL> if line is None : <EOL> line = linecache . getline ( filename , lineno ) <EOL> line = line . strip ( ) <EOL> if line : <EOL> s += \"<STR_LIT>\" % line <EOL> s += \"<STR_LIT>\" % ( category . __name__ , message ) <EOL> return s <EOL> def idle_showwarning ( <EOL> message , category , filename , lineno , file = None , line = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if file is None : <EOL> file = warning_stream <EOL> try : <EOL> file . write ( idle_formatwarning ( <EOL> message , category , filename , lineno , line = line ) ) <EOL> file . write ( \"<STR_LIT>\" ) <EOL> except ( AttributeError , IOError ) : <EOL> pass <EOL> _warnings_showwarning = None <EOL> def capture_warnings ( capture ) : <EOL> \"<STR_LIT>\" <EOL> global _warnings_showwarning <EOL> if capture : <EOL> if _warnings_showwarning is None : <EOL> _warnings_showwarning = warnings . showwarning <EOL> warnings . showwarning = idle_showwarning <EOL> else : <EOL> if _warnings_showwarning is not None : <EOL> warnings . showwarning = _warnings_showwarning <EOL> _warnings_showwarning = None <EOL> capture_warnings ( True ) <EOL> def extended_linecache_checkcache ( filename = None , <EOL> orig_checkcache = linecache . checkcache ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cache = linecache . cache <EOL> save = { } <EOL> for key in list ( cache ) : <EOL> if key [ : <NUM_LIT:1> ] + key [ - <NUM_LIT:1> : ] == '<STR_LIT>' : <EOL> save [ key ] = cache . pop ( key ) <EOL> orig_checkcache ( filename ) <EOL> cache . update ( save ) <EOL> linecache . checkcache = extended_linecache_checkcache <EOL> class PyShellEditorWindow ( EditorWindow ) : <EOL> \"<STR_LIT>\" <EOL> def __init__ ( self , * args ) : <EOL> self . breakpoints = [ ] <EOL> EditorWindow . __init__ ( self , * args ) <EOL> self . text . bind ( \"<STR_LIT>\" , self . set_breakpoint_here ) <EOL> self . text . bind ( \"<STR_LIT>\" , self . clear_breakpoint_here ) <EOL> self . text . bind ( \"<STR_LIT>\" , self . flist . open_shell ) <EOL> self . breakpointPath = os . path . join ( idleConf . GetUserCfgDir ( ) , <EOL> '<STR_LIT>' ) <EOL> def filename_changed_hook ( old_hook = self . io . filename_change_hook , <EOL> self = self ) : <EOL> self . restore_file_breaks ( ) <EOL> old_hook ( ) <EOL> self . io . set_filename_change_hook ( filename_changed_hook ) <EOL> if self . io . filename : <EOL> self . restore_file_breaks ( ) <EOL> self . color_breakpoint_text ( ) <EOL> rmenu_specs = [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" , None ) , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" , None ) <EOL> ] <EOL> def color_breakpoint_text ( self , color = True ) : <EOL> \"<STR_LIT>\" <EOL> if self . io is None : <EOL> return <EOL> if color : <EOL> theme = idleConf . GetOption ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:name>' ) <EOL> cfg = idleConf . GetHighlight ( theme , \"<STR_LIT>\" ) <EOL> else : <EOL> cfg = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } <EOL> self . text . tag_config ( '<STR_LIT>' , cfg ) <EOL> def set_breakpoint ( self , lineno ) : <EOL> text = self . text <EOL> filename = self . io . filename <EOL> text . tag_add ( \"<STR_LIT>\" , \"<STR_LIT>\" % lineno , \"<STR_LIT>\" % ( lineno + <NUM_LIT:1> ) ) <EOL> try : <EOL> self . breakpoints . index ( lineno ) <EOL> except ValueError : <EOL> self . breakpoints . append ( lineno ) <EOL> try : <EOL> debug = self . flist . pyshell . interp . debugger <EOL> debug . set_breakpoint_here ( filename , lineno ) <EOL> except : <EOL> pass <EOL> def set_breakpoint_here ( self , event = None ) : <EOL> text = self . text <EOL> filename = self . io . filename <EOL> if not filename : <EOL> text . bell ( ) <EOL> return <EOL> lineno = int ( float ( text . index ( \"<STR_LIT>\" ) ) ) <EOL> self . set_breakpoint ( lineno ) <EOL> def clear_breakpoint_here ( self , event = None ) : <EOL> text = self . text <EOL> filename = self . io . filename <EOL> if not filename : <EOL> text . bell ( ) <EOL> return <EOL> lineno = int ( float ( text . index ( \"<STR_LIT>\" ) ) ) <EOL> try : <EOL> self . breakpoints . remove ( lineno ) <EOL> except : <EOL> pass <EOL> text . tag_remove ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> try : <EOL> debug = self . flist . pyshell . interp . debugger <EOL> debug . clear_breakpoint_here ( filename , lineno ) <EOL> except : <EOL> pass <EOL> def clear_file_breaks ( self ) : <EOL> if self . breakpoints : <EOL> text = self . text <EOL> filename = self . io . filename <EOL> if not filename : <EOL> text . bell ( ) <EOL> return <EOL> self . breakpoints = [ ] <EOL> text . tag_remove ( \"<STR_LIT>\" , \"<STR_LIT:1.0>\" , END ) <EOL> try : <EOL> debug = self . flist . pyshell . interp . debugger <EOL> debug . clear_file_breaks ( filename ) <EOL> except : <EOL> pass <EOL> def store_file_breaks ( self ) : <EOL> \"<STR_LIT>\" <EOL> breaks = self . breakpoints <EOL> filename = self . io . filename <EOL> try : <EOL> with open ( self . breakpointPath , \"<STR_LIT:r>\" ) as old_file : <EOL> lines = old_file . readlines ( ) <EOL> except IOError : <EOL> lines = [ ] <EOL> try : <EOL> with open ( self . breakpointPath , \"<STR_LIT:w>\" ) as new_file : <EOL> for line in lines : <EOL> if not line . startswith ( filename + '<STR_LIT:=>' ) : <EOL> new_file . write ( line ) <EOL> self . update_breakpoints ( ) <EOL> breaks = self . breakpoints <EOL> if breaks : <EOL> new_file . write ( filename + '<STR_LIT:=>' + str ( breaks ) + '<STR_LIT:\\n>' ) <EOL> except IOError as err : <EOL> if not getattr ( self . root , \"<STR_LIT>\" , False ) : <EOL> self . root . breakpoint_error_displayed = True <EOL> tkMessageBox . showerror ( title = '<STR_LIT>' , <EOL> message = '<STR_LIT>' <EOL> % str ( err ) , <EOL> parent = self . text ) <EOL> def restore_file_breaks ( self ) : <EOL> self . text . update ( ) <EOL> if self . io is None : <EOL> return <EOL> filename = self . io . filename <EOL> if filename is None : <EOL> return <EOL> if os . path . isfile ( self . breakpointPath ) : <EOL> lines = open ( self . breakpointPath , \"<STR_LIT:r>\" ) . readlines ( ) <EOL> for line in lines : <EOL> if line . startswith ( filename + '<STR_LIT:=>' ) : <EOL> breakpoint_linenumbers = eval ( line [ len ( filename ) + <NUM_LIT:1> : ] ) <EOL> for breakpoint_linenumber in breakpoint_linenumbers : <EOL> self . set_breakpoint ( breakpoint_linenumber ) <EOL> def update_breakpoints ( self ) : <EOL> \"<STR_LIT>\" <EOL> text = self . text <EOL> ranges = text . tag_ranges ( \"<STR_LIT>\" ) <EOL> linenumber_list = self . ranges_to_linenumbers ( ranges ) <EOL> self . breakpoints = linenumber_list <EOL> def ranges_to_linenumbers ( self , ranges ) : <EOL> lines = [ ] <EOL> for index in range ( <NUM_LIT:0> , len ( ranges ) , <NUM_LIT:2> ) : <EOL> lineno = int ( float ( ranges [ index ] . string ) ) <EOL> end = int ( float ( ranges [ index + <NUM_LIT:1> ] . string ) ) <EOL> while lineno < end : <EOL> lines . append ( lineno ) <EOL> lineno += <NUM_LIT:1> <EOL> return lines <EOL> def _close ( self ) : <EOL> \"<STR_LIT>\" <EOL> self . clear_file_breaks ( ) <EOL> EditorWindow . _close ( self ) <EOL> class PyShellFileList ( FileList ) : <EOL> \"<STR_LIT>\" <EOL> EditorWindow = PyShellEditorWindow <EOL> pyshell = None <EOL> def open_shell ( self , event = None ) : <EOL> if self . pyshell : <EOL> self . pyshell . top . wakeup ( ) <EOL> else : <EOL> self . pyshell = PyShell ( self ) <EOL> if self . pyshell : <EOL> if not self . pyshell . begin ( ) : <EOL> return None <EOL> return self . pyshell <EOL> class ModifiedColorDelegator ( ColorDelegator ) : <EOL> \"<STR_LIT>\" <EOL> def __init__ ( self ) : <EOL> ColorDelegator . __init__ ( self ) <EOL> self . LoadTagDefs ( ) <EOL> def recolorize_main ( self ) : <EOL> self . tag_remove ( \"<STR_LIT>\" , \"<STR_LIT:1.0>\" , \"<STR_LIT>\" ) <EOL> self . tag_add ( \"<STR_LIT>\" , \"<STR_LIT:1.0>\" , \"<STR_LIT>\" ) <EOL> ColorDelegator . recolorize_main ( self ) <EOL> def LoadTagDefs ( self ) : <EOL> ColorDelegator . LoadTagDefs ( self ) <EOL> theme = idleConf . GetOption ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:name>' ) <EOL> self . tagdefs . update ( { <EOL> \"<STR_LIT>\" : { '<STR_LIT>' : None , '<STR_LIT>' : None } , <EOL> \"<STR_LIT>\" : idleConf . GetHighlight ( theme , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : idleConf . GetHighlight ( theme , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : idleConf . GetHighlight ( theme , \"<STR_LIT>\" ) , <EOL> } ) <EOL> def removecolors ( self ) : <EOL> for tag in self . tagdefs : <EOL> self . tag_remove ( tag , \"<STR_LIT>\" , \"<STR_LIT:end>\" ) <EOL> class ModifiedUndoDelegator ( UndoDelegator ) : <EOL> \"<STR_LIT>\" <EOL> def insert ( self , index , chars , tags = None ) : <EOL> try : <EOL> if self . delegate . compare ( index , \"<STR_LIT:<>\" , \"<STR_LIT>\" ) : <EOL> self . delegate . bell ( ) <EOL> return <EOL> except TclError : <EOL> pass <EOL> UndoDelegator . insert ( self , index , chars , tags ) <EOL> def delete ( self , index1 , index2 = None ) : <EOL> try : <EOL> if self . delegate . compare ( index1 , \"<STR_LIT:<>\" , \"<STR_LIT>\" ) : <EOL> self . delegate . bell ( ) <EOL> return <EOL> except TclError : <EOL> pass <EOL> UndoDelegator . delete ( self , index1 , index2 ) <EOL> class MyRPCClient ( rpc . RPCClient ) : <EOL> def handle_EOF ( self ) : <EOL> \"<STR_LIT>\" <EOL> raise EOFError <EOL> class ModifiedInterpreter ( InteractiveInterpreter ) : <EOL> def __init__ ( self , tkconsole ) : <EOL> self . tkconsole = tkconsole <EOL> locals = sys . modules [ '<STR_LIT:__main__>' ] . __dict__ <EOL> InteractiveInterpreter . __init__ ( self , locals = locals ) <EOL> self . save_warnings_filters = None <EOL> self . restarting = False <EOL> self . subprocess_arglist = None <EOL> self . port = PORT <EOL> self . original_compiler_flags = self . compile . compiler . flags <EOL> _afterid = None <EOL> rpcclt = None <EOL> rpcpid = None <EOL> def spawn_subprocess ( self ) : <EOL> if self . subprocess_arglist is None : <EOL> self . subprocess_arglist = self . build_subprocess_arglist ( ) <EOL> args = self . subprocess_arglist <EOL> self . rpcpid = os . spawnv ( os . P_NOWAIT , sys . executable , args ) <EOL> def build_subprocess_arglist ( self ) : <EOL> assert ( self . port != <NUM_LIT:0> ) , ( <EOL> \"<STR_LIT>\" ) <EOL> w = [ '<STR_LIT>' + s for s in sys . warnoptions ] <EOL> if <NUM_LIT:1> / <NUM_LIT:2> > <NUM_LIT:0> : <EOL> w . append ( '<STR_LIT>' ) <EOL> del_exitf = idleConf . GetOption ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> default = False , type = '<STR_LIT:bool>' ) <EOL> if __name__ == '<STR_LIT>' : <EOL> command = \"<STR_LIT>\" % ( del_exitf , ) <EOL> else : <EOL> command = \"<STR_LIT>\" % ( del_exitf , ) <EOL> if sys . platform [ : <NUM_LIT:3> ] == '<STR_LIT>' and '<STR_LIT:U+0020>' in sys . executable : <EOL> decorated_exec = '<STR_LIT>' % sys . executable <EOL> else : <EOL> decorated_exec = sys . executable <EOL> return [ decorated_exec ] + w + [ \"<STR_LIT:-c>\" , command , str ( self . port ) ] <EOL> def start_subprocess ( self ) : <EOL> addr = ( HOST , self . port ) <EOL> for i in range ( <NUM_LIT:3> ) : <EOL> time . sleep ( i ) <EOL> try : <EOL> self . rpcclt = MyRPCClient ( addr ) <EOL> break <EOL> except socket . error : <EOL> pass <EOL> else : <EOL> self . display_port_binding_error ( ) <EOL> return None <EOL> self . port = self . rpcclt . listening_sock . getsockname ( ) [ <NUM_LIT:1> ] <EOL> if PORT != <NUM_LIT:0> : <EOL> self . rpcclt . listening_sock . setsockopt ( socket . SOL_SOCKET , <EOL> socket . SO_REUSEADDR , <NUM_LIT:1> ) <EOL> self . spawn_subprocess ( ) <EOL> self . rpcclt . listening_sock . settimeout ( <NUM_LIT:10> ) <EOL> try : <EOL> self . rpcclt . accept ( ) <EOL> except socket . timeout : <EOL> self . display_no_subprocess_error ( ) <EOL> return None <EOL> self . rpcclt . register ( \"<STR_LIT>\" , self . tkconsole ) <EOL> self . rpcclt . register ( \"<STR_LIT>\" , self . tkconsole . stdin ) <EOL> self . rpcclt . register ( \"<STR_LIT>\" , self . tkconsole . stdout ) <EOL> self . rpcclt . register ( \"<STR_LIT>\" , self . tkconsole . stderr ) <EOL> self . rpcclt . register ( \"<STR_LIT>\" , self . tkconsole . flist ) <EOL> self . rpcclt . register ( \"<STR_LIT>\" , linecache ) <EOL> self . rpcclt . register ( \"<STR_LIT>\" , self ) <EOL> self . transfer_path ( with_cwd = True ) <EOL> self . poll_subprocess ( ) <EOL> return self . rpcclt <EOL> def restart_subprocess ( self , with_cwd = False ) : <EOL> if self . restarting : <EOL> return self . rpcclt <EOL> self . restarting = True <EOL> debug = self . getdebugger ( ) <EOL> if debug : <EOL> try : <EOL> RemoteDebugger . close_subprocess_debugger ( self . rpcclt ) <EOL> except : <EOL> pass <EOL> self . rpcclt . close ( ) <EOL> self . unix_terminate ( ) <EOL> console = self . tkconsole <EOL> was_executing = console . executing <EOL> console . executing = False <EOL> self . spawn_subprocess ( ) <EOL> try : <EOL> self . rpcclt . accept ( ) <EOL> except socket . timeout : <EOL> self . display_no_subprocess_error ( ) <EOL> return None <EOL> self . transfer_path ( with_cwd = with_cwd ) <EOL> console . stop_readline ( ) <EOL> console . text . delete ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if was_executing : <EOL> console . write ( '<STR_LIT:\\n>' ) <EOL> console . showprompt ( ) <EOL> halfbar = ( ( int ( console . width ) - <NUM_LIT:16> ) // <NUM_LIT:2> ) * '<STR_LIT:=>' <EOL> console . write ( halfbar + '<STR_LIT>' + halfbar ) <EOL> console . text . mark_set ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> console . text . mark_gravity ( \"<STR_LIT>\" , \"<STR_LIT:left>\" ) <EOL> console . showprompt ( ) <EOL> if debug : <EOL> RemoteDebugger . restart_subprocess_debugger ( self . rpcclt ) <EOL> debug . load_breakpoints ( ) <EOL> self . compile . compiler . flags = self . original_compiler_flags <EOL> self . restarting = False <EOL> return self . rpcclt <EOL> def __request_interrupt ( self ) : <EOL> self . rpcclt . remotecall ( \"<STR_LIT>\" , \"<STR_LIT>\" , ( ) , { } ) <EOL> def interrupt_subprocess ( self ) : <EOL> threading . Thread ( target = self . __request_interrupt ) . start ( ) <EOL> def kill_subprocess ( self ) : <EOL> if self . _afterid is not None : <EOL> self . tkconsole . text . after_cancel ( self . _afterid ) <EOL> try : <EOL> self . rpcclt . close ( ) <EOL> except AttributeError : <EOL> pass <EOL> self . unix_terminate ( ) <EOL> self . tkconsole . executing = False <EOL> self . rpcclt = None <EOL> def unix_terminate ( self ) : <EOL> \"<STR_LIT>\" <EOL> if hasattr ( os , '<STR_LIT>' ) : <EOL> try : <EOL> os . kill ( self . rpcpid , SIGTERM ) <EOL> except OSError : <EOL> return <EOL> else : <EOL> try : <EOL> os . waitpid ( self . rpcpid , <NUM_LIT:0> ) <EOL> except OSError : <EOL> return <EOL> def transfer_path ( self , with_cwd = False ) : <EOL> if with_cwd : <EOL> path = [ '<STR_LIT>' ] <EOL> path . extend ( sys . path ) <EOL> else : <EOL> path = sys . path <EOL> self . runcommand ( \"\"\"<STR_LIT>\"\"\" % ( path , ) ) <EOL> active_seq = None <EOL> def poll_subprocess ( self ) : <EOL> clt = self . rpcclt <EOL> if clt is None : <EOL> return <EOL> try : <EOL> response = clt . pollresponse ( self . active_seq , wait = <NUM_LIT> ) <EOL> except ( EOFError , IOError , KeyboardInterrupt ) : <EOL> if self . tkconsole . closing : <EOL> return <EOL> response = None <EOL> self . restart_subprocess ( ) <EOL> if response : <EOL> self . tkconsole . resetoutput ( ) <EOL> self . active_seq = None <EOL> how , what = response <EOL> console = self . tkconsole . console <EOL> if how == \"<STR_LIT:OK>\" : <EOL> if what is not None : <EOL> print ( repr ( what ) , file = console ) <EOL> elif how == \"<STR_LIT>\" : <EOL> if self . tkconsole . getvar ( \"<STR_LIT>\" ) : <EOL> self . remote_stack_viewer ( ) <EOL> elif how == \"<STR_LIT>\" : <EOL> errmsg = \"<STR_LIT>\" <EOL> print ( errmsg , what , file = sys . __stderr__ ) <EOL> print ( errmsg , what , file = console ) <EOL> try : <EOL> self . tkconsole . endexecuting ( ) <EOL> except AttributeError : <EOL> pass <EOL> if not self . tkconsole . closing : <EOL> self . _afterid = self . tkconsole . text . after ( <EOL> self . tkconsole . pollinterval , self . poll_subprocess ) <EOL> debugger = None <EOL> def setdebugger ( self , debugger ) : <EOL> self . debugger = debugger <EOL> def getdebugger ( self ) : <EOL> return self . debugger <EOL> def open_remote_stack_viewer ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . tkconsole . text . after ( <NUM_LIT> , self . remote_stack_viewer ) <EOL> return <EOL> def remote_stack_viewer ( self ) : <EOL> from idlelib import RemoteObjectBrowser <EOL> oid = self . rpcclt . remotequeue ( \"<STR_LIT>\" , \"<STR_LIT>\" , ( \"<STR_LIT>\" , ) , { } ) <EOL> if oid is None : <EOL> self . tkconsole . root . bell ( ) <EOL> return <EOL> item = RemoteObjectBrowser . StubObjectTreeItem ( self . rpcclt , oid ) <EOL> from idlelib . TreeWidget import ScrolledCanvas , TreeNode <EOL> top = Toplevel ( self . tkconsole . root ) <EOL> theme = idleConf . GetOption ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:name>' ) <EOL> background = idleConf . GetHighlight ( theme , '<STR_LIT>' ) [ '<STR_LIT>' ] <EOL> sc = ScrolledCanvas ( top , bg = background , highlightthickness = <NUM_LIT:0> ) <EOL> sc . frame . pack ( expand = <NUM_LIT:1> , fill = \"<STR_LIT>\" ) <EOL> node = TreeNode ( sc . canvas , None , item ) <EOL> node . expand ( ) <EOL> gid = <NUM_LIT:0> <EOL> def execsource ( self , source ) : <EOL> \"<STR_LIT>\" <EOL> filename = self . stuffsource ( source ) <EOL> self . execfile ( filename , source ) <EOL> def execfile ( self , filename , source = None ) : <EOL> \"<STR_LIT>\" <EOL> if source is None : <EOL> source = open ( filename , \"<STR_LIT:r>\" ) . read ( ) <EOL> try : <EOL> code = compile ( source , filename , \"<STR_LIT>\" , dont_inherit = True ) <EOL> except ( OverflowError , SyntaxError ) : <EOL> self . tkconsole . resetoutput ( ) <EOL> print ( '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> file = self . tkconsole . stderr ) <EOL> InteractiveInterpreter . showsyntaxerror ( self , filename ) <EOL> self . tkconsole . showprompt ( ) <EOL> else : <EOL> self . runcode ( code ) <EOL> def runsource ( self , source ) : <EOL> \"<STR_LIT>\" <EOL> filename = self . stuffsource ( source ) <EOL> self . more = <NUM_LIT:0> <EOL> self . save_warnings_filters = warnings . filters [ : ] <EOL> warnings . filterwarnings ( action = \"<STR_LIT:error>\" , category = SyntaxWarning ) <EOL> if isinstance ( source , unicode ) and IOBinding . encoding != '<STR_LIT:utf-8>' : <EOL> try : <EOL> source = '<STR_LIT>' % ( <EOL> IOBinding . encoding , <EOL> source . encode ( IOBinding . encoding ) ) <EOL> except UnicodeError : <EOL> self . tkconsole . resetoutput ( ) <EOL> self . write ( \"<STR_LIT>\" ) <EOL> return <EOL> try : <EOL> return InteractiveInterpreter . runsource ( self , source , filename ) <EOL> finally : <EOL> if self . save_warnings_filters is not None : <EOL> warnings . filters [ : ] = self . save_warnings_filters <EOL> self . save_warnings_filters = None <EOL> def stuffsource ( self , source ) : <EOL> \"<STR_LIT>\" <EOL> filename = \"<STR_LIT>\" % self . gid <EOL> self . gid = self . gid + <NUM_LIT:1> <EOL> lines = source . split ( \"<STR_LIT:\\n>\" ) <EOL> linecache . cache [ filename ] = len ( source ) + <NUM_LIT:1> , <NUM_LIT:0> , lines , filename <EOL> return filename <EOL> def prepend_syspath ( self , filename ) : <EOL> \"<STR_LIT>\" <EOL> self . runcommand ( \"\"\"<STR_LIT>\"\"\" % ( filename , ) ) <EOL> def showsyntaxerror ( self , filename = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> text = self . tkconsole . text <EOL> stuff = self . unpackerror ( ) <EOL> if stuff : <EOL> msg , lineno , offset , line = stuff <EOL> if lineno == <NUM_LIT:1> : <EOL> pos = \"<STR_LIT>\" % ( offset - <NUM_LIT:1> ) <EOL> else : <EOL> pos = \"<STR_LIT>\" % ( lineno - <NUM_LIT:1> , offset - <NUM_LIT:1> ) <EOL> text . tag_add ( \"<STR_LIT>\" , pos ) <EOL> text . see ( pos ) <EOL> char = text . get ( pos ) <EOL> if char and char in IDENTCHARS : <EOL> text . tag_add ( \"<STR_LIT>\" , pos + \"<STR_LIT>\" , pos ) <EOL> self . tkconsole . resetoutput ( ) <EOL> self . write ( \"<STR_LIT>\" % str ( msg ) ) <EOL> else : <EOL> self . tkconsole . resetoutput ( ) <EOL> InteractiveInterpreter . showsyntaxerror ( self , filename ) <EOL> self . tkconsole . showprompt ( ) <EOL> def unpackerror ( self ) : <EOL> type , value , tb = sys . exc_info ( ) <EOL> ok = type is SyntaxError <EOL> if ok : <EOL> try : <EOL> msg , ( dummy_filename , lineno , offset , line ) = value <EOL> if not offset : <EOL> offset = <NUM_LIT:0> <EOL> except : <EOL> ok = <NUM_LIT:0> <EOL> if ok : <EOL> return msg , lineno , offset , line <EOL> else : <EOL> return None <EOL> def showtraceback ( self ) : <EOL> \"<STR_LIT>\" <EOL> self . tkconsole . resetoutput ( ) <EOL> self . checklinecache ( ) <EOL> InteractiveInterpreter . showtraceback ( self ) <EOL> if self . tkconsole . getvar ( \"<STR_LIT>\" ) : <EOL> self . tkconsole . open_stack_viewer ( ) <EOL> def checklinecache ( self ) : <EOL> c = linecache . cache <EOL> for key in c . keys ( ) : <EOL> if key [ : <NUM_LIT:1> ] + key [ - <NUM_LIT:1> : ] != \"<STR_LIT>\" : <EOL> del c [ key ] <EOL> def runcommand ( self , code ) : <EOL> \"<STR_LIT>\" <EOL> if self . tkconsole . executing : <EOL> self . display_executing_dialog ( ) <EOL> return <NUM_LIT:0> <EOL> if self . rpcclt : <EOL> self . rpcclt . remotequeue ( \"<STR_LIT>\" , \"<STR_LIT>\" , ( code , ) , { } ) <EOL> else : <EOL> exec code in self . locals <EOL> return <NUM_LIT:1> <EOL> def runcode ( self , code ) : <EOL> \"<STR_LIT>\" <EOL> if self . tkconsole . executing : <EOL> self . interp . restart_subprocess ( ) <EOL> self . checklinecache ( ) <EOL> if self . save_warnings_filters is not None : <EOL> warnings . filters [ : ] = self . save_warnings_filters <EOL> self . save_warnings_filters = None <EOL> debugger = self . debugger <EOL> try : <EOL> self . tkconsole . beginexecuting ( ) <EOL> if not debugger and self . rpcclt is not None : <EOL> self . active_seq = self . rpcclt . asyncqueue ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> ( code , ) , { } ) <EOL> elif debugger : <EOL> debugger . run ( code , self . locals ) <EOL> else : <EOL> exec code in self . locals <EOL> except SystemExit : <EOL> if not self . tkconsole . closing : <EOL> if tkMessageBox . askyesno ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> default = \"<STR_LIT:yes>\" , <EOL> master = self . tkconsole . text ) : <EOL> raise <EOL> else : <EOL> self . showtraceback ( ) <EOL> else : <EOL> raise <EOL> except : <EOL> if use_subprocess : <EOL> print ( \"<STR_LIT>\" , <EOL> file = self . tkconsole . stderr ) <EOL> self . showtraceback ( ) <EOL> self . tkconsole . endexecuting ( ) <EOL> else : <EOL> if self . tkconsole . canceled : <EOL> self . tkconsole . canceled = False <EOL> print ( \"<STR_LIT>\" , file = self . tkconsole . stderr ) <EOL> else : <EOL> self . showtraceback ( ) <EOL> finally : <EOL> if not use_subprocess : <EOL> try : <EOL> self . tkconsole . endexecuting ( ) <EOL> except AttributeError : <EOL> pass <EOL> def write ( self , s ) : <EOL> \"<STR_LIT>\" <EOL> self . tkconsole . stderr . write ( s ) <EOL> def display_port_binding_error ( self ) : <EOL> tkMessageBox . showerror ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> master = self . tkconsole . text ) <EOL> def display_no_subprocess_error ( self ) : <EOL> tkMessageBox . showerror ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> master = self . tkconsole . text ) <EOL> def display_executing_dialog ( self ) : <EOL> tkMessageBox . showerror ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> master = self . tkconsole . text ) <EOL> class PyShell ( OutputWindow ) : <EOL> shell_title = \"<STR_LIT>\" + python_version ( ) + \"<STR_LIT>\" <EOL> ColorDelegator = ModifiedColorDelegator <EOL> UndoDelegator = ModifiedUndoDelegator <EOL> menu_specs = [ <EOL> ( \"<STR_LIT:file>\" , \"<STR_LIT>\" ) , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] <EOL> from idlelib . IdleHistory import History <EOL> def __init__ ( self , flist = None ) : <EOL> if use_subprocess : <EOL> ms = self . menu_specs <EOL> if ms [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] != \"<STR_LIT>\" : <EOL> ms . insert ( <NUM_LIT:2> , ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> self . interp = ModifiedInterpreter ( self ) <EOL> if flist is None : <EOL> root = Tk ( ) <EOL> fixwordbreaks ( root ) <EOL> root . withdraw ( ) <EOL> flist = PyShellFileList ( root ) <EOL> OutputWindow . __init__ ( self , flist , None , None ) <EOL> self . usetabs = True <EOL> self . indentwidth = <NUM_LIT:8> <EOL> self . context_use_ps1 = True <EOL> text = self . text <EOL> text . configure ( wrap = \"<STR_LIT>\" ) <EOL> text . bind ( \"<STR_LIT>\" , self . enter_callback ) <EOL> text . bind ( \"<STR_LIT>\" , self . linefeed_callback ) <EOL> text . bind ( \"<STR_LIT>\" , self . cancel_callback ) <EOL> text . bind ( \"<STR_LIT>\" , self . eof_callback ) <EOL> text . bind ( \"<STR_LIT>\" , self . open_stack_viewer ) <EOL> text . bind ( \"<STR_LIT>\" , self . toggle_debugger ) <EOL> text . bind ( \"<STR_LIT>\" , self . toggle_jit_stack_viewer ) <EOL> if use_subprocess : <EOL> text . bind ( \"<STR_LIT>\" , self . view_restart_mark ) <EOL> text . bind ( \"<STR_LIT>\" , self . restart_shell ) <EOL> self . save_stdout = sys . stdout <EOL> self . save_stderr = sys . stderr <EOL> self . save_stdin = sys . stdin <EOL> from idlelib import IOBinding <EOL> self . stdin = PseudoInputFile ( self , \"<STR_LIT>\" , IOBinding . encoding ) <EOL> self . stdout = PseudoOutputFile ( self , \"<STR_LIT>\" , IOBinding . encoding ) <EOL> self . stderr = PseudoOutputFile ( self , \"<STR_LIT>\" , IOBinding . encoding ) <EOL> self . console = PseudoOutputFile ( self , \"<STR_LIT>\" , IOBinding . encoding ) <EOL> if not use_subprocess : <EOL> sys . stdout = self . stdout <EOL> sys . stderr = self . stderr <EOL> sys . stdin = self . stdin <EOL> self . history = self . History ( self . text ) <EOL> self . pollinterval = <NUM_LIT:50> <EOL> def get_standard_extension_names ( self ) : <EOL> return idleConf . GetExtensions ( shell_only = True ) <EOL> reading = False <EOL> executing = False <EOL> canceled = False <EOL> endoffile = False <EOL> closing = False <EOL> _stop_readline_flag = False <EOL> def set_warning_stream ( self , stream ) : <EOL> global warning_stream <EOL> warning_stream = stream <EOL> def get_warning_stream ( self ) : <EOL> return warning_stream <EOL> def toggle_debugger ( self , event = None ) : <EOL> if self . executing : <EOL> tkMessageBox . showerror ( \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> master = self . text ) <EOL> self . set_debugger_indicator ( ) <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> db = self . interp . getdebugger ( ) <EOL> if db : <EOL> self . close_debugger ( ) <EOL> else : <EOL> self . open_debugger ( ) <EOL> def set_debugger_indicator ( self ) : <EOL> db = self . interp . getdebugger ( ) <EOL> self . setvar ( \"<STR_LIT>\" , not not db ) <EOL> def toggle_jit_stack_viewer ( self , event = None ) : <EOL> pass <EOL> def close_debugger ( self ) : <EOL> db = self . interp . getdebugger ( ) <EOL> if db : <EOL> self . interp . setdebugger ( None ) <EOL> db . close ( ) <EOL> if self . interp . rpcclt : <EOL> RemoteDebugger . close_remote_debugger ( self . interp . rpcclt ) <EOL> self . resetoutput ( ) <EOL> self . console . write ( \"<STR_LIT>\" ) <EOL> sys . ps1 = \"<STR_LIT>\" <EOL> self . showprompt ( ) <EOL> self . set_debugger_indicator ( ) <EOL> def open_debugger ( self ) : <EOL> if self . interp . rpcclt : <EOL> dbg_gui = RemoteDebugger . start_remote_debugger ( self . interp . rpcclt , <EOL> self ) <EOL> else : <EOL> dbg_gui = Debugger . Debugger ( self ) <EOL> self . interp . setdebugger ( dbg_gui ) <EOL> dbg_gui . load_breakpoints ( ) <EOL> sys . ps1 = \"<STR_LIT>\" <EOL> self . showprompt ( ) <EOL> self . set_debugger_indicator ( ) <EOL> def beginexecuting ( self ) : <EOL> \"<STR_LIT>\" <EOL> self . resetoutput ( ) <EOL> self . executing = <NUM_LIT:1> <EOL> def endexecuting ( self ) : <EOL> \"<STR_LIT>\" <EOL> self . executing = <NUM_LIT:0> <EOL> self . canceled = <NUM_LIT:0> <EOL> self . showprompt ( ) <EOL> def close ( self ) : <EOL> \"<STR_LIT>\" <EOL> if self . executing : <EOL> response = tkMessageBox . askokcancel ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" , <EOL> parent = self . text ) <EOL> if response is False : <EOL> return \"<STR_LIT>\" <EOL> self . stop_readline ( ) <EOL> self . canceled = True <EOL> self . closing = True <EOL> return EditorWindow . close ( self ) <EOL> def _close ( self ) : <EOL> \"<STR_LIT>\" <EOL> self . close_debugger ( ) <EOL> if use_subprocess : <EOL> self . interp . kill_subprocess ( ) <EOL> sys . stdout = self . save_stdout <EOL> sys . stderr = self . save_stderr <EOL> sys . stdin = self . save_stdin <EOL> self . interp = None <EOL> self . console = None <EOL> self . flist . pyshell = None <EOL> self . history = None <EOL> EditorWindow . _close ( self ) <EOL> def ispythonsource ( self , filename ) : <EOL> \"<STR_LIT>\" <EOL> return True <EOL> def short_title ( self ) : <EOL> return self . shell_title <EOL> COPYRIGHT = '<STR_LIT>' <EOL> def begin ( self ) : <EOL> self . resetoutput ( ) <EOL> if use_subprocess : <EOL> nosub = '<STR_LIT>' <EOL> client = self . interp . start_subprocess ( ) <EOL> if not client : <EOL> self . close ( ) <EOL> return False <EOL> else : <EOL> nosub = \"<STR_LIT>\" <EOL> self . write ( \"<STR_LIT>\" % <EOL> ( sys . version , sys . platform , self . COPYRIGHT , nosub ) ) <EOL> self . showprompt ( ) <EOL> import Tkinter <EOL> Tkinter . _default_root = None <EOL> return True <EOL> def stop_readline ( self ) : <EOL> if not self . reading : <EOL> return <EOL> self . _stop_readline_flag = True <EOL> self . top . quit ( ) <EOL> def readline ( self ) : <EOL> save = self . reading <EOL> try : <EOL> self . reading = <NUM_LIT:1> <EOL> self . top . mainloop ( ) <EOL> finally : <EOL> self . reading = save <EOL> if self . _stop_readline_flag : <EOL> self . _stop_readline_flag = False <EOL> return \"<STR_LIT>\" <EOL> line = self . text . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if len ( line ) == <NUM_LIT:0> : <EOL> line = \"<STR_LIT:\\n>\" <EOL> if isinstance ( line , unicode ) : <EOL> from idlelib import IOBinding <EOL> try : <EOL> line = line . encode ( IOBinding . encoding ) <EOL> except UnicodeError : <EOL> pass <EOL> self . resetoutput ( ) <EOL> if self . canceled : <EOL> self . canceled = <NUM_LIT:0> <EOL> if not use_subprocess : <EOL> raise KeyboardInterrupt <EOL> if self . endoffile : <EOL> self . endoffile = <NUM_LIT:0> <EOL> line = \"<STR_LIT>\" <EOL> return line <EOL> def isatty ( self ) : <EOL> return True <EOL> def cancel_callback ( self , event = None ) : <EOL> try : <EOL> if self . text . compare ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> return <EOL> except : <EOL> pass <EOL> if not ( self . executing or self . reading ) : <EOL> self . resetoutput ( ) <EOL> self . interp . write ( \"<STR_LIT>\" ) <EOL> self . showprompt ( ) <EOL> return \"<STR_LIT>\" <EOL> self . endoffile = <NUM_LIT:0> <EOL> self . canceled = <NUM_LIT:1> <EOL> if ( self . executing and self . interp . rpcclt ) : <EOL> if self . interp . getdebugger ( ) : <EOL> self . interp . restart_subprocess ( ) <EOL> else : <EOL> self . interp . interrupt_subprocess ( ) <EOL> if self . reading : <EOL> self . top . quit ( ) <EOL> return \"<STR_LIT>\" <EOL> def eof_callback ( self , event ) : <EOL> if self . executing and not self . reading : <EOL> return <EOL> if not ( self . text . compare ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) and <EOL> self . text . compare ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) : <EOL> return <EOL> if not self . executing : <EOL> self . resetoutput ( ) <EOL> self . close ( ) <EOL> else : <EOL> self . canceled = <NUM_LIT:0> <EOL> self . endoffile = <NUM_LIT:1> <EOL> self . top . quit ( ) <EOL> return \"<STR_LIT>\" <EOL> def linefeed_callback ( self , event ) : <EOL> if self . reading : <EOL> self . text . insert ( \"<STR_LIT>\" , \"<STR_LIT:\\n>\" ) <EOL> self . text . see ( \"<STR_LIT>\" ) <EOL> else : <EOL> self . newline_and_indent_event ( event ) <EOL> return \"<STR_LIT>\" <EOL> def enter_callback ( self , event ) : <EOL> if self . executing and not self . reading : <EOL> return <EOL> try : <EOL> sel = self . text . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if sel : <EOL> if self . text . compare ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> self . recall ( sel , event ) <EOL> return \"<STR_LIT>\" <EOL> except : <EOL> pass <EOL> if self . text . compare ( \"<STR_LIT>\" , \"<STR_LIT:<>\" , \"<STR_LIT>\" ) : <EOL> prev = self . text . tag_prevrange ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prev and self . text . compare ( \"<STR_LIT>\" , \"<STR_LIT:<>\" , prev [ <NUM_LIT:1> ] ) : <EOL> self . recall ( self . text . get ( prev [ <NUM_LIT:0> ] , prev [ <NUM_LIT:1> ] ) , event ) <EOL> return \"<STR_LIT>\" <EOL> next = self . text . tag_nextrange ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if next and self . text . compare ( \"<STR_LIT>\" , \"<STR_LIT>\" , next [ <NUM_LIT:0> ] ) : <EOL> self . recall ( self . text . get ( next [ <NUM_LIT:0> ] , next [ <NUM_LIT:1> ] ) , event ) <EOL> return \"<STR_LIT>\" <EOL> indices = self . text . tag_nextrange ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if indices and self . text . compare ( indices [ <NUM_LIT:0> ] , \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> self . recall ( self . text . get ( indices [ <NUM_LIT:1> ] , \"<STR_LIT>\" ) , event ) <EOL> else : <EOL> self . recall ( self . text . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , event ) <EOL> return \"<STR_LIT>\" <EOL> if self . text . compare ( \"<STR_LIT>\" , \"<STR_LIT:<>\" , \"<STR_LIT>\" ) : <EOL> self . text . mark_set ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> s = self . text . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if s and not s . strip ( ) : <EOL> self . text . delete ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if self . text . compare ( \"<STR_LIT>\" , \"<STR_LIT:<>\" , \"<STR_LIT>\" ) : <EOL> self . newline_and_indent_event ( event ) <EOL> return \"<STR_LIT>\" <EOL> self . text . mark_set ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if self . reading : <EOL> self . text . insert ( \"<STR_LIT>\" , \"<STR_LIT:\\n>\" ) <EOL> self . text . see ( \"<STR_LIT>\" ) <EOL> else : <EOL> self . newline_and_indent_event ( event ) <EOL> self . text . tag_add ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . text . update_idletasks ( ) <EOL> if self . reading : <EOL> self . top . quit ( ) <EOL> else : <EOL> self . runit ( ) <EOL> return \"<STR_LIT>\" <EOL> def recall ( self , s , event ) : <EOL> s = re . sub ( r'<STR_LIT>' , '<STR_LIT>' , s ) <EOL> s = re . sub ( r'<STR_LIT>' , '<STR_LIT>' , s ) <EOL> lines = s . split ( '<STR_LIT:\\n>' ) <EOL> self . text . undo_block_start ( ) <EOL> try : <EOL> self . text . tag_remove ( \"<STR_LIT>\" , \"<STR_LIT:1.0>\" , \"<STR_LIT:end>\" ) <EOL> self . text . mark_set ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> prefix = self . text . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if prefix . rstrip ( ) . endswith ( '<STR_LIT::>' ) : <EOL> self . newline_and_indent_event ( event ) <EOL> prefix = self . text . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . text . insert ( \"<STR_LIT>\" , lines [ <NUM_LIT:0> ] . strip ( ) ) <EOL> if len ( lines ) > <NUM_LIT:1> : <EOL> orig_base_indent = re . search ( r'<STR_LIT>' , lines [ <NUM_LIT:0> ] ) . group ( <NUM_LIT:0> ) <EOL> new_base_indent = re . search ( r'<STR_LIT>' , prefix ) . group ( <NUM_LIT:0> ) <EOL> for line in lines [ <NUM_LIT:1> : ] : <EOL> if line . startswith ( orig_base_indent ) : <EOL> line = new_base_indent + line [ len ( orig_base_indent ) : ] <EOL> self . text . insert ( '<STR_LIT>' , '<STR_LIT:\\n>' + line . rstrip ( ) ) <EOL> finally : <EOL> self . text . see ( \"<STR_LIT>\" ) <EOL> self . text . undo_block_stop ( ) <EOL> def runit ( self ) : <EOL> line = self . text . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> i = len ( line ) <EOL> while i > <NUM_LIT:0> and line [ i - <NUM_LIT:1> ] in \"<STR_LIT>\" : <EOL> i = i - <NUM_LIT:1> <EOL> if i > <NUM_LIT:0> and line [ i - <NUM_LIT:1> ] == \"<STR_LIT:\\n>\" : <EOL> i = i - <NUM_LIT:1> <EOL> while i > <NUM_LIT:0> and line [ i - <NUM_LIT:1> ] in \"<STR_LIT>\" : <EOL> i = i - <NUM_LIT:1> <EOL> line = line [ : i ] <EOL> self . interp . runsource ( line ) <EOL> def open_stack_viewer ( self , event = None ) : <EOL> if self . interp . rpcclt : <EOL> return self . interp . remote_stack_viewer ( ) <EOL> try : <EOL> sys . last_traceback <EOL> except : <EOL> tkMessageBox . showerror ( \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> master = self . text ) <EOL> return <EOL> from idlelib . StackViewer import StackBrowser <EOL> StackBrowser ( self . root , self . flist ) <EOL> def view_restart_mark ( self , event = None ) : <EOL> self . text . see ( \"<STR_LIT>\" ) <EOL> self . text . see ( \"<STR_LIT>\" ) <EOL> def restart_shell ( self , event = None ) : <EOL> \"<STR_LIT>\" <EOL> self . interp . restart_subprocess ( with_cwd = True ) <EOL> def showprompt ( self ) : <EOL> self . resetoutput ( ) <EOL> try : <EOL> s = str ( sys . ps1 ) <EOL> except : <EOL> s = \"<STR_LIT>\" <EOL> self . console . write ( s ) <EOL> self . text . mark_set ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . set_line_and_column ( ) <EOL> self . io . reset_undo ( ) <EOL> def resetoutput ( self ) : <EOL> source = self . text . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if self . history : <EOL> self . history . store ( source ) <EOL> if self . text . get ( \"<STR_LIT>\" ) != \"<STR_LIT:\\n>\" : <EOL> self . text . insert ( \"<STR_LIT>\" , \"<STR_LIT:\\n>\" ) <EOL> self . text . mark_set ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . set_line_and_column ( ) <EOL> sys . stdout . softspace = <NUM_LIT:0> <EOL> def write ( self , s , tags = ( ) ) : <EOL> try : <EOL> self . text . mark_gravity ( \"<STR_LIT>\" , \"<STR_LIT:right>\" ) <EOL> OutputWindow . write ( self , s , tags , \"<STR_LIT>\" ) <EOL> self . text . mark_gravity ( \"<STR_LIT>\" , \"<STR_LIT:left>\" ) <EOL> except : <EOL> pass <EOL> if self . canceled : <EOL> self . canceled = <NUM_LIT:0> <EOL> if not use_subprocess : <EOL> raise KeyboardInterrupt <EOL> def rmenu_check_cut ( self ) : <EOL> try : <EOL> if self . text . compare ( '<STR_LIT>' , '<STR_LIT:<>' , '<STR_LIT>' ) : <EOL> return '<STR_LIT>' <EOL> except TclError : <EOL> return '<STR_LIT>' <EOL> return super ( PyShell , self ) . rmenu_check_cut ( ) <EOL> def rmenu_check_paste ( self ) : <EOL> if self . text . compare ( '<STR_LIT>' , '<STR_LIT:<>' , '<STR_LIT>' ) : <EOL> return '<STR_LIT>' <EOL> return super ( PyShell , self ) . rmenu_check_paste ( ) <EOL> class PseudoFile ( io . TextIOBase ) : <EOL> def __init__ ( self , shell , tags , encoding = None ) : <EOL> self . shell = shell <EOL> self . tags = tags <EOL> self . softspace = <NUM_LIT:0> <EOL> self . _encoding = encoding <EOL> @ property <EOL> def encoding ( self ) : <EOL> return self . _encoding <EOL> @ property <EOL> def name ( self ) : <EOL> return '<STR_LIT>' % self . tags <EOL> def isatty ( self ) : <EOL> return True <EOL> class PseudoOutputFile ( PseudoFile ) : <EOL> def writable ( self ) : <EOL> return True <EOL> def write ( self , s ) : <EOL> if self . closed : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if type ( s ) not in ( unicode , str , bytearray ) : <EOL> if isinstance ( s , unicode ) : <EOL> s = unicode . __getitem__ ( s , slice ( None ) ) <EOL> elif isinstance ( s , str ) : <EOL> s = str . __str__ ( s ) <EOL> elif isinstance ( s , bytearray ) : <EOL> s = bytearray . __str__ ( s ) <EOL> else : <EOL> raise TypeError ( '<STR_LIT>' + type ( s ) . __name__ ) <EOL> return self . shell . write ( s , self . tags ) <EOL> class PseudoInputFile ( PseudoFile ) : <EOL> def __init__ ( self , shell , tags , encoding = None ) : <EOL> PseudoFile . __init__ ( self , shell , tags , encoding ) <EOL> self . _line_buffer = '<STR_LIT>' <EOL> def readable ( self ) : <EOL> return True <EOL> def read ( self , size = - <NUM_LIT:1> ) : <EOL> if self . closed : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if size is None : <EOL> size = - <NUM_LIT:1> <EOL> elif not isinstance ( size , int ) : <EOL> raise TypeError ( '<STR_LIT>' + type ( size ) . __name__ ) <EOL> result = self . _line_buffer <EOL> self . _line_buffer = '<STR_LIT>' <EOL> if size < <NUM_LIT:0> : <EOL> while True : <EOL> line = self . shell . readline ( ) <EOL> if not line : break <EOL> result += line <EOL> else : <EOL> while len ( result ) < size : <EOL> line = self . shell . readline ( ) <EOL> if not line : break <EOL> result += line <EOL> self . _line_buffer = result [ size : ] <EOL> result = result [ : size ] <EOL> return result <EOL> def readline ( self , size = - <NUM_LIT:1> ) : <EOL> if self . closed : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if size is None : <EOL> size = - <NUM_LIT:1> <EOL> elif not isinstance ( size , int ) : <EOL> raise TypeError ( '<STR_LIT>' + type ( size ) . __name__ ) <EOL> line = self . _line_buffer or self . shell . readline ( ) <EOL> if size < <NUM_LIT:0> : <EOL> size = len ( line ) <EOL> eol = line . find ( '<STR_LIT:\\n>' , <NUM_LIT:0> , size ) <EOL> if eol >= <NUM_LIT:0> : <EOL> size = eol + <NUM_LIT:1> <EOL> self . _line_buffer = line [ size : ] <EOL> return line [ : size ] <EOL> def close ( self ) : <EOL> self . shell . close ( ) <EOL> usage_msg = \"\"\"<STR_LIT>\"\"\" <EOL> def main ( ) : <EOL> global flist , root , use_subprocess <EOL> capture_warnings ( True ) <EOL> use_subprocess = True <EOL> enable_shell = False <EOL> enable_edit = False <EOL> debug = False <EOL> cmd = None <EOL> script = None <EOL> startup = False <EOL> try : <EOL> opts , args = getopt . getopt ( sys . argv [ <NUM_LIT:1> : ] , \"<STR_LIT>\" ) <EOL> except getopt . error as msg : <EOL> print ( \"<STR_LIT>\" % ( msg , usage_msg ) , file = sys . stderr ) <EOL> sys . exit ( <NUM_LIT:2> ) <EOL> for o , a in opts : <EOL> if o == '<STR_LIT:-c>' : <EOL> cmd = a <EOL> enable_shell = True <EOL> if o == '<STR_LIT>' : <EOL> debug = True <EOL> enable_shell = True <EOL> if o == '<STR_LIT>' : <EOL> enable_edit = True <EOL> if o == '<STR_LIT>' : <EOL> sys . stdout . write ( usage_msg ) <EOL> sys . exit ( ) <EOL> if o == '<STR_LIT>' : <EOL> enable_shell = True <EOL> if o == '<STR_LIT>' : <EOL> use_subprocess = False <EOL> if o == '<STR_LIT>' : <EOL> script = a <EOL> if os . path . isfile ( script ) : <EOL> pass <EOL> else : <EOL> print ( \"<STR_LIT>\" , script , file = sys . stderr ) <EOL> sys . exit ( ) <EOL> enable_shell = True <EOL> if o == '<STR_LIT>' : <EOL> startup = True <EOL> enable_shell = True <EOL> if o == '<STR_LIT>' : <EOL> PyShell . shell_title = a <EOL> enable_shell = True <EOL> if args and args [ <NUM_LIT:0> ] == '<STR_LIT:->' : <EOL> cmd = sys . stdin . read ( ) <EOL> enable_shell = True <EOL> for i in range ( len ( sys . path ) ) : <EOL> sys . path [ i ] = os . path . abspath ( sys . path [ i ] ) <EOL> if args and args [ <NUM_LIT:0> ] == '<STR_LIT:->' : <EOL> sys . argv = [ '<STR_LIT>' ] + args [ <NUM_LIT:1> : ] <EOL> elif cmd : <EOL> sys . argv = [ '<STR_LIT:-c>' ] + args <EOL> elif script : <EOL> sys . argv = [ script ] + args <EOL> elif args : <EOL> enable_edit = True <EOL> pathx = [ ] <EOL> for filename in args : <EOL> pathx . append ( os . path . dirname ( filename ) ) <EOL> for dir in pathx : <EOL> dir = os . path . abspath ( dir ) <EOL> if dir not in sys . path : <EOL> sys . path . insert ( <NUM_LIT:0> , dir ) <EOL> else : <EOL> dir = os . getcwd ( ) <EOL> if not dir in sys . path : <EOL> sys . path . insert ( <NUM_LIT:0> , dir ) <EOL> edit_start = idleConf . GetOption ( '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , type = '<STR_LIT:bool>' ) <EOL> enable_edit = enable_edit or edit_start <EOL> enable_shell = enable_shell or not enable_edit <EOL> root = Tk ( className = \"<STR_LIT>\" ) <EOL> icondir = os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT>' ) <EOL> if system ( ) == '<STR_LIT>' : <EOL> iconfile = os . path . join ( icondir , '<STR_LIT>' ) <EOL>", "answer": "root . wm_iconbitmap ( default = iconfile )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . conf . urls import url <EOL>", "answer": "from oscar . apps . promotions . models import KeywordPromotion , PagePromotion"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> import logging <EOL> import warnings <EOL> class PipDeprecationWarning ( Warning ) : <EOL> pass <EOL> class RemovedInPip8Warning ( PipDeprecationWarning , PendingDeprecationWarning ) : <EOL> pass <EOL> class RemovedInPip9Warning ( PipDeprecationWarning , PendingDeprecationWarning ) : <EOL> pass <EOL> DEPRECATIONS = [ RemovedInPip8Warning , RemovedInPip9Warning ] <EOL> _warnings_showwarning = None <EOL> def _showwarning ( message , category , filename , lineno , file = None , line = None ) : <EOL> if file is not None : <EOL> if _warnings_showwarning is not None : <EOL> _warnings_showwarning ( <EOL> message , category , filename , lineno , file , line , <EOL> ) <EOL> else : <EOL> if issubclass ( category , PipDeprecationWarning ) : <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> log_message = \"<STR_LIT>\" % message <EOL> if issubclass ( category , DeprecationWarning ) : <EOL> logger . error ( log_message ) <EOL>", "answer": "else :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import time <EOL>", "answer": "import remi . server as server"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from south . utils import datetime_utils as datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . add_column ( u'<STR_LIT>' , '<STR_LIT:target>' , <EOL> self . gf ( '<STR_LIT>' ) ( default = '<STR_LIT>' , max_length = <NUM_LIT:10> ) , <EOL> keep_default = False ) <EOL> def backwards ( self , orm ) : <EOL> db . delete_column ( u'<STR_LIT>' , '<STR_LIT:target>' ) <EOL> models = { <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : u\"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : u\"<STR_LIT>\" } ) , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:to>' : u\"<STR_LIT>\" } ) , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:password>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:to>' : u\"<STR_LIT>\" } ) , <EOL> '<STR_LIT:username>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:state>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:1>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL>", "answer": "'<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from steve . restapi import urljoin <EOL> def test_urljoin ( ) : <EOL> data = [ <EOL> ( '<STR_LIT>' , [ '<STR_LIT>' ] , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , [ '<STR_LIT>' ] , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , [ '<STR_LIT>' ] , '<STR_LIT>' ) , <EOL> ] <EOL>", "answer": "for base , args , expected in data :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from __future__ import with_statement <EOL> from contextlib import nested <EOL> from StringIO import StringIO <EOL> from nose . tools import ok_ <EOL> from fudge import with_fakes , Fake <EOL> from fudge . inspector import arg as fudge_arg <EOL> from paramiko . sftp_client import SFTPClient <EOL> from fabric . state import env , output <EOL> from fabric . operations import require , prompt , _sudo_prefix , _shell_wrap , _shell_escape <EOL> from fabric . api import get , put , hide , show , cd , lcd , local , run , sudo , quiet <EOL> from fabric . exceptions import CommandTimeout <EOL> from fabric . decorators import with_settings <EOL> from utils import * <EOL> from server import ( server , PORT , RESPONSES , FILES , PASSWORDS , CLIENT_PRIVKEY , <EOL> USER , CLIENT_PRIVKEY_PASSPHRASE ) <EOL> def test_require_single_existing_key ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> require ( '<STR_LIT:version>' ) <EOL> def test_require_multiple_existing_keys ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> require ( '<STR_LIT:version>' , '<STR_LIT>' ) <EOL> @ aborts <EOL> def test_require_single_missing_key ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> require ( '<STR_LIT>' ) <EOL> @ aborts <EOL> def test_require_multiple_missing_keys ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> require ( '<STR_LIT:foo>' , '<STR_LIT:bar>' ) <EOL> @ aborts <EOL> def test_require_mixed_state_keys ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> require ( '<STR_LIT:foo>' , '<STR_LIT:version>' ) <EOL> @ mock_streams ( '<STR_LIT>' ) <EOL> def test_require_mixed_state_keys_prints_missing_only ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> require ( '<STR_LIT:foo>' , '<STR_LIT:version>' ) <EOL> except SystemExit : <EOL> err = sys . stderr . getvalue ( ) <EOL> assert '<STR_LIT:version>' not in err <EOL> assert '<STR_LIT:foo>' in err <EOL> @ aborts <EOL> def test_require_iterable_provided_by_key ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def fake_providing_function ( ) : <EOL> pass <EOL> require ( '<STR_LIT:foo>' , provided_by = [ fake_providing_function ] ) <EOL> @ aborts <EOL> def test_require_noniterable_provided_by_key ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def fake_providing_function ( ) : <EOL> pass <EOL> require ( '<STR_LIT:foo>' , provided_by = fake_providing_function ) <EOL> @ aborts <EOL> def test_require_key_exists_empty_list ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> require ( '<STR_LIT>' ) <EOL> @ aborts <EOL> @ with_settings ( foo = { } ) <EOL> def test_require_key_exists_empty_dict ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> require ( '<STR_LIT:foo>' ) <EOL> @ aborts <EOL> @ with_settings ( foo = ( ) ) <EOL> def test_require_key_exists_empty_tuple ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> require ( '<STR_LIT:foo>' ) <EOL> @ aborts <EOL> @ with_settings ( foo = set ( ) ) <EOL> def test_require_key_exists_empty_set ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> require ( '<STR_LIT:foo>' ) <EOL> @ with_settings ( foo = <NUM_LIT:0> , bar = False ) <EOL> def test_require_key_exists_false_primitive_values ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> require ( '<STR_LIT:foo>' , '<STR_LIT:bar>' ) <EOL> @ with_settings ( foo = [ '<STR_LIT:foo>' ] , bar = { '<STR_LIT:bar>' : '<STR_LIT:bar>' } , baz = ( '<STR_LIT>' , ) , qux = set ( '<STR_LIT>' ) ) <EOL> def test_require_complex_non_empty_values ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> require ( '<STR_LIT:foo>' , '<STR_LIT:bar>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def p ( x ) : <EOL> sys . stdout . write ( x ) <EOL> @ mock_streams ( '<STR_LIT>' ) <EOL> @ with_patched_input ( p ) <EOL> def test_prompt_appends_space ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> s = \"<STR_LIT>\" <EOL> prompt ( s ) <EOL> eq_ ( sys . stdout . getvalue ( ) , s + '<STR_LIT:U+0020>' ) <EOL> @ mock_streams ( '<STR_LIT>' ) <EOL> @ with_patched_input ( p ) <EOL> def test_prompt_with_default ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> s = \"<STR_LIT>\" <EOL> d = \"<STR_LIT>\" <EOL> prompt ( s , default = d ) <EOL> eq_ ( sys . stdout . getvalue ( ) , \"<STR_LIT>\" % ( s , d ) ) <EOL> def test_sudo_prefix_with_user ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> eq_ ( <EOL> _sudo_prefix ( user = \"<STR_LIT:foo>\" , group = None ) , <EOL> \"<STR_LIT>\" % ( env . sudo_prefix % env ) <EOL> ) <EOL> def test_sudo_prefix_without_user ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> eq_ ( _sudo_prefix ( user = None , group = None ) , env . sudo_prefix % env ) <EOL> def test_sudo_prefix_with_group ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> eq_ ( <EOL> _sudo_prefix ( user = None , group = \"<STR_LIT:foo>\" ) , <EOL> \"<STR_LIT>\" % ( env . sudo_prefix % env ) <EOL> ) <EOL> def test_sudo_prefix_with_user_and_group ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> eq_ ( <EOL> _sudo_prefix ( user = \"<STR_LIT:foo>\" , group = \"<STR_LIT:bar>\" ) , <EOL> \"<STR_LIT>\" % ( env . sudo_prefix % env ) <EOL> ) <EOL> @ with_settings ( use_shell = True ) <EOL> def test_shell_wrap ( ) : <EOL> prefix = \"<STR_LIT>\" <EOL> command = \"<STR_LIT>\" <EOL> for description , shell , sudo_prefix , result in ( <EOL> ( \"<STR_LIT>\" , <EOL> True , None , '<STR_LIT>' % ( env . shell , command ) ) , <EOL> ( \"<STR_LIT>\" , <EOL> True , prefix , prefix + '<STR_LIT>' % ( env . shell , command ) ) , <EOL> ( \"<STR_LIT>\" , <EOL> False , None , command ) , <EOL> ( \"<STR_LIT>\" , <EOL> False , prefix , prefix + \"<STR_LIT:U+0020>\" + command ) , <EOL> ) : <EOL> eq_ . description = \"<STR_LIT>\" % description <EOL> yield eq_ , _shell_wrap ( command , shell_escape = True , shell = shell , sudo_prefix = sudo_prefix ) , result <EOL> del eq_ . description <EOL> @ with_settings ( use_shell = True ) <EOL> def test_shell_wrap_escapes_command_if_shell_is_true ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cmd = \"<STR_LIT>\" <EOL> eq_ ( <EOL> _shell_wrap ( cmd , shell_escape = True , shell = True ) , <EOL> '<STR_LIT>' % ( env . shell , _shell_escape ( cmd ) ) <EOL> ) <EOL> @ with_settings ( use_shell = True ) <EOL> def test_shell_wrap_does_not_escape_command_if_shell_is_true_and_shell_escape_is_false ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cmd = \"<STR_LIT>\" <EOL> eq_ ( <EOL> _shell_wrap ( cmd , shell_escape = False , shell = True ) , <EOL> '<STR_LIT>' % ( env . shell , cmd ) <EOL> ) <EOL> def test_shell_wrap_does_not_escape_command_if_shell_is_false ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cmd = \"<STR_LIT>\" <EOL> eq_ ( _shell_wrap ( cmd , shell_escape = True , shell = False ) , cmd ) <EOL> def test_shell_escape_escapes_doublequotes ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cmd = \"<STR_LIT>\" <EOL> eq_ ( _shell_escape ( cmd ) , '<STR_LIT>' ) <EOL> def test_shell_escape_escapes_dollar_signs ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cmd = \"<STR_LIT>\" <EOL> eq_ ( _shell_escape ( cmd ) , '<STR_LIT>' ) <EOL> def test_shell_escape_escapes_backticks ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cmd = \"<STR_LIT>\" <EOL> eq_ ( _shell_escape ( cmd ) , \"<STR_LIT>\" ) <EOL> class TestCombineStderr ( FabricTest ) : <EOL> @ server ( ) <EOL> def test_local_none_global_true ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> output . everything = False <EOL> r = run ( \"<STR_LIT>\" ) <EOL> eq_ ( \"<STR_LIT>\" , r . stdout ) <EOL> eq_ ( r . stderr , \"<STR_LIT>\" ) <EOL> @ server ( ) <EOL> def test_local_none_global_false ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> output . everything = False <EOL> env . combine_stderr = False <EOL> r = run ( \"<STR_LIT>\" ) <EOL> eq_ ( \"<STR_LIT>\" , r . stdout ) <EOL> eq_ ( \"<STR_LIT>\" , r . stderr ) <EOL> @ server ( ) <EOL> def test_local_true_global_false ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> output . everything = False <EOL> env . combine_stderr = False <EOL> r = run ( \"<STR_LIT>\" , combine_stderr = True ) <EOL> eq_ ( \"<STR_LIT>\" , r . stdout ) <EOL> eq_ ( r . stderr , \"<STR_LIT>\" ) <EOL> @ server ( ) <EOL> def test_local_false_global_true ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> output . everything = False <EOL> env . combine_stderr = True <EOL> r = run ( \"<STR_LIT>\" , combine_stderr = False ) <EOL> eq_ ( \"<STR_LIT>\" , r . stdout ) <EOL> eq_ ( \"<STR_LIT>\" , r . stderr ) <EOL> class TestQuietAndWarnKwargs ( FabricTest ) : <EOL> @ server ( responses = { '<STR_LIT>' : [ \"<STR_LIT>\" , \"<STR_LIT>\" , <NUM_LIT:1> ] } ) <EOL> def test_quiet_implies_warn_only ( self ) : <EOL> eq_ ( run ( \"<STR_LIT>\" , quiet = True ) . failed , True ) <EOL> @ server ( ) <EOL> @ mock_streams ( '<STR_LIT>' ) <EOL> def test_quiet_implies_hide_everything ( self ) : <EOL> run ( \"<STR_LIT>\" , quiet = True ) <EOL> eq_ ( sys . stdout . getvalue ( ) , \"<STR_LIT>\" ) <EOL> eq_ ( sys . stderr . getvalue ( ) , \"<STR_LIT>\" ) <EOL> @ server ( responses = { '<STR_LIT>' : [ \"<STR_LIT>\" , \"<STR_LIT>\" , <NUM_LIT:1> ] } ) <EOL> @ mock_streams ( '<STR_LIT>' ) <EOL> def test_warn_only_is_same_as_settings_warn_only ( self ) : <EOL> eq_ ( run ( \"<STR_LIT>\" , warn_only = True ) . failed , True ) <EOL> @ server ( ) <EOL> @ mock_streams ( '<STR_LIT>' ) <EOL> def test_warn_only_does_not_imply_hide_everything ( self ) : <EOL> run ( \"<STR_LIT>\" , warn_only = True ) <EOL> assert sys . stdout . getvalue ( ) != \"<STR_LIT>\" <EOL> class TestMultipleOKReturnCodes ( FabricTest ) : <EOL> @ server ( responses = { '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT:1> ] } ) <EOL> def test_expand_to_include_1 ( self ) : <EOL> with settings ( quiet ( ) , ok_ret_codes = [ <NUM_LIT:0> , <NUM_LIT:1> ] ) : <EOL> eq_ ( run ( \"<STR_LIT>\" ) . succeeded , True ) <EOL> slow_server = server ( responses = { '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:3> ] } ) <EOL> slow = lambda x : slow_server ( raises ( CommandTimeout ) ( x ) ) <EOL> class TestRun ( FabricTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ slow <EOL> def test_command_timeout_via_env_var ( self ) : <EOL> env . command_timeout = <NUM_LIT:2> <EOL> with hide ( '<STR_LIT>' ) : <EOL> run ( \"<STR_LIT>\" ) <EOL> @ slow <EOL> def test_command_timeout_via_kwarg ( self ) : <EOL> with hide ( '<STR_LIT>' ) : <EOL> run ( \"<STR_LIT>\" , timeout = <NUM_LIT:2> ) <EOL> @ slow <EOL> def test_command_timeout_via_env_var_in_sudo ( self ) : <EOL> env . command_timeout = <NUM_LIT:2> <EOL> with hide ( '<STR_LIT>' ) : <EOL> sudo ( \"<STR_LIT>\" ) <EOL> @ slow <EOL> def test_command_timeout_via_kwarg_of_sudo ( self ) : <EOL> with hide ( '<STR_LIT>' ) : <EOL> sudo ( \"<STR_LIT>\" , timeout = <NUM_LIT:2> ) <EOL> class TestFileTransfers ( FabricTest ) : <EOL> @ server ( files = { '<STR_LIT>' : '<STR_LIT>' } , home = '<STR_LIT>' ) <EOL> def test_get_relative_remote_dir_uses_home ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with hide ( '<STR_LIT>' ) : <EOL> eq_ ( get ( '<STR_LIT>' , self . path ( ) ) , [ self . path ( '<STR_LIT>' ) ] ) <EOL> @ server ( files = { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> def test_get_with_format_chars_on_server ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> remote = '<STR_LIT:*>' <EOL> with hide ( '<STR_LIT>' ) : <EOL> get ( remote , self . path ( ) ) <EOL> @ server ( ) <EOL> def test_get_single_file ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> remote = '<STR_LIT>' <EOL> local = self . path ( remote ) <EOL> with hide ( '<STR_LIT>' ) : <EOL> get ( remote , local ) <EOL> eq_contents ( local , FILES [ remote ] ) <EOL> @ server ( files = { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> def test_get_file_from_relative_path_with_spaces ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with hide ( '<STR_LIT>' ) : <EOL> with cd ( '<STR_LIT>' ) : <EOL> eq_ ( get ( '<STR_LIT:file>' , self . path ( ) ) , [ self . path ( '<STR_LIT:file>' ) ] ) <EOL> @ server ( ) <EOL> def test_get_sibling_globs ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> remotes = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> with hide ( '<STR_LIT>' ) : <EOL> get ( '<STR_LIT>' , self . tmpdir ) <EOL> for remote in remotes : <EOL> eq_contents ( self . path ( remote ) , FILES [ remote ] ) <EOL> @ server ( ) <EOL> def test_get_single_file_in_folder ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> remote = '<STR_LIT>' <EOL> with hide ( '<STR_LIT>' ) : <EOL> get ( '<STR_LIT>' , self . tmpdir ) <EOL> eq_contents ( self . path ( remote ) , FILES [ remote ] ) <EOL> @ server ( ) <EOL> def test_get_tree ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with hide ( '<STR_LIT>' ) : <EOL> get ( '<STR_LIT>' , self . tmpdir ) <EOL> leaves = filter ( lambda x : x [ <NUM_LIT:0> ] . startswith ( '<STR_LIT>' ) , FILES . items ( ) ) <EOL> for path , contents in leaves : <EOL> eq_contents ( self . path ( path [ <NUM_LIT:1> : ] ) , contents ) <EOL> @ server ( ) <EOL> def test_get_tree_with_implicit_local_path ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dirname = env . host_string . replace ( '<STR_LIT::>' , '<STR_LIT:->' ) <EOL> try : <EOL> with hide ( '<STR_LIT>' ) : <EOL> get ( '<STR_LIT>' ) <EOL> leaves = filter ( lambda x : x [ <NUM_LIT:0> ] . startswith ( '<STR_LIT>' ) , FILES . items ( ) ) <EOL> for path , contents in leaves : <EOL> path = os . path . join ( dirname , path [ <NUM_LIT:1> : ] ) <EOL> eq_contents ( path , contents ) <EOL> os . remove ( path ) <EOL> finally : <EOL> if os . path . exists ( dirname ) : <EOL> shutil . rmtree ( dirname ) <EOL> @ server ( ) <EOL> def test_get_absolute_path_should_save_relative ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> lpath = self . path ( ) <EOL> ltarget = os . path . join ( lpath , \"<STR_LIT>\" ) <EOL> with hide ( '<STR_LIT>' ) : <EOL> get ( '<STR_LIT>' , ltarget ) <EOL> assert self . exists_locally ( os . path . join ( lpath , '<STR_LIT>' ) ) <EOL> assert not self . exists_locally ( os . path . join ( lpath , '<STR_LIT>' ) ) <EOL> @ server ( ) <EOL> def test_path_formatstr_nonrecursively_is_just_filename ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> lpath = self . path ( ) <EOL> ltarget = os . path . join ( lpath , \"<STR_LIT>\" ) <EOL> with hide ( '<STR_LIT>' ) : <EOL> get ( '<STR_LIT>' , ltarget ) <EOL> assert self . exists_locally ( os . path . join ( lpath , '<STR_LIT>' ) ) <EOL> @ server ( ) <EOL> @ mock_streams ( '<STR_LIT>' ) <EOL> def _invalid_file_obj_situations ( self , remote_path ) : <EOL> with settings ( hide ( '<STR_LIT>' ) , warn_only = True ) : <EOL> get ( remote_path , StringIO ( ) ) <EOL> assert_contains ( '<STR_LIT>' , sys . stderr . getvalue ( ) ) <EOL> def test_glob_and_file_object_invalid ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _invalid_file_obj_situations ( '<STR_LIT>' ) <EOL> def test_directory_and_file_object_invalid ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _invalid_file_obj_situations ( '<STR_LIT>' ) <EOL> @ server ( ) <EOL> def test_get_single_file_absolutely ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> target = '<STR_LIT>' <EOL> with hide ( '<STR_LIT>' ) : <EOL> get ( target , self . tmpdir ) <EOL> eq_contents ( self . path ( os . path . basename ( target ) ) , FILES [ target ] ) <EOL> @ server ( ) <EOL> def test_get_file_with_nonexistent_target ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> local = self . path ( '<STR_LIT>' ) <EOL> target = '<STR_LIT>' <EOL> with hide ( '<STR_LIT>' ) : <EOL> get ( target , local ) <EOL> eq_contents ( local , FILES [ target ] ) <EOL> @ server ( ) <EOL> @ mock_streams ( '<STR_LIT>' ) <EOL> def test_get_file_with_existing_file_target ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> local = self . path ( '<STR_LIT>' ) <EOL> target = '<STR_LIT>' <EOL> with open ( local , '<STR_LIT:w>' ) as fd : <EOL> fd . write ( \"<STR_LIT:foo>\" ) <EOL> with hide ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> get ( target , local ) <EOL> assert \"<STR_LIT>\" % local in sys . stderr . getvalue ( ) <EOL> eq_contents ( local , FILES [ target ] ) <EOL> @ server ( ) <EOL> def test_get_file_to_directory ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> target = '<STR_LIT>' <EOL> with hide ( '<STR_LIT>' ) : <EOL> get ( target , self . tmpdir ) <EOL> eq_contents ( self . path ( target ) , FILES [ target ] ) <EOL> @ server ( port = <NUM_LIT> ) <EOL> @ server ( port = <NUM_LIT> ) <EOL> def test_get_from_multiple_servers ( self ) : <EOL> ports = [ <NUM_LIT> , <NUM_LIT> ] <EOL> hosts = map ( lambda x : '<STR_LIT>' % x , ports ) <EOL> with settings ( all_hosts = hosts ) : <EOL> for port in ports : <EOL> with settings ( <EOL> hide ( '<STR_LIT>' ) , host_string = '<STR_LIT>' % port <EOL> ) : <EOL> tmp = self . path ( '<STR_LIT>' ) <EOL> local_path = os . path . join ( tmp , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> path = '<STR_LIT>' <EOL> get ( path , local_path ) <EOL> assert self . exists_locally ( os . path . join ( <EOL> tmp , \"<STR_LIT>\" % port , path <EOL> ) ) <EOL> get ( '<STR_LIT>' , local_path ) <EOL> assert self . exists_locally ( os . path . join ( <EOL> tmp , \"<STR_LIT>\" % port , '<STR_LIT>' <EOL> ) ) <EOL> @ server ( ) <EOL> def test_get_from_empty_directory_uses_cwd ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with hide ( '<STR_LIT>' ) : <EOL> get ( '<STR_LIT>' , self . tmpdir ) <EOL> for x in \"<STR_LIT>\" . split ( ) : <EOL> assert os . path . exists ( os . path . join ( self . tmpdir , x ) ) <EOL> @ server ( ) <EOL> def _get_to_cwd ( self , arg ) : <EOL>", "answer": "path = '<STR_LIT>'"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from contracts import contract <EOL> from neat . contracts_primitive import * <EOL> from neat . contracts_extra import * <EOL> from numpy import median <EOL> from scipy . optimize import leastsq <EOL> import numpy as np <EOL> import logging <EOL> log = logging . getLogger ( __name__ ) <EOL> @ contract <EOL> def loess_factory ( time_step , migration_time , params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> migration_time_normalized = float ( migration_time ) / time_step <EOL> return lambda utilization , state = None : ( loess ( params [ '<STR_LIT>' ] , <EOL> params [ '<STR_LIT>' ] , <EOL> params [ '<STR_LIT>' ] , <EOL> migration_time_normalized , <EOL> utilization ) , <EOL> { } ) <EOL> @ contract <EOL> def loess_robust_factory ( time_step , migration_time , params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> migration_time_normalized = float ( migration_time ) / time_step <EOL> return lambda utilization , state = None : ( loess_robust ( params [ '<STR_LIT>' ] , <EOL> params [ '<STR_LIT>' ] , <EOL> params [ '<STR_LIT>' ] , <EOL> migration_time_normalized , <EOL> utilization ) , <EOL> { } ) <EOL> @ contract <EOL> def mad_threshold_factory ( time_step , migration_time , params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return lambda utilization , state = None : ( mad_threshold ( params [ '<STR_LIT>' ] , <EOL> params [ '<STR_LIT>' ] , <EOL> utilization ) , <EOL> { } ) <EOL> @ contract <EOL> def iqr_threshold_factory ( time_step , migration_time , params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return lambda utilization , state = None : ( iqr_threshold ( params [ '<STR_LIT>' ] , <EOL> params [ '<STR_LIT>' ] , <EOL> utilization ) , <EOL> { } ) <EOL> @ contract <EOL> def loess ( threshold , param , length , migration_time , utilization ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return loess_abstract ( loess_parameter_estimates , <EOL> threshold , <EOL> param , <EOL> length , <EOL> migration_time , <EOL> utilization ) <EOL> @ contract <EOL> def loess_robust ( threshold , param , length , migration_time , utilization ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return loess_abstract ( loess_robust_parameter_estimates , <EOL>", "answer": "threshold ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from . . excel_comparsion_test import ExcelComparisonTest <EOL> from ... workbook import Workbook <EOL> class TestCompareXLSXFiles ( ExcelComparisonTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . maxDiff = None <EOL> filename = '<STR_LIT>' <EOL> test_dir = '<STR_LIT>' <EOL> self . got_filename = test_dir + '<STR_LIT>' + filename <EOL> self . exp_filename = test_dir + '<STR_LIT>' + filename <EOL> self . ignore_files = [ ] <EOL> self . ignore_elements = { } <EOL> def test_create_file ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> workbook = Workbook ( self . got_filename ) <EOL> worksheet = workbook . add_worksheet ( ) <EOL> chart = workbook . add_chart ( { '<STR_LIT:type>' : '<STR_LIT>' } ) <EOL> chart . axis_ids = [ <NUM_LIT> , <NUM_LIT> ] <EOL> data = [ <EOL> [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> ] , <EOL> [ <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:6> , <NUM_LIT:8> , <NUM_LIT:10> ] , <EOL> [ <NUM_LIT:3> , <NUM_LIT:6> , <NUM_LIT:9> , <NUM_LIT:12> , <NUM_LIT:15> ] , <EOL> ] <EOL> worksheet . write_column ( '<STR_LIT>' , data [ <NUM_LIT:0> ] ) <EOL> worksheet . write_column ( '<STR_LIT>' , data [ <NUM_LIT:1> ] ) <EOL> worksheet . write_column ( '<STR_LIT>' , data [ <NUM_LIT:2> ] ) <EOL> chart . add_series ( { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> chart . add_series ( { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> chart . add_series ( { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> chart . set_x_axis ( { '<STR_LIT>' : <NUM_LIT:1> } ) <EOL>", "answer": "worksheet . insert_chart ( '<STR_LIT>' , chart )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import time <EOL> import random <EOL> import logging <EOL> import requests <EOL> import yaml <EOL> import redis <EOL> import gevent <EOL> from gevent . pool import Pool , Group <EOL> from gevent . timeout import Timeout <EOL> from gevent import monkey <EOL> from lxml import etree <EOL> monkey . patch_all ( thread = False , select = False ) <EOL> logging . basicConfig ( level = logging . INFO , <EOL> format = '<STR_LIT>' , <EOL> datefmt = '<STR_LIT>' ) <EOL> class ProxyPool ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , configfile = '<STR_LIT>' ) : <EOL> self . configs = self . _get_configs ( configfile ) <EOL> self . rdb = redis . StrictRedis ( db = self . configs [ '<STR_LIT>' ] ) <EOL> self . db_zproxy = self . configs [ '<STR_LIT>' ] <EOL> self . pool = Pool ( self . configs [ '<STR_LIT>' ] ) <EOL> self . group = Group ( ) <EOL> self . wrong_value = self . configs [ '<STR_LIT>' ] <EOL> self . init_value = self . configs [ '<STR_LIT>' ] <EOL> def _get_configs ( self , configfile ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> configpath = os . path . join ( '<STR_LIT:.>' , configfile ) <EOL> with open ( configpath , '<STR_LIT:rb>' ) as fp : <EOL> configs = yaml . load ( fp ) <EOL> return configs <EOL> def get_many ( self , num = <NUM_LIT:3> , minscore = <NUM_LIT:0> , maxscore = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> minscore = minscore <EOL> maxscore = maxscore or self . init_value <EOL> res = self . rdb . zrange ( self . db_zproxy , minscore , maxscore ) <EOL> if res : <EOL> random . shuffle ( res ) <EOL>", "answer": "if len ( res ) < num :"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from importlib import import_module <EOL> from django . conf import settings <EOL> from django . test . utils import override_settings <EOL> from django . utils . translation import LANGUAGE_SESSION_KEY <EOL> from cms import api <EOL> from cms . test_utils . testcases import CMSTestCase <EOL> from cms . utils import i18n <EOL> @ override_settings ( <EOL> LANGUAGE_CODE = '<STR_LIT>' , <EOL> LANGUAGES = ( ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) ) , <EOL> CMS_LANGUAGES = { <EOL> <NUM_LIT:1> : [ { '<STR_LIT:code>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : True } , <EOL> { '<STR_LIT:code>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : False } , <EOL> ] , <EOL> '<STR_LIT:default>' : { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> } , <EOL> SITE_ID = <NUM_LIT:1> , <EOL> ) <EOL> class TestLanguages ( CMSTestCase ) : <EOL> def test_language_code ( self ) : <EOL> self . assertEqual ( i18n . get_language_code ( '<STR_LIT>' ) , '<STR_LIT>' ) <EOL> self . assertEqual ( i18n . get_current_language ( ) , '<STR_LIT>' ) <EOL> def test_get_languages_default_site ( self ) : <EOL> result = i18n . get_languages ( ) <EOL> self . assertEqual ( <NUM_LIT:2> , len ( result ) ) <EOL> lang = result [ <NUM_LIT:0> ] <EOL> self . assertEqual ( lang [ '<STR_LIT:code>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( i18n . get_language_code ( lang [ '<STR_LIT:code>' ] ) , '<STR_LIT>' ) <EOL> self . assertEqual ( lang [ '<STR_LIT>' ] , True ) <EOL> lang = result [ <NUM_LIT:1> ] <EOL> self . assertEqual ( lang [ '<STR_LIT:code>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( i18n . get_language_code ( lang [ '<STR_LIT:code>' ] ) , '<STR_LIT>' ) <EOL>", "answer": "self . assertEqual ( lang [ '<STR_LIT>' ] , False )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> class Shift ( object ) : <EOL> def __init__ ( self , area , width = <NUM_LIT:4> , char = '<STR_LIT:U+0020>' ) : <EOL> self . width = width <EOL> self . char = char <EOL> area . install ( ( '<STR_LIT>' , '<STR_LIT>' , lambda event : event . widget . shift_sel_right ( self . width , self . char ) ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , lambda event : event . widget . shift_sel_left ( self . width ) ) ) <EOL>", "answer": "install = Shift "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "DEBUG = False"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import unittest <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> class SequencePathTest ( GafferTest . TestCase ) : <EOL> def __dictPath ( self ) : <EOL> dict = { } <EOL> dict [ \"<STR_LIT>\" ] = { } <EOL> for f in IECore . FileSequence ( \"<STR_LIT>\" ) . fileNames ( ) : <EOL> dict [ \"<STR_LIT>\" ] [ f ] = <NUM_LIT:1> <EOL> for f in IECore . FileSequence ( \"<STR_LIT>\" ) . fileNames ( ) : <EOL> dict [ \"<STR_LIT>\" ] [ f ] = <NUM_LIT:1> <EOL> return Gaffer . DictPath ( dict , \"<STR_LIT:/>\" ) <EOL> def test ( self ) : <EOL> path = Gaffer . SequencePath ( self . __dictPath ( ) ) <EOL> self . failUnless ( path . isValid ( ) ) <EOL> self . failUnless ( not path . isLeaf ( ) ) <EOL> path . append ( \"<STR_LIT>\" ) <EOL> self . failUnless ( path . isValid ( ) ) <EOL> self . failUnless ( not path . isLeaf ( ) ) <EOL> path [ <NUM_LIT:0> ] = \"<STR_LIT>\" <EOL> self . failIf ( path . isValid ( ) ) <EOL> self . failIf ( path . isLeaf ( ) ) <EOL> path [ : ] = [ \"<STR_LIT>\" ] <EOL> children = path . children ( ) <EOL> for child in children : <EOL> self . failUnless ( isinstance ( child , Gaffer . SequencePath ) ) <EOL> self . assertEqual ( len ( children ) , <NUM_LIT:2> ) <EOL> childrenStrings = [ str ( c ) for c in children ] <EOL> self . failUnless ( \"<STR_LIT>\" in childrenStrings ) <EOL> self . failUnless ( \"<STR_LIT>\" in childrenStrings ) <EOL> def testNonLeafChildren ( self ) : <EOL> path = Gaffer . SequencePath ( self . __dictPath ( ) ) <EOL> children = path . children ( ) <EOL> for child in children : <EOL> self . failUnless ( isinstance ( child , Gaffer . SequencePath ) ) <EOL> self . assertEqual ( len ( children ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( str ( children [ <NUM_LIT:0> ] ) , \"<STR_LIT>\" ) <EOL> def testCopy ( self ) : <EOL> path = Gaffer . SequencePath ( self . __dictPath ( ) ) <EOL> path . append ( \"<STR_LIT>\" ) <EOL> path2 = path . copy ( ) <EOL> self . failUnless ( isinstance ( path2 , Gaffer . SequencePath ) ) <EOL> self . assertEqual ( path [ : ] , path2 [ : ] ) <EOL> self . failUnless ( path . getFilter ( ) is path2 . getFilter ( ) ) <EOL> c = [ str ( p ) for p in path . children ( ) ] <EOL> c2 = [ str ( p ) for p in path2 . children ( ) ] <EOL> self . assertEqual ( c , c2 ) <EOL> def testInfo ( self ) : <EOL> dictPath = self . __dictPath ( ) <EOL> path = Gaffer . SequencePath ( dictPath ) <EOL> self . assertEqual ( dictPath . info ( ) , path . info ( ) ) <EOL> def testInfoOfInvalidPath ( self ) : <EOL> fp = Gaffer . FileSystemPath ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( fp . isValid ( ) , False ) <EOL> self . assertEqual ( fp . info ( ) , None ) <EOL> sp = Gaffer . SequencePath ( fp ) <EOL> self . assertEqual ( sp . isValid ( ) , False ) <EOL> self . assertEqual ( sp . info ( ) , None ) <EOL> def testFilter ( self ) : <EOL> dictPath = self . __dictPath ( ) <EOL>", "answer": "path = Gaffer . SequencePath ( dictPath )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from sahara . api import acl <EOL> from sahara . service . api . v2 import job_executions as api <EOL> from sahara . service import validation as v <EOL> from sahara . service . validations . edp import job_execution as v_j_e <EOL> from sahara . service . validations . edp import job_execution_schema as v_j_e_schema <EOL> import sahara . utils . api as u <EOL>", "answer": "rest = u . RestV2 ( '<STR_LIT>' , __name__ )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> import math <EOL> try : <EOL> from _json import encode_basestring_ascii as c_encode_basestring_ascii <EOL> except ImportError : <EOL> c_encode_basestring_ascii = None <EOL> __all__ = [ '<STR_LIT>' ] <EOL> ESCAPE = re . compile ( r'<STR_LIT>' ) <EOL> ESCAPE_ASCII = re . compile ( r'<STR_LIT>' ) <EOL> HAS_UTF8 = re . compile ( r'<STR_LIT>' ) <EOL> ESCAPE_DCT = { <EOL> '<STR_LIT:\\\\>' : '<STR_LIT>' , <EOL> '<STR_LIT:\">' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:\\n>' : '<STR_LIT>' , <EOL> '<STR_LIT:\\r>' : '<STR_LIT>' , <EOL> '<STR_LIT:\\t>' : '<STR_LIT>' , <EOL> } <EOL> for i in range ( <NUM_LIT> ) : <EOL> ESCAPE_DCT . setdefault ( chr ( i ) , '<STR_LIT>' . format ( i ) ) <EOL> FLOAT_REPR = repr <EOL> def floatstr ( o , allow_nan = True ) : <EOL> if math . isnan ( o ) : <EOL> text = '<STR_LIT>' <EOL> elif math . isinf ( o ) : <EOL> if math . copysign ( <NUM_LIT:1.> , o ) == <NUM_LIT:1.> : <EOL> text = '<STR_LIT>' <EOL> else : <EOL> text = '<STR_LIT>' <EOL> else : <EOL> return FLOAT_REPR ( o ) <EOL> if not allow_nan : <EOL> msg = \"<STR_LIT>\" + repr ( o ) <EOL> raise ValueError ( msg ) <EOL> return text <EOL> def encode_basestring ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def replace ( match ) : <EOL> return ESCAPE_DCT [ match . group ( <NUM_LIT:0> ) ] <EOL> return '<STR_LIT:\">' + ESCAPE . sub ( replace , s ) + '<STR_LIT:\">' <EOL> def py_encode_basestring_ascii ( s ) : <EOL> if isinstance ( s , str ) and HAS_UTF8 . search ( s ) is not None : <EOL> s = s . decode ( '<STR_LIT:utf-8>' ) <EOL> def replace ( match ) : <EOL> s = match . group ( <NUM_LIT:0> ) <EOL> try : <EOL> return ESCAPE_DCT [ s ] <EOL> except KeyError : <EOL> n = ord ( s ) <EOL> if n < <NUM_LIT> : <EOL> return '<STR_LIT>' . format ( n ) <EOL> else : <EOL> n -= <NUM_LIT> <EOL> s1 = <NUM_LIT> | ( ( n >> <NUM_LIT:10> ) & <NUM_LIT> ) <EOL> s2 = <NUM_LIT> | ( n & <NUM_LIT> ) <EOL> return '<STR_LIT>' . format ( s1 , s2 ) <EOL> return '<STR_LIT:\">' + str ( ESCAPE_ASCII . sub ( replace , s ) ) + '<STR_LIT:\">' <EOL> if c_encode_basestring_ascii is not None : <EOL> encode_basestring_ascii = c_encode_basestring_ascii <EOL> else : <EOL> encode_basestring_ascii = py_encode_basestring_ascii <EOL> class JSONEncoder ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT:default>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> item_separator = '<STR_LIT:U+002CU+0020>' <EOL> key_separator = '<STR_LIT>' <EOL> def __init__ ( self , skipkeys = False , ensure_ascii = True , <EOL> check_circular = True , allow_nan = True , sort_keys = False , <EOL> indent = None , separators = None , encoding = '<STR_LIT:utf-8>' , default = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . skipkeys = skipkeys <EOL> self . ensure_ascii = ensure_ascii <EOL> self . check_circular = check_circular <EOL> self . allow_nan = allow_nan <EOL> self . sort_keys = sort_keys <EOL> self . indent = indent <EOL> self . current_indent_level = <NUM_LIT:0> <EOL> if separators is not None : <EOL> self . item_separator , self . key_separator = separators <EOL> if default is not None : <EOL> self . default = default <EOL> self . encoding = encoding <EOL> def _newline_indent ( self ) : <EOL> return '<STR_LIT:\\n>' + ( '<STR_LIT:U+0020>' * ( self . indent * self . current_indent_level ) ) <EOL> def _iterencode_list ( self , lst , markers = None ) : <EOL> if not lst : <EOL> yield '<STR_LIT>' <EOL> return <EOL> if markers is not None : <EOL> markerid = id ( lst ) <EOL> if markerid in markers : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> markers [ markerid ] = lst <EOL> yield '<STR_LIT:[>' <EOL> if self . indent is not None : <EOL> self . current_indent_level += <NUM_LIT:1> <EOL> newline_indent = self . _newline_indent ( ) <EOL> separator = self . item_separator + newline_indent <EOL> yield newline_indent <EOL> else : <EOL> newline_indent = None <EOL> separator = self . item_separator <EOL> first = True <EOL> for value in lst : <EOL> if first : <EOL> first = False <EOL> else : <EOL> yield separator <EOL> for chunk in self . _iterencode ( value , markers ) : <EOL> yield chunk <EOL> if newline_indent is not None : <EOL> self . current_indent_level -= <NUM_LIT:1> <EOL>", "answer": "yield self . _newline_indent ( )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from google . appengine . api import users <EOL> from simian import settings <EOL> from simian . mac import admin <EOL> from simian . mac . common import mail <EOL> from simian . mac . munki import common <EOL> class AdminPanic ( admin . AdminHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def get ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . IsAdminUser ( ) : <EOL> return <EOL> modes = [ ] <EOL> for mode in common . PANIC_MODES : <EOL> d = { <EOL> '<STR_LIT:name>' : mode , <EOL> '<STR_LIT>' : common . IsPanicMode ( mode ) , <EOL> } <EOL> modes . append ( d ) <EOL> self . Render ( <EOL> '<STR_LIT>' , { '<STR_LIT>' : modes , '<STR_LIT>' : '<STR_LIT>' } ) <EOL> def post ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . IsAdminUser ( ) : <EOL> return <EOL> mode = self . request . get ( '<STR_LIT>' ) <EOL> enabled = self . request . get ( '<STR_LIT>' ) <EOL> verify = self . request . get ( '<STR_LIT>' ) <EOL> if not verify : <EOL> self . Render ( <EOL> '<STR_LIT>' , <EOL>", "answer": "{ '<STR_LIT>' : { '<STR_LIT:name>' : mode , '<STR_LIT>' : enabled } , '<STR_LIT>' : '<STR_LIT>' } )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> '''<STR_LIT>''' <EOL> from setuptools import setup <EOL> setup ( <EOL> name = \"<STR_LIT>\" , <EOL> version = \"<STR_LIT>\" , <EOL> author = \"<STR_LIT>\" , <EOL> author_email = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> license = '<STR_LIT>' , <EOL> keywords = '<STR_LIT>' , <EOL> url = \"<STR_LIT>\" , <EOL> long_description = \"<STR_LIT>\" , <EOL> packages = [ '<STR_LIT>' , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:test>\" ] , <EOL> include_package_data = True , <EOL> package_data = { <EOL> '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } , <EOL>", "answer": ") "}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os <EOL> from urlparse import urlparse <EOL> from lockfile import FileLock <EOL>", "answer": "from . import CatalogCoordinator"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from django . conf . urls import patterns , include , url <EOL>", "answer": "import health_check"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import ( <EOL> absolute_import , division , print_function , with_statement , <EOL> unicode_literals ) <EOL> import sys <EOL> import itertools as it <EOL> from os import getcwd , path as p <EOL> from argparse import RawTextHelpFormatter , ArgumentParser <EOL> from builtins import * <EOL> import pygogo as gogo <EOL> HDLRS_FULL = tuple ( h for h in dir ( gogo . handlers ) if h . endswith ( '<STR_LIT>' ) ) <EOL> HDLRS = tuple ( h [ : - <NUM_LIT:5> ] for h in HDLRS_FULL ) <EOL> LEVELS = ( '<STR_LIT>' , '<STR_LIT:error>' , '<STR_LIT>' , '<STR_LIT:info>' , '<STR_LIT>' ) <EOL> FRMTRS_FULL = tuple ( f for f in dir ( gogo . formatters ) if f . endswith ( '<STR_LIT>' ) ) <EOL> FORMATS = tuple ( f [ : - <NUM_LIT:10> ] for f in FRMTRS_FULL ) <EOL> CURDIR = p . basename ( getcwd ( ) ) <EOL> LOGFILE = '<STR_LIT>' % CURDIR <EOL> parser = ArgumentParser ( <EOL>", "answer": "description = '<STR_LIT>' , prog = '<STR_LIT>' ,"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> import os . path <EOL> import subprocess <EOL> import yaml <EOL> def find_modified_deliverable_files ( reporoot ) : <EOL> \"<STR_LIT>\" <EOL> results = subprocess . check_output ( <EOL> [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> cwd = reporoot , <EOL> ) <EOL> filenames = [ <EOL> l . strip ( ) <EOL> for l in results . splitlines ( ) <EOL> if l . startswith ( '<STR_LIT>' ) <EOL> ] <EOL> return filenames <EOL> def get_modified_deliverable_file_content ( reporoot , filenames ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> deliverable_files = filenames <EOL> if not deliverable_files : <EOL> deliverable_files = find_modified_deliverable_files ( <EOL> reporoot <EOL> ) <EOL> for basename in deliverable_files : <EOL>", "answer": "filename = os . path . join ( reporoot , basename )"}, {"prompt": "Complete the next line of the following codes. Give your answer first, and then the reasoning.\n<s> from tempfile import mkstemp <EOL> import numpy as np <EOL> from numpy . testing import assert_array_equal <EOL> from nose . tools import assert_less <EOL> from sklearn . datasets import load_iris <EOL> from sklearn . cross_validation import train_test_split <EOL> from pystruct . models import GridCRF , GraphCRF <EOL> from pystruct . datasets import generate_blocks_multinomial <EOL> from pystruct . learners import FrankWolfeSSVM <EOL> from pystruct . utils import SaveLogger <EOL> def test_multinomial_blocks_frankwolfe ( ) : <EOL> X , Y = generate_blocks_multinomial ( n_samples = <NUM_LIT:10> , noise = <NUM_LIT:0.5> , seed = <NUM_LIT:0> ) <EOL> crf = GridCRF ( inference_method = '<STR_LIT>' ) <EOL> clf = FrankWolfeSSVM ( model = crf , C = <NUM_LIT:1> , max_iter = <NUM_LIT:50> ) <EOL> clf . fit ( X , Y ) <EOL> Y_pred = clf . predict ( X ) <EOL> assert_array_equal ( Y , Y_pred ) <EOL> def test_multinomial_blocks_frankwolfe_batch ( ) : <EOL> X , Y = generate_blocks_multinomial ( n_samples = <NUM_LIT:10> , noise = <NUM_LIT> , seed = <NUM_LIT:0> ) <EOL> crf = GridCRF ( inference_method = '<STR_LIT>' ) <EOL> clf = FrankWolfeSSVM ( model = crf , C = <NUM_LIT:1> , max_iter = <NUM_LIT> , batch_mode = True ) <EOL> clf . fit ( X , Y ) <EOL> Y_pred = clf . predict ( X ) <EOL> assert_array_equal ( Y , Y_pred ) <EOL> def test_svm_as_crf_pickling_bcfw ( ) : <EOL> iris = load_iris ( ) <EOL> X , y = iris . data , iris . target <EOL> X_ = [ ( np . atleast_2d ( x ) , np . empty ( ( <NUM_LIT:0> , <NUM_LIT:2> ) , dtype = np . int ) ) for x in X ] <EOL> Y = y . reshape ( - <NUM_LIT:1> , <NUM_LIT:1> ) <EOL> X_train , X_test , y_train , y_test = train_test_split ( X_ , Y , random_state = <NUM_LIT:1> ) <EOL> _ , file_name = mkstemp ( ) <EOL>", "answer": "pbl = GraphCRF ( n_features = <NUM_LIT:4> , n_states = <NUM_LIT:3> , inference_method = '<STR_LIT>' )"}]