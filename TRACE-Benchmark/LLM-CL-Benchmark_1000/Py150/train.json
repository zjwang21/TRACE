[{"prompt": "<s> from django . conf import settings <EOL> QUEUE_MAX_TRIES = getattr ( settings , '<STR_LIT>' , <NUM_LIT:5> ) <EOL>", "answer": "FAIL_SILENT = getattr ( settings , '<STR_LIT>' , True ) "}, {"prompt": "<s> import ElementTree <EOL> class TreeBuilder ( ElementTree . XMLTreeBuilder ) : <EOL> pass <EOL> class FancyTreeBuilder ( TreeBuilder ) : <EOL> def __init__ ( self , html = <NUM_LIT:0> ) : <EOL> TreeBuilder . __init__ ( self , html ) <EOL> self . _parser . StartNamespaceDeclHandler = self . _start_ns <EOL> self . _parser . EndNamespaceDeclHandler = self . _end_ns <EOL> self . namespaces = [ ] <EOL> def _start ( self , tag , attrib_in ) : <EOL> elem = TreeBuilder . _start ( self , tag , attrib_in ) <EOL> self . start ( elem ) <EOL> def _start_list ( self , tag , attrib_in ) : <EOL> elem = TreeBuilder . _start_list ( self , tag , attrib_in ) <EOL> self . start ( elem ) <EOL> def _end ( self , tag ) : <EOL> elem = TreeBuilder . _end ( self , tag ) <EOL> self . end ( elem ) <EOL> def _start_ns ( self , prefix , value ) : <EOL> self . namespaces . insert ( <NUM_LIT:0> , ( prefix , value ) ) <EOL> def _end_ns ( self , prefix ) : <EOL> assert self . namespaces . pop ( <NUM_LIT:0> ) [ <NUM_LIT:0> ] == prefix , \"<STR_LIT>\" <EOL> def start ( self , element ) : <EOL> pass <EOL>", "answer": "def end ( self , element ) :"}, {"prompt": "<s> from __future__ import print_function , absolute_import <EOL> import humanize <EOL> import inspect <EOL> import json <EOL> import logging <EOL> import os <EOL> import re <EOL> import requests <EOL> import time <EOL> from hashlib import sha1 <EOL> from bs4 import BeautifulSoup <EOL> from requests . cookies import RequestsCookieJar <EOL> from u115 import conf <EOL> from u115 . utils import ( get_timestamp , get_utcdatetime , string_to_datetime , <EOL> eval_path , quote , unquote , utf8_encode , txt_type , PY3 ) <EOL> from homura import download <EOL> if PY3 : <EOL> from http import cookiejar as cookielib <EOL> else : <EOL> import cookielib <EOL> USER_AGENT = '<STR_LIT>' <EOL> LOGIN_URL = '<STR_LIT>' <EOL> LOGOUT_URL = '<STR_LIT>' <EOL> CHECKPOINT_URL = '<STR_LIT>' <EOL> class RequestsLWPCookieJar ( cookielib . LWPCookieJar , RequestsCookieJar ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class RequestsMozillaCookieJar ( cookielib . MozillaCookieJar , RequestsCookieJar ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class RequestHandler ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> self . session = requests . Session ( ) <EOL> self . session . headers [ '<STR_LIT>' ] = USER_AGENT <EOL> def get ( self , url , params = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . session . get ( url , params = params ) <EOL> return self . _response_parser ( r , expect_json = False ) <EOL> def post ( self , url , data , params = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . session . post ( url , data = data , params = params ) <EOL> return self . _response_parser ( r , expect_json = False ) <EOL> def send ( self , request , expect_json = True , ignore_content = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . session . request ( method = request . method , <EOL> url = request . url , <EOL> params = request . params , <EOL> data = request . data , <EOL> files = request . files , <EOL> headers = request . headers ) <EOL> return self . _response_parser ( r , expect_json , ignore_content ) <EOL> def _response_parser ( self , r , expect_json = True , ignore_content = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if r . ok : <EOL> try : <EOL> j = r . json ( ) <EOL> return Response ( j . get ( '<STR_LIT:state>' ) , j ) <EOL> except ValueError : <EOL> if expect_json : <EOL> logger = logging . getLogger ( conf . LOGGING_API_LOGGER ) <EOL> logger . debug ( r . text ) <EOL> raise InvalidAPIAccess ( '<STR_LIT>' ) <EOL> if ignore_content : <EOL> res = Response ( True , None ) <EOL> else : <EOL> res = Response ( True , r . text ) <EOL> return res <EOL> else : <EOL> r . raise_for_status ( ) <EOL> class Request ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , url , method = '<STR_LIT:GET>' , params = None , data = None , <EOL> files = None , headers = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . url = url <EOL> self . method = method <EOL> self . params = params <EOL> self . data = data <EOL> self . files = files <EOL> self . headers = headers <EOL> self . _debug ( ) <EOL> def _debug ( self ) : <EOL> logger = logging . getLogger ( conf . LOGGING_API_LOGGER ) <EOL> level = logger . getEffectiveLevel ( ) <EOL> if level == logging . DEBUG : <EOL> func = inspect . stack ( ) [ <NUM_LIT:2> ] [ <NUM_LIT:3> ] <EOL> msg = conf . DEBUG_REQ_FMT % ( func , self . url , self . method , <EOL> self . params , self . data ) <EOL> logger . debug ( msg ) <EOL> class Response ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , state , content ) : <EOL> self . state = state <EOL> self . content = content <EOL> self . _debug ( ) <EOL> def _debug ( self ) : <EOL> logger = logging . getLogger ( conf . LOGGING_API_LOGGER ) <EOL> level = logger . getEffectiveLevel ( ) <EOL> if level == logging . DEBUG : <EOL> func = inspect . stack ( ) [ <NUM_LIT:4> ] [ <NUM_LIT:3> ] <EOL> msg = conf . DEBUG_RES_FMT % ( func , self . state , self . content ) <EOL> logger . debug ( msg ) <EOL> class API ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> num_tasks_per_page = <NUM_LIT:30> <EOL> web_api_url = '<STR_LIT>' <EOL> aps_natsort_url = '<STR_LIT>' <EOL> proapi_url = '<STR_LIT>' <EOL> referer_url = '<STR_LIT>' <EOL> def __init__ ( self , persistent = False , <EOL> cookies_filename = None , cookies_type = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . persistent = persistent <EOL> self . cookies_filename = cookies_filename <EOL> self . cookies_type = cookies_type <EOL> self . passport = None <EOL> self . http = RequestHandler ( ) <EOL> self . logger = logging . getLogger ( conf . LOGGING_API_LOGGER ) <EOL> self . _user_id = None <EOL> self . _username = None <EOL> self . _signatures = { } <EOL> self . _upload_url = None <EOL> self . _lixian_timestamp = None <EOL> self . _root_directory = None <EOL> self . _downloads_directory = None <EOL> self . _receiver_directory = None <EOL> self . _torrents_directory = None <EOL> self . _task_count = None <EOL> self . _task_quota = None <EOL> if self . persistent : <EOL> self . load_cookies ( ) <EOL> def _reset_cache ( self ) : <EOL> self . _user_id = None <EOL> self . _username = None <EOL> self . _signatures = { } <EOL> self . _upload_url = None <EOL> self . _lixian_timestamp = None <EOL> self . _root_directory = None <EOL> self . _downloads_directory = None <EOL> self . _receiver_directory = None <EOL> self . _torrents_directory = None <EOL> self . _task_count = None <EOL> self . _task_quota = None <EOL> def _init_cookies ( self ) : <EOL> cookies_class = globals ( ) [ '<STR_LIT>' + self . cookies_type ] <EOL> f = self . cookies_filename or conf . COOKIES_FILENAME <EOL> self . cookies = cookies_class ( f ) <EOL> def load_cookies ( self , ignore_discard = True , ignore_expires = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _init_cookies ( ) <EOL> if os . path . exists ( self . cookies . filename ) : <EOL> self . cookies . load ( ignore_discard = ignore_discard , <EOL> ignore_expires = ignore_expires ) <EOL> self . _reset_cache ( ) <EOL> def save_cookies ( self , ignore_discard = True , ignore_expires = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( self . cookies , cookielib . FileCookieJar ) : <EOL> m = '<STR_LIT>' <EOL> raise APIError ( m ) <EOL> self . cookies . save ( ignore_discard = ignore_discard , <EOL> ignore_expires = ignore_expires ) <EOL> @ property <EOL> def cookies ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . http . session . cookies <EOL> @ cookies . setter <EOL> def cookies ( self , cookies ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . http . session . cookies = cookies <EOL> def login ( self , username = None , password = None , <EOL> section = '<STR_LIT:default>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . has_logged_in : <EOL> return True <EOL> if username is None or password is None : <EOL> credential = conf . get_credential ( section ) <EOL> username = credential [ '<STR_LIT:username>' ] <EOL> password = credential [ '<STR_LIT:password>' ] <EOL> passport = Passport ( username , password ) <EOL> r = self . http . post ( LOGIN_URL , passport . form ) <EOL> if r . state is True : <EOL> self . passport = passport <EOL> passport . data = r . content [ '<STR_LIT:data>' ] <EOL> self . _user_id = r . content [ '<STR_LIT:data>' ] [ '<STR_LIT>' ] <EOL> return True <EOL> else : <EOL> msg = None <EOL> if '<STR_LIT>' in r . content : <EOL> if r . content [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> msg = '<STR_LIT>' <EOL> elif r . content [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> msg = '<STR_LIT>' <EOL> raise AuthenticationError ( msg ) <EOL> def get_user_info ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _req_get_user_aq ( ) <EOL> @ property <EOL> def user_id ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _user_id is None : <EOL> if self . has_logged_in : <EOL> self . _user_id = self . _req_get_user_aq ( ) [ '<STR_LIT:data>' ] [ '<STR_LIT>' ] <EOL> else : <EOL> raise AuthenticationError ( '<STR_LIT>' ) <EOL> return self . _user_id <EOL> @ property <EOL> def username ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _username is None : <EOL> if self . has_logged_in : <EOL> self . _username = self . _get_username ( ) <EOL> else : <EOL> raise AuthenticationError ( '<STR_LIT>' ) <EOL> return self . _username <EOL> @ property <EOL> def has_logged_in ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . http . get ( CHECKPOINT_URL ) <EOL> if r . state is False : <EOL> return True <EOL> self . _reset_cache ( ) <EOL> return False <EOL> def logout ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . http . get ( LOGOUT_URL ) <EOL> self . _reset_cache ( ) <EOL> return True <EOL> @ property <EOL> def root_directory ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _root_directory is None : <EOL> self . _load_root_directory ( ) <EOL> return self . _root_directory <EOL> @ property <EOL> def downloads_directory ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _downloads_directory is None : <EOL> self . _load_downloads_directory ( ) <EOL> return self . _downloads_directory <EOL> @ property <EOL> def receiver_directory ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _receiver_directory is None : <EOL> self . _receiver_directory = self . downloads_directory . parent <EOL> return self . _receiver_directory <EOL> @ property <EOL> def torrents_directory ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _torrents_directory is None : <EOL> self . _load_torrents_directory ( ) <EOL> return self . _torrents_directory <EOL> @ property <EOL> def task_count ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _req_lixian_task_lists ( ) <EOL> return self . _task_count <EOL> @ property <EOL> def task_quota ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _req_lixian_task_lists ( ) <EOL> return self . _task_quota <EOL> def get_tasks ( self , count = <NUM_LIT:30> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _load_tasks ( count ) <EOL> def add_task_bt ( self , filename , select = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> filename = eval_path ( filename ) <EOL> u = self . upload ( filename , self . torrents_directory ) <EOL> t = self . _load_torrent ( u ) <EOL> if select : <EOL> return t <EOL> return t . submit ( ) <EOL> def add_task_url ( self , target_url ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _req_lixian_add_task_url ( target_url ) <EOL> def get_storage_info ( self , human = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> res = self . _req_get_storage_info ( ) <EOL> if human : <EOL> res [ '<STR_LIT>' ] = humanize . naturalsize ( res [ '<STR_LIT>' ] , binary = True ) <EOL> res [ '<STR_LIT>' ] = humanize . naturalsize ( res [ '<STR_LIT>' ] , binary = True ) <EOL> return res <EOL> def upload ( self , filename , directory = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> filename = eval_path ( filename ) <EOL> if directory is None : <EOL> directory = self . downloads_directory <EOL> res1 = self . _req_upload ( filename , directory ) <EOL> data1 = res1 [ '<STR_LIT:data>' ] <EOL> file_id = data1 [ '<STR_LIT>' ] <EOL> res2 = self . _req_file ( file_id ) <EOL> data2 = res2 [ '<STR_LIT:data>' ] [ <NUM_LIT:0> ] <EOL> data2 . update ( ** data1 ) <EOL> return _instantiate_uploaded_file ( self , data2 ) <EOL> def download ( self , obj , path = None , show_progress = True , resume = True , <EOL> auto_retry = True , proapi = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url = obj . get_download_url ( proapi ) <EOL> download ( url , path = path , session = self . http . session , <EOL> show_progress = show_progress , resume = resume , <EOL> auto_retry = auto_retry ) <EOL> def search ( self , keyword , count = <NUM_LIT:30> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> kwargs = { } <EOL> kwargs [ '<STR_LIT>' ] = keyword <EOL> root = self . root_directory <EOL> entries = root . _load_entries ( func = self . _req_files_search , <EOL> count = count , page = <NUM_LIT:1> , ** kwargs ) <EOL> res = [ ] <EOL> for entry in entries : <EOL> if '<STR_LIT>' in entry : <EOL> res . append ( _instantiate_directory ( self , entry ) ) <EOL> else : <EOL> res . append ( _instantiate_file ( self , entry ) ) <EOL> return res <EOL> def move ( self , entries , directory ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fcids = [ ] <EOL> for entry in entries : <EOL> if isinstance ( entry , File ) : <EOL> fcid = entry . fid <EOL> elif isinstance ( entry , Directory ) : <EOL> fcid = entry . cid <EOL> else : <EOL> raise APIError ( '<STR_LIT>' ) <EOL> fcids . append ( fcid ) <EOL> if not isinstance ( directory , Directory ) : <EOL> raise APIError ( '<STR_LIT>' ) <EOL> if self . _req_files_move ( directory . cid , fcids ) : <EOL> for entry in entries : <EOL> if isinstance ( entry , File ) : <EOL> entry . cid = directory . cid <EOL> entry . reload ( ) <EOL> return True <EOL> else : <EOL> raise APIError ( '<STR_LIT>' ) <EOL> def edit ( self , entry , name , mark = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fcid = None <EOL> if isinstance ( entry , File ) : <EOL> fcid = entry . fid <EOL> elif isinstance ( entry , Directory ) : <EOL> fcid = entry . cid <EOL> else : <EOL> raise APIError ( '<STR_LIT>' ) <EOL> is_mark = <NUM_LIT:0> <EOL> if mark is True : <EOL> is_mark = <NUM_LIT:1> <EOL> if self . _req_files_edit ( fcid , name , is_mark ) : <EOL> entry . reload ( ) <EOL> return True <EOL> else : <EOL> raise APIError ( '<STR_LIT>' ) <EOL> def mkdir ( self , parent , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pid = None <EOL> cid = None <EOL> if isinstance ( parent , Directory ) : <EOL> pid = parent . cid <EOL> else : <EOL> raise ( '<STR_LIT>' ) <EOL> cid = self . _req_files_add ( pid , name ) [ '<STR_LIT>' ] <EOL> return self . _load_directory ( cid ) <EOL> def _req_offline_space ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url = '<STR_LIT>' <EOL> params = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:_>' : get_timestamp ( <NUM_LIT> ) <EOL> } <EOL> _sign = os . environ . get ( '<STR_LIT>' ) <EOL> if _sign is not None : <EOL> _time = os . environ . get ( '<STR_LIT>' ) <EOL> if _time is None : <EOL> msg = '<STR_LIT>' <EOL> raise APIError ( msg ) <EOL> params [ '<STR_LIT>' ] = _sign <EOL> params [ '<STR_LIT:time>' ] = _time <EOL> params [ '<STR_LIT>' ] = self . user_id <EOL> req = Request ( url = url , params = params ) <EOL> r = self . http . send ( req ) <EOL> if r . state : <EOL> self . _signatures [ '<STR_LIT>' ] = r . content [ '<STR_LIT>' ] <EOL> self . _lixian_timestamp = r . content [ '<STR_LIT:time>' ] <EOL> else : <EOL> msg = '<STR_LIT>' <EOL> raise RequestFailure ( msg ) <EOL> def _req_lixian_task_lists ( self , page = <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url = '<STR_LIT>' <EOL> params = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } <EOL> self . _load_signatures ( ) <EOL> data = { <EOL> '<STR_LIT>' : page , <EOL> '<STR_LIT>' : self . user_id , <EOL> '<STR_LIT>' : self . _signatures [ '<STR_LIT>' ] , <EOL> '<STR_LIT:time>' : self . _lixian_timestamp , <EOL> } <EOL> req = Request ( method = '<STR_LIT:POST>' , url = url , params = params , data = data ) <EOL> res = self . http . send ( req ) <EOL> if res . state : <EOL> self . _task_count = res . content [ '<STR_LIT:count>' ] <EOL> self . _task_quota = res . content [ '<STR_LIT>' ] <EOL> return res . content [ '<STR_LIT>' ] <EOL> else : <EOL> msg = '<STR_LIT>' <EOL> raise RequestFailure ( msg ) <EOL> def _req_lixian_get_id ( self , torrent = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url = '<STR_LIT>' <EOL> params = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:1> if torrent else None , <EOL> '<STR_LIT:_>' : get_timestamp ( <NUM_LIT> ) <EOL> } <EOL> req = Request ( method = '<STR_LIT:GET>' , url = url , params = params ) <EOL> res = self . http . send ( req ) <EOL> return res . content <EOL> def _req_lixian_torrent ( self , u ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _load_signatures ( ) <EOL> url = '<STR_LIT>' <EOL> params = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> data = { <EOL> '<STR_LIT>' : u . pickcode , <EOL> '<STR_LIT>' : u . sha , <EOL> '<STR_LIT>' : self . user_id , <EOL> '<STR_LIT>' : self . _signatures [ '<STR_LIT>' ] , <EOL> '<STR_LIT:time>' : self . _lixian_timestamp , <EOL> } <EOL> req = Request ( method = '<STR_LIT:POST>' , url = url , params = params , data = data ) <EOL> res = self . http . send ( req ) <EOL> if res . state : <EOL> return res . content <EOL> else : <EOL> msg = res . content . get ( '<STR_LIT>' ) <EOL> self . logger . error ( msg ) <EOL> raise RequestFailure ( '<STR_LIT>' ) <EOL> def _req_lixian_add_task_bt ( self , t ) : <EOL> self . _load_signatures ( ) <EOL> url = '<STR_LIT>' <EOL> params = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } <EOL> _wanted = [ ] <EOL> for i , b in enumerate ( t . files ) : <EOL> if b . selected : <EOL> _wanted . append ( str ( i ) ) <EOL> wanted = '<STR_LIT:U+002C>' . join ( _wanted ) <EOL> data = { <EOL> '<STR_LIT>' : t . info_hash , <EOL> '<STR_LIT>' : wanted , <EOL> '<STR_LIT>' : t . name , <EOL> '<STR_LIT>' : self . user_id , <EOL> '<STR_LIT>' : self . _signatures [ '<STR_LIT>' ] , <EOL> '<STR_LIT:time>' : self . _lixian_timestamp , <EOL> } <EOL> req = Request ( method = '<STR_LIT:POST>' , url = url , params = params , data = data ) <EOL> res = self . http . send ( req ) <EOL> if res . state : <EOL> return True <EOL> else : <EOL> msg = res . content . get ( '<STR_LIT>' ) <EOL> self . logger . error ( msg ) <EOL> raise RequestFailure ( '<STR_LIT>' ) <EOL> def _req_lixian_add_task_url ( self , target_url ) : <EOL> self . _load_signatures ( ) <EOL> url = '<STR_LIT>' <EOL> params = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } <EOL> data = { <EOL> '<STR_LIT:url>' : target_url , <EOL> '<STR_LIT>' : self . user_id , <EOL> '<STR_LIT>' : self . _signatures [ '<STR_LIT>' ] , <EOL> '<STR_LIT:time>' : self . _lixian_timestamp , <EOL> } <EOL> req = Request ( method = '<STR_LIT:POST>' , url = url , params = params , data = data ) <EOL> res = self . http . send ( req ) <EOL> if res . state : <EOL> return True <EOL> else : <EOL> msg = res . content . get ( '<STR_LIT>' ) <EOL> self . logger . error ( msg ) <EOL> raise RequestFailure ( '<STR_LIT>' ) <EOL> def _req_lixian_task_del ( self , t ) : <EOL> self . _load_signatures ( ) <EOL> url = '<STR_LIT>' <EOL> params = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } <EOL> data = { <EOL> '<STR_LIT>' : t . info_hash , <EOL> '<STR_LIT>' : self . user_id , <EOL> '<STR_LIT>' : self . _signatures [ '<STR_LIT>' ] , <EOL> '<STR_LIT:time>' : self . _lixian_timestamp , <EOL> } <EOL>", "answer": "req = Request ( method = '<STR_LIT:POST>' , url = url , params = params , data = data )"}, {"prompt": "<s> import unittest <EOL> import tempfile <EOL> import os <EOL> from os import path <EOL> from shellpython . helpers import Dir <EOL> class TestDirectory ( unittest . TestCase ) : <EOL> def test_relative_dirs ( self ) : <EOL> cur_dir = path . dirname ( path . abspath ( __file__ ) ) <EOL>", "answer": "with Dir ( path . join ( cur_dir , '<STR_LIT:data>' ) ) :"}, {"prompt": "<s> import unittest <EOL> from simpleai . search . models import CspProblem <EOL> from simpleai . search . csp import ( _find_conflicts , _count_conflicts , <EOL> _most_constrained_variable_chooser , <EOL> _highest_degree_variable_chooser , <EOL> _least_constraining_values_sorter , <EOL> _min_conflicts_value , backtrack , <EOL> min_conflicts ) <EOL> class TestCsp ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . variables = ( '<STR_LIT:A>' , '<STR_LIT:B>' , '<STR_LIT:C>' ) <EOL> self . domains = { <EOL> '<STR_LIT:A>' : [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] , <EOL> '<STR_LIT:B>' : [ <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:4> ] , <EOL> '<STR_LIT:C>' : [ <NUM_LIT:1> , <NUM_LIT:2> ] , <EOL> } <EOL> def const_different ( variables , values ) : <EOL> return len ( values ) == len ( set ( values ) ) <EOL>", "answer": "def const_one_bigger_other ( variables , values ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os as _os , sys as _sys <EOL> __version__ = \"<STR_LIT>\" <EOL> from _ctypes import Union , Structure , Array <EOL> from _ctypes import _Pointer <EOL> from _ctypes import CFuncPtr as _CFuncPtr <EOL> from _ctypes import __version__ as _ctypes_version <EOL> from _ctypes import RTLD_LOCAL , RTLD_GLOBAL <EOL> from _ctypes import ArgumentError <EOL> from struct import calcsize as _calcsize <EOL> if __version__ != _ctypes_version : <EOL> raise Exception , ( \"<STR_LIT>\" , __version__ , _ctypes_version ) <EOL> if _os . name in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> from _ctypes import FormatError <EOL> DEFAULT_MODE = RTLD_LOCAL <EOL> if _os . name == \"<STR_LIT>\" and _sys . platform == \"<STR_LIT>\" : <EOL> import gestalt <EOL> if gestalt . gestalt ( \"<STR_LIT>\" ) < <NUM_LIT> : <EOL> DEFAULT_MODE = RTLD_GLOBAL <EOL> from _ctypes import FUNCFLAG_CDECL as _FUNCFLAG_CDECL , FUNCFLAG_PYTHONAPI as _FUNCFLAG_PYTHONAPI <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def create_string_buffer ( init , size = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( init , ( str , unicode ) ) : <EOL> if size is None : <EOL> size = len ( init ) + <NUM_LIT:1> <EOL> buftype = c_char * size <EOL> buf = buftype ( ) <EOL> buf . value = init <EOL> return buf <EOL> elif isinstance ( init , ( int , long ) ) : <EOL> buftype = c_char * init <EOL> buf = buftype ( ) <EOL> return buf <EOL> raise TypeError , init <EOL> def c_buffer ( init , size = None ) : <EOL> return create_string_buffer ( init , size ) <EOL> _c_functype_cache = { } <EOL> def CFUNCTYPE ( restype , * argtypes ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> return _c_functype_cache [ ( restype , argtypes ) ] <EOL> except KeyError : <EOL> class CFunctionType ( _CFuncPtr ) : <EOL> _argtypes_ = argtypes <EOL> _restype_ = restype <EOL> _flags_ = _FUNCFLAG_CDECL <EOL> _c_functype_cache [ ( restype , argtypes ) ] = CFunctionType <EOL> return CFunctionType <EOL> if _os . name in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> from _ctypes import LoadLibrary as _dlopen <EOL> from _ctypes import FUNCFLAG_STDCALL as _FUNCFLAG_STDCALL <EOL> if _os . name == \"<STR_LIT>\" : <EOL> _FUNCFLAG_STDCALL = _FUNCFLAG_CDECL <EOL> _win_functype_cache = { } <EOL> def WINFUNCTYPE ( restype , * argtypes ) : <EOL> try : <EOL> return _win_functype_cache [ ( restype , argtypes ) ] <EOL> except KeyError : <EOL> class WinFunctionType ( _CFuncPtr ) : <EOL> _argtypes_ = argtypes <EOL> _restype_ = restype <EOL> _flags_ = _FUNCFLAG_STDCALL <EOL> _win_functype_cache [ ( restype , argtypes ) ] = WinFunctionType <EOL> return WinFunctionType <EOL> if WINFUNCTYPE . __doc__ : <EOL> WINFUNCTYPE . __doc__ = CFUNCTYPE . __doc__ . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> elif _os . name == \"<STR_LIT>\" : <EOL> from _ctypes import dlopen as _dlopen <EOL> from _ctypes import sizeof , byref , addressof , alignment , resize <EOL> from _ctypes import _SimpleCData <EOL> def _check_size ( typ , typecode = None ) : <EOL> from struct import calcsize <EOL> if typecode is None : <EOL> typecode = typ . _type_ <EOL> actual , required = sizeof ( typ ) , calcsize ( typecode ) <EOL> if actual != required : <EOL> raise SystemError ( \"<STR_LIT>\" % ( typ , actual , required ) ) <EOL> class py_object ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:O>\" <EOL> def __repr__ ( self ) : <EOL> try : <EOL> return super ( py_object , self ) . __repr__ ( ) <EOL> except ValueError : <EOL> return \"<STR_LIT>\" % type ( self ) . __name__ <EOL> _check_size ( py_object , \"<STR_LIT:P>\" ) <EOL> class c_short ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:h>\" <EOL> _check_size ( c_short ) <EOL> class c_ushort ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:H>\" <EOL> _check_size ( c_ushort ) <EOL> class c_long ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:l>\" <EOL> _check_size ( c_long ) <EOL> class c_ulong ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:L>\" <EOL> _check_size ( c_ulong ) <EOL> if _calcsize ( \"<STR_LIT:i>\" ) == _calcsize ( \"<STR_LIT:l>\" ) : <EOL> c_int = c_long <EOL> c_uint = c_ulong <EOL> else : <EOL> class c_int ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:i>\" <EOL> _check_size ( c_int ) <EOL> class c_uint ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:I>\" <EOL> _check_size ( c_uint ) <EOL> class c_float ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:f>\" <EOL> _check_size ( c_float ) <EOL> class c_double ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:d>\" <EOL> _check_size ( c_double ) <EOL> if _calcsize ( \"<STR_LIT:l>\" ) == _calcsize ( \"<STR_LIT:q>\" ) : <EOL> c_longlong = c_long <EOL> c_ulonglong = c_ulong <EOL> else : <EOL> class c_longlong ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:q>\" <EOL> _check_size ( c_longlong ) <EOL> class c_ulonglong ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT>\" <EOL> _check_size ( c_ulonglong ) <EOL> class c_ubyte ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:B>\" <EOL> c_ubyte . __ctype_le__ = c_ubyte . __ctype_be__ = c_ubyte <EOL> _check_size ( c_ubyte ) <EOL> class c_byte ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:b>\" <EOL> c_byte . __ctype_le__ = c_byte . __ctype_be__ = c_byte <EOL> _check_size ( c_byte ) <EOL> class c_char ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:c>\" <EOL> c_char . __ctype_le__ = c_char . __ctype_be__ = c_char <EOL> _check_size ( c_char ) <EOL> class c_char_p ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:z>\" <EOL> if _os . name == \"<STR_LIT>\" : <EOL> def __repr__ ( self ) : <EOL> if not windll . kernel32 . IsBadStringPtrA ( self , - <NUM_LIT:1> ) : <EOL> return \"<STR_LIT>\" % ( self . __class__ . __name__ , self . value ) <EOL> return \"<STR_LIT>\" % ( self . __class__ . __name__ , cast ( self , c_void_p ) . value ) <EOL> else : <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . __class__ . __name__ , cast ( self , c_void_p ) . value ) <EOL> _check_size ( c_char_p , \"<STR_LIT:P>\" ) <EOL> class c_void_p ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:P>\" <EOL> c_voidp = c_void_p <EOL> _check_size ( c_void_p ) <EOL> _pointer_type_cache = { } <EOL> def POINTER ( cls ) : <EOL> try : <EOL> return _pointer_type_cache [ cls ] <EOL> except KeyError : <EOL> pass <EOL> if type ( cls ) is str : <EOL> klass = type ( _Pointer ) ( \"<STR_LIT>\" % cls , <EOL> ( _Pointer , ) , <EOL> { } ) <EOL> _pointer_type_cache [ id ( klass ) ] = klass <EOL> return klass <EOL> else : <EOL> name = \"<STR_LIT>\" % cls . __name__ <EOL> klass = type ( _Pointer ) ( name , <EOL> ( _Pointer , ) , <EOL> { '<STR_LIT>' : cls } ) <EOL> _pointer_type_cache [ cls ] = klass <EOL> return klass <EOL> try : <EOL> from _ctypes import set_conversion_mode <EOL> except ImportError : <EOL> pass <EOL> else : <EOL> if _os . name in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> set_conversion_mode ( \"<STR_LIT>\" , \"<STR_LIT:ignore>\" ) <EOL> else : <EOL> set_conversion_mode ( \"<STR_LIT:ascii>\" , \"<STR_LIT:strict>\" ) <EOL> class c_wchar_p ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT>\" <EOL> class c_wchar ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:u>\" <EOL> POINTER ( c_wchar ) . from_param = c_wchar_p . from_param <EOL> def create_unicode_buffer ( init , size = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( init , ( str , unicode ) ) : <EOL> if size is None : <EOL> size = len ( init ) + <NUM_LIT:1> <EOL> buftype = c_wchar * size <EOL> buf = buftype ( ) <EOL> buf . value = init <EOL> return buf <EOL> elif isinstance ( init , ( int , long ) ) : <EOL> buftype = c_wchar * init <EOL> buf = buftype ( ) <EOL> return buf <EOL> raise TypeError , init <EOL> POINTER ( c_char ) . from_param = c_char_p . from_param <EOL> def SetPointerType ( pointer , cls ) : <EOL> if _pointer_type_cache . get ( cls , None ) is not None : <EOL> raise RuntimeError , \"<STR_LIT>\" <EOL> if not _pointer_type_cache . has_key ( id ( pointer ) ) : <EOL> raise RuntimeError , \"<STR_LIT>\" <EOL> pointer . set_type ( cls ) <EOL> _pointer_type_cache [ cls ] = pointer <EOL> del _pointer_type_cache [ id ( pointer ) ] <EOL> def pointer ( inst ) : <EOL> return POINTER ( type ( inst ) ) ( inst ) <EOL> def ARRAY ( typ , len ) : <EOL> return typ * len <EOL> class CDLL ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class _FuncPtr ( _CFuncPtr ) : <EOL> _flags_ = _FUNCFLAG_CDECL <EOL> _restype_ = c_int <EOL> def __init__ ( self , name , mode = DEFAULT_MODE , handle = None ) : <EOL> self . _name = name <EOL> if handle is None : <EOL> self . _handle = _dlopen ( self . _name , mode ) <EOL> else : <EOL> self . _handle = handle <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . __class__ . __name__ , self . _name , <EOL> ( self . _handle & ( _sys . maxint * <NUM_LIT:2> + <NUM_LIT:1> ) ) , <EOL> id ( self ) & ( _sys . maxint * <NUM_LIT:2> + <NUM_LIT:1> ) ) <EOL> def __getattr__ ( self , name ) : <EOL> if name . startswith ( '<STR_LIT>' ) and name . endswith ( '<STR_LIT>' ) : <EOL> raise AttributeError , name <EOL> func = self . __getitem__ ( name ) <EOL> setattr ( self , name , func ) <EOL> return func <EOL> def __getitem__ ( self , name_or_ordinal ) : <EOL> func = self . _FuncPtr ( ( name_or_ordinal , self ) ) <EOL> if not isinstance ( name_or_ordinal , ( int , long ) ) : <EOL> func . __name__ = name_or_ordinal <EOL> return func <EOL> class PyDLL ( CDLL ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class _FuncPtr ( _CFuncPtr ) : <EOL> _flags_ = _FUNCFLAG_CDECL | _FUNCFLAG_PYTHONAPI <EOL> _restype_ = c_int <EOL> if _os . name in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> class WinDLL ( CDLL ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class _FuncPtr ( _CFuncPtr ) : <EOL> _flags_ = _FUNCFLAG_STDCALL <EOL> _restype_ = c_int <EOL> from _ctypes import _check_HRESULT , _SimpleCData <EOL> class HRESULT ( _SimpleCData ) : <EOL> _type_ = \"<STR_LIT:l>\" <EOL> _check_retval_ = _check_HRESULT <EOL> class OleDLL ( CDLL ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class _FuncPtr ( _CFuncPtr ) : <EOL> _flags_ = _FUNCFLAG_STDCALL <EOL> _restype_ = HRESULT <EOL> class LibraryLoader ( object ) : <EOL> def __init__ ( self , dlltype ) : <EOL> self . _dlltype = dlltype <EOL> def __getattr__ ( self , name ) : <EOL> if name [ <NUM_LIT:0> ] == '<STR_LIT:_>' : <EOL> raise AttributeError ( name ) <EOL> dll = self . _dlltype ( name ) <EOL> setattr ( self , name , dll ) <EOL> return dll <EOL> def __getitem__ ( self , name ) : <EOL> return getattr ( self , name ) <EOL> def LoadLibrary ( self , name ) : <EOL> return self . _dlltype ( name ) <EOL> cdll = LibraryLoader ( CDLL ) <EOL> pydll = LibraryLoader ( PyDLL ) <EOL> if _os . name in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> pythonapi = PyDLL ( \"<STR_LIT>\" , None , _sys . dllhandle ) <EOL> elif _sys . platform == \"<STR_LIT>\" : <EOL> pythonapi = PyDLL ( \"<STR_LIT>\" % _sys . version_info [ : <NUM_LIT:2> ] ) <EOL> else : <EOL> pythonapi = PyDLL ( None ) <EOL> if _os . name in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> windll = LibraryLoader ( WinDLL ) <EOL> oledll = LibraryLoader ( OleDLL ) <EOL> if _os . name == \"<STR_LIT>\" : <EOL> GetLastError = windll . kernel32 . GetLastError <EOL> else : <EOL> GetLastError = windll . coredll . GetLastError <EOL> def WinError ( code = None , descr = None ) : <EOL> if code is None : <EOL> code = GetLastError ( ) <EOL> if descr is None : <EOL> descr = FormatError ( code ) . strip ( ) <EOL> return WindowsError ( code , descr ) <EOL> _pointer_type_cache [ None ] = c_void_p <EOL> if sizeof ( c_uint ) == sizeof ( c_void_p ) : <EOL> c_size_t = c_uint <EOL> elif sizeof ( c_ulong ) == sizeof ( c_void_p ) : <EOL> c_size_t = c_ulong <EOL> from _ctypes import _memmove_addr , _memset_addr , _string_at_addr , _cast_addr <EOL> memmove = CFUNCTYPE ( c_void_p , c_void_p , c_void_p , c_size_t ) ( _memmove_addr ) <EOL> memset = CFUNCTYPE ( c_void_p , c_void_p , c_int , c_size_t ) ( _memset_addr ) <EOL> def PYFUNCTYPE ( restype , * argtypes ) : <EOL> class CFunctionType ( _CFuncPtr ) : <EOL> _argtypes_ = argtypes <EOL> _restype_ = restype <EOL> _flags_ = _FUNCFLAG_CDECL | _FUNCFLAG_PYTHONAPI <EOL> return CFunctionType <EOL> _cast = PYFUNCTYPE ( py_object , c_void_p , py_object , py_object ) ( _cast_addr ) <EOL> def cast ( obj , typ ) : <EOL> return _cast ( obj , obj , typ ) <EOL> _string_at = CFUNCTYPE ( py_object , c_void_p , c_int ) ( _string_at_addr ) <EOL> def string_at ( ptr , size = - <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return _string_at ( ptr , size ) <EOL> try : <EOL> from _ctypes import _wstring_at_addr <EOL> except ImportError : <EOL> pass <EOL> else : <EOL> _wstring_at = CFUNCTYPE ( py_object , c_void_p , c_int ) ( _wstring_at_addr ) <EOL> def wstring_at ( ptr , size = - <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return _wstring_at ( ptr , size ) <EOL> if _os . name in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> def DllGetClassObject ( rclsid , riid , ppv ) : <EOL> try : <EOL> ccom = __import__ ( \"<STR_LIT>\" , globals ( ) , locals ( ) , [ '<STR_LIT:*>' ] ) <EOL> except ImportError : <EOL> return - <NUM_LIT> <EOL> else : <EOL> return ccom . DllGetClassObject ( rclsid , riid , ppv ) <EOL> def DllCanUnloadNow ( ) : <EOL> try : <EOL> ccom = __import__ ( \"<STR_LIT>\" , globals ( ) , locals ( ) , [ '<STR_LIT:*>' ] ) <EOL> except ImportError : <EOL> return <NUM_LIT:0> <EOL> return ccom . DllCanUnloadNow ( ) <EOL> from ctypes . _endian import BigEndianStructure , LittleEndianStructure <EOL> c_int8 = c_byte <EOL> c_uint8 = c_ubyte <EOL> for kind in [ c_short , c_int , c_long , c_longlong ] : <EOL>", "answer": "if sizeof ( kind ) == <NUM_LIT:2> : c_int16 = kind"}, {"prompt": "<s> import logging <EOL> import luigi <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> try : <EOL> import _mssql <EOL> except ImportError as e : <EOL> logger . warning ( \"<STR_LIT>\" ) <EOL> class MSSqlTarget ( luigi . Target ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> marker_table = luigi . configuration . get_config ( ) . get ( '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> def __init__ ( self , host , database , user , password , table , update_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT::>' in host : <EOL> self . host , self . port = host . split ( '<STR_LIT::>' ) <EOL> self . port = int ( self . port ) <EOL> else : <EOL> self . host = host <EOL> self . port = <NUM_LIT> <EOL> self . database = database <EOL> self . user = user <EOL> self . password = password <EOL> self . table = table <EOL> self . update_id = update_id <EOL> def touch ( self , connection = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . create_marker_table ( ) <EOL> if connection is None : <EOL> connection = self . connect ( ) <EOL> connection . execute_non_query ( <EOL> \"\"\"<STR_LIT>\"\"\" . format ( marker_table = self . marker_table ) , <EOL> { \"<STR_LIT>\" : self . update_id , \"<STR_LIT>\" : self . table } ) <EOL> assert self . exists ( connection ) <EOL> def exists ( self , connection = None ) : <EOL> if connection is None : <EOL> connection = self . connect ( ) <EOL> try : <EOL> row = connection . execute_row ( \"\"\"<STR_LIT>\"\"\" . format ( marker_table = self . marker_table ) , <EOL> ( self . update_id , ) ) <EOL> except _mssql . MSSQLDatabaseException as e : <EOL> if e . number == <NUM_LIT> : <EOL> row = None <EOL> else : <EOL> raise <EOL> return row is not None <EOL> def connect ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> connection = _mssql . connect ( user = self . user , <EOL> password = self . password , <EOL> server = self . host , <EOL> port = self . port , <EOL> database = self . database ) <EOL> return connection <EOL> def create_marker_table ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> connection = self . connect ( ) <EOL> try : <EOL> connection . execute_non_query ( <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> . format ( marker_table = self . marker_table ) <EOL> ) <EOL> except _mssql . MSSQLDatabaseException as e : <EOL> if e . number == <NUM_LIT> : <EOL>", "answer": "pass"}, {"prompt": "<s> from django . conf . urls import patterns , url <EOL> from packages . simple . views import PackageIndex , PackageDetail <EOL>", "answer": "handler404 = \"<STR_LIT>\""}, {"prompt": "<s> import sys <EOL> from mixbox . binding_utils import * <EOL> from . import cybox_common <EOL> from . import address_object <EOL> from . import port_object <EOL> from . import uri_object <EOL> class HTTPRequestResponseType ( GeneratedsSuper ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subclass = None <EOL> superclass = None <EOL> def __init__ ( self , ordinal_position = None , HTTP_Client_Request = None , HTTP_Provisional_Server_Response = None , HTTP_Server_Response = None ) : <EOL> self . ordinal_position = _cast ( int , ordinal_position ) <EOL> self . HTTP_Client_Request = HTTP_Client_Request <EOL> self . HTTP_Provisional_Server_Response = HTTP_Provisional_Server_Response <EOL> self . HTTP_Server_Response = HTTP_Server_Response <EOL> def factory ( * args_ , ** kwargs_ ) : <EOL> if HTTPRequestResponseType . subclass : <EOL> return HTTPRequestResponseType . subclass ( * args_ , ** kwargs_ ) <EOL> else : <EOL> return HTTPRequestResponseType ( * args_ , ** kwargs_ ) <EOL> factory = staticmethod ( factory ) <EOL> def get_HTTP_Client_Request ( self ) : return self . HTTP_Client_Request <EOL> def set_HTTP_Client_Request ( self , HTTP_Client_Request ) : self . HTTP_Client_Request = HTTP_Client_Request <EOL> def get_HTTP_Provisional_Server_Response ( self ) : return self . HTTP_Provisional_Server_Response <EOL> def set_HTTP_Provisional_Server_Response ( self , HTTP_Provisional_Server_Response ) : self . HTTP_Provisional_Server_Response = HTTP_Provisional_Server_Response <EOL> def get_HTTP_Server_Response ( self ) : return self . HTTP_Server_Response <EOL> def set_HTTP_Server_Response ( self , HTTP_Server_Response ) : self . HTTP_Server_Response = HTTP_Server_Response <EOL> def get_ordinal_position ( self ) : return self . ordinal_position <EOL> def set_ordinal_position ( self , ordinal_position ) : self . ordinal_position = ordinal_position <EOL> def hasContent_ ( self ) : <EOL> if ( <EOL> self . HTTP_Client_Request is not None or <EOL> self . HTTP_Provisional_Server_Response is not None or <EOL> self . HTTP_Server_Response is not None <EOL> ) : <EOL> return True <EOL> else : <EOL> return False <EOL> def export ( self , lwrite , level , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' , namespacedef_ = '<STR_LIT>' , pretty_print = True ) : <EOL> if pretty_print : <EOL> eol_ = '<STR_LIT:\\n>' <EOL> else : <EOL> eol_ = '<STR_LIT>' <EOL> showIndent ( lwrite , level , pretty_print ) <EOL> lwrite ( '<STR_LIT>' % ( namespace_ , name_ , namespacedef_ and '<STR_LIT:U+0020>' + namespacedef_ or '<STR_LIT>' , ) ) <EOL> already_processed = set ( ) <EOL> self . exportAttributes ( lwrite , level , already_processed , namespace_ , name_ = '<STR_LIT>' ) <EOL> if self . hasContent_ ( ) : <EOL> lwrite ( '<STR_LIT>' % ( eol_ , ) ) <EOL> self . exportChildren ( lwrite , level + <NUM_LIT:1> , namespace_ , name_ , pretty_print = pretty_print ) <EOL> showIndent ( lwrite , level , pretty_print ) <EOL> lwrite ( '<STR_LIT>' % ( namespace_ , name_ , eol_ ) ) <EOL> else : <EOL> lwrite ( '<STR_LIT>' % ( eol_ , ) ) <EOL> def exportAttributes ( self , lwrite , level , already_processed , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' ) : <EOL> if self . ordinal_position is not None : <EOL> lwrite ( '<STR_LIT>' % self . gds_format_integer ( self . ordinal_position , input_name = '<STR_LIT>' ) ) <EOL> def exportChildren ( self , lwrite , level , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' , fromsubclass_ = False , pretty_print = True ) : <EOL> if pretty_print : <EOL> eol_ = '<STR_LIT:\\n>' <EOL> else : <EOL> eol_ = '<STR_LIT>' <EOL> if self . HTTP_Client_Request is not None : <EOL> self . HTTP_Client_Request . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . HTTP_Provisional_Server_Response is not None : <EOL> self . HTTP_Provisional_Server_Response . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . HTTP_Server_Response is not None : <EOL> self . HTTP_Server_Response . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> def build ( self , node ) : <EOL> already_processed = set ( ) <EOL> self . buildAttributes ( node , node . attrib , already_processed ) <EOL> for child in node : <EOL> nodeName_ = Tag_pattern_ . match ( child . tag ) . groups ( ) [ - <NUM_LIT:1> ] <EOL> self . buildChildren ( child , node , nodeName_ ) <EOL> def buildAttributes ( self , node , attrs , already_processed ) : <EOL> value = find_attr_value_ ( '<STR_LIT>' , node ) <EOL> if value is not None : <EOL> try : <EOL> self . ordinal_position = int ( value ) <EOL> except ValueError as exp : <EOL> raise_parse_error ( node , '<STR_LIT>' % exp ) <EOL> if self . ordinal_position < <NUM_LIT:0> : <EOL> raise_parse_error ( node , '<STR_LIT>' ) <EOL> def buildChildren ( self , child_ , node , nodeName_ , fromsubclass_ = False ) : <EOL> if nodeName_ == '<STR_LIT>' : <EOL> obj_ = HTTPClientRequestType . factory ( ) <EOL> obj_ . build ( child_ ) <EOL> self . set_HTTP_Client_Request ( obj_ ) <EOL> elif nodeName_ == '<STR_LIT>' : <EOL> obj_ = HTTPServerResponseType . factory ( ) <EOL> obj_ . build ( child_ ) <EOL> self . set_HTTP_Provisional_Server_Response ( obj_ ) <EOL> elif nodeName_ == '<STR_LIT>' : <EOL> obj_ = HTTPServerResponseType . factory ( ) <EOL> obj_ . build ( child_ ) <EOL> self . set_HTTP_Server_Response ( obj_ ) <EOL> class HTTPClientRequestType ( GeneratedsSuper ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subclass = None <EOL> superclass = None <EOL> def __init__ ( self , HTTP_Request_Line = None , HTTP_Request_Header = None , HTTP_Message_Body = None ) : <EOL> self . HTTP_Request_Line = HTTP_Request_Line <EOL> self . HTTP_Request_Header = HTTP_Request_Header <EOL> self . HTTP_Message_Body = HTTP_Message_Body <EOL> def factory ( * args_ , ** kwargs_ ) : <EOL> if HTTPClientRequestType . subclass : <EOL> return HTTPClientRequestType . subclass ( * args_ , ** kwargs_ ) <EOL> else : <EOL> return HTTPClientRequestType ( * args_ , ** kwargs_ ) <EOL> factory = staticmethod ( factory ) <EOL> def get_HTTP_Request_Line ( self ) : return self . HTTP_Request_Line <EOL> def set_HTTP_Request_Line ( self , HTTP_Request_Line ) : self . HTTP_Request_Line = HTTP_Request_Line <EOL> def get_HTTP_Request_Header ( self ) : return self . HTTP_Request_Header <EOL> def set_HTTP_Request_Header ( self , HTTP_Request_Header ) : self . HTTP_Request_Header = HTTP_Request_Header <EOL> def get_HTTP_Message_Body ( self ) : return self . HTTP_Message_Body <EOL> def set_HTTP_Message_Body ( self , HTTP_Message_Body ) : self . HTTP_Message_Body = HTTP_Message_Body <EOL> def hasContent_ ( self ) : <EOL> if ( <EOL> self . HTTP_Request_Line is not None or <EOL> self . HTTP_Request_Header is not None or <EOL> self . HTTP_Message_Body is not None <EOL> ) : <EOL> return True <EOL> else : <EOL> return False <EOL> def export ( self , lwrite , level , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' , namespacedef_ = '<STR_LIT>' , pretty_print = True ) : <EOL> if pretty_print : <EOL> eol_ = '<STR_LIT:\\n>' <EOL> else : <EOL> eol_ = '<STR_LIT>' <EOL> showIndent ( lwrite , level , pretty_print ) <EOL> lwrite ( '<STR_LIT>' % ( namespace_ , name_ , namespacedef_ and '<STR_LIT:U+0020>' + namespacedef_ or '<STR_LIT>' , ) ) <EOL> already_processed = set ( ) <EOL> self . exportAttributes ( lwrite , level , already_processed , namespace_ , name_ = '<STR_LIT>' ) <EOL> if self . hasContent_ ( ) : <EOL> lwrite ( '<STR_LIT>' % ( eol_ , ) ) <EOL> self . exportChildren ( lwrite , level + <NUM_LIT:1> , namespace_ , name_ , pretty_print = pretty_print ) <EOL> showIndent ( lwrite , level , pretty_print ) <EOL> lwrite ( '<STR_LIT>' % ( namespace_ , name_ , eol_ ) ) <EOL> else : <EOL> lwrite ( '<STR_LIT>' % ( eol_ , ) ) <EOL> def exportAttributes ( self , lwrite , level , already_processed , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' ) : <EOL> pass <EOL> def exportChildren ( self , lwrite , level , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' , fromsubclass_ = False , pretty_print = True ) : <EOL> if pretty_print : <EOL> eol_ = '<STR_LIT:\\n>' <EOL> else : <EOL> eol_ = '<STR_LIT>' <EOL> if self . HTTP_Request_Line is not None : <EOL> self . HTTP_Request_Line . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . HTTP_Request_Header is not None : <EOL> self . HTTP_Request_Header . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . HTTP_Message_Body is not None : <EOL> self . HTTP_Message_Body . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> def build ( self , node ) : <EOL> already_processed = set ( ) <EOL> self . buildAttributes ( node , node . attrib , already_processed ) <EOL> for child in node : <EOL> nodeName_ = Tag_pattern_ . match ( child . tag ) . groups ( ) [ - <NUM_LIT:1> ] <EOL> self . buildChildren ( child , node , nodeName_ ) <EOL> def buildAttributes ( self , node , attrs , already_processed ) : <EOL> pass <EOL> def buildChildren ( self , child_ , node , nodeName_ , fromsubclass_ = False ) : <EOL> if nodeName_ == '<STR_LIT>' : <EOL> obj_ = HTTPRequestLineType . factory ( ) <EOL> obj_ . build ( child_ ) <EOL> self . set_HTTP_Request_Line ( obj_ ) <EOL> elif nodeName_ == '<STR_LIT>' : <EOL> obj_ = HTTPRequestHeaderType . factory ( ) <EOL> obj_ . build ( child_ ) <EOL> self . set_HTTP_Request_Header ( obj_ ) <EOL> elif nodeName_ == '<STR_LIT>' : <EOL> obj_ = HTTPMessageType . factory ( ) <EOL> obj_ . build ( child_ ) <EOL> self . set_HTTP_Message_Body ( obj_ ) <EOL> class HTTPServerResponseType ( GeneratedsSuper ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subclass = None <EOL> superclass = None <EOL> def __init__ ( self , HTTP_Status_Line = None , HTTP_Response_Header = None , HTTP_Message_Body = None ) : <EOL> self . HTTP_Status_Line = HTTP_Status_Line <EOL> self . HTTP_Response_Header = HTTP_Response_Header <EOL> self . HTTP_Message_Body = HTTP_Message_Body <EOL> def factory ( * args_ , ** kwargs_ ) : <EOL> if HTTPServerResponseType . subclass : <EOL> return HTTPServerResponseType . subclass ( * args_ , ** kwargs_ ) <EOL> else : <EOL> return HTTPServerResponseType ( * args_ , ** kwargs_ ) <EOL> factory = staticmethod ( factory ) <EOL> def get_HTTP_Status_Line ( self ) : return self . HTTP_Status_Line <EOL> def set_HTTP_Status_Line ( self , HTTP_Status_Line ) : self . HTTP_Status_Line = HTTP_Status_Line <EOL> def get_HTTP_Response_Header ( self ) : return self . HTTP_Response_Header <EOL> def set_HTTP_Response_Header ( self , HTTP_Response_Header ) : self . HTTP_Response_Header = HTTP_Response_Header <EOL> def get_HTTP_Message_Body ( self ) : return self . HTTP_Message_Body <EOL> def set_HTTP_Message_Body ( self , HTTP_Message_Body ) : self . HTTP_Message_Body = HTTP_Message_Body <EOL> def hasContent_ ( self ) : <EOL> if ( <EOL> self . HTTP_Status_Line is not None or <EOL> self . HTTP_Response_Header is not None or <EOL> self . HTTP_Message_Body is not None <EOL> ) : <EOL> return True <EOL> else : <EOL> return False <EOL> def export ( self , lwrite , level , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' , namespacedef_ = '<STR_LIT>' , pretty_print = True ) : <EOL> if pretty_print : <EOL> eol_ = '<STR_LIT:\\n>' <EOL> else : <EOL> eol_ = '<STR_LIT>' <EOL> showIndent ( lwrite , level , pretty_print ) <EOL> lwrite ( '<STR_LIT>' % ( namespace_ , name_ , namespacedef_ and '<STR_LIT:U+0020>' + namespacedef_ or '<STR_LIT>' , ) ) <EOL> already_processed = set ( ) <EOL> self . exportAttributes ( lwrite , level , already_processed , namespace_ , name_ = '<STR_LIT>' ) <EOL> if self . hasContent_ ( ) : <EOL> lwrite ( '<STR_LIT>' % ( eol_ , ) ) <EOL> self . exportChildren ( lwrite , level + <NUM_LIT:1> , namespace_ , name_ , pretty_print = pretty_print ) <EOL> showIndent ( lwrite , level , pretty_print ) <EOL> lwrite ( '<STR_LIT>' % ( namespace_ , name_ , eol_ ) ) <EOL> else : <EOL> lwrite ( '<STR_LIT>' % ( eol_ , ) ) <EOL> def exportAttributes ( self , lwrite , level , already_processed , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' ) : <EOL> pass <EOL> def exportChildren ( self , lwrite , level , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' , fromsubclass_ = False , pretty_print = True ) : <EOL> if pretty_print : <EOL> eol_ = '<STR_LIT:\\n>' <EOL> else : <EOL> eol_ = '<STR_LIT>' <EOL> if self . HTTP_Status_Line is not None : <EOL> self . HTTP_Status_Line . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . HTTP_Response_Header is not None : <EOL> self . HTTP_Response_Header . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . HTTP_Message_Body is not None : <EOL> self . HTTP_Message_Body . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> def build ( self , node ) : <EOL> already_processed = set ( ) <EOL> self . buildAttributes ( node , node . attrib , already_processed ) <EOL> for child in node : <EOL> nodeName_ = Tag_pattern_ . match ( child . tag ) . groups ( ) [ - <NUM_LIT:1> ] <EOL> self . buildChildren ( child , node , nodeName_ ) <EOL> def buildAttributes ( self , node , attrs , already_processed ) : <EOL> pass <EOL> def buildChildren ( self , child_ , node , nodeName_ , fromsubclass_ = False ) : <EOL> if nodeName_ == '<STR_LIT>' : <EOL> obj_ = HTTPStatusLineType . factory ( ) <EOL> obj_ . build ( child_ ) <EOL> self . set_HTTP_Status_Line ( obj_ ) <EOL> elif nodeName_ == '<STR_LIT>' : <EOL> obj_ = HTTPResponseHeaderType . factory ( ) <EOL> obj_ . build ( child_ ) <EOL> self . set_HTTP_Response_Header ( obj_ ) <EOL> elif nodeName_ == '<STR_LIT>' : <EOL> obj_ = HTTPMessageType . factory ( ) <EOL> obj_ . build ( child_ ) <EOL> self . set_HTTP_Message_Body ( obj_ ) <EOL> class HTTPRequestLineType ( GeneratedsSuper ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subclass = None <EOL> superclass = None <EOL> def __init__ ( self , HTTP_Method = None , Value = None , Version = None ) : <EOL> self . HTTP_Method = HTTP_Method <EOL> self . Value = Value <EOL> self . Version = Version <EOL> def factory ( * args_ , ** kwargs_ ) : <EOL> if HTTPRequestLineType . subclass : <EOL> return HTTPRequestLineType . subclass ( * args_ , ** kwargs_ ) <EOL> else : <EOL> return HTTPRequestLineType ( * args_ , ** kwargs_ ) <EOL> factory = staticmethod ( factory ) <EOL> def get_HTTP_Method ( self ) : return self . HTTP_Method <EOL> def set_HTTP_Method ( self , HTTP_Method ) : self . HTTP_Method = HTTP_Method <EOL> def validate_HTTPMethodType ( self , value ) : <EOL> pass <EOL> def get_Value ( self ) : return self . Value <EOL> def set_Value ( self , Value ) : self . Value = Value <EOL> def validate_StringObjectPropertyType ( self , value ) : <EOL> pass <EOL> def get_Version ( self ) : return self . Version <EOL> def set_Version ( self , Version ) : self . Version = Version <EOL> def hasContent_ ( self ) : <EOL> if ( <EOL> self . HTTP_Method is not None or <EOL> self . Value is not None or <EOL> self . Version is not None <EOL> ) : <EOL> return True <EOL> else : <EOL> return False <EOL> def export ( self , lwrite , level , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' , namespacedef_ = '<STR_LIT>' , pretty_print = True ) : <EOL> if pretty_print : <EOL> eol_ = '<STR_LIT:\\n>' <EOL> else : <EOL> eol_ = '<STR_LIT>' <EOL> showIndent ( lwrite , level , pretty_print ) <EOL> lwrite ( '<STR_LIT>' % ( namespace_ , name_ , namespacedef_ and '<STR_LIT:U+0020>' + namespacedef_ or '<STR_LIT>' , ) ) <EOL> already_processed = set ( ) <EOL> self . exportAttributes ( lwrite , level , already_processed , namespace_ , name_ = '<STR_LIT>' ) <EOL> if self . hasContent_ ( ) : <EOL> lwrite ( '<STR_LIT>' % ( eol_ , ) ) <EOL> self . exportChildren ( lwrite , level + <NUM_LIT:1> , namespace_ , name_ , pretty_print = pretty_print ) <EOL> showIndent ( lwrite , level , pretty_print ) <EOL> lwrite ( '<STR_LIT>' % ( namespace_ , name_ , eol_ ) ) <EOL> else : <EOL> lwrite ( '<STR_LIT>' % ( eol_ , ) ) <EOL> def exportAttributes ( self , lwrite , level , already_processed , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' ) : <EOL> pass <EOL> def exportChildren ( self , lwrite , level , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' , fromsubclass_ = False , pretty_print = True ) : <EOL> if pretty_print : <EOL> eol_ = '<STR_LIT:\\n>' <EOL> else : <EOL> eol_ = '<STR_LIT>' <EOL> if self . HTTP_Method is not None : <EOL> self . HTTP_Method . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Value is not None : <EOL> self . Value . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Version is not None : <EOL> self . Version . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> def build ( self , node ) : <EOL> already_processed = set ( ) <EOL> self . buildAttributes ( node , node . attrib , already_processed ) <EOL> for child in node : <EOL> nodeName_ = Tag_pattern_ . match ( child . tag ) . groups ( ) [ - <NUM_LIT:1> ] <EOL> self . buildChildren ( child , node , nodeName_ ) <EOL> def buildAttributes ( self , node , attrs , already_processed ) : <EOL> pass <EOL> def buildChildren ( self , child_ , node , nodeName_ , fromsubclass_ = False ) : <EOL> if nodeName_ == '<STR_LIT>' : <EOL> obj_ = HTTPMethodType . factory ( ) <EOL> obj_ . build ( child_ ) <EOL> self . set_HTTP_Method ( obj_ ) <EOL> elif nodeName_ == '<STR_LIT>' : <EOL> obj_ = cybox_common . StringObjectPropertyType . factory ( ) <EOL> obj_ . build ( child_ ) <EOL> self . set_Value ( obj_ ) <EOL> elif nodeName_ == '<STR_LIT>' : <EOL> obj_ = cybox_common . StringObjectPropertyType . factory ( ) <EOL> obj_ . build ( child_ ) <EOL> self . set_Version ( obj_ ) <EOL> class HTTPRequestHeaderType ( GeneratedsSuper ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subclass = None <EOL> superclass = None <EOL> def __init__ ( self , Raw_Header = None , Parsed_Header = None ) : <EOL> self . Raw_Header = Raw_Header <EOL> self . Parsed_Header = Parsed_Header <EOL> def factory ( * args_ , ** kwargs_ ) : <EOL> if HTTPRequestHeaderType . subclass : <EOL> return HTTPRequestHeaderType . subclass ( * args_ , ** kwargs_ ) <EOL> else : <EOL> return HTTPRequestHeaderType ( * args_ , ** kwargs_ ) <EOL> factory = staticmethod ( factory ) <EOL> def get_Raw_Header ( self ) : return self . Raw_Header <EOL> def set_Raw_Header ( self , Raw_Header ) : self . Raw_Header = Raw_Header <EOL> def validate_StringObjectPropertyType ( self , value ) : <EOL> pass <EOL> def get_Parsed_Header ( self ) : return self . Parsed_Header <EOL> def set_Parsed_Header ( self , Parsed_Header ) : self . Parsed_Header = Parsed_Header <EOL> def hasContent_ ( self ) : <EOL> if ( <EOL> self . Raw_Header is not None or <EOL> self . Parsed_Header is not None <EOL> ) : <EOL> return True <EOL> else : <EOL> return False <EOL> def export ( self , lwrite , level , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' , namespacedef_ = '<STR_LIT>' , pretty_print = True ) : <EOL> if pretty_print : <EOL> eol_ = '<STR_LIT:\\n>' <EOL> else : <EOL> eol_ = '<STR_LIT>' <EOL> showIndent ( lwrite , level , pretty_print ) <EOL> lwrite ( '<STR_LIT>' % ( namespace_ , name_ , namespacedef_ and '<STR_LIT:U+0020>' + namespacedef_ or '<STR_LIT>' , ) ) <EOL> already_processed = set ( ) <EOL> self . exportAttributes ( lwrite , level , already_processed , namespace_ , name_ = '<STR_LIT>' ) <EOL> if self . hasContent_ ( ) : <EOL> lwrite ( '<STR_LIT>' % ( eol_ , ) ) <EOL> self . exportChildren ( lwrite , level + <NUM_LIT:1> , namespace_ , name_ , pretty_print = pretty_print ) <EOL> showIndent ( lwrite , level , pretty_print ) <EOL> lwrite ( '<STR_LIT>' % ( namespace_ , name_ , eol_ ) ) <EOL> else : <EOL> lwrite ( '<STR_LIT>' % ( eol_ , ) ) <EOL> def exportAttributes ( self , lwrite , level , already_processed , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' ) : <EOL> pass <EOL> def exportChildren ( self , lwrite , level , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' , fromsubclass_ = False , pretty_print = True ) : <EOL> if pretty_print : <EOL> eol_ = '<STR_LIT:\\n>' <EOL> else : <EOL> eol_ = '<STR_LIT>' <EOL> if self . Raw_Header is not None : <EOL> if self . Raw_Header . get_valueOf_ ( ) is not None : <EOL> value = self . Raw_Header . get_valueOf_ ( ) <EOL> if not value . startswith ( '<STR_LIT>' ) : <EOL> value = '<STR_LIT>' + value + '<STR_LIT>' <EOL> self . Raw_Header . set_valueOf_ ( value ) <EOL> self . Raw_Header . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Parsed_Header is not None : <EOL> self . Parsed_Header . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> def build ( self , node ) : <EOL> already_processed = set ( ) <EOL> self . buildAttributes ( node , node . attrib , already_processed ) <EOL> for child in node : <EOL> nodeName_ = Tag_pattern_ . match ( child . tag ) . groups ( ) [ - <NUM_LIT:1> ] <EOL> self . buildChildren ( child , node , nodeName_ ) <EOL> def buildAttributes ( self , node , attrs , already_processed ) : <EOL> pass <EOL> def buildChildren ( self , child_ , node , nodeName_ , fromsubclass_ = False ) : <EOL> if nodeName_ == '<STR_LIT>' : <EOL> obj_ = cybox_common . StringObjectPropertyType . factory ( ) <EOL> obj_ . build ( child_ ) <EOL> self . set_Raw_Header ( obj_ ) <EOL> elif nodeName_ == '<STR_LIT>' : <EOL> obj_ = HTTPRequestHeaderFieldsType . factory ( ) <EOL> obj_ . build ( child_ ) <EOL> self . set_Parsed_Header ( obj_ ) <EOL> class HTTPRequestHeaderFieldsType ( GeneratedsSuper ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subclass = None <EOL> superclass = None <EOL> def __init__ ( self , Accept = None , Accept_Charset = None , Accept_Language = None , Accept_Datetime = None , Accept_Encoding = None , Authorization = None , Cache_Control = None , Connection = None , Cookie = None , Content_Length = None , Content_MD5 = None , Content_Type = None , Date = None , Expect = None , From = None , Host = None , If_Match = None , If_Modified_Since = None , If_None_Match = None , If_Range = None , If_Unmodified_Since = None , Max_Forwards = None , Pragma = None , Proxy_Authorization = None , Range = None , Referer = None , TE = None , User_Agent = None , Via = None , Warning = None , DNT = None , X_Requested_With = None , X_Forwarded_For = None , X_Forwarded_Proto = None , X_ATT_DeviceId = None , X_Wap_Profile = None ) : <EOL> self . Accept = Accept <EOL> self . Accept_Charset = Accept_Charset <EOL> self . Accept_Language = Accept_Language <EOL> self . Accept_Datetime = Accept_Datetime <EOL> self . Accept_Encoding = Accept_Encoding <EOL> self . Authorization = Authorization <EOL> self . Cache_Control = Cache_Control <EOL> self . Connection = Connection <EOL> self . Cookie = Cookie <EOL> self . Content_Length = Content_Length <EOL> self . Content_MD5 = Content_MD5 <EOL> self . Content_Type = Content_Type <EOL> self . Date = Date <EOL> self . Expect = Expect <EOL> self . From = From <EOL> self . Host = Host <EOL> self . If_Match = If_Match <EOL> self . If_Modified_Since = If_Modified_Since <EOL> self . If_None_Match = If_None_Match <EOL> self . If_Range = If_Range <EOL> self . If_Unmodified_Since = If_Unmodified_Since <EOL> self . Max_Forwards = Max_Forwards <EOL> self . Pragma = Pragma <EOL> self . Proxy_Authorization = Proxy_Authorization <EOL> self . Range = Range <EOL> self . Referer = Referer <EOL> self . TE = TE <EOL> self . User_Agent = User_Agent <EOL> self . Via = Via <EOL> self . Warning = Warning <EOL> self . DNT = DNT <EOL> self . X_Requested_With = X_Requested_With <EOL> self . X_Forwarded_For = X_Forwarded_For <EOL> self . X_Forwarded_Proto = X_Forwarded_Proto <EOL> self . X_ATT_DeviceId = X_ATT_DeviceId <EOL> self . X_Wap_Profile = X_Wap_Profile <EOL> def factory ( * args_ , ** kwargs_ ) : <EOL> if HTTPRequestHeaderFieldsType . subclass : <EOL> return HTTPRequestHeaderFieldsType . subclass ( * args_ , ** kwargs_ ) <EOL> else : <EOL> return HTTPRequestHeaderFieldsType ( * args_ , ** kwargs_ ) <EOL> factory = staticmethod ( factory ) <EOL> def get_Accept ( self ) : return self . Accept <EOL> def set_Accept ( self , Accept ) : self . Accept = Accept <EOL> def validate_StringObjectPropertyType ( self , value ) : <EOL> pass <EOL> def get_Accept_Charset ( self ) : return self . Accept_Charset <EOL> def set_Accept_Charset ( self , Accept_Charset ) : self . Accept_Charset = Accept_Charset <EOL> def get_Accept_Language ( self ) : return self . Accept_Language <EOL> def set_Accept_Language ( self , Accept_Language ) : self . Accept_Language = Accept_Language <EOL> def get_Accept_Datetime ( self ) : return self . Accept_Datetime <EOL> def set_Accept_Datetime ( self , Accept_Datetime ) : self . Accept_Datetime = Accept_Datetime <EOL> def get_Accept_Encoding ( self ) : return self . Accept_Encoding <EOL> def set_Accept_Encoding ( self , Accept_Encoding ) : self . Accept_Encoding = Accept_Encoding <EOL> def get_Authorization ( self ) : return self . Authorization <EOL> def set_Authorization ( self , Authorization ) : self . Authorization = Authorization <EOL> def get_Cache_Control ( self ) : return self . Cache_Control <EOL> def set_Cache_Control ( self , Cache_Control ) : self . Cache_Control = Cache_Control <EOL> def get_Connection ( self ) : return self . Connection <EOL> def set_Connection ( self , Connection ) : self . Connection = Connection <EOL> def get_Cookie ( self ) : return self . Cookie <EOL> def set_Cookie ( self , Cookie ) : self . Cookie = Cookie <EOL> def get_Content_Length ( self ) : return self . Content_Length <EOL> def set_Content_Length ( self , Content_Length ) : self . Content_Length = Content_Length <EOL> def validate_IntegerObjectPropertyType ( self , value ) : <EOL> pass <EOL> def get_Content_MD5 ( self ) : return self . Content_MD5 <EOL> def set_Content_MD5 ( self , Content_MD5 ) : self . Content_MD5 = Content_MD5 <EOL> def get_Content_Type ( self ) : return self . Content_Type <EOL> def set_Content_Type ( self , Content_Type ) : self . Content_Type = Content_Type <EOL> def get_Date ( self ) : return self . Date <EOL> def set_Date ( self , Date ) : self . Date = Date <EOL> def validate_DateTimeObjectPropertyType ( self , value ) : <EOL> pass <EOL> def get_Expect ( self ) : return self . Expect <EOL> def set_Expect ( self , Expect ) : self . Expect = Expect <EOL> def get_From ( self ) : return self . From <EOL> def set_From ( self , From ) : self . From = From <EOL> def get_Host ( self ) : return self . Host <EOL> def set_Host ( self , Host ) : self . Host = Host <EOL> def get_If_Match ( self ) : return self . If_Match <EOL> def set_If_Match ( self , If_Match ) : self . If_Match = If_Match <EOL> def get_If_Modified_Since ( self ) : return self . If_Modified_Since <EOL> def set_If_Modified_Since ( self , If_Modified_Since ) : self . If_Modified_Since = If_Modified_Since <EOL> def get_If_None_Match ( self ) : return self . If_None_Match <EOL> def set_If_None_Match ( self , If_None_Match ) : self . If_None_Match = If_None_Match <EOL> def get_If_Range ( self ) : return self . If_Range <EOL> def set_If_Range ( self , If_Range ) : self . If_Range = If_Range <EOL> def get_If_Unmodified_Since ( self ) : return self . If_Unmodified_Since <EOL> def set_If_Unmodified_Since ( self , If_Unmodified_Since ) : self . If_Unmodified_Since = If_Unmodified_Since <EOL> def get_Max_Forwards ( self ) : return self . Max_Forwards <EOL> def set_Max_Forwards ( self , Max_Forwards ) : self . Max_Forwards = Max_Forwards <EOL> def get_Pragma ( self ) : return self . Pragma <EOL> def set_Pragma ( self , Pragma ) : self . Pragma = Pragma <EOL> def get_Proxy_Authorization ( self ) : return self . Proxy_Authorization <EOL> def set_Proxy_Authorization ( self , Proxy_Authorization ) : self . Proxy_Authorization = Proxy_Authorization <EOL> def get_Range ( self ) : return self . Range <EOL> def set_Range ( self , Range ) : self . Range = Range <EOL> def get_Referer ( self ) : return self . Referer <EOL> def set_Referer ( self , Referer ) : self . Referer = Referer <EOL> def get_TE ( self ) : return self . TE <EOL> def set_TE ( self , TE ) : self . TE = TE <EOL> def get_User_Agent ( self ) : return self . User_Agent <EOL> def set_User_Agent ( self , User_Agent ) : self . User_Agent = User_Agent <EOL> def get_Via ( self ) : return self . Via <EOL> def set_Via ( self , Via ) : self . Via = Via <EOL> def get_Warning ( self ) : return self . Warning <EOL> def set_Warning ( self , Warning ) : self . Warning = Warning <EOL> def get_DNT ( self ) : return self . DNT <EOL> def set_DNT ( self , DNT ) : self . DNT = DNT <EOL> def get_X_Requested_With ( self ) : return self . X_Requested_With <EOL> def set_X_Requested_With ( self , X_Requested_With ) : self . X_Requested_With = X_Requested_With <EOL> def get_X_Forwarded_For ( self ) : return self . X_Forwarded_For <EOL> def set_X_Forwarded_For ( self , X_Forwarded_For ) : self . X_Forwarded_For = X_Forwarded_For <EOL> def get_X_Forwarded_Proto ( self ) : return self . X_Forwarded_Proto <EOL> def set_X_Forwarded_Proto ( self , X_Forwarded_Proto ) : self . X_Forwarded_Proto = X_Forwarded_Proto <EOL> def get_X_ATT_DeviceId ( self ) : return self . X_ATT_DeviceId <EOL> def set_X_ATT_DeviceId ( self , X_ATT_DeviceId ) : self . X_ATT_DeviceId = X_ATT_DeviceId <EOL> def get_X_Wap_Profile ( self ) : return self . X_Wap_Profile <EOL> def set_X_Wap_Profile ( self , X_Wap_Profile ) : self . X_Wap_Profile = X_Wap_Profile <EOL> def hasContent_ ( self ) : <EOL> if ( <EOL> self . Accept is not None or <EOL> self . Accept_Charset is not None or <EOL> self . Accept_Language is not None or <EOL> self . Accept_Datetime is not None or <EOL> self . Accept_Encoding is not None or <EOL> self . Authorization is not None or <EOL> self . Cache_Control is not None or <EOL> self . Connection is not None or <EOL> self . Cookie is not None or <EOL> self . Content_Length is not None or <EOL> self . Content_MD5 is not None or <EOL> self . Content_Type is not None or <EOL> self . Date is not None or <EOL> self . Expect is not None or <EOL> self . From is not None or <EOL> self . Host is not None or <EOL> self . If_Match is not None or <EOL> self . If_Modified_Since is not None or <EOL> self . If_None_Match is not None or <EOL> self . If_Range is not None or <EOL> self . If_Unmodified_Since is not None or <EOL> self . Max_Forwards is not None or <EOL> self . Pragma is not None or <EOL> self . Proxy_Authorization is not None or <EOL> self . Range is not None or <EOL> self . Referer is not None or <EOL> self . TE is not None or <EOL> self . User_Agent is not None or <EOL> self . Via is not None or <EOL> self . Warning is not None or <EOL> self . DNT is not None or <EOL> self . X_Requested_With is not None or <EOL> self . X_Forwarded_For is not None or <EOL> self . X_Forwarded_Proto is not None or <EOL> self . X_ATT_DeviceId is not None or <EOL> self . X_Wap_Profile is not None <EOL> ) : <EOL> return True <EOL> else : <EOL> return False <EOL> def export ( self , lwrite , level , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' , namespacedef_ = '<STR_LIT>' , pretty_print = True ) : <EOL> if pretty_print : <EOL> eol_ = '<STR_LIT:\\n>' <EOL> else : <EOL> eol_ = '<STR_LIT>' <EOL> showIndent ( lwrite , level , pretty_print ) <EOL> lwrite ( '<STR_LIT>' % ( namespace_ , name_ , namespacedef_ and '<STR_LIT:U+0020>' + namespacedef_ or '<STR_LIT>' , ) ) <EOL> already_processed = set ( ) <EOL> self . exportAttributes ( lwrite , level , already_processed , namespace_ , name_ = '<STR_LIT>' ) <EOL> if self . hasContent_ ( ) : <EOL> lwrite ( '<STR_LIT>' % ( eol_ , ) ) <EOL> self . exportChildren ( lwrite , level + <NUM_LIT:1> , namespace_ , name_ , pretty_print = pretty_print ) <EOL> showIndent ( lwrite , level , pretty_print ) <EOL> lwrite ( '<STR_LIT>' % ( namespace_ , name_ , eol_ ) ) <EOL> else : <EOL> lwrite ( '<STR_LIT>' % ( eol_ , ) ) <EOL> def exportAttributes ( self , lwrite , level , already_processed , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' ) : <EOL> pass <EOL> def exportChildren ( self , lwrite , level , namespace_ = '<STR_LIT>' , name_ = '<STR_LIT>' , fromsubclass_ = False , pretty_print = True ) : <EOL> if pretty_print : <EOL> eol_ = '<STR_LIT:\\n>' <EOL> else : <EOL> eol_ = '<STR_LIT>' <EOL> if self . Accept is not None : <EOL> self . Accept . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Accept_Charset is not None : <EOL> self . Accept_Charset . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Accept_Language is not None : <EOL> self . Accept_Language . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Accept_Datetime is not None : <EOL> self . Accept_Datetime . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Accept_Encoding is not None : <EOL> self . Accept_Encoding . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Authorization is not None : <EOL> self . Authorization . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Cache_Control is not None : <EOL> self . Cache_Control . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Connection is not None : <EOL> self . Connection . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Cookie is not None : <EOL> self . Cookie . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Content_Length is not None : <EOL> self . Content_Length . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Content_MD5 is not None : <EOL> self . Content_MD5 . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Content_Type is not None : <EOL> self . Content_Type . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Date is not None : <EOL> self . Date . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Expect is not None : <EOL> self . Expect . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . From is not None : <EOL> self . From . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Host is not None : <EOL> self . Host . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . If_Match is not None : <EOL> self . If_Match . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . If_Modified_Since is not None : <EOL> self . If_Modified_Since . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . If_None_Match is not None : <EOL> self . If_None_Match . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . If_Range is not None : <EOL> self . If_Range . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . If_Unmodified_Since is not None : <EOL> self . If_Unmodified_Since . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Max_Forwards is not None : <EOL> self . Max_Forwards . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Pragma is not None : <EOL> self . Pragma . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Proxy_Authorization is not None : <EOL> self . Proxy_Authorization . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Range is not None : <EOL> self . Range . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Referer is not None : <EOL> self . Referer . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . TE is not None : <EOL> self . TE . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . User_Agent is not None : <EOL> self . User_Agent . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Via is not None : <EOL> self . Via . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . Warning is not None : <EOL> self . Warning . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . DNT is not None : <EOL> self . DNT . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . X_Requested_With is not None : <EOL> self . X_Requested_With . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . X_Forwarded_For is not None : <EOL> self . X_Forwarded_For . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . X_Forwarded_Proto is not None : <EOL> self . X_Forwarded_Proto . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . X_ATT_DeviceId is not None : <EOL> self . X_ATT_DeviceId . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> if self . X_Wap_Profile is not None : <EOL> self . X_Wap_Profile . export ( lwrite , level , '<STR_LIT>' , name_ = '<STR_LIT>' , pretty_print = pretty_print ) <EOL> def build ( self , node ) : <EOL> already_processed = set ( ) <EOL> self . buildAttributes ( node , node . attrib , already_processed ) <EOL> for child in node : <EOL>", "answer": "nodeName_ = Tag_pattern_ . match ( child . tag ) . groups ( ) [ - <NUM_LIT:1> ]"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> print ( __doc__ ) <EOL> import matplotlib . pyplot as plt <EOL> from mpl_toolkits . mplot3d import Axes3D <EOL> from sklearn import datasets <EOL> from sklearn . decomposition import PCA <EOL> iris = datasets . load_iris ( ) <EOL> X = iris . data [ : , : <NUM_LIT:2> ] <EOL> Y = iris . target <EOL> x_min , x_max = X [ : , <NUM_LIT:0> ] . min ( ) - <NUM_LIT> , X [ : , <NUM_LIT:0> ] . max ( ) + <NUM_LIT> <EOL> y_min , y_max = X [ : , <NUM_LIT:1> ] . min ( ) - <NUM_LIT> , X [ : , <NUM_LIT:1> ] . max ( ) + <NUM_LIT> <EOL> plt . figure ( <NUM_LIT:2> , figsize = ( <NUM_LIT:8> , <NUM_LIT:6> ) ) <EOL> plt . clf ( ) <EOL> plt . scatter ( X [ : , <NUM_LIT:0> ] , X [ : , <NUM_LIT:1> ] , c = Y , cmap = plt . cm . Paired ) <EOL> plt . xlabel ( '<STR_LIT>' ) <EOL> plt . ylabel ( '<STR_LIT>' ) <EOL> plt . xlim ( x_min , x_max ) <EOL> plt . ylim ( y_min , y_max ) <EOL> plt . xticks ( ( ) ) <EOL> plt . yticks ( ( ) ) <EOL> fig = plt . figure ( <NUM_LIT:1> , figsize = ( <NUM_LIT:8> , <NUM_LIT:6> ) ) <EOL>", "answer": "ax = Axes3D ( fig , elev = - <NUM_LIT> , azim = <NUM_LIT> )"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> from __future__ import absolute_import , unicode_literals <EOL> import warnings <EOL> from functools import wraps <EOL> from itertools import count <EOL> from django . db import connection <EOL> try : <EOL> from django . db import connections , router <EOL> except ImportError : <EOL> connections = router = None <EOL> from django . db import models <EOL> from django . db . models . query import QuerySet <EOL> from django . conf import settings <EOL> from celery . utils . timeutils import maybe_timedelta <EOL> from . db import commit_on_success , get_queryset , rollback_unless_managed <EOL> from . utils import now <EOL> class TxIsolationWarning ( UserWarning ) : <EOL> pass <EOL> def transaction_retry ( max_retries = <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _outer ( fun ) : <EOL> @ wraps ( fun ) <EOL> def _inner ( * args , ** kwargs ) : <EOL> _max_retries = kwargs . pop ( '<STR_LIT>' , max_retries ) <EOL> for retries in count ( <NUM_LIT:0> ) : <EOL> try : <EOL> return fun ( * args , ** kwargs ) <EOL> except Exception : <EOL> if retries >= _max_retries : <EOL> raise <EOL> try : <EOL> rollback_unless_managed ( ) <EOL> except Exception : <EOL> pass <EOL> return _inner <EOL> return _outer <EOL> def update_model_with_dict ( obj , fields ) : <EOL> [ setattr ( obj , attr_name , attr_value ) <EOL> for attr_name , attr_value in fields . items ( ) ] <EOL> obj . save ( ) <EOL> return obj <EOL> class ExtendedQuerySet ( QuerySet ) : <EOL> def update_or_create ( self , ** kwargs ) : <EOL> obj , created = self . get_or_create ( ** kwargs ) <EOL> if not created : <EOL> fields = dict ( kwargs . pop ( '<STR_LIT>' , { } ) ) <EOL> fields . update ( kwargs ) <EOL> update_model_with_dict ( obj , fields ) <EOL> return obj <EOL> class ExtendedManager ( models . Manager ) : <EOL> def get_queryset ( self ) : <EOL>", "answer": "return ExtendedQuerySet ( self . model )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from datetime import datetime , time <EOL> from pyrseas . relation . attribute import Attribute <EOL> RESERVED_ATTRIBUTE_NAMES = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> class Tuple ( object ) : <EOL> \"<STR_LIT>\" <EOL> def __init__ ( self , attribs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( attribs , list ) : <EOL> attribs = [ attribs ] <EOL> self . _sysdefault_attribs = [ ] <EOL> self . _nullable_attribs = [ ] <EOL> self . _tuple_version = None <EOL> heading = [ ] <EOL> for attr in attribs : <EOL> assert isinstance ( attr , Attribute ) <EOL> assert attr . name not in RESERVED_ATTRIBUTE_NAMES , \"<STR_LIT>\" % attr . name <EOL> setattr ( self , attr . name , attr . value ) <EOL> heading . append ( ( attr . name , attr . type ) ) <EOL> if attr . sysdefault : <EOL> self . _sysdefault_attribs . append ( attr . name ) <EOL>", "answer": "if attr . nullable :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import division , print_function <EOL> import sys <EOL> import os <EOL> import re <EOL> import glob <EOL> import math <EOL> import zlib <EOL> import time <EOL> import json <EOL> import struct <EOL> import warnings <EOL> import tempfile <EOL> import datetime <EOL> import collections <EOL> from fractions import Fraction <EOL> from xml . etree import cElementTree as etree <EOL> import numpy <EOL> try : <EOL> import lzma <EOL> except ImportError : <EOL> try : <EOL> import backports . lzma as lzma <EOL> except ImportError : <EOL> lzma = None <EOL> try : <EOL> from . import _tifffile <EOL> except ImportError : <EOL> warnings . warn ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> __version__ = '<STR_LIT>' <EOL> __docformat__ = '<STR_LIT>' <EOL> __all__ = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def imsave ( filename , data , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> tifargs = { } <EOL> for key in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if key in kwargs : <EOL> tifargs [ key ] = kwargs [ key ] <EOL> del kwargs [ key ] <EOL> if '<STR_LIT>' not in tifargs and '<STR_LIT>' not in tifargs and ( <EOL> data . size * data . dtype . itemsize > <NUM_LIT> * <NUM_LIT:2> ** <NUM_LIT:20> ) : <EOL> tifargs [ '<STR_LIT>' ] = True <EOL> with TiffWriter ( filename , ** tifargs ) as tif : <EOL> tif . save ( data , ** kwargs ) <EOL> class TiffWriter ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> TYPES = { '<STR_LIT:B>' : <NUM_LIT:1> , '<STR_LIT:s>' : <NUM_LIT:2> , '<STR_LIT:H>' : <NUM_LIT:3> , '<STR_LIT:I>' : <NUM_LIT:4> , '<STR_LIT>' : <NUM_LIT:5> , '<STR_LIT:b>' : <NUM_LIT:6> , <EOL> '<STR_LIT:h>' : <NUM_LIT:8> , '<STR_LIT:i>' : <NUM_LIT:9> , '<STR_LIT:f>' : <NUM_LIT:11> , '<STR_LIT:d>' : <NUM_LIT:12> , '<STR_LIT>' : <NUM_LIT:16> , '<STR_LIT:q>' : <NUM_LIT> } <EOL> TAGS = { <EOL> '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT:255> , <EOL> '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> } <EOL> def __init__ ( self , filename , bigtiff = False , byteorder = None , <EOL> software = '<STR_LIT>' , imagej = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if byteorder not in ( None , '<STR_LIT:<>' , '<STR_LIT:>>' ) : <EOL> raise ValueError ( \"<STR_LIT>\" % byteorder ) <EOL> if byteorder is None : <EOL> byteorder = '<STR_LIT:<>' if sys . byteorder == '<STR_LIT>' else '<STR_LIT:>>' <EOL> if imagej and bigtiff : <EOL> warnings . warn ( \"<STR_LIT>\" ) <EOL> self . _byteorder = byteorder <EOL> self . _software = software <EOL> self . _imagej = bool ( imagej ) <EOL> self . _metadata = None <EOL> self . _colormap = None <EOL> self . _description_offset = <NUM_LIT:0> <EOL> self . _description_len_offset = <NUM_LIT:0> <EOL> self . _description_len = <NUM_LIT:0> <EOL> self . _tags = None <EOL> self . _shape = None <EOL> self . _data_shape = None <EOL> self . _data_dtype = None <EOL> self . _data_offset = None <EOL> self . _data_byte_counts = None <EOL> self . _tag_offsets = None <EOL> self . _fh = open ( filename , '<STR_LIT:wb>' ) <EOL> self . _fh . write ( { '<STR_LIT:<>' : b'<STR_LIT>' , '<STR_LIT:>>' : b'<STR_LIT>' } [ byteorder ] ) <EOL> if bigtiff : <EOL> self . _bigtiff = True <EOL> self . _offset_size = <NUM_LIT:8> <EOL> self . _tag_size = <NUM_LIT:20> <EOL> self . _numtag_format = '<STR_LIT>' <EOL> self . _offset_format = '<STR_LIT>' <EOL> self . _value_format = '<STR_LIT>' <EOL> self . _fh . write ( struct . pack ( byteorder + '<STR_LIT>' , <NUM_LIT> , <NUM_LIT:8> , <NUM_LIT:0> ) ) <EOL> else : <EOL> self . _bigtiff = False <EOL> self . _offset_size = <NUM_LIT:4> <EOL> self . _tag_size = <NUM_LIT:12> <EOL> self . _numtag_format = '<STR_LIT:H>' <EOL> self . _offset_format = '<STR_LIT:I>' <EOL> self . _value_format = '<STR_LIT>' <EOL> self . _fh . write ( struct . pack ( byteorder + '<STR_LIT:H>' , <NUM_LIT> ) ) <EOL> self . _ifd_offset = self . _fh . tell ( ) <EOL> self . _fh . write ( struct . pack ( byteorder + self . _offset_format , <NUM_LIT:0> ) ) <EOL> def save ( self , data , photometric = None , planarconfig = None , resolution = None , <EOL> compress = <NUM_LIT:0> , colormap = None , tile = None , datetime = None , <EOL> description = None , metadata = { } , contiguous = True , extratags = ( ) ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fh = self . _fh <EOL> byteorder = self . _byteorder <EOL> numtag_format = self . _numtag_format <EOL> value_format = self . _value_format <EOL> offset_format = self . _offset_format <EOL> offset_size = self . _offset_size <EOL> tag_size = self . _tag_size <EOL> data = numpy . asarray ( data , dtype = byteorder + data . dtype . char , order = '<STR_LIT:C>' ) <EOL> if self . _data_shape : <EOL> if ( not contiguous or <EOL> self . _data_shape [ <NUM_LIT:1> : ] != data . shape or <EOL> self . _data_dtype != data . dtype or <EOL> ( compress and self . _tags ) or <EOL> tile or <EOL> not numpy . array_equal ( colormap , self . _colormap ) ) : <EOL> self . _write_remaining_pages ( ) <EOL> self . _write_image_description ( ) <EOL> self . _description_offset = <NUM_LIT:0> <EOL> self . _description_len_offset = <NUM_LIT:0> <EOL> self . _data_shape = None <EOL> self . _colormap = None <EOL> if self . _imagej : <EOL> raise ValueError ( <EOL> \"<STR_LIT>\" ) <EOL> else : <EOL> self . _data_shape = ( self . _data_shape [ <NUM_LIT:0> ] + <NUM_LIT:1> , ) + data . shape <EOL> if not compress : <EOL> data . tofile ( fh ) <EOL> return <EOL> if photometric not in ( None , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) : <EOL> raise ValueError ( \"<STR_LIT>\" % photometric ) <EOL> if planarconfig not in ( None , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> raise ValueError ( \"<STR_LIT>\" % planarconfig ) <EOL> if not compress : <EOL> compress = False <EOL> compress_tag = <NUM_LIT:1> <EOL> elif compress == '<STR_LIT>' : <EOL> compress = lzma . compress <EOL> compress_tag = <NUM_LIT> <EOL> if self . _imagej : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif not <NUM_LIT:0> <= compress <= <NUM_LIT:9> : <EOL> raise ValueError ( \"<STR_LIT>\" % compress ) <EOL> elif compress : <EOL> def compress ( data , level = compress ) : <EOL> return zlib . compress ( data , level ) <EOL> compress_tag = <NUM_LIT> <EOL> if self . _imagej : <EOL> if description : <EOL> warnings . warn ( \"<STR_LIT>\" ) <EOL> description = None <EOL> volume = False <EOL> if data . dtype . char not in '<STR_LIT>' : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> % data . dtype . char ) <EOL> ijrgb = photometric == '<STR_LIT>' if photometric else None <EOL> if data . dtype . char not in '<STR_LIT:B>' : <EOL> ijrgb = False <EOL> ijshape = imagej_shape ( data . shape , ijrgb ) <EOL> if ijshape [ - <NUM_LIT:1> ] in ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> photometric = '<STR_LIT>' <EOL> if data . dtype . char not in '<STR_LIT:B>' : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % data . dtype . char ) <EOL> elif photometric is None : <EOL> photometric = '<STR_LIT>' <EOL> planarconfig = None <EOL> if planarconfig == '<STR_LIT>' : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> planarconfig = '<STR_LIT>' if ijrgb else None <EOL> if colormap is not None : <EOL> if data . dtype . char not in '<STR_LIT>' : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> colormap = numpy . asarray ( colormap , dtype = byteorder + '<STR_LIT:H>' ) <EOL> if colormap . shape != ( <NUM_LIT:3> , <NUM_LIT:2> ** ( data . itemsize * <NUM_LIT:8> ) ) : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> self . _colormap = colormap <EOL> if tile : <EOL> tile = tuple ( int ( i ) for i in tile [ : <NUM_LIT:3> ] ) <EOL> volume = len ( tile ) == <NUM_LIT:3> <EOL> if ( len ( tile ) < <NUM_LIT:2> or tile [ - <NUM_LIT:1> ] % <NUM_LIT:16> or tile [ - <NUM_LIT:2> ] % <NUM_LIT:16> or <EOL> any ( i < <NUM_LIT:1> for i in tile ) ) : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> tile = ( ) <EOL> volume = False <EOL> data_shape = shape = data . shape <EOL> data = numpy . atleast_2d ( data ) <EOL> samplesperpixel = <NUM_LIT:1> <EOL> extrasamples = <NUM_LIT:0> <EOL> if volume and data . ndim < <NUM_LIT:3> : <EOL> volume = False <EOL> if colormap is not None : <EOL> photometric = '<STR_LIT>' <EOL> planarconfig = None <EOL> if photometric is None : <EOL> if planarconfig : <EOL> photometric = '<STR_LIT>' <EOL> elif data . ndim > <NUM_LIT:2> and shape [ - <NUM_LIT:1> ] in ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> photometric = '<STR_LIT>' <EOL> elif self . _imagej : <EOL> photometric = '<STR_LIT>' <EOL> elif volume and data . ndim > <NUM_LIT:3> and shape [ - <NUM_LIT:4> ] in ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> photometric = '<STR_LIT>' <EOL> elif data . ndim > <NUM_LIT:2> and shape [ - <NUM_LIT:3> ] in ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> photometric = '<STR_LIT>' <EOL> else : <EOL> photometric = '<STR_LIT>' <EOL> if planarconfig and len ( shape ) <= ( <NUM_LIT:3> if volume else <NUM_LIT:2> ) : <EOL> planarconfig = None <EOL> photometric = '<STR_LIT>' <EOL> if photometric == '<STR_LIT>' : <EOL> if len ( shape ) < <NUM_LIT:3> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if len ( shape ) < <NUM_LIT:4> : <EOL> volume = False <EOL> if planarconfig is None : <EOL> if shape [ - <NUM_LIT:1> ] in ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> planarconfig = '<STR_LIT>' <EOL> elif shape [ - <NUM_LIT:4> if volume else - <NUM_LIT:3> ] in ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> planarconfig = '<STR_LIT>' <EOL> elif shape [ - <NUM_LIT:1> ] > shape [ - <NUM_LIT:4> if volume else - <NUM_LIT:3> ] : <EOL> planarconfig = '<STR_LIT>' <EOL> else : <EOL> planarconfig = '<STR_LIT>' <EOL> if planarconfig == '<STR_LIT>' : <EOL> data = data . reshape ( ( - <NUM_LIT:1> , <NUM_LIT:1> ) + shape [ ( - <NUM_LIT:4> if volume else - <NUM_LIT:3> ) : ] ) <EOL> samplesperpixel = data . shape [ - <NUM_LIT:1> ] <EOL> else : <EOL> data = data . reshape ( <EOL> ( - <NUM_LIT:1> , ) + shape [ ( - <NUM_LIT:4> if volume else - <NUM_LIT:3> ) : ] + ( <NUM_LIT:1> , ) ) <EOL> samplesperpixel = data . shape [ <NUM_LIT:1> ] <EOL> if samplesperpixel > <NUM_LIT:3> : <EOL> extrasamples = samplesperpixel - <NUM_LIT:3> <EOL> elif planarconfig and len ( shape ) > ( <NUM_LIT:3> if volume else <NUM_LIT:2> ) : <EOL> if planarconfig == '<STR_LIT>' : <EOL> data = data . reshape ( ( - <NUM_LIT:1> , <NUM_LIT:1> ) + shape [ ( - <NUM_LIT:4> if volume else - <NUM_LIT:3> ) : ] ) <EOL> samplesperpixel = data . shape [ - <NUM_LIT:1> ] <EOL> else : <EOL> data = data . reshape ( <EOL> ( - <NUM_LIT:1> , ) + shape [ ( - <NUM_LIT:4> if volume else - <NUM_LIT:3> ) : ] + ( <NUM_LIT:1> , ) ) <EOL> samplesperpixel = data . shape [ <NUM_LIT:1> ] <EOL> extrasamples = samplesperpixel - <NUM_LIT:1> <EOL> else : <EOL> planarconfig = None <EOL> while len ( shape ) > <NUM_LIT:2> and shape [ - <NUM_LIT:1> ] == <NUM_LIT:1> : <EOL> shape = shape [ : - <NUM_LIT:1> ] <EOL> if len ( shape ) < <NUM_LIT:3> : <EOL> volume = False <EOL> if False and ( <EOL> photometric != '<STR_LIT>' and <EOL> len ( shape ) > ( <NUM_LIT:3> if volume else <NUM_LIT:2> ) and shape [ - <NUM_LIT:1> ] < <NUM_LIT:5> and <EOL> all ( shape [ - <NUM_LIT:1> ] < i <EOL> for i in shape [ ( - <NUM_LIT:4> if volume else - <NUM_LIT:3> ) : - <NUM_LIT:1> ] ) ) : <EOL> planarconfig = '<STR_LIT>' <EOL> samplesperpixel = shape [ - <NUM_LIT:1> ] <EOL> data = data . reshape ( ( - <NUM_LIT:1> , <NUM_LIT:1> ) + shape [ ( - <NUM_LIT:4> if volume else - <NUM_LIT:3> ) : ] ) <EOL> else : <EOL> data = data . reshape ( <EOL> ( - <NUM_LIT:1> , <NUM_LIT:1> ) + shape [ ( - <NUM_LIT:3> if volume else - <NUM_LIT:2> ) : ] + ( <NUM_LIT:1> , ) ) <EOL> assert len ( data . shape ) in ( <NUM_LIT:5> , <NUM_LIT:6> ) <EOL> if len ( data . shape ) == <NUM_LIT:5> : <EOL> data = data . reshape ( data . shape [ : <NUM_LIT:2> ] + ( <NUM_LIT:1> , ) + data . shape [ <NUM_LIT:2> : ] ) <EOL> shape = data . shape <EOL> if tile and not volume : <EOL> tile = ( <NUM_LIT:1> , tile [ - <NUM_LIT:2> ] , tile [ - <NUM_LIT:1> ] ) <EOL> if photometric == '<STR_LIT>' : <EOL> if ( samplesperpixel != <NUM_LIT:1> or extrasamples or <EOL> shape [ <NUM_LIT:1> ] != <NUM_LIT:1> or shape [ - <NUM_LIT:1> ] != <NUM_LIT:1> ) : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if samplesperpixel == <NUM_LIT:2> : <EOL> warnings . warn ( \"<STR_LIT>\" ) <EOL> bytestr = bytes if sys . version [ <NUM_LIT:0> ] == '<STR_LIT:2>' else ( <EOL> lambda x : bytes ( x , '<STR_LIT:utf-8>' ) if isinstance ( x , str ) else x ) <EOL> tags = [ ] <EOL> strip_or_tile = '<STR_LIT>' if tile else '<STR_LIT>' <EOL> tag_byte_counts = TiffWriter . TAGS [ strip_or_tile + '<STR_LIT>' ] <EOL> tag_offsets = TiffWriter . TAGS [ strip_or_tile + '<STR_LIT>' ] <EOL> self . _tag_offsets = tag_offsets <EOL> def pack ( fmt , * val ) : <EOL> return struct . pack ( byteorder + fmt , * val ) <EOL> def addtag ( code , dtype , count , value , writeonce = False ) : <EOL> code = int ( TiffWriter . TAGS . get ( code , code ) ) <EOL> try : <EOL> tifftype = TiffWriter . TYPES [ dtype ] <EOL> except KeyError : <EOL> raise ValueError ( \"<STR_LIT>\" % dtype ) <EOL> rawcount = count <EOL> if dtype == '<STR_LIT:s>' : <EOL> value = bytestr ( value ) + b'<STR_LIT>' <EOL> count = rawcount = len ( value ) <EOL> rawcount = value . find ( b'<STR_LIT>' ) <EOL> if rawcount < <NUM_LIT:0> : <EOL> rawcount = count <EOL> else : <EOL> rawcount += <NUM_LIT:1> <EOL> value = ( value , ) <EOL> if len ( dtype ) > <NUM_LIT:1> : <EOL> count *= int ( dtype [ : - <NUM_LIT:1> ] ) <EOL> dtype = dtype [ - <NUM_LIT:1> ] <EOL> ifdentry = [ pack ( '<STR_LIT>' , code , tifftype ) , <EOL> pack ( offset_format , rawcount ) ] <EOL> ifdvalue = None <EOL> if struct . calcsize ( dtype ) * count <= offset_size : <EOL> if count == <NUM_LIT:1> : <EOL> if isinstance ( value , ( tuple , list , numpy . ndarray ) ) : <EOL> value = value [ <NUM_LIT:0> ] <EOL> ifdentry . append ( pack ( value_format , pack ( dtype , value ) ) ) <EOL> else : <EOL> ifdentry . append ( pack ( value_format , <EOL> pack ( str ( count ) + dtype , * value ) ) ) <EOL> else : <EOL> ifdentry . append ( pack ( offset_format , <NUM_LIT:0> ) ) <EOL> if isinstance ( value , numpy . ndarray ) : <EOL> assert value . size == count <EOL> assert value . dtype . char == dtype <EOL> ifdvalue = value . tobytes ( ) <EOL> elif isinstance ( value , ( tuple , list ) ) : <EOL> ifdvalue = pack ( str ( count ) + dtype , * value ) <EOL> else : <EOL> ifdvalue = pack ( dtype , value ) <EOL> tags . append ( ( code , b'<STR_LIT>' . join ( ifdentry ) , ifdvalue , writeonce ) ) <EOL> def rational ( arg , max_denominator = <NUM_LIT> ) : <EOL> try : <EOL> f = Fraction . from_float ( arg ) <EOL> except TypeError : <EOL> f = Fraction ( arg [ <NUM_LIT:0> ] , arg [ <NUM_LIT:1> ] ) <EOL> f = f . limit_denominator ( max_denominator ) <EOL> return f . numerator , f . denominator <EOL> if description : <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:s>' , <NUM_LIT:0> , description , writeonce = True ) <EOL> self . _metadata = { } if not metadata else metadata <EOL> if self . _imagej : <EOL> description = imagej_description ( <EOL> data_shape , shape [ - <NUM_LIT:1> ] in ( <NUM_LIT:3> , <NUM_LIT:4> ) , self . _colormap is not None , <EOL> ** self . _metadata ) <EOL> elif metadata or metadata == { } : <EOL> description = image_description ( <EOL> data_shape , self . _colormap is not None , ** self . _metadata ) <EOL> else : <EOL> description = None <EOL> if description : <EOL> description += b'<STR_LIT>' * <NUM_LIT:32> <EOL> self . _description_len = len ( description ) <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:s>' , <NUM_LIT:0> , description , writeonce = True ) <EOL> if self . _software : <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:s>' , <NUM_LIT:0> , self . _software , writeonce = True ) <EOL> self . _software = None <EOL> if datetime is None : <EOL> datetime = self . _now ( ) <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:s>' , <NUM_LIT:0> , datetime . strftime ( \"<STR_LIT>\" ) , <EOL> writeonce = True ) <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:H>' , <NUM_LIT:1> , compress_tag ) <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:I>' , <NUM_LIT:1> , shape [ - <NUM_LIT:2> ] ) <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:I>' , <NUM_LIT:1> , shape [ - <NUM_LIT:3> ] ) <EOL> if tile : <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:I>' , <NUM_LIT:1> , tile [ - <NUM_LIT:1> ] ) <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:I>' , <NUM_LIT:1> , tile [ - <NUM_LIT:2> ] ) <EOL> if tile [ <NUM_LIT:0> ] > <NUM_LIT:1> : <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:I>' , <NUM_LIT:1> , shape [ - <NUM_LIT:4> ] ) <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:I>' , <NUM_LIT:1> , tile [ <NUM_LIT:0> ] ) <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:I>' , <NUM_LIT:1> , <NUM_LIT:0> ) <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:H>' , <NUM_LIT:1> , <EOL> { '<STR_LIT:u>' : <NUM_LIT:1> , '<STR_LIT:i>' : <NUM_LIT:2> , '<STR_LIT:f>' : <NUM_LIT:3> , '<STR_LIT:c>' : <NUM_LIT:6> } [ data . dtype . kind ] ) <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:H>' , <NUM_LIT:1> , { '<STR_LIT>' : <NUM_LIT:0> , '<STR_LIT>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : <NUM_LIT:2> , '<STR_LIT>' : <NUM_LIT:3> } [ photometric ] ) <EOL> if colormap is not None : <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:H>' , colormap . size , colormap ) <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:H>' , <NUM_LIT:1> , samplesperpixel ) <EOL> if planarconfig and samplesperpixel > <NUM_LIT:1> : <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:H>' , <NUM_LIT:1> , <NUM_LIT:1> <EOL> if planarconfig == '<STR_LIT>' else <NUM_LIT:2> ) <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:H>' , samplesperpixel , <EOL> ( data . dtype . itemsize * <NUM_LIT:8> , ) * samplesperpixel ) <EOL> else : <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:H>' , <NUM_LIT:1> , data . dtype . itemsize * <NUM_LIT:8> ) <EOL> if extrasamples : <EOL> if photometric == '<STR_LIT>' and extrasamples == <NUM_LIT:1> : <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:H>' , <NUM_LIT:1> , <NUM_LIT:1> ) <EOL> else : <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:H>' , extrasamples , ( <NUM_LIT:0> , ) * extrasamples ) <EOL> if resolution : <EOL> addtag ( '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT:1> , rational ( resolution [ <NUM_LIT:0> ] ) ) <EOL> addtag ( '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT:1> , rational ( resolution [ <NUM_LIT:1> ] ) ) <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:H>' , <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> if not tile : <EOL> addtag ( '<STR_LIT>' , '<STR_LIT:I>' , <NUM_LIT:1> , shape [ - <NUM_LIT:3> ] ) <EOL> if tile : <EOL> tiles = ( ( shape [ <NUM_LIT:2> ] + tile [ <NUM_LIT:0> ] - <NUM_LIT:1> ) // tile [ <NUM_LIT:0> ] , <EOL> ( shape [ <NUM_LIT:3> ] + tile [ <NUM_LIT:1> ] - <NUM_LIT:1> ) // tile [ <NUM_LIT:1> ] , <EOL> ( shape [ <NUM_LIT:4> ] + tile [ <NUM_LIT:2> ] - <NUM_LIT:1> ) // tile [ <NUM_LIT:2> ] ) <EOL> numtiles = product ( tiles ) * shape [ <NUM_LIT:1> ] <EOL> strip_byte_counts = [ <EOL> product ( tile ) * shape [ - <NUM_LIT:1> ] * data . dtype . itemsize ] * numtiles <EOL> addtag ( tag_byte_counts , offset_format , numtiles , strip_byte_counts ) <EOL> addtag ( tag_offsets , offset_format , numtiles , [ <NUM_LIT:0> ] * numtiles ) <EOL> chunk = numpy . empty ( tile + ( shape [ - <NUM_LIT:1> ] , ) , dtype = data . dtype ) <EOL> else : <EOL> strip_byte_counts = [ <EOL> data [ <NUM_LIT:0> , <NUM_LIT:0> ] . size * data . dtype . itemsize ] * shape [ <NUM_LIT:1> ] <EOL> addtag ( tag_byte_counts , offset_format , shape [ <NUM_LIT:1> ] , strip_byte_counts ) <EOL> addtag ( tag_offsets , offset_format , shape [ <NUM_LIT:1> ] , [ <NUM_LIT:0> ] * shape [ <NUM_LIT:1> ] ) <EOL> for t in extratags : <EOL> addtag ( * t ) <EOL> tags = sorted ( tags , key = lambda x : x [ <NUM_LIT:0> ] ) <EOL> if not ( self . _bigtiff or self . _imagej ) and ( <EOL> fh . tell ( ) + data . size * data . dtype . itemsize > <NUM_LIT:2> ** <NUM_LIT> - <NUM_LIT:1> ) : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> for pageindex in range ( shape [ <NUM_LIT:0> ] if ( compress or tile ) else <NUM_LIT:1> ) : <EOL> pos = fh . tell ( ) <EOL> fh . seek ( self . _ifd_offset ) <EOL> fh . write ( pack ( offset_format , pos ) ) <EOL> fh . seek ( pos ) <EOL> fh . write ( pack ( numtag_format , len ( tags ) ) ) <EOL> tag_offset = fh . tell ( ) <EOL> fh . write ( b'<STR_LIT>' . join ( t [ <NUM_LIT:1> ] for t in tags ) ) <EOL> self . _ifd_offset = fh . tell ( ) <EOL> fh . write ( pack ( offset_format , <NUM_LIT:0> ) ) <EOL> for tagindex , tag in enumerate ( tags ) : <EOL> if tag [ <NUM_LIT:2> ] : <EOL> pos = fh . tell ( ) <EOL> fh . seek ( tag_offset + tagindex * tag_size + offset_size + <NUM_LIT:4> ) <EOL> fh . write ( pack ( offset_format , pos ) ) <EOL> fh . seek ( pos ) <EOL> if tag [ <NUM_LIT:0> ] == tag_offsets : <EOL> strip_offsets_offset = pos <EOL> elif tag [ <NUM_LIT:0> ] == tag_byte_counts : <EOL> strip_byte_counts_offset = pos <EOL> elif tag [ <NUM_LIT:0> ] == <NUM_LIT> and tag [ <NUM_LIT:2> ] . endswith ( b'<STR_LIT>' ) : <EOL> self . _description_offset = pos <EOL> self . _description_len_offset = ( <EOL> tag_offset + tagindex * tag_size + <NUM_LIT:4> ) <EOL> fh . write ( tag [ <NUM_LIT:2> ] ) <EOL> data_offset = fh . tell ( ) <EOL> if compress : <EOL> strip_byte_counts = [ ] <EOL> if tile : <EOL> for plane in data [ pageindex ] : <EOL> for tz in range ( tiles [ <NUM_LIT:0> ] ) : <EOL> for ty in range ( tiles [ <NUM_LIT:1> ] ) : <EOL> for tx in range ( tiles [ <NUM_LIT:2> ] ) : <EOL> c0 = min ( tile [ <NUM_LIT:0> ] , shape [ <NUM_LIT:2> ] - tz * tile [ <NUM_LIT:0> ] ) <EOL> c1 = min ( tile [ <NUM_LIT:1> ] , shape [ <NUM_LIT:3> ] - ty * tile [ <NUM_LIT:1> ] ) <EOL> c2 = min ( tile [ <NUM_LIT:2> ] , shape [ <NUM_LIT:4> ] - tx * tile [ <NUM_LIT:2> ] ) <EOL> chunk [ c0 : , c1 : , c2 : ] = <NUM_LIT:0> <EOL> chunk [ : c0 , : c1 , : c2 ] = plane [ <EOL> tz * tile [ <NUM_LIT:0> ] : tz * tile [ <NUM_LIT:0> ] + c0 , <EOL> ty * tile [ <NUM_LIT:1> ] : ty * tile [ <NUM_LIT:1> ] + c1 , <EOL> tx * tile [ <NUM_LIT:2> ] : tx * tile [ <NUM_LIT:2> ] + c2 ] <EOL> if compress : <EOL> t = compress ( chunk ) <EOL> strip_byte_counts . append ( len ( t ) ) <EOL> fh . write ( t ) <EOL> else : <EOL> chunk . tofile ( fh ) <EOL> fh . flush ( ) <EOL> elif compress : <EOL> for plane in data [ pageindex ] : <EOL> plane = compress ( plane ) <EOL> strip_byte_counts . append ( len ( plane ) ) <EOL> fh . write ( plane ) <EOL> else : <EOL> data . tofile ( fh ) <EOL> pos = fh . tell ( ) <EOL> for tagindex , tag in enumerate ( tags ) : <EOL> if tag [ <NUM_LIT:0> ] == tag_offsets : <EOL> if tag [ <NUM_LIT:2> ] : <EOL> fh . seek ( strip_offsets_offset ) <EOL> strip_offset = data_offset <EOL> for size in strip_byte_counts : <EOL> fh . write ( pack ( offset_format , strip_offset ) ) <EOL> strip_offset += size <EOL> else : <EOL> fh . seek ( tag_offset + tagindex * tag_size + <EOL> offset_size + <NUM_LIT:4> ) <EOL> fh . write ( pack ( offset_format , data_offset ) ) <EOL> elif tag [ <NUM_LIT:0> ] == tag_byte_counts : <EOL> if compress : <EOL> if tag [ <NUM_LIT:2> ] : <EOL> fh . seek ( strip_byte_counts_offset ) <EOL> for size in strip_byte_counts : <EOL> fh . write ( pack ( offset_format , size ) ) <EOL> else : <EOL> fh . seek ( tag_offset + tagindex * tag_size + <EOL> offset_size + <NUM_LIT:4> ) <EOL> fh . write ( pack ( offset_format , strip_byte_counts [ <NUM_LIT:0> ] ) ) <EOL> break <EOL> fh . seek ( pos ) <EOL> fh . flush ( ) <EOL> if pageindex == <NUM_LIT:0> : <EOL> tags = [ tag for tag in tags if not tag [ - <NUM_LIT:1> ] ] <EOL> if not ( compress or tile ) : <EOL> self . _tags = tags <EOL> self . _shape = shape <EOL> self . _data_shape = ( <NUM_LIT:1> , ) + data_shape <EOL> self . _data_dtype = data . dtype <EOL> self . _data_offset = data_offset <EOL> self . _data_byte_counts = strip_byte_counts <EOL> def _write_remaining_pages ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . _tags : <EOL> return <EOL> fh = self . _fh <EOL> byteorder = self . _byteorder <EOL> numtag_format = self . _numtag_format <EOL> offset_format = self . _offset_format <EOL> offset_size = self . _offset_size <EOL> tag_size = self . _tag_size <EOL> data_offset = self . _data_offset <EOL> page_data_size = sum ( self . _data_byte_counts ) <EOL> tag_bytes = b'<STR_LIT>' . join ( t [ <NUM_LIT:1> ] for t in self . _tags ) <EOL> numpages = self . _shape [ <NUM_LIT:0> ] * self . _data_shape [ <NUM_LIT:0> ] - <NUM_LIT:1> <EOL> pos = fh . tell ( ) <EOL> if not self . _bigtiff and pos + len ( tag_bytes ) * numpages > <NUM_LIT:2> ** <NUM_LIT:32> - <NUM_LIT> : <EOL> if self . _imagej : <EOL> warnings . warn ( \"<STR_LIT>\" ) <EOL> return <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def pack ( fmt , * val ) : <EOL> return struct . pack ( byteorder + fmt , * val ) <EOL> for _ in range ( numpages ) : <EOL> pos = fh . tell ( ) <EOL> fh . seek ( self . _ifd_offset ) <EOL> fh . write ( pack ( offset_format , pos ) ) <EOL> fh . seek ( pos ) <EOL> fh . write ( pack ( numtag_format , len ( self . _tags ) ) ) <EOL> tag_offset = fh . tell ( ) <EOL> fh . write ( tag_bytes ) <EOL> self . _ifd_offset = fh . tell ( ) <EOL> fh . write ( pack ( offset_format , <NUM_LIT:0> ) ) <EOL> data_offset += page_data_size <EOL> for tagindex , tag in enumerate ( self . _tags ) : <EOL> if tag [ <NUM_LIT:2> ] : <EOL> pos = fh . tell ( ) <EOL> fh . seek ( tag_offset + tagindex * tag_size + offset_size + <NUM_LIT:4> ) <EOL> fh . write ( pack ( offset_format , pos ) ) <EOL> fh . seek ( pos ) <EOL> if tag [ <NUM_LIT:0> ] == self . _tag_offsets : <EOL> strip_offsets_offset = pos <EOL> fh . write ( tag [ <NUM_LIT:2> ] ) <EOL> pos = fh . tell ( ) <EOL> for tagindex , tag in enumerate ( self . _tags ) : <EOL> if tag [ <NUM_LIT:0> ] == self . _tag_offsets : <EOL> if tag [ <NUM_LIT:2> ] : <EOL> fh . seek ( strip_offsets_offset ) <EOL> strip_offset = data_offset <EOL> for size in self . _data_byte_counts : <EOL> fh . write ( pack ( offset_format , strip_offset ) ) <EOL> strip_offset += size <EOL> else : <EOL> fh . seek ( tag_offset + tagindex * tag_size + <EOL> offset_size + <NUM_LIT:4> ) <EOL> fh . write ( pack ( offset_format , data_offset ) ) <EOL> break <EOL> fh . seek ( pos ) <EOL> self . _tags = None <EOL> self . _data_dtype = None <EOL> self . _data_offset = None <EOL> self . _data_byte_counts = None <EOL> def _write_image_description ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ( not self . _data_shape or self . _data_shape [ <NUM_LIT:0> ] == <NUM_LIT:1> or <EOL> self . _description_offset <= <NUM_LIT:0> ) : <EOL> return <EOL> colormapped = self . _colormap is not None <EOL> if self . _imagej : <EOL> isrgb = self . _shape [ - <NUM_LIT:1> ] in ( <NUM_LIT:3> , <NUM_LIT:4> ) <EOL> description = imagej_description ( <EOL> self . _data_shape , isrgb , colormapped , ** self . _metadata ) <EOL> else : <EOL> description = image_description ( <EOL> self . _data_shape , colormapped , ** self . _metadata ) <EOL> description = description [ : self . _description_len - <NUM_LIT:1> ] <EOL> pos = self . _fh . tell ( ) <EOL> self . _fh . seek ( self . _description_offset ) <EOL> self . _fh . write ( description ) <EOL> self . _fh . seek ( self . _description_len_offset ) <EOL> self . _fh . write ( struct . pack ( self . _byteorder + self . _offset_format , <EOL> len ( description ) + <NUM_LIT:1> ) ) <EOL> self . _fh . seek ( pos ) <EOL> self . _description_offset = <NUM_LIT:0> <EOL> self . _description_len_offset = <NUM_LIT:0> <EOL> self . _description_len = <NUM_LIT:0> <EOL> def _now ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return datetime . datetime . now ( ) <EOL> def close ( self , truncate = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not truncate : <EOL> self . _write_remaining_pages ( ) <EOL> self . _write_image_description ( ) <EOL> self . _fh . close ( ) <EOL> def __enter__ ( self ) : <EOL> return self <EOL> def __exit__ ( self , exc_type , exc_value , traceback ) : <EOL> self . close ( ) <EOL> def imread ( files , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> kwargs_file = { } <EOL> if '<STR_LIT>' in kwargs : <EOL> kwargs_file [ '<STR_LIT>' ] = kwargs [ '<STR_LIT>' ] <EOL> del kwargs [ '<STR_LIT>' ] <EOL> else : <EOL> kwargs_file [ '<STR_LIT>' ] = True <EOL> kwargs_seq = { } <EOL> if '<STR_LIT>' in kwargs : <EOL> kwargs_seq [ '<STR_LIT>' ] = kwargs [ '<STR_LIT>' ] <EOL> del kwargs [ '<STR_LIT>' ] <EOL> if isinstance ( files , basestring ) and any ( i in files for i in '<STR_LIT>' ) : <EOL> files = glob . glob ( files ) <EOL> if not files : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> if len ( files ) == <NUM_LIT:1> : <EOL> files = files [ <NUM_LIT:0> ] <EOL> if isinstance ( files , basestring ) : <EOL> with TiffFile ( files , ** kwargs_file ) as tif : <EOL> return tif . asarray ( ** kwargs ) <EOL> else : <EOL> with TiffSequence ( files , ** kwargs_seq ) as imseq : <EOL> return imseq . asarray ( ** kwargs ) <EOL> class lazyattr ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __slots__ = ( '<STR_LIT>' , ) <EOL> def __init__ ( self , func ) : <EOL> self . func = func <EOL> def __get__ ( self , instance , owner ) : <EOL> if instance is None : <EOL> return self <EOL> value = self . func ( instance ) <EOL> if value is NotImplemented : <EOL> return getattr ( super ( owner , instance ) , self . func . __name__ ) <EOL> setattr ( instance , self . func . __name__ , value ) <EOL> return value <EOL> class TiffFile ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , arg , name = None , offset = None , size = None , <EOL> multifile = True , multifile_close = True , maxpages = None , <EOL> fastij = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _fh = FileHandle ( arg , name = name , offset = offset , size = size ) <EOL> self . offset_size = None <EOL> self . pages = [ ] <EOL> self . _multifile = bool ( multifile ) <EOL> self . _multifile_close = bool ( multifile_close ) <EOL> self . _files = { self . _fh . name : self } <EOL> try : <EOL> self . _fromfile ( maxpages , fastij ) <EOL> except Exception : <EOL> self . _fh . close ( ) <EOL> raise <EOL> @ property <EOL> def filehandle ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _fh <EOL> @ property <EOL> def filename ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _fh . name <EOL> def close ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for tif in self . _files . values ( ) : <EOL> tif . _fh . close ( ) <EOL> self . _files = { } <EOL> def _fromfile ( self , maxpages = None , fastij = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _fh . seek ( <NUM_LIT:0> ) <EOL> try : <EOL> self . byteorder = { b'<STR_LIT>' : '<STR_LIT:<>' , b'<STR_LIT>' : '<STR_LIT:>>' } [ self . _fh . read ( <NUM_LIT:2> ) ] <EOL> except KeyError : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> self . _is_native = self . byteorder == { '<STR_LIT>' : '<STR_LIT:>>' , <EOL> '<STR_LIT>' : '<STR_LIT:<>' } [ sys . byteorder ] <EOL> version = struct . unpack ( self . byteorder + '<STR_LIT:H>' , self . _fh . read ( <NUM_LIT:2> ) ) [ <NUM_LIT:0> ] <EOL> if version == <NUM_LIT> : <EOL> self . offset_size , zero = struct . unpack ( self . byteorder + '<STR_LIT>' , <EOL> self . _fh . read ( <NUM_LIT:4> ) ) <EOL> if zero or self . offset_size != <NUM_LIT:8> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif version == <NUM_LIT> : <EOL> self . offset_size = <NUM_LIT:4> <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> self . pages = [ ] <EOL> while True : <EOL> try : <EOL> page = TiffPage ( self ) <EOL> self . pages . append ( page ) <EOL> except StopIteration : <EOL> break <EOL> if maxpages and len ( self . pages ) > maxpages : <EOL> break <EOL> if fastij and page . is_imagej : <EOL> if page . _patch_imagej ( ) : <EOL> break <EOL> fastij = False <EOL> if not self . pages : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if self . is_micromanager : <EOL> self . micromanager_metadata = read_micromanager_metadata ( self . _fh ) <EOL> if self . is_lsm : <EOL> self . _fix_lsm_strip_offsets ( ) <EOL> self . _fix_lsm_strip_byte_counts ( ) <EOL> def _fix_lsm_strip_offsets ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for series in self . series : <EOL> positions = <NUM_LIT:1> <EOL> for i in <NUM_LIT:0> , <NUM_LIT:1> : <EOL> if series . axes [ i ] in '<STR_LIT>' : <EOL> positions *= series . shape [ i ] <EOL> positions = len ( series . pages ) // positions <EOL> for i , page in enumerate ( series . pages ) : <EOL> if not i % positions : <EOL> wrap = <NUM_LIT:0> <EOL> previous_offset = <NUM_LIT:0> <EOL> strip_offsets = [ ] <EOL> for current_offset in page . strip_offsets : <EOL> if current_offset < previous_offset : <EOL> wrap += <NUM_LIT:2> ** <NUM_LIT:32> <EOL> strip_offsets . append ( current_offset + wrap ) <EOL> previous_offset = current_offset <EOL> page . strip_offsets = tuple ( strip_offsets ) <EOL> def _fix_lsm_strip_byte_counts ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . pages : <EOL> return <EOL> strips = { } <EOL> for page in self . pages : <EOL> assert len ( page . strip_offsets ) == len ( page . strip_byte_counts ) <EOL> for offset , bytecount in zip ( page . strip_offsets , <EOL> page . strip_byte_counts ) : <EOL> strips [ offset ] = bytecount <EOL> offsets = sorted ( strips . keys ( ) ) <EOL> offsets . append ( min ( offsets [ - <NUM_LIT:1> ] + strips [ offsets [ - <NUM_LIT:1> ] ] , self . _fh . size ) ) <EOL> for i , offset in enumerate ( offsets [ : - <NUM_LIT:1> ] ) : <EOL> strips [ offset ] = min ( strips [ offset ] , offsets [ i + <NUM_LIT:1> ] - offset ) <EOL> for page in self . pages : <EOL> if page . compression : <EOL> page . strip_byte_counts = tuple ( <EOL> strips [ offset ] for offset in page . strip_offsets ) <EOL> def asarray ( self , key = None , series = None , memmap = False , tempdir = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if key is None and series is None : <EOL> series = <NUM_LIT:0> <EOL> if series is not None : <EOL> try : <EOL> series = self . series [ series ] <EOL> except ( KeyError , TypeError ) : <EOL> pass <EOL> pages = series . pages <EOL> else : <EOL> pages = self . pages <EOL> if key is None : <EOL> pass <EOL> elif isinstance ( key , int ) : <EOL> pages = [ pages [ key ] ] <EOL> elif isinstance ( key , slice ) : <EOL> pages = pages [ key ] <EOL> elif isinstance ( key , collections . Iterable ) : <EOL> pages = [ pages [ k ] for k in key ] <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> if not len ( pages ) : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if self . is_nih : <EOL> if pages [ <NUM_LIT:0> ] . is_indexed : <EOL> result = stack_pages ( pages , colormapped = False , squeeze = False ) <EOL> result = apply_colormap ( result , pages [ <NUM_LIT:0> ] . color_map ) <EOL> else : <EOL> result = stack_pages ( pages , memmap = memmap , tempdir = tempdir , <EOL> colormapped = False , squeeze = False ) <EOL> elif len ( pages ) == <NUM_LIT:1> : <EOL> result = pages [ <NUM_LIT:0> ] . asarray ( memmap = memmap ) <EOL> elif self . is_ome : <EOL> assert not self . is_indexed , \"<STR_LIT>\" <EOL> if any ( p is None for p in pages ) : <EOL> firstpage = next ( p for p in pages if p ) <EOL> nopage = numpy . zeros_like ( <EOL> firstpage . asarray ( memmap = False ) ) <EOL> if memmap : <EOL> with tempfile . NamedTemporaryFile ( ) as fh : <EOL> result = numpy . memmap ( fh , series . dtype , shape = series . shape ) <EOL> result = result . reshape ( - <NUM_LIT:1> ) <EOL> else : <EOL> result = numpy . empty ( series . shape , series . dtype ) . reshape ( - <NUM_LIT:1> ) <EOL> index = <NUM_LIT:0> <EOL> class KeepOpen : <EOL> def __init__ ( self , parent , close ) : <EOL> self . master = parent <EOL> self . parent = parent <EOL> self . _close = close <EOL> def open ( self , page ) : <EOL> if self . _close and page and page . parent != self . parent : <EOL> if self . parent != self . master : <EOL> self . parent . filehandle . close ( ) <EOL> self . parent = page . parent <EOL> self . parent . filehandle . open ( ) <EOL> def close ( self ) : <EOL> if self . _close and self . parent != self . master : <EOL> self . parent . filehandle . close ( ) <EOL> keep = KeepOpen ( self , self . _multifile_close ) <EOL> for page in pages : <EOL> keep . open ( page ) <EOL> if page : <EOL> a = page . asarray ( memmap = False , colormapped = False , <EOL> reopen = False ) <EOL> else : <EOL> a = nopage <EOL> try : <EOL> result [ index : index + a . size ] = a . reshape ( - <NUM_LIT:1> ) <EOL> except ValueError as e : <EOL> warnings . warn ( \"<STR_LIT>\" % e ) <EOL> break <EOL> index += a . size <EOL> keep . close ( ) <EOL> elif key is None and series and series . offset : <EOL> result = self . filehandle . memmap_array ( series . dtype , series . shape , <EOL> series . offset ) <EOL> else : <EOL> result = stack_pages ( pages , memmap = memmap , tempdir = tempdir ) <EOL> if key is None : <EOL> try : <EOL> result . shape = series . shape <EOL> except ValueError : <EOL> try : <EOL> warnings . warn ( \"<STR_LIT>\" % ( <EOL> result . shape , series . shape ) ) <EOL> result . shape = ( - <NUM_LIT:1> , ) + series . shape <EOL> except ValueError : <EOL> result . shape = ( - <NUM_LIT:1> , ) + pages [ <NUM_LIT:0> ] . shape <EOL> elif len ( pages ) == <NUM_LIT:1> : <EOL> result . shape = pages [ <NUM_LIT:0> ] . shape <EOL> else : <EOL> result . shape = ( - <NUM_LIT:1> , ) + pages [ <NUM_LIT:0> ] . shape <EOL> return result <EOL> @ lazyattr <EOL> def series ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . pages : <EOL> return [ ] <EOL> series = [ ] <EOL> if self . is_ome : <EOL> series = self . _ome_series ( ) <EOL> elif self . is_fluoview : <EOL> series = self . _fluoview_series ( ) <EOL> elif self . is_lsm : <EOL> series = self . _lsm_series ( ) <EOL> elif self . is_imagej : <EOL> series = self . _imagej_series ( ) <EOL> elif self . is_nih : <EOL> series = self . _nih_series ( ) <EOL> if not series : <EOL> shapes = [ ] <EOL> pages = { } <EOL> index = <NUM_LIT:0> <EOL> for page in self . pages : <EOL> if not page . shape : <EOL> continue <EOL> if page . is_shaped : <EOL> index += <NUM_LIT:1> <EOL> shape = page . shape + ( index , page . axes , <EOL> page . compression in TIFF_DECOMPESSORS ) <EOL> if shape in pages : <EOL> pages [ shape ] . append ( page ) <EOL> else : <EOL> shapes . append ( shape ) <EOL> pages [ shape ] = [ page ] <EOL> series = [ ] <EOL> for s in shapes : <EOL> shape = ( ( len ( pages [ s ] ) , ) + s [ : - <NUM_LIT:3> ] if len ( pages [ s ] ) > <NUM_LIT:1> <EOL> else s [ : - <NUM_LIT:3> ] ) <EOL> axes = ( ( '<STR_LIT:I>' + s [ - <NUM_LIT:2> ] ) if len ( pages [ s ] ) > <NUM_LIT:1> else s [ - <NUM_LIT:2> ] ) <EOL> page0 = pages [ s ] [ <NUM_LIT:0> ] <EOL> if page0 . is_shaped : <EOL> metadata = image_description_dict ( page0 . is_shaped ) <EOL> reshape = metadata [ '<STR_LIT>' ] <EOL> if '<STR_LIT>' in metadata : <EOL> reaxes = metadata [ '<STR_LIT>' ] <EOL> if len ( reaxes ) == len ( reshape ) : <EOL> axes = reaxes <EOL> shape = reshape <EOL> else : <EOL> warnings . warn ( \"<STR_LIT>\" ) <EOL> try : <EOL> axes = reshape_axes ( axes , shape , reshape ) <EOL> shape = reshape <EOL> except ValueError as e : <EOL> warnings . warn ( e . message ) <EOL> series . append ( <EOL> TiffPageSeries ( pages [ s ] , shape , page0 . dtype , axes ) ) <EOL> series = [ s for s in series if sum ( s . shape ) > <NUM_LIT:0> ] <EOL> return series <EOL> def _fluoview_series ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> page0 = self . pages [ <NUM_LIT:0> ] <EOL> dims = { <EOL> b'<STR_LIT:X>' : '<STR_LIT:X>' , b'<STR_LIT:Y>' : '<STR_LIT:Y>' , b'<STR_LIT>' : '<STR_LIT>' , b'<STR_LIT:T>' : '<STR_LIT:T>' , <EOL> b'<STR_LIT>' : '<STR_LIT:C>' , b'<STR_LIT>' : '<STR_LIT:T>' , b'<STR_LIT>' : '<STR_LIT:R>' , <EOL> b'<STR_LIT>' : '<STR_LIT>' , b'<STR_LIT>' : '<STR_LIT:L>' } <EOL> mmhd = list ( reversed ( page0 . mm_header . dimensions ) ) <EOL> axes = '<STR_LIT>' . join ( dims . get ( i [ <NUM_LIT:0> ] . strip ( ) . upper ( ) , '<STR_LIT>' ) <EOL> for i in mmhd if i [ <NUM_LIT:1> ] > <NUM_LIT:1> ) <EOL> shape = tuple ( int ( i [ <NUM_LIT:1> ] ) for i in mmhd if i [ <NUM_LIT:1> ] > <NUM_LIT:1> ) <EOL> return [ TiffPageSeries ( self . pages , shape , page0 . dtype , axes ) ] <EOL> def _lsm_series ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> page0 = self . pages [ <NUM_LIT:0> ] <EOL> lsmi = page0 . cz_lsm_info <EOL> axes = CZ_SCAN_TYPES [ lsmi . scan_type ] <EOL> if page0 . is_rgb : <EOL> axes = axes . replace ( '<STR_LIT:C>' , '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if hasattr ( lsmi , '<STR_LIT>' ) and lsmi . dimension_p > <NUM_LIT:1> : <EOL> axes += '<STR_LIT:P>' <EOL> if hasattr ( lsmi , '<STR_LIT>' ) and lsmi . dimension_m > <NUM_LIT:1> : <EOL> axes += '<STR_LIT:M>' <EOL> axes = axes [ : : - <NUM_LIT:1> ] <EOL> shape = tuple ( getattr ( lsmi , CZ_DIMENSIONS [ i ] ) for i in axes ) <EOL> pages = [ p for p in self . pages if not p . is_reduced ] <EOL> dtype = pages [ <NUM_LIT:0> ] . dtype <EOL> series = [ TiffPageSeries ( pages , shape , dtype , axes ) ] <EOL> if len ( pages ) != len ( self . pages ) : <EOL> pages = [ p for p in self . pages if p . is_reduced ] <EOL> cp = <NUM_LIT:1> <EOL> i = <NUM_LIT:0> <EOL> while cp < len ( pages ) and i < len ( shape ) - <NUM_LIT:2> : <EOL> cp *= shape [ i ] <EOL> i += <NUM_LIT:1> <EOL> shape = shape [ : i ] + pages [ <NUM_LIT:0> ] . shape <EOL> axes = axes [ : i ] + '<STR_LIT>' <EOL> dtype = pages [ <NUM_LIT:0> ] . dtype <EOL> series . append ( TiffPageSeries ( pages , shape , dtype , axes ) ) <EOL> return series <EOL> def _imagej_series ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> shape = [ ] <EOL> axes = [ ] <EOL> page0 = self . pages [ <NUM_LIT:0> ] <EOL> ij = page0 . imagej_tags <EOL> if '<STR_LIT>' in ij : <EOL>", "answer": "shape . append ( ij [ '<STR_LIT>' ] )"}, {"prompt": "<s> from __future__ import print_function <EOL> import gzip <EOL> import os <EOL> import posixpath <EOL> import re <EOL> import shelve <EOL> import sys <EOL> try : <EOL> from StringIO import StringIO <EOL> import cPickle as pickle <EOL> import urllib2 as urllib <EOL> from urllib2 import HTTPError , URLError <EOL> except ImportError : <EOL> from io import StringIO <EOL> import pickle <EOL> import urllib . request <EOL> import urllib . error <EOL> import urllib . parse <EOL> from urllib . error import HTTPError , URLError <EOL> def _get_data ( url ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if url . startswith ( '<STR_LIT>' ) : <EOL> try : <EOL> resp = urllib . urlopen ( url ) <EOL> encoding = resp . headers . dict . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> except AttributeError : <EOL> resp = urllib . request . urlopen ( url ) <EOL> encoding = resp . headers . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> data = resp . read ( ) <EOL> if encoding == '<STR_LIT>' : <EOL> pass <EOL> elif encoding == '<STR_LIT>' : <EOL> data = StringIO ( data ) <EOL> data = gzip . GzipFile ( fileobj = data ) . read ( ) <EOL> else : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> else : <EOL> with open ( url , '<STR_LIT:r>' ) as fid : <EOL> data = fid . read ( ) <EOL> return data <EOL> def get_data ( url , gallery_dir ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if sys . version_info [ <NUM_LIT:0> ] == <NUM_LIT:2> and isinstance ( url , unicode ) : <EOL> url = url . encode ( '<STR_LIT:utf-8>' ) <EOL> cached_file = os . path . join ( gallery_dir , '<STR_LIT>' ) <EOL> search_index = shelve . open ( cached_file ) <EOL> if url in search_index : <EOL> data = search_index [ url ] <EOL> else : <EOL> data = _get_data ( url ) <EOL> search_index [ url ] = data <EOL> search_index . close ( ) <EOL> return data <EOL> def _select_block ( str_in , start_tag , end_tag ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> start_pos = str_in . find ( start_tag ) <EOL> if start_pos < <NUM_LIT:0> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> depth = <NUM_LIT:0> <EOL> for pos in range ( start_pos , len ( str_in ) ) : <EOL> if str_in [ pos ] == start_tag : <EOL> depth += <NUM_LIT:1> <EOL> elif str_in [ pos ] == end_tag : <EOL> depth -= <NUM_LIT:1> <EOL>", "answer": "if depth == <NUM_LIT:0> :"}, {"prompt": "<s> import os <EOL> import subprocess <EOL> import six <EOL> import testtools <EOL> class RuntimeTests ( testtools . TestCase ) : <EOL> def _test_runtime ( self , cmdlist ) : <EOL> process = subprocess . Popen ( <EOL> cmdlist , <EOL> stdin = subprocess . PIPE , <EOL> stdout = subprocess . PIPE , <EOL> stderr = subprocess . STDOUT , <EOL> close_fds = True <EOL> ) <EOL> stdout , stderr = process . communicate ( ) <EOL> retcode = process . poll ( ) <EOL> return ( retcode , stdout . decode ( '<STR_LIT:utf-8>' ) ) <EOL>", "answer": "def _test_example ( self , cmdlist , targets ) :"}, {"prompt": "<s> from invoke . tasks import task <EOL> @ task ( aliases = ( '<STR_LIT:bar>' , '<STR_LIT>' ) ) <EOL> def foo ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> @ task <EOL> def foo2 ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> @ task <EOL> def foo3 ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> @ task ( default = True ) <EOL> def biz ( ) : <EOL> pass <EOL> @ task ( help = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } ) <EOL> def punch ( who , why ) : <EOL>", "answer": "pass"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from dateutil . tz import tzutc <EOL> from dateutil import parser <EOL> from security_monkey . watchers . iam . iam_ssl import IAMSSL <EOL> from security_monkey . auditor import Auditor <EOL> HEARTBLEED_DATE = '<STR_LIT>' <EOL> class IAMSSLAuditor ( Auditor ) : <EOL> index = IAMSSL . index <EOL> i_am_singular = IAMSSL . i_am_singular <EOL> i_am_plural = IAMSSL . i_am_plural <EOL> def __init__ ( self , accounts = None , debug = False ) : <EOL> super ( IAMSSLAuditor , self ) . __init__ ( accounts = accounts , debug = debug ) <EOL> def check_issuer ( self , cert_item ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> issuer = cert_item . config . get ( '<STR_LIT>' , None ) <EOL> if issuer and '<STR_LIT>' in issuer : <EOL> self . add_issue ( <NUM_LIT:10> , '<STR_LIT>' , cert_item , notes = issuer ) <EOL> def check_cert_size_lt_1024 ( self , cert_item ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> size = cert_item . config . get ( '<STR_LIT:size>' , None ) <EOL> if size and size < <NUM_LIT> : <EOL> notes = '<STR_LIT>' . format ( size ) <EOL> self . add_issue ( <NUM_LIT:10> , '<STR_LIT>' , cert_item , notes = notes ) <EOL> def check_cert_size_lt_2048 ( self , cert_item ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> size = cert_item . config . get ( '<STR_LIT:size>' , None ) <EOL> if size and <NUM_LIT> <= size < <NUM_LIT> : <EOL>", "answer": "notes = '<STR_LIT>' . format ( size )"}, {"prompt": "<s> import tempfile <EOL> import stripe <EOL> from stripe . test . helper import StripeResourceTest <EOL> class FileUploadTest ( StripeResourceTest ) : <EOL> def test_create_file_upload ( self ) : <EOL> test_file = tempfile . TemporaryFile ( ) <EOL> stripe . FileUpload . create ( <EOL> purpose = '<STR_LIT>' , <EOL>", "answer": "file = test_file"}, {"prompt": "<s> from bento . distutils . monkey_patch import setup <EOL>", "answer": "setup ( ) "}, {"prompt": "<s> from django . utils . encoding import smart_str <EOL> class Menu ( object ) : <EOL> namespace = None <EOL> def __init__ ( self ) : <EOL> if not self . namespace : <EOL> self . namespace = self . __class__ . __name__ <EOL> def get_nodes ( self , request ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "raise NotImplementedError"}, {"prompt": "<s> import sys <EOL> import logging <EOL> import gettor . smtp <EOL> def main ( ) : <EOL> logging_level = '<STR_LIT>' <EOL> logging_file = '<STR_LIT>' <EOL> logging_format = '<STR_LIT>' <EOL>", "answer": "date_format = \"<STR_LIT>\""}, {"prompt": "<s> from docutils import nodes <EOL> from docutils . parsers . rst import Directive <EOL>", "answer": "import os"}, {"prompt": "<s> from ehp import * <EOL> html = Html ( ) <EOL> dom = html . feed ( '''<STR_LIT>''' ) <EOL> for root , ind in dom . find_with_root ( '<STR_LIT:p>' ) : <EOL>", "answer": "root . remove ( ind )"}, {"prompt": "<s> import logging <EOL> from google . appengine . ext import ndb <EOL> class Comment ( ndb . Model ) : <EOL> created = ndb . DateTimeProperty ( auto_now_add = True ) <EOL> text = ndb . StringProperty ( ) <EOL> author = ndb . StringProperty ( ) <EOL> def comment_to_json ( comment ) : <EOL> return { <EOL>", "answer": "'<STR_LIT:key>' : comment . key . urlsafe ( ) ,"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import migrations , models <EOL> def set_default_date ( apps , schema_editor ) : <EOL> obj = apps . get_model ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for o in obj . objects . all ( ) : <EOL> o . date = o . created <EOL> o . save ( ) <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL>", "answer": "migrations . AddField ("}, {"prompt": "<s> import pytest <EOL> from mock import Mock , patch , call <EOL> from . fixtures import engine_mock , config_mock , guards_engine_mock <EOL> @ pytest . mark . usefixtures ( '<STR_LIT>' ) <EOL> class TestHelperFunctions ( object ) : <EOL> @ patch ( '<STR_LIT>' ) <EOL> def test_get_existing_model_not_found ( self , mock_eng ) : <EOL> from ramses import models <EOL> mock_eng . get_document_cls . side_effect = ValueError <EOL> model_cls = models . get_existing_model ( '<STR_LIT>' ) <EOL> assert model_cls is None <EOL> mock_eng . get_document_cls . assert_called_once_with ( '<STR_LIT>' ) <EOL> @ patch ( '<STR_LIT>' ) <EOL> def test_get_existing_model_found ( self , mock_eng ) : <EOL> from ramses import models <EOL> mock_eng . get_document_cls . return_value = <NUM_LIT:1> <EOL> model_cls = models . get_existing_model ( '<STR_LIT>' ) <EOL> assert model_cls == <NUM_LIT:1> <EOL> mock_eng . get_document_cls . assert_called_once_with ( '<STR_LIT>' ) <EOL> @ patch ( '<STR_LIT>' ) <EOL> @ patch ( '<STR_LIT>' ) <EOL> def test_prepare_relationship_model_exists ( self , mock_get , mock_set ) : <EOL> from ramses import models <EOL> config = Mock ( ) <EOL> models . prepare_relationship ( <EOL> config , '<STR_LIT>' , '<STR_LIT>' ) <EOL>", "answer": "mock_get . assert_called_once_with ( '<STR_LIT>' )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import posixpath <EOL> import re <EOL> import six <EOL> from six . moves . urllib . parse import ( ParseResult , urlunparse , urldefrag , <EOL> urlparse , parse_qsl , urlencode , <EOL> quote , unquote ) <EOL> if not six . PY2 : <EOL> from urllib . parse import unquote_to_bytes <EOL> from w3lib . url import * <EOL> from w3lib . url import _safe_chars <EOL> from scrapy . utils . python import to_bytes , to_native_str , to_unicode <EOL> def url_is_from_any_domain ( url , domains ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> host = parse_url ( url ) . netloc . lower ( ) <EOL> if not host : <EOL> return False <EOL> domains = [ d . lower ( ) for d in domains ] <EOL> return any ( ( host == d ) or ( host . endswith ( '<STR_LIT>' % d ) ) for d in domains ) <EOL> def url_is_from_spider ( url , spider ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return url_is_from_any_domain ( url , <EOL> [ spider . name ] + list ( getattr ( spider , '<STR_LIT>' , [ ] ) ) ) <EOL> def url_has_any_extension ( url , extensions ) : <EOL> return posixpath . splitext ( parse_url ( url ) . path ) [ <NUM_LIT:1> ] . lower ( ) in extensions <EOL> def _safe_ParseResult ( parts , encoding = '<STR_LIT:utf8>' , path_encoding = '<STR_LIT:utf8>' ) : <EOL> return ( <EOL> to_native_str ( parts . scheme ) , <EOL> to_native_str ( parts . netloc . encode ( '<STR_LIT>' ) ) , <EOL> quote ( to_bytes ( parts . path , path_encoding ) , _safe_chars ) , <EOL> quote ( to_bytes ( parts . params , path_encoding ) , _safe_chars ) , <EOL> quote ( to_bytes ( parts . query , encoding ) , _safe_chars ) , <EOL> quote ( to_bytes ( parts . fragment , encoding ) , _safe_chars ) <EOL> ) <EOL> def canonicalize_url ( url , keep_blank_values = True , keep_fragments = False , <EOL> encoding = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> scheme , netloc , path , params , query , fragment = _safe_ParseResult ( <EOL> parse_url ( url ) , encoding = encoding ) <EOL> except UnicodeEncodeError as e : <EOL>", "answer": "scheme , netloc , path , params , query , fragment = _safe_ParseResult ("}, {"prompt": "<s> from __future__ import absolute_import <EOL> from salt . modules import win_dism as dism <EOL> from salttesting import TestCase <EOL> from salttesting . helpers import ensure_in_syspath <EOL> from salttesting . mock import ( <EOL> MagicMock , <EOL> patch <EOL>", "answer": ")"}, {"prompt": "<s> import uuid <EOL> from openstack . network . v2 import address_scope as _address_scope <EOL> from openstack . tests . functional import base <EOL> class TestAddressScope ( base . BaseFunctionalTest ) : <EOL> ADDRESS_SCOPE_ID = None <EOL> ADDRESS_SCOPE_NAME = uuid . uuid4 ( ) . hex <EOL> ADDRESS_SCOPE_NAME_UPDATED = uuid . uuid4 ( ) . hex <EOL> IS_SHARED = False <EOL> IP_VERSION = <NUM_LIT:4> <EOL> @ classmethod <EOL> def setUpClass ( cls ) : <EOL> super ( TestAddressScope , cls ) . setUpClass ( ) <EOL> address_scope = cls . conn . network . create_address_scope ( <EOL> ip_version = cls . IP_VERSION , <EOL> name = cls . ADDRESS_SCOPE_NAME , <EOL> shared = cls . IS_SHARED , <EOL> ) <EOL> assert isinstance ( address_scope , _address_scope . AddressScope ) <EOL> cls . assertIs ( cls . ADDRESS_SCOPE_NAME , address_scope . name ) <EOL> cls . ADDRESS_SCOPE_ID = address_scope . id <EOL> @ classmethod <EOL> def tearDownClass ( cls ) : <EOL> sot = cls . conn . network . delete_address_scope ( cls . ADDRESS_SCOPE_ID ) <EOL> cls . assertIs ( None , sot ) <EOL> def test_find ( self ) : <EOL> sot = self . conn . network . find_address_scope ( self . ADDRESS_SCOPE_NAME ) <EOL> self . assertEqual ( self . ADDRESS_SCOPE_ID , sot . id ) <EOL> def test_get ( self ) : <EOL> sot = self . conn . network . get_address_scope ( self . ADDRESS_SCOPE_ID ) <EOL> self . assertEqual ( self . ADDRESS_SCOPE_NAME , sot . name ) <EOL> self . assertEqual ( self . IS_SHARED , sot . is_shared ) <EOL> self . assertEqual ( self . IP_VERSION , sot . ip_version ) <EOL> def test_list ( self ) : <EOL> names = [ o . name for o in self . conn . network . address_scopes ( ) ] <EOL> self . assertIn ( self . ADDRESS_SCOPE_NAME , names ) <EOL> def test_update ( self ) : <EOL> sot = self . conn . network . update_address_scope ( <EOL> self . ADDRESS_SCOPE_ID , <EOL> name = self . ADDRESS_SCOPE_NAME_UPDATED ) <EOL>", "answer": "self . assertEqual ( self . ADDRESS_SCOPE_NAME_UPDATED , sot . name ) "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import unittest <EOL> import tornado . options <EOL> import tornado . testing <EOL> testlist = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "]"}, {"prompt": "<s> import autograd . numpy as np <EOL> import autograd . numpy . random as npr <EOL> from autograd . util import check_grads <EOL> from autograd import grad <EOL> npr . seed ( <NUM_LIT:0> ) <EOL> def test_getter ( ) : <EOL> def fun ( input_dict ) : <EOL> A = np . sum ( input_dict [ '<STR_LIT>' ] ) <EOL> B = np . sum ( input_dict [ '<STR_LIT>' ] ) <EOL> C = np . sum ( input_dict [ '<STR_LIT>' ] ) <EOL> return A + B + C <EOL> d_fun = grad ( fun ) <EOL> input_dict = { '<STR_LIT>' : npr . randn ( <NUM_LIT:5> , <NUM_LIT:6> ) , <EOL> '<STR_LIT>' : npr . randn ( <NUM_LIT:4> , <NUM_LIT:3> ) , <EOL> '<STR_LIT>' : npr . randn ( <NUM_LIT:2> , <NUM_LIT:4> ) } <EOL> result = d_fun ( input_dict ) <EOL> assert np . allclose ( result [ '<STR_LIT>' ] , np . ones ( ( <NUM_LIT:5> , <NUM_LIT:6> ) ) ) <EOL> assert np . allclose ( result [ '<STR_LIT>' ] , <NUM_LIT:2> * np . ones ( ( <NUM_LIT:4> , <NUM_LIT:3> ) ) ) <EOL> assert np . allclose ( result [ '<STR_LIT>' ] , np . zeros ( ( <NUM_LIT:2> , <NUM_LIT:4> ) ) ) <EOL>", "answer": "def test_grads ( ) :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "<s> class NuGetPackage ( GitHubTarballPackage ) : <EOL> def __init__ ( self ) : <EOL> GitHubTarballPackage . __init__ ( self , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __version__ = \"<STR_LIT>\" <EOL> import os <EOL> import os . path <EOL> from . import types as S <EOL> from . MplStyle import MplStyle <EOL> import matplotlib as MPL <EOL> __all__ = [ '<STR_LIT>' ] <EOL> MPLSTYLE_CLASS = MplStyle <EOL> MPLSTYLE_EXTENSION = \"<STR_LIT>\" <EOL> MPLSTYLE_PREFIX = \"<STR_LIT>\" <EOL> MPLSTYLE_CUSTOM_FUNC = \"<STR_LIT>\" <EOL> MPLSTYLE_HEADER = \"\"\"<STR_LIT>\"\"\" <EOL> class MplStyleManager ( S . StyleManager ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> S . StyleManager . __init__ ( self , MPLSTYLE_CLASS , <EOL> MPLSTYLE_EXTENSION , <EOL> MPLSTYLE_PREFIX ) <EOL> def _loadFromFile ( self , fname ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> createData = lambda : { <EOL> '<STR_LIT>' : MplStyle , <EOL> } <EOL> data = createData ( ) <EOL> try : <EOL> execfile ( fname , data ) <EOL> except Exception , e : <EOL> msg = \"<STR_LIT>\" % fname <EOL> raise S . util . mergeExceptions ( e , msg ) <EOL> if '<STR_LIT>' in data : <EOL> style = data [ '<STR_LIT>' ] <EOL> else : <EOL> msg = \"<STR_LIT>\" \"<STR_LIT>\" \"<STR_LIT>\" % ( fname , ) <EOL> raise Exception ( msg ) <EOL> if not isinstance ( style , MplStyle ) : <EOL>", "answer": "msg = \"<STR_LIT>\" \"<STR_LIT>\" \"<STR_LIT>\" % ( fname , style . __class__ . __name__ )"}, {"prompt": "<s> import olefile <EOL> import StringIO <EOL> from laikaboss . objectmodel import ModuleObject , ExternalVars , QuitScanException , GlobalScanTimeoutError , GlobalModuleTimeoutError <EOL> from laikaboss . util import log_module <EOL> from laikaboss . si_module import SI_MODULE <EOL> class EXPLODE_OLE ( SI_MODULE ) : <EOL> def __init__ ( self , ) : <EOL> self . module_name = \"<STR_LIT>\" <EOL> self . global_search = \"<STR_LIT>\" <EOL> def _run ( self , scanObject , result , depth , args ) : <EOL> moduleResult = [ ] <EOL> minFileSize = <NUM_LIT:0> <EOL> useUnvalidatedFilenames = <NUM_LIT:0> <EOL> if '<STR_LIT>' in args : <EOL> try : <EOL> minFileSize = int ( args [ '<STR_LIT>' ] ) <EOL> except ( QuitScanException , GlobalScanTimeoutError , GlobalModuleTimeoutError ) : <EOL> raise <EOL> except : <EOL> pass <EOL> if '<STR_LIT>' in args : <EOL> try : <EOL> minFileSize = int ( args [ '<STR_LIT>' ] ) <EOL> except ( QuitScanException , GlobalScanTimeoutError , GlobalModuleTimeoutError ) : <EOL> raise <EOL> except : <EOL> pass <EOL> file = StringIO . StringIO ( ) <EOL> file . write ( scanObject . buffer ) <EOL> file . flush ( ) <EOL>", "answer": "file . seek ( <NUM_LIT:0> )"}, {"prompt": "<s> import empty <EOL> from opcodes import * <EOL> from memory_map import mem_map <EOL> from branching_flags import * <EOL> bench_dir = \"<STR_LIT>\" <EOL> bench_file = \"<STR_LIT>\" <EOL> bench_name = bench_dir + \"<STR_LIT:/>\" + bench_file <EOL> SIMD_bench_name = bench_dir + \"<STR_LIT:/>\" + \"<STR_LIT>\" + bench_file <EOL>", "answer": "empty = empty . assemble_all ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> from nose . tools import * <EOL> from tests . base import OsfTestCase <EOL> from tests . factories import NodeFactory <EOL> from website . app import init_app <EOL> from website . project . model import Node <EOL> from website . addons . wiki . model import AddonWikiNodeSettings <EOL> from website . addons . osffiles . model import AddonFilesNodeSettings <EOL> logger = logging . getLogger ( __name__ ) <EOL> ADDONS = { AddonFilesNodeSettings , AddonWikiNodeSettings } <EOL> def main ( ) : <EOL> from framework . mongo import db <EOL> init_app ( routes = False ) <EOL> migrate_nodes ( db ) <EOL> def migrate_addons ( node ) : <EOL> ret = False <EOL> if not node . has_addon ( '<STR_LIT>' ) : <EOL> node . add_addon ( '<STR_LIT>' , auth = node . creator , log = False ) <EOL> ret = True <EOL> if not node . has_addon ( '<STR_LIT>' ) : <EOL> node . add_addon ( '<STR_LIT>' , auth = node . creator , log = False ) <EOL> ret = True <EOL> return ret <EOL> def migrate_nodes ( db ) : <EOL> for addon_class in ADDONS : <EOL> print ( '<STR_LIT>' + addon_class . __name__ ) <EOL> for node in get_affected_nodes ( db , addon_class ) : <EOL> print ( '<STR_LIT>' + node . _id ) <EOL> migrate_addons ( node ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' ) <EOL> def get_affected_nodes ( db , addon_class ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> query = db [ '<STR_LIT>' ] . find ( { <EOL> '<STR_LIT:.>' . join ( <EOL> ( '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> addon_class . __name__ . lower ( ) , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT:0>' <EOL> ) <EOL> ) : { '<STR_LIT>' : False } <EOL> } ) <EOL> return ( Node . load ( node [ '<STR_LIT>' ] ) for node in query ) <EOL> class TestMigratingAddons ( OsfTestCase ) : <EOL> def test_migrate_wiki ( self ) : <EOL> node = NodeFactory ( ) <EOL> wiki_addon = node . get_addon ( '<STR_LIT>' ) <EOL> AddonWikiNodeSettings . remove_one ( wiki_addon ) <EOL> assert_false ( node . has_addon ( '<STR_LIT>' ) ) <EOL> was_migrated = migrate_addons ( node ) <EOL> assert_true ( was_migrated ) <EOL> assert_true ( node . has_addon ( '<STR_LIT>' ) ) <EOL> def test_migrate_osffiles ( self ) : <EOL> node = NodeFactory ( ) <EOL>", "answer": "osf_addon = node . get_addon ( '<STR_LIT>' )"}, {"prompt": "<s> from collections import defaultdict <EOL> from Queue import Queue , Empty <EOL> from threading import Thread <EOL> def import_string ( import_name , silent = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> import_name = str ( import_name ) <EOL> try : <EOL> if '<STR_LIT:.>' in import_name : <EOL> module , obj = import_name . rsplit ( '<STR_LIT:.>' , <NUM_LIT:1> ) <EOL> return getattr ( __import__ ( module , None , None , [ obj ] ) , obj ) <EOL> else : <EOL> return __import__ ( import_name ) <EOL> except ( ImportError , AttributeError ) : <EOL> if not silent : <EOL> raise <EOL> def apply_defaults ( host , defaults ) : <EOL> for key , value in defaults . iteritems ( ) : <EOL> if key not in host : <EOL> host [ key ] = value <EOL> return host <EOL> def peek ( value ) : <EOL> generator = iter ( value ) <EOL> prev = generator . next ( ) <EOL> for item in generator : <EOL> yield prev , item <EOL> prev = item <EOL> yield prev , None <EOL> class Worker ( Thread ) : <EOL>", "answer": "def __init__ ( self , queue ) :"}, {"prompt": "<s> from __future__ import print_function <EOL> import argparse <EOL> import signal <EOL> signal . signal ( signal . SIGPIPE , signal . SIG_DFL ) <EOL> import Pyro4 <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> parser = argparse . ArgumentParser ( ) <EOL> parser . add_argument ( \"<STR_LIT>\" , type = str , help = \"<STR_LIT>\" ) <EOL> options = parser . parse_args ( ) <EOL> uri_file = options . uri_file <EOL> try : <EOL> uf = open ( uri_file ) <EOL> serverURI = Pyro4 . URI ( uf . readline ( ) ) <EOL> uf . close ( ) <EOL> except : <EOL> print ( \"<STR_LIT>\" % uri_file ) <EOL> raise <EOL> proxyServer = Pyro4 . Proxy ( serverURI ) <EOL> numStages = proxyServer . getTotalNumberOfStages ( ) <EOL> processedStages = proxyServer . getNumberProcessedStages ( ) <EOL> print ( \"<STR_LIT>\" , numStages ) <EOL> print ( \"<STR_LIT>\" , processedStages , \"<STR_LIT:\\n>\" ) <EOL> runningClients = proxyServer . getNumberOfRunningClients ( ) <EOL> waitingClients = proxyServer . getNumberOfQueuedClients ( ) <EOL>", "answer": "print ( \"<STR_LIT>\" , runningClients )"}, {"prompt": "<s> class Error ( Exception ) : <EOL> '''<STR_LIT>''' <EOL> pass <EOL> class DecodingError ( Error ) : <EOL> '''<STR_LIT>''' <EOL>", "answer": "pass "}, {"prompt": "<s> from supybot . test import * <EOL> class FormatTestCase ( PluginTestCase ) : <EOL> plugins = ( '<STR_LIT>' , ) <EOL> def testBold ( self ) : <EOL> self . assertResponse ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def testUnderline ( self ) : <EOL> self . assertResponse ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def testReverse ( self ) : <EOL> self . assertResponse ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def testFormat ( self ) : <EOL> self . assertResponse ( '<STR_LIT>' , '<STR_LIT:foo>' ) <EOL> self . assertResponse ( '<STR_LIT>' , '<STR_LIT>' ) <EOL>", "answer": "self . assertResponse ( '<STR_LIT>' , '<STR_LIT>' )"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL>", "answer": "import multiple_definition_variable_instance"}, {"prompt": "<s> from __future__ import ( unicode_literals , division , absolute_import , print_function ) <EOL> import os <EOL> from inspect import formatargspec <EOL> from sphinx . ext import autodoc <EOL> from powerline . lint . inspect import getconfigargspec <EOL> from powerline . segments import Segment <EOL> from powerline . lib . unicode import unicode <EOL> def formatvalue ( val ) : <EOL> if type ( val ) is str : <EOL> return '<STR_LIT>' + unicode ( val , '<STR_LIT:utf-8>' ) . replace ( '<STR_LIT:\">' , '<STR_LIT>' ) . replace ( '<STR_LIT:\\\\>' , '<STR_LIT>' ) + '<STR_LIT:\">' <EOL> else : <EOL> return '<STR_LIT:=>' + repr ( val ) <EOL> class ThreadedDocumenter ( autodoc . FunctionDocumenter ) : <EOL> '''<STR_LIT>''' <EOL> @ classmethod <EOL> def can_document_member ( cls , member , membername , isattr , parent ) : <EOL> return ( isinstance ( member , Segment ) or <EOL> super ( ThreadedDocumenter , cls ) . can_document_member ( member , membername , isattr , parent ) ) <EOL> def format_args ( self ) : <EOL> argspec = getconfigargspec ( self . object ) <EOL> return formatargspec ( * argspec , formatvalue = formatvalue ) . replace ( '<STR_LIT:\\\\>' , '<STR_LIT>' ) <EOL> class Repr ( object ) : <EOL> def __init__ ( self , repr_contents ) : <EOL>", "answer": "self . repr_contents = repr_contents"}, {"prompt": "<s> import tempfile <EOL> import numpy <EOL> from numpy . testing import assert_raises <EOL> from six import BytesIO <EOL> from six . moves import cPickle <EOL> from fuel . datasets import TextFile , IterableDataset , IndexableDataset <EOL> from fuel . schemes import SequentialScheme <EOL> from fuel . streams import DataStream <EOL> from fuel . transformers . text import NGrams <EOL> def lower ( s ) : <EOL> return s . lower ( ) <EOL> def test_text ( ) : <EOL> with tempfile . NamedTemporaryFile ( mode = '<STR_LIT:w>' , delete = False ) as f : <EOL> sentences1 = f . name <EOL> f . write ( \"<STR_LIT>\" ) <EOL> f . write ( \"<STR_LIT>\" ) <EOL> with tempfile . NamedTemporaryFile ( mode = '<STR_LIT:w>' , delete = False ) as f : <EOL> sentences2 = f . name <EOL>", "answer": "f . write ( \"<STR_LIT>\" )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import unicode_literals <EOL> from builtins import str <EOL> from django . db import models <EOL> from django . conf import settings <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from django . utils . translation import string_concat <EOL> from lino . utils . xmlgen . html import E <EOL> from lino . api import dd <EOL> from lino import mixins <EOL> from lino . core . constants import _handle_attr_name <EOL> def sepjoin ( items , sep = '<STR_LIT:U+002CU+0020>' ) : <EOL> rv = [ ] <EOL> for i in items : <EOL> if len ( rv ) : <EOL> rv . append ( sep ) <EOL> rv . append ( str ( i ) ) <EOL> return rv <EOL> class Place ( mixins . BabelNamed ) : <EOL> city = dd . ForeignKey ( <EOL> '<STR_LIT>' , <EOL> related_name = '<STR_LIT>' , <EOL> blank = True , null = True ) <EOL> class Places ( dd . Table ) : <EOL> model = Place <EOL> class Feature ( mixins . BabelNamed ) : <EOL> pass <EOL> class Features ( dd . Table ) : <EOL> model = Feature <EOL> class Type ( mixins . BabelNamed ) : <EOL>", "answer": "events_column_names = models . CharField ("}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import StringIO <EOL> from grr . lib import flags <EOL> from grr . lib import test_lib <EOL> from grr . lib . rdfvalues import anomaly as rdf_anomaly <EOL> from grr . lib . rdfvalues import client as rdf_client <EOL> from grr . lib . rdfvalues import config_file as rdf_config_file <EOL> from grr . lib . rdfvalues import paths as rdf_paths <EOL> from grr . lib . rdfvalues import protodict as rdf_protodict <EOL> from grr . parsers import config_file <EOL> CFG = \"\"\"<STR_LIT>\"\"\" <EOL> class SshdConfigTest ( test_lib . GRRBaseTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def GetConfig ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> parser = config_file . SshdConfigParser ( ) <EOL> results = list ( parser . Parse ( None , StringIO . StringIO ( CFG ) , None ) ) <EOL> self . assertEqual ( <NUM_LIT:1> , len ( results ) ) <EOL> return results [ <NUM_LIT:0> ] <EOL> def testParseConfig ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = self . GetConfig ( ) <EOL> self . assertTrue ( isinstance ( result , rdf_config_file . SshdConfig ) ) <EOL> self . assertItemsEqual ( [ <NUM_LIT:2> ] , result . config . protocol ) <EOL> expect = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> self . assertItemsEqual ( expect , result . config . ciphers ) <EOL> def testFindNumericValues ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = self . GetConfig ( ) <EOL> self . assertEqual ( <NUM_LIT> , result . config . serverkeybits ) <EOL> self . assertItemsEqual ( [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] , result . config . port ) <EOL> def testParseMatchGroups ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = self . GetConfig ( ) <EOL> self . assertEqual ( <NUM_LIT:2> , len ( result . matches ) ) <EOL> block_1 , block_2 = result . matches <EOL> self . assertEqual ( \"<STR_LIT>\" , block_1 . criterion ) <EOL> self . assertEqual ( \"<STR_LIT>\" , block_2 . criterion ) <EOL> self . assertEqual ( \"<STR_LIT:yes>\" , block_1 . config . permitrootlogin ) <EOL> self . assertEqual ( \"<STR_LIT>\" , block_2 . config . permitrootlogin ) <EOL> self . assertFalse ( block_1 . config . protocol ) <EOL> class FieldParserTests ( test_lib . GRRBaseTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testParser ( self ) : <EOL> test_data = r\"\"\"<STR_LIT>\"\"\" <EOL> expected = [ [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] , <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" ] ] <EOL> cfg = config_file . FieldParser ( sep = [ \"<STR_LIT>\" , \"<STR_LIT::>\" , \"<STR_LIT:;>\" ] , <EOL> comments = [ \"<STR_LIT:#>\" , \"<STR_LIT>\" ] ) <EOL> results = cfg . ParseEntries ( test_data ) <EOL> for i , expect in enumerate ( expected ) : <EOL> self . assertItemsEqual ( expect , results [ i ] ) <EOL> def testNoFinalTerminator ( self ) : <EOL> test_data = \"<STR_LIT>\" <EOL> expected = [ [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:a>\" , \"<STR_LIT>\" ] ] <EOL> cfg = config_file . FieldParser ( ) <EOL> results = cfg . ParseEntries ( test_data ) <EOL> for i , expect in enumerate ( expected ) : <EOL> self . assertItemsEqual ( expect , results [ i ] ) <EOL> def testWhitespaceDoesntNukeNewline ( self ) : <EOL> test_data = \"<STR_LIT>\" <EOL> expected = [ [ \"<STR_LIT>\" , \"<STR_LIT>\" ] , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ] <EOL> results = config_file . FieldParser ( ) . ParseEntries ( test_data ) <EOL> for i , expect in enumerate ( expected ) : <EOL> self . assertItemsEqual ( expect , results [ i ] ) <EOL> expected = [ [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ] <EOL> results = config_file . FieldParser ( sep = r\"<STR_LIT>\" ) . ParseEntries ( test_data ) <EOL> for i , expect in enumerate ( expected ) : <EOL> self . assertItemsEqual ( expect , results [ i ] ) <EOL> class KeyValueParserTests ( test_lib . GRRBaseTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testParser ( self ) : <EOL> test_data = r\"\"\"<STR_LIT>\"\"\" <EOL> expected = [ { \"<STR_LIT>\" : [ \"<STR_LIT:a>\" , \"<STR_LIT:list>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] } , <EOL> { \"<STR_LIT>\" : [ \"<STR_LIT>\" , \"<STR_LIT>\" ] } , <EOL> { \"<STR_LIT>\" : [ ] } ] <EOL> cfg = config_file . KeyValueParser ( kv_sep = [ \"<STR_LIT:=>\" , \"<STR_LIT::>\" ] , comments = [ \"<STR_LIT:#>\" , \"<STR_LIT>\" ] ) <EOL> results = cfg . ParseEntries ( test_data ) <EOL> for i , expect in enumerate ( expected ) : <EOL> self . assertDictEqual ( expect , results [ i ] ) <EOL> class NfsExportParserTests ( test_lib . GRRBaseTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testParseNfsExportFile ( self ) : <EOL> test_data = r\"\"\"<STR_LIT>\"\"\" <EOL> exports = StringIO . StringIO ( test_data ) <EOL> parser = config_file . NfsExportsParser ( ) <EOL> results = list ( parser . Parse ( None , exports , None ) ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:0> ] . share ) <EOL> self . assertItemsEqual ( [ \"<STR_LIT>\" , \"<STR_LIT>\" ] , results [ <NUM_LIT:0> ] . defaults ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:0> ] . clients [ <NUM_LIT:0> ] . host ) <EOL> self . assertItemsEqual ( [ \"<STR_LIT>\" ] , results [ <NUM_LIT:0> ] . clients [ <NUM_LIT:0> ] . options ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:0> ] . clients [ <NUM_LIT:1> ] . host ) <EOL> self . assertItemsEqual ( [ ] , results [ <NUM_LIT:0> ] . clients [ <NUM_LIT:1> ] . options ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:1> ] . share ) <EOL> self . assertItemsEqual ( [ \"<STR_LIT>\" ] , results [ <NUM_LIT:1> ] . defaults ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:1> ] . clients [ <NUM_LIT:0> ] . host ) <EOL> self . assertItemsEqual ( [ \"<STR_LIT>\" , \"<STR_LIT>\" ] , results [ <NUM_LIT:1> ] . clients [ <NUM_LIT:0> ] . options ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:1> ] . clients [ <NUM_LIT:1> ] . host ) <EOL> self . assertItemsEqual ( [ ] , results [ <NUM_LIT:1> ] . clients [ <NUM_LIT:1> ] . options ) <EOL> class MtabParserTests ( test_lib . GRRBaseTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testParseMountData ( self ) : <EOL> test_data = r\"\"\"<STR_LIT>\"\"\" <EOL> exports = StringIO . StringIO ( test_data ) <EOL> parser = config_file . MtabParser ( ) <EOL> results = list ( parser . Parse ( None , exports , None ) ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:0> ] . device ) <EOL> self . assertEqual ( \"<STR_LIT:/>\" , results [ <NUM_LIT:0> ] . mount_point ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:0> ] . type ) <EOL> self . assertTrue ( results [ <NUM_LIT:0> ] . options . rw ) <EOL> self . assertFalse ( results [ <NUM_LIT:0> ] . options . ro ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:1> ] . device ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:1> ] . mount_point ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:1> ] . type ) <EOL> self . assertTrue ( results [ <NUM_LIT:1> ] . options . rw ) <EOL> self . assertTrue ( results [ <NUM_LIT:1> ] . options . nosuid ) <EOL> self . assertTrue ( results [ <NUM_LIT:1> ] . options . nodev ) <EOL> self . assertEqual ( [ \"<STR_LIT>\" ] , results [ <NUM_LIT:1> ] . options . max_read ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:2> ] . device ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:2> ] . mount_point ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:2> ] . type ) <EOL> self . assertTrue ( results [ <NUM_LIT:2> ] . options . ro ) <EOL> self . assertTrue ( results [ <NUM_LIT:2> ] . options . nosuid ) <EOL> self . assertTrue ( results [ <NUM_LIT:2> ] . options . nodev ) <EOL> class MountCmdTests ( test_lib . GRRBaseTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testParseMountData ( self ) : <EOL> test_data = r\"\"\"<STR_LIT>\"\"\" <EOL> parser = config_file . MountCmdParser ( ) <EOL> results = list ( parser . Parse ( \"<STR_LIT>\" , [ ] , test_data , \"<STR_LIT>\" , <NUM_LIT:0> , <NUM_LIT:5> , None ) ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:0> ] . device ) <EOL> self . assertEqual ( \"<STR_LIT:/>\" , results [ <NUM_LIT:0> ] . mount_point ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:0> ] . type ) <EOL> self . assertTrue ( results [ <NUM_LIT:0> ] . options . rw ) <EOL> self . assertFalse ( results [ <NUM_LIT:0> ] . options . ro ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:1> ] . device ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:1> ] . mount_point ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:1> ] . type ) <EOL> self . assertTrue ( results [ <NUM_LIT:1> ] . options . rw ) <EOL> self . assertTrue ( results [ <NUM_LIT:1> ] . options . nosuid ) <EOL> self . assertTrue ( results [ <NUM_LIT:1> ] . options . nodev ) <EOL> self . assertEqual ( [ \"<STR_LIT>\" ] , results [ <NUM_LIT:1> ] . options . max_read ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:2> ] . device ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:2> ] . mount_point ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results [ <NUM_LIT:2> ] . type ) <EOL> self . assertTrue ( results [ <NUM_LIT:2> ] . options . ro ) <EOL> self . assertTrue ( results [ <NUM_LIT:2> ] . options . nosuid ) <EOL> self . assertTrue ( results [ <NUM_LIT:2> ] . options . nodev ) <EOL> class RsyslogParserTests ( test_lib . GRRBaseTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testParseRsyslog ( self ) : <EOL> test_data = r\"\"\"<STR_LIT>\"\"\" <EOL> log_conf = StringIO . StringIO ( test_data ) <EOL> parser = config_file . RsyslogParser ( ) <EOL> results = list ( parser . ParseMultiple ( [ None ] , [ log_conf ] , None ) ) <EOL> self . assertEqual ( <NUM_LIT:1> , len ( results ) ) <EOL> tcp , udp , pipe , null , script , fs , wall , async_fs = [ <EOL> target for target in results [ <NUM_LIT:0> ] . targets ] <EOL> self . assertEqual ( \"<STR_LIT>\" , tcp . facility ) <EOL> self . assertEqual ( \"<STR_LIT:*>\" , tcp . priority ) <EOL> self . assertEqual ( \"<STR_LIT>\" , tcp . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , tcp . destination ) <EOL> self . assertEqual ( \"<STR_LIT>\" , udp . facility ) <EOL> self . assertEqual ( \"<STR_LIT>\" , udp . priority ) <EOL> self . assertEqual ( \"<STR_LIT>\" , udp . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , udp . destination ) <EOL> self . assertEqual ( \"<STR_LIT>\" , pipe . facility ) <EOL> self . assertEqual ( \"<STR_LIT:*>\" , pipe . priority ) <EOL> self . assertEqual ( \"<STR_LIT>\" , pipe . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , pipe . destination ) <EOL> self . assertEqual ( \"<STR_LIT>\" , null . facility ) <EOL> self . assertEqual ( \"<STR_LIT:*>\" , null . priority ) <EOL> self . assertEqual ( \"<STR_LIT>\" , null . transport ) <EOL> self . assertFalse ( null . destination ) <EOL> self . assertEqual ( \"<STR_LIT:user>\" , script . facility ) <EOL> self . assertEqual ( \"<STR_LIT:*>\" , script . priority ) <EOL> self . assertEqual ( \"<STR_LIT>\" , script . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , script . destination ) <EOL> self . assertEqual ( \"<STR_LIT:*>\" , fs . facility ) <EOL> self . assertEqual ( \"<STR_LIT:*>\" , fs . priority ) <EOL> self . assertEqual ( \"<STR_LIT>\" , fs . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , fs . destination ) <EOL> self . assertEqual ( \"<STR_LIT:*>\" , wall . facility ) <EOL> self . assertEqual ( \"<STR_LIT>\" , wall . priority ) <EOL> self . assertEqual ( \"<STR_LIT>\" , wall . transport ) <EOL> self . assertEqual ( \"<STR_LIT:*>\" , wall . destination ) <EOL> self . assertEqual ( \"<STR_LIT>\" , async_fs . facility ) <EOL> self . assertEqual ( \"<STR_LIT:*>\" , async_fs . priority ) <EOL> self . assertEqual ( \"<STR_LIT>\" , async_fs . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , async_fs . destination ) <EOL> class APTPackageSourceParserTests ( test_lib . GRRBaseTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testPackageSourceData ( self ) : <EOL> test_data = r\"\"\"<STR_LIT>\"\"\" <EOL> file_obj = StringIO . StringIO ( test_data ) <EOL> pathspec = rdf_paths . PathSpec ( path = \"<STR_LIT>\" ) <EOL> stat = rdf_client . StatEntry ( pathspec = pathspec ) <EOL> parser = config_file . APTPackageSourceParser ( ) <EOL> results = list ( parser . Parse ( stat , file_obj , None ) ) <EOL> result = [ d for d in results if isinstance ( d , <EOL> rdf_protodict . AttributedDict ) ] [ <NUM_LIT:0> ] <EOL> self . assertEqual ( \"<STR_LIT>\" , result . filename ) <EOL> self . assertEqual ( <NUM_LIT:5> , len ( result . uris ) ) <EOL> self . assertEqual ( \"<STR_LIT:http>\" , result . uris [ <NUM_LIT:0> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:0> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT:/>\" , result . uris [ <NUM_LIT:0> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:1> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:1> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT:/>\" , result . uris [ <NUM_LIT:1> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:2> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:2> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:2> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT:file>\" , result . uris [ <NUM_LIT:3> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:3> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:3> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT:file>\" , result . uris [ <NUM_LIT:4> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:4> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT:/>\" , result . uris [ <NUM_LIT:4> ] . path ) <EOL> def testEmptySourceData ( self ) : <EOL> test_data = ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT:\\n>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> file_obj = StringIO . StringIO ( test_data ) <EOL> pathspec = rdf_paths . PathSpec ( path = \"<STR_LIT>\" ) <EOL> stat = rdf_client . StatEntry ( pathspec = pathspec ) <EOL> parser = config_file . APTPackageSourceParser ( ) <EOL> results = list ( parser . Parse ( stat , file_obj , None ) ) <EOL> result = [ d for d in results if isinstance ( d , <EOL> rdf_protodict . AttributedDict ) ] [ <NUM_LIT:0> ] <EOL> self . assertEqual ( \"<STR_LIT>\" , result . filename ) <EOL> self . assertEqual ( <NUM_LIT:0> , len ( result . uris ) ) <EOL> def testRFC822StyleSourceDataParser ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> test_data = r\"\"\"<STR_LIT>\"\"\" <EOL> file_obj = StringIO . StringIO ( test_data ) <EOL> pathspec = rdf_paths . PathSpec ( path = \"<STR_LIT>\" ) <EOL> stat = rdf_client . StatEntry ( pathspec = pathspec ) <EOL> parser = config_file . APTPackageSourceParser ( ) <EOL> results = list ( parser . Parse ( stat , file_obj , None ) ) <EOL> result = [ d for d in results if isinstance ( d , <EOL> rdf_protodict . AttributedDict ) ] [ <NUM_LIT:0> ] <EOL> self . assertEqual ( \"<STR_LIT>\" , result . filename ) <EOL> self . assertEqual ( <NUM_LIT:11> , len ( result . uris ) ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:0> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:0> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT:/>\" , result . uris [ <NUM_LIT:0> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT:http>\" , result . uris [ <NUM_LIT:1> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:1> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:1> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT:http>\" , result . uris [ <NUM_LIT:2> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:2> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:2> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT:http>\" , result . uris [ <NUM_LIT:3> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:3> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:3> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT:http>\" , result . uris [ <NUM_LIT:4> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:4> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:4> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:5> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:5> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:5> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT:http>\" , result . uris [ <NUM_LIT:6> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:6> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:6> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT:http>\" , result . uris [ <NUM_LIT:7> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:7> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:7> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT:http>\" , result . uris [ <NUM_LIT:8> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:8> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:8> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:9> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:9> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:9> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:10> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:10> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:10> ] . path ) <EOL> class YumPackageSourceParserTests ( test_lib . GRRBaseTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testPackageSourceData ( self ) : <EOL> test_data = r\"\"\"<STR_LIT>\"\"\" <EOL> file_obj = StringIO . StringIO ( test_data ) <EOL> pathspec = rdf_paths . PathSpec ( path = \"<STR_LIT>\" ) <EOL> stat = rdf_client . StatEntry ( pathspec = pathspec ) <EOL> parser = config_file . YumPackageSourceParser ( ) <EOL> results = list ( parser . Parse ( stat , file_obj , None ) ) <EOL> result = [ d for d in results if isinstance ( d , <EOL> rdf_protodict . AttributedDict ) ] [ <NUM_LIT:0> ] <EOL> self . assertEqual ( \"<STR_LIT>\" , result . filename ) <EOL> self . assertEqual ( <NUM_LIT:4> , len ( result . uris ) ) <EOL> self . assertEqual ( \"<STR_LIT:file>\" , result . uris [ <NUM_LIT:0> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:0> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:0> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT:http>\" , result . uris [ <NUM_LIT:1> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:1> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:1> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:2> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:2> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:2> ] . path ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:3> ] . transport ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:3> ] . host ) <EOL> self . assertEqual ( \"<STR_LIT>\" , result . uris [ <NUM_LIT:3> ] . path ) <EOL> def testEmptySourceData ( self ) : <EOL> test_data = ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> file_obj = StringIO . StringIO ( test_data ) <EOL> pathspec = rdf_paths . PathSpec ( path = \"<STR_LIT>\" ) <EOL> stat = rdf_client . StatEntry ( pathspec = pathspec ) <EOL> parser = config_file . YumPackageSourceParser ( ) <EOL> results = list ( parser . Parse ( stat , file_obj , None ) ) <EOL> result = [ d for d in results if isinstance ( d , <EOL> rdf_protodict . AttributedDict ) ] [ <NUM_LIT:0> ] <EOL> self . assertEqual ( \"<STR_LIT>\" , result . filename ) <EOL> self . assertEqual ( <NUM_LIT:0> , len ( result . uris ) ) <EOL> class CronAtAllowDenyParserTests ( test_lib . GRRBaseTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testParseCronData ( self ) : <EOL> test_data = r\"\"\"<STR_LIT>\"\"\" <EOL> file_obj = StringIO . StringIO ( test_data ) <EOL> pathspec = rdf_paths . PathSpec ( path = \"<STR_LIT>\" ) <EOL> stat = rdf_client . StatEntry ( pathspec = pathspec ) <EOL> parser = config_file . CronAtAllowDenyParser ( ) <EOL> results = list ( parser . Parse ( stat , file_obj , None ) ) <EOL> result = [ d for d in results if isinstance ( d , <EOL> rdf_protodict . AttributedDict ) ] [ <NUM_LIT:0> ] <EOL> filename = result . filename <EOL> users = result . users <EOL> self . assertEqual ( \"<STR_LIT>\" , filename ) <EOL> self . assertEqual ( sorted ( [ \"<STR_LIT:root>\" , \"<STR_LIT:user>\" , \"<STR_LIT>\" ] ) , sorted ( users ) ) <EOL> anomalies = [ a for a in results if isinstance ( a , rdf_anomaly . Anomaly ) ] <EOL> self . assertEqual ( <NUM_LIT:1> , len ( anomalies ) ) <EOL> anom = anomalies [ <NUM_LIT:0> ] <EOL> self . assertEqual ( \"<STR_LIT>\" , anom . symptom ) <EOL> self . assertEqual ( sorted ( [ \"<STR_LIT>\" , \"<STR_LIT>\" ] ) , sorted ( anom . finding ) ) <EOL> self . assertEqual ( pathspec , anom . reference_pathspec ) <EOL> self . assertEqual ( \"<STR_LIT>\" , anom . type ) <EOL> class NtpParserTests ( test_lib . GRRBaseTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testParseNtpConfig ( self ) : <EOL> test_data = r\"\"\"<STR_LIT>\"\"\" <EOL> conffile = StringIO . StringIO ( test_data ) <EOL> parser = config_file . NtpdParser ( ) <EOL> results = list ( parser . Parse ( None , conffile , None ) ) <EOL> self . assertTrue ( results ) <EOL> self . assertEqual ( <NUM_LIT:1> , len ( results ) ) <EOL> results = results [ <NUM_LIT:0> ] <EOL> expected_config_keywords = set ( <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] ) | set ( parser . _defaults . keys ( ) ) <EOL> self . assertEqual ( expected_config_keywords , set ( results . config . keys ( ) ) ) <EOL> self . assertTrue ( results . server ) <EOL> self . assertTrue ( results . restrict ) <EOL> self . assertFalse ( results . trap ) <EOL> servers = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] <EOL> self . assertItemsEqual ( servers , [ r . address for r in results . server ] ) <EOL> for r in results . server : <EOL> self . assertEqual ( \"<STR_LIT>\" , r . options ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results . config [ \"<STR_LIT>\" ] ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results . config [ \"<STR_LIT>\" ] ) <EOL> self . assertEqual ( \"<STR_LIT>\" , <EOL> results . config [ \"<STR_LIT>\" ] ) <EOL> self . assertEqual ( <NUM_LIT:1> , len ( results . restrict ) ) <EOL> self . assertEqual ( \"<STR_LIT:default>\" , results . restrict [ <NUM_LIT:0> ] . address ) <EOL> self . assertEqual ( \"<STR_LIT>\" , results . restrict [ <NUM_LIT:0> ] . options ) <EOL> self . assertEqual ( [ <NUM_LIT> , <NUM_LIT> ] , results . config [ \"<STR_LIT>\" ] ) <EOL> self . assertEqual ( [ <NUM_LIT> ] , results . config [ \"<STR_LIT>\" ] ) <EOL> self . assertFalse ( results . config [ \"<STR_LIT>\" ] ) <EOL> self . assertTrue ( results . config [ \"<STR_LIT>\" ] ) <EOL> self . assertFalse ( results . config [ \"<STR_LIT>\" ] ) <EOL> self . assertTrue ( results . config [ \"<STR_LIT>\" ] ) <EOL> class SudoersParserTest ( test_lib . GRRBaseTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testIncludes ( self ) : <EOL> test_data = r\"\"\"<STR_LIT>\"\"\" <EOL> contents = StringIO . StringIO ( test_data ) <EOL> config = config_file . SudoersParser ( ) <EOL> result = list ( config . Parse ( None , contents , None ) ) <EOL> self . assertListEqual ( list ( result [ <NUM_LIT:0> ] . includes ) , [ \"<STR_LIT:a>\" , \"<STR_LIT:b>\" ] ) <EOL> self . assertListEqual ( list ( result [ <NUM_LIT:0> ] . entries ) , [ ] ) <EOL> def testParseAliases ( self ) : <EOL> test_data = r\"\"\"<STR_LIT>\"\"\" <EOL> contents = StringIO . StringIO ( test_data ) <EOL> config = config_file . SudoersParser ( ) <EOL> result = list ( config . Parse ( None , contents , None ) ) <EOL> golden = { <EOL> \"<STR_LIT>\" : [ <EOL> { <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ \"<STR_LIT:a>\" , \"<STR_LIT:b>\" , \"<STR_LIT:c>\" ] , <EOL> } , <EOL> { <EOL> \"<STR_LIT:name>\" : \"<STR_LIT:left>\" , <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ \"<STR_LIT:a>\" , \"<STR_LIT:b>\" , \"<STR_LIT:c>\" ] , <EOL> } , <EOL> { <EOL> \"<STR_LIT:name>\" : \"<STR_LIT:right>\" , <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ \"<STR_LIT:d>\" , \"<STR_LIT:e>\" , \"<STR_LIT:f>\" ] , <EOL> } , <EOL> { <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> } , <EOL> ] , <EOL> } <EOL> self . assertDictEqual ( result [ <NUM_LIT:0> ] . ToPrimitiveDict ( ) , golden ) <EOL> def testDefaults ( self ) : <EOL> test_data = r\"\"\"<STR_LIT>\"\"\" <EOL> contents = StringIO . StringIO ( test_data ) <EOL> config = config_file . SudoersParser ( ) <EOL> result = list ( config . Parse ( None , contents , None ) ) <EOL> golden = { <EOL> \"<STR_LIT>\" : [ <EOL> { <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:value>\" : \"<STR_LIT>\" , <EOL> } , <EOL>", "answer": "{"}, {"prompt": "<s> from __future__ import with_statement <EOL> from fabric . api import * <EOL> from fabric . colors import red , green <EOL> import os <EOL> from datetime import date <EOL> import pexpect <EOL> env . database = \"<STR_LIT>\" <EOL> env . postgis_path = \"<STR_LIT>\" <EOL> env . postgis_spatial_ref_path = \"<STR_LIT>\" <EOL> env . tested = False <EOL> def demo ( ) : <EOL> env . user = \"<STR_LIT:root>\" <EOL> env . database = \"<STR_LIT>\" <EOL> env . hosts = [ \"<STR_LIT>\" ] <EOL> def camp ( ) : <EOL> env . user = \"<STR_LIT:root>\" <EOL> env . database = \"<STR_LIT>\" <EOL> env . hosts = [ \"<STR_LIT>\" ] <EOL> def larc ( ) : <EOL> env . user = \"<STR_LIT:root>\" <EOL> env . database = \"<STR_LIT>\" <EOL> env . hosts = [ \"<STR_LIT>\" ] <EOL> def libya ( ) : <EOL> env . user = \"<STR_LIT:root>\" <EOL> env . database = \"<STR_LIT>\" <EOL> env . hosts = [ \"<STR_LIT>\" ] <EOL> def atlantico ( ) : <EOL> env . user = \"<STR_LIT:root>\" <EOL> env . hosts = [ \"<STR_LIT>\" ] <EOL> def california ( ) : <EOL> env . user = \"<STR_LIT:root>\" <EOL> env . hosts = [ \"<STR_LIT>\" ] <EOL> def japan ( ) : <EOL> env . user = \"<STR_LIT:root>\" <EOL> env . database = \"<STR_LIT>\" <EOL> env . hosts = [ \"<STR_LIT>\" ] <EOL> def taiwan ( ) : <EOL> env . user = \"<STR_LIT:root>\" <EOL> env . hosts = [ \"<STR_LIT>\" ] <EOL> def vietnam ( ) : <EOL> env . user = \"<STR_LIT:root>\" <EOL> env . hosts = [ \"<STR_LIT>\" ] <EOL> test_host = \"<STR_LIT>\" <EOL> def test ( ) : <EOL> env . user = \"<STR_LIT:root>\" <EOL> env . hosts = [ test_host ] <EOL> prod_host = \"<STR_LIT>\" <EOL> def pakistan ( ) : <EOL> env . user = \"<STR_LIT:root>\" <EOL> env . tested = True <EOL> env . hosts = [ prod_host ] <EOL> all_hosts = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> def all ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> env . user = \"<STR_LIT:root>\" <EOL> env . hosts = all_hosts <EOL> env . key_filename = [ \"<STR_LIT>\" ] <EOL> def generate_keys ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> local ( \"<STR_LIT>\" ) <EOL> def distribute_keys ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> local ( \"<STR_LIT>\" % ( env . user , env . host ) ) <EOL> def deploy ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print ( green ( \"<STR_LIT>\" % env . host ) ) <EOL> maintenance_on ( ) <EOL> backup ( ) <EOL> pull ( ) <EOL> cleanup ( ) <EOL> migrate_on ( ) <EOL> if \"<STR_LIT:test>\" in env . host : <EOL> db_sync ( ) <EOL> else : <EOL> db_upgrade ( ) <EOL> migrate ( ) <EOL> db_upgrade_ ( ) <EOL> migrate_off ( ) <EOL> optimise ( ) <EOL> maintenance_off ( ) <EOL> def backup ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print ( green ( \"<STR_LIT>\" % env . host ) ) <EOL> with cd ( \"<STR_LIT>\" ) : <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> env . warn_only = True <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> env . warn_only = False <EOL> if env . database == \"<STR_LIT>\" : <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> elif env . database == \"<STR_LIT>\" : <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> filename = \"<STR_LIT>\" % ( env . host , str ( date . today ( ) ) ) <EOL> run ( \"<STR_LIT>\" % filename , pty = True ) <EOL> env . warn_only = True <EOL> run ( \"<STR_LIT>\" % filename , pty = True ) <EOL> env . warn_only = False <EOL> run ( \"<STR_LIT>\" % filename , pty = True ) <EOL> def cleanup ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print ( green ( \"<STR_LIT>\" % env . host ) ) <EOL> with cd ( \"<STR_LIT>\" ) : <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> print ( green ( \"<STR_LIT>\" % env . host ) ) <EOL> env . warn_only = True <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> env . warn_only = False <EOL> def db_create ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with cd ( \"<STR_LIT>\" ) : <EOL> print ( green ( \"<STR_LIT>\" % env . host ) ) <EOL> if env . database == \"<STR_LIT>\" : <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> elif env . database == \"<STR_LIT>\" : <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> run ( \"<STR_LIT>\" % env . postgis_path , pty = True ) <EOL> run ( \"<STR_LIT>\" % env . postgis_spatial_ref_path , pty = True ) <EOL> def db_drop ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with cd ( \"<STR_LIT>\" ) : <EOL> print ( green ( \"<STR_LIT>\" % env . host ) ) <EOL> env . warn_only = True <EOL> if env . database == \"<STR_LIT>\" : <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> elif env . database == \"<STR_LIT>\" : <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> env . warn_only = False <EOL> print ( green ( \"<STR_LIT>\" % env . host ) ) <EOL> run ( \"<STR_LIT>\" , pty = True ) <EOL> def db_upgrade ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print ( green ( \"<STR_LIT>\" % env . host ) ) <EOL> db_drop ( ) <EOL> db_create ( ) <EOL>", "answer": "with cd ( \"<STR_LIT>\" ) :"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from setuptools import setup , find_packages <EOL> from codecs import open <EOL> from os import path <EOL> here = path . abspath ( path . dirname ( __file__ ) ) <EOL> with open ( path . join ( here , '<STR_LIT>' ) , encoding = '<STR_LIT:utf-8>' ) as f : <EOL> long_description = f . read ( ) <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> long_description = long_description , <EOL> url = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> license = '<STR_LIT>' , <EOL> classifiers = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "] ,"}, {"prompt": "<s> from collections import namedtuple <EOL> from functools import total_ordering <EOL> import logging <EOL> import signal <EOL> import time <EOL> from six . moves . queue import PriorityQueue <EOL> from subprocess import Popen , PIPE <EOL> from threading import Thread <EOL> try : <EOL> from bokeh . plotting import ( curdoc , cursession , figure , output_server , <EOL> push , show ) <EOL> BOKEH_AVAILABLE = True <EOL> except ImportError : <EOL> BOKEH_AVAILABLE = False <EOL> from blocks . config import config <EOL> from blocks . extensions import SimpleExtension <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Plot ( SimpleExtension ) : <EOL> r\"\"\"<STR_LIT>\"\"\" <EOL> colors = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def __init__ ( self , document , channels , open_browser = False , <EOL> start_server = False , server_url = None , ** kwargs ) : <EOL> if not BOKEH_AVAILABLE : <EOL> raise ImportError <EOL> if server_url is None : <EOL> server_url = config . bokeh_server <EOL> self . plots = { } <EOL> self . start_server = start_server <EOL> self . document = document <EOL> self . server_url = server_url <EOL> self . _startserver ( ) <EOL> self . p = [ ] <EOL> self . p_indices = { } <EOL> self . color_indices = { } <EOL> for i , channel_set in enumerate ( channels ) : <EOL> channel_set_opts = { } <EOL> if isinstance ( channel_set , dict ) : <EOL> channel_set_opts = channel_set <EOL> channel_set = channel_set_opts . pop ( '<STR_LIT>' ) <EOL> channel_set_opts . setdefault ( '<STR_LIT:title>' , <EOL> '<STR_LIT>' . format ( document , i + <NUM_LIT:1> ) ) <EOL> channel_set_opts . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> channel_set_opts . setdefault ( '<STR_LIT>' , '<STR_LIT:value>' ) <EOL> self . p . append ( figure ( ** channel_set_opts ) ) <EOL> for j , channel in enumerate ( channel_set ) : <EOL> self . p_indices [ channel ] = i <EOL> self . color_indices [ channel ] = j <EOL> if open_browser : <EOL> show ( ) <EOL> kwargs . setdefault ( '<STR_LIT>' , True ) <EOL> kwargs . setdefault ( \"<STR_LIT>\" , True ) <EOL> kwargs . setdefault ( \"<STR_LIT>\" , True ) <EOL> super ( Plot , self ) . __init__ ( ** kwargs ) <EOL> @ property <EOL> def push_thread ( self ) : <EOL> if not hasattr ( self , '<STR_LIT>' ) : <EOL> self . _push_thread = PushThread ( ) <EOL> self . _push_thread . start ( ) <EOL> return self . _push_thread <EOL> def do ( self , which_callback , * args ) : <EOL> log = self . main_loop . log <EOL> iteration = log . status [ '<STR_LIT>' ] <EOL> for key , value in log . current_row . items ( ) : <EOL> if key in self . p_indices : <EOL> if key not in self . plots : <EOL> line_color = self . colors [ <EOL> self . color_indices [ key ] % len ( self . colors ) ] <EOL> fig = self . p [ self . p_indices [ key ] ] <EOL> fig . line ( [ iteration ] , [ value ] , <EOL> legend = key , name = key , <EOL> line_color = line_color ) <EOL> renderer = fig . select ( dict ( name = key ) ) <EOL> self . plots [ key ] = renderer [ <NUM_LIT:0> ] . data_source <EOL> else : <EOL> self . plots [ key ] . data [ '<STR_LIT:x>' ] . append ( iteration ) <EOL> self . plots [ key ] . data [ '<STR_LIT:y>' ] . append ( value ) <EOL> self . push_thread . put ( self . plots [ key ] , PushThread . PUT ) <EOL> self . push_thread . put ( which_callback , PushThread . PUSH ) <EOL> def _startserver ( self ) : <EOL> if self . start_server : <EOL> def preexec_fn ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> signal . signal ( signal . SIGINT , signal . SIG_IGN ) <EOL> logger . info ( '<STR_LIT>' ) <EOL> self . sub = Popen ( '<STR_LIT>' <EOL> '<STR_LIT>' . split ( ) , <EOL> stdout = PIPE , stderr = PIPE , preexec_fn = preexec_fn ) <EOL> time . sleep ( <NUM_LIT:2> ) <EOL> logger . info ( '<STR_LIT>' . format ( self . sub . pid ) ) <EOL> else : <EOL> self . sub = None <EOL>", "answer": "output_server ( self . document , url = self . server_url )"}, {"prompt": "<s> from vcs . commands . log import LogCommand <EOL> class StandupCommand ( LogCommand ) : <EOL> def handle_repo ( self , repo , ** options ) : <EOL> options [ '<STR_LIT:all>' ] = True <EOL> options [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> username = repo . get_user_name ( ) <EOL>", "answer": "options [ '<STR_LIT>' ] = username + '<STR_LIT:*>'"}, {"prompt": "<s> import sys <EOL> import os <EOL> import nn <EOL> import numpy as np <EOL> import imageqa_test as it <EOL> import imageqa_ensemble as ie <EOL> import imageqa_render as ir <EOL> import prep <EOL> def parseInputFile ( filename ) : <EOL> qids = [ ] <EOL> questions = [ ] <EOL> answers = [ ] <EOL> caption = '<STR_LIT>' <EOL> i = <NUM_LIT:0> <EOL> with open ( filename ) as f : <EOL> for line in f : <EOL> if i == <NUM_LIT:0> and line . startswith ( '<STR_LIT>' ) : <EOL> caption = line [ <NUM_LIT:8> : - <NUM_LIT:1> ] <EOL> else : <EOL> parts = line . split ( '<STR_LIT:U+002C>' ) <EOL> qids . append ( int ( parts [ <NUM_LIT:0> ] ) ) <EOL> questions . append ( parts [ <NUM_LIT:1> ] ) <EOL> answers . append ( parts [ <NUM_LIT:2> ] . strip ( '<STR_LIT:\\n>' ) ) <EOL> i += <NUM_LIT:1> <EOL> return caption , qids , questions , answers <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> params = ir . parseComparativeParams ( sys . argv ) <EOL> urlDict = ir . loadImgUrl ( params [ '<STR_LIT>' ] , params [ '<STR_LIT>' ] ) <EOL> data = it . loadDataset ( params [ '<STR_LIT>' ] ) <EOL> maxlen = data [ '<STR_LIT>' ] [ <NUM_LIT:0> ] . shape [ <NUM_LIT:1> ] <EOL> print ( '<STR_LIT>' ) <EOL> caption , qids , questions , answers = parseInputFile ( params [ '<STR_LIT>' ] ) <EOL> idx = np . array ( qids , dtype = '<STR_LIT:int>' ) <EOL> imgids = qids <EOL> inputTest = prep . combine ( prep . lookupQID ( questions , data [ '<STR_LIT>' ] , maxlen ) , imgids ) <EOL> targetTest = prep . lookupAnsID ( answers , data [ '<STR_LIT>' ] ) <EOL> questionTypeArray = data [ '<STR_LIT>' ] [ idx ] <EOL> print ( '<STR_LIT>' ) <EOL> modelOutputs = ie . runAllModels ( <EOL> inputTest , <EOL> questionTypeArray , <EOL> params [ '<STR_LIT>' ] , <EOL> params [ '<STR_LIT>' ] , <EOL> params [ '<STR_LIT>' ] , <EOL> params [ '<STR_LIT>' ] ) <EOL> if not os . path . exists ( params [ '<STR_LIT>' ] ) : <EOL> os . makedirs ( params [ '<STR_LIT>' ] ) <EOL> if params [ '<STR_LIT>' ] == '<STR_LIT:html>' : <EOL> print ( '<STR_LIT>' ) <EOL> pages = ir . renderHtml ( <EOL> inputTest , <EOL> targetTest , <EOL> data [ '<STR_LIT>' ] , <EOL> data [ '<STR_LIT>' ] , <EOL> urlDict , <EOL> topK = params [ '<STR_LIT>' ] , <EOL> modelOutputs = modelOutputs , <EOL> modelNames = ir . getModelNames ( params [ '<STR_LIT>' ] ) , <EOL> questionIds = idx ) <EOL> for i , page in enumerate ( pages ) : <EOL> with open ( os . path . join ( params [ '<STR_LIT>' ] , <EOL>", "answer": "'<STR_LIT>' % ( params [ '<STR_LIT>' ] , i ) ) , '<STR_LIT:w>' ) as f :"}, {"prompt": "<s> from sqlalchemy import Column , DateTime , String , Integer , Boolean , func <EOL> from ee . core . database import Base <EOL> class SiteDB ( Base ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __tablename__ = '<STR_LIT>' <EOL> __table_args__ = { '<STR_LIT>' : True } <EOL> id = Column ( Integer , primary_key = True ) <EOL>", "answer": "sitename = Column ( String , unique = True )"}, {"prompt": "<s> import collections <EOL> import copy <EOL> from . Utils import _write_complex_object <EOL> class Envelope ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _defaults = collections . OrderedDict ( [ <EOL> ( '<STR_LIT>' , <NUM_LIT:1> ) , <EOL> ( '<STR_LIT:name>' , None ) , <EOL> ( '<STR_LIT:time>' , None ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , None ) , <EOL> ( '<STR_LIT>' , None ) , <EOL> ( '<STR_LIT>' , None ) , <EOL> ( '<STR_LIT>' , None ) , <EOL> ( '<STR_LIT>' , None ) , <EOL> ( '<STR_LIT>' , None ) , <EOL> ( '<STR_LIT>' , None ) , <EOL> ( '<STR_LIT>' , None ) , <EOL> ( '<STR_LIT>' , None ) , <EOL> ( '<STR_LIT>' , { } ) , <EOL> ( '<STR_LIT:data>' , None ) <EOL> ] ) <EOL> def __init__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _values = { <EOL> '<STR_LIT>' : <NUM_LIT:1> , <EOL> '<STR_LIT:name>' : None , <EOL> '<STR_LIT:time>' : None , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } <EOL> self . _initialize ( ) <EOL> @ property <EOL> def ver ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in self . _values : <EOL> return self . _values [ '<STR_LIT>' ] <EOL> return self . _defaults [ '<STR_LIT>' ] <EOL> @ ver . setter <EOL> def ver ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value == self . _defaults [ '<STR_LIT>' ] and '<STR_LIT>' in self . _values : <EOL> del self . _values [ '<STR_LIT>' ] <EOL> else : <EOL> self . _values [ '<STR_LIT>' ] = value <EOL> @ property <EOL> def name ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _values [ '<STR_LIT:name>' ] <EOL> @ name . setter <EOL> def name ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _values [ '<STR_LIT:name>' ] = value <EOL> @ property <EOL> def time ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _values [ '<STR_LIT:time>' ] <EOL> @ time . setter <EOL> def time ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _values [ '<STR_LIT:time>' ] = value <EOL> @ property <EOL> def sample_rate ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in self . _values : <EOL> return self . _values [ '<STR_LIT>' ] <EOL> return self . _defaults [ '<STR_LIT>' ] <EOL> @ sample_rate . setter <EOL> def sample_rate ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value == self . _defaults [ '<STR_LIT>' ] and '<STR_LIT>' in self . _values : <EOL> del self . _values [ '<STR_LIT>' ] <EOL> else : <EOL> self . _values [ '<STR_LIT>' ] = value <EOL> @ property <EOL> def seq ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in self . _values : <EOL> return self . _values [ '<STR_LIT>' ] <EOL> return self . _defaults [ '<STR_LIT>' ] <EOL> @ seq . setter <EOL> def seq ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value == self . _defaults [ '<STR_LIT>' ] and '<STR_LIT>' in self . _values : <EOL> del self . _values [ '<STR_LIT>' ] <EOL> else : <EOL> self . _values [ '<STR_LIT>' ] = value <EOL> @ property <EOL> def ikey ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in self . _values : <EOL> return self . _values [ '<STR_LIT>' ] <EOL> return self . _defaults [ '<STR_LIT>' ] <EOL> @ ikey . setter <EOL> def ikey ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value == self . _defaults [ '<STR_LIT>' ] and '<STR_LIT>' in self . _values : <EOL> del self . _values [ '<STR_LIT>' ] <EOL> else : <EOL> self . _values [ '<STR_LIT>' ] = value <EOL> @ property <EOL> def flags ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in self . _values : <EOL> return self . _values [ '<STR_LIT>' ] <EOL> return self . _defaults [ '<STR_LIT>' ] <EOL> @ flags . setter <EOL> def flags ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value == self . _defaults [ '<STR_LIT>' ] and '<STR_LIT>' in self . _values : <EOL> del self . _values [ '<STR_LIT>' ] <EOL> else : <EOL> self . _values [ '<STR_LIT>' ] = value <EOL> @ property <EOL> def device_id ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in self . _values : <EOL> return self . _values [ '<STR_LIT>' ] <EOL> return self . _defaults [ '<STR_LIT>' ] <EOL> @ device_id . setter <EOL> def device_id ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value == self . _defaults [ '<STR_LIT>' ] and '<STR_LIT>' in self . _values : <EOL> del self . _values [ '<STR_LIT>' ] <EOL> else : <EOL> self . _values [ '<STR_LIT>' ] = value <EOL> @ property <EOL> def os ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in self . _values : <EOL> return self . _values [ '<STR_LIT>' ] <EOL> return self . _defaults [ '<STR_LIT>' ] <EOL> @ os . setter <EOL> def os ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value == self . _defaults [ '<STR_LIT>' ] and '<STR_LIT>' in self . _values : <EOL> del self . _values [ '<STR_LIT>' ] <EOL> else : <EOL> self . _values [ '<STR_LIT>' ] = value <EOL> @ property <EOL> def os_ver ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in self . _values : <EOL> return self . _values [ '<STR_LIT>' ] <EOL> return self . _defaults [ '<STR_LIT>' ] <EOL> @ os_ver . setter <EOL> def os_ver ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value == self . _defaults [ '<STR_LIT>' ] and '<STR_LIT>' in self . _values : <EOL> del self . _values [ '<STR_LIT>' ] <EOL> else : <EOL> self . _values [ '<STR_LIT>' ] = value <EOL> @ property <EOL> def app_id ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in self . _values : <EOL> return self . _values [ '<STR_LIT>' ] <EOL> return self . _defaults [ '<STR_LIT>' ] <EOL> @ app_id . setter <EOL> def app_id ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value == self . _defaults [ '<STR_LIT>' ] and '<STR_LIT>' in self . _values : <EOL> del self . _values [ '<STR_LIT>' ] <EOL> else : <EOL> self . _values [ '<STR_LIT>' ] = value <EOL> @ property <EOL> def app_ver ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in self . _values : <EOL> return self . _values [ '<STR_LIT>' ] <EOL> return self . _defaults [ '<STR_LIT>' ] <EOL> @ app_ver . setter <EOL> def app_ver ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value == self . _defaults [ '<STR_LIT>' ] and '<STR_LIT>' in self . _values : <EOL> del self . _values [ '<STR_LIT>' ] <EOL> else : <EOL> self . _values [ '<STR_LIT>' ] = value <EOL> @ property <EOL> def user_id ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in self . _values : <EOL> return self . _values [ '<STR_LIT>' ] <EOL> return self . _defaults [ '<STR_LIT>' ] <EOL> @ user_id . setter <EOL> def user_id ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value == self . _defaults [ '<STR_LIT>' ] and '<STR_LIT>' in self . _values : <EOL> del self . _values [ '<STR_LIT>' ] <EOL> else : <EOL> self . _values [ '<STR_LIT>' ] = value <EOL> @ property <EOL> def tags ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in self . _values : <EOL> return self . _values [ '<STR_LIT>' ] <EOL>", "answer": "self . _values [ '<STR_LIT>' ] = copy . deepcopy ( self . _defaults [ '<STR_LIT>' ] )"}, {"prompt": "<s> from django . contrib import messages <EOL> from django . contrib . auth . decorators import login_required <EOL> from django . contrib . auth . models import User <EOL> from django . core . mail import mail_admins <EOL> from django . core . urlresolvers import reverse <EOL> from django . db . models import Q , Count <EOL> from django . http import HttpResponseForbidden , HttpResponse <EOL> from django . shortcuts import render , redirect , get_object_or_404 <EOL> from django . utils import simplejson as json <EOL> from haystack . query import SearchQuerySet <EOL> from taggit . models import Tag <EOL> from cab . forms import SnippetForm , SnippetFlagForm <EOL> from cab . models import Snippet , SnippetFlag , Language <EOL> from cab . utils import month_object_list , object_detail <EOL> def snippet_list ( request , queryset = None , ** kwargs ) : <EOL> if queryset is None : <EOL> queryset = Snippet . objects . all ( ) <EOL> return month_object_list ( <EOL> request , <EOL> queryset = queryset , <EOL> paginate_by = <NUM_LIT:20> , <EOL> ** kwargs <EOL> ) <EOL> def snippet_detail ( request , snippet_id ) : <EOL> return object_detail ( <EOL> request , <EOL> queryset = Snippet . objects . all ( ) , <EOL> object_id = snippet_id , <EOL> extra_context = { '<STR_LIT>' : SnippetFlagForm ( ) } , <EOL> ) <EOL> def download_snippet ( request , snippet_id ) : <EOL> snippet = get_object_or_404 ( Snippet , pk = snippet_id ) <EOL> response = HttpResponse ( snippet . code , mimetype = '<STR_LIT>' ) <EOL> response [ '<STR_LIT>' ] = '<STR_LIT>' % ( snippet . id , snippet . language . file_extension ) <EOL> response [ '<STR_LIT:Content-Type>' ] = snippet . language . mime_type <EOL> return response <EOL> def raw_snippet ( request , snippet_id ) : <EOL> snippet = get_object_or_404 ( Snippet , pk = snippet_id ) <EOL> response = HttpResponse ( snippet . code , mimetype = '<STR_LIT>' ) <EOL> response [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> return response <EOL> @ login_required <EOL> def rate_snippet ( request , snippet_id ) : <EOL> snippet = get_object_or_404 ( Snippet , pk = snippet_id ) <EOL> score = request . GET . get ( '<STR_LIT>' ) <EOL> if score and score in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> score = { '<STR_LIT>' : <NUM_LIT:1> , '<STR_LIT>' : - <NUM_LIT:1> } [ score ] <EOL> snippet . ratings . rate ( user = request . user , score = score ) <EOL> elif score == '<STR_LIT>' : <EOL> snippet . ratings . unrate ( request . user ) <EOL> return redirect ( snippet ) <EOL> @ login_required <EOL> def edit_snippet ( request , snippet_id = None , <EOL> template_name = '<STR_LIT>' ) : <EOL> if not request . user . is_active : <EOL> return HttpResponseForbidden ( ) <EOL> if snippet_id : <EOL> snippet = get_object_or_404 ( Snippet , pk = snippet_id ) <EOL> if request . user . id != snippet . author . id : <EOL> return HttpResponseForbidden ( ) <EOL> else : <EOL> template_name = '<STR_LIT>' <EOL> snippet = Snippet ( author = request . user , <EOL> language = Language . objects . get ( name = '<STR_LIT>' ) ) <EOL> if request . method == '<STR_LIT:POST>' : <EOL> form = SnippetForm ( instance = snippet , data = request . POST ) <EOL> if form . is_valid ( ) : <EOL> snippet = form . save ( ) <EOL> messages . info ( request , '<STR_LIT>' ) <EOL> return redirect ( snippet ) <EOL> else : <EOL> form = SnippetForm ( instance = snippet ) <EOL> return render ( request , template_name , { '<STR_LIT>' : form } ) <EOL> @ login_required <EOL> def flag_snippet ( request , snippet_id , template_name = '<STR_LIT>' ) : <EOL> snippet = get_object_or_404 ( Snippet , id = snippet_id ) <EOL> snippet_flag = SnippetFlag ( snippet = snippet , user = request . user ) <EOL> if request . method == '<STR_LIT:POST>' : <EOL> form = SnippetFlagForm ( request . POST , instance = snippet_flag ) <EOL> if form . is_valid ( ) : <EOL> snippet_flag = form . save ( ) <EOL> admin_link = request . build_absolute_uri ( <EOL> reverse ( '<STR_LIT>' ) <EOL> ) <EOL> mail_admins ( <EOL> '<STR_LIT>' % ( snippet . title ) , <EOL> '<STR_LIT>' % ( snippet_flag , admin_link ) , <EOL> fail_silently = True , <EOL> ) <EOL> messages . info ( request , '<STR_LIT>' ) <EOL> return redirect ( snippet ) <EOL> else : <EOL> if request . is_ajax ( ) : <EOL> return redirect ( snippet ) <EOL> messages . error ( request , '<STR_LIT>' ) <EOL> else : <EOL> form = SnippetFlagForm ( instance = snippet_flag ) <EOL> return render ( request , template_name , { <EOL> '<STR_LIT>' : form , <EOL> '<STR_LIT>' : snippet , <EOL> } ) <EOL> def author_snippets ( request , username ) : <EOL> user = get_object_or_404 ( User , username = username ) <EOL> snippet_qs = Snippet . objects . filter ( author = user ) <EOL>", "answer": "return snippet_list ("}, {"prompt": "<s> from django . conf . urls import * <EOL> from django . http import HttpResponseRedirect <EOL>", "answer": "from django_openid . registration import RegistrationConsumer"}, {"prompt": "<s> import sys <EOL> import os . path <EOL> sys . path . append ( os . path . abspath ( __file__ + \"<STR_LIT>\" ) ) <EOL> import _winreg <EOL> import windows <EOL> @ windows . hooks . RegOpenKeyExACallback <EOL> def open_reg_hook ( hKey , lpSubKey , ulOptions , samDesired , phkResult , real_function ) : <EOL> print ( \"<STR_LIT>\" . format ( hex ( hKey ) , lpSubKey . value ) ) <EOL> if \"<STR_LIT>\" in lpSubKey . value : <EOL> print ( \"<STR_LIT>\" ) <EOL>", "answer": "phkResult [ <NUM_LIT:0> ] = <NUM_LIT>"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from defcon . objects . font import Font <EOL> from fontMath import MathKerning <EOL> from fontMath . mathKerning import MathKerning <EOL> from mutatorMath . ufo . document import DesignSpaceDocumentWriter , DesignSpaceDocumentReader <EOL> from mutatorMath . objects . location import Location <EOL> import os , sys , shutil <EOL> def testingProgressFunc ( state , action , text , tick ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> def addGlyphs ( font , offset = <NUM_LIT:0> ) : <EOL> for n in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> font . newGlyph ( n ) <EOL> g = font [ n ] <EOL> p = g . getPen ( ) <EOL> p . moveTo ( ( <NUM_LIT:100> + offset , <NUM_LIT:100> + offset ) ) <EOL> p . lineTo ( ( <NUM_LIT:200> + offset , <NUM_LIT:200> + offset ) ) <EOL> p . lineTo ( ( offset , <NUM_LIT:100> + offset ) ) <EOL> p . closePath ( ) <EOL> def makeTestFonts ( rootPath ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path1 = os . path . join ( rootPath , \"<STR_LIT>\" ) <EOL> path2 = os . path . join ( rootPath , \"<STR_LIT>\" ) <EOL> path3 = os . path . join ( rootPath , \"<STR_LIT>\" ) <EOL> f1 = Font ( ) <EOL> addGlyphs ( f1 , <NUM_LIT:0> ) <EOL> f1 . info . unitsPerEm = <NUM_LIT:1000> <EOL> f1 . kerning [ ( '<STR_LIT>' , '<STR_LIT>' ) ] = - <NUM_LIT:100> <EOL> f2 = Font ( ) <EOL> addGlyphs ( f2 , <NUM_LIT> ) <EOL> f2 . info . unitsPerEm = <NUM_LIT> <EOL> f2 . kerning [ ( '<STR_LIT>' , '<STR_LIT>' ) ] = - <NUM_LIT:200> <EOL> f1 . save ( path1 , <NUM_LIT:3> ) <EOL> f2 . save ( path2 , <NUM_LIT:3> ) <EOL> return path1 , path2 , path3 <EOL> def testMutingOptions ( rootPath , cleanUp = True ) : <EOL> path1 , path2 , path3 = makeTestFonts ( rootPath ) <EOL> documentPath = os . path . join ( rootPath , '<STR_LIT>' ) <EOL> logPath = os . path . join ( rootPath , \"<STR_LIT>\" ) <EOL> try : <EOL> testLogFile = open ( logPath , '<STR_LIT:w>' ) <EOL> testLogFile . close ( ) <EOL> except : <EOL> print \"<STR_LIT>\" <EOL> doc = DesignSpaceDocumentWriter ( documentPath , verbose = True ) <EOL> doc . addSource ( <EOL> path1 , <EOL> name = \"<STR_LIT>\" , <EOL> location = dict ( width = <NUM_LIT:0> ) , <EOL> copyLib = True , <EOL> copyGroups = True , <EOL> copyInfo = True , <EOL> copyFeatures = True , <EOL> muteKerning = True <EOL> ) <EOL> doc . addSource ( <EOL> path2 , <EOL> name = \"<STR_LIT>\" , <EOL> location = dict ( width = <NUM_LIT:1000> ) , <EOL> copyLib = False , <EOL> copyGroups = False , <EOL> copyInfo = False , <EOL> copyFeatures = False , <EOL> muteInfo = True , <EOL> mutedGlyphNames = [ '<STR_LIT>' ] <EOL> ) <EOL> doc . startInstance ( fileName = path3 , <EOL> familyName = \"<STR_LIT>\" , <EOL> styleName = \"<STR_LIT>\" , <EOL> location = dict ( width = <NUM_LIT> ) <EOL> ) <EOL> doc . writeGlyph ( '<STR_LIT>' , mute = True ) <EOL> doc . writeKerning ( ) <EOL> doc . writeInfo ( ) <EOL> doc . endInstance ( ) <EOL> doc . save ( ) <EOL> doc = DesignSpaceDocumentReader ( documentPath , <NUM_LIT:2> , roundGeometry = True , verbose = True , logPath = logPath , progressFunc = testingProgressFunc ) <EOL> doc . process ( makeGlyphs = True , makeKerning = True , makeInfo = True ) <EOL> m1 = Font ( path1 ) <EOL> m2 = Font ( path2 ) <EOL> r = Font ( path3 ) <EOL> assert r [ '<STR_LIT>' ] . bounds == m1 [ '<STR_LIT>' ] . bounds <EOL> assert \"<STR_LIT>\" not in r <EOL> assert r . info . unitsPerEm == m1 . info . unitsPerEm <EOL> assert r . kerning [ ( '<STR_LIT>' , '<STR_LIT>' ) ] == m2 . kerning [ ( '<STR_LIT>' , '<STR_LIT>' ) ] <EOL> if cleanUp : <EOL>", "answer": "try :"}, {"prompt": "<s> import xml . sax . saxutils <EOL> xml_escape = xml . sax . saxutils . escape <EOL> xml_unescape = xml . sax . saxutils . unescape <EOL> escape_other = { <EOL> '<STR_LIT:\">' : '<STR_LIT>' , <EOL> } <EOL>", "answer": "unescape_other = {"}, {"prompt": "<s> from __future__ import absolute_import , division , print_function <EOL> import binascii <EOL> import pytest <EOL> from cryptography . exceptions import _Reasons <EOL> from cryptography . hazmat . primitives import ciphers <EOL> from cryptography . hazmat . primitives . ciphers . algorithms import ( <EOL> AES , ARC4 , Blowfish , CAST5 , Camellia , IDEA , SEED , TripleDES <EOL> ) <EOL> from cryptography . hazmat . primitives . ciphers . modes import ECB <EOL> from ... utils import raises_unsupported_algorithm <EOL> class TestAES ( object ) : <EOL> @ pytest . mark . parametrize ( ( \"<STR_LIT:key>\" , \"<STR_LIT>\" ) , [ <EOL> ( b\"<STR_LIT:0>\" * <NUM_LIT:32> , <NUM_LIT> ) , <EOL> ( b\"<STR_LIT:0>\" * <NUM_LIT> , <NUM_LIT> ) , <EOL> ( b\"<STR_LIT:0>\" * <NUM_LIT:64> , <NUM_LIT> ) , <EOL> ] ) <EOL> def test_key_size ( self , key , keysize ) : <EOL> cipher = AES ( binascii . unhexlify ( key ) ) <EOL> assert cipher . key_size == keysize <EOL> def test_invalid_key_size ( self ) : <EOL> with pytest . raises ( ValueError ) : <EOL> AES ( binascii . unhexlify ( b\"<STR_LIT:0>\" * <NUM_LIT:12> ) ) <EOL> class TestCamellia ( object ) : <EOL> @ pytest . mark . parametrize ( ( \"<STR_LIT:key>\" , \"<STR_LIT>\" ) , [ <EOL> ( b\"<STR_LIT:0>\" * <NUM_LIT:32> , <NUM_LIT> ) , <EOL> ( b\"<STR_LIT:0>\" * <NUM_LIT> , <NUM_LIT> ) , <EOL> ( b\"<STR_LIT:0>\" * <NUM_LIT:64> , <NUM_LIT> ) , <EOL> ] ) <EOL> def test_key_size ( self , key , keysize ) : <EOL> cipher = Camellia ( binascii . unhexlify ( key ) ) <EOL> assert cipher . key_size == keysize <EOL> def test_invalid_key_size ( self ) : <EOL> with pytest . raises ( ValueError ) : <EOL> Camellia ( binascii . unhexlify ( b\"<STR_LIT:0>\" * <NUM_LIT:12> ) ) <EOL> class TestTripleDES ( object ) : <EOL> @ pytest . mark . parametrize ( \"<STR_LIT:key>\" , [ <EOL> b\"<STR_LIT:0>\" * <NUM_LIT:16> , <EOL> b\"<STR_LIT:0>\" * <NUM_LIT:32> , <EOL> b\"<STR_LIT:0>\" * <NUM_LIT> , <EOL> ] ) <EOL> def test_key_size ( self , key ) : <EOL> cipher = TripleDES ( binascii . unhexlify ( key ) ) <EOL> assert cipher . key_size == <NUM_LIT> <EOL> def test_invalid_key_size ( self ) : <EOL> with pytest . raises ( ValueError ) : <EOL> TripleDES ( binascii . unhexlify ( b\"<STR_LIT:0>\" * <NUM_LIT:12> ) ) <EOL> class TestBlowfish ( object ) : <EOL> @ pytest . mark . parametrize ( ( \"<STR_LIT:key>\" , \"<STR_LIT>\" ) , [ <EOL> ( b\"<STR_LIT:0>\" * ( keysize // <NUM_LIT:4> ) , keysize ) for keysize in range ( <NUM_LIT:32> , <NUM_LIT> , <NUM_LIT:8> ) <EOL> ] ) <EOL> def test_key_size ( self , key , keysize ) : <EOL> cipher = Blowfish ( binascii . unhexlify ( key ) ) <EOL> assert cipher . key_size == keysize <EOL> def test_invalid_key_size ( self ) : <EOL> with pytest . raises ( ValueError ) : <EOL> Blowfish ( binascii . unhexlify ( b\"<STR_LIT:0>\" * <NUM_LIT:6> ) ) <EOL> class TestCAST5 ( object ) : <EOL> @ pytest . mark . parametrize ( ( \"<STR_LIT:key>\" , \"<STR_LIT>\" ) , [ <EOL> ( b\"<STR_LIT:0>\" * ( keysize // <NUM_LIT:4> ) , keysize ) for keysize in range ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT:8> ) <EOL> ] ) <EOL> def test_key_size ( self , key , keysize ) : <EOL> cipher = CAST5 ( binascii . unhexlify ( key ) ) <EOL> assert cipher . key_size == keysize <EOL> def test_invalid_key_size ( self ) : <EOL> with pytest . raises ( ValueError ) : <EOL> CAST5 ( binascii . unhexlify ( b\"<STR_LIT:0>\" * <NUM_LIT> ) ) <EOL> class TestARC4 ( object ) : <EOL> @ pytest . mark . parametrize ( ( \"<STR_LIT:key>\" , \"<STR_LIT>\" ) , [ <EOL> ( b\"<STR_LIT:0>\" * <NUM_LIT:10> , <NUM_LIT> ) , <EOL> ( b\"<STR_LIT:0>\" * <NUM_LIT> , <NUM_LIT> ) , <EOL> ( b\"<STR_LIT:0>\" * <NUM_LIT:16> , <NUM_LIT:64> ) , <EOL> ( b\"<STR_LIT:0>\" * <NUM_LIT:20> , <NUM_LIT> ) , <EOL> ( b\"<STR_LIT:0>\" * <NUM_LIT:32> , <NUM_LIT> ) , <EOL> ( b\"<STR_LIT:0>\" * <NUM_LIT> , <NUM_LIT> ) , <EOL> ( b\"<STR_LIT:0>\" * <NUM_LIT:64> , <NUM_LIT> ) , <EOL> ] ) <EOL> def test_key_size ( self , key , keysize ) : <EOL> cipher = ARC4 ( binascii . unhexlify ( key ) ) <EOL> assert cipher . key_size == keysize <EOL> def test_invalid_key_size ( self ) : <EOL> with pytest . raises ( ValueError ) : <EOL> ARC4 ( binascii . unhexlify ( b\"<STR_LIT:0>\" * <NUM_LIT> ) ) <EOL> class TestIDEA ( object ) : <EOL> def test_key_size ( self ) : <EOL> cipher = IDEA ( b\"<STR_LIT:\\x00>\" * <NUM_LIT:16> ) <EOL> assert cipher . key_size == <NUM_LIT> <EOL> def test_invalid_key_size ( self ) : <EOL> with pytest . raises ( ValueError ) : <EOL> IDEA ( b\"<STR_LIT:\\x00>\" * <NUM_LIT> ) <EOL> class TestSEED ( object ) : <EOL> def test_key_size ( self ) : <EOL>", "answer": "cipher = SEED ( b\"<STR_LIT:\\x00>\" * <NUM_LIT:16> )"}, {"prompt": "<s> from datetime import datetime <EOL>", "answer": "from test_ella . cases import RedisTestCase as TestCase"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from cloudcafe . compute . common . behaviors import BaseComputeBehavior <EOL> from cloudcafe . compute . common . types import NovaServerStatusTypes as ServerStates <EOL> from cloudcafe . common . tools . datagen import rand_name <EOL> from cloudcafe . compute . common . exceptions import TimeoutException , BuildErrorException , RequiredResourceException <EOL> class VolumeServerBehaviors ( BaseComputeBehavior ) : <EOL> def __init__ ( self , servers_client , images_client , servers_config , <EOL> images_config , flavors_config , server_behaviors , <EOL> boot_from_volume_client = None , security_groups_config = None ) : <EOL> super ( VolumeServerBehaviors , self ) . __init__ ( ) <EOL> self . config = servers_config <EOL> self . servers_client = servers_client <EOL> self . images_client = images_client <EOL> self . images_config = images_config <EOL> self . flavors_config = flavors_config <EOL> self . server_behaviors = server_behaviors <EOL> self . boot_from_volume_client = boot_from_volume_client <EOL> self . security_groups_config = security_groups_config <EOL> def create_active_server ( <EOL> self , name = None , image_ref = None , flavor_ref = None , <EOL> personality = None , user_data = None , metadata = None , <EOL> accessIPv4 = None , accessIPv6 = None , disk_config = None , <EOL> networks = None , key_name = None , config_drive = None , <EOL> scheduler_hints = None , admin_pass = None , max_count = None , <EOL> min_count = None , block_device_mapping = None , block_device = None , <EOL> security_groups = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if name is None : <EOL> name = rand_name ( '<STR_LIT>' ) <EOL> if ( ( image_ref is None ) and ( block_device_mapping is None ) and ( <EOL> block_device is None ) ) : <EOL> image_ref = self . images_config . primary_image <EOL> if flavor_ref is None : <EOL> flavor_ref = self . flavors_config . primary_flavor <EOL> if self . config . default_network : <EOL> networks = [ { '<STR_LIT>' : self . config . default_network } ] <EOL>", "answer": "default_groups = None"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from refo import Plus , Question <EOL> from quepy . dsl import HasKeyword <EOL> from quepy . parsing import Lemma , Lemmas , Pos , QuestionTemplate , Particle <EOL> from dsl import IsMovie , NameOf , IsPerson , DirectedBy , LabelOf , DurationOf , HasActor , HasName , ReleaseDateOf , DirectorOf , StarsIn , DefinitionOf <EOL> nouns = Plus ( Pos ( \"<STR_LIT>\" ) | Pos ( \"<STR_LIT>\" ) | Pos ( \"<STR_LIT>\" ) | Pos ( \"<STR_LIT>\" ) ) <EOL> class Movie ( Particle ) : <EOL> regex = Question ( Pos ( \"<STR_LIT>\" ) ) + nouns <EOL> def interpret ( self , match ) : <EOL> name = match . words . tokens <EOL> return IsMovie ( ) + HasName ( name ) <EOL> class Actor ( Particle ) : <EOL> regex = nouns <EOL> def interpret ( self , match ) : <EOL> name = match . words . tokens <EOL>", "answer": "return IsPerson ( ) + HasKeyword ( name )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import datetime <EOL> import pytz <EOL> from ndscheduler import settings <EOL> from ndscheduler . core . datastore . providers import base <EOL> class DatastoreSqlite ( base . DatastoreBase ) : <EOL> @ classmethod <EOL> def get_db_url ( cls ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in settings . DATABASE_CONFIG_DICT : <EOL> file_path = settings . DATABASE_CONFIG_DICT [ '<STR_LIT>' ] <EOL>", "answer": "else :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function <EOL> import numpy as np <EOL> import numpy . linalg as L <EOL> from statsmodels . base . model import LikelihoodModelResults <EOL> from statsmodels . tools . decorators import cache_readonly <EOL> class Unit ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , endog , exog_fe , exog_re ) : <EOL> self . Y = endog <EOL> self . X = exog_fe <EOL> self . Z = exog_re <EOL> self . n = endog . shape [ <NUM_LIT:0> ] <EOL> def _compute_S ( self , D , sigma ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . S = ( np . identity ( self . n ) * sigma ** <NUM_LIT:2> + <EOL> np . dot ( self . Z , np . dot ( D , self . Z . T ) ) ) <EOL> def _compute_W ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . W = L . inv ( self . S ) <EOL> def compute_P ( self , Sinv ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> t = np . dot ( self . W , self . X ) <EOL> self . P = self . W - np . dot ( np . dot ( t , Sinv ) , t . T ) <EOL> def _compute_r ( self , alpha ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . r = self . Y - np . dot ( self . X , alpha ) <EOL> def _compute_b ( self , D ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . b = np . dot ( D , np . dot ( np . dot ( self . Z . T , self . W ) , self . r ) ) <EOL> def fit ( self , a , D , sigma ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _compute_S ( D , sigma ) <EOL> self . _compute_W ( ) <EOL> self . _compute_r ( a ) <EOL> self . _compute_b ( D ) <EOL> def compute_xtwy ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return np . dot ( np . dot ( self . W , self . Y ) , self . X ) <EOL> def compute_xtwx ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return np . dot ( np . dot ( self . X . T , self . W ) , self . X ) <EOL> def cov_random ( self , D , Sinv = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if Sinv is not None : <EOL> self . compute_P ( Sinv ) <EOL> t = np . dot ( self . Z , D ) <EOL> return D - np . dot ( np . dot ( t . T , self . P ) , t ) <EOL> def logL ( self , a , ML = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ML : <EOL> return ( np . log ( L . det ( self . W ) ) - ( self . r * np . dot ( self . W , self . r ) ) . sum ( ) ) / <NUM_LIT> <EOL> else : <EOL> if a is None : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> r = self . Y - np . dot ( self . X , a ) <EOL> return ( np . log ( L . det ( self . W ) ) - ( r * np . dot ( self . W , r ) ) . sum ( ) ) / <NUM_LIT> <EOL> def deviance ( self , ML = False ) : <EOL> '''<STR_LIT>''' <EOL> return - <NUM_LIT:2> * self . logL ( ML = ML ) <EOL> class OneWayMixed ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , units ) : <EOL> self . units = units <EOL> self . m = len ( self . units ) <EOL> self . n_units = self . m <EOL> self . N = sum ( unit . X . shape [ <NUM_LIT:0> ] for unit in self . units ) <EOL> self . nobs = self . N <EOL> d = self . units [ <NUM_LIT:0> ] . X <EOL> self . p = d . shape [ <NUM_LIT:1> ] <EOL> self . k_exog_fe = self . p <EOL> self . a = np . zeros ( self . p , np . float64 ) <EOL> d = self . units [ <NUM_LIT:0> ] . Z <EOL> self . q = d . shape [ <NUM_LIT:1> ] <EOL> self . k_exog_re = self . q <EOL> self . D = np . zeros ( ( self . q , ) * <NUM_LIT:2> , np . float64 ) <EOL> self . sigma = <NUM_LIT:1.> <EOL> self . dev = np . inf <EOL> def _compute_a ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for unit in self . units : <EOL> unit . fit ( self . a , self . D , self . sigma ) <EOL> S = sum ( [ unit . compute_xtwx ( ) for unit in self . units ] ) <EOL> Y = sum ( [ unit . compute_xtwy ( ) for unit in self . units ] ) <EOL> self . Sinv = L . pinv ( S ) <EOL> self . a = np . dot ( self . Sinv , Y ) <EOL> def _compute_sigma ( self , ML = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> sigmasq = <NUM_LIT:0.> <EOL> for unit in self . units : <EOL> if ML : <EOL> W = unit . W <EOL> else : <EOL> unit . compute_P ( self . Sinv ) <EOL> W = unit . P <EOL> t = unit . r - np . dot ( unit . Z , unit . b ) <EOL> sigmasq += np . power ( t , <NUM_LIT:2> ) . sum ( ) <EOL> sigmasq += self . sigma ** <NUM_LIT:2> * np . trace ( np . identity ( unit . n ) - <EOL> self . sigma ** <NUM_LIT:2> * W ) <EOL> self . sigma = np . sqrt ( sigmasq / self . N ) <EOL> def _compute_D ( self , ML = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> D = <NUM_LIT:0.> <EOL> for unit in self . units : <EOL> if ML : <EOL> W = unit . W <EOL> else : <EOL> unit . compute_P ( self . Sinv ) <EOL> W = unit . P <EOL> D += np . multiply . outer ( unit . b , unit . b ) <EOL> t = np . dot ( unit . Z , self . D ) <EOL> D += self . D - np . dot ( np . dot ( t . T , W ) , t ) <EOL> self . D = D / self . m <EOL> def cov_fixed ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . Sinv <EOL> def cov_random ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . D <EOL> @ property <EOL> def params ( self ) : <EOL> '''<STR_LIT>''' <EOL> return self . a <EOL> @ property <EOL> def params_random_units ( self ) : <EOL> '''<STR_LIT>''' <EOL> return np . array ( [ unit . b for unit in self . units ] ) <EOL> def cov_params ( self ) : <EOL> '''<STR_LIT>''' <EOL> return self . cov_fixed ( ) <EOL> @ property <EOL> def bse ( self ) : <EOL> '''<STR_LIT>''' <EOL> return np . sqrt ( np . diag ( self . cov_params ( ) ) ) <EOL> def deviance ( self , ML = False ) : <EOL> '''<STR_LIT>''' <EOL> return - <NUM_LIT:2> * self . logL ( ML = ML ) <EOL> def logL ( self , ML = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> logL = <NUM_LIT:0.> <EOL> for unit in self . units : <EOL> logL += unit . logL ( a = self . a , ML = ML ) <EOL> if not ML : <EOL> logL += np . log ( L . det ( self . Sinv ) ) / <NUM_LIT:2> <EOL> return logL <EOL> def initialize ( self ) : <EOL> S = sum ( [ np . dot ( unit . X . T , unit . X ) for unit in self . units ] ) <EOL> Y = sum ( [ np . dot ( unit . X . T , unit . Y ) for unit in self . units ] ) <EOL> self . a = L . lstsq ( S , Y ) [ <NUM_LIT:0> ] <EOL> D = <NUM_LIT:0> <EOL> t = <NUM_LIT:0> <EOL> sigmasq = <NUM_LIT:0> <EOL> for unit in self . units : <EOL> unit . r = unit . Y - np . dot ( unit . X , self . a ) <EOL> if self . q > <NUM_LIT:1> : <EOL> unit . b = L . lstsq ( unit . Z , unit . r ) [ <NUM_LIT:0> ] <EOL> else : <EOL> Z = unit . Z . reshape ( ( unit . Z . shape [ <NUM_LIT:0> ] , <NUM_LIT:1> ) ) <EOL> unit . b = L . lstsq ( Z , unit . r ) [ <NUM_LIT:0> ] <EOL> sigmasq += ( np . power ( unit . Y , <NUM_LIT:2> ) . sum ( ) - <EOL> ( self . a * np . dot ( unit . X . T , unit . Y ) ) . sum ( ) - <EOL> ( unit . b * np . dot ( unit . Z . T , unit . r ) ) . sum ( ) ) <EOL> D += np . multiply . outer ( unit . b , unit . b ) <EOL> t += L . pinv ( np . dot ( unit . Z . T , unit . Z ) ) <EOL> self . df_resid = ( self . N - ( self . m - <NUM_LIT:1> ) * self . q - self . p ) <EOL> sigmasq /= ( self . N - ( self . m - <NUM_LIT:1> ) * self . q - self . p ) <EOL>", "answer": "self . sigma = np . sqrt ( sigmasq )"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> from pysb . testing import * <EOL> from pysb . core import * <EOL> from functools import partial <EOL> def test_component_names_valid ( ) : <EOL> for name in '<STR_LIT:a>' , '<STR_LIT:B>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:_>' , '<STR_LIT>' , '<STR_LIT>' : <EOL> c = Component ( name , _export = False ) <EOL> eq_ ( c . name , name ) <EOL> def test_component_names_invalid ( ) : <EOL> for name in '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' : <EOL> assert_raises ( InvalidComponentNameError , Component , name , _export = False ) <EOL> def test_monomer ( ) : <EOL> sites = [ '<STR_LIT:x>' , '<STR_LIT:y>' , '<STR_LIT:z>' ] <EOL> states = { '<STR_LIT:y>' : [ '<STR_LIT:foo>' , '<STR_LIT:bar>' , '<STR_LIT>' ] , '<STR_LIT:x>' : [ '<STR_LIT:e>' ] } <EOL> m = Monomer ( '<STR_LIT:A>' , sites , states , _export = False ) <EOL> assert_equal ( m . sites , sites ) <EOL> assert_equal ( m . site_states , states ) <EOL> assert_equal ( type ( m ( ) ) , MonomerPattern ) <EOL> assert_raises ( ValueError , Monomer , '<STR_LIT:A>' , '<STR_LIT:x>' , _export = False ) <EOL> assert_raises ( Exception , Monomer , '<STR_LIT:A>' , '<STR_LIT:x>' , '<STR_LIT:x>' , _export = False ) <EOL> assert_raises ( Exception , Monomer , '<STR_LIT:A>' , [ '<STR_LIT:x>' ] , { '<STR_LIT:y>' : [ '<STR_LIT:a>' ] } , _export = False ) <EOL> assert_raises ( Exception , Monomer , '<STR_LIT:A>' , [ '<STR_LIT:x>' ] , { '<STR_LIT:x>' : [ <NUM_LIT:1> ] } , _export = False ) <EOL> @ with_model <EOL> def test_monomer_model ( ) : <EOL> Monomer ( '<STR_LIT:A>' ) <EOL> ok_ ( A in model . monomers ) <EOL>", "answer": "ok_ ( A in model . all_components ( ) )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from SublimeLinter . lint import Linter , util <EOL> class Govet ( Linter ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> syntax = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cmd = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> regex = r'<STR_LIT>' <EOL>", "answer": "tempfile_suffix = '<STR_LIT>'"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pypy . interpreter . error import OperationError <EOL> from pypy . objspace . std . register_all import register_all <EOL> from pypy . rlib . rarithmetic import LONG_BIT <EOL> from pypy . objspace . std . longobject import SHIFT as long_bits <EOL> from pypy . objspace . std . objspace import StdObjSpace <EOL> from pypy . interpreter . special import Ellipsis <EOL> from pypy . interpreter . pycode import PyCode <EOL> from pypy . interpreter import gateway , unicodehelper <EOL> from pypy . rlib . rstruct import ieee <EOL> from pypy . objspace . std . boolobject import W_BoolObject <EOL> from pypy . objspace . std . complexobject import W_ComplexObject <EOL> from pypy . objspace . std . intobject import W_IntObject <EOL> from pypy . objspace . std . floatobject import W_FloatObject <EOL> from pypy . objspace . std . tupleobject import W_TupleObject <EOL> from pypy . objspace . std . listobject import W_ListObject <EOL> from pypy . objspace . std . dictmultiobject import W_DictMultiObject <EOL> from pypy . objspace . std . stringobject import W_StringObject <EOL> from pypy . objspace . std . ropeobject import W_RopeObject <EOL> from pypy . objspace . std . typeobject import W_TypeObject <EOL> from pypy . objspace . std . longobject import W_LongObject <EOL> from pypy . objspace . std . noneobject import W_NoneObject <EOL> from pypy . objspace . std . unicodeobject import W_UnicodeObject <EOL> import longobject <EOL> from pypy . module . marshal . interp_marshal import register <EOL> TYPE_NULL = '<STR_LIT:0>' <EOL> TYPE_NONE = '<STR_LIT:N>' <EOL> TYPE_FALSE = '<STR_LIT:F>' <EOL> TYPE_TRUE = '<STR_LIT:T>' <EOL> TYPE_STOPITER = '<STR_LIT:S>' <EOL> TYPE_ELLIPSIS = '<STR_LIT:.>' <EOL> TYPE_INT = '<STR_LIT:i>' <EOL> TYPE_INT64 = '<STR_LIT:I>' <EOL> TYPE_FLOAT = '<STR_LIT:f>' <EOL> TYPE_BINARY_FLOAT = '<STR_LIT:g>' <EOL> TYPE_COMPLEX = '<STR_LIT:x>' <EOL> TYPE_BINARY_COMPLEX = '<STR_LIT:y>' <EOL> TYPE_LONG = '<STR_LIT:l>' <EOL> TYPE_STRING = '<STR_LIT:s>' <EOL> TYPE_INTERNED = '<STR_LIT:t>' <EOL> TYPE_STRINGREF = '<STR_LIT:R>' <EOL> TYPE_TUPLE = '<STR_LIT:(>' <EOL> TYPE_LIST = '<STR_LIT:[>' <EOL> TYPE_DICT = '<STR_LIT:{>' <EOL> TYPE_CODE = '<STR_LIT:c>' <EOL> TYPE_UNICODE = '<STR_LIT:u>' <EOL> TYPE_UNKNOWN = '<STR_LIT:?>' <EOL> TYPE_SET = '<STR_LIT:<>' <EOL> TYPE_FROZENSET = '<STR_LIT:>>' <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> handled_by_any = [ ] <EOL> def raise_exception ( space , msg ) : <EOL> raise OperationError ( space . w_ValueError , space . wrap ( msg ) ) <EOL> def marshal_w__None ( space , w_none , m ) : <EOL> m . atom ( TYPE_NONE ) <EOL> def unmarshal_None ( space , u , tc ) : <EOL> return space . w_None <EOL> register ( TYPE_NONE , unmarshal_None ) <EOL> def marshal_w__Bool ( space , w_bool , m ) : <EOL> if w_bool . boolval : <EOL> m . atom ( TYPE_TRUE ) <EOL> else : <EOL> m . atom ( TYPE_FALSE ) <EOL> def unmarshal_Bool ( space , u , tc ) : <EOL> if tc == TYPE_TRUE : <EOL> return space . w_True <EOL> else : <EOL> return space . w_False <EOL> register ( TYPE_TRUE + TYPE_FALSE , unmarshal_Bool ) <EOL> def marshal_w__Type ( space , w_type , m ) : <EOL> if not space . is_w ( w_type , space . w_StopIteration ) : <EOL> raise_exception ( space , \"<STR_LIT>\" ) <EOL> m . atom ( TYPE_STOPITER ) <EOL> def unmarshal_Type ( space , u , tc ) : <EOL> return space . w_StopIteration <EOL> register ( TYPE_STOPITER , unmarshal_Type ) <EOL> def marshal_w_Ellipsis ( space , w_ellipsis , m ) : <EOL> m . atom ( TYPE_ELLIPSIS ) <EOL> StdObjSpace . MM . marshal_w . register ( marshal_w_Ellipsis , Ellipsis ) <EOL> def unmarshal_Ellipsis ( space , u , tc ) : <EOL> return space . w_Ellipsis <EOL> register ( TYPE_ELLIPSIS , unmarshal_Ellipsis ) <EOL> def marshal_w__Int ( space , w_int , m ) : <EOL> if LONG_BIT == <NUM_LIT:32> : <EOL> m . atom_int ( TYPE_INT , w_int . intval ) <EOL> else : <EOL> y = w_int . intval >> <NUM_LIT> <EOL> if y and y != - <NUM_LIT:1> : <EOL> m . atom_int64 ( TYPE_INT64 , w_int . intval ) <EOL> else : <EOL> m . atom_int ( TYPE_INT , w_int . intval ) <EOL> def unmarshal_Int ( space , u , tc ) : <EOL> return space . newint ( u . get_int ( ) ) <EOL> register ( TYPE_INT , unmarshal_Int ) <EOL> def unmarshal_Int64 ( space , u , tc ) : <EOL> if LONG_BIT >= <NUM_LIT:64> : <EOL> lo = u . get_int ( ) & ( <NUM_LIT:2> ** <NUM_LIT:32> - <NUM_LIT:1> ) <EOL> hi = u . get_int ( ) <EOL> return space . newint ( ( hi << <NUM_LIT:32> ) | lo ) <EOL> else : <EOL> lshift = longobject . lshift__Long_Long <EOL> longor = longobject . or__Long_Long <EOL> lo1 = space . newlong ( u . get_short ( ) & <NUM_LIT> ) <EOL> lo2 = space . newlong ( u . get_short ( ) & <NUM_LIT> ) <EOL> res = space . newlong ( u . get_int ( ) ) <EOL> nbits = space . newlong ( <NUM_LIT:16> ) <EOL> res = lshift ( space , res , nbits ) <EOL> res = longor ( space , res , lo2 ) <EOL> res = lshift ( space , res , nbits ) <EOL> res = longor ( space , res , lo1 ) <EOL> return res <EOL> register ( TYPE_INT64 , unmarshal_Int64 ) <EOL> def pack_float ( f ) : <EOL> result = [ ] <EOL> ieee . pack_float ( result , f , <NUM_LIT:8> , False ) <EOL> return '<STR_LIT>' . join ( result ) <EOL> def unpack_float ( s ) : <EOL> return ieee . unpack_float ( s , False ) <EOL> def marshal_w__Float ( space , w_float , m ) : <EOL> if m . version > <NUM_LIT:1> : <EOL> m . start ( TYPE_BINARY_FLOAT ) <EOL> m . put ( pack_float ( w_float . floatval ) ) <EOL> else : <EOL> m . start ( TYPE_FLOAT ) <EOL> m . put_pascal ( space . str_w ( space . repr ( w_float ) ) ) <EOL> def unmarshal_Float ( space , u , tc ) : <EOL> return space . call_function ( space . builtin . get ( '<STR_LIT:float>' ) , <EOL> space . wrap ( u . get_pascal ( ) ) ) <EOL> register ( TYPE_FLOAT , unmarshal_Float ) <EOL> def unmarshal_Float_bin ( space , u , tc ) : <EOL> return space . newfloat ( unpack_float ( u . get ( <NUM_LIT:8> ) ) ) <EOL> register ( TYPE_BINARY_FLOAT , unmarshal_Float_bin ) <EOL> def marshal_w__Complex ( space , w_complex , m ) : <EOL> if m . version > <NUM_LIT:1> : <EOL> m . start ( TYPE_BINARY_COMPLEX ) <EOL> m . put ( pack_float ( w_complex . realval ) ) <EOL> m . put ( pack_float ( w_complex . imagval ) ) <EOL> else : <EOL> w_real = space . wrap ( w_complex . realval ) <EOL> w_imag = space . wrap ( w_complex . imagval ) <EOL> m . start ( TYPE_COMPLEX ) <EOL> m . put_pascal ( space . str_w ( space . repr ( w_real ) ) ) <EOL> m . put_pascal ( space . str_w ( space . repr ( w_imag ) ) ) <EOL> def unmarshal_Complex ( space , u , tc ) : <EOL> w_real = space . call_function ( space . builtin . get ( '<STR_LIT:float>' ) , <EOL> space . wrap ( u . get_pascal ( ) ) ) <EOL> w_imag = space . call_function ( space . builtin . get ( '<STR_LIT:float>' ) , <EOL> space . wrap ( u . get_pascal ( ) ) ) <EOL> w_t = space . builtin . get ( '<STR_LIT>' ) <EOL> return space . call_function ( w_t , w_real , w_imag ) <EOL> register ( TYPE_COMPLEX , unmarshal_Complex ) <EOL> def unmarshal_Complex_bin ( space , u , tc ) : <EOL> real = unpack_float ( u . get ( <NUM_LIT:8> ) ) <EOL> imag = unpack_float ( u . get ( <NUM_LIT:8> ) ) <EOL> return space . newcomplex ( real , imag ) <EOL> register ( TYPE_BINARY_COMPLEX , unmarshal_Complex_bin ) <EOL> def marshal_w__Long ( space , w_long , m ) : <EOL> from pypy . rlib . rbigint import rbigint <EOL> m . start ( TYPE_LONG ) <EOL> if long_bits != <NUM_LIT:15> : <EOL> SHIFT = <NUM_LIT:15> <EOL> MASK = ( <NUM_LIT:1> << SHIFT ) - <NUM_LIT:1> <EOL> BIGMASK = rbigint . fromint ( MASK ) <EOL> num = w_long . num <EOL> sign = num . sign <EOL> num = num . abs ( ) <EOL> ints = [ ] <EOL> while num . tobool ( ) : <EOL> next = num . and_ ( BIGMASK ) . toint ( ) <EOL> ints . append ( next ) <EOL> num = num . rshift ( SHIFT ) <EOL> m . put_int ( len ( ints ) * sign ) <EOL> for i in ints : <EOL> m . put_short ( i ) <EOL> return <EOL> lng = len ( w_long . num . digits ) <EOL> if w_long . num . sign < <NUM_LIT:0> : <EOL> m . put_int ( - lng ) <EOL> else : <EOL> m . put_int ( lng ) <EOL> for digit in w_long . num . digits : <EOL> m . put_short ( digit ) <EOL> def unmarshal_Long ( space , u , tc ) : <EOL> from pypy . rlib . rbigint import rbigint <EOL> lng = u . get_int ( ) <EOL> if lng < <NUM_LIT:0> : <EOL> sign = - <NUM_LIT:1> <EOL> lng = - lng <EOL> elif lng > <NUM_LIT:0> : <EOL> sign = <NUM_LIT:1> <EOL> else : <EOL> sign = <NUM_LIT:0> <EOL> if long_bits != <NUM_LIT:15> : <EOL> SHIFT = <NUM_LIT:15> <EOL> result = rbigint ( [ <NUM_LIT:0> ] , <NUM_LIT:0> ) <EOL> for i in range ( lng ) : <EOL> shift = i * SHIFT <EOL> result = result . add ( rbigint . fromint ( u . get_short ( ) ) . lshift ( shift ) ) <EOL> if lng and not result . tobool ( ) : <EOL> raise_exception ( space , '<STR_LIT>' ) <EOL> if sign == - <NUM_LIT:1> : <EOL> result = result . neg ( ) <EOL> else : <EOL> digits = [ <NUM_LIT:0> ] * lng <EOL> for i in range ( lng ) : <EOL> digit = u . get_int ( ) <EOL> if digit < <NUM_LIT:0> : <EOL> raise_exception ( space , '<STR_LIT>' ) <EOL> digits [ i ] = digit <EOL> if digits [ - <NUM_LIT:1> ] == <NUM_LIT:0> : <EOL> raise_exception ( space , '<STR_LIT>' ) <EOL> result = rbigint ( digits , sign ) <EOL> w_long = W_LongObject ( result ) <EOL> return w_long <EOL> register ( TYPE_LONG , unmarshal_Long ) <EOL> def PySTRING_CHECK_INTERNED ( w_str ) : <EOL> return False <EOL> def marshal_w__String ( space , w_str , m ) : <EOL> s = w_str . unwrap ( space ) <EOL> if m . version >= <NUM_LIT:1> and PySTRING_CHECK_INTERNED ( w_str ) : <EOL> idx = m . stringtable . get ( s , - <NUM_LIT:1> ) <EOL> if idx >= <NUM_LIT:0> : <EOL> m . atom_int ( TYPE_STRINGREF , idx ) <EOL> else : <EOL> idx = len ( m . stringtable ) <EOL> m . stringtable [ s ] = idx <EOL> m . atom_str ( TYPE_INTERNED , s ) <EOL> else : <EOL> m . atom_str ( TYPE_STRING , s ) <EOL> marshal_w__Rope = marshal_w__String <EOL> def unmarshal_String ( space , u , tc ) : <EOL> return space . wrap ( u . get_str ( ) ) <EOL> register ( TYPE_STRING , unmarshal_String ) <EOL> def unmarshal_interned ( space , u , tc ) : <EOL> w_ret = space . wrap ( u . get_str ( ) ) <EOL> u . stringtable_w . append ( w_ret ) <EOL> w_intern = space . builtin . get ( '<STR_LIT>' ) <EOL> space . call_function ( w_intern , w_ret ) <EOL> return w_ret <EOL> register ( TYPE_INTERNED , unmarshal_interned ) <EOL> def unmarshal_stringref ( space , u , tc ) : <EOL> idx = u . get_int ( ) <EOL>", "answer": "try :"}, {"prompt": "<s> import os <EOL> import sys <EOL> import codecs <EOL> import logging <EOL> import traceback <EOL> from twisted . python import log as txlog <EOL> from twisted . python import util <EOL> from twisted . python . failure import Failure <EOL> from twisted . python . logfile import DailyLogFile <EOL> from ooni import otime <EOL> logging . getLogger ( \"<STR_LIT>\" ) . setLevel ( logging . ERROR ) <EOL> def log_encode ( logmsg ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( logmsg , unicode ) : <EOL> return codecs . encode ( logmsg , '<STR_LIT>' ) <EOL> elif isinstance ( logmsg , str ) : <EOL> try : <EOL> unicodelogmsg = logmsg . decode ( '<STR_LIT:utf-8>' ) <EOL> except UnicodeDecodeError : <EOL> return codecs . encode ( logmsg , '<STR_LIT>' ) <EOL> else : <EOL> return codecs . encode ( unicodelogmsg , '<STR_LIT>' ) <EOL> else : <EOL> raise Exception ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % ( type ( logmsg ) , <EOL> repr ( logmsg ) ) ) <EOL> class LogWithNoPrefix ( txlog . FileLogObserver ) : <EOL> def emit ( self , eventDict ) : <EOL> text = txlog . textFromEventDict ( eventDict ) <EOL> if text is None : <EOL> return <EOL> util . untilConcludes ( self . write , \"<STR_LIT>\" % text ) <EOL> util . untilConcludes ( self . flush ) <EOL> class OONILogger ( object ) : <EOL> def start ( self , logfile = None , application_name = \"<STR_LIT>\" ) : <EOL> from ooni . settings import config <EOL> if not logfile : <EOL> logfile = os . path . expanduser ( config . basic . logfile ) <EOL> log_folder = os . path . dirname ( logfile ) <EOL> log_filename = os . path . basename ( logfile ) <EOL> daily_logfile = DailyLogFile ( log_filename , log_folder ) <EOL> txlog . msg ( \"<STR_LIT>\" % ( application_name , <EOL> otime . prettyDateNow ( ) , <EOL> otime . prettyDateNowUTC ( ) ) ) <EOL> self . fileObserver = txlog . FileLogObserver ( daily_logfile ) <EOL> self . stdoutObserver = LogWithNoPrefix ( sys . stdout ) <EOL> txlog . startLoggingWithObserver ( self . stdoutObserver . emit ) <EOL> txlog . addObserver ( self . fileObserver . emit ) <EOL> def stop ( self ) : <EOL> self . stdoutObserver . stop ( ) <EOL> self . fileObserver . stop ( ) <EOL> oonilogger = OONILogger ( ) <EOL> def start ( logfile = None , application_name = \"<STR_LIT>\" ) : <EOL> oonilogger . start ( logfile , application_name ) <EOL> def stop ( ) : <EOL> oonilogger . stop ( ) <EOL> def msg ( msg , * arg , ** kw ) : <EOL> from ooni . settings import config <EOL> if config . logging : <EOL> print \"<STR_LIT:%s>\" % log_encode ( msg ) <EOL> def debug ( msg , * arg , ** kw ) : <EOL> from ooni . settings import config <EOL> if config . advanced . debug and config . logging : <EOL> print \"<STR_LIT>\" % log_encode ( msg ) <EOL> def err ( msg , * arg , ** kw ) : <EOL> from ooni . settings import config <EOL> if config . logging : <EOL> if isinstance ( msg , Exception ) : <EOL> msg = \"<STR_LIT>\" % ( msg . __class__ . __name__ , msg ) <EOL> print \"<STR_LIT>\" % log_encode ( msg ) <EOL> def exception ( error ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( error , Failure ) : <EOL> error . printTraceback ( ) <EOL> else : <EOL>", "answer": "exc_type , exc_value , exc_traceback = sys . exc_info ( )"}, {"prompt": "<s> import return_value <EOL> import throw_exception <EOL> import throw_toto_exception <EOL>", "answer": "import return_pid "}, {"prompt": "<s> from __future__ import absolute_import <EOL> import os <EOL> import sys <EOL> from django . core . management . base import BaseCommand <EOL> from zappa . zappa import Zappa <EOL> from . zappa_command import ZappaCommand <EOL> class Command ( ZappaCommand ) : <EOL> can_import_settings = True <EOL> requires_system_checks = False <EOL> help = '''<STR_LIT>''' <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( '<STR_LIT>' , nargs = '<STR_LIT:+>' , type = str ) <EOL> def print_logs ( self , logs ) : <EOL> for log in logs : <EOL> timestamp = log [ '<STR_LIT>' ] <EOL> message = log [ '<STR_LIT:message>' ] <EOL> if \"<STR_LIT>\" in message : <EOL> continue <EOL> if \"<STR_LIT>\" in message : <EOL> continue <EOL> if \"<STR_LIT>\" in message : <EOL> continue <EOL> print ( \"<STR_LIT:[>\" + str ( timestamp ) + \"<STR_LIT>\" + message . strip ( ) ) <EOL> def handle ( self , * args , ** options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . require_settings ( args , options ) <EOL> self . load_credentials ( ) <EOL> try : <EOL> all_logs = self . zappa . fetch_logs ( self . lambda_name ) <EOL> self . print_logs ( all_logs ) <EOL> while True : <EOL> all_logs_again = self . zappa . fetch_logs ( self . lambda_name ) <EOL> new_logs = [ ] <EOL> for log in all_logs_again : <EOL> if log not in all_logs : <EOL> new_logs . append ( log ) <EOL> self . print_logs ( new_logs ) <EOL> all_logs = all_logs + new_logs <EOL> except KeyboardInterrupt : <EOL> try : <EOL> sys . exit ( <NUM_LIT:0> ) <EOL> except SystemExit : <EOL> os . _exit ( <NUM_LIT:0> ) <EOL>", "answer": "return "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function <EOL> import eventlet <EOL> eventlet . monkey_patch ( ) <EOL> import errno <EOL> import inspect <EOL> import logging <EOL> import os <EOL> import re <EOL> import signal <EOL> import sys <EOL> import yaml <EOL> from eventlet import backdoor <EOL> from nameko . constants import AMQP_URI_CONFIG_KEY <EOL> from nameko . exceptions import CommandError <EOL> from nameko . extensions import ENTRYPOINT_EXTENSIONS_ATTR <EOL> from nameko . runners import ServiceRunner <EOL> logger = logging . getLogger ( __name__ ) <EOL> MISSING_MODULE_TEMPLATE = \"<STR_LIT>\" <EOL> def is_type ( obj ) : <EOL> return isinstance ( obj , type ) <EOL> def is_entrypoint ( method ) : <EOL> return hasattr ( method , ENTRYPOINT_EXTENSIONS_ATTR ) <EOL> def import_service ( module_name ) : <EOL> parts = module_name . split ( \"<STR_LIT::>\" , <NUM_LIT:1> ) <EOL> if len ( parts ) == <NUM_LIT:1> : <EOL> module_name , obj = module_name , None <EOL> else : <EOL> module_name , obj = parts [ <NUM_LIT:0> ] , parts [ <NUM_LIT:1> ] <EOL> try : <EOL> __import__ ( module_name ) <EOL> except ImportError as exc : <EOL> if module_name . endswith ( \"<STR_LIT>\" ) and os . path . exists ( module_name ) : <EOL> raise CommandError ( <EOL> \"<STR_LIT>\" . format ( <EOL> module_name [ : - <NUM_LIT:3> ] . replace ( '<STR_LIT:/>' , '<STR_LIT:.>' ) <EOL> ) <EOL> ) <EOL> missing_module_re = MISSING_MODULE_TEMPLATE . format ( module_name ) <EOL> if re . match ( missing_module_re , str ( exc ) ) : <EOL> raise CommandError ( exc ) <EOL> raise <EOL> module = sys . modules [ module_name ] <EOL> if obj is None : <EOL> found_services = [ ] <EOL> for _ , potential_service in inspect . getmembers ( module , is_type ) : <EOL> if inspect . getmembers ( potential_service , is_entrypoint ) : <EOL> found_services . append ( potential_service ) <EOL> if not found_services : <EOL> raise CommandError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" . format ( module_name ) <EOL> ) <EOL> else : <EOL> try : <EOL> service_cls = getattr ( module , obj ) <EOL> except AttributeError : <EOL> raise CommandError ( <EOL> \"<STR_LIT>\" . format ( <EOL> obj , module_name ) <EOL> ) <EOL> if not isinstance ( service_cls , type ) : <EOL> raise CommandError ( \"<STR_LIT>\" ) <EOL> found_services = [ service_cls ] <EOL> return found_services <EOL> def setup_backdoor ( runner , port ) : <EOL> def _bad_call ( ) : <EOL> raise RuntimeError ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> socket = eventlet . listen ( ( '<STR_LIT:localhost>' , port ) ) <EOL> gt = eventlet . spawn ( <EOL> backdoor . backdoor_server , <EOL> socket , <EOL> locals = { <EOL> '<STR_LIT>' : runner , <EOL> '<STR_LIT>' : _bad_call , <EOL> '<STR_LIT>' : _bad_call , <EOL>", "answer": "} )"}, {"prompt": "<s> import os <EOL> import pytest <EOL> import sys <EOL> root = os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) ) ) <EOL> if root not in sys . path : <EOL> sys . path . insert ( <NUM_LIT:0> , root ) <EOL> from alembic . config import Config <EOL> from alembic import command <EOL> from sqlalchemy import event <EOL> from sqlalchemy . orm import Session <EOL> alembic_cfg = Config ( os . path . join ( root , '<STR_LIT>' ) ) <EOL> from changes . config import create_app , db <EOL> from changes . storage . mock import FileStorageCache <EOL> @ pytest . fixture ( scope = '<STR_LIT>' ) <EOL> def session_config ( request ) : <EOL> db_name = '<STR_LIT>' <EOL> return { <EOL> '<STR_LIT>' : db_name , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> @ pytest . fixture ( scope = '<STR_LIT>' ) <EOL> def app ( request , session_config ) : <EOL> app = create_app ( <EOL> _read_config = False , <EOL> TESTING = True , <EOL> SQLALCHEMY_DATABASE_URI = '<STR_LIT>' + session_config [ '<STR_LIT>' ] , <EOL> REDIS_URL = '<STR_LIT>' + session_config [ '<STR_LIT>' ] , <EOL> BASE_URI = '<STR_LIT>' , <EOL> REPO_ROOT = '<STR_LIT>' , <EOL> GREEN_BUILD_URL = '<STR_LIT>' , <EOL> GREEN_BUILD_AUTH = ( '<STR_LIT:username>' , '<STR_LIT:password>' ) , <EOL> JENKINS_URL = '<STR_LIT>' , <EOL> PHABRICATOR_LINK_HOST = '<STR_LIT>' , <EOL> PHABRICATOR_API_HOST = '<STR_LIT>' , <EOL> GOOGLE_CLIENT_ID = '<STR_LIT:a>' * <NUM_LIT:12> , <EOL> GOOGLE_CLIENT_SECRET = '<STR_LIT:b>' * <NUM_LIT> , <EOL> DEFAULT_FILE_STORAGE = '<STR_LIT>' , <EOL> LXC_PRE_LAUNCH = '<STR_LIT>' , <EOL> LXC_POST_LAUNCH = '<STR_LIT>' , <EOL> SNAPSHOT_S3_BUCKET = '<STR_LIT>' <EOL> ) <EOL> app_context = app . test_request_context ( ) <EOL> context = app_context . push ( ) <EOL> return app <EOL> @ pytest . fixture ( scope = '<STR_LIT>' , autouse = True ) <EOL> def setup_db ( request , app , session_config ) : <EOL> db_name = session_config [ '<STR_LIT>' ] <EOL> if os . system ( \"<STR_LIT>\" % db_name ) == <NUM_LIT:0> : <EOL> assert not os . system ( '<STR_LIT>' % db_name ) <EOL> assert not os . system ( '<STR_LIT>' % db_name ) <EOL> command . upgrade ( alembic_cfg , '<STR_LIT>' ) <EOL> @ event . listens_for ( Session , \"<STR_LIT>\" ) <EOL> def restart_savepoint ( session , transaction ) : <EOL> if transaction . nested and not transaction . _parent . nested : <EOL> session . begin_nested ( ) <EOL> @ pytest . fixture ( autouse = True ) <EOL> def db_session ( request ) : <EOL> request . addfinalizer ( db . session . remove ) <EOL> db . session . begin_nested ( ) <EOL> @ pytest . fixture ( autouse = True ) <EOL> def redis_session ( request , app ) : <EOL> import redis <EOL> conn = redis . from_url ( app . config [ '<STR_LIT>' ] ) <EOL>", "answer": "conn . flushdb ( )"}, {"prompt": "<s> from django . core . files . base import ContentFile <EOL> from django . core . files . storage import default_storage <EOL> try : <EOL> from PIL import Image <EOL> except ImportError : <EOL> import Image <EOL> from daguerre . adjustments import Fit , Crop , Fill <EOL> from daguerre . helpers import AdjustmentHelper <EOL> from daguerre . models import AdjustedImage , Area <EOL> from daguerre . tests . base import BaseTestCase <EOL> class FitTestCase ( BaseTestCase ) : <EOL> def test_calculate__both ( self ) : <EOL> fit = Fit ( width = <NUM_LIT:50> , height = <NUM_LIT:50> ) <EOL> self . assertEqual ( fit . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> def test_calculate__width ( self ) : <EOL> fit = Fit ( width = <NUM_LIT:50> ) <EOL> self . assertEqual ( fit . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> def test_calculate__height ( self ) : <EOL> fit = Fit ( height = <NUM_LIT:50> ) <EOL> self . assertEqual ( fit . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> def test_calculate__smallest ( self ) : <EOL> fit = Fit ( width = <NUM_LIT> , height = <NUM_LIT:50> ) <EOL> self . assertEqual ( fit . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> def test_adjust__both ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> fit = Fit ( width = <NUM_LIT:50> , height = <NUM_LIT:50> ) <EOL> adjusted = fit . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> def test_adjust__width ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> fit = Fit ( width = <NUM_LIT:50> ) <EOL> adjusted = fit . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> def test_adjust__height ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> fit = Fit ( height = <NUM_LIT:50> ) <EOL> adjusted = fit . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> def test_adjust__smallest ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> fit = Fit ( width = <NUM_LIT> , height = <NUM_LIT:50> ) <EOL> adjusted = fit . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> class CropTestCase ( BaseTestCase ) : <EOL> def test_calculate__both ( self ) : <EOL> crop = Crop ( width = <NUM_LIT:50> , height = <NUM_LIT:50> ) <EOL> self . assertEqual ( crop . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> def test_calculate__width ( self ) : <EOL> crop = Crop ( width = <NUM_LIT:50> ) <EOL> self . assertEqual ( crop . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:50> , <NUM_LIT:100> ) ) <EOL> def test_calculate__height ( self ) : <EOL> crop = Crop ( height = <NUM_LIT:50> ) <EOL> self . assertEqual ( crop . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:100> , <NUM_LIT:50> ) ) <EOL> def test_adjust__both ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> crop = Crop ( width = <NUM_LIT:50> , height = <NUM_LIT:50> ) <EOL> adjusted = crop . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> def test_adjust__width ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> crop = Crop ( width = <NUM_LIT:50> ) <EOL> adjusted = crop . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:50> , <NUM_LIT:100> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> def test_adjust__height ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> crop = Crop ( height = <NUM_LIT:50> ) <EOL> adjusted = crop . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:100> , <NUM_LIT:50> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> def test_adjust__area ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> crop = Crop ( width = <NUM_LIT:50> , height = <NUM_LIT:50> ) <EOL> areas = [ Area ( x1 = <NUM_LIT> , y1 = <NUM_LIT> , x2 = <NUM_LIT> , y2 = <NUM_LIT> ) ] <EOL> adjusted = crop . adjust ( im , areas = areas ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> class FillTestCase ( BaseTestCase ) : <EOL> def test_calculate__both ( self ) : <EOL> fill = Fill ( width = <NUM_LIT:50> , height = <NUM_LIT:50> ) <EOL> self . assertEqual ( fill . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> def test_calculate__unequal ( self ) : <EOL> fill = Fill ( width = <NUM_LIT:50> , height = <NUM_LIT> ) <EOL> self . assertEqual ( fill . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:50> , <NUM_LIT> ) ) <EOL> def test_calculate__width ( self ) : <EOL> fill = Fill ( width = <NUM_LIT:50> ) <EOL> self . assertEqual ( fill . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> def test_calculate__height ( self ) : <EOL> fill = Fill ( height = <NUM_LIT:50> ) <EOL> self . assertEqual ( fill . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> def test_calculate__max_height ( self ) : <EOL> fill = Fill ( width = <NUM_LIT:50> , max_height = <NUM_LIT:200> ) <EOL> self . assertEqual ( fill . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> def test_calculate__max_width ( self ) : <EOL> fill = Fill ( height = <NUM_LIT:50> , max_width = <NUM_LIT:200> ) <EOL> self . assertEqual ( fill . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> def test_calculate__max_height__smaller ( self ) : <EOL> fill = Fill ( width = <NUM_LIT:100> , max_height = <NUM_LIT:50> ) <EOL> self . assertEqual ( fill . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:100> , <NUM_LIT:50> ) ) <EOL> def test_calculate__max_width__smaller ( self ) : <EOL> fill = Fill ( height = <NUM_LIT:100> , max_width = <NUM_LIT:50> ) <EOL> self . assertEqual ( fill . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:50> , <NUM_LIT:100> ) ) <EOL> def test_calculate__strings ( self ) : <EOL> fill = Fill ( height = '<STR_LIT:100>' , max_width = '<STR_LIT>' ) <EOL> self . assertEqual ( fill . calculate ( ( <NUM_LIT:100> , <NUM_LIT:100> ) ) , ( <NUM_LIT:50> , <NUM_LIT:100> ) ) <EOL> def test_adjust__both ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> fill = Fill ( width = <NUM_LIT:50> , height = <NUM_LIT:50> ) <EOL> adjusted = fill . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> def test_adjust__width ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> fill = Fill ( width = <NUM_LIT:50> ) <EOL> adjusted = fill . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> def test_adjust__height ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> fill = Fill ( height = <NUM_LIT:50> ) <EOL> adjusted = fill . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> def test_adjust__max_height ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> fill = Fill ( width = <NUM_LIT:50> , max_height = <NUM_LIT:200> ) <EOL> adjusted = fill . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> def test_adjust__max_width ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> fill = Fill ( height = <NUM_LIT:50> , max_width = <NUM_LIT:200> ) <EOL> adjusted = fill . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:50> , <NUM_LIT:50> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> def test_adjust__unequal ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> fill = Fill ( width = <NUM_LIT:50> , height = <NUM_LIT> ) <EOL> adjusted = fill . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:50> , <NUM_LIT> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> def test_adjust__max_height__smaller ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> fill = Fill ( width = <NUM_LIT:100> , max_height = <NUM_LIT:50> ) <EOL> adjusted = fill . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:100> , <NUM_LIT:50> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> def test_adjust__max_width__smaller ( self ) : <EOL> im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> fill = Fill ( height = <NUM_LIT:100> , max_width = <NUM_LIT:50> ) <EOL> adjusted = fill . adjust ( im ) <EOL> self . assertEqual ( adjusted . size , ( <NUM_LIT:50> , <NUM_LIT:100> ) ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> self . assertImageEqual ( adjusted , expected ) <EOL> class AdjustmentHelperTestCase ( BaseTestCase ) : <EOL> def setUp ( self ) : <EOL> self . base_image = self . create_image ( '<STR_LIT>' ) <EOL> super ( AdjustmentHelperTestCase , self ) . setUp ( ) <EOL> def test_adjust_crop__50x100 ( self ) : <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> with self . assertNumQueries ( <NUM_LIT:4> ) : <EOL> helper = AdjustmentHelper ( [ self . base_image ] , generate = True ) <EOL> helper . adjust ( '<STR_LIT>' , width = <NUM_LIT:50> , height = <NUM_LIT:100> ) <EOL> helper . _finalize ( ) <EOL> adjusted = AdjustedImage . objects . get ( ) <EOL> self . assertImageEqual ( Image . open ( adjusted . adjusted . path ) , expected ) <EOL> self . assertTrue ( adjusted . adjusted . path . endswith ( '<STR_LIT>' ) ) <EOL> def test_adjust_crop__100x50 ( self ) : <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> with self . assertNumQueries ( <NUM_LIT:4> ) : <EOL> helper = AdjustmentHelper ( [ self . base_image ] , generate = True ) <EOL> helper . adjust ( '<STR_LIT>' , width = <NUM_LIT:100> , height = <NUM_LIT:50> ) <EOL> helper . _finalize ( ) <EOL> adjusted = AdjustedImage . objects . get ( ) <EOL> self . assertImageEqual ( Image . open ( adjusted . adjusted . path ) , expected ) <EOL> def test_adjust_crop__50x50_area ( self ) : <EOL> self . create_area ( storage_path = self . base_image , x1 = <NUM_LIT> , x2 = <NUM_LIT> , y1 = <NUM_LIT> , <EOL> y2 = <NUM_LIT> ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> with self . assertNumQueries ( <NUM_LIT:4> ) : <EOL> helper = AdjustmentHelper ( [ self . base_image ] , generate = True ) <EOL> helper . adjust ( '<STR_LIT>' , width = <NUM_LIT:50> , height = <NUM_LIT:50> ) <EOL> helper . _finalize ( ) <EOL> adjusted = AdjustedImage . objects . get ( ) <EOL> self . assertImageEqual ( Image . open ( adjusted . adjusted . path ) , expected ) <EOL> def test_named_crop ( self ) : <EOL> self . create_area ( storage_path = self . base_image , x1 = <NUM_LIT> , x2 = <NUM_LIT> , y1 = <NUM_LIT> , <EOL> y2 = <NUM_LIT> , name = '<STR_LIT>' ) <EOL> expected = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> with self . assertNumQueries ( <NUM_LIT:4> ) : <EOL> helper = AdjustmentHelper ( [ self . base_image ] , generate = True ) <EOL> helper . adjust ( '<STR_LIT>' , name = '<STR_LIT>' ) <EOL> helper . adjust ( '<STR_LIT>' , width = <NUM_LIT> , height = <NUM_LIT> ) <EOL> helper . _finalize ( ) <EOL> adjusted = AdjustedImage . objects . get ( ) <EOL> self . assertImageEqual ( Image . open ( adjusted . adjusted . path ) , expected ) <EOL> def test_readjust ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> new_im = Image . open ( self . _data_path ( '<STR_LIT>' ) ) <EOL> with self . assertNumQueries ( <NUM_LIT:4> ) : <EOL> helper = AdjustmentHelper ( [ self . base_image ] , generate = True ) <EOL> helper . adjust ( '<STR_LIT>' , width = <NUM_LIT:50> , height = <NUM_LIT:100> ) <EOL> helper . _finalize ( ) <EOL> adjusted = AdjustedImage . objects . get ( ) <EOL> self . assertImageEqual ( Image . open ( adjusted . adjusted . path ) , new_im ) <EOL> with self . assertNumQueries ( <NUM_LIT:1> ) : <EOL> helper = AdjustmentHelper ( [ self . base_image ] , generate = True ) <EOL> helper . adjust ( '<STR_LIT>' , width = <NUM_LIT:50> , height = <NUM_LIT:100> ) <EOL> helper . _finalize ( ) <EOL> self . assertEqual ( AdjustedImage . objects . count ( ) , <NUM_LIT:1> ) <EOL> def test_readjust_multiple ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with self . assertNumQueries ( <NUM_LIT:4> ) : <EOL> helper = AdjustmentHelper ( [ self . base_image ] , generate = True ) <EOL> helper . adjust ( '<STR_LIT>' , width = <NUM_LIT:50> , height = <NUM_LIT:100> ) <EOL> helper . _finalize ( ) <EOL> adjusted1 = AdjustedImage . objects . get ( ) <EOL> adjusted2 = AdjustedImage . objects . get ( ) <EOL> adjusted2 . pk = None <EOL> adjusted2 . save ( ) <EOL> self . assertNotEqual ( adjusted1 . pk , adjusted2 . pk ) <EOL> helper = AdjustmentHelper ( [ self . base_image ] ) <EOL> helper . adjust ( '<STR_LIT>' , width = <NUM_LIT:50> , height = <NUM_LIT:100> ) <EOL> with self . assertNumQueries ( <NUM_LIT:1> ) : <EOL> helper . _finalize ( ) <EOL> url = list ( helper . adjusted . values ( ) ) [ <NUM_LIT:0> ] [ '<STR_LIT:url>' ] <EOL> self . assertEqual ( url , adjusted1 . adjusted . url ) <EOL> self . assertEqual ( url , adjusted2 . adjusted . url ) <EOL> def test_adjust__nonexistant ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> storage_path = '<STR_LIT>' <EOL>", "answer": "self . assertFalse ( default_storage . exists ( storage_path ) )"}, {"prompt": "<s> class PluginManager ( object ) : <EOL> def __init__ ( self , plugin_dir ) : <EOL> self . plugin_root = plugin_dir <EOL> self . __plugins = { } <EOL> self . _loadPlugins ( ) <EOL> def _loadPlugins ( self ) : <EOL> pass <EOL> def getByInterface ( self , interface ) : <EOL> for v in self . __plugins . itervalues ( ) : <EOL>", "answer": "if v . interfaces ( \"<STR_LIT>\" ) :"}, {"prompt": "<s> from flask import Flask <EOL> from werkzeug . contrib . fixers import ProxyFix <EOL>", "answer": "from zoo import api"}, {"prompt": "<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> import subprocess <EOL> from pants . base . exceptions import TaskError <EOL> from pants . task . task import Task <EOL> from pants . contrib . cpp . targets . cpp_binary import CppBinary <EOL> from pants . contrib . cpp . targets . cpp_library import CppLibrary <EOL> from pants . contrib . cpp . targets . cpp_target import CppTarget <EOL> from pants . contrib . cpp . toolchain . cpp_toolchain import CppToolchain <EOL> class CppTask ( Task ) : <EOL> @ staticmethod <EOL> def is_cpp ( target ) : <EOL>", "answer": "return isinstance ( target , CppTarget )"}, {"prompt": "<s> import os <EOL> from django . conf import settings <EOL>", "answer": "from storages . compat import FileSystemStorage"}, {"prompt": "<s> import abc <EOL> from grpc . beta import implementations as beta_implementations <EOL> from grpc . framework . common import cardinality <EOL> from grpc . framework . interfaces . face import utilities as face_utilities <EOL> class BetaOperationsServicer ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __metaclass__ = abc . ABCMeta <EOL> @ abc . abstractmethod <EOL> def GetOperation ( self , request , context ) : <EOL> raise NotImplementedError ( ) <EOL> @ abc . abstractmethod <EOL> def ListOperations ( self , request , context ) : <EOL> raise NotImplementedError ( ) <EOL> @ abc . abstractmethod <EOL> def CancelOperation ( self , request , context ) : <EOL> raise NotImplementedError ( ) <EOL> @ abc . abstractmethod <EOL> def DeleteOperation ( self , request , context ) : <EOL> raise NotImplementedError ( ) <EOL> class BetaOperationsStub ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __metaclass__ = abc . ABCMeta <EOL> @ abc . abstractmethod <EOL> def GetOperation ( self , request , timeout ) : <EOL> raise NotImplementedError ( ) <EOL> GetOperation . future = None <EOL> @ abc . abstractmethod <EOL> def ListOperations ( self , request , timeout ) : <EOL> raise NotImplementedError ( ) <EOL> ListOperations . future = None <EOL> @ abc . abstractmethod <EOL> def CancelOperation ( self , request , timeout ) : <EOL> raise NotImplementedError ( ) <EOL> CancelOperation . future = None <EOL> @ abc . abstractmethod <EOL> def DeleteOperation ( self , request , timeout ) : <EOL> raise NotImplementedError ( ) <EOL> DeleteOperation . future = None <EOL> def beta_create_Operations_server ( servicer , pool = None , pool_size = None , default_timeout = None , maximum_timeout = None ) : <EOL> import google . longrunning . operations_pb2 <EOL> import google . longrunning . operations_pb2 <EOL> import google . longrunning . operations_pb2 <EOL> import google . longrunning . operations_pb2 <EOL> import google . longrunning . operations_pb2 <EOL> import google . protobuf . empty_pb2 <EOL> import google . longrunning . operations_pb2 <EOL> import google . protobuf . empty_pb2 <EOL> request_deserializers = { <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : google . longrunning . operations_pb2 . CancelOperationRequest . FromString , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : google . longrunning . operations_pb2 . DeleteOperationRequest . FromString , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : google . longrunning . operations_pb2 . GetOperationRequest . FromString , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : google . longrunning . operations_pb2 . ListOperationsRequest . FromString , <EOL> } <EOL> response_serializers = { <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : google . protobuf . empty_pb2 . Empty . SerializeToString , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : google . protobuf . empty_pb2 . Empty . SerializeToString , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : google . longrunning . operations_pb2 . Operation . SerializeToString , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : google . longrunning . operations_pb2 . ListOperationsResponse . SerializeToString , <EOL> } <EOL> method_implementations = { <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : face_utilities . unary_unary_inline ( servicer . CancelOperation ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : face_utilities . unary_unary_inline ( servicer . DeleteOperation ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : face_utilities . unary_unary_inline ( servicer . GetOperation ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : face_utilities . unary_unary_inline ( servicer . ListOperations ) , <EOL> } <EOL> server_options = beta_implementations . server_options ( request_deserializers = request_deserializers , response_serializers = response_serializers , thread_pool = pool , thread_pool_size = pool_size , default_timeout = default_timeout , maximum_timeout = maximum_timeout ) <EOL> return beta_implementations . server ( method_implementations , options = server_options ) <EOL> def beta_create_Operations_stub ( channel , host = None , metadata_transformer = None , pool = None , pool_size = None ) : <EOL> import google . longrunning . operations_pb2 <EOL> import google . longrunning . operations_pb2 <EOL> import google . longrunning . operations_pb2 <EOL> import google . longrunning . operations_pb2 <EOL> import google . longrunning . operations_pb2 <EOL> import google . protobuf . empty_pb2 <EOL> import google . longrunning . operations_pb2 <EOL> import google . protobuf . empty_pb2 <EOL> request_serializers = { <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : google . longrunning . operations_pb2 . CancelOperationRequest . SerializeToString , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : google . longrunning . operations_pb2 . DeleteOperationRequest . SerializeToString , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : google . longrunning . operations_pb2 . GetOperationRequest . SerializeToString , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : google . longrunning . operations_pb2 . ListOperationsRequest . SerializeToString , <EOL> } <EOL> response_deserializers = { <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : google . protobuf . empty_pb2 . Empty . FromString , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) : google . protobuf . empty_pb2 . Empty . FromString , <EOL>", "answer": "( '<STR_LIT>' , '<STR_LIT>' ) : google . longrunning . operations_pb2 . Operation . FromString ,"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from __future__ import absolute_import <EOL> import logging <EOL> import re <EOL> import salt . ext . six as six <EOL> from salt . exceptions import SaltInvocationError <EOL> import salt . utils <EOL> try : <EOL> import wmi <EOL> import salt . utils . winapi <EOL> _HAS_MODULE_DEPENDENCIES = True <EOL> except ImportError : <EOL> _HAS_MODULE_DEPENDENCIES = False <EOL> _DEFAULT_SERVER = '<STR_LIT>' <EOL> _WMI_NAMESPACE = '<STR_LIT>' <EOL> _LOG = logging . getLogger ( __name__ ) <EOL> __virtualname__ = '<STR_LIT>' <EOL> def __virtual__ ( ) : <EOL> '''<STR_LIT>''' <EOL> if salt . utils . is_windows ( ) and _HAS_MODULE_DEPENDENCIES : <EOL> return __virtualname__ <EOL> return False <EOL> def _get_wmi_setting ( wmi_class_name , setting , server ) : <EOL> '''<STR_LIT>''' <EOL> with salt . utils . winapi . Com ( ) : <EOL> try : <EOL> connection = wmi . WMI ( namespace = _WMI_NAMESPACE ) <EOL> wmi_class = getattr ( connection , wmi_class_name ) <EOL> objs = wmi_class ( [ setting ] , Name = server ) [ <NUM_LIT:0> ] <EOL> ret = getattr ( objs , setting ) <EOL> except wmi . x_wmi as error : <EOL> _LOG . error ( '<STR_LIT>' , error . com_error ) <EOL> except ( AttributeError , IndexError ) as error : <EOL> _LOG . error ( '<STR_LIT>' , wmi_class_name , error ) <EOL> return ret <EOL> def _set_wmi_setting ( wmi_class_name , setting , value , server ) : <EOL> '''<STR_LIT>''' <EOL> with salt . utils . winapi . Com ( ) : <EOL> try : <EOL> connection = wmi . WMI ( namespace = _WMI_NAMESPACE ) <EOL> wmi_class = getattr ( connection , wmi_class_name ) <EOL> objs = wmi_class ( Name = server ) [ <NUM_LIT:0> ] <EOL> except wmi . x_wmi as error : <EOL> _LOG . error ( '<STR_LIT>' , error . com_error ) <EOL> except ( AttributeError , IndexError ) as error : <EOL> _LOG . error ( '<STR_LIT>' , wmi_class_name , error ) <EOL> try : <EOL> setattr ( objs , setting , value ) <EOL> return True <EOL> except wmi . x_wmi as error : <EOL> _LOG . error ( '<STR_LIT>' , error . com_error ) <EOL> except AttributeError as error : <EOL> _LOG . error ( '<STR_LIT>' , setting , error ) <EOL> return False <EOL> def _normalize_server_settings ( ** settings ) : <EOL> '''<STR_LIT>''' <EOL> ret = dict ( ) <EOL> settings = salt . utils . clean_kwargs ( ** settings ) <EOL> for setting in settings : <EOL> if isinstance ( settings [ setting ] , dict ) : <EOL> _LOG . debug ( '<STR_LIT>' , settings [ setting ] ) <EOL> value_from_key = next ( six . iterkeys ( settings [ setting ] ) ) <EOL> ret [ setting ] = \"<STR_LIT>\" . format ( value_from_key ) <EOL> else : <EOL> ret [ setting ] = settings [ setting ] <EOL> return ret <EOL> def get_log_format_types ( ) : <EOL> '''<STR_LIT>''' <EOL> ret = dict ( ) <EOL> prefix = '<STR_LIT>' <EOL> with salt . utils . winapi . Com ( ) : <EOL> try : <EOL> connection = wmi . WMI ( namespace = _WMI_NAMESPACE ) <EOL> objs = connection . IISLogModuleSetting ( ) <EOL> for obj in objs : <EOL> name = str ( obj . Name ) . replace ( prefix , '<STR_LIT>' , <NUM_LIT:1> ) <EOL> ret [ name ] = str ( obj . LogModuleId ) <EOL> except wmi . x_wmi as error : <EOL> _LOG . error ( '<STR_LIT>' , error . com_error ) <EOL> except ( AttributeError , IndexError ) as error : <EOL> _LOG . error ( '<STR_LIT>' , error ) <EOL> if not ret : <EOL> _LOG . error ( '<STR_LIT>' ) <EOL> return ret <EOL> def get_servers ( ) : <EOL> '''<STR_LIT>''' <EOL> ret = list ( ) <EOL> with salt . utils . winapi . Com ( ) : <EOL> try : <EOL> connection = wmi . WMI ( namespace = _WMI_NAMESPACE ) <EOL> objs = connection . IIsSmtpServerSetting ( ) <EOL> for obj in objs : <EOL> ret . append ( str ( obj . Name ) ) <EOL> except wmi . x_wmi as error : <EOL> _LOG . error ( '<STR_LIT>' , error . com_error ) <EOL> except ( AttributeError , IndexError ) as error : <EOL> _LOG . error ( '<STR_LIT>' , error ) <EOL> _LOG . debug ( '<STR_LIT>' , ret ) <EOL> return ret <EOL> def get_server_setting ( settings , server = _DEFAULT_SERVER ) : <EOL> '''<STR_LIT>''' <EOL> ret = dict ( ) <EOL> if not settings : <EOL> _LOG . warning ( '<STR_LIT>' ) <EOL> return ret <EOL> with salt . utils . winapi . Com ( ) : <EOL> try : <EOL> connection = wmi . WMI ( namespace = _WMI_NAMESPACE ) <EOL> objs = connection . IIsSmtpServerSetting ( settings , Name = server ) [ <NUM_LIT:0> ] <EOL> for setting in settings : <EOL> ret [ setting ] = str ( getattr ( objs , setting ) ) <EOL> except wmi . x_wmi as error : <EOL> _LOG . error ( '<STR_LIT>' , error . com_error ) <EOL> except ( AttributeError , IndexError ) as error : <EOL> _LOG . error ( '<STR_LIT>' , error ) <EOL> return ret <EOL> def set_server_setting ( settings , server = _DEFAULT_SERVER ) : <EOL> '''<STR_LIT>''' <EOL> if not settings : <EOL> _LOG . warning ( '<STR_LIT>' ) <EOL> return False <EOL> settings = _normalize_server_settings ( ** settings ) <EOL> current_settings = get_server_setting ( settings = settings . keys ( ) , server = server ) <EOL> if settings == current_settings : <EOL> _LOG . debug ( '<STR_LIT>' ) <EOL> return True <EOL> with salt . utils . winapi . Com ( ) : <EOL> try : <EOL> connection = wmi . WMI ( namespace = _WMI_NAMESPACE ) <EOL> objs = connection . IIsSmtpServerSetting ( Name = server ) [ <NUM_LIT:0> ] <EOL> except wmi . x_wmi as error : <EOL> _LOG . error ( '<STR_LIT>' , error . com_error ) <EOL> except ( AttributeError , IndexError ) as error : <EOL> _LOG . error ( '<STR_LIT>' , error ) <EOL> for setting in settings : <EOL> if str ( settings [ setting ] ) != str ( current_settings [ setting ] ) : <EOL> try : <EOL> setattr ( objs , setting , settings [ setting ] ) <EOL> except wmi . x_wmi as error : <EOL> _LOG . error ( '<STR_LIT>' , error . com_error ) <EOL> except AttributeError as error : <EOL> _LOG . error ( '<STR_LIT>' , setting , error ) <EOL> new_settings = get_server_setting ( settings = settings . keys ( ) , server = server ) <EOL> failed_settings = dict ( ) <EOL> for setting in settings : <EOL> if str ( settings [ setting ] ) != str ( new_settings [ setting ] ) : <EOL> failed_settings [ setting ] = settings [ setting ] <EOL> if failed_settings : <EOL> _LOG . error ( '<STR_LIT>' , failed_settings ) <EOL> return False <EOL> _LOG . debug ( '<STR_LIT>' , settings . keys ( ) ) <EOL> return True <EOL> def get_log_format ( server = _DEFAULT_SERVER ) : <EOL> '''<STR_LIT>''' <EOL> log_format_types = get_log_format_types ( ) <EOL> format_id = _get_wmi_setting ( '<STR_LIT>' , '<STR_LIT>' , server ) <EOL> for key in log_format_types : <EOL> if str ( format_id ) == log_format_types [ key ] : <EOL> return key <EOL> _LOG . warning ( '<STR_LIT>' ) <EOL> return None <EOL> def set_log_format ( log_format , server = _DEFAULT_SERVER ) : <EOL>", "answer": "'''<STR_LIT>'''"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pygraph . algorithms . minmax import shortest_path <EOL> class chow ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , * centers ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . centers = centers <EOL> self . nodes = { } <EOL> def optimize ( self , graph ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "for center in self . centers :"}, {"prompt": "<s> import hashlib <EOL> import hmac <EOL> import mock <EOL>", "answer": "from six import StringIO"}, {"prompt": "<s> from pyrepl . console import Event <EOL> from pyrepl . tests . infrastructure import ReaderTestCase , EA , run_testcase <EOL> class BugsTestCase ( ReaderTestCase ) : <EOL> def test_transpose_at_start ( self ) : <EOL> self . run_test ( [ ( '<STR_LIT>' , [ EA , '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , [ '<STR_LIT>' ] ) ] ) <EOL> def test ( ) : <EOL> run_testcase ( BugsTestCase ) <EOL>", "answer": "if __name__ == '<STR_LIT:__main__>' :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from color_view import ColorView <EOL> class YellowView ( ColorView ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = '<STR_LIT>' <EOL>", "answer": "position = '<STR_LIT>'"}, {"prompt": "<s> import getopt <EOL> import ipaddress <EOL> import os <EOL> import signal <EOL> import socket <EOL> import sys <EOL> import time <EOL> from statistics import stdev <EOL> import dns . rdatatype <EOL> import dns . resolver <EOL> __VERSION__ = <NUM_LIT> <EOL> __PROGNAME__ = os . path . basename ( sys . argv [ <NUM_LIT:0> ] ) <EOL> should_stop = False <EOL> def usage ( ) : <EOL> print ( \"\"\"<STR_LIT>\"\"\" % ( __PROGNAME__ , __VERSION__ , __PROGNAME__ ) ) <EOL> exit ( ) <EOL> def signal_handler ( sig , frame ) : <EOL> global should_stop <EOL> if should_stop : <EOL> exit ( <NUM_LIT:0> ) <EOL> should_stop = True <EOL> def main ( ) : <EOL> try : <EOL> signal . signal ( signal . SIGTSTP , signal . SIG_IGN ) <EOL> signal . signal ( signal . SIGINT , signal_handler ) <EOL> except AttributeError : <EOL> pass <EOL> if len ( sys . argv ) == <NUM_LIT:1> : <EOL> usage ( ) <EOL> dnsrecord = '<STR_LIT:A>' <EOL> count = <NUM_LIT:10> <EOL> timeout = <NUM_LIT:5> <EOL> quiet = False <EOL> verbose = False <EOL> dnsserver = '<STR_LIT>' <EOL> dst_port = <NUM_LIT> <EOL> src_port = <NUM_LIT:0> <EOL> src_ip = None <EOL> hostname = '<STR_LIT>' <EOL> try : <EOL> opts , args = getopt . getopt ( sys . argv [ <NUM_LIT:1> : ] , \"<STR_LIT>\" , <EOL> [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT:port>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> except getopt . GetoptError as err : <EOL> print ( err ) <EOL> usage ( ) <EOL> if args and len ( args ) == <NUM_LIT:1> : <EOL> hostname = args [ <NUM_LIT:0> ] <EOL> else : <EOL> usage ( ) <EOL> for o , a in opts : <EOL> if o in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> usage ( ) <EOL> elif o in ( \"<STR_LIT:-c>\" , \"<STR_LIT>\" ) : <EOL> count = int ( a ) <EOL> elif o in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> verbose = True <EOL> elif o in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> dnsserver = a <EOL> elif o in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> dst_port = int ( a ) <EOL> elif o in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> quiet = True <EOL> verbose = False <EOL> elif o in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> timeout = int ( a ) <EOL> elif o in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> dnsrecord = a <EOL> elif o in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> src_port = int ( a ) <EOL> if src_port < <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" ) <EOL> elif o in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> src_ip = a <EOL> else : <EOL> usage ( ) <EOL> try : <EOL> ipaddress . ip_address ( dnsserver ) <EOL> except ValueError : <EOL> try : <EOL> dnsserver = socket . getaddrinfo ( dnsserver , port = None ) [ <NUM_LIT:1> ] [ <NUM_LIT:4> ] [ <NUM_LIT:0> ] <EOL> except OSError : <EOL> print ( '<STR_LIT>' , dnsserver ) <EOL> exit ( <NUM_LIT:1> ) <EOL> resolver = dns . resolver . Resolver ( ) <EOL> resolver . nameservers = [ dnsserver ] <EOL> resolver . timeout = timeout <EOL> resolver . lifetime = timeout <EOL> resolver . port = dst_port <EOL> resolver . retry_servfail = <NUM_LIT:0> <EOL> response_time = [ ] <EOL> i = <NUM_LIT:0> <EOL> print ( \"<STR_LIT>\" % ( __PROGNAME__ , dnsserver , dst_port , hostname , dnsrecord ) ) <EOL> for i in range ( count ) : <EOL> if should_stop : <EOL> break <EOL> try : <EOL> stime = time . time ( ) <EOL> answers = resolver . query ( hostname , dnsrecord , source_port = src_port , source = src_ip ) <EOL> etime = time . time ( ) <EOL> except dns . resolver . NoNameservers as e : <EOL> if not quiet : <EOL> print ( \"<STR_LIT>\" ) <EOL> if verbose : <EOL> print ( \"<STR_LIT>\" , e ) <EOL> exit ( <NUM_LIT:1> ) <EOL> except dns . resolver . NXDOMAIN as e : <EOL> if not quiet : <EOL> print ( \"<STR_LIT>\" ) <EOL> if verbose : <EOL> print ( \"<STR_LIT>\" , e ) <EOL> exit ( <NUM_LIT:1> ) <EOL> except dns . resolver . Timeout : <EOL> if not quiet : <EOL> print ( \"<STR_LIT>\" ) <EOL> pass <EOL> except dns . resolver . NoAnswer : <EOL> if not quiet : <EOL> print ( \"<STR_LIT>\" ) <EOL> pass <EOL> else : <EOL> elapsed = ( etime - stime ) * <NUM_LIT:1000> <EOL> response_time . append ( elapsed ) <EOL> if not quiet : <EOL> print ( <EOL> \"<STR_LIT>\" % ( <EOL> len ( str ( answers . rrset ) ) , dnsserver , i , elapsed ) ) <EOL> if verbose : <EOL> print ( answers . rrset ) <EOL> r_sent = i + <NUM_LIT:1> <EOL> r_received = len ( response_time ) <EOL> r_lost = r_sent - r_received <EOL> r_lost_percent = ( <NUM_LIT:100> * r_lost ) / r_sent <EOL>", "answer": "if response_time :"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL> import sys <EOL> import os <EOL> sys . path . insert ( <NUM_LIT:0> , os . path . dirname ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) ) ) <EOL> from veriloggen import * <EOL>", "answer": "import veriloggen . dataflow as dataflow"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from __future__ import division <EOL> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from parselmouth . utils . enum import Enum <EOL> ParselmouthProviders = Enum ( [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ParselmouthTargetTypes = Enum ( [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> TechnologyTargetTypes = Enum ( [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ParselmouthReportMetrics = Enum ( [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> from sleekxmpp . xmlstream import register_stanza_plugin , ElementBase , ET <EOL> from sleekxmpp import Iq <EOL> from baboon . common . file import FileEvent <EOL> class GitInit ( ElementBase ) : <EOL> name = '<STR_LIT>' <EOL> namespace = '<STR_LIT>' <EOL> plugin_attrib = '<STR_LIT>' <EOL> interfaces = set ( ( '<STR_LIT>' , '<STR_LIT:url>' , ) ) <EOL> class Rsync ( ElementBase ) : <EOL> name = '<STR_LIT>' <EOL> namespace = '<STR_LIT>' <EOL> plugin_attrib = '<STR_LIT>' <EOL> interfaces = set ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> sub_interfaces = set ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ) ) <EOL> def get_files ( self ) : <EOL> files = [ ] <EOL> for element in self . xml . getchildren ( ) : <EOL> tag_name = element . tag . split ( '<STR_LIT:}>' , <NUM_LIT:1> ) [ - <NUM_LIT:1> ] <EOL> file_event_type = None <EOL> if tag_name == '<STR_LIT:file>' : <EOL> file_event_type = FileEvent . MODIF <EOL> elif tag_name == '<STR_LIT>' : <EOL> file_event_type = FileEvent . CREATE <EOL> elif tag_name == '<STR_LIT>' : <EOL> file_event_type = FileEvent . MOVE <EOL> elif tag_name == '<STR_LIT>' : <EOL> file_event_type = FileEvent . DELETE <EOL> file_event = FileEvent ( self [ '<STR_LIT>' ] , file_event_type , element . text ) <EOL> files . append ( file_event ) <EOL> return files <EOL> def add_file ( self , f ) : <EOL> file_xml = ET . Element ( '<STR_LIT>' % self . namespace ) <EOL> file_xml . text = f <EOL> self . xml . append ( file_xml ) <EOL> def set_files ( self , files ) : <EOL> for f in files : <EOL> self . add_file ( f ) <EOL> def add_create_file ( self , f ) : <EOL> file_xml = ET . Element ( '<STR_LIT>' % self . namespace ) <EOL> file_xml . text = f <EOL> self . xml . append ( file_xml ) <EOL> def set_create_files ( self , files ) : <EOL> for f in files : <EOL>", "answer": "self . add_create_file ( f )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . build import Build <EOL> from . oauth_token import OAuthToken <EOL> from . repository import Repository <EOL>", "answer": "from . webhook import Webhook "}, {"prompt": "<s> from __future__ import absolute_import <EOL> from __future__ import unicode_literals <EOL> from django . conf . urls import url <EOL> from django_filters . views import FilterView , object_filter <EOL> from . models import Book <EOL> urlpatterns = [ <EOL> url ( r'<STR_LIT>' , object_filter , { '<STR_LIT>' : Book } ) , <EOL> url ( r'<STR_LIT>' , FilterView . as_view ( model = Book ) ) , <EOL>", "answer": "] "}, {"prompt": "<s> from vt_manager . communication . sfa . util . faults import RecordNotFound , ConnectionKeyGIDMismatch <EOL> from vt_manager . communication . sfa . util . xrn import urn_to_hrn <EOL> from vt_manager . communication . sfa . util . method import Method <EOL> from vt_manager . communication . sfa . trust . certificate import Certificate <EOL> from vt_manager . communication . sfa . util . parameter import Parameter , Mixed <EOL> class GetSelfCredential ( Method ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> interfaces = [ '<STR_LIT>' ] <EOL> accepts = [ <EOL> Parameter ( str , \"<STR_LIT>\" ) , <EOL> Parameter ( str , \"<STR_LIT>\" ) , <EOL> Mixed ( Parameter ( str , \"<STR_LIT>\" ) , <EOL> Parameter ( None , \"<STR_LIT>\" ) ) , <EOL> ] <EOL>", "answer": "returns = Parameter ( str , \"<STR_LIT>\" )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import platform <EOL> from . slfn import SLFN <EOL> import numpy as np <EOL> from scipy . linalg import blas , lapack <EOL> class SLFNPython ( SLFN ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , inputs , outputs , norm = None , precision = np . float64 ) : <EOL>", "answer": "super ( SLFNPython , self ) . __init__ ( inputs , outputs , norm , precision )"}, {"prompt": "<s> import networkx as nx <EOL> from networkx . algorithms . dag import ( is_directed_acyclic_graph , ancestors , <EOL> descendants , topological_sort ) <EOL> class DependencyGraph ( object ) : <EOL> def __init__ ( self ) : <EOL> self . g = nx . DiGraph ( ) <EOL> def add_dependency ( self , obj , depending_on ) : <EOL> ng = self . g . copy ( ) <EOL> ng . add_edge ( obj , depending_on ) <EOL> if not is_directed_acyclic_graph ( ng ) : <EOL> raise ValueError ( '<STR_LIT>' <EOL>", "answer": "'<STR_LIT>' . format ( obj , depending_on ) )"}, {"prompt": "<s> from django . utils . translation import ugettext_lazy as _ <EOL> import horizon <EOL>", "answer": "from openstack_dashboard . dashboards . project import dashboard"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from __future__ import absolute_import <EOL> from salttesting import TestCase , skipIf <EOL> from salttesting . mock import MagicMock , NO_MOCK , NO_MOCK_REASON , patch <EOL> from salttesting . helpers import ensure_in_syspath <EOL> ensure_in_syspath ( '<STR_LIT>' ) <EOL> from salt . cloud . clouds import opennebula <EOL> from salt . exceptions import SaltCloudSystemExit , SaltCloudNotFound <EOL> opennebula . __active_provider_name__ = '<STR_LIT>' <EOL> opennebula . __opts__ = { } <EOL> VM_NAME = '<STR_LIT>' <EOL> @ skipIf ( NO_MOCK , NO_MOCK_REASON ) <EOL> @ patch ( '<STR_LIT>' , MagicMock ( return_value = '<STR_LIT>' ) ) <EOL> class OpenNebulaTestCase ( TestCase ) : <EOL> '''<STR_LIT>''' <EOL> def test_avail_images_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . avail_images , '<STR_LIT:action>' ) <EOL> def test_avail_locations_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . avail_locations , '<STR_LIT:action>' ) <EOL> def test_avail_sizes_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . avail_sizes , '<STR_LIT:action>' ) <EOL> def test_avail_sizes ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertEqual ( opennebula . avail_sizes ( call = '<STR_LIT:foo>' ) , { } ) <EOL> def test_list_clusters_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . list_clusters , '<STR_LIT:action>' ) <EOL> def test_list_datastores_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . list_datastores , '<STR_LIT:action>' ) <EOL> def test_list_hosts_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . list_hosts , '<STR_LIT:action>' ) <EOL> def test_list_nodes_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . list_nodes , '<STR_LIT:action>' ) <EOL> def test_list_nodes_full_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . list_nodes_full , '<STR_LIT:action>' ) <EOL> def test_list_nodes_select_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . list_nodes_select , '<STR_LIT:action>' ) <EOL> def test_list_security_groups_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . list_security_groups , '<STR_LIT:action>' ) <EOL> def test_list_templates_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . list_templates , '<STR_LIT:action>' ) <EOL> def test_list_vns_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . list_vns , '<STR_LIT:action>' ) <EOL> def test_reboot_error ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . reboot , '<STR_LIT>' , '<STR_LIT:foo>' ) <EOL> def test_start_error ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . start , '<STR_LIT>' , '<STR_LIT:foo>' ) <EOL> def test_stop_error ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , opennebula . stop , '<STR_LIT>' , '<STR_LIT:foo>' ) <EOL> def test_get_cluster_id_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , <EOL> opennebula . get_cluster_id , <EOL> call = '<STR_LIT:action>' ) <EOL> def test_get_cluster_id_no_name ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , <EOL> opennebula . get_cluster_id , <EOL> None , <EOL> call = '<STR_LIT:foo>' ) <EOL> @ patch ( '<STR_LIT>' , <EOL> MagicMock ( return_value = { '<STR_LIT:foo>' : { '<STR_LIT:id>' : '<STR_LIT:bar>' } } ) ) <EOL> def test_get_cluster_id_not_found ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , <EOL> opennebula . get_cluster_id , <EOL> kwargs = { '<STR_LIT:name>' : '<STR_LIT:test>' } , <EOL> call = '<STR_LIT>' ) <EOL> @ patch ( '<STR_LIT>' , <EOL> MagicMock ( return_value = { '<STR_LIT>' : { '<STR_LIT:id>' : '<STR_LIT:100>' } } ) ) <EOL> def test_get_cluster_id_success ( self ) : <EOL> '''<STR_LIT>''' <EOL> mock_id = '<STR_LIT:100>' <EOL> mock_kwargs = { '<STR_LIT:name>' : '<STR_LIT>' } <EOL> self . assertEqual ( opennebula . get_cluster_id ( mock_kwargs , '<STR_LIT:foo>' ) , <EOL> mock_id ) <EOL> def test_get_datastore_id_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , <EOL> opennebula . get_datastore_id , <EOL> call = '<STR_LIT:action>' ) <EOL> def test_get_datastore_id_no_name ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , <EOL> opennebula . get_datastore_id , <EOL> None , <EOL> call = '<STR_LIT:foo>' ) <EOL> @ patch ( '<STR_LIT>' , <EOL> MagicMock ( return_value = { '<STR_LIT>' : { '<STR_LIT:id>' : '<STR_LIT:100>' } } ) ) <EOL> def test_get_datastore_id_not_found ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , <EOL> opennebula . get_datastore_id , <EOL> kwargs = { '<STR_LIT:name>' : '<STR_LIT:test>' } , <EOL> call = '<STR_LIT>' ) <EOL> @ patch ( '<STR_LIT>' , <EOL> MagicMock ( return_value = { '<STR_LIT>' : { '<STR_LIT:id>' : '<STR_LIT:100>' } } ) ) <EOL> def test_get_datastore_id_success ( self ) : <EOL> '''<STR_LIT>''' <EOL> mock_id = '<STR_LIT:100>' <EOL> mock_kwargs = { '<STR_LIT:name>' : '<STR_LIT>' } <EOL> self . assertEqual ( opennebula . get_datastore_id ( mock_kwargs , '<STR_LIT:foo>' ) , <EOL> mock_id ) <EOL> def test_get_host_id_action ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . assertRaises ( SaltCloudSystemExit , <EOL> opennebula . get_host_id , <EOL> call = '<STR_LIT:action>' ) <EOL> def test_get_host_id_no_name ( self ) : <EOL>", "answer": "'''<STR_LIT>'''"}, {"prompt": "<s> class Token ( object ) : <EOL> def __init__ ( self , start_mark , end_mark ) : <EOL> self . start_mark = start_mark <EOL> self . end_mark = end_mark <EOL> def __repr__ ( self ) : <EOL> attributes = [ key for key in self . __dict__ <EOL> if not key . endswith ( '<STR_LIT>' ) ] <EOL> attributes . sort ( ) <EOL> arguments = '<STR_LIT:U+002CU+0020>' . join ( [ '<STR_LIT>' % ( key , getattr ( self , key ) ) <EOL> for key in attributes ] ) <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ , arguments ) <EOL> class DirectiveToken ( Token ) : <EOL> id = '<STR_LIT>' <EOL> def __init__ ( self , name , value , start_mark , end_mark ) : <EOL> self . name = name <EOL> self . value = value <EOL> self . start_mark = start_mark <EOL> self . end_mark = end_mark <EOL> class DocumentStartToken ( Token ) : <EOL> id = '<STR_LIT>' <EOL>", "answer": "class DocumentEndToken ( Token ) :"}, {"prompt": "<s> __all__ = [ <EOL>", "answer": "\"<STR_LIT>\" ,"}, {"prompt": "<s> from nose . tools import * <EOL> import networkx as nx <EOL> from networkx import NetworkXNotImplemented <EOL> class TestWeaklyConnected : <EOL> def setUp ( self ) : <EOL> self . gc = [ ] <EOL> G = nx . DiGraph ( ) <EOL> G . add_edges_from ( [ ( <NUM_LIT:1> , <NUM_LIT:2> ) , ( <NUM_LIT:2> , <NUM_LIT:3> ) , ( <NUM_LIT:2> , <NUM_LIT:8> ) , ( <NUM_LIT:3> , <NUM_LIT:4> ) , ( <NUM_LIT:3> , <NUM_LIT:7> ) , ( <NUM_LIT:4> , <NUM_LIT:5> ) , <EOL> ( <NUM_LIT:5> , <NUM_LIT:3> ) , ( <NUM_LIT:5> , <NUM_LIT:6> ) , ( <NUM_LIT:7> , <NUM_LIT:4> ) , ( <NUM_LIT:7> , <NUM_LIT:6> ) , ( <NUM_LIT:8> , <NUM_LIT:1> ) , ( <NUM_LIT:8> , <NUM_LIT:7> ) ] ) <EOL> C = [ [ <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> , <NUM_LIT:7> ] , [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:8> ] , [ <NUM_LIT:6> ] ] <EOL> self . gc . append ( ( G , C ) ) <EOL> G = nx . DiGraph ( ) <EOL> G . add_edges_from ( [ ( <NUM_LIT:1> , <NUM_LIT:2> ) , ( <NUM_LIT:1> , <NUM_LIT:3> ) , ( <NUM_LIT:1> , <NUM_LIT:4> ) , ( <NUM_LIT:4> , <NUM_LIT:2> ) , ( <NUM_LIT:3> , <NUM_LIT:4> ) , ( <NUM_LIT:2> , <NUM_LIT:3> ) ] ) <EOL> C = [ [ <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ] , [ <NUM_LIT:1> ] ] <EOL> self . gc . append ( ( G , C ) ) <EOL> G = nx . DiGraph ( ) <EOL> G . add_edges_from ( [ ( <NUM_LIT:1> , <NUM_LIT:2> ) , ( <NUM_LIT:2> , <NUM_LIT:3> ) , ( <NUM_LIT:3> , <NUM_LIT:2> ) , ( <NUM_LIT:2> , <NUM_LIT:1> ) ] ) <EOL> C = [ [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] ] <EOL> self . gc . append ( ( G , C ) ) <EOL> G = nx . DiGraph ( { <NUM_LIT:0> : [ <NUM_LIT:1> ] , <NUM_LIT:1> : [ <NUM_LIT:2> , <NUM_LIT:3> ] , <NUM_LIT:2> : [ <NUM_LIT:4> , <NUM_LIT:5> ] , <NUM_LIT:3> : [ <NUM_LIT:4> , <NUM_LIT:5> ] , <NUM_LIT:4> : [ <NUM_LIT:6> ] , <NUM_LIT:5> : [ ] , <NUM_LIT:6> : [ ] } ) <EOL> C = [ [ <NUM_LIT:0> ] , [ <NUM_LIT:1> ] , [ <NUM_LIT:2> ] , [ <NUM_LIT:3> ] , [ <NUM_LIT:4> ] , [ <NUM_LIT:5> ] , [ <NUM_LIT:6> ] ] <EOL>", "answer": "self . gc . append ( ( G , C ) )"}, {"prompt": "<s> from rest_framework . templatetags . rest_framework import replace_query_param <EOL> from premises . utils import int_or_default <EOL> class MongoDBPaginationMixin ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> page_query_param = '<STR_LIT>' <EOL> limit_query_param = '<STR_LIT>' <EOL> def get_page ( self ) : <EOL> return int_or_default ( self . request . GET . get ( self . page_query_param ) , <NUM_LIT:1> ) <EOL> def get_limit ( self ) : <EOL> return int_or_default ( self . request . GET . get ( self . limit_query_param ) , <NUM_LIT:20> ) <EOL> def get_pagination_context ( self ) : <EOL> offset = self . get_limit ( ) * ( self . get_page ( ) - <NUM_LIT:1> ) <EOL> limit = self . get_limit ( ) + offset <EOL> return { <EOL> '<STR_LIT>' : offset , <EOL> '<STR_LIT>' : limit <EOL> } <EOL> def get_next_link ( self ) : <EOL> url = self . request . build_absolute_uri ( ) <EOL> return replace_query_param ( <EOL> url , self . page_query_param , self . get_page ( ) + <NUM_LIT:1> ) <EOL> def get_previous_link ( self ) : <EOL> url = self . request . build_absolute_uri ( ) <EOL> page = self . get_page ( ) <EOL> if page < <NUM_LIT:2> : <EOL> return None <EOL> return replace_query_param ( <EOL> url , self . page_query_param , self . get_page ( ) - <NUM_LIT:1> ) <EOL>", "answer": "def get_paginated_response ( self , data ) :"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> from oslo_log import log <EOL> from oslo_utils import importutils <EOL> from dragonflow . _i18n import _ , _LE <EOL> LOG = log . getLogger ( __name__ ) <EOL> class AppDispatcher ( object ) : <EOL> def __init__ ( self , apps_location_prefix , app_list ) : <EOL> self . apps_location_prefix = apps_location_prefix <EOL> self . apps_list = app_list . split ( '<STR_LIT:U+002C>' ) <EOL> self . apps = [ ] <EOL> def load ( self , * args , ** kwargs ) : <EOL> for app in self . apps_list : <EOL> app_class_name = self . apps_location_prefix + \"<STR_LIT:.>\" + app <EOL> try : <EOL> app_class = importutils . import_class ( app_class_name ) <EOL> app = app_class ( * args , ** kwargs ) <EOL> self . apps . append ( app ) <EOL> except ImportError as e : <EOL> LOG . exception ( _LE ( \"<STR_LIT>\" ) , e ) <EOL> raise ImportError ( _ ( \"<STR_LIT>\" ) ) <EOL> def dispatch ( self , method , * args , ** kwargs ) : <EOL> for app in self . apps : <EOL> handler = getattr ( app , method , None ) <EOL> if handler is not None : <EOL>", "answer": "handler ( * args , ** kwargs ) "}, {"prompt": "<s> from __future__ import with_statement <EOL> import os <EOL> import shutil <EOL> from vcs import VCSError , get_repo , get_backend <EOL> from vcs . backends . hg import MercurialRepository <EOL> from vcs . utils . compat import unittest <EOL> from vcs . tests . conf import TEST_HG_REPO , TEST_GIT_REPO , TEST_TMP_PATH <EOL> class VCSTest ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def test_get_backend ( self ) : <EOL> hg = get_backend ( '<STR_LIT>' ) <EOL> self . assertEqual ( hg , MercurialRepository ) <EOL>", "answer": "def test_alias_detect_hg ( self ) :"}, {"prompt": "<s> from . suite import BaseSuite <EOL> class TestFront ( BaseSuite ) : <EOL>", "answer": "def test_get ( self ) :"}, {"prompt": "<s> from __future__ import absolute_import <EOL> import flask <EOL>", "answer": "blueprint = flask . Blueprint ( __name__ , __name__ ) "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> revision = '<STR_LIT>' <EOL> down_revision = '<STR_LIT>' <EOL> from alembic import op <EOL> import sqlalchemy as sa <EOL> def upgrade ( ) : <EOL> op . add_column ( '<STR_LIT>' , sa . Column ( '<STR_LIT>' , sa . String ( length = <NUM_LIT:255> ) , nullable = True ) ) <EOL> op . add_column ( '<STR_LIT>' , sa . Column ( '<STR_LIT>' , sa . String ( length = <NUM_LIT:255> ) , nullable = True ) ) <EOL> op . drop_column ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def downgrade ( ) : <EOL>", "answer": "op . add_column ( '<STR_LIT>' , sa . Column ( '<STR_LIT>' , sa . VARCHAR ( length = <NUM_LIT:255> ) , autoincrement = False , nullable = True ) )"}, {"prompt": "<s> from __future__ import with_statement <EOL> import sys <EOL> from distutils . core import setup <EOL> VERSION = '<STR_LIT>' <EOL> options = { } <EOL> with open ( '<STR_LIT>' ) as fp : <EOL> README = fp . read ( ) . strip ( ) + \"<STR_LIT>\" <EOL> ChangeLog = ( <EOL> \"<STR_LIT>\" <EOL>", "answer": "\"<STR_LIT>\""}, {"prompt": "<s> from south . utils import datetime_utils as datetime <EOL> from south . db import db <EOL> from south . v2 import DataMigration <EOL> from django . db import models <EOL> class Migration ( DataMigration ) : <EOL> def forwards ( self , orm ) : <EOL> \"<STR_LIT>\" <EOL> orm . Journal . objects . filter ( previous_ahead_documents = None ) . update ( previous_ahead_documents = <NUM_LIT:0> ) <EOL> def backwards ( self , orm ) : <EOL> \"<STR_LIT>\" <EOL> orm . Journal . objects . filter ( previous_ahead_documents = <NUM_LIT:0> ) . update ( previous_ahead_documents = None ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:password>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:username>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : [ '<STR_LIT>' ] } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:address>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:state>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:url>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:address>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:state>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:label>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:0>' } ) , <EOL> '<STR_LIT:type>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:title>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:0>' , '<STR_LIT:max_length>' : '<STR_LIT:3>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:2>' } ) , <EOL>", "answer": "'<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> import copy <EOL> import os <EOL> import sys <EOL> import anvil . commands . util as commandutil <EOL> from anvil . manage import ManageCommand <EOL> class ServeCommand ( ManageCommand ) : <EOL> def __init__ ( self ) : <EOL> super ( ServeCommand , self ) . __init__ ( <EOL> name = '<STR_LIT>' , <EOL> help_short = '<STR_LIT>' , <EOL> help_long = __doc__ ) <EOL> self . _add_common_build_hints ( ) <EOL> def create_argument_parser ( self ) : <EOL> parser = super ( ServeCommand , self ) . create_argument_parser ( ) <EOL> self . _add_common_build_arguments ( <EOL> parser , targets = True , targets_optional = True ) <EOL>", "answer": "parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' ,"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import base64 <EOL> import os <EOL> import unittest <EOL> import zlib <EOL> from StringIO import StringIO <EOL> import numpy as np <EOL> import scipy . ndimage <EOL> from cellprofiler . preferences import set_headless <EOL> set_headless ( ) <EOL> import cellprofiler . pipeline as cpp <EOL> import cellprofiler . cpmodule as cpm <EOL> import cellprofiler . cpimage as cpi <EOL> import cellprofiler . measurements as cpmeas <EOL> import cellprofiler . objects as cpo <EOL> import cellprofiler . workspace as cpw <EOL> import cellprofiler . modules . labelimages as L <EOL> class TestLabelImages ( unittest . TestCase ) : <EOL> def test_01_00_load_matlab ( self ) : <EOL> data = ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> pipeline = cpp . Pipeline ( ) <EOL> def callback ( caller , event ) : <EOL> self . assertFalse ( isinstance ( event , cpp . LoadExceptionEvent ) ) <EOL> pipeline . add_listener ( callback ) <EOL> pipeline . load ( StringIO ( zlib . decompress ( base64 . b64decode ( data ) ) ) ) <EOL> self . assertEqual ( len ( pipeline . modules ( ) ) , <NUM_LIT:2> ) <EOL> module = pipeline . modules ( ) [ - <NUM_LIT:1> ] <EOL> self . assertTrue ( isinstance ( module , L . LabelImages ) ) <EOL> self . assertEqual ( module . row_count . value , <NUM_LIT:16> ) <EOL> self . assertEqual ( module . column_count . value , <NUM_LIT> ) <EOL> self . assertEqual ( module . site_count . value , <NUM_LIT:2> ) <EOL> self . assertEqual ( module . order , L . O_COLUMN ) <EOL> def test_01_01_load_v1 ( self ) : <EOL> data = r\"\"\"<STR_LIT>\"\"\" <EOL> pipeline = cpp . Pipeline ( ) <EOL> def callback ( caller , event ) : <EOL> self . assertFalse ( isinstance ( event , cpp . LoadExceptionEvent ) ) <EOL> pipeline . add_listener ( callback ) <EOL> pipeline . load ( StringIO ( data ) ) <EOL> self . assertEqual ( len ( pipeline . modules ( ) ) , <NUM_LIT:2> ) <EOL> module = pipeline . modules ( ) [ <NUM_LIT:0> ] <EOL> self . assertTrue ( isinstance ( module , L . LabelImages ) ) <EOL> self . assertEqual ( module . site_count , <NUM_LIT:3> ) <EOL> self . assertEqual ( module . row_count , <NUM_LIT:32> ) <EOL> self . assertEqual ( module . column_count , <NUM_LIT> ) <EOL> self . assertEqual ( module . order , L . O_COLUMN ) <EOL> module = pipeline . modules ( ) [ <NUM_LIT:1> ] <EOL> self . assertTrue ( isinstance ( module , L . LabelImages ) ) <EOL> self . assertEqual ( module . site_count , <NUM_LIT:1> ) <EOL> self . assertEqual ( module . row_count , <NUM_LIT:8> ) <EOL> self . assertEqual ( module . column_count , <NUM_LIT:12> ) <EOL> self . assertEqual ( module . order , L . O_ROW ) <EOL> def make_workspace ( self , image_set_count ) : <EOL> image_set_list = cpi . ImageSetList ( ) <EOL> for i in range ( image_set_count ) : <EOL> image_set = image_set_list . get_image_set ( i ) <EOL> module = L . LabelImages ( ) <EOL> pipeline = cpp . Pipeline ( ) <EOL> def callback ( caller , event ) : <EOL> self . assertFalse ( isinstance ( event , cpp . RunExceptionEvent ) ) <EOL> pipeline . add_listener ( callback ) <EOL> module . module_num = <NUM_LIT:1> <EOL> pipeline . add_module ( module ) <EOL> workspace = cpw . Workspace ( pipeline , module , <EOL> image_set_list . get_image_set ( <NUM_LIT:0> ) , <EOL> cpo . ObjectSet ( ) , cpmeas . Measurements ( ) , <EOL> image_set_list ) <EOL> return workspace , module <EOL> def test_02_01_label_plate_by_row ( self ) : <EOL> '''<STR_LIT>''' <EOL> nsites = <NUM_LIT:6> <EOL> nimagesets = <NUM_LIT> * nsites <EOL> workspace , module = self . make_workspace ( nimagesets ) <EOL> measurements = workspace . measurements <EOL> self . assertTrue ( isinstance ( measurements , cpmeas . Measurements ) ) <EOL> self . assertTrue ( isinstance ( module , L . LabelImages ) ) <EOL> module . row_count . value = <NUM_LIT:8> <EOL> module . column_count . value = <NUM_LIT:12> <EOL> module . order . value = L . O_ROW <EOL> module . site_count . value = nsites <EOL> for i in range ( nimagesets ) : <EOL> if i != <NUM_LIT:0> : <EOL> measurements . next_image_set ( ) <EOL> module . run ( workspace ) <EOL> sites = measurements . get_all_measurements ( cpmeas . IMAGE , cpmeas . M_SITE ) <EOL> rows = measurements . get_all_measurements ( cpmeas . IMAGE , cpmeas . M_ROW ) <EOL> columns = measurements . get_all_measurements ( cpmeas . IMAGE , cpmeas . M_COLUMN ) <EOL> plates = measurements . get_all_measurements ( cpmeas . IMAGE , cpmeas . M_PLATE ) <EOL> wells = measurements . get_all_measurements ( cpmeas . IMAGE , cpmeas . M_WELL ) <EOL> for i in range ( nimagesets ) : <EOL> self . assertEqual ( sites [ i ] , ( i % <NUM_LIT:6> ) + <NUM_LIT:1> ) <EOL> this_row = '<STR_LIT>' [ int ( i / <NUM_LIT:6> / <NUM_LIT:12> ) ] <EOL> this_column = ( int ( i / <NUM_LIT:6> ) % <NUM_LIT:12> ) + <NUM_LIT:1> <EOL> self . assertEqual ( rows [ i ] , this_row ) <EOL> self . assertEqual ( columns [ i ] , this_column ) <EOL> self . assertEqual ( wells [ i ] , '<STR_LIT>' % ( this_row , this_column ) ) <EOL> self . assertEqual ( plates [ i ] , <NUM_LIT:1> ) <EOL> def test_02_02_label_plate_by_column ( self ) : <EOL>", "answer": "'''<STR_LIT>'''"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Tangible ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> DEBUG = True <EOL> TEMPLATE_DEBUG = DEBUG <EOL> BASE_PATH = os . path . abspath ( os . path . dirname ( __file__ ) ) <EOL> REPO_BASE_PATH = BASE_PATH <EOL> REPO = { <EOL>", "answer": "'<STR_LIT>' : \"<STR_LIT>\" ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import codecs <EOL> from setuptools import setup <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> url = '<STR_LIT>' , <EOL> license = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> long_description = codecs . open ( '<STR_LIT>' , '<STR_LIT:r>' , '<STR_LIT:utf-8>' ) . read ( ) , <EOL> py_modules = [ '<STR_LIT>' ] , <EOL> zip_safe = False , <EOL> platforms = '<STR_LIT>' , <EOL> test_suite = \"<STR_LIT>\" , <EOL>", "answer": "install_requires = ["}, {"prompt": "<s> import asyncio <EOL> from contextlib import contextmanager <EOL> from unittest import mock <EOL> import asynqp . frames <EOL> from asynqp import protocol <EOL> from asynqp . exceptions import ConnectionLostError <EOL> def testing_exception_handler ( loop , context ) : <EOL> '''<STR_LIT>''' <EOL> exception = context . get ( '<STR_LIT>' ) <EOL> if exception and isinstance ( exception , ConnectionLostError ) : <EOL> pass <EOL> else : <EOL> loop . default_exception_handler ( context ) <EOL> class MockServer ( object ) : <EOL> def __init__ ( self , protocol , tick ) : <EOL> self . protocol = protocol <EOL> self . tick = tick <EOL> self . data = [ ] <EOL> def send_bytes ( self , b ) : <EOL> self . protocol . data_received ( b ) <EOL> self . tick ( ) <EOL> def send_frame ( self , frame ) : <EOL> self . send_bytes ( frame . serialise ( ) ) <EOL> def send_method ( self , channel_number , method ) : <EOL> frame = asynqp . frames . MethodFrame ( channel_number , method ) <EOL> self . send_frame ( frame ) <EOL> def reset ( self ) : <EOL> self . data = [ ] <EOL> def should_have_received_frames ( self , expected_frames , any_order = False ) : <EOL> results = ( read ( x ) for x in self . data ) <EOL> frames = [ x for x in results if x is not None ] <EOL> if any_order : <EOL> for frame in expected_frames : <EOL> assert frame in frames , \"<STR_LIT>\" . format ( frame , frames ) <EOL> else : <EOL> expected_frames = tuple ( expected_frames ) <EOL> assert expected_frames in windows ( frames , len ( expected_frames ) ) , \"<STR_LIT>\" . format ( expected_frames , frames ) <EOL> def should_have_received_methods ( self , channel_number , methods , any_order = False ) : <EOL> frames = ( asynqp . frames . MethodFrame ( channel_number , m ) for m in methods ) <EOL> self . should_have_received_frames ( frames , any_order ) <EOL> def should_have_received_frame ( self , expected_frame ) : <EOL>", "answer": "self . should_have_received_frames ( [ expected_frame ] , any_order = True )"}, {"prompt": "<s> from msrest . paging import Paged <EOL> class WorkflowAccessKeyPaged ( Paged ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _attribute_map = { <EOL> '<STR_LIT>' : { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:type>' : '<STR_LIT:str>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:key>' : '<STR_LIT:value>' , '<STR_LIT:type>' : '<STR_LIT>' } <EOL> } <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL>", "answer": "super ( WorkflowAccessKeyPaged , self ) . __init__ ( * args , ** kwargs ) "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from base64 import ( urlsafe_b64encode as b64encode , <EOL> urlsafe_b64decode as b64decode ) <EOL> from urllib import urlencode <EOL> from urlparse import parse_qsl <EOL> from functools import wraps <EOL> from flask import request , redirect , abort , current_app , url_for <EOL> from flask_login import LoginManager , make_secure_token <EOL> import requests <EOL> GOOGLE_OAUTH2_AUTH_URL = '<STR_LIT>' <EOL> GOOGLE_OAUTH2_TOKEN_URL = '<STR_LIT>' <EOL> GOOGLE_OAUTH2_USERINFO_URL = '<STR_LIT>' <EOL> USERINFO_PROFILE_SCOPE = '<STR_LIT>' <EOL> class GoogleLogin ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , app = None , login_manager = None ) : <EOL> if login_manager : <EOL> self . login_manager = login_manager <EOL> else : <EOL> self . login_manager = LoginManager ( ) <EOL> if app : <EOL> self . _app = app <EOL> self . init_app ( app ) <EOL> def init_app ( self , app , add_context_processor = True , login_manager = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if login_manager : <EOL> self . login_manager = login_manager <EOL> else : <EOL> self . login_manager = LoginManager ( ) <EOL> if not hasattr ( app , '<STR_LIT>' ) : <EOL> self . login_manager . init_app ( <EOL> app , <EOL> add_context_processor = add_context_processor ) <EOL> self . login_manager . login_message = None <EOL> self . login_manager . needs_refresh_message = None <EOL> self . login_manager . unauthorized_handler ( self . unauthorized_callback ) <EOL> @ property <EOL> def app ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , current_app ) <EOL> @ property <EOL> def scopes ( self ) : <EOL> return self . app . config . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ property <EOL> def client_id ( self ) : <EOL> return self . app . config [ '<STR_LIT>' ] <EOL> @ property <EOL> def client_secret ( self ) : <EOL> return self . app . config [ '<STR_LIT>' ] <EOL> @ property <EOL> def redirect_uri ( self ) : <EOL> return self . app . config . get ( '<STR_LIT>' ) <EOL> @ property <EOL> def redirect_scheme ( self ) : <EOL> return self . app . config . get ( '<STR_LIT>' , '<STR_LIT:http>' ) <EOL> def sign_params ( self , params ) : <EOL> return b64encode ( urlencode ( dict ( sig = make_secure_token ( ** params ) , <EOL> ** params ) ) ) <EOL> def parse_state ( self , state ) : <EOL> return dict ( parse_qsl ( b64decode ( str ( state ) ) ) ) <EOL> def login_url ( self , params = None , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> kwargs . setdefault ( '<STR_LIT>' , '<STR_LIT:code>' ) <EOL> kwargs . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if '<STR_LIT>' not in kwargs : <EOL> kwargs . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> scopes = kwargs . pop ( '<STR_LIT>' , self . scopes . split ( '<STR_LIT:U+002C>' ) ) <EOL> if USERINFO_PROFILE_SCOPE not in scopes : <EOL> scopes . append ( USERINFO_PROFILE_SCOPE ) <EOL> redirect_uri = kwargs . pop ( '<STR_LIT>' , self . redirect_uri ) <EOL> state = self . sign_params ( params or { } ) <EOL> return GOOGLE_OAUTH2_AUTH_URL + '<STR_LIT:?>' + urlencode ( <EOL> dict ( client_id = self . client_id , <EOL> scope = '<STR_LIT:U+0020>' . join ( scopes ) , <EOL> redirect_uri = redirect_uri , <EOL> state = state , <EOL> ** kwargs ) ) <EOL> def unauthorized_callback ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return redirect ( self . login_url ( params = dict ( next = request . url ) ) ) <EOL> def exchange_code ( self , code , redirect_uri ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> token = requests . post ( GOOGLE_OAUTH2_TOKEN_URL , data = dict ( <EOL> code = code , <EOL> redirect_uri = redirect_uri , <EOL> grant_type = '<STR_LIT>' , <EOL> client_id = self . client_id , <EOL> client_secret = self . client_secret , <EOL> ) ) . json <EOL> if not token : <EOL> abort ( <NUM_LIT> ) <EOL> return token <EOL> def get_userinfo ( self , access_token ) : <EOL> userinfo = requests . get ( GOOGLE_OAUTH2_USERINFO_URL , params = dict ( <EOL> access_token = access_token , <EOL> ) ) . json <EOL> if not userinfo : <EOL> abort ( <NUM_LIT> ) <EOL> return userinfo <EOL> def get_access_token ( self , refresh_token ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> token = requests . post ( GOOGLE_OAUTH2_TOKEN_URL , data = dict ( <EOL> refresh_token = refresh_token , <EOL> grant_type = '<STR_LIT>' , <EOL> client_id = self . client_id , <EOL> client_secret = self . client_secret , <EOL> ) ) . json <EOL> if not token : <EOL> return <EOL> return token <EOL> def oauth2callback ( self , view_func ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ wraps ( view_func ) <EOL> def decorated ( * args , ** kwargs ) : <EOL> params = { } <EOL> if '<STR_LIT:state>' in request . args : <EOL> params . update ( ** self . parse_state ( request . args . get ( '<STR_LIT:state>' ) ) ) <EOL> if params . pop ( '<STR_LIT>' , None ) != make_secure_token ( ** params ) : <EOL> return self . login_manager . unauthorized ( ) <EOL> code = request . args . get ( '<STR_LIT:code>' ) <EOL> if code : <EOL> token = self . exchange_code ( <EOL> code , <EOL> url_for ( <EOL>", "answer": "request . endpoint ,"}, {"prompt": "<s> from pubnub import Pubnub <EOL> import random <EOL> pubnub = Pubnub ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> pubnub . set_u ( True ) <EOL> def rand_str ( s ) : <EOL> return str ( s ) + '<STR_LIT:->' + str ( random . randint ( <NUM_LIT:1> , <NUM_LIT> ) ) <EOL> def test_1 ( ) : <EOL> channel = rand_str ( '<STR_LIT>' ) <EOL> channel2 = rand_str ( '<STR_LIT>' ) <EOL> channel_group = rand_str ( '<STR_LIT>' ) <EOL> channel_group2 = rand_str ( '<STR_LIT>' ) <EOL> namespace = rand_str ( '<STR_LIT>' ) <EOL> resp = pubnub . channel_group_add_channel ( channel_group = namespace + '<STR_LIT::>' + channel_group , channel = channel ) <EOL> assert resp [ '<STR_LIT:status>' ] == <NUM_LIT:200> <EOL> assert resp [ '<STR_LIT:message>' ] == '<STR_LIT:OK>' <EOL> assert resp [ '<STR_LIT:error>' ] == False <EOL> resp = pubnub . channel_group_add_channel ( channel_group = namespace + '<STR_LIT::>' + channel_group , channel = channel2 ) <EOL> assert resp [ '<STR_LIT:status>' ] == <NUM_LIT:200> <EOL> assert resp [ '<STR_LIT:message>' ] == '<STR_LIT:OK>' <EOL> assert resp [ '<STR_LIT:error>' ] == False <EOL> resp = pubnub . channel_group_add_channel ( channel_group = namespace + '<STR_LIT::>' + channel_group2 , channel = channel ) <EOL> assert resp [ '<STR_LIT:status>' ] == <NUM_LIT:200> <EOL> assert resp [ '<STR_LIT:message>' ] == '<STR_LIT:OK>' <EOL> assert resp [ '<STR_LIT:error>' ] == False <EOL> resp = pubnub . channel_group_add_channel ( channel_group = namespace + '<STR_LIT::>' + channel_group2 , channel = channel2 ) <EOL> assert resp [ '<STR_LIT:status>' ] == <NUM_LIT:200> <EOL> assert resp [ '<STR_LIT:message>' ] == '<STR_LIT:OK>' <EOL> assert resp [ '<STR_LIT:error>' ] == False <EOL> resp = pubnub . channel_group_list_channels ( channel_group = namespace + '<STR_LIT::>' + channel_group ) <EOL> assert channel in resp [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> assert channel2 in resp [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> assert len ( resp [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) == <NUM_LIT:2> <EOL> resp = pubnub . channel_group_remove_channel ( channel_group = namespace + '<STR_LIT::>' + channel_group , channel = channel2 ) <EOL> print ( resp ) <EOL> assert resp [ '<STR_LIT:status>' ] == <NUM_LIT:200> <EOL>", "answer": "assert resp [ '<STR_LIT:message>' ] == '<STR_LIT:OK>'"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import unittest <EOL> class InequalityTest ( unittest . TestCase ) : <EOL> def testEqual ( self ) : <EOL> self . failIfEqual ( <NUM_LIT:1> , <NUM_LIT:3> - <NUM_LIT:2> ) <EOL> def testNotEqual ( self ) : <EOL> self . failUnlessEqual ( <NUM_LIT:2> , <NUM_LIT:3> - <NUM_LIT:2> ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL>", "answer": "unittest . main ( ) "}, {"prompt": "<s> from __future__ import print_function <EOL> class debug : <EOL> def __init__ ( self ) : <EOL>", "answer": "pass"}, {"prompt": "<s> import unittest <EOL> import time <EOL> import numpy as np <EOL> from openmdao . main . api import Component , Driver , Assembly , set_as_top <EOL> from openmdao . main . datatypes . api import Float , Array <EOL> from openmdao . main . hasparameters import HasParameters <EOL> from openmdao . main . hasobjective import HasObjective <EOL> from openmdao . main . hasconstraints import HasConstraints <EOL> from openmdao . main . interfaces import IHasParameters , implements <EOL> from openmdao . util . decorators import add_delegate <EOL> from openmdao . util . testutil import assert_rel_error <EOL> class Paraboloid ( Component ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> x = Float ( <NUM_LIT:0.0> , iotype = '<STR_LIT>' , desc = '<STR_LIT>' ) <EOL> y = Float ( <NUM_LIT:0.0> , iotype = '<STR_LIT>' , desc = '<STR_LIT>' ) <EOL> f_xy = Float ( iotype = '<STR_LIT>' , desc = '<STR_LIT>' ) <EOL> def execute ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> x = self . x <EOL> y = self . y <EOL> self . f_xy = ( x - <NUM_LIT> ) ** <NUM_LIT:2> + x * y + ( y + <NUM_LIT> ) ** <NUM_LIT:2> - <NUM_LIT> <EOL> def provideJ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> df_dx = <NUM_LIT> * self . x - <NUM_LIT> + self . y <EOL> df_dy = <NUM_LIT> * self . y + <NUM_LIT> + self . x <EOL> self . J = array ( [ [ df_dx , df_dy ] ] ) <EOL> return self . J <EOL> def list_deriv_vars ( self ) : <EOL> input_keys = ( '<STR_LIT:x>' , '<STR_LIT:y>' ) <EOL> output_keys = ( '<STR_LIT>' , ) <EOL> return input_keys , output_keys <EOL> @ add_delegate ( HasParameters , HasObjective , HasConstraints ) <EOL> class SimpleDriver ( Driver ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> implements ( IHasParameters ) <EOL> class TestcaseParaboloid ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . top = top = set_as_top ( Assembly ( ) ) <EOL> top . add ( '<STR_LIT>' , Paraboloid ( ) ) <EOL> top . add ( '<STR_LIT>' , SimpleDriver ( ) ) <EOL> top . driver . workflow . add ( [ '<STR_LIT>' ] ) <EOL> def test_single_comp ( self ) : <EOL> top = self . top <EOL> top . driver . add_parameter ( '<STR_LIT>' , low = - <NUM_LIT:1000> , high = <NUM_LIT:1000> ) <EOL> top . driver . add_parameter ( '<STR_LIT>' , low = - <NUM_LIT:1000> , high = <NUM_LIT:1000> ) <EOL> top . driver . add_objective ( '<STR_LIT>' ) <EOL> top . comp . x = <NUM_LIT:3> <EOL> top . comp . y = <NUM_LIT:5> <EOL> top . run ( ) <EOL> self . assertEqual ( top . comp . f_xy , <NUM_LIT> ) <EOL> self . assertEqual ( top . _pseudo_0 . in0 , <NUM_LIT> ) <EOL> self . assertEqual ( top . _pseudo_0 . out0 , <NUM_LIT> ) <EOL> def test_boundary_out ( self ) : <EOL> top = self . top <EOL> top . driver . add_parameter ( '<STR_LIT>' , low = - <NUM_LIT:1000> , high = <NUM_LIT:1000> ) <EOL> top . driver . add_parameter ( '<STR_LIT>' , low = - <NUM_LIT:1000> , high = <NUM_LIT:1000> ) <EOL> top . driver . add_objective ( '<STR_LIT>' ) <EOL> top . create_passthrough ( '<STR_LIT>' ) <EOL> top . comp . x = <NUM_LIT:3> <EOL> top . comp . y = <NUM_LIT:5> <EOL> top . run ( ) <EOL> self . assertEqual ( top . f_xy , <NUM_LIT> ) <EOL> def test_boundary_in_out ( self ) : <EOL> top = self . top <EOL> top . driver . add_parameter ( '<STR_LIT>' , low = - <NUM_LIT:1000> , high = <NUM_LIT:1000> ) <EOL> top . driver . add_objective ( '<STR_LIT>' ) <EOL> top . create_passthrough ( '<STR_LIT>' ) <EOL> top . create_passthrough ( '<STR_LIT>' ) <EOL> top . x = <NUM_LIT:3> <EOL> top . comp . y = <NUM_LIT:5> <EOL> top . run ( ) <EOL> self . assertEqual ( top . f_xy , <NUM_LIT> ) <EOL> def test_find_system ( self ) : <EOL> top = self . top <EOL> top . driver . add_parameter ( '<STR_LIT>' , low = - <NUM_LIT:1000> , high = <NUM_LIT:1000> ) <EOL> top . driver . add_parameter ( '<STR_LIT>' , low = - <NUM_LIT:1000> , high = <NUM_LIT:1000> ) <EOL> top . driver . add_objective ( '<STR_LIT>' ) <EOL> top . comp . x = <NUM_LIT:3> <EOL> top . comp . y = <NUM_LIT:5> <EOL> top . run ( ) <EOL> sys = top . _system . find_system ( '<STR_LIT>' ) <EOL> self . assertTrue ( sys . name == '<STR_LIT>' ) <EOL> sys = top . _system . find_system ( \"<STR_LIT>\" ) <EOL> self . assertTrue ( sys . name == \"<STR_LIT>\" ) <EOL> system = top . driver . workflow . _system <EOL> self . assertTrue ( system . is_variable_local ( '<STR_LIT>' ) is True ) <EOL> try : <EOL> system . is_variable_local ( '<STR_LIT>' ) <EOL> except Exception as err : <EOL> msg = '<STR_LIT>' <EOL> self . assertEqual ( str ( err ) , msg ) <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" ) <EOL> class ABCDArrayComp ( Component ) : <EOL> delay = Float ( <NUM_LIT> , iotype = '<STR_LIT>' ) <EOL> def __init__ ( self , arr_size = <NUM_LIT:9> ) : <EOL> super ( ABCDArrayComp , self ) . __init__ ( ) <EOL> self . add_trait ( '<STR_LIT:a>' , Array ( np . ones ( arr_size , float ) , iotype = '<STR_LIT>' ) ) <EOL> self . add_trait ( '<STR_LIT:b>' , Array ( np . ones ( arr_size , float ) , iotype = '<STR_LIT>' ) ) <EOL> self . add_trait ( '<STR_LIT:c>' , Array ( np . ones ( arr_size , float ) , iotype = '<STR_LIT>' ) ) <EOL> self . add_trait ( '<STR_LIT:d>' , Array ( np . ones ( arr_size , float ) , iotype = '<STR_LIT>' ) ) <EOL> def execute ( self ) : <EOL> time . sleep ( self . delay ) <EOL> self . c = self . a + self . b <EOL> self . d = self . a - self . b <EOL> class TestArrayComp ( unittest . TestCase ) : <EOL> def test_overlap_exception ( self ) : <EOL> size = <NUM_LIT:20> <EOL> top = set_as_top ( Assembly ( ) ) <EOL> top . add ( \"<STR_LIT>\" , ABCDArrayComp ( size ) ) <EOL> top . add ( \"<STR_LIT>\" , ABCDArrayComp ( size ) ) <EOL> top . add ( \"<STR_LIT>\" , ABCDArrayComp ( size ) ) <EOL> top . add ( \"<STR_LIT>\" , ABCDArrayComp ( size ) ) <EOL> top . driver . workflow . add ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> top . connect ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> top . connect ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> top . connect ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> top . connect ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> top . C1 . a = np . ones ( size , float ) * <NUM_LIT> <EOL> top . C1 . b = np . ones ( size , float ) * <NUM_LIT> <EOL> try : <EOL> top . run ( ) <EOL> except Exception as err : <EOL> self . assertEqual ( str ( err ) , \"<STR_LIT>\" ) <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" ) <EOL> def test_no_flat_subassy_slice ( self ) : <EOL> class BtoR ( Component ) : <EOL> B = Array ( iotype = '<STR_LIT>' , noflat = True ) <EOL> M = Array ( iotype = '<STR_LIT>' , noflat = True ) <EOL> R = Array ( iotype = '<STR_LIT>' , noflat = True ) <EOL> def execute ( self ) : <EOL> self . R = np . array ( [ np . dot ( self . M . T , b ) for b in self . B ] ) <EOL> class B ( Component ) : <EOL> X = Array ( iotype = '<STR_LIT>' , noflat = True ) <EOL> def execute ( self ) : <EOL> self . X += <NUM_LIT:2> <EOL> class AA ( Assembly ) : <EOL> def configure ( self ) : <EOL> self . add ( '<STR_LIT>' , BtoR ( ) ) <EOL> self . create_passthrough ( '<STR_LIT>' ) <EOL> self . create_passthrough ( '<STR_LIT>' ) <EOL> self . create_passthrough ( '<STR_LIT>' ) <EOL> self . driver . workflow . add ( [ '<STR_LIT>' ] ) <EOL> class BB ( Assembly ) : <EOL> def configure ( self ) : <EOL> self . add ( '<STR_LIT:b>' , B ( ) ) <EOL>", "answer": "self . create_passthrough ( '<STR_LIT>' )"}, {"prompt": "<s> from nose import SkipTest <EOL> from rdflib . plugins . sparql import prepareQuery <EOL> from rdflib import ConjunctiveGraph , URIRef , Literal , Namespace , Variable <EOL> g = ConjunctiveGraph ( ) <EOL> def testStr ( ) : <EOL> a = set ( g . query ( \"<STR_LIT>\" , initBindings = { '<STR_LIT:target>' : URIRef ( '<STR_LIT>' ) } ) ) <EOL> b = set ( g . query ( \"<STR_LIT>\" ) ) <EOL> assert a == b , \"<STR_LIT>\" % ( a , b ) <EOL> def testIsIRI ( ) : <EOL> a = set ( g . query ( \"<STR_LIT>\" , initBindings = { '<STR_LIT:target>' : URIRef ( '<STR_LIT>' ) } ) ) <EOL> b = set ( g . query ( \"<STR_LIT>\" ) ) <EOL> assert a == b , \"<STR_LIT>\" % ( a , b ) <EOL> def testIsBlank ( ) : <EOL> a = set ( g . query ( \"<STR_LIT>\" , initBindings = { '<STR_LIT:target>' : URIRef ( '<STR_LIT>' ) } ) ) <EOL> b = set ( g . query ( \"<STR_LIT>\" ) ) <EOL> assert a == b , \"<STR_LIT>\" % ( a , b ) <EOL> def testIsLiteral ( ) : <EOL> a = set ( g . query ( \"<STR_LIT>\" , initBindings = { '<STR_LIT:target>' : Literal ( '<STR_LIT>' ) } ) ) <EOL> b = set ( g . query ( \"<STR_LIT>\" ) ) <EOL> assert a == b , \"<STR_LIT>\" % ( a , b ) <EOL> def testUCase ( ) : <EOL> a = set ( g . query ( \"<STR_LIT>\" , initBindings = { '<STR_LIT:target>' : Literal ( '<STR_LIT>' ) } ) ) <EOL> b = set ( g . query ( \"<STR_LIT>\" ) ) <EOL> assert a == b , \"<STR_LIT>\" % ( a , b ) <EOL> def testNoFunc ( ) : <EOL> a = set ( g . query ( \"<STR_LIT>\" , initBindings = { '<STR_LIT:target>' : Literal ( '<STR_LIT>' ) } ) ) <EOL> b = set ( g . query ( \"<STR_LIT>\" ) ) <EOL> assert a == b , \"<STR_LIT>\" % ( a , b ) <EOL> def testOrderBy ( ) : <EOL> a = set ( g . query ( \"<STR_LIT>\" , initBindings = { '<STR_LIT:target>' : Literal ( '<STR_LIT>' ) } ) ) <EOL> b = set ( g . query ( \"<STR_LIT>\" ) ) <EOL> assert a == b , \"<STR_LIT>\" % ( a , b ) <EOL> def testOrderByFunc ( ) : <EOL> a = set ( g . query ( \"<STR_LIT>\" , initBindings = { '<STR_LIT:target>' : Literal ( '<STR_LIT>' ) } ) ) <EOL> b = set ( g . query ( \"<STR_LIT>\" ) ) <EOL> assert a == b , \"<STR_LIT>\" % ( a , b ) <EOL> def testNoFuncLimit ( ) : <EOL> a = set ( g . query ( \"<STR_LIT>\" , initBindings = { '<STR_LIT:target>' : Literal ( '<STR_LIT>' ) } ) ) <EOL> b = set ( g . query ( \"<STR_LIT>\" ) ) <EOL>", "answer": "assert a == b , \"<STR_LIT>\" % ( a , b )"}, {"prompt": "<s> import sys <EOL> import os <EOL> import signal <EOL> import cmd <EOL> import readline <EOL> import json <EOL> import re <EOL> import sqlite3 <EOL> from optparse import OptionParser <EOL> import zmq <EOL> import requests <EOL> import getpass <EOL> for path in [ <EOL> os . path . join ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT:..>' , '<STR_LIT>' ) ) <EOL> ] : <EOL> if os . path . exists ( os . path . join ( path , '<STR_LIT>' ) ) : <EOL> sys . path . append ( path ) <EOL> break <EOL> import zmq_requestor <EOL> import constants <EOL> import util <EOL> class QasinoZMQConnection ( object ) : <EOL> def __init__ ( self , options ) : <EOL> self . options = options <EOL> self . socket = None <EOL> def connect ( self ) : <EOL> self . context = zmq . Context ( ) <EOL> self . socket = self . context . socket ( zmq . REQ ) <EOL> self . socket . connect ( \"<STR_LIT>\" % ( self . options . hostname , self . options . port ) ) <EOL> def send_and_get_response ( self , json ) : <EOL> if self . socket == None : <EOL> return None <EOL> self . socket . send ( json ) <EOL> return self . socket . recv ( ) <EOL> class QasinoHttpConnection ( object ) : <EOL> def __init__ ( self , options ) : <EOL> self . options = options <EOL> def connect ( self ) : <EOL> self . requests_conn = requests . Session ( ) <EOL> def send_and_get_response ( self , json ) : <EOL> if self . requests_conn == None : <EOL> return None <EOL> URL = '<STR_LIT>' % ( self . options . hostname , self . options . port ) <EOL> request_options = { '<STR_LIT>' : { '<STR_LIT:Content-Type>' : '<STR_LIT:application/json>' } , <EOL> '<STR_LIT:data>' : json } <EOL> if self . options . skip_ssl_verify : <EOL> request_options [ '<STR_LIT>' ] = False <EOL> if self . options . username and self . options . password : <EOL> request_options [ '<STR_LIT>' ] = ( self . options . username , self . options . password ) <EOL> try : <EOL> response = self . requests_conn . post ( URL , ** request_options ) <EOL> except Exception as e : <EOL> print \"<STR_LIT>\" % ( URL , str ( e ) ) <EOL> return None <EOL> return response . text <EOL> class QasinoCmd ( cmd . Cmd ) : <EOL> multiline_prompt = '<STR_LIT>' <EOL> default_prompt = '<STR_LIT>' <EOL> prompt = default_prompt <EOL> sql_statement = '<STR_LIT>' <EOL> def __init__ ( self , conn ) : <EOL> self . conn = conn <EOL> self . use_write_db = False <EOL> cmd . Cmd . __init__ ( self ) <EOL> def send_query ( self , sql_statement , use_write_db = False ) : <EOL> request_meta = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : sql_statement , <EOL> \"<STR_LIT>\" : use_write_db } <EOL> response = self . conn . send_and_get_response ( json . dumps ( request_meta ) ) <EOL> if response == None : <EOL> print \"<STR_LIT>\" <EOL> return <EOL> try : <EOL> obj = json . loads ( response ) <EOL> except Exception as e : <EOL> print \"<STR_LIT>\" % ( response , str ( e ) ) <EOL> return <EOL> if obj == None or \"<STR_LIT>\" not in obj : <EOL> print \"<STR_LIT>\" , obj <EOL> elif obj [ \"<STR_LIT>\" ] == \"<STR_LIT:error>\" : <EOL> if \"<STR_LIT>\" in obj : <EOL> print \"<STR_LIT>\" % str ( obj [ \"<STR_LIT>\" ] ) <EOL> else : <EOL> print \"<STR_LIT>\" <EOL> elif obj [ \"<STR_LIT>\" ] == \"<STR_LIT>\" : <EOL> max_widths = obj [ \"<STR_LIT>\" ] if \"<STR_LIT>\" in obj else None <EOL> util . pretty_print_table ( self , obj [ \"<STR_LIT>\" ] , max_widths = max_widths ) <EOL> else : <EOL> print \"<STR_LIT>\" <EOL> def sendLine ( self , line ) : <EOL> print line <EOL> def is_set_value_true ( self , value ) : <EOL> m = re . search ( r'<STR_LIT>' , value , flags = re . IGNORECASE ) <EOL> if m : <EOL> return <NUM_LIT:1> <EOL> m = re . search ( r'<STR_LIT>' , value , flags = re . IGNORECASE ) <EOL> if m : <EOL> return <NUM_LIT:0> <EOL> return - <NUM_LIT:1> <EOL> def set_set ( self , name , value ) : <EOL> if name == '<STR_LIT>' : <EOL> truth = self . is_set_value_true ( value ) <EOL> if truth == <NUM_LIT:1> : <EOL> print \"<STR_LIT>\" <EOL> self . use_write_db = True <EOL> elif truth == <NUM_LIT:0> : <EOL> print \"<STR_LIT>\" <EOL> self . use_write_db = False <EOL> else : <EOL> print \"<STR_LIT>\" % ( name , ) <EOL> else : <EOL> print \"<STR_LIT>\" % ( name , value ) <EOL> def default ( self , line ) : <EOL> self . sql_statement = self . sql_statement + '<STR_LIT:U+0020>' + line . rstrip ( '<STR_LIT:\\n>' ) <EOL> if sqlite3 . complete_statement ( self . sql_statement ) : <EOL> match_set = re . search ( r\"<STR_LIT>\" , self . sql_statement , flags = re . IGNORECASE ) <EOL> if match_set : <EOL> name = match_set . group ( <NUM_LIT:1> ) <EOL> value = match_set . group ( <NUM_LIT:2> ) <EOL> self . set_set ( name , value ) <EOL> else : <EOL> m = re . search ( r\"<STR_LIT>\" , self . sql_statement , flags = re . IGNORECASE ) <EOL> m2 = re . search ( r\"<STR_LIT>\" , self . sql_statement , flags = re . IGNORECASE ) <EOL> m3 = re . search ( r\"<STR_LIT>\" , self . sql_statement , flags = re . IGNORECASE ) <EOL> if m or m2 or m3 : <EOL> self . send_query ( self . sql_statement , self . use_write_db ) <EOL> else : <EOL> print \"<STR_LIT>\" , self . sql_statement <EOL> self . reset_multiline ( ) <EOL> else : <EOL> self . multiline ( ) <EOL> def multiline ( self ) : <EOL> self . prompt = self . multiline_prompt <EOL> def reset_multiline ( self ) : <EOL> self . prompt = self . default_prompt <EOL> self . sql_statement = '<STR_LIT>' <EOL> def emptyline ( self ) : <EOL> pass <EOL> def do_EOF ( self , line ) : <EOL> return True <EOL> def signal_handler ( signum , frame ) : <EOL> sig_names = dict ( ( k , v ) for v , k in signal . __dict__ . iteritems ( ) if v . startswith ( '<STR_LIT>' ) ) <EOL> print \"<STR_LIT>\" % sig_names [ signum ] <EOL> exit ( <NUM_LIT:0> ) <EOL> def run ( ) : <EOL> parser = OptionParser ( ) <EOL> parser . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , metavar = \"<STR_LIT>\" ) <EOL> parser . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT>\" , default = '<STR_LIT:localhost>' , <EOL> help = \"<STR_LIT>\" , metavar = \"<STR_LIT>\" ) <EOL> parser . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT:port>\" , default = constants . HTTPS_PORT , <EOL> help = \"<STR_LIT>\" , metavar = \"<STR_LIT>\" ) <EOL> parser . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT>\" , default = False , <EOL> action = '<STR_LIT:store_true>' , <EOL>", "answer": "help = \"<STR_LIT>\" )"}, {"prompt": "<s> import logging <EOL> try : <EOL>", "answer": "from . test_formdata import *"}, {"prompt": "<s> from . . cache import get_cache_key , get_hexdigest , get_hashed_mtime <EOL> from django . contrib . staticfiles import finders <EOL> from . . settings import COFFEESCRIPT_EXECUTABLE , COFFEESCRIPT_USE_CACHE , COFFEESCRIPT_CACHE_TIMEOUT , COFFEESCRIPT_ROOT , COFFEESCRIPT_OUTPUT_DIR , POSIX_COMPATIBLE <EOL> from django . conf import settings <EOL> from django . core . cache import cache <EOL> from django . template . base import Library , Node , TemplateSyntaxError <EOL> import logging <EOL> import shlex <EOL> import subprocess <EOL> import os <EOL> STATIC_ROOT = getattr ( settings , \"<STR_LIT>\" , getattr ( settings , \"<STR_LIT>\" ) ) <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> register = Library ( ) <EOL> class InlineCoffeescriptNode ( Node ) : <EOL> def __init__ ( self , nodelist ) : <EOL> self . nodelist = nodelist <EOL> def compile ( self , source ) : <EOL> args = shlex . split ( <EOL> \"<STR_LIT>\" % COFFEESCRIPT_EXECUTABLE , posix = POSIX_COMPATIBLE <EOL> ) <EOL> p = subprocess . Popen ( args , stdin = subprocess . PIPE , stdout = subprocess . PIPE ) <EOL> out , errors = p . communicate ( source . encode ( \"<STR_LIT:utf-8>\" ) ) <EOL> if out : <EOL> return out . decode ( \"<STR_LIT:utf-8>\" ) <EOL> elif errors : <EOL> return errors . decode ( \"<STR_LIT:utf-8>\" ) <EOL> return u\"<STR_LIT>\" <EOL> def render ( self , context ) : <EOL> output = self . nodelist . render ( context ) <EOL> if COFFEESCRIPT_USE_CACHE : <EOL> cache_key = get_cache_key ( get_hexdigest ( output ) ) <EOL> cached = cache . get ( cache_key , None ) <EOL> if cached is not None : <EOL> return cached <EOL> output = self . compile ( output ) <EOL> cache . set ( cache_key , output , COFFEESCRIPT_CACHE_TIMEOUT ) <EOL> return output <EOL> else : <EOL> return self . compile ( output ) <EOL> @ register . tag ( name = \"<STR_LIT>\" ) <EOL> def do_inlinecoffeescript ( parser , token ) : <EOL> nodelist = parser . parse ( ( \"<STR_LIT>\" , ) ) <EOL>", "answer": "parser . delete_first_token ( )"}, {"prompt": "<s> from __future__ import absolute_import <EOL> __author__ = '<STR_LIT>' <EOL> from array import array <EOL> from six . moves import range <EOL> from libpebble2 . events . mixin import EventSourceMixin <EOL> from libpebble2 . exceptions import GetBytesError <EOL> from libpebble2 . protocol . transfers import * <EOL> __all__ = [ \"<STR_LIT>\" ] <EOL> class GetBytesService ( EventSourceMixin ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , pebble ) : <EOL> self . _pebble = pebble <EOL> self . _txid = <NUM_LIT:0> <EOL> super ( GetBytesService , self ) . __init__ ( ) <EOL> def get_coredump ( self , require_fresh = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _get ( GetBytesUnreadCoredumpRequest ( ) if require_fresh else GetBytesCoredumpRequest ( ) ) <EOL> def get_file ( self , filename ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _get ( GetBytesFileRequest ( filename = filename ) ) <EOL> def get_flash_region ( self , offset , length ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _get ( GetBytesFlashRequest ( offset = offset , length = length ) ) <EOL> def _get ( self , message ) : <EOL> self . _txid = txid = self . _txid + <NUM_LIT:1> <EOL> queue = self . _pebble . get_endpoint_queue ( GetBytes ) <EOL> try : <EOL> self . _pebble . send_packet ( GetBytes ( transaction_id = txid , message = message ) ) <EOL> info = queue . get ( ) . message <EOL> assert isinstance ( info , GetBytesInfoResponse ) <EOL> if info . error_code != GetBytesInfoResponse . ErrorCode . Success : <EOL> raise GetBytesError ( info . error_code ) <EOL> data = array ( '<STR_LIT:B>' , ( <NUM_LIT:0> for _ in range ( info . num_bytes ) ) ) <EOL> bytes_received = <NUM_LIT:0> <EOL> while bytes_received < info . num_bytes : <EOL> part = queue . get ( ) . message <EOL> assert isinstance ( part , GetBytesDataResponse ) <EOL>", "answer": "bytes_received += len ( part . data )"}, {"prompt": "<s> def compare ( elem1 , elem2 ) : <EOL>", "answer": "JS ( \"\"\"<STR_LIT>\"\"\" )"}, {"prompt": "<s> from django . db import models <EOL> from django . contrib import auth <EOL> from threading import Lock <EOL> import inspect <EOL> from vt_manager . utils . MutexStore import MutexStore <EOL> from vt_manager . models . MacRange import MacRange <EOL> from vt_manager . models . MacSlot import MacSlot <EOL> from vt_manager . models . Ip4Slot import Ip4Slot <EOL> from vt_manager . models . Ip4Range import Ip4Range <EOL> from vt_manager . utils . EthernetUtils import EthernetUtils <EOL> from vt_manager . common . utils import validators <EOL> class NetworkInterface ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class Meta : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> app_label = '<STR_LIT>' <EOL> '''<STR_LIT>''' <EOL> name = models . CharField ( max_length = <NUM_LIT> , default = \"<STR_LIT>\" , verbose_name = \"<STR_LIT:Name>\" , validators = [ validators . resourceNameValidator ] ) <EOL> mac = models . ForeignKey ( '<STR_LIT>' , blank = True , null = False , editable = False , verbose_name = \"<STR_LIT>\" , validators = [ EthernetUtils . checkValidMac ] , related_name = \"<STR_LIT>\" ) <EOL> ip4s = models . ManyToManyField ( '<STR_LIT>' , blank = True , null = True , editable = False , verbose_name = \"<STR_LIT>\" , related_name = \"<STR_LIT>\" ) <EOL> isMgmt = models . BooleanField ( verbose_name = \"<STR_LIT>\" , default = <NUM_LIT:0> , editable = False ) <EOL> isBridge = models . BooleanField ( verbose_name = \"<STR_LIT>\" , default = <NUM_LIT:0> , editable = False ) <EOL> '''<STR_LIT>''' <EOL> connectedTo = models . ManyToManyField ( '<STR_LIT>' , blank = True , null = False , editable = False , verbose_name = \"<STR_LIT>\" , related_name = \"<STR_LIT>\" ) <EOL> '''<STR_LIT>''' <EOL> switchID = models . CharField ( max_length = <NUM_LIT> , default = \"<STR_LIT>\" , blank = True , null = True , verbose_name = \"<STR_LIT>\" , validators = [ validators . datapathValidator ] ) <EOL> port = models . IntegerField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" , validators = [ validators . numberValidator ] ) <EOL> idForm = models . IntegerField ( blank = True , null = True , editable = False ) <EOL> '''<STR_LIT>''' <EOL> doSave = True <EOL>", "answer": "'''<STR_LIT>'''"}, {"prompt": "<s> import numpy as np <EOL> from . kern import Kern <EOL> from ... core . parameterization import Param <EOL> from paramz . transformations import Logexp <EOL> from paramz . caching import Cache_this <EOL> class Poly ( Kern ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , input_dim , variance = <NUM_LIT:1.> , scale = <NUM_LIT:1.> , bias = <NUM_LIT:1.> , order = <NUM_LIT> , active_dims = None , name = '<STR_LIT>' ) : <EOL> super ( Poly , self ) . __init__ ( input_dim , active_dims , name ) <EOL> self . variance = Param ( '<STR_LIT>' , variance , Logexp ( ) ) <EOL> self . scale = Param ( '<STR_LIT>' , scale , Logexp ( ) ) <EOL> self . bias = Param ( '<STR_LIT>' , bias , Logexp ( ) ) <EOL> self . link_parameters ( self . variance , self . scale , self . bias ) <EOL> assert order >= <NUM_LIT:1> , '<STR_LIT>' <EOL> self . order = order <EOL> def K ( self , X , X2 = None ) : <EOL> _ , _ , B = self . _AB ( X , X2 ) <EOL> return B * self . variance <EOL> @ Cache_this ( limit = <NUM_LIT:3> ) <EOL> def _AB ( self , X , X2 = None ) : <EOL> if X2 is None : <EOL> dot_prod = np . dot ( X , X . T ) <EOL> else : <EOL> dot_prod = np . dot ( X , X2 . T ) <EOL> A = ( self . scale * dot_prod ) + self . bias <EOL> B = A ** self . order <EOL> return dot_prod , A , B <EOL> def Kdiag ( self , X ) : <EOL> return self . K ( X ) . diagonal ( ) <EOL> def update_gradients_full ( self , dL_dK , X , X2 = None ) : <EOL> dot_prod , A , B = self . _AB ( X , X2 ) <EOL> dK_dA = self . variance * self . order * A ** ( self . order - <NUM_LIT:1.> ) <EOL> dL_dA = dL_dK * ( dK_dA ) <EOL> self . scale . gradient = ( dL_dA * dot_prod ) . sum ( ) <EOL> self . bias . gradient = dL_dA . sum ( ) <EOL> self . variance . gradient = np . sum ( dL_dK * B ) <EOL>", "answer": "def update_gradients_diag ( self , dL_dKdiag , X ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import unicode_literals , absolute_import , print_function <EOL> from builtins import object <EOL> import sys <EOL> import subprocess <EOL> from unipath import Path <EOL> from atelier import rstgen <EOL> from atelier . utils import unindent <EOL> from selenium import webdriver <EOL> from selenium . webdriver . common . action_chains import ActionChains <EOL> from selenium . webdriver . common . by import By <EOL> from selenium . webdriver . support . ui import WebDriverWait <EOL> from selenium . webdriver . support import expected_conditions as EC <EOL> def runserver ( settings_module , func , driver = None ) : <EOL> args = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> settings_module ] <EOL> server = subprocess . Popen ( args , stdout = None , stderr = None ) <EOL> if driver is None : <EOL> driver = webdriver . Firefox ( ) <EOL> try : <EOL> driver . get ( \"<STR_LIT>\" ) <EOL> func ( driver ) <EOL> finally : <EOL> driver . quit ( ) <EOL> server . terminate ( ) <EOL> class Album ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> screenshot_root = None <EOL> screenshots = [ ] <EOL> title = None <EOL> intro = None <EOL> ref = None <EOL> def __init__ ( self , driver , root = None , title = \"<STR_LIT>\" , <EOL> ref = None , intro = None ) : <EOL> self . driver = driver <EOL> self . actionChains = ActionChains ( driver ) <EOL> if root is not None : <EOL> self . screenshot_root = Path ( root ) <EOL> self . screenshots = [ ] <EOL>", "answer": "self . title = title"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import migrations , models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL>", "answer": "migrations . CreateModel ("}, {"prompt": "<s> import sys <EOL> import logging <EOL> from flask import Flask <EOL> from sqlalchemy import create_engine <EOL> from flask_appbuilder . security . sqla . models import User <EOL> logging . basicConfig ( format = '<STR_LIT>' ) <EOL> logging . getLogger ( ) . setLevel ( logging . DEBUG ) <EOL> log = logging . getLogger ( '<STR_LIT>' ) <EOL> try : <EOL> app = Flask ( __name__ ) <EOL> app . config . from_object ( '<STR_LIT>' ) <EOL> except Exception as e : <EOL> if len ( sys . argv ) < <NUM_LIT:2> : <EOL> print \"<STR_LIT>\" <EOL> print \"<STR_LIT>\" <EOL> exit ( ) <EOL> con_str = sys . argv [ <NUM_LIT:1> ] <EOL> app = Flask ( __name__ ) <EOL> app . config [ '<STR_LIT>' ] = con_str <EOL> add_column_stmt = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' } <EOL> mod_column_stmt = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' } <EOL> def check_engine_support ( conn ) : <EOL> if not conn . engine . name in add_column_stmt : <EOL> log . error ( '<STR_LIT>' ) <EOL> exit ( ) <EOL> def add_column ( conn , table , column ) : <EOL> table_name = table . __tablename__ <EOL> column_name = column . key <EOL> column_type = column . type . compile ( conn . dialect ) <EOL> try : <EOL> log . info ( \"<STR_LIT>\" . format ( column_name , table_name ) ) <EOL>", "answer": "conn . execute ( add_column_stmt [ conn . engine . name ] % ( table_name , column_name , column_type ) )"}, {"prompt": "<s> import sys <EOL> import os <EOL>", "answer": "from setuptools import setup , find_packages"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL> import sortedm2m . fields <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , serialize = False , auto_created = True , primary_key = True ) ) , <EOL> ] , <EOL> options = { <EOL> } , <EOL> bases = ( models . Model , ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , serialize = False , auto_created = True , primary_key = True ) ) , <EOL> ] , <EOL> options = { <EOL> } , <EOL> bases = ( models . Model , ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , serialize = False , auto_created = True , primary_key = True ) ) , <EOL> ] , <EOL> options = { <EOL> } , <EOL> bases = ( models . Model , ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field = sortedm2m . fields . SortedManyToManyField ( help_text = None , to = '<STR_LIT>' ) , <EOL> preserve_default = True , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field = models . ManyToManyField ( to = '<STR_LIT>' ) , <EOL>", "answer": "preserve_default = True ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> DATE_FORMAT = '<STR_LIT>' <EOL> STATUS_OK = \"<STR_LIT:OK>\" <EOL> STATUS_ERR = \"<STR_LIT>\" <EOL> LAST_UPDATED = '<STR_LIT>' <EOL> DATE_CREATED = '<STR_LIT>' <EOL> ISSUES = '<STR_LIT>' <EOL> STATUS = '<STR_LIT>' <EOL> ERROR = '<STR_LIT>' <EOL> ITEMS = '<STR_LIT>' <EOL> LINKS = '<STR_LIT>' <EOL> ETAG = '<STR_LIT>' <EOL> VERSION = '<STR_LIT>' <EOL> DELETED = '<STR_LIT>' <EOL> META = '<STR_LIT>' <EOL> INFO = None <EOL> VALIDATION_ERROR_STATUS = <NUM_LIT> <EOL> VALIDATION_ERROR_AS_LIST = False <EOL> STANDARD_ERRORS = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> LATEST_VERSION = '<STR_LIT>' <EOL> VERSION_ID_SUFFIX = '<STR_LIT>' <EOL> VERSION_DIFF_INCLUDE = [ ] <EOL> API_VERSION = '<STR_LIT>' <EOL> URL_PREFIX = '<STR_LIT>' <EOL> ID_FIELD = '<STR_LIT>' <EOL> CACHE_CONTROL = '<STR_LIT>' <EOL> CACHE_EXPIRES = <NUM_LIT:0> <EOL> ITEM_CACHE_CONTROL = '<STR_LIT>' <EOL> X_DOMAINS = None <EOL> X_HEADERS = None <EOL> X_EXPOSE_HEADERS = None <EOL> X_ALLOW_CREDENTIALS = None <EOL> X_MAX_AGE = <NUM_LIT> <EOL> HATEOAS = True <EOL> IF_MATCH = True <EOL> ALLOWED_FILTERS = [ '<STR_LIT:*>' ] <EOL> VALIDATE_FILTERS = False <EOL> SORTING = True <EOL> JSON_SORT_KEYS = False <EOL> EMBEDDING = True <EOL> PROJECTION = True <EOL> PAGINATION = True <EOL> PAGINATION_LIMIT = <NUM_LIT:50> <EOL> PAGINATION_DEFAULT = <NUM_LIT> <EOL> VERSIONING = False <EOL> VERSIONS = '<STR_LIT>' <EOL> VERSION_PARAM = '<STR_LIT:version>' <EOL> INTERNAL_RESOURCE = False <EOL> JSONP_ARGUMENT = None <EOL> SOFT_DELETE = False <EOL> SHOW_DELETED_PARAM = '<STR_LIT>' <EOL> BULK_ENABLED = True <EOL> OPLOG = False <EOL> OPLOG_NAME = '<STR_LIT>' <EOL> OPLOG_ENDPOINT = None <EOL> OPLOG_AUDIT = True <EOL> OPLOG_METHODS = [ '<STR_LIT>' , <EOL> '<STR_LIT:POST>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> OPLOG_CHANGE_METHODS = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL>", "answer": "OPLOG_RETURN_EXTRA_FIELD = False"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Static ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . . phonemetadata import NumberFormat , PhoneNumberDesc , PhoneMetadata <EOL> PHONE_METADATA_GP = PhoneMetadata ( id = '<STR_LIT>' , country_code = None , international_prefix = None , <EOL> general_desc = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> toll_free = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> premium_rate = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL>", "answer": "emergency = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' , example_number = '<STR_LIT>' ) ,"}, {"prompt": "<s> import collections <EOL> def paragraph ( style_id = None , style_name = None , numbering = None ) : <EOL> return ParagraphMatcher ( style_id , style_name , numbering ) <EOL> ParagraphMatcher = collections . namedtuple ( \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> ParagraphMatcher . element_type = \"<STR_LIT>\" <EOL>", "answer": "def run ( style_id = None , style_name = None ) :"}, {"prompt": "<s> import json <EOL> import uuid <EOL> from falcon import status_codes <EOL> from jumpgate . common import hooks <EOL> @ hooks . response_hook ( False ) <EOL> def hook_format ( req , resp ) : <EOL> body = resp . body <EOL> if body is not None and not resp . content_type : <EOL> resp . content_type = '<STR_LIT:application/json>' <EOL>", "answer": "resp . body = json . dumps ( body )"}, {"prompt": "<s> from django . utils . translation import ugettext_lazy as _ <EOL>", "answer": "from sellmo . core . apps import SellmoAppConfig"}, {"prompt": "<s> import os <EOL> ADMINS = ( <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ) <EOL> BASE_PATH = os . path . abspath ( os . path . dirname ( __file__ ) ) <EOL> MEDIA_ROOT = os . path . normpath ( os . path . join ( BASE_PATH , '<STR_LIT>' ) ) <EOL> DATABASE_ENGINE = '<STR_LIT>' <EOL> DATABASE_NAME = '<STR_LIT>' <EOL> TEST_DATABASE_NAME = '<STR_LIT>' <EOL> DATABASES = { <EOL>", "answer": "'<STR_LIT:default>' : {"}, {"prompt": "<s> from mock import patch <EOL> from py2neo import Node , Relationship , Path , remote <EOL> from test . util import GraphTestCase <EOL> class NodeHydrationTestCase ( GraphTestCase ) : <EOL> def setUp ( self ) : <EOL> Node . cache . clear ( ) <EOL> def test_minimal_node_hydrate ( self ) : <EOL> dehydrated = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> hydrated = Node . hydrate ( dehydrated ) <EOL> assert isinstance ( hydrated , Node ) <EOL> assert remote ( hydrated ) <EOL> assert remote ( hydrated ) . uri == dehydrated [ \"<STR_LIT>\" ] <EOL> def test_node_hydrate_with_properties ( self ) : <EOL> dehydrated = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:data>\" : { <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> } , <EOL>", "answer": "}"}, {"prompt": "<s> from django . conf . urls import patterns , url <EOL> from yaksh import views <EOL> from django . contrib . auth . views import password_reset , password_reset_confirm , password_reset_done , password_reset_complete , password_change , password_change_done <EOL> urlpatterns = [ <EOL> url ( r'<STR_LIT>' , password_reset , name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , <EOL> password_reset_confirm , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , password_reset_done , <EOL> name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , password_reset_complete , <EOL> name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , password_change , <EOL> name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , password_change_done , <EOL> name = '<STR_LIT>' ) , <EOL> ] <EOL> urlpatterns += [ <EOL> url ( r'<STR_LIT>' , views . index ) , <EOL> url ( r'<STR_LIT>' , views . user_login ) , <EOL> url ( r'<STR_LIT>' , views . quizlist_user ) , <EOL> url ( r'<STR_LIT>' , views . results_user ) , <EOL> url ( r'<STR_LIT>' , views . start ) , <EOL> url ( r'<STR_LIT>' , views . start ) , <EOL> url ( r'<STR_LIT>' , views . start ) , <EOL> url ( r'<STR_LIT>' , views . quit ) , <EOL> url ( r'<STR_LIT>' , views . complete ) , <EOL> url ( r'<STR_LIT>' , views . complete ) , <EOL> url ( r'<STR_LIT>' , views . user_register ) , <EOL> url ( r'<STR_LIT>' , views . check ) , <EOL> url ( r'<STR_LIT>' , views . check ) , <EOL> url ( r'<STR_LIT>' , <EOL> views . skip ) , <EOL> url ( r'<STR_LIT>' , <EOL> views . skip ) , <EOL> url ( r'<STR_LIT>' , views . enroll_request ) , <EOL> url ( r'<STR_LIT>' , views . self_enroll ) , <EOL> url ( r'<STR_LIT>' , views . prof_manage ) , <EOL> url ( r'<STR_LIT>' , views . add_question ) , <EOL> url ( r'<STR_LIT>' , views . add_question ) , <EOL> url ( r'<STR_LIT>' , views . add_quiz ) , <EOL> url ( r'<STR_LIT>' , views . add_quiz ) , <EOL> url ( r'<STR_LIT>' , views . show_all_users ) , <EOL> url ( r'<STR_LIT>' , <EOL> views . grade_user ) , <EOL> url ( r'<STR_LIT>' , views . grade_user ) , <EOL> url ( r'<STR_LIT>' , views . show_all_questions ) , <EOL> url ( r'<STR_LIT>' , views . monitor ) , <EOL> url ( r'<STR_LIT>' , views . show_all_questionpapers ) , <EOL> url ( r'<STR_LIT>' , views . show_all_questionpapers ) , <EOL> url ( r'<STR_LIT>' , views . monitor ) , <EOL> url ( r'<STR_LIT>' , <EOL> views . user_data ) , <EOL> url ( r'<STR_LIT>' , views . user_data ) , <EOL> url ( r'<STR_LIT>' , views . design_questionpaper ) , <EOL> url ( r'<STR_LIT>' , views . design_questionpaper ) , <EOL> url ( r'<STR_LIT>' , <EOL> views . show_statistics ) , <EOL> url ( r'<STR_LIT>' , <EOL> views . show_statistics ) , <EOL> url ( r'<STR_LIT>' , <EOL> views . download_csv ) , <EOL> url ( r'<STR_LIT>' , views . courses ) , <EOL> url ( r'<STR_LIT>' , views . add_course ) , <EOL> url ( r'<STR_LIT>' , views . course_detail ) , <EOL> url ( r'<STR_LIT>' , views . enroll ) , <EOL> url ( r'<STR_LIT>' , <EOL> views . enroll , { '<STR_LIT>' : True } ) , <EOL> url ( r'<STR_LIT>' , views . reject ) , <EOL> url ( r'<STR_LIT>' , <EOL> views . reject , { '<STR_LIT>' : True } ) , <EOL> url ( r'<STR_LIT>' , views . toggle_course_status ) , <EOL> url ( r'<STR_LIT>' , views . ajax_questionpaper ) , <EOL> url ( r'<STR_LIT>' , views . ajax_questions_filter ) , <EOL> url ( r'<STR_LIT>' , views . edit_profile ) , <EOL> url ( r'<STR_LIT>' , views . view_profile ) , <EOL> url ( r'<STR_LIT>' , views . enroll ) , <EOL>", "answer": "url ( r'<STR_LIT>' ,"}, {"prompt": "<s> from . . excel_comparsion_test import ExcelComparisonTest <EOL> from ... workbook import Workbook <EOL> class TestCompareXLSXFiles ( ExcelComparisonTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . maxDiff = None <EOL> filename = '<STR_LIT>' <EOL> test_dir = '<STR_LIT>' <EOL> self . got_filename = test_dir + '<STR_LIT>' + filename <EOL> self . exp_filename = test_dir + '<STR_LIT>' + filename <EOL> self . ignore_files = [ ] <EOL> self . ignore_elements = { } <EOL> def test_create_file ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> workbook = Workbook ( self . got_filename ) <EOL> worksheet = workbook . add_worksheet ( ) <EOL> chart = workbook . add_chart ( { '<STR_LIT:type>' : '<STR_LIT>' } ) <EOL> chart . axis_ids = [ <NUM_LIT> , <NUM_LIT> ] <EOL> data = [ <EOL> [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> ] , <EOL> [ <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:6> , <NUM_LIT:8> , <NUM_LIT:10> ] , <EOL> [ <NUM_LIT:3> , <NUM_LIT:6> , <NUM_LIT:9> , <NUM_LIT:12> , <NUM_LIT:15> ] , <EOL> ] <EOL> worksheet . write_column ( '<STR_LIT>' , data [ <NUM_LIT:0> ] ) <EOL> worksheet . write_column ( '<STR_LIT>' , data [ <NUM_LIT:1> ] ) <EOL> worksheet . write_column ( '<STR_LIT>' , data [ <NUM_LIT:2> ] ) <EOL> chart . add_series ( { <EOL>", "answer": "'<STR_LIT>' : '<STR_LIT>' ,"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL> import seq_delayed <EOL>", "answer": "expected_verilog = \"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "<s> from twisted . application . service import ServiceMaker <EOL> TwistedPortForward = ServiceMaker ( <EOL>", "answer": "\"<STR_LIT>\" ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from warnings import warnpy3k <EOL> warnpy3k ( \"<STR_LIT>\" , stacklevel = <NUM_LIT:2> ) <EOL> del warnpy3k <EOL> import __builtin__ <EOL> import imp <EOL> import os <EOL> import sys <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> VERBOSE = <NUM_LIT:0> <EOL> from imp import C_EXTENSION , PY_SOURCE , PY_COMPILED <EOL> from imp import C_BUILTIN , PY_FROZEN , PKG_DIRECTORY <EOL> BUILTIN_MODULE = C_BUILTIN <EOL> FROZEN_MODULE = PY_FROZEN <EOL> class _Verbose : <EOL> def __init__ ( self , verbose = VERBOSE ) : <EOL> self . verbose = verbose <EOL> def get_verbose ( self ) : <EOL> return self . verbose <EOL> def set_verbose ( self , verbose ) : <EOL> self . verbose = verbose <EOL> def note ( self , * args ) : <EOL> if self . verbose : <EOL> self . message ( * args ) <EOL> def message ( self , format , * args ) : <EOL> if args : <EOL> print format % args <EOL> else : <EOL> print format <EOL> class BasicModuleLoader ( _Verbose ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def find_module ( self , name , path = None ) : <EOL> if path is None : <EOL> path = [ None ] + self . default_path ( ) <EOL> for dir in path : <EOL> stuff = self . find_module_in_dir ( name , dir ) <EOL> if stuff : return stuff <EOL> return None <EOL> def default_path ( self ) : <EOL> return sys . path <EOL> def find_module_in_dir ( self , name , dir ) : <EOL> if dir is None : <EOL> return self . find_builtin_module ( name ) <EOL> else : <EOL> try : <EOL> return imp . find_module ( name , [ dir ] ) <EOL> except ImportError : <EOL> return None <EOL> def find_builtin_module ( self , name ) : <EOL> if imp . is_builtin ( name ) : <EOL> return None , '<STR_LIT>' , ( '<STR_LIT>' , '<STR_LIT>' , BUILTIN_MODULE ) <EOL> if imp . is_frozen ( name ) : <EOL> return None , '<STR_LIT>' , ( '<STR_LIT>' , '<STR_LIT>' , FROZEN_MODULE ) <EOL> return None <EOL> def load_module ( self , name , stuff ) : <EOL> file , filename , info = stuff <EOL> try : <EOL> return imp . load_module ( name , file , filename , info ) <EOL> finally : <EOL> if file : file . close ( ) <EOL> class Hooks ( _Verbose ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def get_suffixes ( self ) : return imp . get_suffixes ( ) <EOL> def new_module ( self , name ) : return imp . new_module ( name ) <EOL> def is_builtin ( self , name ) : return imp . is_builtin ( name ) <EOL> def init_builtin ( self , name ) : return imp . init_builtin ( name ) <EOL> def is_frozen ( self , name ) : return imp . is_frozen ( name ) <EOL> def init_frozen ( self , name ) : return imp . init_frozen ( name ) <EOL> def get_frozen_object ( self , name ) : return imp . get_frozen_object ( name ) <EOL> def load_source ( self , name , filename , file = None ) : <EOL> return imp . load_source ( name , filename , file ) <EOL> def load_compiled ( self , name , filename , file = None ) : <EOL> return imp . load_compiled ( name , filename , file ) <EOL> def load_dynamic ( self , name , filename , file = None ) : <EOL> return imp . load_dynamic ( name , filename , file ) <EOL> def load_package ( self , name , filename , file = None ) : <EOL> return imp . load_module ( name , file , filename , ( \"<STR_LIT>\" , \"<STR_LIT>\" , PKG_DIRECTORY ) ) <EOL> def add_module ( self , name ) : <EOL> d = self . modules_dict ( ) <EOL> if name in d : return d [ name ] <EOL> d [ name ] = m = self . new_module ( name ) <EOL> return m <EOL> def modules_dict ( self ) : return sys . modules <EOL> def default_path ( self ) : return sys . path <EOL> def path_split ( self , x ) : return os . path . split ( x ) <EOL> def path_join ( self , x , y ) : return os . path . join ( x , y ) <EOL> def path_isabs ( self , x ) : return os . path . isabs ( x ) <EOL> def path_exists ( self , x ) : return os . path . exists ( x ) <EOL> def path_isdir ( self , x ) : return os . path . isdir ( x ) <EOL> def path_isfile ( self , x ) : return os . path . isfile ( x ) <EOL> def path_islink ( self , x ) : return os . path . islink ( x ) <EOL> def openfile ( self , * x ) : return open ( * x ) <EOL> openfile_error = IOError <EOL> def listdir ( self , x ) : return os . listdir ( x ) <EOL> listdir_error = os . error <EOL> class ModuleLoader ( BasicModuleLoader ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , hooks = None , verbose = VERBOSE ) : <EOL> BasicModuleLoader . __init__ ( self , verbose ) <EOL> self . hooks = hooks or Hooks ( verbose ) <EOL> def default_path ( self ) : <EOL> return self . hooks . default_path ( ) <EOL> def modules_dict ( self ) : <EOL> return self . hooks . modules_dict ( ) <EOL> def get_hooks ( self ) : <EOL> return self . hooks <EOL> def set_hooks ( self , hooks ) : <EOL> self . hooks = hooks <EOL> def find_builtin_module ( self , name ) : <EOL> if self . hooks . is_builtin ( name ) : <EOL> return None , '<STR_LIT>' , ( '<STR_LIT>' , '<STR_LIT>' , BUILTIN_MODULE ) <EOL> if self . hooks . is_frozen ( name ) : <EOL> return None , '<STR_LIT>' , ( '<STR_LIT>' , '<STR_LIT>' , FROZEN_MODULE ) <EOL> return None <EOL> def find_module_in_dir ( self , name , dir , allow_packages = <NUM_LIT:1> ) : <EOL> if dir is None : <EOL> return self . find_builtin_module ( name ) <EOL> if allow_packages : <EOL> fullname = self . hooks . path_join ( dir , name ) <EOL> if self . hooks . path_isdir ( fullname ) : <EOL> stuff = self . find_module_in_dir ( \"<STR_LIT>\" , fullname , <NUM_LIT:0> ) <EOL> if stuff : <EOL> file = stuff [ <NUM_LIT:0> ] <EOL> if file : file . close ( ) <EOL> return None , fullname , ( '<STR_LIT>' , '<STR_LIT>' , PKG_DIRECTORY ) <EOL> for info in self . hooks . get_suffixes ( ) : <EOL> suff , mode , type = info <EOL> fullname = self . hooks . path_join ( dir , name + suff ) <EOL> try : <EOL> fp = self . hooks . openfile ( fullname , mode ) <EOL> return fp , fullname , info <EOL> except self . hooks . openfile_error : <EOL> pass <EOL> return None <EOL> def load_module ( self , name , stuff ) : <EOL> file , filename , info = stuff <EOL> ( suff , mode , type ) = info <EOL> try : <EOL> if type == BUILTIN_MODULE : <EOL> return self . hooks . init_builtin ( name ) <EOL> if type == FROZEN_MODULE : <EOL> return self . hooks . init_frozen ( name ) <EOL> if type == C_EXTENSION : <EOL> m = self . hooks . load_dynamic ( name , filename , file ) <EOL> elif type == PY_SOURCE : <EOL> m = self . hooks . load_source ( name , filename , file ) <EOL> elif type == PY_COMPILED : <EOL> m = self . hooks . load_compiled ( name , filename , file ) <EOL> elif type == PKG_DIRECTORY : <EOL> m = self . hooks . load_package ( name , filename , file ) <EOL> else : <EOL> raise ImportError , \"<STR_LIT>\" % ( type , name ) <EOL> finally : <EOL> if file : file . close ( ) <EOL> m . __file__ = filename <EOL> return m <EOL> class FancyModuleLoader ( ModuleLoader ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def load_module ( self , name , stuff ) : <EOL> file , filename , ( suff , mode , type ) = stuff <EOL> realfilename = filename <EOL> path = None <EOL> if type == PKG_DIRECTORY : <EOL> initstuff = self . find_module_in_dir ( \"<STR_LIT>\" , filename , <NUM_LIT:0> ) <EOL> if not initstuff : <EOL> raise ImportError , \"<STR_LIT>\" % name <EOL> initfile , initfilename , initinfo = initstuff <EOL> initsuff , initmode , inittype = initinfo <EOL> if inittype not in ( PY_COMPILED , PY_SOURCE ) : <EOL> if initfile : initfile . close ( ) <EOL> raise ImportError , \"<STR_LIT>\" % ( <EOL> inittype , name ) <EOL> path = [ filename ] <EOL> file = initfile <EOL> realfilename = initfilename <EOL> type = inittype <EOL> if type == FROZEN_MODULE : <EOL> code = self . hooks . get_frozen_object ( name ) <EOL> elif type == PY_COMPILED : <EOL> import marshal <EOL> file . seek ( <NUM_LIT:8> ) <EOL> code = marshal . load ( file ) <EOL> elif type == PY_SOURCE : <EOL> data = file . read ( ) <EOL> code = compile ( data , realfilename , '<STR_LIT>' ) <EOL> else : <EOL> return ModuleLoader . load_module ( self , name , stuff ) <EOL> m = self . hooks . add_module ( name ) <EOL> if path : <EOL>", "answer": "m . __path__ = path"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "from numpy . random import random"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> import math <EOL> from random import choice <EOL> from operator import itemgetter <EOL> from itertools import groupby <EOL> from jinja2 . utils import Markup , escape , pformat , urlize , soft_unicode , unicode_urlencode <EOL> from jinja2 . runtime import Undefined <EOL> from jinja2 . exceptions import FilterArgumentError <EOL> from jinja2 . _compat import imap , string_types , text_type , iteritems <EOL> _word_re = re . compile ( r'<STR_LIT>' ) <EOL> def contextfilter ( f ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> f . contextfilter = True <EOL> return f <EOL> def evalcontextfilter ( f ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> f . evalcontextfilter = True <EOL> return f <EOL> def environmentfilter ( f ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> f . environmentfilter = True <EOL> return f <EOL> def make_attrgetter ( environment , attribute ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( attribute , string_types ) or ( '<STR_LIT:.>' not in attribute and not attribute . isdigit ( ) ) : <EOL> return lambda x : environment . getitem ( x , attribute ) <EOL> attribute = attribute . split ( '<STR_LIT:.>' ) <EOL> def attrgetter ( item ) : <EOL> for part in attribute : <EOL> if part . isdigit ( ) : <EOL> part = int ( part ) <EOL> item = environment . getitem ( item , part ) <EOL> return item <EOL> return attrgetter <EOL> def do_forceescape ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if hasattr ( value , '<STR_LIT>' ) : <EOL> value = value . __html__ ( ) <EOL> return escape ( text_type ( value ) ) <EOL> def do_urlencode ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> itemiter = None <EOL> if isinstance ( value , dict ) : <EOL> itemiter = iteritems ( value ) <EOL> elif not isinstance ( value , string_types ) : <EOL> try : <EOL> itemiter = iter ( value ) <EOL> except TypeError : <EOL> pass <EOL> if itemiter is None : <EOL> return unicode_urlencode ( value ) <EOL> return u'<STR_LIT:&>' . join ( unicode_urlencode ( k ) + '<STR_LIT:=>' + <EOL> unicode_urlencode ( v , for_qs = True ) <EOL> for k , v in itemiter ) <EOL> @ evalcontextfilter <EOL> def do_replace ( eval_ctx , s , old , new , count = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if count is None : <EOL> count = - <NUM_LIT:1> <EOL> if not eval_ctx . autoescape : <EOL> return text_type ( s ) . replace ( text_type ( old ) , text_type ( new ) , count ) <EOL> if hasattr ( old , '<STR_LIT>' ) or hasattr ( new , '<STR_LIT>' ) and not hasattr ( s , '<STR_LIT>' ) : <EOL> s = escape ( s ) <EOL> else : <EOL> s = soft_unicode ( s ) <EOL> return s . replace ( soft_unicode ( old ) , soft_unicode ( new ) , count ) <EOL> def do_upper ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return soft_unicode ( s ) . upper ( ) <EOL> def do_lower ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return soft_unicode ( s ) . lower ( ) <EOL> @ evalcontextfilter <EOL> def do_xmlattr ( _eval_ctx , d , autospace = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rv = u'<STR_LIT:U+0020>' . join ( <EOL> u'<STR_LIT>' % ( escape ( key ) , escape ( value ) ) <EOL> for key , value in iteritems ( d ) <EOL> if value is not None and not isinstance ( value , Undefined ) <EOL> ) <EOL> if autospace and rv : <EOL> rv = u'<STR_LIT:U+0020>' + rv <EOL> if _eval_ctx . autoescape : <EOL> rv = Markup ( rv ) <EOL> return rv <EOL> def do_capitalize ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return soft_unicode ( s ) . capitalize ( ) <EOL> def do_title ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rv = [ ] <EOL> for item in re . compile ( r'<STR_LIT>' ) . split ( soft_unicode ( s ) ) : <EOL> if not item : <EOL> continue <EOL> rv . append ( item [ <NUM_LIT:0> ] . upper ( ) + item [ <NUM_LIT:1> : ] . lower ( ) ) <EOL>", "answer": "return '<STR_LIT>' . join ( rv )"}, {"prompt": "<s> from django . db import models <EOL> from bioblend import galaxy <EOL> from galaxy_connector . galaxy_workflow import ( GalaxyWorkflow , <EOL> GalaxyWorkflowInput ) <EOL> class Instance ( models . Model ) : <EOL> base_url = models . CharField ( max_length = <NUM_LIT> ) <EOL>", "answer": "data_url = models . CharField ( max_length = <NUM_LIT:100> , default = \"<STR_LIT>\" )"}, {"prompt": "<s> from datetime import date <EOL> from stdnet . utils import test <EOL> from stdnet . apps . columnts import ColumnTS <EOL> from . main import ColumnMixin , nan <EOL> class TestReadOnly ( ColumnMixin , test . TestCase ) : <EOL> @ classmethod <EOL> def after_setup ( cls ) : <EOL> cls . ts1 = yield cls . data . data1 . create ( cls ) <EOL> cls . ts2 = yield cls . data . data2 . create ( cls ) <EOL> cls . ts3 = yield cls . data . data3 . create ( cls ) <EOL> cls . mul1 = yield cls . data . data_mul1 . create ( cls ) <EOL> cls . mul2 = yield cls . data . data_mul2 . create ( cls ) <EOL> def test_info_simple ( self ) : <EOL> ts = yield self . empty ( ) <EOL> info = yield ts . info ( ) <EOL> self . assertEqual ( info [ '<STR_LIT:size>' ] , <NUM_LIT:0> ) <EOL> self . assertFalse ( '<STR_LIT:start>' in info ) <EOL> d1 = date ( <NUM_LIT> , <NUM_LIT:5> , <NUM_LIT:15> ) <EOL> d2 = date ( <NUM_LIT> , <NUM_LIT:5> , <NUM_LIT:16> ) <EOL> yield ts . update ( { d1 : { '<STR_LIT>' : <NUM_LIT> } , <EOL> d2 : { '<STR_LIT>' : <NUM_LIT> } } ) <EOL> info = yield ts . info ( ) <EOL> self . assertEqual ( info [ '<STR_LIT:size>' ] , <NUM_LIT:2> ) <EOL> self . assertEqual ( info [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <NUM_LIT:0> ) <EOL> self . assertEqual ( info [ '<STR_LIT:start>' ] . date ( ) , d1 ) <EOL>", "answer": "self . assertEqual ( info [ '<STR_LIT>' ] . date ( ) , d2 )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from search_api import SearchService <EOL> import logging <EOL> import tornado . httpserver <EOL> import tornado . httputil <EOL> import tornado . ioloop <EOL> import tornado . web <EOL> import time <EOL> DEFAULT_PORT = <NUM_LIT> <EOL> class MainHandler ( tornado . web . RequestHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def initialize ( self , search_service ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . search_service = search_service <EOL> @ tornado . web . asynchronous <EOL> def post ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> request = self . request <EOL> http_request_data = request . body <EOL>", "answer": "pb_type = request . headers [ '<STR_LIT>' ]"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , print_function <EOL> import rethinkdb as r <EOL> import db . common <EOL> def init ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> db . common . init_table ( '<STR_LIT>' , primary_key = '<STR_LIT>' ) <EOL> def add_tag ( plugin_id , tag ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "with db . common . connect ( ) as con :"}, {"prompt": "<s> from datetime import datetime , timedelta <EOL> import logging <EOL> import os <EOL> import tempfile <EOL> from thespian . actors import InvalidActorSpecification <EOL> def timePeriodSeconds ( basis , other = None ) : <EOL> if isinstance ( basis , datetime ) : <EOL> if isinstance ( other , datetime ) : <EOL> return timePeriodSeconds ( other - basis ) <EOL> if isinstance ( basis , timedelta ) : <EOL> try : <EOL> return basis . total_seconds ( ) <EOL> except AttributeError : <EOL> return ( basis . days * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) + basis . seconds + ( basis . microseconds / <NUM_LIT> / <NUM_LIT:1000> ) <EOL> raise TypeError ( '<STR_LIT>' % str ( type ( basis ) ) ) <EOL> def toTimeDeltaOrNone ( timespec ) : <EOL> if timespec is None : return None <EOL> if isinstance ( timespec , timedelta ) : return timespec <EOL> if isinstance ( timespec , int ) : return timedelta ( seconds = timespec ) <EOL> if isinstance ( timespec , float ) : <EOL> return timedelta ( seconds = int ( timespec ) , <EOL> microseconds = int ( ( timespec - int ( timespec ) ) * <NUM_LIT:1000> * <NUM_LIT:1000> ) ) <EOL> raise TypeError ( '<STR_LIT>' % type ( timespec ) ) <EOL> class ExpiryTime ( object ) : <EOL> def __init__ ( self , duration ) : <EOL> self . _time_to_quit = None if duration is None else ( datetime . now ( ) + duration ) <EOL> def expired ( self ) : <EOL> return False if self . _time_to_quit is None else ( datetime . now ( ) >= self . _time_to_quit ) <EOL> def remaining ( self , forever = None ) : <EOL> return forever if self . _time_to_quit is None else ( timedelta ( seconds = <NUM_LIT:0> ) if datetime . now ( ) > self . _time_to_quit else ( self . _time_to_quit - datetime . now ( ) ) ) <EOL> def remainingSeconds ( self , forever = None ) : <EOL> return forever if self . _time_to_quit is None else ( <NUM_LIT:0> if datetime . now ( ) > self . _time_to_quit else timePeriodSeconds ( self . _time_to_quit - datetime . now ( ) ) ) <EOL> def __str__ ( self ) : <EOL> if self . _time_to_quit is None : return '<STR_LIT>' <EOL> if self . expired ( ) : <EOL> return '<STR_LIT>' % ( datetime . now ( ) - self . _time_to_quit ) <EOL> return '<STR_LIT>' + str ( self . remaining ( ) ) <EOL> def __eq__ ( self , o ) : <EOL> if isinstance ( o , timedelta ) : <EOL> o = ExpiryTime ( o ) <EOL> if self . _time_to_quit == o . _time_to_quit : return True <EOL> if self . _time_to_quit == None or o . _time_to_quit == None : return False <EOL> if self . expired ( ) and o . expired ( ) : return True <EOL> return abs ( self . _time_to_quit - o . _time_to_quit ) < timedelta ( microseconds = <NUM_LIT:1> ) <EOL> def __lt__ ( self , o ) : <EOL> try : <EOL> if self . _time_to_quit is None and o . _time_to_quit is None : return False <EOL> except Exception : pass <EOL> if self . _time_to_quit is None : return False <EOL> if isinstance ( o , timedelta ) : <EOL> o = ExpiryTime ( o ) <EOL> if o . _time_to_quit is None : return True <EOL> return self . _time_to_quit < o . _time_to_quit <EOL> def __gt__ ( self , o ) : <EOL> try : <EOL> if self . _time_to_quit is None and o . _time_to_quit is None : return False <EOL> except Exception : pass <EOL> return not self . __lt__ ( o ) <EOL> def __le__ ( self , o ) : return self . __eq__ ( o ) or self . __lt__ ( o ) <EOL> def __ge__ ( self , o ) : return self . __eq__ ( o ) or self . __gt__ ( o ) <EOL> def __ne__ ( self , o ) : return not self . __eq__ ( o ) <EOL> def __bool__ ( self ) : return self . expired ( ) <EOL> def __nonzero__ ( self ) : return self . expired ( ) <EOL> _thesplog_control_settings = ( <EOL> logging . INFO , <EOL> False , <EOL> os . getenv ( '<STR_LIT>' , <NUM_LIT:50> * <NUM_LIT> ) <EOL> ) <EOL> _thesplog_file = None <EOL> _thesplog_old_file = None <EOL>", "answer": "def thesplog_control ( baseLevel = logging . DEBUG , useLogging = True , tmpFileMaxSize = <NUM_LIT:0> ) :"}, {"prompt": "<s> import time <EOL> from api_keys import CLIENT_ID , CLIENT_SECRET , CATEGORY_ID <EOL> from business import Business , make_request <EOL> SEARCH_URL = '<STR_LIT>' <EOL> def search ( lat , lng , distance ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url = SEARCH_URL . format ( lat , lng , distance , <EOL> CATEGORY_ID , CLIENT_ID , CLIENT_SECRET , <EOL> time . strftime ( \"<STR_LIT>\" ) ) <EOL> venue_list = [ ] <EOL> try : <EOL> data = make_request ( url ) <EOL>", "answer": "for item in data [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] :"}, {"prompt": "<s> import re <EOL> from django . db . backends import BaseDatabaseIntrospection <EOL> field_size_re = re . compile ( r'<STR_LIT>' ) <EOL> def get_field_size ( name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> m = field_size_re . search ( name ) <EOL> return int ( m . group ( <NUM_LIT:1> ) ) if m else None <EOL> class FlexibleFieldLookupDict ( object ) : <EOL> base_data_types_reverse = { <EOL> '<STR_LIT:bool>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:int>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:text>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:date>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:time>' : '<STR_LIT>' , <EOL> } <EOL> def __getitem__ ( self , key ) : <EOL> key = key . lower ( ) <EOL> try : <EOL> return self . base_data_types_reverse [ key ] <EOL> except KeyError : <EOL> size = get_field_size ( key ) <EOL> if size is not None : <EOL> return ( '<STR_LIT>' , { '<STR_LIT:max_length>' : size } ) <EOL> raise KeyError <EOL> class DatabaseIntrospection ( BaseDatabaseIntrospection ) : <EOL> data_types_reverse = FlexibleFieldLookupDict ( ) <EOL> def get_table_list ( self , cursor ) : <EOL> \"<STR_LIT>\" <EOL> cursor . execute ( \"\"\"<STR_LIT>\"\"\" ) <EOL> return [ row [ <NUM_LIT:0> ] for row in cursor . fetchall ( ) ] <EOL> def get_table_description ( self , cursor , table_name ) : <EOL> \"<STR_LIT>\" <EOL> return [ ( info [ '<STR_LIT:name>' ] , info [ '<STR_LIT:type>' ] , None , info [ '<STR_LIT:size>' ] , None , None , <EOL> info [ '<STR_LIT>' ] ) for info in self . _table_info ( cursor , table_name ) ] <EOL> def get_relations ( self , cursor , table_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> relations = { } <EOL> cursor . execute ( \"<STR_LIT>\" , [ table_name , \"<STR_LIT>\" ] ) <EOL> results = cursor . fetchone ( ) [ <NUM_LIT:0> ] . strip ( ) <EOL> results = results [ results . index ( '<STR_LIT:(>' ) + <NUM_LIT:1> : results . rindex ( '<STR_LIT:)>' ) ] <EOL> for field_index , field_desc in enumerate ( results . split ( '<STR_LIT:U+002C>' ) ) : <EOL> field_desc = field_desc . strip ( ) <EOL> if field_desc . startswith ( \"<STR_LIT>\" ) : <EOL> continue <EOL> m = re . search ( '<STR_LIT>' , field_desc , re . I ) <EOL> if not m : <EOL> continue <EOL> table , column = [ s . strip ( '<STR_LIT:\">' ) for s in m . groups ( ) ] <EOL> cursor . execute ( \"<STR_LIT>\" , [ table ] ) <EOL> result = cursor . fetchall ( ) [ <NUM_LIT:0> ] <EOL> other_table_results = result [ <NUM_LIT:0> ] . strip ( ) <EOL> li , ri = other_table_results . index ( '<STR_LIT:(>' ) , other_table_results . rindex ( '<STR_LIT:)>' ) <EOL> other_table_results = other_table_results [ li + <NUM_LIT:1> : ri ] <EOL> for other_index , other_desc in enumerate ( other_table_results . split ( '<STR_LIT:U+002C>' ) ) : <EOL> other_desc = other_desc . strip ( ) <EOL> if other_desc . startswith ( '<STR_LIT>' ) : <EOL> continue <EOL> name = other_desc . split ( '<STR_LIT:U+0020>' , <NUM_LIT:1> ) [ <NUM_LIT:0> ] . strip ( '<STR_LIT:\">' ) <EOL> if name == column : <EOL> relations [ field_index ] = ( other_index , table ) <EOL> break <EOL> return relations <EOL> def get_key_columns ( self , cursor , table_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> key_columns = [ ] <EOL> cursor . execute ( \"<STR_LIT>\" , [ table_name , \"<STR_LIT>\" ] ) <EOL> results = cursor . fetchone ( ) [ <NUM_LIT:0> ] . strip ( ) <EOL> results = results [ results . index ( '<STR_LIT:(>' ) + <NUM_LIT:1> : results . rindex ( '<STR_LIT:)>' ) ] <EOL> for field_index , field_desc in enumerate ( results . split ( '<STR_LIT:U+002C>' ) ) : <EOL> field_desc = field_desc . strip ( ) <EOL> if field_desc . startswith ( \"<STR_LIT>\" ) : <EOL> continue <EOL> m = re . search ( '<STR_LIT>' , field_desc , re . I ) <EOL> if not m : <EOL> continue <EOL> key_columns . append ( tuple ( [ s . strip ( '<STR_LIT:\">' ) for s in m . groups ( ) ] ) ) <EOL> return key_columns <EOL> def get_indexes ( self , cursor , table_name ) : <EOL> indexes = { } <EOL> for info in self . _table_info ( cursor , table_name ) : <EOL> if info [ '<STR_LIT>' ] != <NUM_LIT:0> : <EOL> indexes [ info [ '<STR_LIT:name>' ] ] = { '<STR_LIT:primary_key>' : True , <EOL> '<STR_LIT>' : False } <EOL> cursor . execute ( '<STR_LIT>' % self . connection . ops . quote_name ( table_name ) ) <EOL> for index , unique in [ ( field [ <NUM_LIT:1> ] , field [ <NUM_LIT:2> ] ) for field in cursor . fetchall ( ) ] : <EOL> cursor . execute ( '<STR_LIT>' % self . connection . ops . quote_name ( index ) ) <EOL>", "answer": "info = cursor . fetchall ( )"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . core . urlresolvers import reverse <EOL> from djangobmf . utils . testcases import TestCase <EOL> class ViewApiTests ( TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( ViewApiTests , self ) . setUp ( ) <EOL> self . user = self . create_user ( \"<STR_LIT:user>\" , is_superuser = True ) <EOL> def test_api_index ( self ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> self . client_login ( \"<STR_LIT:user>\" ) <EOL> r = self . client . get ( reverse ( '<STR_LIT>' ) , { } ) <EOL>", "answer": "self . assertEqual ( r . status_code , <NUM_LIT:200> ) "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import datetime <EOL> import getpass <EOL> import logging <EOL> import optparse <EOL> import os <EOL> import shutil <EOL> import socket <EOL> import subprocess <EOL> import sys <EOL> import tempfile <EOL> import urllib <EOL> import gcl <EOL> import scm <EOL> import presubmit_support <EOL> import upload <EOL> __version__ = '<STR_LIT>' <EOL> HELP_STRING = \"<STR_LIT>\" <EOL> USAGE = r\"\"\"<STR_LIT>\"\"\" <EOL> class InvalidScript ( Exception ) : <EOL> def __str__ ( self ) : <EOL> return self . args [ <NUM_LIT:0> ] + '<STR_LIT:\\n>' + HELP_STRING <EOL> class NoTryServerAccess ( Exception ) : <EOL> def __str__ ( self ) : <EOL> return self . args [ <NUM_LIT:0> ] + '<STR_LIT:\\n>' + HELP_STRING <EOL> def PathDifference ( root , subpath ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if subpath . find ( root ) != <NUM_LIT:0> : <EOL> return None <EOL> if not root . endswith ( os . sep ) : <EOL> root += os . sep <EOL> return subpath [ len ( root ) : ] <EOL> def GetSourceRoot ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return os . path . abspath ( os . path . join ( gcl . GetRepositoryRoot ( ) , '<STR_LIT:..>' ) ) <EOL> def GetTryServerSettings ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _SafeResolve ( host ) : <EOL> try : <EOL> return socket . getaddrinfo ( host , None ) <EOL> except socket . gaierror : <EOL> return None <EOL> settings = { } <EOL> settings [ '<STR_LIT>' ] = gcl . GetCodeReviewSetting ( '<STR_LIT>' ) <EOL> settings [ '<STR_LIT>' ] = gcl . GetCodeReviewSetting ( '<STR_LIT>' ) <EOL> settings [ '<STR_LIT>' ] = gcl . GetCodeReviewSetting ( '<STR_LIT>' ) <EOL> settings [ '<STR_LIT>' ] = gcl . GetCodeReviewSetting ( '<STR_LIT>' ) <EOL> settings [ '<STR_LIT>' ] = gcl . GetCodeReviewSetting ( '<STR_LIT>' ) <EOL> default_patchlevel = gcl . GetCodeReviewSetting ( '<STR_LIT>' ) <EOL> if default_patchlevel : <EOL> default_patchlevel = int ( default_patchlevel ) <EOL> else : <EOL> default_patchlevel = <NUM_LIT:0> <EOL> settings [ '<STR_LIT>' ] = default_patchlevel <EOL> if ( settings [ '<STR_LIT>' ] and settings [ '<STR_LIT>' ] and <EOL> _SafeResolve ( settings [ '<STR_LIT>' ] ) ) : <EOL> settings [ '<STR_LIT>' ] = '<STR_LIT:http>' <EOL> elif settings . get ( '<STR_LIT>' ) : <EOL> settings [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> return settings <EOL> def EscapeDot ( name ) : <EOL> return name . replace ( '<STR_LIT:.>' , '<STR_LIT:->' ) <EOL> def RunCommand ( command ) : <EOL> output , retcode = gcl . RunShellWithReturnCode ( command ) <EOL> if retcode : <EOL> raise NoTryServerAccess ( '<STR_LIT:U+0020>' . join ( command ) + '<STR_LIT>' + output ) <EOL> return output <EOL> class SCM ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , options ) : <EOL> self . options = options <EOL> def ProcessOptions ( self ) : <EOL> raise NotImplementedError <EOL> class SVN ( SCM ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def GenerateDiff ( self , files , root ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> previous_cwd = os . getcwd ( ) <EOL> if root is None : <EOL> os . chdir ( gcl . GetRepositoryRoot ( ) ) <EOL> else : <EOL> os . chdir ( root ) <EOL> diff = filter ( None , [ scm . SVN . DiffItem ( f ) for f in files ] ) <EOL> os . chdir ( previous_cwd ) <EOL> return \"<STR_LIT>\" . join ( diff ) <EOL> def GetFileNames ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . change_info . GetFileNames ( ) <EOL> def GetLocalRoot ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . change_info . GetLocalRoot ( ) <EOL> def ProcessOptions ( self ) : <EOL> if not self . options . diff : <EOL> source_root = GetSourceRoot ( ) <EOL> prefix = PathDifference ( source_root , gcl . GetRepositoryRoot ( ) ) <EOL> adjusted_paths = [ os . path . join ( prefix , x ) for x in self . options . files ] <EOL> self . options . diff = self . GenerateDiff ( adjusted_paths , root = source_root ) <EOL> self . change_info = gcl . LoadChangelistInfoForMultiple ( self . options . name , <EOL> gcl . GetRepositoryRoot ( ) , True , True ) <EOL> if not self . options . email : <EOL> self . options . email = scm . SVN . GetEmail ( gcl . GetRepositoryRoot ( ) ) <EOL> class GIT ( SCM ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def GenerateDiff ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> branch = upload . RunShell ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) . strip ( ) <EOL> diff = upload . RunShell ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> branch , '<STR_LIT>' ] ) . splitlines ( True ) <EOL> for i in range ( len ( diff ) ) : <EOL> if diff [ i ] . startswith ( '<STR_LIT>' ) : <EOL> diff [ i ] = '<STR_LIT>' % diff [ i + <NUM_LIT:1> ] [ <NUM_LIT:4> : ] <EOL> return '<STR_LIT>' . join ( diff ) <EOL> def GetFileNames ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . options . files <EOL> def GetLocalRoot ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> root = upload . RunShell ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) . strip ( ) <EOL> return os . path . abspath ( root ) <EOL> def GetPatchName ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> branch = upload . RunShell ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) . strip ( ) <EOL> if not branch . startswith ( '<STR_LIT>' ) : <EOL> raise NoTryServerAccess ( \"<STR_LIT>\" ) <EOL> branch = branch [ len ( '<STR_LIT>' ) : ] <EOL> return branch <EOL> def ProcessOptions ( self ) : <EOL> if not self . options . diff : <EOL> self . options . diff = self . GenerateDiff ( ) <EOL> if not self . options . name : <EOL> self . options . name = self . GetPatchName ( ) <EOL> if not self . options . email : <EOL> self . options . email = scm . GIT . GetEmail ( '<STR_LIT:.>' ) <EOL> def _ParseSendChangeOptions ( options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> values = { } <EOL> if options . email : <EOL> values [ '<STR_LIT:email>' ] = options . email <EOL> values [ '<STR_LIT:user>' ] = options . user <EOL> values [ '<STR_LIT:name>' ] = options . name <EOL> if options . bot : <EOL> values [ '<STR_LIT>' ] = '<STR_LIT:U+002C>' . join ( options . bot ) <EOL> if options . revision : <EOL> values [ '<STR_LIT>' ] = options . revision <EOL> if options . clobber : <EOL> values [ '<STR_LIT>' ] = '<STR_LIT:true>' <EOL> if options . tests : <EOL> values [ '<STR_LIT>' ] = '<STR_LIT:U+002C>' . join ( options . tests ) <EOL> if options . root : <EOL> values [ '<STR_LIT:root>' ] = options . root <EOL> if options . patchlevel : <EOL> values [ '<STR_LIT>' ] = options . patchlevel <EOL> if options . issue : <EOL> values [ '<STR_LIT>' ] = options . issue <EOL> if options . patchset : <EOL> values [ '<STR_LIT>' ] = options . patchset <EOL> if options . target : <EOL> values [ '<STR_LIT:target>' ] = options . target <EOL> if options . project : <EOL> values [ '<STR_LIT>' ] = options . project <EOL> return values <EOL> def _SendChangeHTTP ( options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not options . host : <EOL> raise NoTryServerAccess ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> if not options . port : <EOL> raise NoTryServerAccess ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> values = _ParseSendChangeOptions ( options ) <EOL> values [ '<STR_LIT>' ] = options . diff <EOL> url = '<STR_LIT>' % ( options . host , options . port ) <EOL> proxies = None <EOL> if options . proxy : <EOL> if options . proxy . lower ( ) == '<STR_LIT:none>' : <EOL> proxies = { } <EOL> else : <EOL> proxies = { '<STR_LIT:http>' : options . proxy , '<STR_LIT>' : options . proxy } <EOL> try : <EOL> connection = urllib . urlopen ( url , urllib . urlencode ( values ) , proxies = proxies ) <EOL> except IOError , e : <EOL> if ( values . get ( '<STR_LIT>' ) and len ( e . args ) > <NUM_LIT:2> and <EOL> e . args [ <NUM_LIT:2> ] == '<STR_LIT>' ) : <EOL> raise NoTryServerAccess ( '<STR_LIT>' % url ) <EOL> else : <EOL> raise NoTryServerAccess ( '<STR_LIT>' % ( url , <EOL> str ( e . args ) ) ) <EOL> if not connection : <EOL> raise NoTryServerAccess ( '<STR_LIT>' % url ) <EOL> if connection . read ( ) != '<STR_LIT:OK>' : <EOL> raise NoTryServerAccess ( '<STR_LIT>' % url ) <EOL> def _SendChangeSVN ( options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not options . svn_repo : <EOL> raise NoTryServerAccess ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> values = _ParseSendChangeOptions ( options ) <EOL> description = '<STR_LIT>' <EOL> for ( k , v ) in values . iteritems ( ) : <EOL> description += \"<STR_LIT>\" % ( k , v ) <EOL> temp_dir = tempfile . mkdtemp ( ) <EOL> temp_file = tempfile . NamedTemporaryFile ( ) <EOL> temp_file_name = temp_file . name <EOL> try : <EOL> command = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> options . svn_repo , temp_dir ] <EOL> if options . email : <EOL> command += [ '<STR_LIT>' , options . email ] <EOL> use_shell = sys . platform . startswith ( \"<STR_LIT>\" ) <EOL> subprocess . Popen ( command , shell = use_shell ) . communicate ( ) <EOL> current_time = str ( datetime . datetime . now ( ) ) . replace ( '<STR_LIT::>' , '<STR_LIT:.>' ) <EOL> file_name = ( EscapeDot ( options . user ) + '<STR_LIT:.>' + EscapeDot ( options . name ) + <EOL> '<STR_LIT>' % current_time ) <EOL> full_path = os . path . join ( temp_dir , file_name ) <EOL> full_url = options . svn_repo + '<STR_LIT:/>' + file_name <EOL> file_found = False <EOL> try : <EOL> RunCommand ( [ '<STR_LIT>' , '<STR_LIT>' , full_url ] ) <EOL> file_found = True <EOL> except NoTryServerAccess : <EOL> pass <EOL> if file_found : <EOL> RunCommand ( [ '<STR_LIT>' , '<STR_LIT>' , full_path ] ) <EOL> f = open ( full_path , '<STR_LIT:wb>' ) <EOL> f . write ( options . diff ) <EOL> f . close ( ) <EOL> else : <EOL> f = open ( full_path , '<STR_LIT:wb>' ) <EOL> f . write ( options . diff ) <EOL> f . close ( ) <EOL> RunCommand ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , full_path ] ) <EOL> temp_file . write ( description ) <EOL> temp_file . flush ( ) <EOL> RunCommand ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , full_path , '<STR_LIT>' , <EOL> temp_file_name ] ) <EOL> finally : <EOL> temp_file . close ( ) <EOL> shutil . rmtree ( temp_dir , True ) <EOL> def GuessVCS ( options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __pychecker__ = '<STR_LIT>' <EOL> if os . path . isdir ( '<STR_LIT>' ) : <EOL> logging . info ( \"<STR_LIT>\" ) <EOL> return SVN ( options ) <EOL> try : <EOL> out , returncode = gcl . RunShellWithReturnCode ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] ) <EOL> if returncode == <NUM_LIT:0> : <EOL> logging . info ( \"<STR_LIT>\" ) <EOL> return GIT ( options ) <EOL> except OSError , ( errno , message ) : <EOL> if errno != <NUM_LIT:2> : <EOL> raise <EOL> raise NoTryServerAccess ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def TryChange ( argv , <EOL> file_list , <EOL> swallow_exception , <EOL> prog = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> default_settings = GetTryServerSettings ( ) <EOL> transport_functions = { '<STR_LIT:http>' : _SendChangeHTTP , '<STR_LIT>' : _SendChangeSVN } <EOL> default_transport = transport_functions . get ( <EOL> default_settings . get ( '<STR_LIT>' ) ) <EOL> parser = optparse . OptionParser ( usage = USAGE , <EOL> version = __version__ , <EOL> prog = prog ) <EOL> group = optparse . OptionGroup ( parser , \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , default = getpass . getuser ( ) , <EOL> help = \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> default = os . environ . get ( '<STR_LIT>' , <EOL> os . environ . get ( '<STR_LIT>' ) ) , <EOL> help = \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , type = '<STR_LIT:int>' , <EOL> help = \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , type = '<STR_LIT:int>' , <EOL> help = \"<STR_LIT>\" ) <EOL> parser . add_option_group ( group ) <EOL> group = optparse . OptionGroup ( parser , \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , action = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT:-c>\" , \"<STR_LIT>\" , action = \"<STR_LIT:store_true>\" , <EOL> help = \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , help = optparse . SUPPRESS_HELP ) <EOL>", "answer": "group . add_option ( \"<STR_LIT>\" , help = optparse . SUPPRESS_HELP ,"}, {"prompt": "<s> from django . contrib . syndication . views import Feed <EOL> from django . utils . feedgenerator import Atom1Feed <EOL> from blog . models import Entry <EOL> class LatestEntriesFeed ( Feed ) : <EOL> feed_type = Atom1Feed <EOL> title = \"<STR_LIT>\" <EOL> link = \"<STR_LIT>\" <EOL> subtitle = \"<STR_LIT>\" <EOL> def items ( self ) : <EOL> return Entry . objects . filter ( status = Entry . PUBLISHED_STATUS ) . order_by ( '<STR_LIT>' ) [ : <NUM_LIT:5> ] <EOL> def item_title ( self , item ) : <EOL> return item . title <EOL> def item_link ( self , item ) : <EOL> return item . get_absolute_url ( ) <EOL> def item_description ( self , item ) : <EOL> return item . content_html <EOL>", "answer": "def item_author_name ( self , item ) :"}, {"prompt": "<s> from pypy . rpython . ootypesystem import ootype <EOL> from pypy . translator . cli . node import Node <EOL> from pypy . translator . cli . cts import CTS <EOL> class Record ( Node ) : <EOL> def __init__ ( self , db , record , name ) : <EOL> self . db = db <EOL> self . cts = CTS ( db ) <EOL> self . record = record <EOL> self . name = name <EOL> def __hash__ ( self ) : <EOL> return hash ( self . record ) <EOL> def __eq__ ( self , other ) : <EOL> return self . record == other . record <EOL> def __ne__ ( self , other ) : <EOL> return not self == other <EOL>", "answer": "def get_name ( self ) :"}, {"prompt": "<s> from sympy . utilities . pytest import raises <EOL> from sympy import ( symbols , Function , Integer , Matrix , Abs , <EOL> Rational , Float , S , WildFunction , ImmutableMatrix , sin , true , false , ones , <EOL> sqrt , root , AlgebraicNumber , Symbol , Dummy , Wild ) <EOL> from sympy . core . compatibility import exec_ <EOL> from sympy . geometry import Point , Ellipse <EOL> from sympy . printing import srepr <EOL> from sympy . polys import ring , field , ZZ , QQ , lex , grlex <EOL> x , y = symbols ( '<STR_LIT>' ) <EOL> ENV = { } <EOL> exec_ ( \"<STR_LIT>\" , ENV ) <EOL> def sT ( expr , string ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert srepr ( expr ) == string <EOL> assert eval ( string , ENV ) == expr <EOL> def test_printmethod ( ) : <EOL> class R ( Abs ) : <EOL> def _sympyrepr ( self , printer ) : <EOL> return \"<STR_LIT>\" % printer . _print ( self . args [ <NUM_LIT:0> ] ) <EOL> assert srepr ( R ( x ) ) == \"<STR_LIT>\" <EOL> def test_Add ( ) : <EOL> sT ( x + y , \"<STR_LIT>\" ) <EOL> assert srepr ( x ** <NUM_LIT:2> + <NUM_LIT:1> , order = '<STR_LIT>' ) == \"<STR_LIT>\" <EOL> assert srepr ( x ** <NUM_LIT:2> + <NUM_LIT:1> , order = '<STR_LIT>' ) == \"<STR_LIT>\" <EOL>", "answer": "def test_Function ( ) :"}, {"prompt": "<s> import logging <EOL> import re <EOL> import urlparse <EOL> from django . conf import settings <EOL> from cleanliness import cleaner <EOL> from cleanliness import encoding <EOL> from common import exception <EOL> from common import display <EOL> NICK_MIN_LENGTH = <NUM_LIT:2> <EOL> NICK_MAX_LENGTH = <NUM_LIT> <EOL> RE_NS_DOMAIN = settings . NS_DOMAIN . replace ( '<STR_LIT:.>' , r'<STR_LIT>' ) <EOL> USER_RE = ( <EOL> r'<STR_LIT>' % ( NICK_MIN_LENGTH , <EOL> NICK_MAX_LENGTH , <EOL> RE_NS_DOMAIN ) <EOL> ) <EOL> USERNAME_ALIAS_RE = ( <EOL> r'<STR_LIT>' % ( NICK_MIN_LENGTH , NICK_MAX_LENGTH ) <EOL> ) <EOL> USER_COMPILED = re . compile ( USER_RE ) <EOL> USERNAME_ALIAS_COMPILED = re . compile ( USERNAME_ALIAS_RE ) <EOL> BG_COLOR_RE = '<STR_LIT>' <EOL> BG_COLOR_COMPILED = re . compile ( BG_COLOR_RE ) <EOL> def bg_color ( value , message = '<STR_LIT>' ) : <EOL> if not value : <EOL> return value <EOL> if not BG_COLOR_COMPILED . match ( value ) : <EOL> raise exception . ValidationError ( message ) <EOL> return value <EOL> def bg_repeat ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value == '<STR_LIT>' : <EOL> return value <EOL> return '<STR_LIT>' <EOL> BG_IMAGE_RE = '<STR_LIT>' + USER_RE [ <NUM_LIT:1> : - <NUM_LIT:1> ] + r'<STR_LIT>' <EOL> BG_IMAGE_COMPILED = re . compile ( BG_IMAGE_RE ) <EOL> def bg_image ( value , message = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not value : <EOL> return value <EOL> if not BG_IMAGE_COMPILED . match ( value ) : <EOL> raise exception . ValidationError ( message ) <EOL> return value <EOL> def datetime ( value , message = '<STR_LIT>' ) : <EOL> return cleaner . datetime ( value , message ) <EOL> def nick ( value , message = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> value = encoding . smart_unicode ( value ) <EOL> try : <EOL> return user ( value , message = message ) <EOL> except exception . ValidationError : <EOL> return channel ( value , message = message ) <EOL> def normalize_nick ( value ) : <EOL> return nick ( value ) . lower ( ) <EOL> channel_re = re . compile ( <EOL> r'<STR_LIT>' % ( NICK_MIN_LENGTH , <EOL> NICK_MAX_LENGTH , <EOL> RE_NS_DOMAIN ) <EOL> ) <EOL> def channel ( value , message = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> value = encoding . smart_unicode ( value ) <EOL> if not value . startswith ( '<STR_LIT:#>' ) : <EOL> value = '<STR_LIT>' % value <EOL> if not value . endswith ( '<STR_LIT>' % settings . NS_DOMAIN ) : <EOL> value = '<STR_LIT>' % ( value , settings . NS_DOMAIN ) <EOL> match = channel_re . match ( value ) <EOL> if not match : <EOL> logging . info ( \"<STR_LIT>\" % value ) <EOL> raise exception . ValidationError ( message ) <EOL> return value <EOL> def alias_username ( value , message = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> match = USERNAME_ALIAS_COMPILED . match ( value ) <EOL> if not match : <EOL> raise exception . ValidationError ( message ) <EOL> return value <EOL> def oauth_type ( value , message = '<STR_LIT>' ) : <EOL> if value not in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> raise exception . ValidationError ( message ) <EOL> return value <EOL> def user ( value , message = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> value = encoding . smart_unicode ( value ) <EOL> if not value . endswith ( '<STR_LIT>' % settings . NS_DOMAIN ) : <EOL> value = '<STR_LIT>' % ( value , settings . NS_DOMAIN ) <EOL> match = USER_COMPILED . match ( value ) <EOL> if not match : <EOL> raise exception . ValidationError ( message ) <EOL> return value <EOL> def icon ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if str ( value ) in display . ICONS_BY_ID : <EOL> return str ( value ) <EOL> return display . ICONS . get ( str ( value ) , ( <NUM_LIT:0> , ) ) [ <NUM_LIT:0> ] <EOL> MOBILE_RE = '<STR_LIT>' <EOL> MOBILE_RE_COMPILED = re . compile ( MOBILE_RE ) <EOL> def mobile ( value ) : <EOL>", "answer": "if not value . startswith ( '<STR_LIT:+>' ) :"}, {"prompt": "<s> import json <EOL> import logging <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from horizon import exceptions <EOL> from horizon import forms <EOL> from horizon import workflows <EOL> from openstack_dashboard . api import sahara as saharaclient <EOL> import openstack_dashboard . dashboards . project . data_processing . cluster_templates . workflows . create as t_flows <EOL> import openstack_dashboard . dashboards . project . data_processing . clusters . workflows . create as c_flow <EOL> import openstack_dashboard . dashboards . project . data_processing . utils . workflow_helpers as whelpers <EOL> LOG = logging . getLogger ( __name__ ) <EOL> DATA_SOURCE_CREATE_URL = ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> class JobExecutionGeneralConfigAction ( workflows . Action ) : <EOL> job_input = forms . DynamicChoiceField ( <EOL> label = _ ( \"<STR_LIT>\" ) , <EOL> initial = ( None , \"<STR_LIT:None>\" ) , <EOL> add_item_link = DATA_SOURCE_CREATE_URL ) <EOL> job_output = forms . DynamicChoiceField ( <EOL> label = _ ( \"<STR_LIT>\" ) , <EOL> initial = ( None , \"<STR_LIT:None>\" ) , <EOL> add_item_link = DATA_SOURCE_CREATE_URL ) <EOL> def __init__ ( self , request , * args , ** kwargs ) : <EOL> super ( JobExecutionGeneralConfigAction , self ) . __init__ ( request , <EOL> * args , <EOL> ** kwargs ) <EOL> if request . REQUEST . get ( \"<STR_LIT>\" , None ) is None : <EOL> self . fields [ \"<STR_LIT>\" ] = forms . ChoiceField ( <EOL> label = _ ( \"<STR_LIT>\" ) ) <EOL> self . fields [ \"<STR_LIT>\" ] . choices = self . populate_job_choices ( request ) <EOL> else : <EOL> self . fields [ \"<STR_LIT>\" ] = forms . CharField ( <EOL> widget = forms . HiddenInput ( ) , <EOL> initial = request . REQUEST . get ( \"<STR_LIT>\" , None ) ) <EOL> def populate_job_input_choices ( self , request , context ) : <EOL> return self . get_data_source_choices ( request , context ) <EOL> def populate_job_output_choices ( self , request , context ) : <EOL> return self . get_data_source_choices ( request , context ) <EOL> def get_data_source_choices ( self , request , context ) : <EOL> try : <EOL> data_sources = saharaclient . data_source_list ( request ) <EOL> except Exception : <EOL> data_sources = [ ] <EOL> exceptions . handle ( request , <EOL> _ ( \"<STR_LIT>\" ) ) <EOL> choices = [ ( data_source . id , data_source . name ) <EOL> for data_source in data_sources ] <EOL> choices . insert ( <NUM_LIT:0> , ( None , '<STR_LIT:None>' ) ) <EOL> return choices <EOL> def populate_job_choices ( self , request ) : <EOL> try : <EOL> jobs = saharaclient . job_list ( request ) <EOL> except Exception : <EOL> jobs = [ ] <EOL> exceptions . handle ( request , <EOL> _ ( \"<STR_LIT>\" ) ) <EOL> choices = [ ( job . id , job . name ) <EOL> for job in jobs ] <EOL> return choices <EOL> class Meta : <EOL> name = _ ( \"<STR_LIT>\" ) <EOL> help_text_template = ( <EOL> \"<STR_LIT>\" ) <EOL> class JobExecutionExistingGeneralConfigAction ( JobExecutionGeneralConfigAction ) : <EOL> cluster = forms . ChoiceField ( <EOL> label = _ ( \"<STR_LIT>\" ) , <EOL> initial = ( None , \"<STR_LIT:None>\" ) , <EOL> widget = forms . Select ( attrs = { \"<STR_LIT:class>\" : \"<STR_LIT>\" } ) ) <EOL> def populate_cluster_choices ( self , request , context ) : <EOL> try : <EOL> clusters = saharaclient . cluster_list ( request ) <EOL> except Exception : <EOL> clusters = [ ] <EOL> exceptions . handle ( request , <EOL> _ ( \"<STR_LIT>\" ) ) <EOL> choices = [ ( cluster . id , cluster . name ) <EOL> for cluster in clusters ] <EOL> return choices <EOL> class Meta : <EOL> name = _ ( \"<STR_LIT>\" ) <EOL> help_text_template = ( <EOL> \"<STR_LIT>\" ) <EOL> class JobConfigAction ( workflows . Action ) : <EOL> MAIN_CLASS = \"<STR_LIT>\" <EOL> JAVA_OPTS = \"<STR_LIT>\" <EOL> EDP_MAPPER = \"<STR_LIT>\" <EOL> EDP_REDUCER = \"<STR_LIT>\" <EOL> EDP_PREFIX = \"<STR_LIT>\" <EOL> property_name = forms . ChoiceField ( <EOL> required = False , <EOL> ) <EOL> job_configs = forms . CharField ( <EOL> required = False , <EOL> widget = forms . HiddenInput ( ) ) <EOL> job_params = forms . CharField ( <EOL> required = False , <EOL> widget = forms . HiddenInput ( ) ) <EOL> job_args_array = forms . CharField ( <EOL> required = False , <EOL> widget = forms . HiddenInput ( ) ) <EOL> job_type = forms . CharField ( <EOL> required = False , <EOL> widget = forms . HiddenInput ( ) ) <EOL> main_class = forms . CharField ( label = _ ( \"<STR_LIT>\" ) , <EOL> required = False ) <EOL> java_opts = forms . CharField ( label = _ ( \"<STR_LIT>\" ) , <EOL> required = False ) <EOL> streaming_mapper = forms . CharField ( label = _ ( \"<STR_LIT>\" ) ) <EOL> streaming_reducer = forms . CharField ( label = _ ( \"<STR_LIT>\" ) ) <EOL> def __init__ ( self , request , * args , ** kwargs ) : <EOL> super ( JobConfigAction , self ) . __init__ ( request , * args , ** kwargs ) <EOL> job_ex_id = request . REQUEST . get ( \"<STR_LIT>\" ) <EOL> if job_ex_id is not None : <EOL> job_ex_id = request . REQUEST . get ( \"<STR_LIT>\" ) <EOL> job_ex = saharaclient . job_execution_get ( request , job_ex_id ) <EOL> job_configs = job_ex . job_configs <EOL> edp_configs = { } <EOL> if '<STR_LIT>' in job_configs : <EOL> configs , edp_configs = ( <EOL> self . clean_edp_configs ( job_configs [ '<STR_LIT>' ] ) ) <EOL> self . fields [ '<STR_LIT>' ] . initial = ( <EOL> json . dumps ( configs ) ) <EOL> if '<STR_LIT>' in job_configs : <EOL> self . fields [ '<STR_LIT>' ] . initial = ( <EOL> json . dumps ( job_configs [ '<STR_LIT>' ] ) ) <EOL> job_args = json . dumps ( job_configs [ '<STR_LIT:args>' ] ) <EOL> self . fields [ '<STR_LIT>' ] . initial = job_args <EOL> if self . MAIN_CLASS in edp_configs : <EOL> self . fields [ '<STR_LIT>' ] . initial = ( <EOL> edp_configs [ self . MAIN_CLASS ] ) <EOL> if self . JAVA_OPTS in edp_configs : <EOL> self . fields [ '<STR_LIT>' ] . initial = ( <EOL> edp_configs [ self . JAVA_OPTS ] ) <EOL> if self . EDP_MAPPER in edp_configs : <EOL> self . fields [ '<STR_LIT>' ] . initial = ( <EOL> edp_configs [ self . EDP_MAPPER ] ) <EOL> if self . EDP_REDUCER in edp_configs : <EOL> self . fields [ '<STR_LIT>' ] . initial = ( <EOL> edp_configs [ self . EDP_REDUCER ] ) <EOL> def clean ( self ) : <EOL> cleaned_data = super ( workflows . Action , self ) . clean ( ) <EOL> job_type = cleaned_data . get ( \"<STR_LIT>\" , None ) <EOL> if job_type != \"<STR_LIT>\" : <EOL> if \"<STR_LIT>\" in self . _errors : <EOL> del self . _errors [ \"<STR_LIT>\" ] <EOL> if \"<STR_LIT>\" in self . _errors : <EOL> del self . _errors [ \"<STR_LIT>\" ] <EOL> return cleaned_data <EOL> def populate_property_name_choices ( self , request , context ) : <EOL> job_id = request . REQUEST . get ( \"<STR_LIT>\" ) or request . REQUEST . get ( \"<STR_LIT>\" ) <EOL> job_type = saharaclient . job_get ( request , job_id ) . type <EOL> job_configs = ( <EOL> saharaclient . job_get_configs ( request , job_type ) . job_config ) <EOL> choices = [ ( param [ '<STR_LIT:value>' ] , param [ '<STR_LIT:name>' ] ) <EOL> for param in job_configs [ '<STR_LIT>' ] ] <EOL> return choices <EOL> def clean_edp_configs ( self , configs ) : <EOL> edp_configs = { } <EOL> for key , value in configs . iteritems ( ) : <EOL> if key . startswith ( self . EDP_PREFIX ) : <EOL> edp_configs [ key ] = value <EOL> for rmkey in edp_configs . keys ( ) : <EOL> del configs [ rmkey ] <EOL> return ( configs , edp_configs ) <EOL> class Meta : <EOL> name = _ ( \"<STR_LIT>\" ) <EOL> help_text_template = ( <EOL> \"<STR_LIT>\" ) <EOL> class JobExecutionGeneralConfig ( workflows . Step ) : <EOL> action_class = JobExecutionGeneralConfigAction <EOL> def contribute ( self , data , context ) : <EOL> for k , v in data . items ( ) : <EOL> if k in [ \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> context [ \"<STR_LIT>\" + k ] = None if v == \"<STR_LIT:None>\" else v <EOL> else : <EOL> context [ \"<STR_LIT>\" + k ] = v <EOL> return context <EOL> class JobExecutionExistingGeneralConfig ( workflows . Step ) : <EOL> action_class = JobExecutionExistingGeneralConfigAction <EOL> def contribute ( self , data , context ) : <EOL> for k , v in data . items ( ) : <EOL> if k in [ \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> context [ \"<STR_LIT>\" + k ] = None if v == \"<STR_LIT:None>\" else v <EOL> else : <EOL> context [ \"<STR_LIT>\" + k ] = v <EOL> return context <EOL> class JobConfig ( workflows . Step ) : <EOL> action_class = JobConfigAction <EOL> template_name = '<STR_LIT>' <EOL> def contribute ( self , data , context ) : <EOL> job_config = self . clean_configs ( <EOL> json . loads ( data . get ( \"<STR_LIT>\" , '<STR_LIT:{}>' ) ) ) <EOL> job_params = self . clean_configs ( <EOL> json . loads ( data . get ( \"<STR_LIT>\" , '<STR_LIT:{}>' ) ) ) <EOL> job_args_array = self . clean_configs ( <EOL> json . loads ( data . get ( \"<STR_LIT>\" , '<STR_LIT>' ) ) ) <EOL> job_type = data . get ( \"<STR_LIT>\" , '<STR_LIT>' ) <EOL> context [ \"<STR_LIT>\" ] = job_type <EOL> context [ \"<STR_LIT>\" ] = { \"<STR_LIT>\" : job_config } <EOL> context [ \"<STR_LIT>\" ] [ \"<STR_LIT:args>\" ] = job_args_array <EOL> if job_type in [ \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> context [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ JobConfigAction . MAIN_CLASS ] = ( <EOL> data . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> context [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ JobConfigAction . JAVA_OPTS ] = ( <EOL> data . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> elif job_type == \"<STR_LIT>\" : <EOL> context [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ JobConfigAction . EDP_MAPPER ] = ( <EOL> data . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> context [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ JobConfigAction . EDP_REDUCER ] = ( <EOL>", "answer": "data . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) )"}, {"prompt": "<s> try : <EOL> from pkg_resources import resource_string <EOL> except ImportError : <EOL> resource_string = None <EOL> from django . template . base import TemplateDoesNotExist <EOL> from django . template . loader import BaseLoader <EOL> from django . conf import settings <EOL>", "answer": "class Loader ( BaseLoader ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> class GeneratedServiceType ( type ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _DESCRIPTOR_KEY = '<STR_LIT>' <EOL> def __init__ ( cls , name , bases , dictionary ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if GeneratedServiceType . _DESCRIPTOR_KEY not in dictionary : <EOL> return <EOL> descriptor = dictionary [ GeneratedServiceType . _DESCRIPTOR_KEY ] <EOL> service_builder = _ServiceBuilder ( descriptor ) <EOL> service_builder . BuildService ( cls ) <EOL> class GeneratedServiceStubType ( GeneratedServiceType ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _DESCRIPTOR_KEY = '<STR_LIT>' <EOL> def __init__ ( cls , name , bases , dictionary ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( GeneratedServiceStubType , cls ) . __init__ ( name , bases , dictionary ) <EOL> if GeneratedServiceStubType . _DESCRIPTOR_KEY not in dictionary : <EOL> return <EOL> descriptor = dictionary [ GeneratedServiceStubType . _DESCRIPTOR_KEY ] <EOL> service_stub_builder = _ServiceStubBuilder ( descriptor ) <EOL> service_stub_builder . BuildServiceStub ( cls ) <EOL> class _ServiceBuilder ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , service_descriptor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . descriptor = service_descriptor <EOL> def BuildService ( self , cls ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _WrapCallMethod ( srvc , method_descriptor , <EOL> rpc_controller , request , callback ) : <EOL> return self . _CallMethod ( srvc , method_descriptor , <EOL> rpc_controller , request , callback ) <EOL> self . cls = cls <EOL> cls . CallMethod = _WrapCallMethod <EOL> cls . GetDescriptor = staticmethod ( lambda : self . descriptor ) <EOL> cls . GetDescriptor . __doc__ = \"<STR_LIT>\" <EOL> cls . GetRequestClass = self . _GetRequestClass <EOL> cls . GetResponseClass = self . _GetResponseClass <EOL> for method in self . descriptor . methods : <EOL> setattr ( cls , method . name , self . _GenerateNonImplementedMethod ( method ) ) <EOL> def _CallMethod ( self , srvc , method_descriptor , <EOL> rpc_controller , request , callback ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if method_descriptor . containing_service != self . descriptor : <EOL> raise RuntimeError ( <EOL> '<STR_LIT>' ) <EOL> method = getattr ( srvc , method_descriptor . name ) <EOL> return method ( rpc_controller , request , callback ) <EOL>", "answer": "def _GetRequestClass ( self , method_descriptor ) :"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> from kivy . tools . packaging . pyinstaller_hooks import get_deps_all <EOL> import sys <EOL> from os . path import dirname , join <EOL> args = sys . argv [ <NUM_LIT:1> : ] <EOL> if args and args [ <NUM_LIT:0> ] == '<STR_LIT>' : <EOL> with open ( join ( dirname ( __file__ ) , '<STR_LIT>' ) ) as fh : <EOL> src = fh . read ( ) <EOL> formatted_lines = [ ] <EOL> lines = get_deps_all ( ) [ '<STR_LIT>' ] <EOL> for i , line in enumerate ( lines ) : <EOL> if ( i and <EOL> line [ : line . rfind ( '<STR_LIT:.>' ) ] != lines [ i - <NUM_LIT:1> ] [ : lines [ i - <NUM_LIT:1> ] . rfind ( '<STR_LIT:.>' ) ] ) : <EOL> formatted_lines . append ( '<STR_LIT:\\n>' ) <EOL> if i == len ( lines ) - <NUM_LIT:1> : <EOL> formatted_lines . append ( \"<STR_LIT>\" . format ( line ) ) <EOL> else : <EOL> formatted_lines . append ( \"<STR_LIT>\" . format ( line ) ) <EOL> lines = formatted_lines <EOL> lines = '<STR_LIT>' . format ( src , '<STR_LIT>' . join ( lines ) ) <EOL> if len ( args ) > <NUM_LIT:1> : <EOL> with open ( args [ <NUM_LIT:1> ] , '<STR_LIT:w>' ) as fh : <EOL>", "answer": "fh . write ( lines )"}, {"prompt": "<s> import os <EOL> import sys <EOL> import time <EOL> import shutil <EOL> import logging <EOL> import binascii <EOL> import subprocess <EOL> from errors import CodetypeError , UnsupportedOSError <EOL> log = None <EOL> eabi = { } <EOL> vdappc = \"<STR_LIT>\" <EOL> def setup ( ) : <EOL> global eabi , vdappc , log <EOL> if log is not None or eabi != { } or vdappc != \"<STR_LIT>\" : <EOL> return <EOL> for i in ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> eabi [ i ] = \"<STR_LIT>\" + sys . platform <EOL> if sys . platform == \"<STR_LIT>\" : <EOL> if sys . maxint > <NUM_LIT:2> ** <NUM_LIT:32> : <EOL> eabi [ i ] += \"<STR_LIT>\" <EOL> else : <EOL> eabi [ i ] += \"<STR_LIT>\" <EOL> eabi [ i ] += \"<STR_LIT>\" + i <EOL>", "answer": "if sys . platform == \"<STR_LIT:win32>\" :"}, {"prompt": "<s> from urlparse import urljoin <EOL> from scrapy . contrib . spiders import CrawlSpider , Rule <EOL> from scrapy . contrib . linkextractors . sgml import SgmlLinkExtractor <EOL> from scrapy . selector import HtmlXPathSelector <EOL> from openrecipes . items import RecipeItem , RecipeItemLoader <EOL> class JamieoliverMixin ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> source = '<STR_LIT>' <EOL> def parse_item ( self , response ) : <EOL> hxs = HtmlXPathSelector ( response ) <EOL> base_path = \"\"\"<STR_LIT>\"\"\" <EOL> recipes_scopes = hxs . select ( base_path ) <EOL> name_path = '<STR_LIT>' <EOL> description_path = '<STR_LIT>' <EOL> image_path = '<STR_LIT>' <EOL> recipeYield_path = '<STR_LIT>' <EOL> ingredients_path = '<STR_LIT>' <EOL> recipes = [ ] <EOL> for r_scope in recipes_scopes : <EOL> il = RecipeItemLoader ( item = RecipeItem ( ) ) <EOL> il . add_value ( '<STR_LIT:source>' , self . source ) <EOL> il . add_value ( '<STR_LIT:name>' , r_scope . select ( name_path ) . extract ( ) ) <EOL> il . add_value ( '<STR_LIT:image>' , urljoin ( response . url , r_scope . select ( image_path ) . extract ( ) . pop ( <NUM_LIT:0> ) ) ) <EOL> il . add_value ( '<STR_LIT:url>' , response . url ) <EOL> il . add_value ( '<STR_LIT:description>' , r_scope . select ( description_path ) . extract ( ) ) <EOL>", "answer": "il . add_value ( '<STR_LIT>' , None )"}, {"prompt": "<s> import pecan <EOL> from pecan import rest <EOL> import wsmeext . pecan as wsme_pecan <EOL> from solum . api . controllers . v1 . datamodel import infrastructure <EOL> from solum . api . handlers import infrastructure_handler <EOL> from solum . common import exception <EOL> from solum import objects <EOL> class InfrastructureStackController ( rest . RestController ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , stack_id ) : <EOL> super ( InfrastructureStackController , self ) . __init__ ( ) <EOL> self . _id = stack_id <EOL> @ exception . wrap_wsme_pecan_controller_exception <EOL> @ wsme_pecan . wsexpose ( infrastructure . InfrastructureStack ) <EOL> def get ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> handler = infrastructure_handler . InfrastructureStackHandler ( <EOL> pecan . request . security_context ) <EOL> return infrastructure . InfrastructureStack . from_db_model ( <EOL> handler . get ( self . _id ) , pecan . request . host_url ) <EOL> @ exception . wrap_wsme_pecan_controller_exception <EOL> @ wsme_pecan . wsexpose ( infrastructure . InfrastructureStack , <EOL> body = infrastructure . InfrastructureStack ) <EOL> def put ( self , data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> handler = infrastructure_handler . InfrastructureStackHandler ( <EOL> pecan . request . security_context ) <EOL> res = handler . update ( self . _id , <EOL> data . as_dict ( <EOL> objects . registry . InfrastructureStack ) ) <EOL> return infrastructure . InfrastructureStack . from_db_model ( <EOL> res , pecan . request . host_url ) <EOL> @ exception . wrap_wsme_pecan_controller_exception <EOL> @ wsme_pecan . wsexpose ( status_code = <NUM_LIT> ) <EOL> def delete ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> handler = infrastructure_handler . InfrastructureStackHandler ( <EOL> pecan . request . security_context ) <EOL> return handler . delete ( self . _id ) <EOL> class InfrastructureStacksController ( rest . RestController ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ pecan . expose ( ) <EOL> def _lookup ( self , stack_id , * remainder ) : <EOL> if remainder and not remainder [ - <NUM_LIT:1> ] : <EOL> remainder = remainder [ : - <NUM_LIT:1> ] <EOL> return InfrastructureStackController ( stack_id ) , remainder <EOL> @ exception . wrap_wsme_pecan_controller_exception <EOL> @ wsme_pecan . wsexpose ( infrastructure . InfrastructureStack , <EOL> body = infrastructure . InfrastructureStack , <EOL> status_code = <NUM_LIT> ) <EOL>", "answer": "def post ( self , data ) :"}, {"prompt": "<s> candidate_hash = { <EOL>", "answer": "'<STR_LIT>' : { '<STR_LIT>' : { '<STR_LIT>' : u'<STR_LIT>' , '<STR_LIT>' : u'<STR_LIT:P>' , '<STR_LIT>' : u'<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : u'<STR_LIT>' , '<STR_LIT>' : u'<STR_LIT>' } }"}, {"prompt": "<s> from south . utils import datetime_utils as datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . alter_column ( '<STR_LIT>' , '<STR_LIT:url>' , self . gf ( '<STR_LIT>' ) ( ) ) <EOL> def backwards ( self , orm ) : <EOL> db . alter_column ( '<STR_LIT>' , '<STR_LIT:url>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT> ) ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL>", "answer": "'<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) ,"}, {"prompt": "<s> import json <EOL> import subprocess <EOL> from flask import Response , request <EOL> def call_command ( cmd , verbose = False ) : <EOL> if verbose : <EOL> print cmd <EOL> subprocess . call ( cmd ) <EOL> def json_requested ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> best = request . accept_mimetypes . best_match ( <EOL> [ '<STR_LIT:application/json>' , '<STR_LIT>' ] ) <EOL>", "answer": "return ( best == '<STR_LIT:application/json>' and"}, {"prompt": "<s> from aliyunsdkcore . request import RpcRequest <EOL> class ListGroupsRequest ( RpcRequest ) : <EOL>", "answer": "def __init__ ( self ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "import TestGyp"}, {"prompt": "<s> import os <EOL> from datetime import date <EOL> from stdnet import odm , InvalidTransaction <EOL> from stdnet . utils import test , encoders , zip <EOL> from stdnet . utils . populate import populate <EOL> from . base import StructMixin <EOL> class TestString ( StructMixin , test . TestCase ) : <EOL> structure = odm . String <EOL> name = '<STR_LIT:string>' <EOL> def create_one ( self ) : <EOL>", "answer": "a = self . structure ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from base import GeoJSON <EOL> import geometry <EOL> class Feature ( GeoJSON ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , id = None , geometry = None , properties = None , ** extra ) : <EOL> super ( Feature , self ) . __init__ ( ** extra ) <EOL> self . id = id <EOL> self . geometry = self . to_instance ( geometry , <EOL> default = geojson . geometry . Default , <EOL> strict = True <EOL> ) <EOL> self . properties = properties or { } <EOL> @ property <EOL> def __geo_interface__ ( self ) : <EOL> d = super ( Feature , self ) . __geo_interface__ <EOL>", "answer": "d . update ( id = self . id ,"}, {"prompt": "<s> import httplib <EOL> import logging <EOL> import re <EOL> import mimetools <EOL> import base64 <EOL> from xml . dom . minidom import parseString <EOL> from image import Image <EOL> from instance import Instance <EOL> from flavor import Flavor <EOL> from realm import Realm <EOL> from state import State <EOL> from storage_snapshot import StorageSnapshot <EOL> from storage_volume import StorageVolume <EOL> from transition import Transition <EOL> resource_classes = { <EOL> \"<STR_LIT>\" : Flavor , <EOL> \"<STR_LIT:image>\" : Image , <EOL> \"<STR_LIT>\" : Instance , <EOL> \"<STR_LIT>\" : Realm , <EOL> \"<STR_LIT:state>\" : State , <EOL> \"<STR_LIT>\" : StorageSnapshot , <EOL> \"<STR_LIT>\" : StorageVolume , <EOL> } <EOL> ENCODE_TEMPLATE = \"\"\"<STR_LIT>\"\"\" . replace ( '<STR_LIT:\\n>' , '<STR_LIT:\\r\\n>' ) <EOL> class Deltacloud ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url_regex = re . compile ( r\"\"\"<STR_LIT>\"\"\" , re . VERBOSE ) <EOL> def __init__ ( self , name , password , api_uri ) : <EOL> self . name = name <EOL> self . password = password <EOL> self . api_uri = api_uri <EOL> self . _auth_string = None <EOL> self . entry_points = { } <EOL> self . driver = None <EOL> self . connected = False <EOL> def connect ( self ) : <EOL> if self . connected : <EOL> return <EOL> self . connected = True <EOL> if self . api_uri . startswith ( \"<STR_LIT>\" ) : <EOL> self . secure = False <EOL> elif self . api_uri . startswith ( \"<STR_LIT>\" ) : <EOL> self . secure = True <EOL> else : <EOL> raise ValueError ( '<STR_LIT>' % self . api_uri ) <EOL> matches = Deltacloud . url_regex . match ( self . api_uri ) <EOL> self . api_entry_host = matches . group ( <NUM_LIT:1> ) <EOL> self . api_entry_path = matches . group ( <NUM_LIT:2> ) <EOL> self . _auth_string = \"<STR_LIT>\" % ( self . name , self . password ) <EOL> self . _auth_string = base64 . encodestring ( self . _auth_string ) <EOL> self . _auth_string = self . _auth_string . replace ( \"<STR_LIT:\\n>\" , \"<STR_LIT>\" ) <EOL> self . _discover_entry_points ( ) <EOL> def _discover_entry_points ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dom = self . _request ( self . api_entry_path ) <EOL> if dom . documentElement . tagName != \"<STR_LIT>\" : <EOL> print \"<STR_LIT>\" <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> self . driver = dom . documentElement . getAttribute ( \"<STR_LIT>\" ) <EOL> for entry_point in dom . getElementsByTagName ( '<STR_LIT>' ) : <EOL> rel = entry_point . getAttribute ( \"<STR_LIT>\" ) <EOL> uri = entry_point . getAttribute ( \"<STR_LIT>\" ) <EOL> self . entry_points [ rel ] = uri <EOL> dom . unlink ( ) <EOL> self . entry_points [ '<STR_LIT>' ] = self . entry_points [ '<STR_LIT>' ] <EOL> self . entry_points [ '<STR_LIT>' ] = self . entry_points [ '<STR_LIT>' ] <EOL> def _request ( self , location = \"<STR_LIT>\" , method = \"<STR_LIT:GET>\" , query_args = { } , form_data = { } ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : self . _auth_string , <EOL> } <EOL> matches = Deltacloud . url_regex . match ( location ) <EOL> if matches == None : <EOL> host = self . api_entry_host <EOL> path = location <EOL> else : <EOL> host = matches . group ( <NUM_LIT:1> ) <EOL> path = matches . group ( <NUM_LIT:2> ) <EOL> query_list = map ( lambda key , value : key + \"<STR_LIT:=>\" + value , <EOL> query_args . keys ( ) , <EOL> query_args . values ( ) <EOL> ) <EOL> if query_list : <EOL> query_string = '<STR_LIT:?>' + '<STR_LIT:&>' . join ( query_list ) <EOL> else : <EOL> query_string = \"<STR_LIT>\" <EOL> if method == \"<STR_LIT:POST>\" and form_data : <EOL> BOUNDARY = mimetools . choose_boundary ( ) <EOL> body = \"<STR_LIT>\" <EOL> for key , value in form_data . iteritems ( ) : <EOL> body += ENCODE_TEMPLATE % { <EOL> '<STR_LIT>' : BOUNDARY , <EOL> '<STR_LIT:name>' : str ( key ) , <EOL> '<STR_LIT:value>' : str ( value ) , <EOL> } <EOL> body += \"<STR_LIT>\" % BOUNDARY <EOL> content_type = \"<STR_LIT>\" % BOUNDARY <EOL> headers [ '<STR_LIT:Content-Type>' ] = content_type <EOL> else : <EOL> body = None <EOL> if self . secure : <EOL> connection = httplib . HTTPSConnection ( host ) <EOL> else : <EOL> connection = httplib . HTTPConnection ( host ) <EOL> connection . request ( method , path + query_string , body = body , headers = headers ) <EOL> response = connection . getresponse ( ) <EOL> connection . close ( ) <EOL> text = response . read ( ) <EOL> if response . status < <NUM_LIT:200> or response . status >= <NUM_LIT> : <EOL> raise ValueError ( \"<STR_LIT>\" % response . status ) <EOL> try : <EOL> return parseString ( text ) <EOL> except Exception : <EOL> log . error ( \"<STR_LIT>\" ) <EOL> raise <EOL> def _get_resources ( self , singular_resource_name , opts = { } ) : <EOL> plural_resource_name = singular_resource_name + \"<STR_LIT:s>\" <EOL> resource_class = resource_classes [ singular_resource_name ] <EOL> entry_point_url = self . entry_points [ plural_resource_name ] <EOL> if not self . connected : <EOL> self . connect ( ) <EOL> dom = self . _request ( entry_point_url , \"<STR_LIT:GET>\" , opts ) <EOL> if dom . documentElement . tagName != plural_resource_name : <EOL> print '<STR_LIT>' % plural_resource_name <EOL> raise ValueError <EOL> resource_object_list = [ ] <EOL> for dom in dom . getElementsByTagName ( singular_resource_name ) : <EOL> resource_object_list . append ( resource_class ( self , dom ) ) <EOL> dom . unlink ( ) <EOL> return resource_object_list <EOL> def _get_resource_by_id ( self , singular_resource_name , id ) : <EOL> return self . _get_resources ( singular_resource_name , { \"<STR_LIT:id>\" : id } ) [ <NUM_LIT:0> ] <EOL> def images ( self , opts = { } ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _get_resources ( \"<STR_LIT:image>\" , opts ) <EOL> def image ( self , id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _get_resource_by_id ( \"<STR_LIT:image>\" , id ) <EOL> def fetch_image ( self , uri ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL> def instances ( self , opts = { } ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _get_resources ( \"<STR_LIT>\" , opts ) <EOL> def instance ( self , id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _get_resource_by_id ( \"<STR_LIT>\" , id ) <EOL> def create_instance ( self , image_id , opts = { } ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> form_data = { \"<STR_LIT>\" : image_id } <EOL> if \"<STR_LIT:name>\" in opts : <EOL> form_data [ \"<STR_LIT:name>\" ] = opts [ \"<STR_LIT:name>\" ] <EOL> if \"<STR_LIT>\" in opts : <EOL> form_data [ \"<STR_LIT>\" ] = opts [ \"<STR_LIT>\" ] <EOL> if \"<STR_LIT>\" in opts : <EOL> form_data [ \"<STR_LIT>\" ] = opts [ \"<STR_LIT>\" ] <EOL> entry_point = self . entry_points [ \"<STR_LIT>\" ] <EOL> dom = self . _request ( entry_point , \"<STR_LIT:POST>\" , { } , form_data ) <EOL> if dom . documentElement . tagName != \"<STR_LIT>\" : <EOL> print \"<STR_LIT>\" <EOL> raise ValueError <EOL> instance = Instance ( self , dom ) <EOL> dom . unlink ( ) <EOL> return instance <EOL> def fetch_instance ( self , uri ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL> def instance_states ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL> def instance_state ( self , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return name in self . instance_states ( ) <EOL> def flavors ( self , opts = { } ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _get_resources ( \"<STR_LIT>\" , opts ) <EOL> def flavor ( self , id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _get_resource_by_id ( \"<STR_LIT>\" , id ) <EOL> def fetch_flavor ( self , uri ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL> def realms ( self , opts = { } ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _get_resources ( \"<STR_LIT>\" , opts ) <EOL>", "answer": "def realm ( self , id ) :"}, {"prompt": "<s> import sys <EOL> import unittest <EOL> from supervisor . tests . base import DummySupervisor <EOL> from supervisor . tests . base import DummyRequest <EOL> from supervisor . tests . base import DummySupervisorRPCNamespace <EOL> class XMLRPCMarshallingTests ( unittest . TestCase ) : <EOL> def test_xmlrpc_marshal ( self ) : <EOL> import xmlrpclib <EOL> from supervisor import xmlrpc <EOL> data = xmlrpc . xmlrpc_marshal ( <NUM_LIT:1> ) <EOL> self . assertEqual ( data , xmlrpclib . dumps ( ( <NUM_LIT:1> , ) , methodresponse = True ) ) <EOL> fault = xmlrpclib . Fault ( <NUM_LIT:1> , '<STR_LIT:foo>' ) <EOL> data = xmlrpc . xmlrpc_marshal ( fault ) <EOL> self . assertEqual ( data , xmlrpclib . dumps ( fault ) ) <EOL> class XMLRPCHandlerTests ( unittest . TestCase ) : <EOL> def _getTargetClass ( self ) : <EOL> from supervisor . xmlrpc import supervisor_xmlrpc_handler <EOL> return supervisor_xmlrpc_handler <EOL> def _makeOne ( self , supervisord , subinterfaces ) : <EOL> return self . _getTargetClass ( ) ( supervisord , subinterfaces ) <EOL> def test_ctor ( self ) : <EOL> supervisor = DummySupervisor ( ) <EOL> subinterfaces = [ ( '<STR_LIT>' , DummySupervisorRPCNamespace ( ) ) ] <EOL> handler = self . _makeOne ( supervisor , subinterfaces ) <EOL> self . assertEqual ( handler . supervisord , supervisor ) <EOL> from supervisor . xmlrpc import RootRPCInterface <EOL> self . assertEqual ( handler . rpcinterface . __class__ , RootRPCInterface ) <EOL> def test_match ( self ) : <EOL> class DummyRequest : <EOL> def __init__ ( self , uri ) : <EOL> self . uri = uri <EOL> supervisor = DummySupervisor ( ) <EOL> subinterfaces = [ ( '<STR_LIT>' , DummySupervisorRPCNamespace ( ) ) ] <EOL> handler = self . _makeOne ( supervisor , subinterfaces ) <EOL> self . assertEqual ( handler . match ( DummyRequest ( '<STR_LIT>' ) ) , True ) <EOL> self . assertEqual ( handler . match ( DummyRequest ( '<STR_LIT>' ) ) , False ) <EOL> def test_continue_request_nosuchmethod ( self ) : <EOL> supervisor = DummySupervisor ( ) <EOL> subinterfaces = [ ( '<STR_LIT>' , DummySupervisorRPCNamespace ( ) ) ] <EOL> handler = self . _makeOne ( supervisor , subinterfaces ) <EOL> import xmlrpclib <EOL> data = xmlrpclib . dumps ( ( '<STR_LIT:a>' , '<STR_LIT:b>' ) , '<STR_LIT>' ) <EOL> request = DummyRequest ( '<STR_LIT>' , None , None , None ) <EOL> handler . continue_request ( data , request ) <EOL> logdata = supervisor . options . logger . data <EOL> from supervisor . xmlrpc import loads <EOL> if loads : <EOL> expected = <NUM_LIT:2> <EOL> else : <EOL> expected = <NUM_LIT:3> <EOL> self . assertEqual ( len ( logdata ) , expected ) <EOL> self . assertEqual ( logdata [ - <NUM_LIT:2> ] , <EOL> u'<STR_LIT>' ) <EOL> self . assertEqual ( logdata [ - <NUM_LIT:1> ] , <EOL> ( u'<STR_LIT>' <EOL> '<STR_LIT>' ) ) <EOL> self . assertEqual ( len ( request . producers ) , <NUM_LIT:1> ) <EOL> xml_response = request . producers [ <NUM_LIT:0> ] <EOL> self . assertRaises ( xmlrpclib . Fault , xmlrpclib . loads , xml_response ) <EOL> def test_continue_request_methodsuccess ( self ) : <EOL> supervisor = DummySupervisor ( ) <EOL> subinterfaces = [ ( '<STR_LIT>' , DummySupervisorRPCNamespace ( ) ) ] <EOL> handler = self . _makeOne ( supervisor , subinterfaces ) <EOL> import xmlrpclib <EOL> data = xmlrpclib . dumps ( ( ) , '<STR_LIT>' ) <EOL> request = DummyRequest ( '<STR_LIT>' , None , None , None ) <EOL> handler . continue_request ( data , request ) <EOL> logdata = supervisor . options . logger . data <EOL> from supervisor . xmlrpc import loads <EOL> if loads : <EOL> expected = <NUM_LIT:2> <EOL> else : <EOL> expected = <NUM_LIT:3> <EOL> self . assertEqual ( len ( logdata ) , expected ) <EOL> self . assertEqual ( logdata [ - <NUM_LIT:2> ] , <EOL> u'<STR_LIT>' ) <EOL> self . assertEqual ( logdata [ - <NUM_LIT:1> ] , <EOL> u'<STR_LIT>' ) <EOL> self . assertEqual ( len ( request . producers ) , <NUM_LIT:1> ) <EOL> xml_response = request . producers [ <NUM_LIT:0> ] <EOL> response = xmlrpclib . loads ( xml_response ) <EOL> self . assertEqual ( response [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] , '<STR_LIT>' ) <EOL> self . assertEqual ( request . _done , True ) <EOL> self . assertEqual ( request . headers [ '<STR_LIT:Content-Type>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( request . headers [ '<STR_LIT>' ] , len ( xml_response ) ) <EOL> def test_continue_request_500 ( self ) : <EOL> supervisor = DummySupervisor ( ) <EOL> subinterfaces = [ ( '<STR_LIT>' , DummySupervisorRPCNamespace ( ) ) ] <EOL> handler = self . _makeOne ( supervisor , subinterfaces ) <EOL> import xmlrpclib <EOL> data = xmlrpclib . dumps ( ( ) , '<STR_LIT>' ) <EOL> request = DummyRequest ( '<STR_LIT>' , None , None , None ) <EOL> handler . continue_request ( data , request ) <EOL> logdata = supervisor . options . logger . data <EOL> from supervisor . xmlrpc import loads <EOL> if loads : <EOL> expected = <NUM_LIT:2> <EOL> else : <EOL> expected = <NUM_LIT:3> <EOL> self . assertEqual ( len ( logdata ) , expected ) <EOL> self . assertEqual ( logdata [ - <NUM_LIT:2> ] , <EOL> u'<STR_LIT>' ) <EOL> self . failUnless ( logdata [ - <NUM_LIT:1> ] . startswith ( '<STR_LIT>' ) ) <EOL> self . failUnless ( logdata [ - <NUM_LIT:1> ] . endswith ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( len ( request . producers ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( request . _error , <NUM_LIT> ) <EOL> class TraverseTests ( unittest . TestCase ) : <EOL> def test_underscore ( self ) : <EOL> from supervisor import xmlrpc <EOL> self . assertRaises ( xmlrpc . RPCError , xmlrpc . traverse , None , '<STR_LIT:_>' , None ) <EOL> def test_notfound ( self ) : <EOL> from supervisor import xmlrpc <EOL> self . assertRaises ( xmlrpc . RPCError , xmlrpc . traverse , None , '<STR_LIT:foo>' , None ) <EOL> def test_badparams ( self ) : <EOL> from supervisor import xmlrpc <EOL> self . assertRaises ( xmlrpc . RPCError , xmlrpc . traverse , self , <EOL> '<STR_LIT>' , ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> def test_success ( self ) : <EOL> from supervisor import xmlrpc <EOL> L = [ ] <EOL> class Dummy : <EOL> def foo ( self , a ) : <EOL> L . append ( a ) <EOL> dummy = Dummy ( ) <EOL> xmlrpc . traverse ( dummy , '<STR_LIT:foo>' , [ <NUM_LIT:1> ] ) <EOL>", "answer": "self . assertEqual ( L , [ <NUM_LIT:1> ] )"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> from . . excel_comparsion_test import ExcelComparisonTest <EOL> from ... workbook import Workbook <EOL> class TestCompareXLSXFiles ( ExcelComparisonTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . maxDiff = None <EOL> filename = '<STR_LIT>' <EOL> test_dir = '<STR_LIT>' <EOL> self . got_filename = test_dir + '<STR_LIT>' + filename <EOL> self . exp_filename = test_dir + '<STR_LIT>' + filename <EOL> self . ignore_files = [ ] <EOL> self . ignore_elements = { } <EOL>", "answer": "def test_create_file ( self ) :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import six <EOL> from six . moves import reduce <EOL> try : <EOL> import gnumpy <EOL> import cudamat <EOL> gnumpy_available = True <EOL> ___const_garray = gnumpy . rand ( <NUM_LIT:1> ) <EOL> import theano . sandbox . cuda as cuda <EOL> if cuda . cuda_available is False : <EOL> raise ImportError ( '<STR_LIT>' ) <EOL> if six . PY3 : <EOL> long = int <EOL> def cudandarray_to_garray ( x , copyif = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( x , cuda . CudaNdarray ) : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> size = <NUM_LIT:1> <EOL> c_contiguous = True <EOL> for i in range ( x . ndim - <NUM_LIT:1> , - <NUM_LIT:1> , - <NUM_LIT:1> ) : <EOL> if x . shape [ i ] == <NUM_LIT:1> : <EOL> continue <EOL> if x . _strides [ i ] != size : <EOL> c_contiguous = False <EOL> break <EOL> size *= x . shape [ i ] <EOL> if not c_contiguous : <EOL> if copyif : <EOL> x = x . copy ( ) <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> cm_mat = cudamat . cudamat ( ) <EOL> cm_mat . size [ <NUM_LIT:0> ] = reduce ( lambda x , y : x * y , x . shape , <NUM_LIT:1> ) <EOL> cm_mat . size [ <NUM_LIT:1> ] = <NUM_LIT:1> <EOL> cm_mat . on_host = <NUM_LIT:0> <EOL>", "answer": "cm_mat . on_device = <NUM_LIT:1>"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from contracts import contract <EOL> from neat . contracts_primitive import * <EOL> from neat . contracts_extra import * <EOL> import logging <EOL> log = logging . getLogger ( __name__ ) <EOL> @ contract <EOL>", "answer": "def never_overloaded_factory ( time_step , migration_time , params ) :"}, {"prompt": "<s> import sys <EOL> from marrow . script . core import Parser <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def execute ( obj ) : <EOL> sys . exit ( Parser ( obj ) ( sys . argv [ <NUM_LIT:1> : ] ) ) <EOL> def base ( attr ) : <EOL> def decorator ( ** kw ) : <EOL> def inner ( fn ) : <EOL> if not hasattr ( fn , attr ) : <EOL> fn . __dict__ [ attr ] = dict ( ) <EOL> fn . __dict__ [ attr ] . update ( kw ) <EOL> return fn <EOL> return inner <EOL> return decorator <EOL> script = base ( '<STR_LIT>' ) <EOL>", "answer": "annotate = base ( '<STR_LIT>' )"}, {"prompt": "<s> from unittest import TestCase <EOL> from addic7ed_cli . episode import Episode , search <EOL> from addic7ed_cli . util import file_to_query , normalize_release , parse_release <EOL> def s ( * args ) : <EOL> return set ( args ) <EOL> class TestAddic7ed ( TestCase ) : <EOL> maxDiff = None <EOL> def test_search ( self ) : <EOL> result = search ( '<STR_LIT>' ) <EOL> self . assertEqual ( result , [ <EOL> Episode ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> ] ) <EOL> def test_search_multiple ( self ) : <EOL> result = search ( '<STR_LIT>' ) <EOL> self . assertEqual ( result , [ <EOL> Episode ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) , <EOL> Episode ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) , <EOL> Episode ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) , <EOL> ] ) <EOL> def file_to_query ( self , filename , query , version = set ( ) ) : <EOL> q , v = file_to_query ( filename ) <EOL> self . assertEqual ( query , q ) <EOL> self . assertEqual ( version , v ) <EOL> def test_file_to_query ( self ) : <EOL> self . file_to_query ( '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> s ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> self . file_to_query ( '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> s ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> self . file_to_query ( '<STR_LIT>' , <EOL> \"<STR_LIT>\" , <EOL> s ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> def test_file_to_query_stopword ( self ) : <EOL> self . file_to_query ( '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> s ( '<STR_LIT>' ) ) <EOL> def test_file_to_query_exceptions ( self ) : <EOL> self . file_to_query ( '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> s ( '<STR_LIT>' ) ) <EOL> def test_file_to_query_number_in_title ( self ) : <EOL> self . file_to_query ( '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> s ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> def test_file_to_query_noseason ( self ) : <EOL> self . file_to_query ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def test_file_to_query_nonumber ( self ) : <EOL> self . file_to_query ( '<STR_LIT>' , '<STR_LIT>' , s ( '<STR_LIT:foo>' , '<STR_LIT:bar>' ) ) <EOL> def test_file_to_query_threenumbers ( self ) : <EOL> self . file_to_query ( '<STR_LIT>' , '<STR_LIT>' , s ( '<STR_LIT>' ) ) <EOL> self . file_to_query ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def test_file_to_query_fournumbers ( self ) : <EOL> self . file_to_query ( '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> s ( '<STR_LIT>' ) ) <EOL> self . file_to_query ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def test_file_to_query_season_episode ( self ) : <EOL> self . file_to_query ( '<STR_LIT>' , <EOL> '<STR_LIT>' , s ( '<STR_LIT:foo>' ) ) <EOL> def test_episode ( self ) : <EOL> result = Episode ( '<STR_LIT>' ) <EOL> result . fetch_versions ( ) <EOL> self . assertEqual ( result . title , '<STR_LIT>' ) <EOL> versions = result . filter_versions ( [ '<STR_LIT>' , '<STR_LIT>' ] , s ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( '<STR_LIT>' , versions [ <NUM_LIT:1> ] . language ) <EOL> self . assertEqual ( '<STR_LIT>' , versions [ <NUM_LIT:1> ] . url ) <EOL> self . assertFalse ( versions [ <NUM_LIT:0> ] . hearing_impaired ) <EOL> self . assertTrue ( versions [ <NUM_LIT:1> ] . hearing_impaired ) <EOL> def test_unicode_episode ( self ) : <EOL> search ( '<STR_LIT>' ) [ <NUM_LIT:0> ] . fetch_versions ( ) <EOL> search ( '<STR_LIT>' ) <EOL> def test_normalize_release ( self ) : <EOL>", "answer": "self . assertEqual ( s ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ,"}, {"prompt": "<s> import datetime <EOL> from gluon import current <EOL> from bson . objectid import ObjectId <EOL> def add_seconds_to_date ( date , seconds ) : <EOL> return date + datetime . timedelta ( <NUM_LIT:0> , seconds ) <EOL> class OAuthStorage ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> SALT = '<STR_LIT>' <EOL> @ staticmethod <EOL> def generate_hash_512 ( length = <NUM_LIT:32> , salt = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import hashlib <EOL> import base64 <EOL> encode_str = base64 . urlsafe_b64encode ( os . urandom ( length ) ) <EOL> m = hashlib . sha512 ( ) <EOL> if salt : <EOL> encode_str = self . SALT + encode_str <EOL> m . update ( encode_str ) <EOL> return m . hexdigest ( ) <EOL> @ staticmethod <EOL> def generate_hash_sha1 ( length = <NUM_LIT:32> , salt = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import hashlib <EOL> import base64 <EOL> encode_str = base64 . urlsafe_b64encode ( os . urandom ( length ) ) <EOL> m = hashlib . sha1 ( ) <EOL> if salt : <EOL> encode_str = self . SALT + encode_str <EOL> m . update ( encode_str ) <EOL> return m . hexdigest ( ) <EOL> def __init__ ( self , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . server = kwargs . get ( '<STR_LIT>' , None ) <EOL> self . port = kwargs . get ( '<STR_LIT:port>' , None ) <EOL> self . db_name = kwargs . get ( '<STR_LIT>' , None ) <EOL> class web2pyStorage ( OAuthStorage ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> tables_created = False <EOL> def create_tables ( self ) : <EOL> if self . tables_created : <EOL> return <EOL> from gluon . tools import Field <EOL> from gluon . validators import IS_URL <EOL> self . db . define_table ( '<STR_LIT>' , <EOL> Field ( '<STR_LIT>' ) , <EOL> Field ( '<STR_LIT>' ) , <EOL> Field ( '<STR_LIT>' , requires = IS_URL ( allowed_schemes = [ '<STR_LIT:http>' , '<STR_LIT>' ] ) ) , <EOL> Field ( '<STR_LIT>' ) <EOL> ) <EOL> self . db . define_table ( '<STR_LIT>' , <EOL> Field ( '<STR_LIT>' ) , <EOL> Field ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> Field ( '<STR_LIT>' ) , <EOL> Field ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> Field ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> Field ( '<STR_LIT>' ) , <EOL> Field ( '<STR_LIT>' ) <EOL> ) <EOL> self . db . define_table ( '<STR_LIT>' , <EOL> Field ( '<STR_LIT>' ) , <EOL> Field ( '<STR_LIT>' ) , <EOL> Field ( '<STR_LIT>' ) , <EOL> Field ( '<STR_LIT>' ) , <EOL> Field ( '<STR_LIT>' ) , <EOL> Field ( '<STR_LIT>' ) , <EOL> Field ( '<STR_LIT>' ) <EOL> ) <EOL> self . tables_created = True <EOL> def connect ( self ) : <EOL> from gluon . tools import DAL <EOL> if self . server == self . port == self . db_name == None : <EOL> self . server = '<STR_LIT>' <EOL> conn = self . server if not self . port else self . server + self . port <EOL> self . db = DAL ( conn , pool_size = <NUM_LIT:1> , check_reserved = [ '<STR_LIT:all>' ] ) <EOL> def add_client ( self , client_name , redirect_uri ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> self . db . clients <EOL> except AttributeError : <EOL> self . create_tables ( ) <EOL> client_id = self . generate_hash_sha1 ( ) <EOL> client_secret = self . generate_hash_sha1 ( ) <EOL> self . db . clients . insert ( ** { '<STR_LIT>' : client_id , <EOL> '<STR_LIT>' : client_secret , <EOL> '<STR_LIT>' : redirect_uri , <EOL> '<STR_LIT>' : client_name } ) <EOL>", "answer": "return client_id , client_secret"}, {"prompt": "<s> from fitparse . activity import Activity <EOL> from fitparse . exceptions import FitError , FitParseError , FitParseComplete <EOL>", "answer": "__all__ = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] "}, {"prompt": "<s> from heapq import heappop , heapreplace , heapify <EOL> from operator import attrgetter <EOL> def augment_intervals ( it , i , key ) : <EOL> last = None <EOL> for value in it : <EOL> k = key ( value ) <EOL> if last is not None and k < last : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> yield k , i , value <EOL> def iter_merge ( iterators , key = id ) : <EOL> augmented = [ augment_intervals ( it , i , key ) for i , it in enumerate ( iterators ) ] <EOL> for min_key , index , value in merge ( augmented ) : <EOL> yield index , value <EOL> def merge ( iterables ) : <EOL> '''<STR_LIT>''' <EOL> _heappop , _heapreplace , _StopIteration = heappop , heapreplace , StopIteration <EOL> h = [ ] <EOL> h_append = h . append <EOL> for i , it in enumerate ( map ( iter , iterables ) ) : <EOL> try : <EOL> next = it . next if hasattr ( it , '<STR_LIT>' ) else it . __next__ <EOL> h_append ( [ next ( ) , i , next ] ) <EOL> except _StopIteration : <EOL> pass <EOL> heapify ( h ) <EOL>", "answer": "while <NUM_LIT:1> :"}, {"prompt": "<s> import sys <EOL> import codecs <EOL> import locale <EOL> import requests <EOL> from re import sub <EOL> from datetime import datetime <EOL> from email . utils import parsedate <EOL> from django . utils import timezone <EOL> from django . utils . six . moves import input <EOL> from django . utils . termcolors import colorize <EOL> from django . core . management . base import BaseCommand <EOL> from calaccess_raw . models . tracking import ( <EOL> RawDataVersion , <EOL> RawDataFile , <EOL> RawDataCommand <EOL> ) <EOL> class CalAccessCommand ( BaseCommand ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url = '<STR_LIT>' <EOL> def handle ( self , * args , ** options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . verbosity = options . get ( \"<STR_LIT>\" ) <EOL> self . no_color = options . get ( \"<STR_LIT>\" ) <EOL> self . start_datetime = datetime . now ( ) <EOL> self . raw_data_versions = RawDataVersion . objects <EOL> self . raw_data_files = RawDataFile . objects <EOL> self . command_logs = RawDataCommand . objects <EOL> def get_download_metadata ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> request = requests . head ( self . url ) <EOL> last_modified = request . headers [ '<STR_LIT>' ] <EOL> dt = datetime ( * parsedate ( last_modified ) [ : <NUM_LIT:6> ] ) <EOL> return { <EOL> '<STR_LIT>' : int ( request . headers [ '<STR_LIT>' ] ) , <EOL> '<STR_LIT>' : timezone . utc . localize ( dt ) <EOL> } <EOL> def get_last_log ( self , file_name = None , finished = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if file_name : <EOL> q = self . command_logs . filter ( file_name = file_name ) <EOL> else : <EOL> q = self . command_logs <EOL> if finished : <EOL> order_by_field = '<STR_LIT>' <EOL> q = q . filter ( finish_datetime__isnull = False ) <EOL> else : <EOL> order_by_field = '<STR_LIT>' <EOL> try : <EOL> last_log = q . filter ( <EOL> command = self <EOL> ) . order_by ( order_by_field ) [ <NUM_LIT:0> ] <EOL> except IndexError : <EOL> last_log = None <EOL> return last_log <EOL> def get_caller_log ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> caller = None <EOL> if not self . _called_from_command_line : <EOL> try : <EOL> caller = self . command_logs . filter ( <EOL> command = sys . argv [ <NUM_LIT:1> ] <EOL> ) . order_by ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> except IndexError : <EOL> pass <EOL> return caller <EOL> def header ( self , string ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . no_color : <EOL> string = colorize ( string , fg = \"<STR_LIT>\" , opts = ( \"<STR_LIT>\" , ) ) <EOL> self . stdout . write ( string ) <EOL> def log ( self , string ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . no_color : <EOL> string = colorize ( \"<STR_LIT:%s>\" % string , fg = \"<STR_LIT>\" ) <EOL> self . stdout . write ( string ) <EOL> def success ( self , string ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . no_color : <EOL> string = colorize ( string , fg = \"<STR_LIT>\" ) <EOL> self . stdout . write ( string ) <EOL> def failure ( self , string ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . no_color : <EOL> string = colorize ( string , fg = \"<STR_LIT>\" ) <EOL> self . stdout . write ( string ) <EOL> def duration ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "duration = datetime . now ( ) - self . start_datetime"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from lino . api import ad , _ <EOL> class Plugin ( ad . Plugin ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> verbose_name = _ ( \"<STR_LIT>\" ) <EOL> needs_plugins = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> responsible_user = None <EOL> _responsible_user = None <EOL> def get_responsible_user ( self , checker , obj ) : <EOL> if self . responsible_user is None : <EOL> return None <EOL> if self . _responsible_user is None : <EOL>", "answer": "User = self . site . modules . users . User"}, {"prompt": "<s> import subprocess <EOL> import click <EOL> @ click . group ( ) <EOL> def cli ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> @ click . command ( ) <EOL>", "answer": "def serve ( ) :"}, {"prompt": "<s> from . image import * <EOL>", "answer": "from . math import *"}, {"prompt": "<s> import hTools2 . dialogs . glyphs . mirror <EOL> reload ( hTools2 . dialogs . glyphs . mirror ) <EOL>", "answer": "hTools2 . dialogs . glyphs . mirror . mirrorGlyphsDialog ( ) "}, {"prompt": "<s> import numpy , vigra <EOL> import sys , os , traceback , copy , csv , shutil , warnings <EOL> with warnings . catch_warnings ( ) : <EOL> warnings . simplefilter ( \"<STR_LIT:ignore>\" ) <EOL> import h5py <EOL> import ilastik <EOL> from ilastik . core . volume import VolumeLabels <EOL> from ilastik . core . baseModuleMgr import BaseModuleDataItemMgr , BaseModuleMgr <EOL> from ilastik . modules . connected_components . core . connectedComponentsMgr import ConnectedComponents <EOL> import seedMgr <EOL> from segmentors import segmentorBase <EOL> from PyQt4 . QtCore import SIGNAL <EOL> from PyQt4 . QtGui import QMessageBox <EOL> pathext = os . path . dirname ( __file__ ) <EOL> for f in os . listdir ( os . path . abspath ( pathext ) + \"<STR_LIT>\" ) : <EOL> module_name , ext = os . path . splitext ( f ) <EOL> if ext == '<STR_LIT>' and module_name [ - <NUM_LIT:1> ] != \"<STR_LIT:_>\" : <EOL> try : <EOL> module = __import__ ( \"<STR_LIT>\" + module_name ) <EOL> except Exception , e : <EOL> print e <EOL> traceback . print_exc ( file = sys . stdout ) <EOL> pass <EOL> for i , c in enumerate ( segmentorBase . SegmentorBase . __subclasses__ ( ) ) : <EOL> print \"<STR_LIT>\" , c . name <EOL> segmentorClasses = segmentorBase . SegmentorBase . __subclasses__ ( ) <EOL> if len ( segmentorClasses ) == <NUM_LIT:0> : <EOL> segmentorClasses = [ segmentorBase . SegmentorBase ] <EOL> def unravelIndices ( indices , shape ) : <EOL> if len ( indices . shape ) == <NUM_LIT:1> : <EOL> indices . shape = indices . shape + ( <NUM_LIT:1> , ) <EOL> try : <EOL> ti = numpy . apply_along_axis ( numpy . unravel_index , <NUM_LIT:1> , indices , shape ) <EOL> except Exception , e : <EOL> print e <EOL> print indices <EOL> print shape <EOL> return ti <EOL> def setintersectionmask ( a , b ) : <EOL> if int ( numpy . __version__ . split ( '<STR_LIT:.>' ) [ <NUM_LIT:1> ] ) >= <NUM_LIT:4> : <EOL> return numpy . in1d ( a , b , assume_unique = True ) <EOL> else : <EOL> return numpy . intersect1d ( a , b ) <EOL> class ArrayWrapper : <EOL> def __init__ ( self , array ) : <EOL> self . array = array <EOL> self . dtype = array . dtype <EOL> self . shape = ( <NUM_LIT:1> , ) + array . shape <EOL> def __getitem__ ( self , key ) : <EOL> return self . array [ tuple ( key [ <NUM_LIT:1> : ] ) ] <EOL> class InteractiveSegmentationItemModuleMgr ( BaseModuleDataItemMgr ) : <EOL> name = \"<STR_LIT>\" <EOL> def __init__ ( self , dataItemImage ) : <EOL> BaseModuleDataItemMgr . __init__ ( self , dataItemImage ) <EOL> self . outputPath = None <EOL> self . seedLabelsVolume = None <EOL> self . done = None <EOL> self . segmentation = None <EOL> self . _currentSegmentsKey = None <EOL> self . _mapLabelsToKeys = dict ( ) <EOL> self . _mapKeysToLabels = dict ( ) <EOL> self . _hasSeeds = False <EOL> self . _dataItemImage = dataItemImage <EOL> self . interactiveSegmentationModuleMgr = None <EOL> self . _segmentationWeights = None <EOL> self . _seedLabelsList = None <EOL> self . _seedIndicesList = None <EOL> self . segmentorInstance = None <EOL> self . potentials = None <EOL> def __reset ( self ) : <EOL> self . clearSeeds ( ) <EOL> self . _buildSeedsWhenNotThere ( ) <EOL> self . _currentSegmentsKey = None <EOL> def __loadMapping ( self ) : <EOL> mappingFileName = self . outputPath + \"<STR_LIT>\" <EOL> print \"<STR_LIT>\" <EOL> if os . path . exists ( mappingFileName ) : <EOL> r = csv . reader ( open ( mappingFileName , '<STR_LIT:r>' ) , delimiter = '<STR_LIT:|>' ) <EOL> for entry in r : <EOL> key = entry [ <NUM_LIT:1> ] . strip ( ) <EOL> folderPath = self . outputPath + '<STR_LIT:/>' + key <EOL> if not os . path . exists ( folderPath ) : <EOL> QMessageBox . critical ( None , \"<STR_LIT>\" , <EOL> \"\"\"<STR_LIT>\"\"\" % ( mappingFileName , folderPath ) ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> label = int ( entry [ <NUM_LIT:0> ] ) <EOL> self . _mapLabelsToKeys [ label ] = key <EOL> if key not in self . _mapKeysToLabels . keys ( ) : <EOL> self . _mapKeysToLabels [ key ] = set ( ) <EOL> self . _mapKeysToLabels [ key ] . add ( label ) <EOL> def __saveMapping ( self ) : <EOL> mappingFileName = self . outputPath + \"<STR_LIT>\" <EOL> r = csv . writer ( open ( mappingFileName , '<STR_LIT:w>' ) , delimiter = '<STR_LIT:|>' ) <EOL> for i , key in self . _mapLabelsToKeys . items ( ) : <EOL> r . writerow ( [ i , key ] ) <EOL> def init ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from ilastik . modules . interactive_segmentation . core import startupOutputPath <EOL> self . outputPath = startupOutputPath <EOL> self . __createSeedsData ( ) <EOL> if not self . outputPath : <EOL> return <EOL> else : <EOL> print \"<STR_LIT>\" % ( self . outputPath ) <EOL> if not os . path . exists ( self . outputPath + '<STR_LIT:/>' + '<STR_LIT>' ) : return <EOL> f = open ( self . outputPath + '<STR_LIT:/>' + '<STR_LIT>' ) <EOL> lines = f . readlines ( ) <EOL> d = dict ( ) <EOL> for l in lines : <EOL> l = l . split ( '<STR_LIT:=>' ) ; key = l [ <NUM_LIT:0> ] . strip ( ) ; val = l [ <NUM_LIT:1> ] . strip ( ) <EOL> d [ key ] = val <EOL> if self . _dataItemImage . overlayMgr [ d [ \"<STR_LIT>\" ] ] is None and self . _dataItemImage . overlayMgr [ \"<STR_LIT>\" + d [ \"<STR_LIT>\" ] ] is None : <EOL> from PyQt4 . QtGui import QMessageBox <EOL> QMessageBox . critical ( None , \"<STR_LIT>\" , <EOL> \"\"\"<STR_LIT>\"\"\" % d [ \"<STR_LIT>\" ] ) <EOL> raise RuntimeError ( \"<STR_LIT>\" ) <EOL> overlayName = d [ \"<STR_LIT>\" ] <EOL> if self . _dataItemImage . overlayMgr [ d [ \"<STR_LIT>\" ] ] is None : <EOL> overlayName = \"<STR_LIT>\" + d [ \"<STR_LIT>\" ] <EOL> self . calculateWeights ( self . _dataItemImage . overlayMgr [ overlayName ] . _data [ <NUM_LIT:0> , : , : , : , <NUM_LIT:0> ] , d [ \"<STR_LIT>\" ] ) <EOL> def calculateWeights ( self , volume , borderIndicator , normalizePotential = True , sigma = <NUM_LIT:1.0> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if borderIndicator == \"<STR_LIT>\" : <EOL> weights = volume [ : , : , : ] . view ( vigra . ScalarVolume ) <EOL> elif borderIndicator == \"<STR_LIT>\" : <EOL> weights = ( <NUM_LIT:255> - volume [ : , : , : ] ) . view ( vigra . ScalarVolume ) <EOL> elif borderIndicator == \"<STR_LIT>\" : <EOL> weights = numpy . ndarray ( volume . shape , numpy . float32 ) <EOL> if weights . shape [ <NUM_LIT:0> ] == <NUM_LIT:1> : <EOL> weights [ <NUM_LIT:0> , : , : ] = vigra . filters . gaussianGradientMagnitude ( ( volume [ <NUM_LIT:0> , : , : ] ) . astype ( numpy . float32 ) , sigma ) <EOL> else : <EOL> weights = vigra . filters . gaussianGradientMagnitude ( ( volume [ : , : , : ] ) . astype ( numpy . float32 ) , sigma ) <EOL> if normalizePotential == True : <EOL> min = numpy . min ( volume ) <EOL> max = numpy . max ( volume ) <EOL> print \"<STR_LIT>\" , min , max <EOL> weights = ( weights - min ) * ( <NUM_LIT> / ( max - min ) ) <EOL> self . setupWeights ( weights ) <EOL> def setupWeights ( self , weights = None ) : <EOL> if weights is None : <EOL> weights = self . _segmentationWeights <EOL> else : <EOL> self . _segmentationWeights = weights <EOL> if self . globalMgr . segmentor is not None : <EOL> self . globalMgr . segmentor . setupWeights ( weights ) <EOL> self . emit ( SIGNAL ( '<STR_LIT>' ) ) <EOL> def segmentKeyForLabel ( self , label ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _mapLabelsToKeys [ label ] <EOL> def segmentLabelsForKey ( self , key ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _mapKeysToLabels [ key ] <EOL> def hasSegmentsKey ( self , key ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return key in self . _mapKeysToLabels . keys ( ) <EOL> def saveCurrentSegment ( self ) : <EOL> assert self . _currentSegmentsKey <EOL> self . saveCurrentSegmentsAs ( self . _currentSegmentsKey , overwrite = True ) <EOL> def saveCurrentSegmentsAs ( self , key , overwrite = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print \"<STR_LIT>\" % ( key ) <EOL> assert self . outputPath <EOL> if self . done is None : <EOL> self . done = numpy . zeros ( self . _dataItemImage . shape , numpy . uint16 ) <EOL> self . emit ( SIGNAL ( '<STR_LIT>' ) ) <EOL> if overwrite : <EOL> shutil . rmtree ( self . outputPath + '<STR_LIT:/>' + str ( key ) ) <EOL> labelsToDelete = copy . deepcopy ( self . _mapKeysToLabels [ key ] ) <EOL> del self . _mapKeysToLabels [ key ] <EOL> for l in labelsToDelete : <EOL> del self . _mapLabelsToKeys [ l ] <EOL> self . __rebuildDone ( ) <EOL> elif os . path . exists ( self . outputPath + '<STR_LIT:/>' + str ( key ) ) : <EOL> raise RuntimeError ( \"<STR_LIT>\" , self . outputPath + '<STR_LIT:/>' + str ( key ) ) <EOL> path = self . outputPath + '<STR_LIT:/>' + str ( key ) <EOL> print \"<STR_LIT>\" % ( path ) , <EOL> os . makedirs ( path ) <EOL> print \"<STR_LIT>\" , <EOL> f = h5py . File ( path + \"<STR_LIT>\" , '<STR_LIT:w>' ) <EOL> f . create_group ( '<STR_LIT>' ) <EOL> tmp = self . segmentation [ <NUM_LIT:0> , : , : , : , <NUM_LIT:0> ] <EOL> tmp . shape = ( <NUM_LIT:1> , ) + tmp . shape + ( <NUM_LIT:1> , ) <EOL> f . create_dataset ( '<STR_LIT>' , data = tmp , dtype = tmp . dtype , chunks = True , compression = '<STR_LIT>' ) <EOL> f . close ( ) ; del f <EOL> print \"<STR_LIT>\" <EOL> f = h5py . File ( path + \"<STR_LIT>\" , '<STR_LIT:w>' ) <EOL> f . create_group ( '<STR_LIT>' ) <EOL> f . create_dataset ( '<STR_LIT>' , data = self . seedLabelsVolume . _data [ : , : , : , : , : ] , <EOL> dtype = self . seedLabelsVolume . _data . dtype , <EOL> chunks = True , compression = '<STR_LIT>' ) <EOL> f . close ( ) ; del f <EOL> print \"<STR_LIT>\" <EOL> connectedComponentsComputer = ConnectedComponents ( ) <EOL> prevMaxLabel = numpy . max ( self . done ) <EOL> print \"<STR_LIT>\" % ( prevMaxLabel ) <EOL> cc = connectedComponentsComputer . connect ( self . segmentation [ <NUM_LIT:0> , : , : , : , : ] , background = set ( [ <NUM_LIT:1> ] ) ) <EOL> self . done [ : , : , : , : , : ] = numpy . where ( cc > <NUM_LIT:0> , cc + int ( prevMaxLabel ) , self . done ) <EOL> f = h5py . File ( self . outputPath + \"<STR_LIT>\" , '<STR_LIT:w>' ) <EOL> f . create_group ( '<STR_LIT>' ) <EOL> f . create_dataset ( '<STR_LIT>' , data = self . done , dtype = numpy . uint16 , chunks = True , compression = '<STR_LIT>' ) <EOL> f . close ( ) <EOL> numCC = numpy . max ( cc ) <EOL> print \"<STR_LIT>\" % ( numCC , key ) <EOL> print \"<STR_LIT>\" <EOL> for i in range ( prevMaxLabel + <NUM_LIT:1> , prevMaxLabel + numCC + <NUM_LIT:1> ) : <EOL> print \"<STR_LIT>\" % ( i , key ) <EOL> self . _mapLabelsToKeys [ i ] = key <EOL> if key not in self . _mapKeysToLabels . keys ( ) : <EOL> self . _mapKeysToLabels [ key ] = set ( ) <EOL> self . _mapKeysToLabels [ key ] . add ( i ) <EOL> self . __saveMapping ( ) <EOL> self . __reset ( ) <EOL> self . segmentation = None <EOL> self . emit ( SIGNAL ( '<STR_LIT>' ) , False ) <EOL> self . emit ( SIGNAL ( '<STR_LIT>' ) , False ) <EOL> self . emit ( SIGNAL ( '<STR_LIT>' ) ) <EOL> def discardCurrentSegmentation ( self ) : <EOL> self . segmentation = None <EOL> self . __reset ( ) <EOL> self . emit ( SIGNAL ( '<STR_LIT>' ) ) <EOL> def removeSegmentsByKey ( self , key ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print \"<STR_LIT>\" % ( key ) <EOL> labelsForKey = self . _mapKeysToLabels [ key ] <EOL> print \"<STR_LIT>\" , [ i for i in self . _mapKeysToLabels [ key ] ] , \"<STR_LIT>\" % ( key ) <EOL> del self . _mapKeysToLabels [ key ] <EOL> for l in labelsForKey : <EOL> del self . _mapLabelsToKeys [ l ] <EOL> path = self . outputPath + '<STR_LIT:/>' + str ( key ) <EOL> print \"<STR_LIT>\" % ( path ) <EOL> shutil . rmtree ( path ) <EOL> self . segmentation = None <EOL> self . __reset ( ) <EOL> self . __saveMapping ( ) <EOL> self . __rebuildDone ( ) <EOL> f = h5py . File ( self . outputPath + \"<STR_LIT>\" , '<STR_LIT:w>' ) <EOL> f . create_group ( '<STR_LIT>' ) <EOL> f . create_dataset ( '<STR_LIT>' , data = self . done , dtype = numpy . uint16 , chunks = True , compression = '<STR_LIT>' ) <EOL> f . close ( ) <EOL> self . emit ( SIGNAL ( '<STR_LIT>' ) ) <EOL> def editSegmentsByKey ( self , key ) : <EOL> print \"<STR_LIT>\" % ( key ) <EOL> assert self . hasSegmentsKey ( key ) <EOL> self . _currentSegmentsKey = key <EOL> self . clearSeeds ( ) <EOL> f = h5py . File ( self . outputPath + '<STR_LIT:/>' + key + '<STR_LIT>' , '<STR_LIT:r>' ) <EOL> seeds = f [ '<STR_LIT>' ] . value [ <NUM_LIT:0> , : , : , : , : ] <EOL> self . seedLabelsVolume . _data [ <NUM_LIT:0> , : , : , : , : ] = seeds <EOL> f . close ( ) <EOL> numColorsNeeded = numpy . max ( seeds ) <EOL> print \"<STR_LIT>\" % ( numColorsNeeded ) <EOL> self . emit ( SIGNAL ( '<STR_LIT>' ) , numColorsNeeded ) <EOL> self . _buildSeedsWhenNotThere ( ) <EOL> self . segment ( ) <EOL> self . emit ( SIGNAL ( '<STR_LIT>' ) ) <EOL> def __rebuildDone ( self ) : <EOL> print \"<STR_LIT>\" <EOL> self . done [ : ] = <NUM_LIT:0> <EOL> maxLabel = <NUM_LIT:0> <EOL> keys = copy . deepcopy ( self . _mapKeysToLabels . keys ( ) ) <EOL> self . _mapKeysToLabels = dict ( ) <EOL> self . _mapLabelsToKeys = dict ( ) <EOL> for key in sorted ( keys ) : <EOL> print \"<STR_LIT>\" % ( key ) <EOL> path = self . outputPath + '<STR_LIT:/>' + str ( key ) <EOL> f = h5py . File ( path + '<STR_LIT:/>' + '<STR_LIT>' , '<STR_LIT:r>' ) <EOL> connectedComponentsComputer = ConnectedComponents ( ) <EOL> cc = connectedComponentsComputer . connect ( f [ '<STR_LIT>' ] [ <NUM_LIT:0> , : , : , : , <NUM_LIT:0> ] , background = set ( [ <NUM_LIT:1> ] ) ) <EOL> numNewLabels = numpy . max ( cc ) <EOL> self . done [ : ] = numpy . where ( cc > <NUM_LIT:0> , cc + int ( maxLabel ) , self . done ) <EOL> r = range ( maxLabel + <NUM_LIT:1> , maxLabel + <NUM_LIT:1> + numNewLabels ) <EOL> self . _mapKeysToLabels [ key ] = set ( r ) <EOL> for i in r : <EOL> print \"<STR_LIT>\" % ( i , key ) <EOL> self . _mapLabelsToKeys [ i ] = key <EOL> maxLabel += numNewLabels <EOL> print \"<STR_LIT>\" % ( maxLabel , len ( self . _mapKeysToLabels . keys ( ) ) ) <EOL> def setModuleMgr ( self , interactiveSegmentationModuleMgr ) : <EOL> self . interactiveSegmentationModuleMgr = interactiveSegmentationModuleMgr <EOL> def __createSeedsData ( self ) : <EOL> if self . seedLabelsVolume is None : <EOL> l = numpy . zeros ( self . _dataItemImage . shape [ <NUM_LIT:0> : - <NUM_LIT:1> ] + ( <NUM_LIT:1> , ) , '<STR_LIT>' ) <EOL> self . seedLabelsVolume = VolumeLabels ( l ) <EOL> if not self . outputPath : return <EOL> if not os . path . exists ( self . outputPath ) : <EOL> os . makedirs ( self . outputPath ) <EOL> if self . done is None and os . path . exists ( self . outputPath + \"<STR_LIT>\" ) : <EOL> print \"<STR_LIT>\" % ( self . outputPath + \"<STR_LIT>\" ) <EOL> f = h5py . File ( self . outputPath + \"<STR_LIT>\" , '<STR_LIT:r>' ) <EOL> self . done = f [ '<STR_LIT>' ] . value <EOL> self . emit ( SIGNAL ( '<STR_LIT>' ) ) <EOL> self . __loadMapping ( ) <EOL> def clearSeeds ( self ) : <EOL> self . _hasSeeds = False <EOL> self . emit ( SIGNAL ( '<STR_LIT>' ) , self . _hasSeeds ) <EOL> self . _seedLabelsList = None <EOL> self . _seedIndicesList = None <EOL> self . seedLabelsVolume . _data [ <NUM_LIT:0> , : , : , : , <NUM_LIT:0> ] = <NUM_LIT:0> <EOL> def _buildSeedsWhenNotThere ( self ) : <EOL> if self . _seedLabelsList is None : <EOL> tempL = [ ] <EOL> tempd = self . seedLabelsVolume . _data [ : , : , : , : , <NUM_LIT:0> ] . ravel ( ) <EOL> indices = numpy . nonzero ( tempd ) [ <NUM_LIT:0> ] <EOL> tempL = self . seedLabelsVolume . _data [ : , : , : , : , <NUM_LIT:0> ] . ravel ( ) [ indices ] <EOL> tempL . shape += ( <NUM_LIT:1> , ) <EOL> self . _seedIndicesList = indices <EOL> self . _seedLabelsList = tempL <EOL>", "answer": "def getSeeds ( self ) :"}, {"prompt": "<s> from atom . api import Atom , Unicode <EOL> class Person ( Atom ) : <EOL> first_name = Unicode ( ) <EOL>", "answer": "last_name = Unicode ( ) "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from bbio import * <EOL> class Servo ( object ) : <EOL> def __init__ ( self , pwm_pin = None , pwm_freq = <NUM_LIT:50> , min_ms = <NUM_LIT:0.5> , max_ms = <NUM_LIT> ) : <EOL> assert ( pwm_freq > <NUM_LIT:0> ) , \"<STR_LIT>\" % str ( pwm_freq ) <EOL>", "answer": "assert ( min_ms > <NUM_LIT:0> ) , \"<STR_LIT>\" % str ( min_ms )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> from aminator . plugins . manager import BasePluginManager <EOL> log = logging . getLogger ( __name__ ) <EOL> class DistroPluginManager ( BasePluginManager ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _entry_point = '<STR_LIT>' <EOL> @ property <EOL> def entry_point ( self ) : <EOL> return self . _entry_point <EOL>", "answer": "@ staticmethod"}, {"prompt": "<s> import json <EOL> import logging <EOL> import random <EOL> from django . http import Http404 <EOL> from django . utils . translation import ugettext as _ <EOL> from django . views . decorators . http import require_POST <EOL> from desktop . lib . django_util import JsonResponse <EOL> from desktop . lib . i18n import force_unicode <EOL> from desktop . models import Document2 <EOL> from notebook . models import Notebook <EOL> from metadata . optimizer_client import OptimizerApi <EOL> from metadata . conf import OPTIMIZER <EOL> LOG = logging . getLogger ( __name__ ) <EOL> def error_handler ( view_fn ) : <EOL> def decorator ( * args , ** kwargs ) : <EOL> try : <EOL> return view_fn ( * args , ** kwargs ) <EOL> except Http404 , e : <EOL> raise e <EOL> except Exception , e : <EOL> LOG . exception ( e ) <EOL> response = { <EOL> '<STR_LIT:status>' : - <NUM_LIT:1> , <EOL> '<STR_LIT:message>' : force_unicode ( str ( e ) ) <EOL> } <EOL> return JsonResponse ( response , status = <NUM_LIT> ) <EOL> return decorator <EOL> @ require_POST <EOL> @ error_handler <EOL> def top_tables ( request ) : <EOL> response = { '<STR_LIT:status>' : - <NUM_LIT:1> } <EOL> database = request . POST . get ( '<STR_LIT>' , '<STR_LIT:default>' ) <EOL> len = request . POST . get ( '<STR_LIT>' , <NUM_LIT:1000> ) <EOL> if OPTIMIZER . MOCKING . get ( ) : <EOL> from beeswax . server import dbms <EOL> from beeswax . server . dbms import get_query_server_config <EOL> db = dbms . get ( request . user ) <EOL> tables = [ <EOL> { '<STR_LIT:name>' : table , '<STR_LIT>' : random . randint ( <NUM_LIT:1> , <NUM_LIT:100> ) , '<STR_LIT>' : random . randint ( <NUM_LIT:1> , <NUM_LIT:100> ) , '<STR_LIT>' : bool ( random . getrandbits ( <NUM_LIT:1> ) ) } <EOL> for table in db . get_tables ( database = database ) <EOL> ] [ : len ] <EOL> else : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> api = OptimizerApi ( ) <EOL> data = api . top_tables ( ) <EOL> tables = [ { <EOL> '<STR_LIT>' : table [ '<STR_LIT>' ] , <EOL> '<STR_LIT:name>' : table [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT>' : table [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : table [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : table [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : table [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : table [ '<STR_LIT:type>' ] != '<STR_LIT>' <EOL> } for table in data [ '<STR_LIT>' ] <EOL> ] <EOL> response [ '<STR_LIT>' ] = tables <EOL> response [ '<STR_LIT:status>' ] = <NUM_LIT:0> <EOL> return JsonResponse ( response ) <EOL> @ require_POST <EOL> @ error_handler <EOL> def table_details ( request ) : <EOL> response = { '<STR_LIT:status>' : - <NUM_LIT:1> } <EOL> table_name = request . POST . get ( '<STR_LIT>' ) <EOL> api = OptimizerApi ( ) <EOL> data = api . table_details ( table_name = table_name ) <EOL> if data [ '<STR_LIT:status>' ] == '<STR_LIT:success>' : <EOL> response [ '<STR_LIT:status>' ] = <NUM_LIT:0> <EOL> response [ '<STR_LIT>' ] = data [ '<STR_LIT>' ] <EOL> else : <EOL> response [ '<STR_LIT:message>' ] = '<STR_LIT>' % data [ '<STR_LIT>' ] <EOL> return JsonResponse ( response ) <EOL> @ require_POST <EOL> @ error_handler <EOL> def query_compatibility ( request ) : <EOL> response = { '<STR_LIT:status>' : - <NUM_LIT:1> } <EOL> source_platform = request . POST . get ( '<STR_LIT>' ) <EOL> target_platform = request . POST . get ( '<STR_LIT>' ) <EOL> query = request . POST . get ( '<STR_LIT>' ) <EOL> api = OptimizerApi ( ) <EOL> data = api . query_compatibility ( source_platform = source_platform , target_platform = target_platform , query = query ) <EOL> if data [ '<STR_LIT:status>' ] == '<STR_LIT:success>' : <EOL> response [ '<STR_LIT:status>' ] = <NUM_LIT:0> <EOL> response [ '<STR_LIT>' ] = json . loads ( data [ '<STR_LIT>' ] ) <EOL> else : <EOL> response [ '<STR_LIT:message>' ] = '<STR_LIT>' % data [ '<STR_LIT>' ] <EOL> return JsonResponse ( response ) <EOL> @ require_POST <EOL> @ error_handler <EOL> def query_complexity ( request ) : <EOL> response = { '<STR_LIT:status>' : - <NUM_LIT:1> } <EOL> snippet = json . loads ( request . POST . get ( '<STR_LIT>' ) ) <EOL> if '<STR_LIT>' in snippet [ '<STR_LIT>' ] . lower ( ) : <EOL> comment = '<STR_LIT>' <EOL> elif '<STR_LIT>' in snippet [ '<STR_LIT>' ] . lower ( ) : <EOL> comment = '<STR_LIT>' <EOL> elif '<STR_LIT>' in snippet [ '<STR_LIT>' ] . lower ( ) : <EOL> comment = '<STR_LIT>' <EOL> else : <EOL> comment = '<STR_LIT>' <EOL> response [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : random . choice ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) , <EOL> '<STR_LIT>' : comment <EOL> } <EOL> response [ '<STR_LIT:status>' ] = <NUM_LIT:0> <EOL> return JsonResponse ( response ) <EOL> @ require_POST <EOL> @ error_handler <EOL> def simiar_queries ( request ) : <EOL> response = { '<STR_LIT:status>' : - <NUM_LIT:1> } <EOL> source_platform = request . POST . get ( '<STR_LIT>' ) <EOL> query = request . POST . get ( '<STR_LIT>' ) <EOL> api = OptimizerApi ( ) <EOL> data = api . similar_queries ( source_platform = source_platform , query = query ) <EOL> if data [ '<STR_LIT:status>' ] == '<STR_LIT:success>' : <EOL> response [ '<STR_LIT:status>' ] = <NUM_LIT:0> <EOL> response [ '<STR_LIT>' ] = json . loads ( data [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> else : <EOL> response [ '<STR_LIT:message>' ] = '<STR_LIT>' % data [ '<STR_LIT>' ] <EOL> return JsonResponse ( response ) <EOL> @ require_POST <EOL> @ error_handler <EOL> def popular_values ( request ) : <EOL> response = { '<STR_LIT:status>' : - <NUM_LIT:1> } <EOL> table_name = request . POST . get ( '<STR_LIT>' ) <EOL> column_name = request . POST . get ( '<STR_LIT>' ) <EOL> if OPTIMIZER . MOCKING . get ( ) : <EOL> if column_name : <EOL> values = [ <EOL> { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT:1>\" , <EOL> \"<STR_LIT>\" <EOL> ] , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> ] <EOL> else : <EOL> values = [ <EOL> { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ] , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT:1>\" , <EOL> \"<STR_LIT:2>\" , <EOL> \"<STR_LIT:4>\" <EOL> ] , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" <EOL> ] , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ] , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ] , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT:1>\" , <EOL> \"<STR_LIT:3>\" , <EOL> \"<STR_LIT:2>\" , <EOL> \"<STR_LIT:5>\" , <EOL> \"<STR_LIT:4>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ] , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT:1>\" , <EOL> \"<STR_LIT:3>\" , <EOL> \"<STR_LIT:2>\" <EOL> ] , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ] , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT:1>\" , <EOL> \"<STR_LIT>\" <EOL> ] , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> ] <EOL> else : <EOL> api = OptimizerApi ( ) <EOL> data = api . popular_filter_values ( table_name = table_name , column_name = column_name ) <EOL> if data [ '<STR_LIT:status>' ] == '<STR_LIT:success>' : <EOL> if '<STR_LIT:status>' in data [ '<STR_LIT>' ] : <EOL> response [ '<STR_LIT>' ] = [ ] <EOL>", "answer": "else :"}, {"prompt": "<s> from gen import Tree , gentree <EOL> from operator import lt , gt <EOL> from sys import stdout <EOL> class DrawTree ( object ) : <EOL> def __init__ ( self , tree , parent = None , depth = <NUM_LIT:0> , number = <NUM_LIT:1> ) : <EOL> self . x = - <NUM_LIT:1.> <EOL> self . y = depth <EOL> self . tree = tree <EOL> self . children = [ DrawTree ( c , self , depth + <NUM_LIT:1> , i + <NUM_LIT:1> ) <EOL> for i , c <EOL> in enumerate ( tree . children ) ] <EOL> self . parent = parent <EOL> self . thread = None <EOL> self . mod = <NUM_LIT:0> <EOL> self . ancestor = self <EOL> self . change = self . shift = <NUM_LIT:0> <EOL> self . _lmost_sibling = None <EOL> self . number = number <EOL> def left ( self ) : <EOL> return self . thread or len ( self . children ) and self . children [ <NUM_LIT:0> ] <EOL> def right ( self ) : <EOL> return self . thread or len ( self . children ) and self . children [ - <NUM_LIT:1> ] <EOL> def lbrother ( self ) : <EOL> n = None <EOL> if self . parent : <EOL> for node in self . parent . children : <EOL> if node == self : return n <EOL> else : n = node <EOL> return n <EOL> def get_lmost_sibling ( self ) : <EOL> if not self . _lmost_sibling and self . parent and self != self . parent . children [ <NUM_LIT:0> ] : <EOL> self . _lmost_sibling = self . parent . children [ <NUM_LIT:0> ] <EOL> return self . _lmost_sibling <EOL> lmost_sibling = property ( get_lmost_sibling ) <EOL> def __str__ ( self ) : return \"<STR_LIT>\" % ( self . tree , self . x , self . mod ) <EOL> def __repr__ ( self ) : return self . __str__ ( ) <EOL> def buchheim ( tree ) : <EOL> dt = firstwalk ( DrawTree ( tree ) ) <EOL> min = second_walk ( dt ) <EOL> if min < <NUM_LIT:0> : <EOL> third_walk ( dt , - min ) <EOL> return dt <EOL> def third_walk ( tree , n ) : <EOL> tree . x += n <EOL> for c in tree . children : <EOL> third_walk ( c , n ) <EOL> def firstwalk ( v , distance = <NUM_LIT:1.> ) : <EOL> if len ( v . children ) == <NUM_LIT:0> : <EOL> if v . lmost_sibling : <EOL> v . x = v . lbrother ( ) . x + distance <EOL> else : <EOL> v . x = <NUM_LIT:0.> <EOL> else : <EOL> default_ancestor = v . children [ <NUM_LIT:0> ] <EOL> for w in v . children : <EOL> firstwalk ( w ) <EOL> default_ancestor = apportion ( w , default_ancestor , distance ) <EOL> print \"<STR_LIT>\" , v . tree , \"<STR_LIT>\" <EOL> execute_shifts ( v ) <EOL> midpoint = ( v . children [ <NUM_LIT:0> ] . x + v . children [ - <NUM_LIT:1> ] . x ) / <NUM_LIT:2> <EOL> ell = v . children [ <NUM_LIT:0> ] <EOL> arr = v . children [ - <NUM_LIT:1> ] <EOL> w = v . lbrother ( ) <EOL> if w : <EOL> v . x = w . x + distance <EOL> v . mod = v . x - midpoint <EOL> else : <EOL> v . x = midpoint <EOL> return v <EOL> def apportion ( v , default_ancestor , distance ) : <EOL> w = v . lbrother ( ) <EOL> if w is not None : <EOL> vir = vor = v <EOL> vil = w <EOL> vol = v . lmost_sibling <EOL> sir = sor = v . mod <EOL> sil = vil . mod <EOL> sol = vol . mod <EOL> while vil . right ( ) and vir . left ( ) : <EOL> vil = vil . right ( ) <EOL> vir = vir . left ( ) <EOL> vol = vol . left ( ) <EOL> vor = vor . right ( ) <EOL> vor . ancestor = v <EOL> shift = ( vil . x + sil ) - ( vir . x + sir ) + distance <EOL> if shift > <NUM_LIT:0> : <EOL> move_subtree ( ancestor ( vil , v , default_ancestor ) , v , shift ) <EOL>", "answer": "sir = sir + shift"}, {"prompt": "<s> try : <EOL> import geoalchemy2 <EOL>", "answer": "import shapely"}, {"prompt": "<s> import re <EOL> from itertools import chain <EOL> def wrap_nested_params ( app , options = { } ) : <EOL> def wrapped_app ( req ) : <EOL> key_parser = options . get ( '<STR_LIT>' , parse_nested_keys ) <EOL> req [ \"<STR_LIT>\" ] = nest_params ( req [ \"<STR_LIT>\" ] , key_parser ) <EOL> return app ( req ) <EOL> return wrapped_app <EOL> def nest_params ( params , key_parser ) : <EOL> return reduce ( lambda d , kv : set_nested_value ( d , key_parser ( kv [ <NUM_LIT:0> ] ) , kv [ <NUM_LIT:1> ] ) , <EOL> param_pairs ( params ) , { } ) <EOL> def param_pairs ( params ) : <EOL> return sum ( <EOL> [ [ ( key , v ) for v in val ] if isinstance ( val , list ) else [ ( key , val ) ] <EOL> for ( key , val ) in params . items ( ) ] , [ ] ) <EOL> def set_nested_value ( d , keys , v ) : <EOL>", "answer": "k , ks = None , None"}, {"prompt": "<s> import os <EOL> import sys <EOL> from setuptools import setup , find_packages <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> url = '<STR_LIT>' , <EOL> packages = find_packages ( ) , <EOL> zip_safe = True , <EOL>", "answer": "keywords = '<STR_LIT>' ,"}, {"prompt": "<s> from django . conf import settings <EOL> def push_credentials ( hub_url ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "return tuple ( settings . SUPERFEEDR_CREDS ) "}, {"prompt": "<s> __all__ = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> import functools <EOL> from oslo_log import log as logging <EOL> import oslo_messaging as messaging <EOL> from oslo_serialization import jsonutils <EOL> import nova . conf <EOL> import nova . context <EOL> import nova . exception <EOL> from nova . i18n import _ <EOL> CONF = nova . conf . CONF <EOL> LOG = logging . getLogger ( __name__ ) <EOL> TRANSPORT = None <EOL> LEGACY_NOTIFIER = None <EOL> NOTIFICATION_TRANSPORT = None <EOL> NOTIFIER = None <EOL> ALLOWED_EXMODS = [ <EOL> nova . exception . __name__ , <EOL> ] <EOL> EXTRA_EXMODS = [ ] <EOL> TRANSPORT_ALIASES = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> def init ( conf ) : <EOL> global TRANSPORT , NOTIFICATION_TRANSPORT , LEGACY_NOTIFIER , NOTIFIER <EOL> exmods = get_allowed_exmods ( ) <EOL> TRANSPORT = messaging . get_transport ( conf , <EOL> allowed_remote_exmods = exmods , <EOL> aliases = TRANSPORT_ALIASES ) <EOL> NOTIFICATION_TRANSPORT = messaging . get_notification_transport ( <EOL> conf , allowed_remote_exmods = exmods , aliases = TRANSPORT_ALIASES ) <EOL> serializer = RequestContextSerializer ( JsonPayloadSerializer ( ) ) <EOL> if conf . notification_format == '<STR_LIT>' : <EOL> LEGACY_NOTIFIER = messaging . Notifier ( NOTIFICATION_TRANSPORT , <EOL> serializer = serializer ) <EOL> NOTIFIER = messaging . Notifier ( NOTIFICATION_TRANSPORT , <EOL> serializer = serializer , driver = '<STR_LIT>' ) <EOL> elif conf . notification_format == '<STR_LIT>' : <EOL> LEGACY_NOTIFIER = messaging . Notifier ( NOTIFICATION_TRANSPORT , <EOL> serializer = serializer ) <EOL> NOTIFIER = messaging . Notifier ( NOTIFICATION_TRANSPORT , <EOL> serializer = serializer , <EOL> topics = [ '<STR_LIT>' ] ) <EOL> else : <EOL> LEGACY_NOTIFIER = messaging . Notifier ( NOTIFICATION_TRANSPORT , <EOL> serializer = serializer , <EOL> driver = '<STR_LIT>' ) <EOL> NOTIFIER = messaging . Notifier ( NOTIFICATION_TRANSPORT , <EOL> serializer = serializer , <EOL> topics = [ '<STR_LIT>' ] ) <EOL> def cleanup ( ) : <EOL> global TRANSPORT , NOTIFICATION_TRANSPORT , LEGACY_NOTIFIER , NOTIFIER <EOL> assert TRANSPORT is not None <EOL> assert NOTIFICATION_TRANSPORT is not None <EOL> assert LEGACY_NOTIFIER is not None <EOL> assert NOTIFIER is not None <EOL> TRANSPORT . cleanup ( ) <EOL> NOTIFICATION_TRANSPORT . cleanup ( ) <EOL> TRANSPORT = NOTIFICATION_TRANSPORT = LEGACY_NOTIFIER = NOTIFIER = None <EOL> def set_defaults ( control_exchange ) : <EOL> messaging . set_transport_defaults ( control_exchange ) <EOL> def add_extra_exmods ( * args ) : <EOL> EXTRA_EXMODS . extend ( args ) <EOL> def clear_extra_exmods ( ) : <EOL> del EXTRA_EXMODS [ : ] <EOL> def get_allowed_exmods ( ) : <EOL> return ALLOWED_EXMODS + EXTRA_EXMODS <EOL> class JsonPayloadSerializer ( messaging . NoOpSerializer ) : <EOL> @ staticmethod <EOL> def serialize_entity ( context , entity ) : <EOL> return jsonutils . to_primitive ( entity , convert_instances = True ) <EOL> class RequestContextSerializer ( messaging . Serializer ) : <EOL> def __init__ ( self , base ) : <EOL> self . _base = base <EOL> def serialize_entity ( self , context , entity ) : <EOL> if not self . _base : <EOL> return entity <EOL> return self . _base . serialize_entity ( context , entity ) <EOL> def deserialize_entity ( self , context , entity ) : <EOL> if not self . _base : <EOL> return entity <EOL> return self . _base . deserialize_entity ( context , entity ) <EOL> def serialize_context ( self , context ) : <EOL> return context . to_dict ( ) <EOL> def deserialize_context ( self , context ) : <EOL> return nova . context . RequestContext . from_dict ( context ) <EOL> def get_transport_url ( url_str = None ) : <EOL> return messaging . TransportURL . parse ( CONF , url_str , TRANSPORT_ALIASES ) <EOL> def get_client ( target , version_cap = None , serializer = None ) : <EOL> assert TRANSPORT is not None <EOL> serializer = RequestContextSerializer ( serializer ) <EOL> return messaging . RPCClient ( TRANSPORT , <EOL> target , <EOL> version_cap = version_cap , <EOL> serializer = serializer ) <EOL> def get_server ( target , endpoints , serializer = None ) : <EOL> assert TRANSPORT is not None <EOL> serializer = RequestContextSerializer ( serializer ) <EOL> return messaging . get_rpc_server ( TRANSPORT , <EOL> target , <EOL> endpoints , <EOL> executor = '<STR_LIT>' , <EOL> serializer = serializer ) <EOL> def get_notifier ( service , host = None , publisher_id = None ) : <EOL> assert LEGACY_NOTIFIER is not None <EOL> if not publisher_id : <EOL> publisher_id = \"<STR_LIT>\" % ( service , host or CONF . host ) <EOL> return LegacyValidatingNotifier ( <EOL> LEGACY_NOTIFIER . prepare ( publisher_id = publisher_id ) ) <EOL> def get_versioned_notifier ( publisher_id ) : <EOL> assert NOTIFIER is not None <EOL> return NOTIFIER . prepare ( publisher_id = publisher_id ) <EOL> class LegacyValidatingNotifier ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fatal = False <EOL> allowed_legacy_notification_event_types = [ <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> import test . support , unittest <EOL> class PowTest ( unittest . TestCase ) : <EOL> def powtest ( self , type ) : <EOL> if type != float : <EOL> for i in range ( - <NUM_LIT:1000> , <NUM_LIT:1000> ) : <EOL> self . assertEqual ( pow ( type ( i ) , <NUM_LIT:0> ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( pow ( type ( i ) , <NUM_LIT:1> ) , type ( i ) ) <EOL> self . assertEqual ( pow ( type ( <NUM_LIT:0> ) , <NUM_LIT:1> ) , type ( <NUM_LIT:0> ) ) <EOL> self . assertEqual ( pow ( type ( <NUM_LIT:1> ) , <NUM_LIT:1> ) , type ( <NUM_LIT:1> ) ) <EOL> for i in range ( - <NUM_LIT:100> , <NUM_LIT:100> ) : <EOL> self . assertEqual ( pow ( type ( i ) , <NUM_LIT:3> ) , i * i * i ) <EOL> pow2 = <NUM_LIT:1> <EOL> for i in range ( <NUM_LIT:0> , <NUM_LIT> ) : <EOL> self . assertEqual ( pow ( <NUM_LIT:2> , i ) , pow2 ) <EOL> if i != <NUM_LIT:30> : pow2 = pow2 * <NUM_LIT:2> <EOL> for othertype in ( int , ) : <EOL> for i in list ( range ( - <NUM_LIT:10> , <NUM_LIT:0> ) ) + list ( range ( <NUM_LIT:1> , <NUM_LIT:10> ) ) : <EOL> ii = type ( i ) <EOL> for j in range ( <NUM_LIT:1> , <NUM_LIT:11> ) : <EOL> jj = - othertype ( j ) <EOL> pow ( ii , jj ) <EOL> for othertype in int , float : <EOL> for i in range ( <NUM_LIT:1> , <NUM_LIT:100> ) : <EOL> zero = type ( <NUM_LIT:0> ) <EOL> exp = - othertype ( i / <NUM_LIT> ) <EOL> if exp == <NUM_LIT:0> : <EOL> continue <EOL> self . assertRaises ( ZeroDivisionError , pow , zero , exp ) <EOL> il , ih = - <NUM_LIT:20> , <NUM_LIT:20> <EOL> jl , jh = - <NUM_LIT:5> , <NUM_LIT:5> <EOL> kl , kh = - <NUM_LIT:10> , <NUM_LIT:10> <EOL> asseq = self . assertEqual <EOL> if type == float : <EOL> il = <NUM_LIT:1> <EOL> asseq = self . assertAlmostEqual <EOL> elif type == int : <EOL> jl = <NUM_LIT:0> <EOL> elif type == int : <EOL> jl , jh = <NUM_LIT:0> , <NUM_LIT:15> <EOL>", "answer": "for i in range ( il , ih + <NUM_LIT:1> ) :"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from django . conf . urls import include , patterns , url <EOL> from . views import * <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL> url ( r'<STR_LIT>' , <EOL> PageUpdateView . as_view ( ) , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , <EOL> PageCreateView . as_view ( ) , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , <EOL> PageCreateView . as_view ( ) , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , <EOL> PageDeleteView . as_view ( ) , name = '<STR_LIT>' ) , <EOL>", "answer": "url ( r'<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import codecs <EOL> from pygments . util import get_bool_opt <EOL> from pygments . styles import get_style_by_name <EOL> __all__ = [ '<STR_LIT>' ] <EOL> def _lookup_style ( style ) : <EOL> if isinstance ( style , basestring ) : <EOL> return get_style_by_name ( style ) <EOL> return style <EOL> class Formatter ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = None <EOL> aliases = [ ] <EOL> filenames = [ ] <EOL> unicodeoutput = True <EOL> def __init__ ( self , ** options ) : <EOL> self . style = _lookup_style ( options . get ( '<STR_LIT>' , '<STR_LIT:default>' ) ) <EOL> self . full = get_bool_opt ( options , '<STR_LIT>' , False ) <EOL> self . title = options . get ( '<STR_LIT:title>' , '<STR_LIT>' ) <EOL> self . encoding = options . get ( '<STR_LIT>' , None ) or None <EOL> self . encoding = options . get ( '<STR_LIT>' , None ) or self . encoding <EOL> self . options = options <EOL> def get_style_defs ( self , arg = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return '<STR_LIT>' <EOL>", "answer": "def format ( self , tokensource , outfile ) :"}, {"prompt": "<s> from commit import _get_service_file <EOL> import jsonschema <EOL> import subprocess <EOL> import fnmatch <EOL> import os <EOL> from fileio import dirio <EOL> from log import log <EOL> import glob <EOL> import tempfile <EOL> import stat <EOL> _action_schema = { <EOL> '<STR_LIT:type>' : '<STR_LIT:object>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:description>' : '<STR_LIT>' , <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:type>' : '<STR_LIT:string>' <EOL> } , <EOL> '<STR_LIT>' : <NUM_LIT:1> <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:description>' : '<STR_LIT>' , <EOL> '<STR_LIT:type>' : '<STR_LIT:string>' , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:description>' : '<STR_LIT>' , <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:type>' : '<STR_LIT:string>' <EOL> } , <EOL> '<STR_LIT>' : True <EOL> } <EOL> } , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] <EOL> } <EOL> _reaction_schema = { <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:type>' : '<STR_LIT:object>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:description>' : '<STR_LIT>' , <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:type>' : '<STR_LIT:string>' <EOL> } , <EOL> '<STR_LIT>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : True <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:type>' : '<STR_LIT:object>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:description>' : '<STR_LIT>' , <EOL> '<STR_LIT:type>' : '<STR_LIT:string>' <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:description>' : '<STR_LIT>' , <EOL> '<STR_LIT:type>' : '<STR_LIT>' <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:description>' : '<STR_LIT>' , <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL>", "answer": "'<STR_LIT:type>' : '<STR_LIT:string>'"}, {"prompt": "<s> from __future__ import absolute_import , division , print_function , unicode_literals <EOL> from collections import deque , namedtuple , OrderedDict <EOL> from cStringIO import StringIO <EOL> from itertools import chain , imap <EOL> from json import JSONDecoder , JSONEncoder <EOL> from json . encoder import encode_basestring_ascii as json_encode_string <EOL> from urllib import unquote <EOL> import csv <EOL> import gzip <EOL> import os <EOL> import re <EOL> import sys <EOL> from . import environment <EOL> csv . field_size_limit ( <NUM_LIT> ) <EOL> if sys . platform == '<STR_LIT:win32>' : <EOL> from platform import python_implementation <EOL> implementation = python_implementation ( ) <EOL> fileno = sys . stdout . fileno ( ) <EOL> if implementation == '<STR_LIT>' : <EOL> sys . stdout = os . fdopen ( fileno , '<STR_LIT:wb>' , <NUM_LIT:0> ) <EOL> else : <EOL> from msvcrt import setmode <EOL> setmode ( fileno , os . O_BINARY ) <EOL> class CommandLineParser ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ classmethod <EOL> def parse ( cls , command , argv ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> debug = environment . splunklib_logger . debug <EOL> command_class = type ( command ) . __name__ <EOL> debug ( '<STR_LIT>' , command_class , argv ) <EOL> command . fieldnames = None <EOL> command . options . reset ( ) <EOL> argv = '<STR_LIT:U+0020>' . join ( argv ) <EOL> command_args = cls . _arguments_re . match ( argv ) <EOL> if command_args is None : <EOL> raise SyntaxError ( '<STR_LIT>' . format ( argv ) ) <EOL> for option in cls . _options_re . finditer ( command_args . group ( '<STR_LIT>' ) ) : <EOL> name , value = option . group ( '<STR_LIT:name>' ) , option . group ( '<STR_LIT:value>' ) <EOL> if name not in command . options : <EOL> raise ValueError ( <EOL> '<STR_LIT>' . format ( command . name , name , json_encode_string ( value ) ) ) <EOL> command . options [ name ] . value = cls . unquote ( value ) <EOL> missing = command . options . get_missing ( ) <EOL> if missing is not None : <EOL> if len ( missing ) > <NUM_LIT:1> : <EOL> raise ValueError ( <EOL> '<STR_LIT>' . format ( command . name , '<STR_LIT:U+002CU+0020>' . join ( missing ) ) ) <EOL> raise ValueError ( '<STR_LIT>' . format ( command . name , missing [ <NUM_LIT:0> ] ) ) <EOL> fieldnames = command_args . group ( '<STR_LIT>' ) <EOL> if fieldnames is None : <EOL> command . fieldnames = [ ] <EOL> else : <EOL> command . fieldnames = [ cls . unquote ( value . group ( <NUM_LIT:0> ) ) for value in cls . _fieldnames_re . finditer ( fieldnames ) ] <EOL> debug ( '<STR_LIT>' , command_class , command ) <EOL> @ classmethod <EOL> def unquote ( cls , string ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( string ) == <NUM_LIT:0> : <EOL> return '<STR_LIT>' <EOL> if string [ <NUM_LIT:0> ] == '<STR_LIT:\">' : <EOL> if len ( string ) == <NUM_LIT:1> or string [ - <NUM_LIT:1> ] != '<STR_LIT:\">' : <EOL> raise SyntaxError ( '<STR_LIT>' + string ) <EOL> string = string [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> if len ( string ) == <NUM_LIT:0> : <EOL> return '<STR_LIT>' <EOL> def replace ( match ) : <EOL> value = match . group ( <NUM_LIT:0> ) <EOL> if value == '<STR_LIT>' : <EOL> return '<STR_LIT:\">' <EOL> if len ( value ) < <NUM_LIT:2> : <EOL> raise SyntaxError ( '<STR_LIT>' + string ) <EOL> return value [ <NUM_LIT:1> ] <EOL> result = re . sub ( cls . _escaped_character_re , replace , string ) <EOL> return result <EOL> _arguments_re = re . compile ( r\"\"\"<STR_LIT>\"\"\" , re . VERBOSE | re . UNICODE ) <EOL> _escaped_character_re = re . compile ( r'<STR_LIT>' ) <EOL> _fieldnames_re = re . compile ( r\"\"\"<STR_LIT>\"\"\" ) <EOL> _options_re = re . compile ( r\"\"\"<STR_LIT>\"\"\" , re . VERBOSE | re . UNICODE ) <EOL> class ConfigurationSettingsType ( type ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __new__ ( mcs , module , name , bases ) : <EOL> mcs = super ( ConfigurationSettingsType , mcs ) . __new__ ( mcs , name , bases , { } ) <EOL> return mcs <EOL> def __init__ ( cls , module , name , bases ) : <EOL> super ( ConfigurationSettingsType , cls ) . __init__ ( name , bases , None ) <EOL> cls . __module__ = module <EOL> @ staticmethod <EOL> def validate_configuration_setting ( specification , name , value ) : <EOL> if not isinstance ( value , specification . type ) : <EOL> if isinstance ( specification . type , type ) : <EOL> type_names = specification . type . __name__ <EOL> else : <EOL> type_names = '<STR_LIT:U+002CU+0020>' . join ( imap ( lambda t : t . __name__ , specification . type ) ) <EOL> raise ValueError ( '<STR_LIT>' . format ( type_names , name , repr ( value ) ) ) <EOL> if specification . constraint and not specification . constraint ( value ) : <EOL> raise ValueError ( '<STR_LIT>' . format ( name , repr ( value ) ) ) <EOL> return value <EOL> specification = namedtuple ( <EOL> b'<STR_LIT>' , ( <EOL> b'<STR_LIT:type>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ) ) <EOL> specification_matrix = { <EOL> '<STR_LIT>' : specification ( <EOL> type = bool , <EOL> constraint = None , <EOL> supporting_protocols = [ <NUM_LIT:1> ] ) , <EOL> '<STR_LIT>' : specification ( <EOL> type = bool , <EOL> constraint = None , <EOL> supporting_protocols = [ <NUM_LIT:2> ] ) , <EOL> '<STR_LIT>' : specification ( <EOL> type = bool , <EOL> constraint = None , <EOL> supporting_protocols = [ <NUM_LIT:1> ] ) , <EOL> '<STR_LIT>' : specification ( <EOL> type = bool , <EOL> constraint = None , <EOL> supporting_protocols = [ <NUM_LIT:1> , <NUM_LIT:2> ] ) , <EOL> '<STR_LIT>' : specification ( <EOL> type = bool , <EOL> constraint = None , <EOL> supporting_protocols = [ <NUM_LIT:1> ] ) , <EOL> '<STR_LIT>' : specification ( <EOL> type = int , <EOL> constraint = lambda value : <NUM_LIT:0> <= value <= sys . maxint , <EOL> supporting_protocols = [ <NUM_LIT:2> ] ) , <EOL> '<STR_LIT>' : specification ( <EOL> type = bool , <EOL> constraint = None , <EOL> supporting_protocols = [ <NUM_LIT:1> ] ) , <EOL> '<STR_LIT>' : specification ( <EOL> type = ( list , set , tuple ) , <EOL> constraint = None , <EOL> supporting_protocols = [ <NUM_LIT:1> , <NUM_LIT:2> ] ) , <EOL> '<STR_LIT>' : specification ( <EOL> type = bool , <EOL> constraint = None , <EOL> supporting_protocols = [ <NUM_LIT:1> ] ) , <EOL> '<STR_LIT>' : specification ( <EOL> type = bool , <EOL> constraint = None , <EOL> supporting_protocols = [ <NUM_LIT:1> ] ) , <EOL> '<STR_LIT>' : specification ( <EOL> type = bool , <EOL> constraint = None , <EOL> supporting_protocols = [ <NUM_LIT:2> ] ) , <EOL> '<STR_LIT>' : specification ( <EOL> type = bool , <EOL> constraint = None , <EOL> supporting_protocols = [ <NUM_LIT:1> ] ) , <EOL> '<STR_LIT>' : specification ( <EOL> type = ( bytes , unicode ) , <EOL> constraint = None , <EOL> supporting_protocols = [ <NUM_LIT:1> , <NUM_LIT:2> ] ) , <EOL> '<STR_LIT:type>' : specification ( <EOL> type = ( bytes , unicode ) , <EOL> constraint = lambda value : value in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> supporting_protocols = [ <NUM_LIT:2> ] ) } <EOL> class CsvDialect ( csv . Dialect ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> delimiter = b'<STR_LIT:U+002C>' <EOL> quotechar = b'<STR_LIT:\">' <EOL> doublequote = True <EOL> skipinitialspace = False <EOL> lineterminator = b'<STR_LIT:\\r\\n>' <EOL> quoting = csv . QUOTE_MINIMAL <EOL> class InputHeader ( dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT:\\n>' . join ( [ name + '<STR_LIT::>' + value for name , value in self . iteritems ( ) ] ) <EOL> def read ( self , ifile ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name , value = None , None <EOL> for line in ifile : <EOL> if line == '<STR_LIT:\\n>' : <EOL> break <EOL> item = line . split ( '<STR_LIT::>' , <NUM_LIT:1> ) <EOL> if len ( item ) == <NUM_LIT:2> : <EOL> if name is not None : <EOL> self [ name ] = value [ : - <NUM_LIT:1> ] <EOL> name , value = item [ <NUM_LIT:0> ] , unquote ( item [ <NUM_LIT:1> ] ) <EOL> elif name is not None : <EOL> value += unquote ( line ) <EOL> if name is not None : self [ name ] = value [ : - <NUM_LIT:1> ] if value [ - <NUM_LIT:1> ] == '<STR_LIT:\\n>' else value <EOL> Message = namedtuple ( b'<STR_LIT>' , ( b'<STR_LIT:type>' , b'<STR_LIT:text>' ) ) <EOL> class MetadataDecoder ( JSONDecoder ) : <EOL> def __init__ ( self ) : <EOL> JSONDecoder . __init__ ( self , object_hook = self . _object_hook ) <EOL> @ staticmethod <EOL> def _object_hook ( dictionary ) : <EOL> object_view = ObjectView ( dictionary ) <EOL> stack = deque ( ) <EOL> stack . append ( ( None , None , dictionary ) ) <EOL> while len ( stack ) : <EOL> instance , member_name , dictionary = stack . popleft ( ) <EOL> for name , value in dictionary . iteritems ( ) : <EOL> if isinstance ( value , dict ) : <EOL> stack . append ( ( dictionary , name , value ) ) <EOL> if instance is not None : <EOL> instance [ member_name ] = ObjectView ( dictionary ) <EOL> return object_view <EOL> class MetadataEncoder ( JSONEncoder ) : <EOL> def __init__ ( self ) : <EOL> JSONEncoder . __init__ ( self , separators = MetadataEncoder . _separators ) <EOL> def default ( self , o ) : <EOL> return o . __dict__ if isinstance ( o , ObjectView ) else JSONEncoder . default ( self , o ) <EOL> _separators = ( '<STR_LIT:U+002C>' , '<STR_LIT::>' ) <EOL> class ObjectView ( object ) : <EOL> def __init__ ( self , dictionary ) : <EOL> self . __dict__ = dictionary <EOL> def __repr__ ( self ) : <EOL> return repr ( self . __dict__ ) <EOL> def __str__ ( self ) : <EOL> return str ( self . __dict__ ) <EOL> class Recorder ( object ) : <EOL> def __init__ ( self , path , f ) : <EOL> self . _recording = gzip . open ( path + '<STR_LIT>' , '<STR_LIT:wb>' ) <EOL> self . _file = f <EOL> def __getattr__ ( self , name ) : <EOL> return getattr ( self . _file , name ) <EOL> def __iter__ ( self ) : <EOL> for line in self . _file : <EOL> self . _recording . write ( line ) <EOL> self . _recording . flush ( ) <EOL> yield line <EOL> def read ( self , size = None ) : <EOL> value = self . _file . read ( ) if size is None else self . _file . read ( size ) <EOL> self . _recording . write ( value ) <EOL> self . _recording . flush ( ) <EOL> return value <EOL> def readline ( self , size = None ) : <EOL> value = self . _file . readline ( ) if size is None else self . _file . readline ( size ) <EOL> if len ( value ) > <NUM_LIT:0> : <EOL> self . _recording . write ( value ) <EOL> self . _recording . flush ( ) <EOL> return value <EOL> def record ( self , * args ) : <EOL> for arg in args : <EOL> self . _recording . write ( arg ) <EOL> def write ( self , text ) : <EOL> self . _recording . write ( text ) <EOL> self . _file . write ( text ) <EOL> self . _recording . flush ( ) <EOL> class RecordWriter ( object ) : <EOL> def __init__ ( self , ofile , maxresultrows = None ) : <EOL> self . _maxresultrows = <NUM_LIT> if maxresultrows is None else maxresultrows <EOL> self . _ofile = ofile <EOL> self . _fieldnames = None <EOL> self . _buffer = StringIO ( ) <EOL> self . _writer = csv . writer ( self . _buffer , dialect = CsvDialect ) <EOL> self . _writerow = self . _writer . writerow <EOL> self . _finished = False <EOL> self . _flushed = False <EOL> self . _inspector = OrderedDict ( ) <EOL> self . _chunk_count = <NUM_LIT:0> <EOL> self . _record_count = <NUM_LIT:0> <EOL> self . _total_record_count = <NUM_LIT:0> L <EOL> @ property <EOL> def is_flushed ( self ) : <EOL> return self . _flushed <EOL> @ is_flushed . setter <EOL> def is_flushed ( self , value ) : <EOL> self . _flushed = True if value else False <EOL> @ property <EOL> def ofile ( self ) : <EOL> return self . _ofile <EOL> @ ofile . setter <EOL> def ofile ( self , value ) : <EOL> self . _ofile = value <EOL> def flush ( self , finished = None , partial = None ) : <EOL> assert finished is None or isinstance ( finished , bool ) <EOL> assert partial is None or isinstance ( partial , bool ) <EOL> assert not ( finished is None and partial is None ) <EOL> assert finished is None or partial is None <EOL> self . _ensure_validity ( ) <EOL> def write_message ( self , message_type , message_text , * args , ** kwargs ) : <EOL> self . _ensure_validity ( ) <EOL> self . _inspector . setdefault ( '<STR_LIT>' , [ ] ) . append ( ( message_type , message_text . format ( * args , ** kwargs ) ) ) <EOL> def write_record ( self , record ) : <EOL> self . _ensure_validity ( ) <EOL> self . _write_record ( record ) <EOL> def write_records ( self , records ) : <EOL> self . _ensure_validity ( ) <EOL> write_record = self . _write_record <EOL> for record in records : <EOL> write_record ( record ) <EOL> def _clear ( self ) : <EOL> self . _buffer . reset ( ) <EOL>", "answer": "self . _buffer . truncate ( )"}, {"prompt": "<s> import argparse <EOL> import dns . resolver <EOL> import dns . query <EOL> import dns . zone <EOL> import os <EOL> import sys <EOL> from multiprocessing import Pool <EOL> INPUTFILE = sys . stdin <EOL> OUTPUTFILE = sys . stdout <EOL> LOGFILE = sys . stderr <EOL> PROCESSES = <NUM_LIT:20> <EOL> def checkaxfr ( domain ) : <EOL> domain = domain . strip ( ) <EOL> try : <EOL> ns_query = dns . resolver . query ( domain , '<STR_LIT>' ) <EOL> for ns in ns_query . rrset : <EOL> nameserver = str ( ns ) [ : - <NUM_LIT:1> ] <EOL> if nameserver is None or nameserver == \"<STR_LIT>\" : <EOL> continue <EOL> try : <EOL> axfr = dns . query . xfr ( nameserver , domain , lifetime = <NUM_LIT:5> ) <EOL> try : <EOL> zone = dns . zone . from_xfr ( axfr ) <EOL> if zone is None : <EOL> continue <EOL> LOGFILE . write ( \"<STR_LIT>\" + domain + \"<STR_LIT>\" + nameserver + \"<STR_LIT:\\n>\" ) <EOL>", "answer": "LOGFILE . flush ( )"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import time , sys <EOL> import RPi . GPIO as GPIO <EOL> import smbus <EOL> DISPLAY_RGB_ADDR = <NUM_LIT> <EOL> DISPLAY_TEXT_ADDR = <NUM_LIT> <EOL> rev = GPIO . RPI_REVISION <EOL> if rev == <NUM_LIT:2> or rev == <NUM_LIT:3> : <EOL> bus = smbus . SMBus ( <NUM_LIT:1> ) <EOL> else : <EOL> bus = smbus . SMBus ( <NUM_LIT:0> ) <EOL> def setRGB ( r , g , b ) : <EOL> bus . write_byte_data ( DISPLAY_RGB_ADDR , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> bus . write_byte_data ( DISPLAY_RGB_ADDR , <NUM_LIT:1> , <NUM_LIT:0> ) <EOL> bus . write_byte_data ( DISPLAY_RGB_ADDR , <NUM_LIT> , <NUM_LIT> ) <EOL> bus . write_byte_data ( DISPLAY_RGB_ADDR , <NUM_LIT:4> , r ) <EOL> bus . write_byte_data ( DISPLAY_RGB_ADDR , <NUM_LIT:3> , g ) <EOL> bus . write_byte_data ( DISPLAY_RGB_ADDR , <NUM_LIT:2> , b ) <EOL> def textCommand ( cmd ) : <EOL> bus . write_byte_data ( DISPLAY_TEXT_ADDR , <NUM_LIT> , cmd ) <EOL> def setText ( text ) : <EOL> textCommand ( <NUM_LIT> ) <EOL> time . sleep ( <NUM_LIT> ) <EOL> textCommand ( <NUM_LIT> | <NUM_LIT> ) <EOL> textCommand ( <NUM_LIT> ) <EOL> time . sleep ( <NUM_LIT> ) <EOL> count = <NUM_LIT:0> <EOL> row = <NUM_LIT:0> <EOL> for c in text : <EOL> if c == '<STR_LIT:\\n>' or count == <NUM_LIT:16> : <EOL> count = <NUM_LIT:0> <EOL> row += <NUM_LIT:1> <EOL> if row == <NUM_LIT:2> : <EOL> break <EOL> textCommand ( <NUM_LIT> ) <EOL> if c == '<STR_LIT:\\n>' : <EOL> continue <EOL> count += <NUM_LIT:1> <EOL> bus . write_byte_data ( DISPLAY_TEXT_ADDR , <NUM_LIT> , ord ( c ) ) <EOL> def setText_norefresh ( text ) : <EOL> textCommand ( <NUM_LIT> ) <EOL> time . sleep ( <NUM_LIT> ) <EOL> textCommand ( <NUM_LIT> | <NUM_LIT> ) <EOL> textCommand ( <NUM_LIT> ) <EOL> time . sleep ( <NUM_LIT> ) <EOL> count = <NUM_LIT:0> <EOL> row = <NUM_LIT:0> <EOL> for c in text : <EOL> if c == '<STR_LIT:\\n>' or count == <NUM_LIT:16> : <EOL> count = <NUM_LIT:0> <EOL> row += <NUM_LIT:1> <EOL>", "answer": "if row == <NUM_LIT:2> :"}, {"prompt": "<s> import types <EOL> import sys <EOL> from org . sikuli . script import Screen as JScreen <EOL> from org . sikuli . basics import Debug <EOL> from Region import * <EOL> import Sikuli <EOL> class Screen ( Region ) : <EOL> def __init__ ( self , id = None ) : <EOL> try : <EOL> if id != None : <EOL> r = JScreen . getBounds ( id ) <EOL> s = JScreen . getScreen ( id ) <EOL> else : <EOL> id = JScreen . getPrimaryId ( ) <EOL>", "answer": "r = JScreen . getBounds ( id )"}, {"prompt": "<s> from __future__ import with_statement <EOL> import lockfile <EOL> import os <EOL> import random <EOL> import string <EOL> class FilePermissionError ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> def generate_key ( key_length = <NUM_LIT:64> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if hasattr ( random , '<STR_LIT>' ) : <EOL> choice = random . SystemRandom ( ) . choice <EOL> else : <EOL> choice = random . choice <EOL> return '<STR_LIT>' . join ( map ( lambda x : choice ( string . digits + string . letters ) , <EOL> range ( key_length ) ) ) <EOL> def generate_or_read_from_file ( key_file = '<STR_LIT>' , key_length = <NUM_LIT:64> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> lock = lockfile . FileLock ( key_file ) <EOL>", "answer": "with lock :"}, {"prompt": "<s> from collections import defaultdict <EOL> from sympy import Symbol <EOL> from sympy . core . compatibility import range <EOL> from sympy . ntheory import n_order , is_primitive_root , is_quad_residue , legendre_symbol , jacobi_symbol , totient , primerange , sqrt_mod , primitive_root , quadratic_residues , is_nthpow_residue , nthroot_mod , sqrt_mod_iter , mobius <EOL> from sympy . ntheory . residue_ntheory import _primitive_root_prime_iter <EOL> from sympy . polys . domains import ZZ <EOL> from sympy . utilities . pytest import raises <EOL> def test_residue ( ) : <EOL> assert n_order ( <NUM_LIT:2> , <NUM_LIT> ) == <NUM_LIT:12> <EOL> assert [ n_order ( a , <NUM_LIT:7> ) for a in range ( <NUM_LIT:1> , <NUM_LIT:7> ) ] == [ <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:6> , <NUM_LIT:3> , <NUM_LIT:6> , <NUM_LIT:2> ] <EOL> assert n_order ( <NUM_LIT:5> , <NUM_LIT> ) == <NUM_LIT:16> <EOL> assert n_order ( <NUM_LIT> , <NUM_LIT:11> ) == n_order ( <NUM_LIT:6> , <NUM_LIT:11> ) <EOL> assert n_order ( <NUM_LIT> , <NUM_LIT> ) == <NUM_LIT:6> <EOL> assert n_order ( <NUM_LIT:11> , ( <NUM_LIT:10> ** <NUM_LIT:50> + <NUM_LIT> ) ** <NUM_LIT:2> ) == <NUM_LIT> <EOL> raises ( ValueError , lambda : n_order ( <NUM_LIT:6> , <NUM_LIT:9> ) ) <EOL> assert is_primitive_root ( <NUM_LIT:2> , <NUM_LIT:7> ) is False <EOL> assert is_primitive_root ( <NUM_LIT:3> , <NUM_LIT:8> ) is False <EOL> assert is_primitive_root ( <NUM_LIT:11> , <NUM_LIT> ) is False <EOL> assert is_primitive_root ( <NUM_LIT:12> , <NUM_LIT> ) == is_primitive_root ( <NUM_LIT> , <NUM_LIT> ) <EOL> raises ( ValueError , lambda : is_primitive_root ( <NUM_LIT:3> , <NUM_LIT:6> ) ) <EOL> assert [ primitive_root ( i ) for i in range ( <NUM_LIT:2> , <NUM_LIT> ) ] == [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:5> , <NUM_LIT:3> , None , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> , None , <NUM_LIT:2> , <NUM_LIT:3> , None , None , <NUM_LIT:3> , <NUM_LIT:5> , <NUM_LIT:2> , None , None , <NUM_LIT:7> , <NUM_LIT:5> , None , <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:2> , None , <NUM_LIT:2> , None ] <EOL> for p in primerange ( <NUM_LIT:3> , <NUM_LIT:100> ) : <EOL> it = _primitive_root_prime_iter ( p ) <EOL> assert len ( list ( it ) ) == totient ( totient ( p ) ) <EOL> assert primitive_root ( <NUM_LIT> ) == <NUM_LIT:5> <EOL> assert primitive_root ( <NUM_LIT> ** <NUM_LIT:2> ) == <NUM_LIT:5> <EOL> assert primitive_root ( <NUM_LIT> ) == <NUM_LIT:5> <EOL> assert primitive_root ( <NUM_LIT> ** <NUM_LIT:2> ) == <NUM_LIT:10> <EOL> assert primitive_root ( <NUM_LIT> ) == <NUM_LIT:7> <EOL> p = <NUM_LIT:10> ** <NUM_LIT:50> + <NUM_LIT> <EOL> assert primitive_root ( p ) == <NUM_LIT:11> <EOL> assert primitive_root ( <NUM_LIT:2> * p ) == <NUM_LIT:11> <EOL> assert primitive_root ( p ** <NUM_LIT:2> ) == <NUM_LIT:11> <EOL> raises ( ValueError , lambda : primitive_root ( - <NUM_LIT:3> ) ) <EOL> assert is_quad_residue ( <NUM_LIT:3> , <NUM_LIT:7> ) is False <EOL> assert is_quad_residue ( <NUM_LIT:10> , <NUM_LIT> ) is True <EOL> assert is_quad_residue ( <NUM_LIT> , <NUM_LIT> ) == is_quad_residue ( <NUM_LIT> % <NUM_LIT> , <NUM_LIT> ) <EOL> assert is_quad_residue ( <NUM_LIT> , <NUM_LIT> ) is True <EOL> assert is_quad_residue ( <NUM_LIT:0> , <NUM_LIT:1> ) is True <EOL> assert is_quad_residue ( <NUM_LIT:1> , <NUM_LIT:1> ) is True <EOL> assert is_quad_residue ( <NUM_LIT:0> , <NUM_LIT:2> ) == is_quad_residue ( <NUM_LIT:1> , <NUM_LIT:2> ) is True <EOL> assert is_quad_residue ( <NUM_LIT:1> , <NUM_LIT:4> ) is True <EOL> assert is_quad_residue ( <NUM_LIT:2> , <NUM_LIT> ) is False <EOL> assert is_quad_residue ( <NUM_LIT> , <NUM_LIT> ) is True <EOL> assert [ j for j in range ( <NUM_LIT> ) if is_quad_residue ( j , <NUM_LIT> ) ] == [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:7> , <NUM_LIT:8> , <NUM_LIT:9> , <NUM_LIT:11> ] <EOL> raises ( ValueError , lambda : is_quad_residue ( <NUM_LIT> , <NUM_LIT:2> ) ) <EOL> raises ( ValueError , lambda : is_quad_residue ( <NUM_LIT:2> , <NUM_LIT:0> ) ) <EOL> assert quadratic_residues ( <NUM_LIT:12> ) == [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:4> , <NUM_LIT:9> ] <EOL> assert quadratic_residues ( <NUM_LIT> ) == [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:9> , <NUM_LIT:10> , <NUM_LIT:12> ] <EOL> assert [ len ( quadratic_residues ( i ) ) for i in range ( <NUM_LIT:1> , <NUM_LIT:20> ) ] == [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:4> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:6> , <NUM_LIT:6> , <NUM_LIT:4> , <NUM_LIT:7> , <NUM_LIT:8> , <NUM_LIT:6> , <NUM_LIT:4> , <NUM_LIT:9> , <NUM_LIT:8> , <NUM_LIT:10> ] <EOL> assert list ( sqrt_mod_iter ( <NUM_LIT:6> , <NUM_LIT:2> ) ) == [ <NUM_LIT:0> ] <EOL> assert sqrt_mod ( <NUM_LIT:3> , <NUM_LIT> ) == <NUM_LIT:4> <EOL> assert sqrt_mod ( <NUM_LIT:3> , - <NUM_LIT> ) == <NUM_LIT:4> <EOL> assert sqrt_mod ( <NUM_LIT:6> , <NUM_LIT> ) == <NUM_LIT:11> <EOL> assert sqrt_mod ( <NUM_LIT> , <NUM_LIT> ) == <NUM_LIT> <EOL> for p in range ( <NUM_LIT:3> , <NUM_LIT:100> ) : <EOL> d = defaultdict ( list ) <EOL> for i in range ( p ) : <EOL> d [ pow ( i , <NUM_LIT:2> , p ) ] . append ( i ) <EOL> for i in range ( <NUM_LIT:1> , p ) : <EOL> it = sqrt_mod_iter ( i , p ) <EOL> v = sqrt_mod ( i , p , True ) <EOL> if v : <EOL> v = sorted ( v ) <EOL> assert d [ i ] == v <EOL> else : <EOL> assert not d [ i ] <EOL> assert sqrt_mod ( <NUM_LIT:9> , <NUM_LIT> , True ) == [ <NUM_LIT:3> , <NUM_LIT:6> , <NUM_LIT:12> , <NUM_LIT:15> , <NUM_LIT> , <NUM_LIT> ] <EOL> assert sqrt_mod ( <NUM_LIT:9> , <NUM_LIT> , True ) == [ <NUM_LIT:3> , <NUM_LIT> , <NUM_LIT:30> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> assert sqrt_mod ( <NUM_LIT:9> , <NUM_LIT:3> ** <NUM_LIT:5> , True ) == [ <NUM_LIT:3> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> assert sqrt_mod ( <NUM_LIT> , <NUM_LIT:3> ** <NUM_LIT:4> , True ) == [ <NUM_LIT:0> , <NUM_LIT:9> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> assert sqrt_mod ( <NUM_LIT> , <NUM_LIT:3> ** <NUM_LIT:5> , True ) == [ <NUM_LIT:9> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> assert sqrt_mod ( <NUM_LIT> , <NUM_LIT:3> ** <NUM_LIT:6> , True ) == [ <NUM_LIT:9> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> assert sqrt_mod ( <NUM_LIT> , <NUM_LIT:3> ** <NUM_LIT:7> , True ) == [ <NUM_LIT:9> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> for a , p in [ ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) ] : <EOL> assert pow ( sqrt_mod ( a , p ) , <NUM_LIT:2> , p ) == a <EOL> n = <NUM_LIT> <EOL> a , p = <NUM_LIT:5> ** <NUM_LIT:2> * <NUM_LIT:3> ** n * <NUM_LIT:2> ** n , <NUM_LIT:5> ** <NUM_LIT:6> * <NUM_LIT:3> ** ( n + <NUM_LIT:1> ) * <NUM_LIT:2> ** ( n + <NUM_LIT:2> ) <EOL> it = sqrt_mod_iter ( a , p ) <EOL> for i in range ( <NUM_LIT:10> ) : <EOL>", "answer": "assert pow ( next ( it ) , <NUM_LIT:2> , p ) == a"}, {"prompt": "<s> from __future__ import absolute_import , unicode_literals <EOL>", "answer": "from django_services . api import DjangoServiceAPI , register"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , division , print_function <EOL> import itertools <EOL> import json <EOL> from collections import OrderedDict , defaultdict <EOL> from copy import copy <EOL> from math import cos , sin <EOL> from colorsys import hsv_to_rgb <EOL> from pandas . io . json import json_normalize <EOL> import pandas as pd <EOL> import numpy as np <EOL> from six import iteritems <EOL> from . . models . glyphs import ( <EOL> Asterisk , Circle , CircleCross , CircleX , Cross , Diamond , DiamondCross , <EOL> InvertedTriangle , Square , SquareCross , SquareX , Triangle , X ) <EOL> from . . models . sources import ColumnDataSource <EOL> from . . plotting . helpers import DEFAULT_PALETTE <EOL> DEFAULT_COLUMN_NAMES = '<STR_LIT>' <EOL> marker_types = OrderedDict ( <EOL> [ <EOL> ( \"<STR_LIT>\" , Circle ) , <EOL> ( \"<STR_LIT>\" , Square ) , <EOL> ( \"<STR_LIT>\" , Triangle ) , <EOL> ( \"<STR_LIT>\" , Diamond ) , <EOL> ( \"<STR_LIT>\" , InvertedTriangle ) , <EOL> ( \"<STR_LIT>\" , Asterisk ) , <EOL> ( \"<STR_LIT>\" , Cross ) , <EOL> ( \"<STR_LIT:x>\" , X ) , <EOL> ( \"<STR_LIT>\" , CircleCross ) , <EOL> ( \"<STR_LIT>\" , CircleX ) , <EOL> ( \"<STR_LIT>\" , SquareX ) , <EOL> ( \"<STR_LIT>\" , SquareCross ) , <EOL> ( \"<STR_LIT>\" , DiamondCross ) , <EOL> ] <EOL> ) <EOL> def take ( n , iterable ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return itertools . islice ( iterable , n ) <EOL> def cycle_colors ( chunk , palette = DEFAULT_PALETTE ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> colors = [ ] <EOL> g = itertools . cycle ( palette ) <EOL> for i in range ( len ( chunk ) ) : <EOL> colors . append ( next ( g ) ) <EOL> return colors <EOL> def polar_to_cartesian ( r , start_angles , end_angles ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cartesian = lambda r , alpha : ( r * cos ( alpha ) , r * sin ( alpha ) ) <EOL> points = [ ] <EOL> for r , start , end in zip ( r , start_angles , end_angles ) : <EOL> points . append ( cartesian ( r , ( end + start ) / <NUM_LIT:2> ) ) <EOL> return zip ( * points ) <EOL> def ordered_set ( iterable ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> mmap = { } <EOL> ord_set = [ ] <EOL> for item in iterable : <EOL> if item not in mmap : <EOL> mmap [ item ] = <NUM_LIT:1> <EOL> ord_set . append ( item ) <EOL> return ord_set <EOL> def collect_attribute_columns ( ** specs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> selected_specs = { spec_name : spec for spec_name , spec in iteritems ( specs ) <EOL> if spec . columns } <EOL> spec_cols = list ( itertools . chain . from_iterable ( [ spec . columns <EOL> for spec in selected_specs . values ( ) ] ) ) <EOL> return ordered_set ( spec_cols ) <EOL> def df_from_json ( data , rename = True , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> parsed = None <EOL> if isinstance ( data , str ) : <EOL> with open ( data ) as data_file : <EOL> data = json . load ( data_file ) <EOL> if isinstance ( data , list ) : <EOL> parsed = json_normalize ( data ) <EOL> elif isinstance ( data , dict ) : <EOL> for k , v in iteritems ( data ) : <EOL> if isinstance ( v , list ) : <EOL> parsed = json_normalize ( v ) <EOL> if rename and parsed is not None : <EOL> parsed = denormalize_column_names ( parsed ) <EOL> return parsed <EOL> def denormalize_column_names ( parsed_data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cols = parsed_data . columns . tolist ( ) <EOL> base_columns = defaultdict ( list ) <EOL> for col in cols : <EOL> if '<STR_LIT:.>' in col : <EOL> base_columns [ col ] . append ( col . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] ) <EOL> rename = { } <EOL> for col , new_cols in iteritems ( base_columns ) : <EOL> if len ( new_cols ) == <NUM_LIT:1> : <EOL> rename [ col ] = new_cols [ <NUM_LIT:0> ] <EOL> if len ( list ( rename . keys ( ) ) ) > <NUM_LIT:0> : <EOL> return parsed_data . rename ( columns = rename ) <EOL> else : <EOL> return parsed_data <EOL> def get_index ( data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return data . index <EOL> def get_unity ( data , value = <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> data_copy = data . copy ( ) <EOL> data_copy [ '<STR_LIT>' ] = value <EOL> return data_copy [ '<STR_LIT>' ] <EOL> special_columns = { '<STR_LIT:index>' : get_index , <EOL> '<STR_LIT>' : get_unity } <EOL> def title_from_columns ( cols ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if cols is not None : <EOL> cols_title = copy ( cols ) <EOL> if not isinstance ( cols_title , list ) : <EOL> cols_title = [ cols_title ] <EOL> return str ( '<STR_LIT:U+002CU+0020>' . join ( cols_title ) . title ( ) ) . title ( ) <EOL> else : <EOL> return None <EOL> def gen_column_names ( n ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> col_names = list ( DEFAULT_COLUMN_NAMES ) <EOL> if n < len ( col_names ) : <EOL> return list ( take ( n , col_names ) ) <EOL> else : <EOL> n_left = n - len ( col_names ) <EOL> labels = [ '<STR_LIT>' . join ( item ) for item in <EOL> take ( n_left , itertools . product ( DEFAULT_COLUMN_NAMES , <EOL> DEFAULT_COLUMN_NAMES ) ) ] <EOL> col_names . extend ( labels ) <EOL> return col_names <EOL> def generate_patch_base ( x , y , base = <NUM_LIT:0.0> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> x = x . values <EOL> y = y . values <EOL> y0 = np . insert ( y , <NUM_LIT:0> , base ) <EOL> y0 = np . append ( y0 , base ) <EOL> x0 = np . insert ( x , <NUM_LIT:0> , x [ <NUM_LIT:0> ] ) <EOL> x0 = np . append ( x0 , x0 [ - <NUM_LIT:1> ] ) <EOL> return x0 , y0 <EOL> class ChartHelp ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , * builders ) : <EOL> self . builders = builders <EOL> def __repr__ ( self ) : <EOL> help_str = '<STR_LIT>' <EOL> for builder in self . builders : <EOL> help_str += builder . generate_help ( ) <EOL> return help_str <EOL> def help ( * builders ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def add_help ( f ) : <EOL> f . help = ChartHelp ( * builders ) <EOL> return f <EOL> return add_help <EOL> def derive_aggregation ( dim_cols , agg_col , agg ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if dim_cols == '<STR_LIT:index>' or agg_col == '<STR_LIT:index>' or dim_cols == None : <EOL> agg = None <EOL> agg_col = None <EOL> elif agg_col is None : <EOL> if isinstance ( dim_cols , list ) : <EOL> agg_col = dim_cols [ <NUM_LIT:0> ] <EOL> else : <EOL> agg_col = dim_cols <EOL> agg = '<STR_LIT:count>' <EOL> return agg_col , agg <EOL> def build_wedge_source ( df , cat_cols , agg_col = None , agg = '<STR_LIT>' , level_width = <NUM_LIT:0.5> , <EOL> level_spacing = <NUM_LIT> ) : <EOL> df = cat_to_polar ( df , cat_cols , agg_col , agg , level_width ) <EOL> add_wedge_spacing ( df , level_spacing ) <EOL> df [ '<STR_LIT>' ] = df [ '<STR_LIT>' ] - ( df [ '<STR_LIT>' ] - df [ '<STR_LIT>' ] ) / <NUM_LIT> <EOL> if not isinstance ( level_spacing , list ) : <EOL> df . ix [ df [ '<STR_LIT>' ] == <NUM_LIT:0> , '<STR_LIT>' ] *= <NUM_LIT> <EOL> return df <EOL> def shift_series ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> s0 = s . copy ( ) <EOL> s0 = s0 . shift ( <NUM_LIT:1> ) <EOL> s0 . iloc [ <NUM_LIT:0> ] = <NUM_LIT:0.0> <EOL> return s0 <EOL> def _create_start_end ( levels ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rads = levels [ <NUM_LIT:0> ] . copy ( ) <EOL> for level in levels [ <NUM_LIT:1> : ] : <EOL> rads = rads * level <EOL> rads *= ( <NUM_LIT:2> * np . pi ) <EOL> end = rads . cumsum ( ) <EOL> start = shift_series ( end ) <EOL> return start , end <EOL> def cat_to_polar ( df , cat_cols , agg_col = None , agg = '<STR_LIT>' , level_width = <NUM_LIT:0.5> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> agg_col , agg = derive_aggregation ( cat_cols , agg_col , agg ) <EOL> def calc_span_proportion ( data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return data / data . sum ( ) <EOL> levels_cols = [ ] <EOL> starts = [ ] <EOL> ends = [ ] <EOL> levels = [ ] <EOL> agg_values = [ ] <EOL> for i in range ( <NUM_LIT:0> , len ( cat_cols ) ) : <EOL> level_cols = cat_cols [ : i + <NUM_LIT:1> ] <EOL>", "answer": "if agg_col is not None and agg is not None :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import tempfile <EOL> from googleads import dfp <EOL> from googleads import errors <EOL> def main ( client ) : <EOL> report_downloader = client . GetDataDownloader ( version = '<STR_LIT>' ) <EOL> report_job = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } <EOL> try : <EOL> report_job_id = report_downloader . WaitForReport ( report_job ) <EOL> except errors . DfpReportError , e : <EOL> print '<STR_LIT>' % e <EOL> export_format = '<STR_LIT>' <EOL> report_file = tempfile . NamedTemporaryFile ( suffix = '<STR_LIT>' , delete = False ) <EOL> report_downloader . DownloadReportToFile ( <EOL> report_job_id , export_format , report_file ) <EOL> report_file . close ( ) <EOL> print '<STR_LIT>' % ( <EOL> report_job_id , report_file . name ) <EOL>", "answer": "if __name__ == '<STR_LIT:__main__>' :"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from __future__ import absolute_import <EOL> import hashlib <EOL> import random <EOL> import salt . utils . pycrypto <EOL> from salt . exceptions import SaltInvocationError <EOL> __virtualname__ = '<STR_LIT>' <EOL> def __virtual__ ( algorithm = '<STR_LIT>' ) : <EOL> '''<STR_LIT>''' <EOL> if not hasattr ( hashlib , '<STR_LIT>' ) and not hasattr ( hashlib , algorithm ) : <EOL> return ( False , '<STR_LIT>' ) <EOL> return __virtualname__ <EOL> def hash ( value , algorithm = '<STR_LIT>' ) : <EOL> '''<STR_LIT>''' <EOL> if hasattr ( hashlib , '<STR_LIT>' ) and algorithm in hashlib . algorithms : <EOL> hasher = hashlib . new ( algorithm ) <EOL> hasher . update ( value ) <EOL> out = hasher . hexdigest ( ) <EOL> elif hasattr ( hashlib , algorithm ) : <EOL> hasher = hashlib . new ( algorithm ) <EOL> hasher . update ( value ) <EOL> out = hasher . hexdigest ( ) <EOL> else : <EOL> raise SaltInvocationError ( '<STR_LIT>' ) <EOL> return out <EOL> def str_encode ( value , encoder = '<STR_LIT>' ) : <EOL> '''<STR_LIT>''' <EOL> try : <EOL> out = value . encode ( encoder ) <EOL> except LookupError : <EOL> raise SaltInvocationError ( '<STR_LIT>' ) <EOL> except AttributeError : <EOL> raise SaltInvocationError ( '<STR_LIT>' ) <EOL> return out <EOL> def get_str ( length = <NUM_LIT:20> ) : <EOL> '''<STR_LIT>''' <EOL> return salt . utils . pycrypto . secure_password ( length ) <EOL> def shadow_hash ( crypt_salt = None , password = None , algorithm = '<STR_LIT>' ) : <EOL> '''<STR_LIT>''' <EOL> return salt . utils . pycrypto . gen_hash ( crypt_salt , password , algorithm ) <EOL> def rand_int ( start = <NUM_LIT:1> , end = <NUM_LIT:10> ) : <EOL> '''<STR_LIT>''' <EOL> return random . randint ( start , end ) <EOL>", "answer": "def seed ( range = <NUM_LIT:10> , hash = None ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import math <EOL> import pyglet <EOL> from pyglet . gl import * <EOL> import ctypes <EOL> from noise . shader_noise import ShaderNoiseTexture , shader_noise_glsl <EOL> from noise import shader <EOL> vert_shader = shader . VertexShader ( '<STR_LIT>' , '''<STR_LIT>''' ) <EOL> atmosphere_frag_shader = shader . FragmentShader ( '<STR_LIT>' , shader_noise_glsl + '''<STR_LIT>''' ) <EOL> atmosphere_prog = shader . ShaderProgram ( vert_shader , atmosphere_frag_shader ) <EOL> atmosphere_prog . install ( ) <EOL> atmosphere_prog . uset1F ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import sys <EOL> global xrot , yrot , d <EOL> win = pyglet . window . Window ( width = <NUM_LIT> , height = <NUM_LIT> , resizable = True , visible = False , <EOL> config = pyglet . gl . Config ( sample_buffers = <NUM_LIT:1> , samples = <NUM_LIT:4> , double_buffer = True , depth_size = <NUM_LIT> ) ) <EOL> glEnable ( GL_LIGHTING ) <EOL> glEnable ( GL_LIGHT0 ) <EOL> fourfv = ctypes . c_float * <NUM_LIT:4> <EOL> glLightfv ( GL_LIGHT0 , GL_POSITION , fourfv ( <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1.0> , <NUM_LIT:0.5> ) ) <EOL>", "answer": "glLightfv ( GL_LIGHT0 , GL_AMBIENT , fourfv ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:1.0> ) )"}, {"prompt": "<s> from functools import wraps <EOL> try : <EOL> from rospy . core import get_node_uri <EOL> except ImportError : <EOL> print ( '<STR_LIT>' ) <EOL> exit ( <NUM_LIT:1> ) <EOL> def decorator_has_connection ( f ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ wraps ( f ) <EOL> def wrapper ( self , endpoint_id ) : <EOL> if endpoint_id == get_node_uri ( ) : <EOL>", "answer": "return True"}, {"prompt": "<s> import smtplib <EOL> import os <EOL> from email . mime . multipart import MIMEMultipart <EOL> from email . mime . base import MIMEBase <EOL>", "answer": "from email . mime . text import MIMEText"}, {"prompt": "<s> from unittest import TestCase <EOL> from mock import Mock <EOL> import os <EOL> from subprocess import Popen , PIPE , check_call <EOL> from shutil import rmtree <EOL> from StringIO import StringIO <EOL> from tempfile import mkdtemp <EOL> from citools . version import ( <EOL> compute_version , get_git_describe , replace_version , compute_meta_version , <EOL> sum_versions , fetch_repository , <EOL> get_highest_tag , get_tags_from_line , <EOL> get_branch_suffix , <EOL> ) <EOL> class TestVersioning ( TestCase ) : <EOL> def test_after_tag ( self ) : <EOL> self . assertEquals ( ( <NUM_LIT:0> , <NUM_LIT:7> , <NUM_LIT:20> ) , compute_version ( '<STR_LIT>' ) ) <EOL> def test_after_tag_without_name ( self ) : <EOL> self . assertEquals ( ( <NUM_LIT:0> , <NUM_LIT:7> , <NUM_LIT:20> ) , compute_version ( '<STR_LIT>' ) ) <EOL> def test_after_tag_with_project_suffix ( self ) : <EOL> self . assertEquals ( ( <NUM_LIT:0> , <NUM_LIT:7> , <NUM_LIT:20> ) , compute_version ( '<STR_LIT>' ) ) <EOL> def test_on_tag ( self ) : <EOL> self . assertEquals ( ( <NUM_LIT:0> , <NUM_LIT:7> , <NUM_LIT:0> ) , compute_version ( '<STR_LIT>' ) ) <EOL> def test_on_tag_with_suffix ( self ) : <EOL> self . assertEquals ( ( <NUM_LIT:0> , <NUM_LIT:7> , <NUM_LIT:0> ) , compute_version ( '<STR_LIT>' ) ) <EOL> def test_after_tag_twodigit ( self ) : <EOL> self . assertEquals ( ( <NUM_LIT> , <NUM_LIT:7> , <NUM_LIT:20> ) , compute_version ( '<STR_LIT>' ) ) <EOL> def test_first_release_tag ( self ) : <EOL> self . assertEquals ( ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> ) , compute_version ( '<STR_LIT>' ) ) <EOL> def test_bad_release_tag ( self ) : <EOL> self . assertRaises ( ValueError , compute_version , '<STR_LIT>' ) <EOL> def test_on_tag_with_suffix_four_digits ( self ) : <EOL> self . assertEquals ( ( <NUM_LIT:0> , <NUM_LIT:7> , <NUM_LIT:3> , <NUM_LIT:0> ) , compute_version ( '<STR_LIT>' ) ) <EOL> def test_project_with_digit_in_name ( self ) : <EOL> self . assertEquals ( ( <NUM_LIT:9> , <NUM_LIT:7> , <NUM_LIT:3> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:11> , <NUM_LIT> ) , compute_version ( '<STR_LIT>' ) ) <EOL> def test_multiple_digit_versin ( self ) : <EOL> self . assertEquals ( ( <NUM_LIT:0> , <NUM_LIT:10> , <NUM_LIT:2> ) , compute_version ( '<STR_LIT>' ) ) <EOL> def test_version_replacing_three_digits ( self ) : <EOL> source = StringIO ( \"\"\"<STR_LIT>\"\"\" ) <EOL> expected_output = \"\"\"<STR_LIT>\"\"\" <EOL> self . assertEquals ( expected_output , '<STR_LIT>' . join ( replace_version ( source , version = ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> ) ) ) ) <EOL> def test_version_replacing_lot_digits ( self ) : <EOL> source = StringIO ( \"\"\"<STR_LIT>\"\"\" ) <EOL> expected_output = \"\"\"<STR_LIT>\"\"\" <EOL> self . assertEquals ( expected_output , '<STR_LIT>' . join ( replace_version ( source , version = ( <NUM_LIT:9> , <NUM_LIT:7> , <NUM_LIT:3> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:11> , <NUM_LIT> ) ) ) ) <EOL> class TestGitVersionRetrieving ( TestCase ) : <EOL> def setUp ( self ) : <EOL> TestCase . setUp ( self ) <EOL> self . repo = mkdtemp ( prefix = '<STR_LIT>' ) <EOL> self . oldcwd = os . getcwd ( ) <EOL> os . chdir ( self . repo ) <EOL> proc = Popen ( [ '<STR_LIT>' , '<STR_LIT>' ] , stdout = PIPE , stdin = PIPE ) <EOL> proc . wait ( ) <EOL> self . assertEquals ( <NUM_LIT:0> , proc . returncode ) <EOL> proc = Popen ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> proc . wait ( ) <EOL> self . assertEquals ( <NUM_LIT:0> , proc . returncode ) <EOL> proc = Popen ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> proc . wait ( ) <EOL> self . assertEquals ( <NUM_LIT:0> , proc . returncode ) <EOL> def prepare_tagged_repo_with_file ( self , tag ) : <EOL> f = open ( os . path . join ( self . repo , '<STR_LIT>' ) , '<STR_LIT:wb>' ) <EOL> f . write ( \"<STR_LIT:test>\" ) <EOL> f . close ( ) <EOL> proc = Popen ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:*>\" ] ) <EOL> proc . wait ( ) <EOL> self . assertEquals ( <NUM_LIT:0> , proc . returncode ) <EOL> proc = Popen ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , stdout = PIPE , stdin = PIPE ) <EOL> proc . wait ( ) <EOL> self . assertEquals ( <NUM_LIT:0> , proc . returncode ) <EOL> proc = Popen ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , tag ] , stdout = PIPE , stdin = PIPE ) <EOL> proc . wait ( ) <EOL> self . assertEquals ( <NUM_LIT:0> , proc . returncode ) <EOL> def test_without_tag ( self ) : <EOL> self . assertEquals ( '<STR_LIT>' , get_git_describe ( ) ) <EOL> def test_tag_retrieved ( self ) : <EOL> self . prepare_tagged_repo_with_file ( tag = '<STR_LIT>' ) <EOL> self . assertEquals ( '<STR_LIT>' , get_git_describe ( ) ) <EOL> def test_number_of_commit_since_tag ( self ) : <EOL> self . prepare_tagged_repo_with_file ( tag = '<STR_LIT>' ) <EOL> f = open ( os . path . join ( self . repo , '<STR_LIT>' ) , '<STR_LIT:wb>' ) <EOL> f . write ( \"<STR_LIT>\" ) <EOL> f . close ( ) <EOL> proc = Popen ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:*>' ] ) <EOL> proc . wait ( ) <EOL> self . assertEquals ( <NUM_LIT:0> , proc . returncode ) <EOL> proc = Popen ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , stdout = PIPE , stdin = PIPE ) <EOL>", "answer": "proc . wait ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import py <EOL> from py . __ . execnet . gwmanage import GatewayManager , HostRSync <EOL> class TestGatewayManagerPopen : <EOL> def test_popen_no_default_chdir ( self ) : <EOL> gm = GatewayManager ( [ \"<STR_LIT>\" ] ) <EOL> assert gm . specs [ <NUM_LIT:0> ] . chdir is None <EOL> def test_default_chdir ( self ) : <EOL> l = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> for spec in GatewayManager ( l ) . specs : <EOL> assert spec . chdir == \"<STR_LIT>\" <EOL> for spec in GatewayManager ( l , defaultchdir = \"<STR_LIT:abc>\" ) . specs : <EOL> assert spec . chdir == \"<STR_LIT:abc>\" <EOL> def test_popen_makegateway_events ( self , _pytest ) : <EOL> rec = _pytest . gethookrecorder ( py . execnet . _HookSpecs ) <EOL> hm = GatewayManager ( [ \"<STR_LIT>\" ] * <NUM_LIT:2> ) <EOL> hm . makegateways ( ) <EOL> call = rec . popcall ( \"<STR_LIT>\" ) <EOL> assert call . gateway . id == \"<STR_LIT>\" <EOL> assert call . platinfo . executable == call . gateway . _rinfo ( ) . executable <EOL> call = rec . popcall ( \"<STR_LIT>\" ) <EOL> assert call . gateway . id == \"<STR_LIT>\" <EOL> assert len ( hm . gateways ) == <NUM_LIT:2> <EOL> hm . exit ( ) <EOL> assert not len ( hm . gateways ) <EOL> def test_popens_rsync ( self , mysetup ) : <EOL> source = mysetup . source <EOL> hm = GatewayManager ( [ \"<STR_LIT>\" ] * <NUM_LIT:2> ) <EOL> hm . makegateways ( ) <EOL> assert len ( hm . gateways ) == <NUM_LIT:2> <EOL> for gw in hm . gateways : <EOL> gw . remote_exec = None <EOL> l = [ ] <EOL> hm . rsync ( source , notify = lambda * args : l . append ( args ) ) <EOL> assert not l <EOL> hm . exit ( ) <EOL> assert not len ( hm . gateways ) <EOL> def test_rsync_popen_with_path ( self , mysetup ) : <EOL> source , dest = mysetup . source , mysetup . dest <EOL> hm = GatewayManager ( [ \"<STR_LIT>\" % dest ] * <NUM_LIT:1> ) <EOL> hm . makegateways ( ) <EOL> source . ensure ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:hello>\" ) <EOL> l = [ ] <EOL> hm . rsync ( source , notify = lambda * args : l . append ( args ) ) <EOL> assert len ( l ) == <NUM_LIT:1> <EOL> assert l [ <NUM_LIT:0> ] == ( \"<STR_LIT>\" , hm . gateways [ <NUM_LIT:0> ] . spec , source ) <EOL> hm . exit ( ) <EOL> dest = dest . join ( source . basename ) <EOL> assert dest . join ( \"<STR_LIT>\" ) . check ( ) <EOL> assert dest . join ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . check ( ) <EOL> assert dest . join ( \"<STR_LIT>\" , \"<STR_LIT>\" , '<STR_LIT:hello>' ) . check ( ) <EOL> def test_hostmanage_rsync_same_popen_twice ( self , mysetup , _pytest ) : <EOL> source , dest = mysetup . source , mysetup . dest <EOL> rec = _pytest . gethookrecorder ( py . execnet . _HookSpecs ) <EOL> hm = GatewayManager ( [ \"<STR_LIT>\" % dest ] * <NUM_LIT:2> ) <EOL> hm . makegateways ( ) <EOL> source . ensure ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:hello>\" ) <EOL> hm . rsync ( source ) <EOL> call = rec . popcall ( \"<STR_LIT>\" ) <EOL> assert call . source == source <EOL> assert len ( call . gateways ) == <NUM_LIT:1> <EOL> assert hm . gateways [ <NUM_LIT:0> ] == call . gateways [ <NUM_LIT:0> ] <EOL> call = rec . popcall ( \"<STR_LIT>\" ) <EOL> def test_multi_chdir_popen_with_path ( self , testdir ) : <EOL> import os <EOL> hm = GatewayManager ( [ \"<STR_LIT>\" ] * <NUM_LIT:2> ) <EOL> testdir . tmpdir . chdir ( ) <EOL> hellopath = testdir . tmpdir . mkdir ( \"<STR_LIT:hello>\" ) . realpath ( ) <EOL> hm . makegateways ( ) <EOL> l = hm . multi_exec ( \"<STR_LIT>\" ) . receive_each ( ) <EOL> paths = [ x [ <NUM_LIT:1> ] for x in l ] <EOL> assert l == [ str ( hellopath ) ] * <NUM_LIT:2> <EOL> py . test . raises ( hm . RemoteError , '<STR_LIT>' ) <EOL> worldpath = hellopath . mkdir ( \"<STR_LIT>\" ) <EOL> hm . multi_chdir ( \"<STR_LIT>\" , inplacelocal = False ) <EOL> l = hm . multi_exec ( \"<STR_LIT>\" ) . receive_each ( ) <EOL> assert len ( l ) == <NUM_LIT:2> <EOL> assert l [ <NUM_LIT:0> ] == l [ <NUM_LIT:1> ] <EOL> curwd = os . getcwd ( ) <EOL>", "answer": "assert l [ <NUM_LIT:0> ] . startswith ( curwd )"}, {"prompt": "<s> from django . conf . urls import url <EOL> from django . views import defaults <EOL>", "answer": "from openstack_dashboard . urls import urlpatterns"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models <EOL> from django . core . urlresolvers import reverse <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AbstractUser <EOL> from . . core . utils . timezone import TIMEZONE_CHOICES <EOL> from . . core . utils . models import AutoSlugField <EOL> class UserProfile ( models . Model ) : <EOL> user = models . OneToOneField ( settings . AUTH_USER_MODEL , verbose_name = _ ( \"<STR_LIT>\" ) , related_name = '<STR_LIT>' ) <EOL> slug = AutoSlugField ( populate_from = \"<STR_LIT>\" , db_index = False , blank = True ) <EOL> location = models . CharField ( _ ( \"<STR_LIT:location>\" ) , max_length = <NUM_LIT> , blank = True ) <EOL> last_seen = models . DateTimeField ( _ ( \"<STR_LIT>\" ) , auto_now = True ) <EOL> last_ip = models . GenericIPAddressField ( _ ( \"<STR_LIT>\" ) , blank = True , null = True ) <EOL> timezone = models . CharField ( _ ( \"<STR_LIT>\" ) , max_length = <NUM_LIT:32> , choices = TIMEZONE_CHOICES , default = '<STR_LIT>' ) <EOL> is_administrator = models . BooleanField ( _ ( '<STR_LIT>' ) , default = False ) <EOL> is_moderator = models . BooleanField ( _ ( '<STR_LIT>' ) , default = False ) <EOL> is_verified = models . BooleanField ( _ ( '<STR_LIT>' ) , default = False , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) ) <EOL> topic_count = models . PositiveIntegerField ( _ ( \"<STR_LIT>\" ) , default = <NUM_LIT:0> ) <EOL> comment_count = models . PositiveIntegerField ( _ ( \"<STR_LIT>\" ) , default = <NUM_LIT:0> ) <EOL> class Meta : <EOL> verbose_name = _ ( \"<STR_LIT>\" ) <EOL> verbose_name_plural = _ ( \"<STR_LIT>\" ) <EOL> def save ( self , * args , ** kwargs ) : <EOL> if self . user . is_superuser : <EOL> self . is_administrator = True <EOL> if self . is_administrator : <EOL> self . is_moderator = True <EOL> super ( UserProfile , self ) . save ( * args , ** kwargs ) <EOL> def get_absolute_url ( self ) : <EOL> return reverse ( '<STR_LIT>' , kwargs = { '<STR_LIT>' : self . user . pk , '<STR_LIT>' : self . slug } ) <EOL> class User ( AbstractUser ) : <EOL> class Meta ( AbstractUser . Meta ) : <EOL> swappable = '<STR_LIT>' <EOL> ordering = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> verbose_name = _ ( '<STR_LIT:user>' ) <EOL>", "answer": "verbose_name_plural = _ ( '<STR_LIT>' )"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Static ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> import numpy as np <EOL> import theano <EOL> import theano . tensor as T <EOL> import lasagne as nn <EOL> import data <EOL> import load <EOL> import nn_plankton <EOL> import dihedral <EOL> import tmp_dnn <EOL> import tta <EOL> features = [ <EOL> \"<STR_LIT>\" , <EOL>", "answer": "]"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from diesel import Application , Loop , log , quickstart , quickstop <EOL> from diesel . protocols . http import HttpClient <EOL> def req_loop ( ) : <EOL> for path in [ '<STR_LIT>' , '<STR_LIT:/>' ] : <EOL> with HttpClient ( '<STR_LIT>' , <NUM_LIT> ) as client : <EOL>", "answer": "heads = { '<STR_LIT>' : '<STR_LIT>' }"}, {"prompt": "<s> from nova . api . openstack import extensions <EOL> class User_quotas ( extensions . ExtensionDescriptor ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __all__ = [ \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] <EOL> from pbcore . io import ReaderBase <EOL> from pbcore . io . _utils import splitFileContents <EOL> class DOMRecord ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , pid , sid , score , pStart , pEnd , pLen , <EOL> sStart , sEnd , sLen ) : <EOL> self . pid = pid <EOL> self . sid = sid <EOL>", "answer": "self . score = float ( score )"}, {"prompt": "<s> from setuptools import setup <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> long_description = open ( '<STR_LIT>' , '<STR_LIT:r>' ) . read ( ) , <EOL> url = '<STR_LIT>' , <EOL> packages = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] , <EOL> classifiers = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> from __future__ import absolute_import , unicode_literals <EOL> def get_manager ( client , hostname = None , port = None , userid = None , <EOL> password = None ) : <EOL> import pyrabbit <EOL> opt = client . transport_options . get <EOL> def get ( name , val , default ) : <EOL> return ( val if val is not None <EOL> else opt ( '<STR_LIT>' % name ) or <EOL> getattr ( client , name , None ) or default ) <EOL> host = get ( '<STR_LIT>' , hostname , '<STR_LIT:localhost>' ) <EOL> port = port if port is not None else opt ( '<STR_LIT>' , <NUM_LIT> ) <EOL> userid = get ( '<STR_LIT>' , userid , '<STR_LIT>' ) <EOL>", "answer": "password = get ( '<STR_LIT:password>' , password , '<STR_LIT>' )"}, {"prompt": "<s> import argparse <EOL> import tornado . httpserver <EOL> import tornado . ioloop <EOL> import tornado . web <EOL> import atexit <EOL> import sys <EOL> import signal <EOL> import os <EOL> import os . path <EOL> from pushkin . requesthandlers . events import ProtoEventHandler , JsonEventHandler <EOL> from pushkin . requesthandlers . notifications import ProtoNotificationHandler , JsonNotificationHandler <EOL> from pushkin . request . request_processor import RequestProcessor <EOL> from pushkin . request . event_handlers import EventHandlerManager <EOL> from pushkin . requesthandlers . monitoring import RequestQueueHandler <EOL> from pushkin . requesthandlers . monitoring import ApnSenderQueueHandler <EOL> from pushkin . requesthandlers . monitoring import GcmSenderQueueHandler <EOL> import multiprocessing <EOL> from pushkin import context <EOL> from pushkin . database import database <EOL> from pushkin import config <EOL> CONFIGURATION_FILENAME = None <EOL> def init ( ) : <EOL> context . setup_configuration ( CONFIGURATION_FILENAME ) <EOL> database . init_db ( ) <EOL> context . log_queue = multiprocessing . Queue ( ) <EOL> context . request_processor = RequestProcessor ( ) <EOL> context . event_handler_manager = EventHandlerManager ( ) <EOL> def create_app ( ) : <EOL> application = tornado . web . Application ( [ <EOL> ( config . proto_event_handler_url , ProtoEventHandler ) , <EOL> ( config . proto_notification_handler_url , ProtoNotificationHandler ) , <EOL> ( config . json_event_handler_url , JsonEventHandler ) , <EOL> ( config . json_notification_handler_url , JsonNotificationHandler ) , <EOL> ( config . request_queue_handler_url , RequestQueueHandler ) , <EOL> ( config . apn_sender_queue_handler_url , ApnSenderQueueHandler ) , <EOL> ( config . gcm_sender_queue_handler_url , GcmSenderQueueHandler ) , <EOL> ] ) <EOL> return application <EOL> def start ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> os . umask ( <NUM_LIT:0> <NUM_LIT> ) <EOL> context . setup_loggers ( ) <EOL> context . main_logger . info ( \"<STR_LIT>\" ) <EOL> context . main_logger . info ( \"<STR_LIT>\" ) <EOL> context . start_processors ( ) <EOL> def shutdown_handler ( signum , frame ) : <EOL> context . main_logger . info ( \"<STR_LIT>\" ) <EOL>", "answer": "print \"<STR_LIT>\""}, {"prompt": "<s> from expsuite import PyExperimentSuite <EOL> class MySuite ( PyExperimentSuite ) : <EOL>", "answer": "def reset ( self , params , rep ) :"}, {"prompt": "<s> from montepython . likelihood_class import Likelihood_newdat <EOL>", "answer": "class quad ( Likelihood_newdat ) :"}, {"prompt": "<s> from yubico_client . modhex import translate <EOL> from yubico_client . py3 import u <EOL> class OTP ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , otp , translate_otp = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if translate_otp : <EOL> self . otp = self . get_otp_modehex_interpretation ( otp ) <EOL>", "answer": "else :"}, {"prompt": "<s> import json <EOL> import os <EOL> import sys <EOL> import time <EOL> import signal <EOL> import re <EOL> from random import shuffle <EOL> from swift import gettext_ as _ <EOL> from contextlib import closing <EOL> from eventlet import Timeout <EOL> from swift . obj import diskfile , replicator <EOL> from swift . common . utils import ( <EOL> get_logger , ratelimit_sleep , dump_recon_cache , list_from_csv , listdir , <EOL> unlink_paths_older_than , readconf , config_auto_int_value ) <EOL> from swift . common . exceptions import DiskFileQuarantined , DiskFileNotExist <EOL> from swift . common . daemon import Daemon <EOL> from swift . common . storage_policy import POLICIES <EOL> RE_RSYNC_TEMPFILE = re . compile ( r'<STR_LIT>' ) <EOL> class AuditorWorker ( object ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from ajenti . api import * <EOL> from ajenti . plugins import * <EOL> info = PluginInfo ( <EOL> title = '<STR_LIT>' , <EOL> icon = '<STR_LIT>' , <EOL> dependencies = [ <EOL> PluginDependency ( '<STR_LIT>' ) , <EOL> BinaryDependency ( '<STR_LIT>' ) , <EOL>", "answer": "BinaryDependency ( '<STR_LIT>' ) ,"}, {"prompt": "<s> import datetime <EOL> from catwatch . lib . util_datetime import timedelta_months <EOL> from catwatch . lib . util_sqlalchemy import ResourceMixin <EOL> from catwatch . extensions import db <EOL>", "answer": "class CreditCard ( ResourceMixin , db . Model ) :"}, {"prompt": "<s> import platform <EOL> from toolz . functoolz import ( thread_first , thread_last , memoize , curry , <EOL> compose , pipe , complement , do , juxt , flip , excepts ) <EOL> from operator import add , mul , itemgetter <EOL> from toolz . utils import raises <EOL> from functools import partial <EOL> from toolz . compatibility import PY3 <EOL> def iseven ( x ) : <EOL> return x % <NUM_LIT:2> == <NUM_LIT:0> <EOL> def isodd ( x ) : <EOL> return x % <NUM_LIT:2> == <NUM_LIT:1> <EOL> def inc ( x ) : <EOL> return x + <NUM_LIT:1> <EOL> def double ( x ) : <EOL> return <NUM_LIT:2> * x <EOL> def test_thread_first ( ) : <EOL> assert thread_first ( <NUM_LIT:2> ) == <NUM_LIT:2> <EOL> assert thread_first ( <NUM_LIT:2> , inc ) == <NUM_LIT:3> <EOL> assert thread_first ( <NUM_LIT:2> , inc , inc ) == <NUM_LIT:4> <EOL> assert thread_first ( <NUM_LIT:2> , double , inc ) == <NUM_LIT:5> <EOL> assert thread_first ( <NUM_LIT:2> , ( add , <NUM_LIT:5> ) , double ) == <NUM_LIT> <EOL> def test_thread_last ( ) : <EOL> assert list ( thread_last ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] , ( map , inc ) , ( filter , iseven ) ) ) == [ <NUM_LIT:2> , <NUM_LIT:4> ] <EOL> assert list ( thread_last ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] , ( map , inc ) , ( filter , isodd ) ) ) == [ <NUM_LIT:3> ] <EOL> assert thread_last ( <NUM_LIT:2> , ( add , <NUM_LIT:5> ) , double ) == <NUM_LIT> <EOL> def test_memoize ( ) : <EOL> fn_calls = [ <NUM_LIT:0> ] <EOL> def f ( x , y ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fn_calls [ <NUM_LIT:0> ] += <NUM_LIT:1> <EOL> return x + y <EOL> mf = memoize ( f ) <EOL> assert mf ( <NUM_LIT:2> , <NUM_LIT:3> ) is mf ( <NUM_LIT:2> , <NUM_LIT:3> ) <EOL> assert fn_calls == [ <NUM_LIT:1> ] <EOL> assert mf . __doc__ == f . __doc__ <EOL> assert raises ( TypeError , lambda : mf ( <NUM_LIT:1> , { } ) ) <EOL> def test_memoize_kwargs ( ) : <EOL> fn_calls = [ <NUM_LIT:0> ] <EOL> def f ( x , y = <NUM_LIT:0> ) : <EOL> return x + y <EOL> mf = memoize ( f ) <EOL> assert mf ( <NUM_LIT:1> ) == f ( <NUM_LIT:1> ) <EOL> assert mf ( <NUM_LIT:1> , <NUM_LIT:2> ) == f ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> assert mf ( <NUM_LIT:1> , y = <NUM_LIT:2> ) == f ( <NUM_LIT:1> , y = <NUM_LIT:2> ) <EOL> assert mf ( <NUM_LIT:1> , y = <NUM_LIT:3> ) == f ( <NUM_LIT:1> , y = <NUM_LIT:3> ) <EOL> def test_memoize_curried ( ) : <EOL> @ curry <EOL> def f ( x , y = <NUM_LIT:0> ) : <EOL> return x + y <EOL> f2 = f ( y = <NUM_LIT:1> ) <EOL> fm2 = memoize ( f2 ) <EOL> assert fm2 ( <NUM_LIT:3> ) == f2 ( <NUM_LIT:3> ) <EOL> assert fm2 ( <NUM_LIT:3> ) == f2 ( <NUM_LIT:3> ) <EOL> def test_memoize_partial ( ) : <EOL> def f ( x , y = <NUM_LIT:0> ) : <EOL> return x + y <EOL> f2 = partial ( f , y = <NUM_LIT:1> ) <EOL> fm2 = memoize ( f2 ) <EOL> assert fm2 ( <NUM_LIT:3> ) == f2 ( <NUM_LIT:3> ) <EOL> assert fm2 ( <NUM_LIT:3> ) == f2 ( <NUM_LIT:3> ) <EOL> def test_memoize_key_signature ( ) : <EOL> mf = memoize ( lambda x : False , cache = { <NUM_LIT:1> : True } ) <EOL> assert mf ( <NUM_LIT:1> ) is True <EOL> assert mf ( <NUM_LIT:2> ) is False <EOL> mf = memoize ( lambda x , * args : False , cache = { ( <NUM_LIT:1> , ) : True , ( <NUM_LIT:1> , <NUM_LIT:2> ) : <NUM_LIT:2> } ) <EOL> assert mf ( <NUM_LIT:1> ) is True <EOL> assert mf ( <NUM_LIT:2> ) is False <EOL> assert mf ( <NUM_LIT:1> , <NUM_LIT:1> ) is False <EOL> assert mf ( <NUM_LIT:1> , <NUM_LIT:2> ) == <NUM_LIT:2> <EOL> assert mf ( ( <NUM_LIT:1> , <NUM_LIT:2> ) ) is False <EOL> mf = memoize ( lambda x , y : False , cache = { ( <NUM_LIT:1> , <NUM_LIT:2> ) : True } ) <EOL> assert mf ( <NUM_LIT:1> , <NUM_LIT:2> ) is True <EOL> assert mf ( <NUM_LIT:1> , <NUM_LIT:3> ) is False <EOL> assert raises ( TypeError , lambda : mf ( ( <NUM_LIT:1> , <NUM_LIT:2> ) ) ) <EOL> mf = memoize ( lambda : False , cache = { ( ) : True } ) <EOL> assert mf ( ) is True <EOL> mf = memoize ( lambda x , y = <NUM_LIT:0> : False , <EOL> cache = { ( ( <NUM_LIT:1> , ) , frozenset ( ( ( '<STR_LIT:y>' , <NUM_LIT:2> ) , ) ) ) : <NUM_LIT:2> , <EOL> ( ( <NUM_LIT:1> , <NUM_LIT:2> ) , None ) : <NUM_LIT:3> } ) <EOL> assert mf ( <NUM_LIT:1> , y = <NUM_LIT:2> ) == <NUM_LIT:2> <EOL> assert mf ( <NUM_LIT:1> , <NUM_LIT:2> ) == <NUM_LIT:3> <EOL> assert mf ( <NUM_LIT:2> , y = <NUM_LIT:2> ) is False <EOL> assert mf ( <NUM_LIT:2> , <NUM_LIT:2> ) is False <EOL> assert mf ( <NUM_LIT:1> ) is False <EOL> assert mf ( ( <NUM_LIT:1> , <NUM_LIT:2> ) ) is False <EOL> mf = memoize ( lambda x = <NUM_LIT:0> : False , cache = { ( None , frozenset ( ( ( '<STR_LIT:x>' , <NUM_LIT:1> ) , ) ) ) : <NUM_LIT:1> , <EOL> ( ( <NUM_LIT:1> , ) , None ) : <NUM_LIT:2> } ) <EOL> assert mf ( ) is False <EOL> assert mf ( x = <NUM_LIT:1> ) == <NUM_LIT:1> <EOL> assert mf ( <NUM_LIT:1> ) == <NUM_LIT:2> <EOL> def test_memoize_curry_cache ( ) : <EOL> @ memoize ( cache = { <NUM_LIT:1> : True } ) <EOL> def f ( x ) : <EOL> return False <EOL> assert f ( <NUM_LIT:1> ) is True <EOL> assert f ( <NUM_LIT:2> ) is False <EOL> def test_memoize_key ( ) : <EOL> @ memoize ( key = lambda args , kwargs : args [ <NUM_LIT:0> ] ) <EOL> def f ( x , y , * args , ** kwargs ) : <EOL> return x + y <EOL> assert f ( <NUM_LIT:1> , <NUM_LIT:2> ) == <NUM_LIT:3> <EOL> assert f ( <NUM_LIT:1> , <NUM_LIT:3> ) == <NUM_LIT:3> <EOL> def test_memoize_wrapped ( ) : <EOL> def foo ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> memoized_foo = memoize ( foo ) <EOL> assert memoized_foo . __wrapped__ is foo <EOL> def test_curry_simple ( ) : <EOL> cmul = curry ( mul ) <EOL> double = cmul ( <NUM_LIT:2> ) <EOL> assert callable ( double ) <EOL> assert double ( <NUM_LIT:10> ) == <NUM_LIT:20> <EOL> assert repr ( cmul ) == repr ( mul ) <EOL> cmap = curry ( map ) <EOL> assert list ( cmap ( inc ) ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] ) ) == [ <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ] <EOL> assert raises ( TypeError , lambda : curry ( ) ) <EOL> assert raises ( TypeError , lambda : curry ( { <NUM_LIT:1> : <NUM_LIT:2> } ) ) <EOL> def test_curry_kwargs ( ) : <EOL> def f ( a , b , c = <NUM_LIT:10> ) : <EOL> return ( a + b ) * c <EOL> f = curry ( f ) <EOL> assert f ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) == <NUM_LIT:9> <EOL> assert f ( <NUM_LIT:1> ) ( <NUM_LIT:2> , <NUM_LIT:3> ) == <NUM_LIT:9> <EOL> assert f ( <NUM_LIT:1> , <NUM_LIT:2> ) == <NUM_LIT:30> <EOL> assert f ( <NUM_LIT:1> , c = <NUM_LIT:3> ) ( <NUM_LIT:2> ) == <NUM_LIT:9> <EOL> assert f ( c = <NUM_LIT:3> ) ( <NUM_LIT:1> , <NUM_LIT:2> ) == <NUM_LIT:9> <EOL> def g ( a = <NUM_LIT:1> , b = <NUM_LIT:10> , c = <NUM_LIT:0> ) : <EOL> return a + b + c <EOL> cg = curry ( g , b = <NUM_LIT:2> ) <EOL> assert cg ( ) == <NUM_LIT:3> <EOL> assert cg ( b = <NUM_LIT:3> ) == <NUM_LIT:4> <EOL> assert cg ( a = <NUM_LIT:0> ) == <NUM_LIT:2> <EOL> assert cg ( a = <NUM_LIT:0> , b = <NUM_LIT:1> ) == <NUM_LIT:1> <EOL> assert cg ( <NUM_LIT:0> ) == <NUM_LIT:2> <EOL> assert raises ( TypeError , lambda : cg ( <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> def h ( x , func = int ) : <EOL> return func ( x ) <EOL> if platform . python_implementation ( ) != '<STR_LIT>' or platform . python_version_tuple ( ) [ <NUM_LIT:0> ] != '<STR_LIT:3>' : <EOL> assert curry ( h ) ( <NUM_LIT:0.0> ) == <NUM_LIT:0> <EOL> assert curry ( h ) ( func = str ) ( <NUM_LIT:0.0> ) == '<STR_LIT>' <EOL> assert curry ( h , func = str ) ( <NUM_LIT:0.0> ) == '<STR_LIT>' <EOL> def test_curry_passes_errors ( ) : <EOL> @ curry <EOL> def f ( a , b ) : <EOL> if not isinstance ( a , int ) : <EOL> raise TypeError ( ) <EOL> return a + b <EOL> assert f ( <NUM_LIT:1> , <NUM_LIT:2> ) == <NUM_LIT:3> <EOL> assert raises ( TypeError , lambda : f ( '<STR_LIT:1>' , <NUM_LIT:2> ) ) <EOL> assert raises ( TypeError , lambda : f ( '<STR_LIT:1>' ) ( <NUM_LIT:2> ) ) <EOL> assert raises ( TypeError , lambda : f ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> def test_curry_docstring ( ) : <EOL> def f ( x , y ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return x <EOL> g = curry ( f ) <EOL> assert g . __doc__ == f . __doc__ <EOL> assert str ( g ) == str ( f ) <EOL> assert f ( <NUM_LIT:1> , <NUM_LIT:2> ) == g ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> def test_curry_is_like_partial ( ) : <EOL> def foo ( a , b , c = <NUM_LIT:1> ) : <EOL> return a + b + c <EOL>", "answer": "p , c = partial ( foo , <NUM_LIT:1> , c = <NUM_LIT:2> ) , curry ( foo ) ( <NUM_LIT:1> , c = <NUM_LIT:2> )"}, {"prompt": "<s> import operator <EOL> from calvin . actor . actor import Actor , ActionResult , manage , condition , guard <EOL> from calvin . utilities . calvinlogger import get_actor_logger <EOL> _log = get_actor_logger ( __name__ ) <EOL> class Compare ( Actor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ manage ( [ '<STR_LIT>' ] ) <EOL> def init ( self , op ) : <EOL>", "answer": "try :"}, {"prompt": "<s> from thrift . Thrift import TType , TMessageType , TException , TApplicationException <EOL> from thrift . transport import TTransport <EOL> from thrift . protocol import TBinaryProtocol , TProtocol <EOL> try : <EOL> from thrift . protocol import fastbinary <EOL> except : <EOL> fastbinary = None <EOL> class TStatusCode ( object ) : <EOL> OK = <NUM_LIT:0> <EOL> CANCELLED = <NUM_LIT:1> <EOL> ANALYSIS_ERROR = <NUM_LIT:2> <EOL> NOT_IMPLEMENTED_ERROR = <NUM_LIT:3> <EOL> RUNTIME_ERROR = <NUM_LIT:4> <EOL>", "answer": "MEM_LIMIT_EXCEEDED = <NUM_LIT:5>"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "from babel . messages . catalog import * "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "from __future__ import absolute_import"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from OpenSSL import rand , crypto , SSL <EOL> from OpenSSL . version import ( <EOL> __author__ , __copyright__ , __email__ , __license__ , __summary__ , __title__ , <EOL>", "answer": "__uri__ , __version__ ,"}, {"prompt": "<s> import vtk <EOL> from vtk . util . misc import vtkGetDataRoot <EOL> VTK_DATA_ROOT = vtkGetDataRoot ( ) <EOL> fran = vtk . vtkPolyDataReader ( ) <EOL>", "answer": "fran . SetFileName ( VTK_DATA_ROOT + \"<STR_LIT>\" )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import datetime <EOL> from flask import Flask , request , jsonify <EOL> from flask . ext import restful <EOL> from flask . ext . restful import abort <EOL> from learning_text_transformer import learner3 as learner <EOL> from learning_text_transformer import transforms <EOL> from learning_text_transformer import config <EOL> app = Flask ( __name__ ) <EOL> api = restful . Api ( app ) <EOL> conf = config . get ( ) <EOL> class Logging ( object ) : <EOL> def __init__ ( self , conf ) : <EOL> self . conf = conf <EOL> self . write ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def log_learn_entry ( self , examples_to_learn_from ) : <EOL> self . write ( self . log_learn_entry . __name__ , examples_to_learn_from ) <EOL> def log_learn_exit ( self , result , best_score ) : <EOL> self . write ( self . log_learn_exit . __name__ , ( result , best_score ) ) <EOL> def log_transform_entry ( self , inputs ) : <EOL> self . write ( self . log_transform_entry . __name__ , inputs ) <EOL> def write ( self , fn_name , items ) : <EOL> output = repr ( ( datetime . datetime . utcnow ( ) . isoformat ( ) , fn_name , items ) ) <EOL> with open ( self . conf . log_filename , '<STR_LIT:a>' ) as f : <EOL> f . write ( output ) <EOL> f . write ( '<STR_LIT:\\n>' ) <EOL> logger = Logging ( conf ) <EOL> class HelloWorld ( restful . Resource ) : <EOL> def get ( self ) : <EOL> return { '<STR_LIT>' : '<STR_LIT>' } <EOL> api . add_resource ( HelloWorld , '<STR_LIT:/>' ) <EOL> def make_learn_result ( ts ) : <EOL> serialisation = transforms . Serialisation ( ) <EOL> serialised_json = serialisation . serialise ( ts ) <EOL> result = { \"<STR_LIT>\" : serialised_json } <EOL> return result <EOL> class Learn ( restful . Resource ) : <EOL> def check_inputs_or_abort ( self , reqs ) : <EOL> if len ( reqs [ '<STR_LIT>' ] ) != len ( reqs [ '<STR_LIT>' ] ) : <EOL> abort ( <NUM_LIT> ) <EOL> def post ( self ) : <EOL> reqs = request . get_json ( ) <EOL> self . check_inputs_or_abort ( reqs ) <EOL> examples_to_learn_from = list ( zip ( reqs [ '<STR_LIT>' ] , reqs [ '<STR_LIT>' ] ) ) <EOL> logger . log_learn_entry ( examples_to_learn_from ) <EOL> best_score = None <EOL> if examples_to_learn_from : <EOL> transform_searcher = learner . get_transform_searcher ( ) <EOL> chosen_transformations , best_score = transform_searcher . search_and_find_best_sequence ( examples_to_learn_from ) <EOL> else : <EOL> chosen_transformations = [ ] <EOL> result = make_learn_result ( chosen_transformations ) <EOL> logger . log_learn_exit ( result , best_score ) <EOL> return jsonify ( result ) <EOL> api . add_resource ( Learn , '<STR_LIT>' ) <EOL>", "answer": "class Transform ( restful . Resource ) :"}, {"prompt": "<s> from collections import namedtuple <EOL> LogEntry = namedtuple ( \"<STR_LIT>\" , ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT:email>\" , <EOL> \"<STR_LIT>\" <EOL> ) ) <EOL> class HistoryMixin ( ) : <EOL> def log ( self , limit = None , skip = None , author = None , fpath = None , start_end = None , reverse = False ) : <EOL> log_output = self . git ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" . format ( limit ) if limit else None , <EOL> \"<STR_LIT>\" . format ( skip ) if skip else None , <EOL> \"<STR_LIT>\" . format ( author ) if author else None , <EOL> \"<STR_LIT>\" if reverse else None , <EOL> '<STR_LIT>' , <EOL> \"<STR_LIT>\" . format ( * start_end ) if start_end else None , <EOL> \"<STR_LIT>\" if fpath else None , <EOL> fpath <EOL> ) . strip ( \"<STR_LIT:\\x00>\" ) <EOL> entries = [ ] <EOL> for entry in log_output . split ( \"<STR_LIT>\" ) : <EOL> entry = entry . strip ( ) <EOL> if not entry : <EOL> continue <EOL>", "answer": "entry , raw_body = entry . split ( \"<STR_LIT:\\x00>\" )"}, {"prompt": "<s> from django . conf . urls import * <EOL> from django . contrib . auth . decorators import login_required <EOL> from questionnaire . views import * <EOL> from mcbv . base import TemplateView <EOL> urlpatterns = patterns ( \"<STR_LIT>\" , <EOL> ( r\"<STR_LIT>\" , login_required ( Questionnaires . as_view ( ) ) , { } , \"<STR_LIT>\" ) , <EOL> ( r\"<STR_LIT>\" , <EOL> login_required ( ViewQuestionnaire . as_view ( ) ) , { } , \"<STR_LIT>\" ) , <EOL> ( r\"<STR_LIT>\" , <EOL> login_required ( ViewQuestionnaire . as_view ( ) ) , { } , \"<STR_LIT>\" ) , <EOL> ( r\"<STR_LIT>\" , <EOL> login_required ( UserQuests . as_view ( ) ) , { } , \"<STR_LIT>\" ) , <EOL>", "answer": "( r\"<STR_LIT>\" ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> sys . path . append ( '<STR_LIT:..>' ) <EOL> from pymir import AudioFile <EOL> from pymir import Energy <EOL> from pymir import Onsets <EOL> import matplotlib . pyplot as plt <EOL> filename = \"<STR_LIT>\" <EOL> print \"<STR_LIT>\" + filename <EOL> audiofile = AudioFile . open ( filename ) <EOL> plt . plot ( audiofile ) <EOL> plt . show ( ) <EOL> print \"<STR_LIT>\" <EOL> o = Onsets . onsetsByEnergy ( audiofile ) <EOL> print o <EOL> frames = audiofile . framesFromOnsets ( o ) <EOL> for i in range ( <NUM_LIT:0> , len ( frames ) ) : <EOL> print \"<STR_LIT>\" + str ( i ) <EOL>", "answer": "plt . plot ( frames [ i ] )"}, {"prompt": "<s> from __future__ import with_statement <EOL> import logging <EOL> import os <EOL> from alembic import context <EOL> from sqlalchemy import MetaData <EOL> from sqlalchemy import engine_from_config , pool <EOL> from h . settings import database_url <EOL> config = context . config <EOL> from h import db <EOL> from h . api import db as api_db <EOL> from h import models <EOL> from h . api . models import annotation <EOL> target_metadata = MetaData ( naming_convention = db . Base . metadata . naming_convention ) <EOL> for metadata in [ db . Base . metadata , api_db . Base . metadata ] : <EOL> for t in metadata . tables . values ( ) : <EOL> t . tometadata ( target_metadata ) <EOL> def configure_logging ( ) : <EOL>", "answer": "logging . basicConfig ( format = '<STR_LIT>'"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function <EOL> from networkx import * <EOL> import re <EOL> import sys <EOL> def roget_graph ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> import gzip <EOL> fh = gzip . open ( '<STR_LIT>' , '<STR_LIT:r>' ) <EOL> G = DiGraph ( ) <EOL> for line in fh . readlines ( ) : <EOL> line = line . decode ( ) <EOL> if line . startswith ( \"<STR_LIT:*>\" ) : <EOL> continue <EOL> if line . startswith ( \"<STR_LIT:U+0020>\" ) : <EOL> line = oldline + line <EOL> if line . endswith ( \"<STR_LIT>\" ) : <EOL> oldline = line . strip ( \"<STR_LIT>\" ) <EOL> continue <EOL> ( headname , tails ) = line . split ( \"<STR_LIT::>\" ) <EOL> numfind = re . compile ( \"<STR_LIT>\" ) <EOL> head = numfind . findall ( headname ) [ <NUM_LIT:0> ] <EOL> G . add_node ( head ) <EOL>", "answer": "for tail in tails . split ( ) :"}, {"prompt": "<s> class Solution : <EOL> lookup = { '<STR_LIT:0>' : '<STR_LIT:0>' , '<STR_LIT:1>' : '<STR_LIT:1>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } <EOL> def findStrobogrammatic ( self , n ) : <EOL> return self . findStrobogrammaticRecu ( n , n ) <EOL> def findStrobogrammaticRecu ( self , n , k ) : <EOL> if k == <NUM_LIT:0> : <EOL> return [ '<STR_LIT>' ] <EOL> elif k == <NUM_LIT:1> : <EOL> return [ '<STR_LIT:0>' , '<STR_LIT:1>' , '<STR_LIT>' ] <EOL> result = [ ] <EOL> for num in self . findStrobogrammaticRecu ( n , k - <NUM_LIT:2> ) : <EOL> for key , val in self . lookup . iteritems ( ) : <EOL> if n != k or key != '<STR_LIT:0>' : <EOL>", "answer": "result . append ( key + num + val )"}, {"prompt": "<s> import collections , math , sys , json , urllib2 , os <EOL> def main ( ) : <EOL> model = json . loads ( urllib2 . urlopen ( os . environ [ '<STR_LIT>' ] ) . readline ( ) . strip ( ) ) <EOL> split = float ( os . environ [ '<STR_LIT>' ] ) if os . environ . has_key ( '<STR_LIT>' ) else <NUM_LIT> <EOL> W = collections . defaultdict ( float ) <EOL> for f , w in model [ '<STR_LIT>' ] . items ( ) : <EOL> W [ f ] = w <EOL> for line in sys . stdin : <EOL> x = json . loads ( line ) <EOL> if x . has_key ( '<STR_LIT:class>' ) and x [ \"<STR_LIT>\" ] <= split : <EOL> prediction = <NUM_LIT:1> if <NUM_LIT:0.> < sum ( [ W [ j ] * x [ \"<STR_LIT>\" ] [ j ] for j in x [ \"<STR_LIT>\" ] . keys ( ) ] ) else <NUM_LIT:0> <EOL> print '<STR_LIT>' % ( x [ \"<STR_LIT:id>\" ] , prediction , x [ \"<STR_LIT:class>\" ] ) <EOL>", "answer": "if __name__ == '<STR_LIT:__main__>' :"}, {"prompt": "<s> from django . core . management import CommandError <EOL> import djclick as click <EOL> @ click . command ( version = '<STR_LIT>' ) <EOL> def command ( ) : <EOL>", "answer": "raise CommandError ( '<STR_LIT>' ) "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import division <EOL> import copy <EOL> from distutils . version import LooseVersion <EOL> import inspect <EOL> import itertools <EOL> import os <EOL> import sys <EOL> import warnings <EOL> from vistrails . core import debug , get_vistrails_application , system <EOL> from vistrails . core . configuration import ConfigurationObject , get_vistrails_configuration <EOL> import vistrails . core . data_structures . graph <EOL> from vistrails . core . modules . module_registry import MissingPackage , MissingPackageVersion <EOL> from vistrails . core . modules . package import Package <EOL> from vistrails . core . requirements import MissingRequirement <EOL> from vistrails . core . utils import VistrailsInternalError , versions_increasing , VistrailsDeprecation <EOL> import vistrails . packages <EOL> global _package_manager <EOL> _package_manager = None <EOL> class PackageManager ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class DependencyCycle ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , p1 , p2 ) : <EOL> self . _package_1 = p1 <EOL> self . _package_2 = p2 <EOL> def __str__ ( self ) : <EOL> return ( \"<STR_LIT>\" % <EOL> ( self . _package_1 , <EOL> self . _package_2 ) ) <EOL> class PackageInternalError ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , n , d ) : <EOL> self . _package_name = n <EOL> self . _description = d <EOL>", "answer": "def __str__ ( self ) :"}, {"prompt": "<s> import logging <EOL> import re <EOL> import wdr <EOL> ( <EOL> AdminApp , AdminConfig , AdminControl , AdminTask , Help <EOL> ) = wdr . WsadminObjects ( ) . getObjects ( ) <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> _listPattern = re . compile ( r'<STR_LIT>' ) <EOL> _itemPattern = re . compile ( <EOL>", "answer": "r'<STR_LIT>'"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from . import toolkit <EOL>", "answer": "toolkit = toolkit . GUIToolkit ( ) "}, {"prompt": "<s> import re <EOL> from datetime import datetime <EOL> import uuid <EOL> from sqlalchemy import Table , Column <EOL> from sqlalchemy . types import * <EOL> from meta import * <EOL> from base import DomainObject , JsonType <EOL> make_uuid = lambda : unicode ( uuid . uuid4 ( ) ) <EOL> user_table = Table ( '<STR_LIT:user>' , metadata , <EOL> Column ( '<STR_LIT:id>' , UnicodeText , primary_key = True , default = make_uuid ) , <EOL> Column ( '<STR_LIT>' , UnicodeText , unique = True ) , <EOL> Column ( '<STR_LIT:username>' , UnicodeText , unique = True ) , <EOL> Column ( '<STR_LIT>' , UnicodeText ) , <EOL>", "answer": "Column ( '<STR_LIT:email>' , UnicodeText , unique = True ) ,"}, {"prompt": "<s> import unittest <EOL> import test . test_support <EOL> class ListTest ( unittest . TestCase ) : <EOL> def test_recursive_list_slices ( self ) : <EOL> x = [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> ] <EOL> x [ <NUM_LIT:1> : ] = x <EOL> self . assertEquals ( x , [ <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> ] , <EOL> \"<STR_LIT>\" ) <EOL> def test_main ( ) : <EOL> test . test_support . run_unittest ( ListTest ) <EOL>", "answer": "if __name__ == \"<STR_LIT:__main__>\" :"}, {"prompt": "<s> from __future__ import division <EOL> import numpy as np <EOL> from . import _surf <EOL> __all__ = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> from flask_superadmin . model . base import BaseModelAdmin <EOL> from orm import model_form , AdminModelConverter <EOL> from django . db import models <EOL> import operator <EOL> class ModelAdmin ( BaseModelAdmin ) : <EOL> @ staticmethod <EOL> def model_detect ( model ) : <EOL> return issubclass ( model , models . Model ) <EOL>", "answer": "def allow_pk ( self ) :"}, {"prompt": "<s> import functools <EOL> import time <EOL> import inspect <EOL> import os <EOL> import SocketServer <EOL> import django <EOL> from django . conf import settings <EOL> import pymongo <EOL> import pymongo . collection <EOL> import pymongo . cursor <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] <EOL> _original_methods = { <EOL> '<STR_LIT>' : pymongo . collection . Collection . insert , <EOL> '<STR_LIT>' : pymongo . collection . Collection . update , <EOL> '<STR_LIT>' : pymongo . collection . Collection . remove , <EOL> '<STR_LIT>' : pymongo . cursor . Cursor . _refresh , <EOL> } <EOL> queries = [ ] <EOL> inserts = [ ] <EOL> updates = [ ] <EOL> removes = [ ] <EOL> WANT_STACK_TRACE = getattr ( settings , '<STR_LIT>' , True ) <EOL> def _get_stacktrace ( ) : <EOL> if WANT_STACK_TRACE : <EOL> try : <EOL> stack = inspect . stack ( ) <EOL> except IndexError : <EOL> return [ ( <EOL> \"<STR_LIT>\" , <EOL> <NUM_LIT:0> , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> ) ] <EOL> return _tidy_stacktrace ( reversed ( stack ) ) <EOL> else : <EOL> return [ ] <EOL> @ functools . wraps ( _original_methods [ '<STR_LIT>' ] ) <EOL> def _insert ( collection_self , doc_or_docs , manipulate = True , <EOL> safe = False , check_keys = True , ** kwargs ) : <EOL> start_time = time . time ( ) <EOL> result = _original_methods [ '<STR_LIT>' ] ( <EOL> collection_self , <EOL> doc_or_docs , <EOL> manipulate = manipulate , <EOL> safe = safe , <EOL> check_keys = check_keys , <EOL> ** kwargs <EOL> ) <EOL> total_time = ( time . time ( ) - start_time ) * <NUM_LIT:1000> <EOL> __traceback_hide__ = True <EOL> inserts . append ( { <EOL> '<STR_LIT>' : doc_or_docs , <EOL> '<STR_LIT>' : safe , <EOL> '<STR_LIT:time>' : total_time , <EOL> '<STR_LIT>' : _get_stacktrace ( ) , <EOL> } ) <EOL> return result <EOL> @ functools . wraps ( _original_methods [ '<STR_LIT>' ] ) <EOL> def _update ( collection_self , spec , document , upsert = False , <EOL> maniuplate = False , safe = False , multi = False , ** kwargs ) : <EOL> start_time = time . time ( ) <EOL> result = _original_methods [ '<STR_LIT>' ] ( <EOL> collection_self , <EOL> spec , <EOL> document , <EOL> upsert = upsert , <EOL> safe = safe , <EOL> multi = multi , <EOL> ** kwargs <EOL> ) <EOL> total_time = ( time . time ( ) - start_time ) * <NUM_LIT:1000> <EOL> __traceback_hide__ = True <EOL> updates . append ( { <EOL> '<STR_LIT>' : document , <EOL> '<STR_LIT>' : upsert , <EOL> '<STR_LIT>' : multi , <EOL> '<STR_LIT>' : spec , <EOL> '<STR_LIT>' : safe , <EOL> '<STR_LIT:time>' : total_time , <EOL> '<STR_LIT>' : _get_stacktrace ( ) , <EOL> } ) <EOL> return result <EOL> @ functools . wraps ( _original_methods [ '<STR_LIT>' ] ) <EOL> def _remove ( collection_self , spec_or_id , safe = False , ** kwargs ) : <EOL> start_time = time . time ( ) <EOL> result = _original_methods [ '<STR_LIT>' ] ( <EOL> collection_self , <EOL> spec_or_id , <EOL> safe = safe , <EOL> ** kwargs <EOL> ) <EOL> total_time = ( time . time ( ) - start_time ) * <NUM_LIT:1000> <EOL> __traceback_hide__ = True <EOL> removes . append ( { <EOL> '<STR_LIT>' : spec_or_id , <EOL> '<STR_LIT>' : safe , <EOL> '<STR_LIT:time>' : total_time , <EOL> '<STR_LIT>' : _get_stacktrace ( ) , <EOL> } ) <EOL> return result <EOL> @ functools . wraps ( _original_methods [ '<STR_LIT>' ] ) <EOL> def _cursor_refresh ( cursor_self ) : <EOL> def privar ( name ) : <EOL> return getattr ( cursor_self , '<STR_LIT>' . format ( name ) ) <EOL> is_getmore = privar ( '<STR_LIT:id>' ) is not None <EOL> start_time = time . time ( ) <EOL> result = _original_methods [ '<STR_LIT>' ] ( cursor_self ) <EOL> total_time = ( time . time ( ) - start_time ) * <NUM_LIT:1000> <EOL> query_son = privar ( '<STR_LIT>' ) ( ) <EOL> __traceback_hide__ = True <EOL> query_data = { <EOL> '<STR_LIT:time>' : total_time , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : _get_stacktrace ( ) , <EOL> } <EOL> if is_getmore : <EOL> query_data [ '<STR_LIT>' ] = id ( cursor_self ) <EOL> query_data [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> queries . append ( query_data ) <EOL> return result <EOL> collection_name = privar ( '<STR_LIT>' ) <EOL> query_data [ '<STR_LIT>' ] = collection_name . full_name . split ( '<STR_LIT:.>' ) [ <NUM_LIT:1> ] <EOL> if query_data [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> query_son = query_son . get ( \"<STR_LIT>\" , query_son ) <EOL> query_data [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> if '<STR_LIT:count>' in query_son : <EOL> query_data [ '<STR_LIT>' ] = query_son [ '<STR_LIT:count>' ] <EOL> query_data [ '<STR_LIT>' ] = '<STR_LIT:count>' <EOL> query_data [ '<STR_LIT>' ] = query_son . get ( '<STR_LIT>' ) <EOL> query_data [ '<STR_LIT>' ] = abs ( query_son . get ( '<STR_LIT>' , <NUM_LIT:0> ) ) <EOL> query_data [ '<STR_LIT>' ] = query_son [ '<STR_LIT>' ] <EOL> elif '<STR_LIT>' in query_son : <EOL> query_data [ '<STR_LIT>' ] = query_son [ '<STR_LIT>' ] <EOL> query_data [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> query_data [ '<STR_LIT>' ] = query_son [ '<STR_LIT>' ] <EOL> query_data [ '<STR_LIT>' ] = <NUM_LIT:0> <EOL> query_data [ '<STR_LIT>' ] = None <EOL> else : <EOL> query_data [ '<STR_LIT>' ] = privar ( '<STR_LIT>' ) <EOL> query_data [ '<STR_LIT>' ] = abs ( privar ( '<STR_LIT>' ) or <NUM_LIT:0> ) <EOL> query_data [ '<STR_LIT>' ] = query_son . get ( '<STR_LIT>' ) or query_son <EOL>", "answer": "query_data [ '<STR_LIT>' ] = _get_ordering ( query_son )"}, {"prompt": "<s> from django import forms <EOL> from faq . models import Question <EOL> class QuestionForm ( forms . ModelForm ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class Meta : <EOL>", "answer": "fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:status>' )"}, {"prompt": "<s> import re <EOL> from tornado . web import HTTPError <EOL> from pypi_server . db . users import Users <EOL> from pypi_server . handlers import route <EOL> from pypi_server . handlers . base import threaded <EOL> from pypi_server . handlers . api import JSONHandler <EOL> from pypi_server . handlers . api . login import authorization_required <EOL> LOGIN_EXP = re . compile ( \"<STR_LIT>\" ) <EOL> EMAIL_EXP = re . compile ( \"<STR_LIT>\" ) <EOL> @ route ( '<STR_LIT>' ) <EOL> class UsersHandler ( JSONHandler ) : <EOL> @ authorization_required ( is_admin = True ) <EOL> @ threaded <EOL> def get ( self ) : <EOL> self . response ( <EOL> list ( <EOL> map ( <EOL> lambda x : dict ( <EOL> id = x . id , <EOL> login = x . login , <EOL> email = x . email , <EOL> is_admin = x . is_admin , <EOL> disabled = x . disabled , <EOL> ) , <EOL> Users . select ( <EOL> Users . id , <EOL> Users . login , <EOL> Users . email , <EOL> Users . is_admin , <EOL> Users . disabled <EOL> ) <EOL> ) <EOL> ) <EOL> ) <EOL> @ authorization_required ( is_admin = True ) <EOL> @ threaded <EOL> def post ( self ) : <EOL> try : <EOL> login = self . json [ \"<STR_LIT>\" ] <EOL> email = self . json [ \"<STR_LIT:email>\" ] <EOL> is_admin = bool ( self . json . get ( \"<STR_LIT>\" , <NUM_LIT:0> ) ) <EOL> password = self . json [ \"<STR_LIT:password>\" ] <EOL> assert password and len ( password ) > <NUM_LIT:3> <EOL> assert LOGIN_EXP . match ( login ) <EOL> assert EMAIL_EXP . match ( email ) <EOL> except ( KeyError , AssertionError , TypeError ) : <EOL>", "answer": "raise HTTPError ( <NUM_LIT> )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import unittest <EOL> import numpy as np <EOL> from openmdao . api import Problem , InMemoryRecorder , ScipyOptimizer <EOL> from openmdao . test . sellar import SellarDerivativesGrouped <EOL> from openmdao . test . util import assert_rel_error <EOL> OPT = None <EOL> OPTIMIZER = None <EOL> try : <EOL> from pyoptsparse import OPT <EOL> try : <EOL> OPT ( '<STR_LIT>' ) <EOL> OPTIMIZER = '<STR_LIT>' <EOL> except : <EOL> pass <EOL> except : <EOL> pass <EOL> if OPTIMIZER : <EOL> from openmdao . drivers . pyoptsparse_driver import pyOptSparseDriver <EOL>", "answer": "class TestInMemoryRecorder ( unittest . TestCase ) :"}, {"prompt": "<s> import sys <EOL> try : <EOL> from StringIO import StringIO as BytesIO <EOL> except : <EOL> from io import BytesIO <EOL> PY3 = sys . version_info [ <NUM_LIT:0> ] == <NUM_LIT:3> <EOL> if PY3 : <EOL> string_types = str , <EOL> integer_types = int , <EOL> class_types = type , <EOL> text_type = str <EOL> binary_type = bytes <EOL> long = int <EOL> else : <EOL> string_types = basestring , <EOL> integer_types = ( int , long ) <EOL> text_type = unicode <EOL> binary_type = str <EOL> long = long <EOL> def bytes_ ( s , encoding = '<STR_LIT:utf-8>' , errors = '<STR_LIT:strict>' ) : <EOL> if isinstance ( s , text_type ) : <EOL> return s . encode ( encoding , errors ) <EOL> return s <EOL> def text_ ( s , encoding = '<STR_LIT:utf-8>' , errors = '<STR_LIT:strict>' ) : <EOL> if isinstance ( s , binary_type ) : <EOL> return s . decode ( encoding , errors ) <EOL> return s <EOL>", "answer": "try :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = <NUM_LIT:8>"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from importlib import import_module <EOL> from django . core . exceptions import ImproperlyConfigured <EOL> def load_model_class ( model_path ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dot = model_path . rindex ( '<STR_LIT:.>' ) <EOL>", "answer": "module_name = model_path [ : dot ]"}, {"prompt": "<s> from . . import annotations <EOL> def calculateslidingspace ( base , offset , frame ) : <EOL> xstart = max ( <NUM_LIT:0> , base . xtl - offset ) <EOL> xstop = min ( frame [ <NUM_LIT:0> ] - <NUM_LIT:1> , base . xbr + offset ) <EOL>", "answer": "ystart = max ( <NUM_LIT:0> , base . ytl - offset )"}, {"prompt": "<s> from . permission import Permission <EOL> from flask . views import View , MethodView <EOL> from functools import wraps <EOL> def requires ( * requirements , ** opts ) : <EOL> def decorator ( f ) : <EOL> @ wraps ( f ) <EOL> def allower ( * args , ** kwargs ) : <EOL> with Permission ( * requirements , ** opts ) : <EOL> return f ( * args , ** kwargs ) <EOL> return allower <EOL> return decorator <EOL> class PermissionedView ( View ) : <EOL> requirements = ( ) <EOL> @ classmethod <EOL> def as_view ( cls , name , * cls_args , ** cls_kwargs ) : <EOL> allower = requires ( * cls . requirements ) <EOL> view = allower ( super ( PermissionedView , cls ) . as_view ( name , * cls_args , ** cls_kwargs ) ) <EOL> view . requirements = cls . requirements <EOL> return view <EOL>", "answer": "class PermissionedMethodView ( PermissionedView , MethodView ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import os <EOL> import hotshot <EOL> import hotshot . stats <EOL> import threading <EOL> import cgi <EOL> import six <EOL> import time <EOL> from cStringIO import StringIO <EOL> from paste import response <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> class ProfileMiddleware ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> style = ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> def __init__ ( self , app , global_conf = None , <EOL> log_filename = '<STR_LIT>' , <EOL> limit = <NUM_LIT> ) : <EOL> self . app = app <EOL> self . lock = threading . Lock ( ) <EOL> self . log_filename = log_filename <EOL> self . limit = limit <EOL> def __call__ ( self , environ , start_response ) : <EOL> catch_response = [ ] <EOL> body = [ ] <EOL> def replace_start_response ( status , headers , exc_info = None ) : <EOL> catch_response . extend ( [ status , headers ] ) <EOL> start_response ( status , headers , exc_info ) <EOL> return body . append <EOL> def run_app ( ) : <EOL> app_iter = self . app ( environ , replace_start_response ) <EOL> try : <EOL> body . extend ( app_iter ) <EOL> finally : <EOL> if hasattr ( app_iter , '<STR_LIT>' ) : <EOL> app_iter . close ( ) <EOL> self . lock . acquire ( ) <EOL> try : <EOL> prof = hotshot . Profile ( self . log_filename ) <EOL> prof . addinfo ( '<STR_LIT>' , environ . get ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> try : <EOL> prof . runcall ( run_app ) <EOL> finally : <EOL> prof . close ( ) <EOL> body = '<STR_LIT>' . join ( body ) <EOL> headers = catch_response [ <NUM_LIT:1> ] <EOL> content_type = response . header_value ( headers , '<STR_LIT>' ) <EOL> if content_type is None or not content_type . startswith ( '<STR_LIT>' ) : <EOL> return [ body ] <EOL> stats = hotshot . stats . load ( self . log_filename ) <EOL> stats . strip_dirs ( ) <EOL> stats . sort_stats ( '<STR_LIT:time>' , '<STR_LIT>' ) <EOL> output = capture_output ( stats . print_stats , self . limit ) <EOL> output_callers = capture_output ( <EOL> stats . print_callers , self . limit ) <EOL> body += '<STR_LIT>' % ( <EOL> self . style , cgi . escape ( output ) , cgi . escape ( output_callers ) ) <EOL> return [ body ] <EOL> finally : <EOL> self . lock . release ( ) <EOL> def capture_output ( func , * args , ** kw ) : <EOL> out = StringIO ( ) <EOL> old_stdout = sys . stdout <EOL> sys . stdout = out <EOL> try : <EOL> func ( * args , ** kw ) <EOL> finally : <EOL> sys . stdout = old_stdout <EOL> return out . getvalue ( ) <EOL> def profile_decorator ( ** options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if options . get ( '<STR_LIT>' ) : <EOL> def decorator ( func ) : <EOL> return func <EOL> return decorator <EOL> def decorator ( func ) : <EOL> def replacement ( * args , ** kw ) : <EOL> return DecoratedProfile ( func , ** options ) ( * args , ** kw ) <EOL> return replacement <EOL> return decorator <EOL> class DecoratedProfile ( object ) : <EOL> lock = threading . Lock ( ) <EOL> def __init__ ( self , func , ** options ) : <EOL> self . func = func <EOL> self . options = options <EOL> def __call__ ( self , * args , ** kw ) : <EOL> self . lock . acquire ( ) <EOL> try : <EOL> return self . profile ( self . func , * args , ** kw ) <EOL> finally : <EOL> self . lock . release ( ) <EOL> def profile ( self , func , * args , ** kw ) : <EOL> ops = self . options <EOL> prof_filename = ops . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> prof = hotshot . Profile ( prof_filename ) <EOL> prof . addinfo ( '<STR_LIT>' , <EOL> self . format_function ( func , * args , ** kw ) ) <EOL> if ops . get ( '<STR_LIT>' ) : <EOL> prof . addinfo ( '<STR_LIT>' , ops [ '<STR_LIT>' ] ) <EOL> exc_info = None <EOL> try : <EOL>", "answer": "start_time = time . time ( )"}, {"prompt": "<s> from openstack . image import image_service <EOL> from openstack . image . v2 import image <EOL>", "answer": "from openstack import resource"}, {"prompt": "<s> from setuptools import setup , find_packages <EOL> from setuptools . command . test import test as TestCommand <EOL> import versioneer <EOL> versioneer . VCS = '<STR_LIT>' <EOL> versioneer . versionfile_source = '<STR_LIT>' <EOL> versioneer . versionfile_build = None <EOL>", "answer": "versioneer . tag_prefix = '<STR_LIT:v>'"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL>", "answer": "result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import time <EOL> import struct <EOL> import argparse <EOL> def Run ( fileName = None , period = <NUM_LIT> , real = False , <EOL> verbose = <NUM_LIT:0> , profiling = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> import ioflo . base . skedding as skedding <EOL> if not fileName : <EOL> fileName = \"<STR_LIT>\" <EOL> print ( \"<STR_LIT>\" ) <EOL> skedder = tasking . Skedder ( name = \"<STR_LIT>\" , <EOL> period = period , <EOL> real = real , <EOL> filepath = fileName ) <EOL> if skedder . build ( ) : <EOL> print ( \"<STR_LIT>\" % ( fileName ) ) <EOL> if not profiling : <EOL> skedder . run ( ) <EOL> else : <EOL> import cProfile <EOL> import pstats <EOL> cProfile . runctx ( '<STR_LIT>' , globals ( ) , locals ( ) , '<STR_LIT>' ) <EOL> p = pstats . Stats ( '<STR_LIT>' ) <EOL> p . sort_stats ( '<STR_LIT:time>' ) . print_stats ( ) <EOL> p . print_callers ( ) <EOL> p . print_callees ( ) <EOL> return skedder <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL> import sys <EOL> import getopt <EOL> sys . stderr . write ( str ( sys . argv ) + \"<STR_LIT:\\n>\" ) <EOL> filename = '<STR_LIT>' <EOL> period = <NUM_LIT> <EOL> verbose = <NUM_LIT:0> <EOL> real = False <EOL> usage = \"<STR_LIT>\" <EOL> try : <EOL> ( opts , pargs ) = getopt . getopt ( sys . argv [ <NUM_LIT:1> : ] , \"<STR_LIT>\" ) <EOL> except getopt . GetoptError : <EOL> sys . stderr . write ( str ( opts ) + \"<STR_LIT>\" ) <EOL> print ( usage ) <EOL> sys . exit ( <NUM_LIT:2> ) <EOL> sys . stderr . write ( str ( opts ) + \"<STR_LIT:\\n>\" ) <EOL>", "answer": "help = False"}, {"prompt": "<s> from nose . tools import * <EOL> from scripts . googledrive . migrate_to_external_account import do_migration , get_targets <EOL> from framework . auth import Auth <EOL> from tests . base import OsfTestCase <EOL> from tests . factories import ProjectFactory , UserFactory <EOL> from website . addons . googledrive . model import GoogleDriveUserSettings <EOL> from website . addons . googledrive . tests . factories import GoogleDriveOAuthSettingsFactory <EOL> class TestGoogleDriveMigration ( OsfTestCase ) : <EOL> def test_migration_no_project ( self ) : <EOL> user = UserFactory ( ) <EOL> user . add_addon ( '<STR_LIT>' ) <EOL> user_addon = user . get_addon ( '<STR_LIT>' ) <EOL> user_addon . oauth_settings = GoogleDriveOAuthSettingsFactory ( ) <EOL> user_addon . save ( ) <EOL> do_migration ( [ user_addon ] ) <EOL> user_addon . reload ( ) <EOL> assert_is_none ( user_addon . oauth_settings ) <EOL> assert_equal ( len ( user . external_accounts ) , <NUM_LIT:1> ) <EOL> account = user . external_accounts [ <NUM_LIT:0> ] <EOL> assert_equal ( account . provider , '<STR_LIT>' ) <EOL> assert_equal ( account . oauth_key , '<STR_LIT>' ) <EOL> def test_migration_removes_targets ( self ) : <EOL> GoogleDriveUserSettings . remove ( ) <EOL> user = UserFactory ( ) <EOL> project = ProjectFactory ( creator = user ) <EOL> user . add_addon ( '<STR_LIT>' , auth = Auth ( user ) ) <EOL> user_addon = user . get_addon ( '<STR_LIT>' ) <EOL> user_addon . oauth_settings = GoogleDriveOAuthSettingsFactory ( ) <EOL> user_addon . save ( ) <EOL> project . add_addon ( '<STR_LIT>' , auth = Auth ( user ) ) <EOL> node_addon = project . get_addon ( '<STR_LIT>' ) <EOL> node_addon . foreign_user_settings = user_addon <EOL> node_addon . save ( ) <EOL> assert_equal ( get_targets ( ) . count ( ) , <NUM_LIT:1> ) <EOL> do_migration ( [ user_addon ] ) <EOL> user_addon . reload ( ) <EOL> assert_equal ( get_targets ( ) . count ( ) , <NUM_LIT:0> ) <EOL>", "answer": "def test_migration_multiple_users ( self ) :"}, {"prompt": "<s> import datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . create_table ( u'<STR_LIT>' , ( <EOL> ( '<STR_LIT:user>' , self . gf ( '<STR_LIT>' ) ( to = orm [ '<STR_LIT>' ] , unique = True , primary_key = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = <NUM_LIT:1> ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = '<STR_LIT:default>' , max_length = <NUM_LIT:20> ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = '<STR_LIT>' , max_length = <NUM_LIT:50> ) ) , <EOL> ) ) <EOL> db . send_create_signal ( u'<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> def backwards ( self , orm ) : <EOL> db . delete_table ( u'<STR_LIT>' ) <EOL> models = { <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : u\"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : u\"<STR_LIT>\" } ) , <EOL>", "answer": "u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import struct <EOL> import xboxtime <EOL>", "answer": "import time"}, {"prompt": "<s> from pkgutil import walk_packages <EOL> import os <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _global_import ( name ) : <EOL> p = __import__ ( name , globals ( ) , None , level = <NUM_LIT:1> ) <EOL> lst = p . __all__ if '<STR_LIT>' in dir ( p ) else dir ( p ) <EOL>", "answer": "del globals ( ) [ name ]"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import errno <EOL> import glob <EOL> import os <EOL> import sys <EOL> import time <EOL> from . _common import memoize <EOL> from . _common import sdiskusage <EOL> from . _common import usage_percent <EOL> from . _compat import PY3 <EOL> from . _compat import unicode <EOL> class TimeoutExpired ( Exception ) : <EOL> pass <EOL> def pid_exists ( pid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if pid == <NUM_LIT:0> : <EOL> return True <EOL> try : <EOL> os . kill ( pid , <NUM_LIT:0> ) <EOL> except OSError as err : <EOL> if err . errno == errno . ESRCH : <EOL> return False <EOL> elif err . errno == errno . EPERM : <EOL> return True <EOL> else : <EOL> raise err <EOL> else : <EOL> return True <EOL> def wait_pid ( pid , timeout = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def check_timeout ( delay ) :"}, {"prompt": "<s> import argparse <EOL> import json <EOL> from calvin . utilities . calvinlogger import get_logger <EOL> from calvin . utilities . security import Security <EOL> from calvin . utilities import certificate <EOL> _log = get_logger ( __name__ ) <EOL> _request_handler = None <EOL> def get_request_handler ( ) : <EOL> from calvin . requests . request_handler import RequestHandler <EOL> return _request_handler if _request_handler else RequestHandler ( ) <EOL> def control_id ( args ) : <EOL> return get_request_handler ( ) . get_node_id ( args . node ) <EOL> def get_node_info ( control_uri , node_id ) : <EOL> try : <EOL> return get_request_handler ( ) . get_node ( control_uri , node_id ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" . format ( node_id ) ) <EOL> def get_node_control_uri ( control_uri , node_id ) : <EOL> nodeinfo = get_node_info ( control_uri , node_id ) <EOL> return nodeinfo . get ( \"<STR_LIT>\" ) <EOL> def requirements_file ( path ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> reqs = None <EOL>", "answer": "try :"}, {"prompt": "<s> import os <EOL> import flopy <EOL> import numpy as np <EOL> def test_usg_disu_load ( ) : <EOL> pthusgtest = os . path . join ( '<STR_LIT:..>' , '<STR_LIT>' , '<STR_LIT:data>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> fname = os . path . join ( pthusgtest , '<STR_LIT>' ) <EOL> assert os . path . isfile ( fname ) , '<STR_LIT>' . format ( fname ) <EOL> m = flopy . modflow . Modflow ( modelname = '<STR_LIT>' , verbose = True ) <EOL> disu = flopy . modflow . ModflowDisU . load ( fname , m ) <EOL> assert isinstance ( disu , flopy . modflow . ModflowDisU ) <EOL> model_ws = '<STR_LIT>' <EOL>", "answer": "m . model_ws = model_ws"}, {"prompt": "<s> import logging <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from horizon import exceptions <EOL> from horizon import forms <EOL> from openstack_dashboard . api import sahara as saharaclient <EOL> from openstack_dashboard . dashboards . project . data_processing . utils import workflow_helpers <EOL> LOG = logging . getLogger ( __name__ ) <EOL> class UploadFileForm ( forms . SelfHandlingForm , <EOL> workflow_helpers . PluginAndVersionMixin ) : <EOL> template_name = forms . CharField ( max_length = <NUM_LIT> , <EOL> label = _ ( \"<STR_LIT>\" ) ) <EOL> def __init__ ( self , request , * args , ** kwargs ) : <EOL> super ( UploadFileForm , self ) . __init__ ( request , * args , ** kwargs ) <EOL> sahara = saharaclient . client ( request ) <EOL>", "answer": "self . _generate_plugin_version_fields ( sahara )"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL> import django . db . models . deletion <EOL> from django . conf import settings <EOL> import django . utils . timezone <EOL> import django_prices . models <EOL> import django . core . validators <EOL> import satchless . item <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> migrations . swappable_dependency ( settings . AUTH_USER_MODEL ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , serialize = False , auto_created = True , primary_key = True ) ) , <EOL> ( '<STR_LIT:status>' , models . CharField ( default = '<STR_LIT>' , max_length = <NUM_LIT:32> , verbose_name = '<STR_LIT>' , choices = [ ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) ] ) ) , <EOL> ( '<STR_LIT>' , models . BooleanField ( default = True , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , django_prices . models . PriceField ( decimal_places = <NUM_LIT:4> , default = <NUM_LIT:0> , editable = False , currency = b'<STR_LIT>' , max_digits = <NUM_LIT:12> , verbose_name = '<STR_LIT>' ) ) , <EOL> ] , <EOL> bases = ( models . Model , satchless . item . ItemSet ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , serialize = False , auto_created = True , primary_key = True ) ) , <EOL> ( '<STR_LIT:status>' , models . CharField ( default = '<STR_LIT>' , max_length = <NUM_LIT:32> , verbose_name = '<STR_LIT>' , choices = [ ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) ] ) ) , <EOL> ( '<STR_LIT>' , models . DateTimeField ( default = django . utils . timezone . now , verbose_name = '<STR_LIT>' , editable = False ) ) , <EOL> ( '<STR_LIT>' , models . DateTimeField ( default = django . utils . timezone . now , verbose_name = '<STR_LIT>' , editable = False ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT> , editable = False , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT:255> , verbose_name = '<STR_LIT>' , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . EmailField ( default = '<STR_LIT>' , max_length = <NUM_LIT> , editable = False , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( unique = True , max_length = <NUM_LIT> , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( related_name = '<STR_LIT:+>' , editable = False , to = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( related_name = '<STR_LIT:+>' , editable = False , to = '<STR_LIT>' , null = True ) ) , <EOL> ( '<STR_LIT:user>' , models . ForeignKey ( related_name = '<STR_LIT>' , verbose_name = '<STR_LIT:user>' , blank = True , to = settings . AUTH_USER_MODEL , null = True ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : ( '<STR_LIT>' , ) , <EOL> } , <EOL> bases = ( models . Model , satchless . item . ItemSet ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , serialize = False , auto_created = True , primary_key = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT> , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT:32> , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . IntegerField ( verbose_name = '<STR_LIT>' , validators = [ django . core . validators . MinValueValidator ( <NUM_LIT:0> ) , django . core . validators . MaxValueValidator ( <NUM_LIT> ) ] ) ) , <EOL> ( '<STR_LIT>' , models . DecimalField ( verbose_name = '<STR_LIT>' , max_digits = <NUM_LIT:12> , decimal_places = <NUM_LIT:4> ) ) , <EOL> ( '<STR_LIT>' , models . DecimalField ( verbose_name = '<STR_LIT>' , max_digits = <NUM_LIT:12> , decimal_places = <NUM_LIT:4> ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( related_name = '<STR_LIT>' , editable = False , to = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( related_name = '<STR_LIT:+>' , on_delete = django . db . models . deletion . SET_NULL , verbose_name = '<STR_LIT>' , blank = True , to = '<STR_LIT>' , null = True ) ) , <EOL> ] , <EOL> bases = ( models . Model , satchless . item . ItemLine ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , serialize = False , auto_created = True , primary_key = True ) ) , <EOL> ( '<STR_LIT:date>' , models . DateTimeField ( default = django . utils . timezone . now , verbose_name = '<STR_LIT>' , editable = False ) ) , <EOL> ( '<STR_LIT:status>' , models . CharField ( max_length = <NUM_LIT:32> , verbose_name = '<STR_LIT>' , choices = [ ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) ] ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( default = '<STR_LIT>' , max_length = <NUM_LIT:100> , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( related_name = '<STR_LIT>' , to = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT:user>' , models . ForeignKey ( blank = True , to = settings . AUTH_USER_MODEL , null = True ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : [ '<STR_LIT:date>' ] , <EOL> } , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , serialize = False , auto_created = True , primary_key = True ) ) , <EOL> ( '<STR_LIT:date>' , models . DateTimeField ( auto_now_add = True ) ) , <EOL> ( '<STR_LIT:content>' , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( related_name = '<STR_LIT>' , to = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT:user>' , models . ForeignKey ( to = settings . AUTH_USER_MODEL ) ) , <EOL> ] , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , serialize = False , auto_created = True , primary_key = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT:255> ) ) , <EOL> ( '<STR_LIT:status>' , models . CharField ( default = '<STR_LIT>' , max_length = <NUM_LIT:10> , choices = [ ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT:error>' , '<STR_LIT>' ) , ( '<STR_LIT:input>' , '<STR_LIT>' ) ] ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( default = '<STR_LIT>' , max_length = <NUM_LIT:10> , verbose_name = '<STR_LIT>' , choices = [ ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) ] ) ) , <EOL> ( '<STR_LIT>' , models . TextField ( default = '<STR_LIT>' , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . DateTimeField ( auto_now_add = True ) ) , <EOL> ( '<STR_LIT>' , models . DateTimeField ( auto_now = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT:255> , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT:10> ) ) , <EOL> ( '<STR_LIT>' , models . DecimalField ( default = '<STR_LIT>' , max_digits = <NUM_LIT:9> , decimal_places = <NUM_LIT:2> ) ) , <EOL> ( '<STR_LIT>' , models . DecimalField ( default = '<STR_LIT>' , max_digits = <NUM_LIT:9> , decimal_places = <NUM_LIT:2> ) ) , <EOL> ( '<STR_LIT>' , models . DecimalField ( default = '<STR_LIT>' , max_digits = <NUM_LIT:9> , decimal_places = <NUM_LIT:2> ) ) , <EOL> ( '<STR_LIT:description>' , models . TextField ( default = '<STR_LIT>' , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT> , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT> , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT> , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT> , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT> , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT> , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT:2> , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT> , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . EmailField ( max_length = <NUM_LIT> , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . IPAddressField ( blank = True ) ) , <EOL> ( '<STR_LIT>' , models . TextField ( default = '<STR_LIT>' , blank = True ) ) , <EOL> ( '<STR_LIT:message>' , models . TextField ( default = '<STR_LIT>' , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( default = '<STR_LIT>' , max_length = <NUM_LIT> , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . DecimalField ( default = '<STR_LIT>' , max_digits = <NUM_LIT:9> , decimal_places = <NUM_LIT:2> ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( related_name = '<STR_LIT>' , to = '<STR_LIT>' ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL>", "answer": ") ,"}, {"prompt": "<s> crayons = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' : '<STR_LIT>' ,"}, {"prompt": "<s> from zorro import Hub , zmq , mysql <EOL> hub = Hub ( ) <EOL> sql = mysql . Mysql ( host = '<STR_LIT:localhost>' , user = '<STR_LIT:test>' , database = '<STR_LIT>' ) <EOL> def replier ( uri ) : <EOL> uri = uri . decode ( '<STR_LIT:utf-8>' ) <EOL> sql . execute_prepared ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , uri ) <EOL> for row in sql . query_prepared ( <EOL> \"<STR_LIT>\" , uri ) : <EOL> nvisits = row [ <NUM_LIT:0> ] <EOL>", "answer": "return uri + '<STR_LIT:U+0020>' + str ( nvisits )"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field = models . TextField ( default = b'<STR_LIT>' , max_length = <NUM_LIT> , verbose_name = '<STR_LIT>' , blank = True ) , <EOL> preserve_default = True , <EOL> ) , <EOL> migrations . AddField ( <EOL>", "answer": "model_name = '<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import fileinput <EOL> class Rule : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , rulecount ) : <EOL> self . guard = Guard ( self ) <EOL> self . count = <NUM_LIT:0> <EOL> self . number = rulecount <EOL> self . index = <NUM_LIT:0> <EOL> def first ( self ) : <EOL> return self . guard . n <EOL> def last ( self ) : <EOL> return self . guard . p <EOL> def get_rules ( self ) : <EOL> rules = [ ] <EOL> processed_rules = <NUM_LIT:0> <EOL> text = \"<STR_LIT>\" <EOL> rules . append ( self ) <EOL> while processed_rules < len ( rules ) : <EOL>", "answer": "current_rule = rules [ processed_rules ]"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import datetime <EOL> import sqlalchemy as sa <EOL> from alembic import op <EOL> revision = '<STR_LIT>' <EOL> down_revision = '<STR_LIT>' <EOL> def upgrade ( ) : <EOL>", "answer": "last_login = sa . Column ( '<STR_LIT>' , sa . DateTime )"}, {"prompt": "<s> from pypi_notifier . models . user import User <EOL> from pypi_notifier . models . repo import Repo <EOL> from pypi_notifier . models . package import Package <EOL>", "answer": "from pypi_notifier . models . requirement import Requirement "}, {"prompt": "<s> import simplejson as json <EOL> from werkzeug . routing import BaseConverter <EOL> from eve . tests import TestBase , TestMinimal <EOL> from eve import Eve <EOL> from datetime import datetime <EOL> from eve . utils import config <EOL> from eve . io . base import BaseJSONEncoder <EOL> from eve . tests . test_settings import MONGO_DBNAME <EOL> from uuid import UUID <EOL> from eve . io . mongo import Validator <EOL> import os <EOL> class UUIDEncoder ( BaseJSONEncoder ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def default ( self , obj ) : <EOL> if isinstance ( obj , UUID ) : <EOL> return str ( obj ) <EOL> else : <EOL> return super ( UUIDEncoder , self ) . default ( obj ) <EOL> class UUIDConverter ( BaseConverter ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , url_map , strict = True ) : <EOL> super ( UUIDConverter , self ) . __init__ ( url_map ) <EOL> def to_python ( self , value ) : <EOL> return UUID ( value ) <EOL> def to_url ( self , value ) : <EOL> return str ( value ) <EOL> class UUIDValidator ( Validator ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _validate_type_uuid ( self , field , value ) : <EOL> try : <EOL> UUID ( value ) <EOL> except ValueError : <EOL> self . _error ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % ( value , field ) ) <EOL> class TestCustomConverters ( TestMinimal ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> uuids = { <EOL> '<STR_LIT>' : [ '<STR_LIT:GET>' , '<STR_LIT:POST>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT:GET>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : { '<STR_LIT:type>' : '<STR_LIT>' } , <EOL> '<STR_LIT:name>' : { '<STR_LIT:type>' : '<STR_LIT:string>' } <EOL> } <EOL> } <EOL> settings = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : uuids <EOL> } <EOL> } <EOL> url_converters = { '<STR_LIT>' : UUIDConverter } <EOL> self . uuid_valid = '<STR_LIT>' <EOL> self . url = '<STR_LIT>' % self . uuid_valid <EOL> self . headers = [ ( '<STR_LIT:Content-Type>' , '<STR_LIT:application/json>' ) ] <EOL> super ( TestCustomConverters , self ) . setUp ( settings_file = settings , <EOL> url_converters = url_converters ) <EOL> self . app . validator = UUIDValidator <EOL> self . app . data . json_encoder_class = UUIDEncoder <EOL> def bulk_insert ( self ) : <EOL> _db = self . connection [ MONGO_DBNAME ] <EOL> fake = { '<STR_LIT>' : UUID ( self . uuid_valid ) , } <EOL> _db . uuids . insert ( fake ) <EOL> def _get_etag ( self ) : <EOL> r = self . test_client . get ( self . url ) <EOL> self . assert200 ( r . status_code ) <EOL> return json . loads ( r . get_data ( ) ) [ config . ETAG ] <EOL> def test_get_uuid ( self ) : <EOL> r = self . test_client . get ( self . url ) <EOL> self . assertEqual ( r . status_code , <NUM_LIT:200> ) <EOL> def test_patch_uuid ( self ) : <EOL> etag = self . _get_etag ( ) <EOL> self . headers . append ( ( '<STR_LIT>' , etag ) ) <EOL> r = self . test_client . patch ( self . url , <EOL>", "answer": "data = json . dumps ( { \"<STR_LIT:name>\" : \"<STR_LIT>\" } ) ,"}, {"prompt": "<s> from django_authopenid import mimeparse <EOL> from django . http import HttpResponseRedirect <EOL> from django . core . urlresolvers import reverse <EOL> __all__ = [ \"<STR_LIT>\" ] <EOL> class OpenIDMiddleware ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def process_request ( self , request ) : <EOL> request . openid = request . session . get ( '<STR_LIT>' , None ) <EOL> def process_response ( self , request , response ) : <EOL> if response . status_code != <NUM_LIT:200> or len ( response . content ) < <NUM_LIT:200> : <EOL> return response <EOL> path = request . get_full_path ( ) <EOL> if path == \"<STR_LIT:/>\" and request . META . has_key ( '<STR_LIT>' ) and mimeparse . best_match ( [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL>", "answer": "request . META [ '<STR_LIT>' ] ) == '<STR_LIT>' :"}, {"prompt": "<s> import arrow <EOL> from flexmock import flexmock , flexmock_teardown <EOL> from ... import OratorTestCase <EOL> from orator . query . builder import QueryBuilder <EOL> from orator . query . grammars import QueryGrammar <EOL> from orator . query . expression import QueryExpression <EOL> from orator . orm . builder import Builder <EOL> from orator . orm . model import Model <EOL> from orator . orm . relations import HasMany <EOL> from orator . orm . collection import Collection <EOL> class OrmHasManyTestCase ( OratorTestCase ) : <EOL> def tearDown ( self ) : <EOL> flexmock_teardown ( ) <EOL> def test_create_properly_creates_new_model ( self ) : <EOL> relation = self . _get_relation ( ) <EOL> created = flexmock ( Model ( ) , save = lambda : True , set_attribute = lambda : None ) <EOL> created . should_receive ( '<STR_LIT>' ) . once ( ) . and_return ( True ) <EOL> relation . get_related ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( { '<STR_LIT:name>' : '<STR_LIT>' } ) . and_return ( created ) <EOL> created . should_receive ( '<STR_LIT>' ) . with_args ( '<STR_LIT>' , <NUM_LIT:1> ) <EOL> self . assertEqual ( created , relation . create ( name = '<STR_LIT>' ) ) <EOL> def test_find_or_new_finds_model ( self ) : <EOL> relation = self . _get_relation ( ) <EOL> model = flexmock ( ) <EOL> model . foo = '<STR_LIT:bar>' <EOL> relation . get_query ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( '<STR_LIT:foo>' , [ '<STR_LIT:*>' ] ) . and_return ( model ) <EOL> model . should_receive ( '<STR_LIT>' ) . never ( ) <EOL> self . assertEqual ( '<STR_LIT:bar>' , relation . find_or_new ( '<STR_LIT:foo>' ) . foo ) <EOL> def test_find_or_new_returns_new_model_with_foreign_key_set ( self ) : <EOL> relation = self . _get_relation ( ) <EOL> relation . get_query ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( '<STR_LIT:foo>' , [ '<STR_LIT:*>' ] ) . and_return ( None ) <EOL> model = flexmock ( ) <EOL> model . foo = '<STR_LIT:bar>' <EOL> relation . get_related ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( ) . and_return ( model ) <EOL> model . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( '<STR_LIT>' , <NUM_LIT:1> ) <EOL> self . assertEqual ( '<STR_LIT:bar>' , relation . find_or_new ( '<STR_LIT:foo>' ) . foo ) <EOL> def test_first_or_new_finds_first_model ( self ) : <EOL> relation = self . _get_relation ( ) <EOL> relation . get_query ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( { '<STR_LIT:foo>' : '<STR_LIT:bar>' } ) . and_return ( relation . get_query ( ) ) <EOL> model = flexmock ( ) <EOL> model . foo = '<STR_LIT:bar>' <EOL> relation . get_query ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( ) . and_return ( model ) <EOL> model . should_receive ( '<STR_LIT>' ) . never ( ) <EOL> self . assertEqual ( '<STR_LIT:bar>' , relation . first_or_new ( foo = '<STR_LIT:bar>' ) . foo ) <EOL> def test_first_or_new_returns_new_model_with_foreign_key_set ( self ) : <EOL> relation = self . _get_relation ( ) <EOL> relation . get_query ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( { '<STR_LIT:foo>' : '<STR_LIT:bar>' } ) . and_return ( relation . get_query ( ) ) <EOL> relation . get_query ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( ) . and_return ( None ) <EOL> model = flexmock ( ) <EOL> model . foo = '<STR_LIT:bar>' <EOL> relation . get_related ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( ) . and_return ( model ) <EOL> model . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( '<STR_LIT>' , <NUM_LIT:1> ) <EOL> self . assertEqual ( '<STR_LIT:bar>' , relation . first_or_new ( foo = '<STR_LIT:bar>' ) . foo ) <EOL> def test_first_or_create_finds_first_model ( self ) : <EOL> relation = self . _get_relation ( ) <EOL> relation . get_query ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( { '<STR_LIT:foo>' : '<STR_LIT:bar>' } ) . and_return ( relation . get_query ( ) ) <EOL> model = flexmock ( ) <EOL> model . foo = '<STR_LIT:bar>' <EOL> relation . get_query ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( ) . and_return ( model ) <EOL> model . should_receive ( '<STR_LIT>' ) . never ( ) <EOL> self . assertEqual ( '<STR_LIT:bar>' , relation . first_or_create ( foo = '<STR_LIT:bar>' ) . foo ) <EOL> def test_first_or_create_returns_new_model_with_foreign_key_set ( self ) : <EOL> relation = self . _get_relation ( ) <EOL> relation . get_query ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( { '<STR_LIT:foo>' : '<STR_LIT:bar>' } ) . and_return ( relation . get_query ( ) ) <EOL> relation . get_query ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( ) . and_return ( None ) <EOL> model = flexmock ( ) <EOL> model . foo = '<STR_LIT:bar>' <EOL> relation . get_related ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( { '<STR_LIT:foo>' : '<STR_LIT:bar>' } ) . and_return ( model ) <EOL> model . should_receive ( '<STR_LIT>' ) . once ( ) . and_return ( True ) <EOL> model . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( '<STR_LIT>' , <NUM_LIT:1> ) <EOL> self . assertEqual ( '<STR_LIT:bar>' , relation . first_or_create ( foo = '<STR_LIT:bar>' ) . foo ) <EOL> def test_update_or_create_finds_first_model_and_updates ( self ) : <EOL> relation = self . _get_relation ( ) <EOL> relation . get_query ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( { '<STR_LIT:foo>' : '<STR_LIT:bar>' } ) . and_return ( relation . get_query ( ) ) <EOL> model = flexmock ( ) <EOL> model . foo = '<STR_LIT:bar>' <EOL> relation . get_query ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( ) . and_return ( model ) <EOL> relation . get_related ( ) . should_receive ( '<STR_LIT>' ) . never ( ) <EOL> model . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( { '<STR_LIT:foo>' : '<STR_LIT>' } ) <EOL> model . should_receive ( '<STR_LIT>' ) . once ( ) <EOL> self . assertEqual ( '<STR_LIT:bar>' , relation . update_or_create ( { '<STR_LIT:foo>' : '<STR_LIT:bar>' } , { '<STR_LIT:foo>' : '<STR_LIT>' } ) . foo ) <EOL> def test_update_or_create_creates_new_model_with_foreign_key_set ( self ) : <EOL> relation = self . _get_relation ( ) <EOL> relation . get_query ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( { '<STR_LIT:foo>' : '<STR_LIT:bar>' } ) . and_return ( relation . get_query ( ) ) <EOL>", "answer": "relation . get_query ( ) . should_receive ( '<STR_LIT>' ) . once ( ) . with_args ( ) . and_return ( None )"}, {"prompt": "<s> from __future__ import print_function <EOL> import os <EOL> import time <EOL> import wave <EOL> import sys <EOL> import pprint <EOL> import pyaudio <EOL> import pygame <EOL> import pygame . camera <EOL> from guild . actor import * <EOL> pygame . init ( ) <EOL> pygame . camera . init ( ) <EOL> modes = { <EOL> \"<STR_LIT>\" : ( ) , <EOL> \"<STR_LIT>\" : ( ) , <EOL> \"<STR_LIT>\" : ( ) <EOL> } <EOL> vidsize = ( <NUM_LIT> , <NUM_LIT> ) <EOL> p = pyaudio . PyAudio ( ) <EOL> class AudioCapture ( Actor ) : <EOL> def gen_process ( self ) : <EOL> global p <EOL> yield <NUM_LIT:1> <EOL> CHUNK = <NUM_LIT> <EOL> FORMAT = pyaudio . paInt16 <EOL> RECORD_SECONDS = <NUM_LIT:5> <EOL> device_count = p . get_device_count ( ) <EOL> devices = { } <EOL> for i in range ( device_count ) : <EOL> info = p . get_device_info_by_index ( i ) <EOL> devices [ info [ \"<STR_LIT:name>\" ] ] = info <EOL> device_names = [ x for x in devices . keys ( ) if ( ( \"<STR_LIT>\" in x ) and ( \"<STR_LIT>\" in x ) ) ] <EOL> device = devices [ device_names [ <NUM_LIT:0> ] ] <EOL> RATE = int ( device . get ( \"<STR_LIT>\" , <NUM_LIT> ) ) <EOL> CHANNELS = int ( device . get ( \"<STR_LIT>\" , <NUM_LIT:2> ) ) <EOL> DEVICE_INDEX = int ( device . get ( \"<STR_LIT:index>\" , <NUM_LIT:0> ) ) <EOL> stream = p . open ( format = FORMAT , <EOL> channels = CHANNELS , <EOL> rate = RATE , <EOL> input = True , <EOL> input_device_index = DEVICE_INDEX , <EOL> frames_per_buffer = CHUNK ) <EOL> print ( \"<STR_LIT>\" ) <EOL> frames = [ ] <EOL> for i in range ( <NUM_LIT:0> , int ( RATE / CHUNK * RECORD_SECONDS ) ) : <EOL> data = stream . read ( CHUNK ) <EOL> self . output ( data , time . time ( ) ) <EOL> yield <NUM_LIT:1> <EOL> self . output ( None , <NUM_LIT:0> ) <EOL> print ( \"<STR_LIT>\" ) <EOL> stream . stop_stream ( ) <EOL> stream . close ( ) <EOL> p . terminate ( ) <EOL> @ late_bind <EOL> def output ( self , frame , timestamp ) : <EOL> pass <EOL> class WaveWriter ( Actor ) : <EOL> def __init__ ( self ) : <EOL> self . frames = [ ] <EOL> self . CHANNELS = <NUM_LIT:1> <EOL> self . FORMAT = pyaudio . paInt16 <EOL> self . WAVE_OUTPUT_FILENAME = \"<STR_LIT>\" <EOL> self . RATE = <NUM_LIT> <EOL> super ( WaveWriter , self ) . __init__ ( ) <EOL> @ actor_method <EOL> def record ( self , audio , timestamp ) : <EOL> global p <EOL> if audio != None : <EOL> self . frames . append ( audio ) <EOL> else : <EOL> wf = wave . open ( self . WAVE_OUTPUT_FILENAME , '<STR_LIT:wb>' ) <EOL> wf . setnchannels ( self . CHANNELS ) <EOL> wf . setsampwidth ( p . get_sample_size ( self . FORMAT ) ) <EOL> wf . setframerate ( self . RATE ) <EOL> wf . writeframes ( b'<STR_LIT>' . join ( self . frames ) ) <EOL> wf . close ( ) <EOL> self . stop ( ) <EOL> class WebCamTest ( Actor ) : <EOL> def gen_process ( self ) : <EOL> device = \"<STR_LIT>\" <EOL> capturesize = vidsize <EOL> camera = pygame . camera . Camera ( device , capturesize ) <EOL> camera . start ( ) <EOL> count = <NUM_LIT:0> <EOL> ts = time . time ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> while True : <EOL> time . sleep ( <NUM_LIT> ) <EOL> yield <NUM_LIT:1> <EOL> count += <NUM_LIT:1> <EOL> snapshot = camera . get_image ( ) <EOL> now = time . time ( ) <EOL> try : <EOL> self . produce ( snapshot , now ) <EOL> except : <EOL> pass <EOL> if count > <NUM_LIT:30> : <EOL> print ( ts , time . time ( ) , \"<STR_LIT>\" , count , end = \"<STR_LIT>\" ) <EOL> dur = time . time ( ) - ts <EOL> if dur > <NUM_LIT:0> : <EOL>", "answer": "print ( \"<STR_LIT>\" , count / ( time . time ( ) - ts ) )"}, {"prompt": "<s> from . . builder import build_fn <EOL> from . . ndtypes import ( NoneT , ScalarT , Int64 , SliceT , TupleT , NoneType , repeat_tuple ) <EOL> from . . syntax import Index , Tuple , Var , ArrayView <EOL> from . . syntax . helpers import zero_i64 , one_i64 , all_scalars , slice_none , none <EOL> from transform import Transform <EOL> from phase import Phase <EOL> class LowerSlices ( Transform ) : <EOL> _setidx_cache = { } <EOL> def make_setidx_fn ( self , lhs_array_type , <EOL> rhs_value_type , <EOL> fixed_positions , <EOL> slice_positions ) : <EOL> fixed_positions = tuple ( fixed_positions ) <EOL> slice_positions = tuple ( slice_positions ) <EOL> key = lhs_array_type , rhs_value_type , fixed_positions , slice_positions <EOL> if key in self . _setidx_cache : <EOL> return self . _setidx_cache [ key ] <EOL> n_fixed_indices = len ( fixed_positions ) <EOL> n_parfor_indices = len ( slice_positions ) <EOL> n_indices = n_fixed_indices + n_parfor_indices <EOL> parfor_idx_t = repeat_tuple ( Int64 , n_parfor_indices ) if n_parfor_indices > <NUM_LIT:1> else Int64 <EOL> fixed_index_types = [ Int64 ] * n_fixed_indices <EOL> slice_start_types = [ Int64 ] * n_parfor_indices <EOL> slice_step_types = [ Int64 ] * n_parfor_indices <EOL> input_types = [ lhs_array_type , rhs_value_type ] + fixed_index_types + slice_start_types + slice_step_types + [ parfor_idx_t ] <EOL> name = \"<STR_LIT>\" % ( lhs_array_type . rank , lhs_array_type . elt_type , n_parfor_indices ) <EOL> idx_names = [ \"<STR_LIT>\" % ( i + <NUM_LIT:1> ) for i in xrange ( n_fixed_indices ) ] <EOL> start_names = [ \"<STR_LIT>\" % ( i + <NUM_LIT:1> ) for i in xrange ( n_parfor_indices ) ] <EOL> step_names = [ \"<STR_LIT>\" % ( i + <NUM_LIT:1> ) for i in xrange ( n_parfor_indices ) ] <EOL> input_names = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] + idx_names + start_names + step_names + [ \"<STR_LIT>\" ] <EOL> fn , builder , input_vars = build_fn ( input_types , NoneType , name , input_names ) <EOL> lhs = input_vars [ <NUM_LIT:0> ] <EOL> rhs = input_vars [ <NUM_LIT:1> ] <EOL> fixed_indices = input_vars [ <NUM_LIT:2> : ( <NUM_LIT:2> + n_fixed_indices ) ] <EOL> starts = input_vars [ ( <NUM_LIT:2> + n_fixed_indices ) : ( <NUM_LIT:2> + n_fixed_indices + n_parfor_indices ) ] <EOL> steps = input_vars [ ( <NUM_LIT:2> + n_fixed_indices + n_parfor_indices ) : ( <NUM_LIT:2> + n_fixed_indices + <NUM_LIT:2> * n_parfor_indices ) ] <EOL> assert ( <NUM_LIT:2> + n_fixed_indices + <NUM_LIT:2> * n_parfor_indices + <NUM_LIT:1> ) == len ( input_vars ) , \"<STR_LIT>\" % ( input_vars , <NUM_LIT:2> + n_fixed_indices + <NUM_LIT:2> * n_parfor_indices + <NUM_LIT:1> , len ( input_vars ) ) <EOL> parfor_idx = input_vars [ - <NUM_LIT:1> ] <EOL> if n_parfor_indices > <NUM_LIT:1> : <EOL> parfor_indices = builder . tuple_elts ( parfor_idx ) <EOL> else : <EOL> parfor_indices = [ parfor_idx ] <EOL> indices = [ ] <EOL> slice_counter = <NUM_LIT:0> <EOL> fixed_counter = <NUM_LIT:0> <EOL> for i in xrange ( n_indices ) : <EOL> if fixed_counter < len ( fixed_positions ) and i == fixed_positions [ fixed_counter ] : <EOL> indices . append ( fixed_indices [ fixed_counter ] ) <EOL> fixed_counter += <NUM_LIT:1> <EOL> else : <EOL> assert slice_counter < len ( slice_positions ) and slice_positions [ slice_counter ] == i , \"<STR_LIT>\" % i <EOL> start = starts [ slice_counter ] <EOL> step = steps [ slice_counter ] <EOL> parfor_idx = parfor_indices [ slice_counter ] <EOL> indices . append ( builder . add ( start , builder . mul ( step , parfor_idx ) ) ) <EOL> slice_counter += <NUM_LIT:1> <EOL> value = builder . index ( rhs , parfor_indices ) <EOL> builder . setidx ( lhs , builder . tuple ( indices ) , value ) <EOL> builder . return_ ( none ) <EOL> self . _setidx_cache [ key ] = fn <EOL> return fn <EOL> def dissect_index_expr ( self , expr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( expr . index . type , TupleT ) : <EOL> indices = self . tuple_elts ( expr . index ) <EOL> else : <EOL> indices = [ expr . index ] <EOL> n_dims = expr . value . type . rank <EOL> n_indices = len ( indices ) <EOL> assert n_dims >= n_indices , \"<STR_LIT>\" % ( n_indices , n_dims , expr ) <EOL> if n_indices < n_dims : <EOL> indices = indices + [ slice_none ] * ( n_dims - n_indices ) <EOL> if all_scalars ( indices ) : <EOL> return indices , range ( len ( indices ) ) , [ ] , [ ] <EOL> shape = self . shape ( expr . value ) <EOL> shape_elts = self . tuple_elts ( shape ) <EOL> slices = [ ] <EOL> slice_positions = [ ] <EOL> scalar_indices = [ ] <EOL> scalar_index_positions = [ ] <EOL> for i , shape_elt in enumerate ( shape_elts ) : <EOL> idx = indices [ i ] <EOL> t = idx . type <EOL> if isinstance ( t , ScalarT ) : <EOL>", "answer": "scalar_indices . append ( idx )"}, {"prompt": "<s> import os <EOL> from collections import deque <EOL> def split_path_into_components ( path ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> import time <EOL> from twisted . trial import unittest <EOL>", "answer": "from twisted . names import dns , cache"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from rlpy . Tools import vec2id <EOL> from . Policy import Policy <EOL> import numpy as np <EOL> from rlpy . Tools import randSet , className <EOL> __copyright__ = \"<STR_LIT>\" <EOL> __credits__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> __license__ = \"<STR_LIT>\" <EOL> __author__ = \"<STR_LIT>\" <EOL> class BasicPuddlePolicy ( Policy ) : <EOL> __author__ = \"<STR_LIT>\" <EOL> def __init__ ( self , seed = <NUM_LIT:1> , * args , ** kwargs ) : <EOL> self . random_state = np . random . RandomState ( ) <EOL> def pi ( self , s , terminal , p_actions ) : <EOL> assert ( len ( s ) == <NUM_LIT:2> ) <EOL> if <NUM_LIT:0> not in p_actions : <EOL> assert ( <NUM_LIT:1> in p_actions ) <EOL> return <NUM_LIT:1> <EOL> if <NUM_LIT:1> not in p_actions : <EOL> assert ( <NUM_LIT:0> in p_actions ) <EOL> return <NUM_LIT:0> <EOL> d = np . ones ( <NUM_LIT:2> ) - s <EOL> if self . random_state . rand ( ) * d . sum ( ) < d [ <NUM_LIT:0> ] : <EOL> return <NUM_LIT:0> <EOL> else : <EOL> return <NUM_LIT:1> <EOL> def __getstate__ ( self ) : <EOL> return self . __dict__ <EOL> class FixedPolicy ( Policy ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> policyName = '<STR_LIT>' <EOL> tableOfValues = None <EOL> gridWorldPolicyNames = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL>", "answer": "def __init__ ( self , representation ,"}, {"prompt": "<s> from __future__ import absolute_import , print_function , division <EOL> import itertools <EOL> from petl . compat import next , text_type <EOL> from petl . errors import FieldSelectionError <EOL> from petl . util . base import Table , asindices , rowgetter <EOL> def rename ( table , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return RenameView ( table , * args , ** kwargs ) <EOL> Table . rename = rename <EOL> class RenameView ( Table ) : <EOL> def __init__ ( self , table , * args , ** kwargs ) : <EOL> self . source = table <EOL> if len ( args ) == <NUM_LIT:0> : <EOL> self . spec = dict ( ) <EOL> elif len ( args ) == <NUM_LIT:1> : <EOL> self . spec = args [ <NUM_LIT:0> ] <EOL> elif len ( args ) == <NUM_LIT:2> : <EOL> self . spec = { args [ <NUM_LIT:0> ] : args [ <NUM_LIT:1> ] } <EOL> self . strict = kwargs . get ( '<STR_LIT:strict>' , True ) <EOL> def __iter__ ( self ) : <EOL> return iterrename ( self . source , self . spec , self . strict ) <EOL> def __setitem__ ( self , key , value ) : <EOL> self . spec [ key ] = value <EOL> def iterrename ( source , spec , strict ) : <EOL> it = iter ( source ) <EOL> hdr = next ( it ) <EOL> flds = list ( map ( text_type , hdr ) ) <EOL> if strict : <EOL> for x in spec : <EOL> if isinstance ( x , int ) : <EOL> if x < <NUM_LIT:0> or x >= len ( hdr ) : <EOL> raise FieldSelectionError ( x ) <EOL> elif x not in flds : <EOL> raise FieldSelectionError ( x ) <EOL>", "answer": "outhdr = [ spec [ i ] if i in spec"}, {"prompt": "<s> from sympy . matrices . densesolve import LU_solve , rref_solve , cholesky_solve <EOL> from sympy import Dummy <EOL> from sympy import QQ <EOL> def test_LU_solve ( ) : <EOL>", "answer": "x , y , z = Dummy ( '<STR_LIT:x>' ) , Dummy ( '<STR_LIT:y>' ) , Dummy ( '<STR_LIT:z>' )"}, {"prompt": "<s> from arangodb . api import Database , Collection <EOL> from arangodb . query . simple import SimpleQuery <EOL> from arangodb . tests . base import ExtendedTestCase <EOL> class SimpleQueryTestCase ( ExtendedTestCase ) : <EOL> def setUp ( self ) : <EOL> self . database_name = '<STR_LIT>' <EOL> self . db = Database . create ( name = self . database_name ) <EOL> self . test_1_col = self . db . create_collection ( '<STR_LIT>' ) <EOL> self . test_2_col = self . db . create_collection ( '<STR_LIT>' ) <EOL> self . col1_doc1 = self . test_1_col . create_document ( ) <EOL> self . col1_doc1 . ta = '<STR_LIT>' <EOL> self . col1_doc1 . bla = '<STR_LIT>' <EOL> self . col1_doc1 . save ( ) <EOL> self . col1_doc2 = self . test_1_col . create_document ( ) <EOL> self . col1_doc2 . ta = '<STR_LIT>' <EOL> self . col1_doc2 . bla = '<STR_LIT>' <EOL> self . col1_doc2 . save ( ) <EOL> self . col2_doc1 = self . test_2_col . create_document ( ) <EOL> self . col2_doc1 . save ( ) <EOL> def tearDown ( self ) : <EOL> Collection . remove ( name = self . test_1_col . name ) <EOL> Collection . remove ( name = self . test_2_col . name ) <EOL> Database . remove ( name = self . database_name ) <EOL>", "answer": "def test_get_document_by_example ( self ) :"}, {"prompt": "<s> from django . contrib . gis . sitemaps . georss import GeoRSSSitemap <EOL>", "answer": "from django . contrib . gis . sitemaps . kml import KMLSitemap , KMZSitemap "}, {"prompt": "<s> from wtforms . fields . core import * <EOL> from wtforms . fields . simple import * <EOL>", "answer": "from wtforms . fields . core import Label , Field , _unset_value , SelectFieldBase , Flags "}, {"prompt": "<s> from south . db import db <EOL> from django . db import models <EOL> from transifex . languages . models import Language <EOL> class Migration : <EOL> def forwards ( self , orm ) : <EOL> db . create_table ( '<STR_LIT>' , ( <EOL> ( '<STR_LIT>' , models . CharField ( _ ( '<STR_LIT>' ) , default = '<STR_LIT>' , max_length = <NUM_LIT:100> , null = True ) ) , <EOL> ( '<STR_LIT:code>' , models . CharField ( _ ( '<STR_LIT>' ) , max_length = <NUM_LIT:50> , unique = True ) ) , <EOL> ( '<STR_LIT:description>' , models . CharField ( _ ( '<STR_LIT>' ) , max_length = <NUM_LIT:255> , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( _ ( \"<STR_LIT>\" ) , max_length = <NUM_LIT:255> , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . SmallIntegerField ( _ ( \"<STR_LIT>\" ) , default = <NUM_LIT:0> ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( _ ( \"<STR_LIT>\" ) , max_length = <NUM_LIT:255> , blank = True ) ) , <EOL> ( '<STR_LIT:id>' , models . AutoField ( primary_key = True ) ) , <EOL> ( '<STR_LIT:name>' , models . CharField ( _ ( '<STR_LIT:Name>' ) , max_length = <NUM_LIT:50> , unique = True ) ) , <EOL> ) ) <EOL> db . send_create_signal ( '<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> def backwards ( self , orm ) : <EOL> db . delete_table ( '<STR_LIT>' ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT:code>' : ( '<STR_LIT>' , [ \"<STR_LIT>\" ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ \"<STR_LIT>\" ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT:100>' , '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:description>' : ( '<STR_LIT>' , [ \"<STR_LIT>\" ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ \"<STR_LIT>\" ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ '<STR_LIT>' ] , { '<STR_LIT:default>' : '<STR_LIT:0>' } ) , <EOL>", "answer": "'<STR_LIT>' : ( '<STR_LIT>' , [ '<STR_LIT>' ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) ,"}, {"prompt": "<s> from flask_table import Table , Col <EOL> class Item ( object ) : <EOL> def __init__ ( self , name , language ) : <EOL> self . name = name <EOL> self . language = language <EOL> class LangCol ( Col ) : <EOL> def td_format ( self , content ) : <EOL> if content == '<STR_LIT>' : <EOL> return '<STR_LIT>' <EOL> elif content == '<STR_LIT>' : <EOL> return '<STR_LIT>' <EOL> elif content == '<STR_LIT>' : <EOL> return '<STR_LIT>' <EOL>", "answer": "else :"}, {"prompt": "<s> from unittest import TestCase <EOL> from cleo . testers . command_tester import CommandTester <EOL> from cleo . commands . command import Command <EOL> from cleo . outputs . output import Output <EOL> class TestCommandTester ( TestCase ) : <EOL> def setUp ( self ) : <EOL> self . command = Command ( '<STR_LIT:foo>' ) <EOL> self . command . add_argument ( '<STR_LIT>' ) <EOL>", "answer": "self . command . add_argument ( '<STR_LIT:foo>' )"}, {"prompt": "<s> import sys <EOL> from setuptools import setup , find_packages <EOL> requires = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> if ( <NUM_LIT:3> , <NUM_LIT:0> ) <= sys . version_info < ( <NUM_LIT:3> , <NUM_LIT:3> ) : <EOL> raise SystemExit ( \"<STR_LIT>\" ) <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> packages = find_packages ( ) , <EOL> include_package_data = True , <EOL> zip_safe = False , <EOL> url = '<STR_LIT>' , <EOL> license = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL>", "answer": "classifiers = ["}, {"prompt": "<s> if '<STR_LIT>' in dir ( __builtins__ ) : <EOL> input = raw_input <EOL> def ler_num ( ) : <EOL> num = input ( '<STR_LIT>' ) <EOL> try : <EOL> num = float ( num ) <EOL> except ValueError : <EOL> return <NUM_LIT:0> <EOL> return num <EOL> def somadora ( ) : <EOL> qt_parcelas = <NUM_LIT:0> <EOL> total = <NUM_LIT:0> <EOL> try : <EOL> while True : <EOL> parcela = yield <EOL> qt_parcelas += <NUM_LIT:1> <EOL> total += parcela <EOL> print ( '<STR_LIT>' % ( qt_parcelas , total ) ) <EOL> finally : <EOL> print ( '<STR_LIT>' % ( qt_parcelas , total , total / qt_parcelas ) ) <EOL> def main ( ) : <EOL> coro = somadora ( ) <EOL> next ( coro ) <EOL>", "answer": "while True :"}, {"prompt": "<s> from boto . exception import JSONResponseError <EOL> class PipelineDeletedException ( JSONResponseError ) : <EOL> pass <EOL> class InvalidRequestException ( JSONResponseError ) : <EOL> pass <EOL> class TaskNotFoundException ( JSONResponseError ) : <EOL>", "answer": "pass"}, {"prompt": "<s> \"<STR_LIT>\" <EOL> __version__ = \"<STR_LIT>\" <EOL> import unittest <EOL> import os <EOL> import datetime <EOL> import mplStyle . types . convert as cvt <EOL> class TesttoDateTime ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def setUp ( self ) :"}, {"prompt": "<s> from __future__ import absolute_import , print_function , unicode_literals <EOL> from cms . sitemaps import CMSSitemap <EOL> from django . conf import settings <EOL>", "answer": "from django . conf . urls import include , url"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from __future__ import absolute_import <EOL> import os <EOL> import shutil <EOL> import salt . utils <EOL> import salt . ext . six as six <EOL> try : <EOL> import portage <EOL> HAS_PORTAGE = True <EOL> except ImportError : <EOL> HAS_PORTAGE = False <EOL> import sys <EOL> if os . path . isdir ( '<STR_LIT>' ) : <EOL> try : <EOL> sys . path . insert ( <NUM_LIT:0> , '<STR_LIT>' ) <EOL> import portage <EOL> HAS_PORTAGE = True <EOL> except ImportError : <EOL> pass <EOL> BASE_PATH = '<STR_LIT>' <EOL> SUPPORTED_CONFS = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __virtual__ ( ) : <EOL> '''<STR_LIT>''' <EOL> if HAS_PORTAGE and __grains__ [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> return '<STR_LIT>' <EOL> return ( False , '<STR_LIT>' ) <EOL> def _get_portage ( ) : <EOL> '''<STR_LIT>''' <EOL> return reload ( portage ) <EOL> def _porttree ( ) : <EOL> return portage . db [ portage . root ] [ '<STR_LIT>' ] <EOL> def _get_config_file ( conf , atom ) : <EOL> '''<STR_LIT>''' <EOL> if '<STR_LIT:*>' in atom : <EOL> parts = portage . dep . Atom ( atom , allow_wildcard = True ) <EOL> if not parts : <EOL> return <EOL> if parts . cp == '<STR_LIT>' : <EOL> relative_path = parts . repo or \"<STR_LIT>\" <EOL> else : <EOL> relative_path = os . path . join ( * [ x for x in os . path . split ( parts . cp ) if x != '<STR_LIT:*>' ] ) <EOL> else : <EOL> relative_path = _p_to_cp ( atom ) <EOL> if not relative_path : <EOL> return <EOL> complete_file_path = BASE_PATH . format ( conf ) + '<STR_LIT:/>' + relative_path <EOL> return complete_file_path <EOL> def _p_to_cp ( p ) : <EOL> '''<STR_LIT>''' <EOL> ret = _porttree ( ) . dbapi . xmatch ( \"<STR_LIT>\" , p ) <EOL> if ret : <EOL> return portage . cpv_getkey ( ret [ <NUM_LIT:0> ] ) <EOL> return None <EOL> def _get_cpv ( cp , installed = True ) : <EOL> '''<STR_LIT>''' <EOL> if installed : <EOL> return _get_portage ( ) . db [ portage . root ] [ '<STR_LIT>' ] . dep_bestmatch ( cp ) <EOL> else : <EOL> return _porttree ( ) . dep_bestmatch ( cp ) <EOL> def enforce_nice_config ( ) : <EOL> '''<STR_LIT>''' <EOL> _convert_all_package_confs_to_dir ( ) <EOL> _order_all_package_confs ( ) <EOL> def _convert_all_package_confs_to_dir ( ) : <EOL> '''<STR_LIT>''' <EOL> for conf_file in SUPPORTED_CONFS : <EOL> _package_conf_file_to_dir ( conf_file ) <EOL> def _order_all_package_confs ( ) : <EOL> '''<STR_LIT>''' <EOL> for conf_file in SUPPORTED_CONFS : <EOL> _package_conf_ordering ( conf_file ) <EOL> _unify_keywords ( ) <EOL> def _unify_keywords ( ) : <EOL> '''<STR_LIT>''' <EOL> old_path = BASE_PATH . format ( '<STR_LIT>' ) <EOL> if os . path . exists ( old_path ) : <EOL> if os . path . isdir ( old_path ) : <EOL> for triplet in os . walk ( old_path ) : <EOL> for file_name in triplet [ <NUM_LIT:2> ] : <EOL> file_path = '<STR_LIT>' . format ( triplet [ <NUM_LIT:0> ] , file_name ) <EOL> with salt . utils . fopen ( file_path ) as fh_ : <EOL> for line in fh_ : <EOL> line = line . strip ( ) <EOL> if line and not line . startswith ( '<STR_LIT:#>' ) : <EOL> append_to_package_conf ( <EOL> '<STR_LIT>' , string = line ) <EOL> shutil . rmtree ( old_path ) <EOL> else : <EOL> with salt . utils . fopen ( old_path ) as fh_ : <EOL> for line in fh_ : <EOL> line = line . strip ( ) <EOL> if line and not line . startswith ( '<STR_LIT:#>' ) : <EOL> append_to_package_conf ( '<STR_LIT>' , string = line ) <EOL> os . remove ( old_path ) <EOL> def _package_conf_file_to_dir ( file_name ) : <EOL> '''<STR_LIT>''' <EOL> if file_name in SUPPORTED_CONFS : <EOL> path = BASE_PATH . format ( file_name ) <EOL> if os . path . exists ( path ) : <EOL> if os . path . isdir ( path ) : <EOL> return False <EOL> else : <EOL> os . rename ( path , path + '<STR_LIT>' ) <EOL> os . mkdir ( path , <NUM_LIT> ) <EOL> with salt . utils . fopen ( path + '<STR_LIT>' ) as fh_ : <EOL> for line in fh_ : <EOL> line = line . strip ( ) <EOL> if line and not line . startswith ( '<STR_LIT:#>' ) : <EOL> append_to_package_conf ( file_name , string = line ) <EOL> os . remove ( path + '<STR_LIT>' ) <EOL> return True <EOL> else : <EOL> os . mkdir ( path , <NUM_LIT> ) <EOL> return True <EOL> def _package_conf_ordering ( conf , clean = True , keep_backup = False ) : <EOL> '''<STR_LIT>''' <EOL> if conf in SUPPORTED_CONFS : <EOL> rearrange = [ ] <EOL> path = BASE_PATH . format ( conf ) <EOL> backup_files = [ ] <EOL> for triplet in os . walk ( path ) : <EOL> for file_name in triplet [ <NUM_LIT:2> ] : <EOL> file_path = '<STR_LIT>' . format ( triplet [ <NUM_LIT:0> ] , file_name ) <EOL> cp = triplet [ <NUM_LIT:0> ] [ len ( path ) + <NUM_LIT:1> : ] + '<STR_LIT:/>' + file_name <EOL> shutil . copy ( file_path , file_path + '<STR_LIT>' ) <EOL> backup_files . append ( file_path + '<STR_LIT>' ) <EOL> if cp [ <NUM_LIT:0> ] == '<STR_LIT:/>' or cp . split ( '<STR_LIT:/>' ) > <NUM_LIT:2> : <EOL> rearrange . extend ( list ( salt . utils . fopen ( file_path ) ) ) <EOL> os . remove ( file_path ) <EOL> else : <EOL> new_contents = '<STR_LIT>' <EOL> with salt . utils . fopen ( file_path , '<STR_LIT>' ) as file_handler : <EOL> for line in file_handler : <EOL> try : <EOL> atom = line . strip ( ) . split ( ) [ <NUM_LIT:0> ] <EOL> except IndexError : <EOL> new_contents += line <EOL> else : <EOL> if atom [ <NUM_LIT:0> ] == '<STR_LIT:#>' or portage . dep_getkey ( atom ) == cp : <EOL> new_contents += line <EOL> else : <EOL> rearrange . append ( line . strip ( ) ) <EOL> if len ( new_contents ) != <NUM_LIT:0> : <EOL> file_handler . seek ( <NUM_LIT:0> ) <EOL> file_handler . truncate ( len ( new_contents ) ) <EOL> file_handler . write ( new_contents ) <EOL> if len ( new_contents ) == <NUM_LIT:0> : <EOL> os . remove ( file_path ) <EOL> for line in rearrange : <EOL> append_to_package_conf ( conf , string = line ) <EOL> if not keep_backup : <EOL> for bfile in backup_files : <EOL> try : <EOL> os . remove ( bfile ) <EOL> except OSError : <EOL> pass <EOL> if clean : <EOL> for triplet in os . walk ( path ) : <EOL> if len ( triplet [ <NUM_LIT:1> ] ) == <NUM_LIT:0> and len ( triplet [ <NUM_LIT:2> ] ) == <NUM_LIT:0> and triplet [ <NUM_LIT:0> ] != path : <EOL> shutil . rmtree ( triplet [ <NUM_LIT:0> ] ) <EOL> def _check_accept_keywords ( approved , flag ) : <EOL> '''<STR_LIT>''' <EOL> if flag in approved : <EOL> return False <EOL> elif ( flag . startswith ( '<STR_LIT>' ) and flag [ <NUM_LIT:1> : ] in approved ) or ( '<STR_LIT>' + flag in approved ) : <EOL> return False <EOL> else : <EOL> return True <EOL> def _merge_flags ( new_flags , old_flags = None , conf = '<STR_LIT>' ) : <EOL> '''<STR_LIT>''' <EOL> if not old_flags : <EOL> old_flags = [ ] <EOL> args = [ old_flags , new_flags ] <EOL> if conf == '<STR_LIT>' : <EOL> tmp = new_flags + [ i for i in old_flags if _check_accept_keywords ( new_flags , i ) ] <EOL> else : <EOL> tmp = portage . flatten ( args ) <EOL> flags = { } <EOL> for flag in tmp : <EOL> if flag [ <NUM_LIT:0> ] == '<STR_LIT:->' : <EOL> flags [ flag [ <NUM_LIT:1> : ] ] = False <EOL> else : <EOL> flags [ flag ] = True <EOL> tmp = [ ] <EOL> for key , val in six . iteritems ( flags ) : <EOL> if val : <EOL> tmp . append ( key ) <EOL> else : <EOL> tmp . append ( '<STR_LIT:->' + key ) <EOL> tmp . sort ( cmp = lambda x , y : cmp ( x . lstrip ( '<STR_LIT:->' ) , y . lstrip ( '<STR_LIT:->' ) ) ) <EOL> return tmp <EOL> def append_to_package_conf ( conf , atom = '<STR_LIT>' , flags = None , string = '<STR_LIT>' , overwrite = False ) : <EOL> '''<STR_LIT>''' <EOL> if flags is None : <EOL> flags = [ ] <EOL> if conf in SUPPORTED_CONFS : <EOL> if not string : <EOL> if '<STR_LIT:/>' not in atom : <EOL> atom = _p_to_cp ( atom ) <EOL> if not atom : <EOL> return <EOL> string = '<STR_LIT>' . format ( atom , '<STR_LIT:U+0020>' . join ( flags ) ) <EOL> new_flags = list ( flags ) <EOL> else : <EOL> atom = string . strip ( ) . split ( ) [ <NUM_LIT:0> ] <EOL> new_flags = [ flag for flag in string . strip ( ) . split ( '<STR_LIT:U+0020>' ) if flag ] [ <NUM_LIT:1> : ] <EOL> if '<STR_LIT:/>' not in atom : <EOL> atom = _p_to_cp ( atom ) <EOL> string = '<STR_LIT>' . format ( atom , '<STR_LIT:U+0020>' . join ( new_flags ) ) <EOL> if not atom : <EOL> return <EOL> to_delete_if_empty = [ ] <EOL> if conf == '<STR_LIT>' : <EOL> if '<STR_LIT>' in new_flags : <EOL> new_flags . remove ( '<STR_LIT>' ) <EOL> to_delete_if_empty . append ( atom ) <EOL> if '<STR_LIT>' in new_flags : <EOL> new_flags . remove ( '<STR_LIT>' ) <EOL> append_to_package_conf ( conf , string = atom , overwrite = overwrite ) <EOL> if not new_flags : <EOL> return <EOL> new_flags . sort ( cmp = lambda x , y : cmp ( x . lstrip ( '<STR_LIT:->' ) , y . lstrip ( '<STR_LIT:->' ) ) ) <EOL> complete_file_path = _get_config_file ( conf , atom ) <EOL> pdir = os . path . dirname ( complete_file_path ) <EOL> if not os . path . exists ( pdir ) : <EOL> os . makedirs ( pdir , <NUM_LIT> ) <EOL> try : <EOL> shutil . copy ( complete_file_path , complete_file_path + '<STR_LIT>' ) <EOL> except IOError : <EOL> pass <EOL> try : <EOL> file_handler = salt . utils . fopen ( complete_file_path , '<STR_LIT>' ) <EOL> except IOError : <EOL> file_handler = salt . utils . fopen ( complete_file_path , '<STR_LIT>' ) <EOL> new_contents = '<STR_LIT>' <EOL> added = False <EOL> for l in file_handler : <EOL> l_strip = l . strip ( ) <EOL> if l_strip == '<STR_LIT>' : <EOL> new_contents += '<STR_LIT:\\n>' <EOL> elif l_strip [ <NUM_LIT:0> ] == '<STR_LIT:#>' : <EOL> new_contents += l <EOL> elif l_strip . split ( ) [ <NUM_LIT:0> ] == atom : <EOL> if l_strip in to_delete_if_empty : <EOL> continue <EOL> if overwrite : <EOL> new_contents += string . strip ( ) + '<STR_LIT:\\n>' <EOL> added = True <EOL> else : <EOL> old_flags = [ flag for flag in l_strip . split ( '<STR_LIT:U+0020>' ) if flag ] [ <NUM_LIT:1> : ] <EOL> if conf == '<STR_LIT>' : <EOL> if not old_flags : <EOL> new_contents += l <EOL> if not new_flags : <EOL> added = True <EOL> continue <EOL> elif not new_flags : <EOL> continue <EOL> merged_flags = _merge_flags ( new_flags , old_flags , conf ) <EOL> if merged_flags : <EOL> new_contents += '<STR_LIT>' . format ( <EOL> atom , '<STR_LIT:U+0020>' . join ( merged_flags ) ) <EOL> else : <EOL> new_contents += '<STR_LIT>' . format ( atom ) <EOL> added = True <EOL> else : <EOL> new_contents += l <EOL> if not added : <EOL> new_contents += string . strip ( ) + '<STR_LIT:\\n>' <EOL> file_handler . seek ( <NUM_LIT:0> ) <EOL> file_handler . truncate ( len ( new_contents ) ) <EOL> file_handler . write ( new_contents ) <EOL> file_handler . close ( ) <EOL> try : <EOL> os . remove ( complete_file_path + '<STR_LIT>' ) <EOL> except OSError : <EOL> pass <EOL> def append_use_flags ( atom , uses = None , overwrite = False ) : <EOL> '''<STR_LIT>''' <EOL> if not uses : <EOL> uses = portage . dep . dep_getusedeps ( atom ) <EOL> if len ( uses ) == <NUM_LIT:0> : <EOL> return <EOL> atom = atom [ : atom . rfind ( '<STR_LIT:[>' ) ] <EOL> append_to_package_conf ( '<STR_LIT>' , atom = atom , flags = uses , overwrite = overwrite ) <EOL>", "answer": "def get_flags_from_package_conf ( conf , atom ) :"}, {"prompt": "<s> from msrest . serialization import Model <EOL> class JobScheduleTerminateOptions ( Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , timeout = <NUM_LIT:30> , client_request_id = None , return_client_request_id = None , ocp_date = None , if_match = None , if_none_match = None , if_modified_since = None , if_unmodified_since = None ) : <EOL>", "answer": "self . timeout = timeout"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL> class Migration ( migrations . Migration ) : <EOL>", "answer": "dependencies = ["}, {"prompt": "<s> from __future__ import unicode_literals <EOL> import boto <EOL> from boto . exception import S3ResponseError <EOL> from boto . s3 . lifecycle import Lifecycle , Transition , Expiration , Rule <EOL> import sure <EOL> from moto import mock_s3 <EOL> @ mock_s3 <EOL> def test_lifecycle_create ( ) : <EOL> conn = boto . s3 . connect_to_region ( \"<STR_LIT>\" ) <EOL> bucket = conn . create_bucket ( \"<STR_LIT>\" ) <EOL> lifecycle = Lifecycle ( ) <EOL> lifecycle . add_rule ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT:30> ) <EOL> bucket . configure_lifecycle ( lifecycle ) <EOL> response = bucket . get_lifecycle_config ( ) <EOL> len ( response ) . should . equal ( <NUM_LIT:1> ) <EOL> lifecycle = response [ <NUM_LIT:0> ] <EOL> lifecycle . id . should . equal ( '<STR_LIT>' ) <EOL> lifecycle . prefix . should . equal ( '<STR_LIT>' ) <EOL> lifecycle . status . should . equal ( '<STR_LIT>' ) <EOL> lifecycle . transition . should . equal ( None ) <EOL> @ mock_s3 <EOL> def test_lifecycle_with_glacier_transition ( ) : <EOL> conn = boto . s3 . connect_to_region ( \"<STR_LIT>\" ) <EOL> bucket = conn . create_bucket ( \"<STR_LIT>\" ) <EOL> lifecycle = Lifecycle ( ) <EOL> transition = Transition ( days = <NUM_LIT:30> , storage_class = '<STR_LIT>' ) <EOL> rule = Rule ( '<STR_LIT>' , prefix = '<STR_LIT>' , status = '<STR_LIT>' , expiration = None , <EOL> transition = transition ) <EOL> lifecycle . append ( rule ) <EOL> bucket . configure_lifecycle ( lifecycle ) <EOL> response = bucket . get_lifecycle_config ( ) <EOL>", "answer": "transition = response [ <NUM_LIT:0> ] . transition"}, {"prompt": "<s> import py <EOL>", "answer": "from py . __ . misc import svnlook"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> import mock <EOL> from yelp . client import Client <EOL> from yelp . obj . search_response import SearchResponse <EOL> class TestBusiness ( object ) : <EOL> @ classmethod <EOL> def setup_class ( cls ) : <EOL> auth = mock . Mock ( ) <EOL> cls . client = Client ( auth ) <EOL> def test_phone_search_builds_correct_params ( self ) : <EOL> with mock . patch ( '<STR_LIT>' ) as request : <EOL> request . return_value = '<STR_LIT:{}>' <EOL> params = { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL>", "answer": "}"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import inspect <EOL> import matplotlib . pyplot as plt <EOL> import numpy as np <EOL> import os <EOL> mod_path = os . path . dirname ( os . path . abspath ( __file__ ) ) <EOL> from base_world import World as BaseWorld <EOL> import world_tools as wtools <EOL> class World ( BaseWorld ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def __init__ ( self , lifespan = None ) :"}, {"prompt": "<s> import feedparser <EOL> import re <EOL> from twisted . web . client import getPage <EOL> from mk2 . plugins import Plugin <EOL> reddit_link = re . compile ( '<STR_LIT>' ) <EOL> class FeedPoller ( object ) : <EOL> last_seen_id = None <EOL> def parse ( self , data ) : <EOL> result = feedparser . parse ( data ) <EOL> result . entries . reverse ( ) <EOL> skipping = True <EOL> for entry in result . entries : <EOL> if ( self . last_seen_id == entry . id ) : <EOL> skipping = False <EOL> elif not skipping : <EOL> yield entry <EOL> if result . entries : <EOL> self . last_seen_id = result . entries [ - <NUM_LIT:1> ] . id <EOL> class RSS ( Plugin ) : <EOL>", "answer": "url = Plugin . Property ( default = \"<STR_LIT>\" )"}, {"prompt": "<s> import os <EOL> import yaml <EOL> from fuel_bootstrap import consts <EOL>", "answer": "from fuel_bootstrap import errors"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . test import TestCase <EOL> from localflavor . us import forms <EOL> from . forms import USPlaceForm <EOL> class USLocalFlavorTests ( TestCase ) : <EOL> def setUp ( self ) : <EOL> self . form = USPlaceForm ( { <EOL> '<STR_LIT:state>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } ) <EOL> def test_get_display_methods ( self ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import github3 <EOL> from . import helper <EOL> class TestRepoCommit ( helper . IntegrationHelper ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def test_statuses ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cassette_name = self . cassette_name ( '<STR_LIT>' ) <EOL> with self . recorder . use_cassette ( cassette_name ) : <EOL> repository = self . gh . repository ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> commit = repository . commit ( <EOL> '<STR_LIT>' <EOL> ) <EOL> statuses = list ( commit . statuses ( ) ) <EOL> for status in statuses : <EOL> assert isinstance ( status , github3 . repos . status . Status ) <EOL> def test_comments ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cassette_name = self . cassette_name ( '<STR_LIT>' ) <EOL> with self . recorder . use_cassette ( cassette_name ) : <EOL> repository = self . gh . repository ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> commit = repository . commit ( <EOL> '<STR_LIT>' <EOL> ) <EOL> comments = list ( commit . comments ( ) ) <EOL>", "answer": "for comment in comments :"}, {"prompt": "<s> from libsaas . filters import auth <EOL> from libsaas . services import base <EOL> from . accounts import Account <EOL> from . plans import Plans , Plan <EOL> from . tokens import Tokens , Token <EOL> from . events import Events , Event <EOL> from . charges import Charges , Charge <EOL> from . coupons import Coupons , Coupon <EOL> from . customers import Customers , Customer <EOL> from . invoices import Invoices , Invoice , InvoiceItems , InvoiceItem <EOL> from . balance_history import BalanceHistory <EOL> class Stripe ( base . Resource ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> def __init__ ( self , api_key ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . apiroot = '<STR_LIT>' <EOL> self . add_filter ( auth . BasicAuth ( api_key , '<STR_LIT>' ) ) <EOL> def get_url ( self ) : <EOL> return self . apiroot <EOL> @ base . resource ( Account ) <EOL> def account ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return Account ( self ) <EOL> @ base . resource ( Plans ) <EOL> def plans ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return Plans ( self ) <EOL> @ base . resource ( Plan ) <EOL> def plan ( self , id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return Plan ( self , id ) <EOL> @ base . resource ( Charges ) <EOL> def charges ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return Charges ( self ) <EOL> @ base . resource ( Charge ) <EOL> def charge ( self , id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return Charge ( self , id ) <EOL> @ base . resource ( Customers ) <EOL> def customers ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return Customers ( self ) <EOL> @ base . resource ( Customer ) <EOL> def customer ( self , id ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from django . contrib . auth . models import Group <EOL> from django . core import mail <EOL> from django . core . exceptions import ValidationError <EOL> from django . core . urlresolvers import reverse <EOL> from django . contrib . sites . shortcuts import get_current_site <EOL> from django . test import TestCase , RequestFactory <EOL> from connect . config . factories import SiteConfigFactory <EOL> from connect . accounts . factories import UserFactory <EOL> from connect . accounts . utils import ( <EOL> create_inactive_user , get_user , invite_user_to_reactivate_account , <EOL> validate_email_availability <EOL> ) <EOL> class AccountUtilsTest ( TestCase ) : <EOL> fixtures = [ '<STR_LIT>' ] <EOL> def setUp ( self ) : <EOL> self . standard_user = UserFactory ( email = '<STR_LIT>' ) <EOL> self . factory = RequestFactory ( ) <EOL> self . site = get_current_site ( self . client . request ) <EOL> self . site . config = SiteConfigFactory ( site = self . site ) <EOL> self . closed_user = UserFactory ( <EOL> full_name = '<STR_LIT>' , <EOL> email = '<STR_LIT>' , <EOL> is_closed = True , <EOL> ) <EOL> def test_create_inactive_user ( self ) : <EOL> user = create_inactive_user ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> moderators = Group . objects . get ( name = '<STR_LIT>' ) <EOL> self . assertEqual ( user . email , '<STR_LIT>' ) <EOL> self . assertEqual ( user . full_name , '<STR_LIT>' ) <EOL> self . assertEqual ( user . is_active , False ) <EOL> self . assertEqual ( user . is_moderator , False ) <EOL> self . assertNotIn ( moderators , user . groups . all ( ) ) <EOL> def test_reactivated_account_token_is_reset ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> initial_token = self . standard_user . auth_token <EOL> request = self . factory . get ( reverse ( '<STR_LIT>' ) ) <EOL> user = invite_user_to_reactivate_account ( self . standard_user , request ) <EOL> self . assertNotEqual ( initial_token , user . auth_token ) <EOL> self . assertFalse ( user . auth_token_is_used ) <EOL> def test_reactivation_email_sent_to_user ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> request = self . factory . get ( '<STR_LIT:/>' ) <EOL> invite_user_to_reactivate_account ( self . closed_user , request ) <EOL> expected_subject = '<STR_LIT>' . format ( self . site . name ) <EOL> expected_intro = '<STR_LIT>' . format ( self . closed_user . full_name ) <EOL> expected_content = '<STR_LIT>' . format ( <EOL> self . site . name ) <EOL> expected_url = '<STR_LIT>' . format ( <EOL> self . closed_user . auth_token <EOL> ) <EOL> email = mail . outbox [ <NUM_LIT:0> ] <EOL> self . assertEqual ( len ( mail . outbox ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( email . subject , expected_subject ) <EOL> self . assertIn ( expected_intro , email . body ) <EOL> self . assertIn ( expected_content , email . body ) <EOL> self . assertIn ( expected_url , email . body ) <EOL> def test_get_user ( self ) : <EOL>", "answer": "user = get_user ( '<STR_LIT>' )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import hashlib <EOL> from django . template . base import TemplateDoesNotExist <EOL> from django . template . loader import BaseLoader , get_template_from_string , find_template_loader , make_origin <EOL> from django . utils . encoding import force_bytes <EOL> class Loader ( BaseLoader ) : <EOL> is_usable = True <EOL> def __init__ ( self , loaders ) : <EOL> self . template_cache = { } <EOL> self . _loaders = loaders <EOL> self . _cached_loaders = [ ] <EOL> @ property <EOL> def loaders ( self ) : <EOL> if not self . _cached_loaders : <EOL>", "answer": "cached_loaders = [ ]"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from homeassistant . components . insteon_hub import INSTEON , InsteonToggleDevice <EOL> def setup_platform ( hass , config , add_devices , discovery_info = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> devs = [ ] <EOL> for device in INSTEON . devices : <EOL> if device . DeviceCategory == \"<STR_LIT>\" : <EOL> devs . append ( InsteonToggleDevice ( device ) ) <EOL> if device . DeviceCategory == \"<STR_LIT>\" : <EOL> devs . append ( InsteonToggleDevice ( device ) ) <EOL>", "answer": "add_devices ( devs ) "}, {"prompt": "<s> from __future__ import unicode_literals <EOL>", "answer": "from django . db import models , migrations"}, {"prompt": "<s> from os . path import abspath , dirname , normpath , join <EOL> import os <EOL> import sys <EOL> BASEDIR = dirname ( abspath ( __file__ ) ) <EOL> LOG = normpath ( join ( BASEDIR , '<STR_LIT:..>' , '<STR_LIT>' ) ) <EOL> TESTDATA = join ( BASEDIR , '<STR_LIT>' ) <EOL> OUTPUT = join ( BASEDIR , '<STR_LIT>' ) <EOL> TARGET = join ( BASEDIR , '<STR_LIT>' ) <EOL> SRC = normpath ( join ( BASEDIR , '<STR_LIT:..>' , '<STR_LIT:..>' , '<STR_LIT:..>' ) ) <EOL> sys . path . insert ( <NUM_LIT:0> , SRC ) <EOL> from robot import run <EOL> from robot . conf . settings import RebotSettings <EOL> from robot . reporting . resultwriter import Results <EOL> from robot . reporting . jswriter import JsResultWriter <EOL> from robot . utils import file_writer <EOL> def run_robot ( testdata , outxml ) : <EOL> run ( testdata , loglevel = '<STR_LIT>' , output = outxml , log = None , report = None ) <EOL> def create_jsdata ( outxml , target ) : <EOL> settings = RebotSettings ( { <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __authors__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> __copyright__ = \"<STR_LIT>\" <EOL> __credits__ = [ \"<STR_LIT>\" ] <EOL> __license__ = \"<STR_LIT>\" <EOL> __maintainer__ = \"<STR_LIT>\" <EOL> import functools <EOL> import logging <EOL> import operator <EOL> import numpy as np <EOL> from theano . compat . six . moves import reduce , xrange <EOL> from theano import tensor as T , config <EOL> from pylearn2 . compat import OrderedDict <EOL> from pylearn2 . models import Model <EOL> from pylearn2 . models . dbm import flatten <EOL> from pylearn2 . models . dbm . inference_procedure import WeightDoubling <EOL> from pylearn2 . models . dbm . sampling_procedure import GibbsEvenOdd <EOL> from pylearn2 . utils import safe_zip , safe_izip <EOL> from pylearn2 . utils . rng import make_np_rng <EOL> logger = logging . getLogger ( __name__ ) <EOL> class DBM ( Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , batch_size , visible_layer , hidden_layers , niter , <EOL> sampling_procedure = None , inference_procedure = None ) : <EOL> super ( DBM , self ) . __init__ ( ) <EOL> self . __dict__ . update ( locals ( ) ) <EOL> del self . self <EOL> assert len ( hidden_layers ) >= <NUM_LIT:1> <EOL> if len ( hidden_layers ) > <NUM_LIT:1> and niter <= <NUM_LIT:1> : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> self . setup_rng ( ) <EOL> self . layer_names = set ( ) <EOL> self . visible_layer . set_dbm ( self ) <EOL> for layer in hidden_layers : <EOL> assert layer . get_dbm ( ) is None <EOL> layer . set_dbm ( self ) <EOL> assert layer . layer_name not in self . layer_names <EOL> self . layer_names . add ( layer . layer_name ) <EOL> self . _update_layer_input_spaces ( ) <EOL> self . force_batch_size = batch_size <EOL> self . freeze_set = set ( [ ] ) <EOL> if inference_procedure is None : <EOL> self . setup_inference_procedure ( ) <EOL> self . inference_procedure . set_dbm ( self ) <EOL> if sampling_procedure is None : <EOL> self . setup_sampling_procedure ( ) <EOL> self . sampling_procedure . set_dbm ( self ) <EOL> def get_all_layers ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return [ self . visible_layer ] + self . hidden_layers <EOL> def energy ( self , V , hidden ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> terms = [ ] <EOL> terms . append ( self . visible_layer . expected_energy_term ( state = V , <EOL> average = False ) ) <EOL> assert len ( self . hidden_layers ) > <NUM_LIT:0> <EOL> terms . append ( self . hidden_layers [ <NUM_LIT:0> ] . expected_energy_term ( <EOL> state_below = self . visible_layer . upward_state ( V ) , <EOL> state = hidden [ <NUM_LIT:0> ] , average_below = False , average = False ) ) <EOL> for i in xrange ( <NUM_LIT:1> , len ( self . hidden_layers ) ) : <EOL> layer = self . hidden_layers [ i ] <EOL> samples_below = hidden [ i - <NUM_LIT:1> ] <EOL> layer_below = self . hidden_layers [ i - <NUM_LIT:1> ] <EOL> samples_below = layer_below . upward_state ( samples_below ) <EOL> samples = hidden [ i ] <EOL> terms . append ( layer . expected_energy_term ( state_below = samples_below , <EOL> state = samples , average_below = False , average = False ) ) <EOL> assert len ( terms ) > <NUM_LIT:0> <EOL> rval = reduce ( operator . add , terms ) <EOL> assert rval . ndim == <NUM_LIT:1> <EOL> return rval <EOL> def mf ( self , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . setup_inference_procedure ( ) <EOL> return self . inference_procedure . mf ( * args , ** kwargs ) <EOL> def expected_energy ( self , V , mf_hidden ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . visible_layer . space . validate ( V ) <EOL> assert isinstance ( mf_hidden , ( list , tuple ) ) <EOL> assert len ( mf_hidden ) == len ( self . hidden_layers ) <EOL> terms = [ ] <EOL> terms . append ( self . visible_layer . expected_energy_term ( state = V , <EOL> average = False ) ) <EOL> assert len ( self . hidden_layers ) > <NUM_LIT:0> <EOL> terms . append ( self . hidden_layers [ <NUM_LIT:0> ] . expected_energy_term ( <EOL> state_below = self . visible_layer . upward_state ( V ) , <EOL> average_below = False , state = mf_hidden [ <NUM_LIT:0> ] , average = True ) ) <EOL> for i in xrange ( <NUM_LIT:1> , len ( self . hidden_layers ) ) : <EOL> layer = self . hidden_layers [ i ] <EOL> layer_below = self . hidden_layers [ i - <NUM_LIT:1> ] <EOL> mf_below = mf_hidden [ i - <NUM_LIT:1> ] <EOL> mf_below = layer_below . upward_state ( mf_below ) <EOL> mf = mf_hidden [ i ] <EOL> terms . append ( layer . expected_energy_term ( state_below = mf_below , <EOL> state = mf , average_below = True , average = True ) ) <EOL> assert len ( terms ) > <NUM_LIT:0> <EOL> rval = reduce ( operator . add , terms ) <EOL> assert rval . ndim == <NUM_LIT:1> <EOL> return rval <EOL> def setup_rng ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . rng = make_np_rng ( None , [ <NUM_LIT> , <NUM_LIT:10> , <NUM_LIT> ] , which_method = \"<STR_LIT>\" ) <EOL> def setup_inference_procedure ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not hasattr ( self , '<STR_LIT>' ) or self . inference_procedure is None : <EOL> self . inference_procedure = WeightDoubling ( ) <EOL> self . inference_procedure . set_dbm ( self ) <EOL> def setup_sampling_procedure ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not hasattr ( self , '<STR_LIT>' ) or self . sampling_procedure is None : <EOL> self . sampling_procedure = GibbsEvenOdd ( ) <EOL> self . sampling_procedure . set_dbm ( self ) <EOL> def get_output_space ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . hidden_layers [ - <NUM_LIT:1> ] . get_output_space ( ) <EOL> def _update_layer_input_spaces ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> visible_layer = self . visible_layer <EOL> hidden_layers = self . hidden_layers <EOL> self . hidden_layers [ <NUM_LIT:0> ] . set_input_space ( visible_layer . space ) <EOL> for i in xrange ( <NUM_LIT:1> , len ( hidden_layers ) ) : <EOL> hidden_layers [ i ] . set_input_space ( <EOL> hidden_layers [ i - <NUM_LIT:1> ] . get_output_space ( ) ) <EOL> for layer in self . get_all_layers ( ) : <EOL> layer . finalize_initialization ( ) <EOL> def add_layers ( self , layers ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not hasattr ( self , '<STR_LIT>' ) : <EOL> self . setup_rng ( ) <EOL> hidden_layers = self . hidden_layers <EOL> assert len ( hidden_layers ) > <NUM_LIT:0> <EOL> for layer in layers : <EOL> assert layer . get_dbm ( ) is None <EOL> layer . set_dbm ( self ) <EOL> layer . set_input_space ( hidden_layers [ - <NUM_LIT:1> ] . get_output_space ( ) ) <EOL> hidden_layers . append ( layer ) <EOL> assert layer . layer_name not in self . layer_names <EOL> self . layer_names . add ( layer . layer_name ) <EOL> def freeze ( self , parameter_set ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not hasattr ( self , '<STR_LIT>' ) : <EOL> self . freeze_set = set ( [ ] ) <EOL> self . freeze_set = self . freeze_set . union ( parameter_set ) <EOL> def get_params ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rval = [ ] <EOL> for param in self . visible_layer . get_params ( ) : <EOL> assert param . name is not None <EOL> rval = self . visible_layer . get_params ( ) <EOL> for layer in self . hidden_layers : <EOL> for param in layer . get_params ( ) : <EOL> if param . name is None : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" + layer . layer_name + <EOL> \"<STR_LIT>\" ) <EOL> layer_params = layer . get_params ( ) <EOL> assert not isinstance ( layer_params , set ) <EOL> for param in layer_params : <EOL> if param not in rval : <EOL> rval . append ( param ) <EOL> if not hasattr ( self , '<STR_LIT>' ) : <EOL> self . freeze_set = set ( [ ] ) <EOL> rval = [ elem for elem in rval if elem not in self . freeze_set ] <EOL> assert all ( [ elem . name is not None for elem in rval ] ) <EOL> return rval <EOL> def set_batch_size ( self , batch_size ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . batch_size = batch_size <EOL> self . force_batch_size = batch_size <EOL> for layer in self . hidden_layers : <EOL> layer . set_batch_size ( batch_size ) <EOL> if not hasattr ( self , '<STR_LIT>' ) : <EOL> self . setup_inference_procedure ( ) <EOL> self . inference_procedure . set_batch_size ( batch_size ) <EOL> @ functools . wraps ( Model . _modify_updates ) <EOL> def _modify_updates ( self , updates ) : <EOL> self . visible_layer . modify_updates ( updates ) <EOL> for layer in self . hidden_layers : <EOL> layer . modify_updates ( updates ) <EOL> def get_input_space ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . visible_layer . space <EOL> def get_lr_scalers ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rval = OrderedDict ( ) <EOL> params = self . get_params ( ) <EOL> for layer in self . hidden_layers + [ self . visible_layer ] : <EOL> contrib = layer . get_lr_scalers ( ) <EOL> assert not any ( [ key in rval for key in contrib ] ) <EOL> assert all ( [ key in params for key in contrib ] ) <EOL> rval . update ( contrib ) <EOL> assert all ( [ isinstance ( val , float ) for val in rval . values ( ) ] ) <EOL> return rval <EOL> def get_weights ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . hidden_layers [ <NUM_LIT:0> ] . get_weights ( ) <EOL> def get_weights_view_shape ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . hidden_layers [ <NUM_LIT:0> ] . get_weights_view_shape ( ) <EOL> def get_weights_format ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . hidden_layers [ <NUM_LIT:0> ] . get_weights_format ( ) <EOL> def get_weights_topo ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . hidden_layers [ <NUM_LIT:0> ] . get_weights_topo ( ) <EOL> def make_layer_to_state ( self , num_examples , rng = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> layers = [ self . visible_layer ] + self . hidden_layers <EOL> if rng is None : <EOL> rng = self . rng <EOL> states = [ layer . make_state ( num_examples , rng ) for layer in layers ] <EOL> def recurse_check ( layer , state ) : <EOL> if isinstance ( state , ( list , tuple ) ) : <EOL> for elem in state : <EOL> recurse_check ( layer , elem ) <EOL> else : <EOL> val = state . get_value ( ) <EOL> m = val . shape [ <NUM_LIT:0> ] <EOL> if m != num_examples : <EOL> raise ValueError ( layer . layer_name + \"<STR_LIT>\" + <EOL> str ( m ) + \"<STR_LIT>\" <EOL> \"<STR_LIT>\" + str ( num_examples ) ) <EOL> for layer , state in safe_zip ( layers , states ) : <EOL> recurse_check ( layer , state ) <EOL> rval = OrderedDict ( safe_zip ( layers , states ) ) <EOL> return rval <EOL> def make_layer_to_symbolic_state ( self , num_examples , rng = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> layers = [ self . visible_layer ] + self . hidden_layers <EOL> assert rng is not None <EOL> states = [ layer . make_symbolic_state ( num_examples , rng ) <EOL> for layer in layers ] <EOL> zipped = safe_zip ( layers , states ) <EOL>", "answer": "rval = OrderedDict ( zipped )"}, {"prompt": "<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> from pex . interpreter import PythonIdentity <EOL> from twitter . common . collections import maybe_list <EOL> from pants . backend . python . python_artifact import PythonArtifact <EOL> from pants . base . exceptions import TargetDefinitionException <EOL> from pants . base . payload import Payload <EOL> from pants . base . payload_field import PrimitiveField <EOL> from pants . build_graph . address import Address <EOL> from pants . build_graph . resources import Resources <EOL> from pants . build_graph . target import Target <EOL> from pants . util . memo import memoized_property <EOL> class PythonTarget ( Target ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , <EOL> address = None , <EOL> payload = None , <EOL> sources = None , <EOL> resources = None , <EOL> resource_targets = None , <EOL> provides = None , <EOL> compatibility = None , <EOL> ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . address = address <EOL> payload = payload or Payload ( ) <EOL> payload . add_fields ( { <EOL> '<STR_LIT>' : self . create_sources_field ( sources , address . spec_path , key_arg = '<STR_LIT>' ) , <EOL> '<STR_LIT>' : self . create_sources_field ( resources , address . spec_path , key_arg = '<STR_LIT>' ) , <EOL> '<STR_LIT>' : provides , <EOL> '<STR_LIT>' : PrimitiveField ( maybe_list ( compatibility or ( ) ) ) , <EOL> } ) <EOL> super ( PythonTarget , self ) . __init__ ( address = address , <EOL> payload = payload , <EOL> ** kwargs ) <EOL> self . _resource_target_specs = resource_targets <EOL> self . add_labels ( '<STR_LIT>' ) <EOL> if provides and not isinstance ( provides , PythonArtifact ) : <EOL> raise TargetDefinitionException ( self , <EOL> \"<STR_LIT>\" . format ( <EOL> provides . __class__ . __name__ ) ) <EOL> self . _provides = provides <EOL> for req in self . payload . compatibility : <EOL> try : <EOL> PythonIdentity . parse_requirement ( req ) <EOL> except ValueError as e : <EOL> raise TargetDefinitionException ( self , str ( e ) ) <EOL> @ property <EOL> def traversable_specs ( self ) : <EOL> for spec in super ( PythonTarget , self ) . traversable_specs : <EOL> yield spec <EOL> if self . _provides : <EOL> for spec in self . _provides . _binaries . values ( ) : <EOL> address = Address . parse ( spec , relative_to = self . address . spec_path ) <EOL> yield address . spec <EOL> @ property <EOL> def traversable_dependency_specs ( self ) : <EOL> for spec in super ( PythonTarget , self ) . traversable_dependency_specs : <EOL> yield spec <EOL> if self . _resource_target_specs : <EOL> for spec in self . _resource_target_specs : <EOL> yield spec <EOL> if self . _synthetic_resources_target : <EOL> yield self . _synthetic_resources_target . address . spec <EOL> @ property <EOL> def provides ( self ) : <EOL> return self . payload . provides <EOL> @ property <EOL> def provided_binaries ( self ) : <EOL> def binary_iter ( ) : <EOL> if self . payload . provides : <EOL> for key , binary_spec in self . payload . provides . binaries . items ( ) : <EOL> address = Address . parse ( binary_spec , relative_to = self . address . spec_path ) <EOL> yield ( key , self . _build_graph . get_target ( address ) ) <EOL> return dict ( binary_iter ( ) ) <EOL> @ property <EOL> def compatibility ( self ) : <EOL> return self . payload . compatibility <EOL> @ property <EOL> def resources ( self ) : <EOL> resource_targets = [ ] <EOL> if self . _resource_target_specs : <EOL> def get_target ( spec ) : <EOL> address = Address . parse ( spec , relative_to = self . address . spec_path ) <EOL> tgt = self . _build_graph . get_target ( address ) <EOL> if tgt is None : <EOL> raise TargetDefinitionException ( self , '<STR_LIT>' . format ( address ) ) <EOL> return tgt <EOL> resource_targets . extend ( get_target ( spec ) for spec in self . _resource_target_specs ) <EOL> if self . _synthetic_resources_target : <EOL> resource_targets . append ( self . _synthetic_resources_target ) <EOL> return resource_targets <EOL> def walk ( self , work , predicate = None ) : <EOL> super ( PythonTarget , self ) . walk ( work , predicate ) <EOL>", "answer": "for binary in self . provided_binaries . values ( ) :"}, {"prompt": "<s> import re <EOL> import uuid <EOL> import six <EOL> from django . test import TestCase <EOL> from django_extensions . db . fields import PostgreSQLUUIDField <EOL> from . testapp . models import ( <EOL> UUIDTestAgregateModel , UUIDTestManyToManyModel , UUIDTestModel_field , <EOL> UUIDTestModel_pk , <EOL> ) <EOL> class UUIDFieldTest ( TestCase ) : <EOL> def test_UUID_field_create ( self ) : <EOL> j = UUIDTestModel_field . objects . create ( a = <NUM_LIT:6> , uuid_field = six . u ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( j . uuid_field , six . u ( '<STR_LIT>' ) ) <EOL> def test_UUID_field_pk_create ( self ) : <EOL> j = UUIDTestModel_pk . objects . create ( uuid_field = six . u ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( j . uuid_field , six . u ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( j . pk , six . u ( '<STR_LIT>' ) ) <EOL> def test_UUID_field_pk_agregate_create ( self ) : <EOL> j = UUIDTestAgregateModel . objects . create ( a = <NUM_LIT:6> , uuid_field = six . u ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( j . a , <NUM_LIT:6> ) <EOL> self . assertIsInstance ( j . pk , six . string_types ) <EOL> self . assertEqual ( len ( j . pk ) , <NUM_LIT> ) <EOL> def test_UUID_field_manytomany_create ( self ) : <EOL> j = UUIDTestManyToManyModel . objects . create ( uuid_field = six . u ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( j . uuid_field , six . u ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( j . pk , six . u ( '<STR_LIT>' ) ) <EOL> class PostgreSQLUUIDFieldTest ( TestCase ) : <EOL> def test_uuid_casting ( self ) : <EOL> matcher = re . compile ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> field = PostgreSQLUUIDField ( ) <EOL>", "answer": "for value in ( str ( uuid . uuid4 ( ) ) , uuid . uuid4 ( ) . urn , uuid . uuid4 ( ) . hex ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , unicode_literals <EOL> from django . conf import settings <EOL> from django . contrib import admin <EOL> from django . core . cache import cache <EOL> from django . core . exceptions import ObjectDoesNotExist <EOL> from django . db import models <EOL> from django . db . models import Q <EOL>", "answer": "from django . utils import translation"}, {"prompt": "<s> import unittest <EOL> import sys , os , os . path <EOL> rootDirectory = os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , '<STR_LIT:..>' , '<STR_LIT:..>' ) <EOL> if rootDirectory not in sys . path : <EOL> sys . path . append ( rootDirectory ) <EOL> from applicationinsights import channel <EOL> class TestAsynchronousQueue ( unittest . TestCase ) : <EOL> def test_construct ( self ) : <EOL> queue = channel . AsynchronousQueue ( MockAsynchronousSender ( ) ) <EOL> self . assertIsNotNone ( queue . flush_notification ) <EOL> def test_flush_notification_works_as_expected ( self ) : <EOL> queue = channel . AsynchronousQueue ( MockAsynchronousSender ( ) ) <EOL> self . assertIsNotNone ( queue . flush_notification ) <EOL> result = queue . flush_notification . wait ( <NUM_LIT:1> ) <EOL> self . assertEqual ( False , result ) <EOL> queue . flush_notification . set ( ) <EOL> result = queue . flush_notification . wait ( ) <EOL> self . assertEqual ( True , result ) <EOL> queue . flush_notification . clear ( ) <EOL> result = queue . flush_notification . wait ( <NUM_LIT:1> ) <EOL> self . assertEqual ( False , result ) <EOL> def test_push_works_As_expected ( self ) : <EOL> sender = MockAsynchronousSender ( ) <EOL> queue = channel . AsynchronousQueue ( sender ) <EOL> queue . put ( <NUM_LIT> ) <EOL> self . assertEqual ( <NUM_LIT:1> , sender . start_call_count ) <EOL> self . assertEqual ( <NUM_LIT> , queue . get ( ) ) <EOL> self . assertIsNone ( queue . get ( ) ) <EOL> def test_flush_works_as_expected ( self ) : <EOL> sender = MockAsynchronousSender ( ) <EOL> queue = channel . AsynchronousQueue ( sender ) <EOL> self . assertIsNotNone ( queue . flush_notification ) <EOL> result = queue . flush_notification . wait ( <NUM_LIT:1> ) <EOL> self . assertEqual ( False , result ) <EOL> queue . flush ( ) <EOL> self . assertEqual ( <NUM_LIT:1> , sender . start_call_count ) <EOL> result = queue . flush_notification . wait ( ) <EOL> self . assertEqual ( True , result ) <EOL> class MockAsynchronousSender : <EOL> def __init__ ( self ) : <EOL> self . send_buffer_size = <NUM_LIT:2> <EOL> self . data = [ ] <EOL> self . queue = None <EOL> self . start_call_count = <NUM_LIT:0> <EOL> def start ( self ) : <EOL> self . start_call_count += <NUM_LIT:1> <EOL>", "answer": "def send ( self , data_to_send ) :"}, {"prompt": "<s> from django . conf . urls import patterns , url , include <EOL> from django . contrib . auth . decorators import login_required <EOL> from . views import PracticeDeckList <EOL> from cardbox import deck_views <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL> url ( r'<STR_LIT>' , login_required ( PracticeDeckList . as_view ( template_name = \"<STR_LIT>\" ) ) , <EOL> name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , login_required ( deck_views . DeckCreate . as_view ( <EOL>", "answer": "template_name = \"<STR_LIT>\" ) ) , name = '<STR_LIT>' ) ,"}, {"prompt": "<s> from os import listdir <EOL> from twisted . python . reflect import namedModule <EOL> from twisted . python . util import sibpath <EOL> from smartanthill . device . board . base import BoardBase <EOL> from smartanthill . device . device import Device <EOL> from smartanthill . exception import ( BoardUnknownId , DeviceUnknownBoard , <EOL> DeviceUnknownId ) <EOL>", "answer": "from smartanthill . service import SAMultiService"}, {"prompt": "<s> import numpy as np <EOL>", "answer": "try :"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> from biicode . common . migrations . migration import Migration <EOL> class AddContributorsAndPermissionsToWorkspace ( Migration ) : <EOL> def migrate ( self , * args , ** kwargs ) : <EOL> pass <EOL> class AddTagsToWorkspaceBlocks ( Migration ) : <EOL> def migrate ( self , * args , ** kwargs ) : <EOL> pass <EOL> class EnsureUserSubscriptionCreated ( Migration ) : <EOL> def migrate ( self , * args , ** kwargs ) : <EOL> pass <EOL> class PGUserAndWorkspaceToUser ( Migration ) : <EOL> def migrate ( self , * args , ** kwargs ) : <EOL> pass <EOL> class ResetUserSubscription ( Migration ) : <EOL> '''<STR_LIT>''' <EOL> def migrate ( self , * args , ** kwargs ) : <EOL> pass <EOL> class ComputeUserWorkspaceSizes ( Migration ) : <EOL> def migrate ( self , * args , ** kwargs ) : <EOL>", "answer": "pass"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import base64 <EOL> import os <EOL> import uuid <EOL> from googleads import dfp <EOL> ADVERTISER_ID = '<STR_LIT>' <EOL> def main ( client , advertiser_id ) : <EOL> creative_service = client . GetService ( '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> creative_template_id = '<STR_LIT>' <EOL> image_data = open ( os . path . join ( os . path . split ( __file__ ) [ <NUM_LIT:0> ] , '<STR_LIT:..>' , '<STR_LIT:..>' , '<STR_LIT:data>' , <EOL> '<STR_LIT>' ) , '<STR_LIT:r>' ) . read ( ) <EOL> image_data = base64 . encodestring ( image_data ) <EOL> creative = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' % uuid . uuid4 ( ) , <EOL> '<STR_LIT>' : advertiser_id , <EOL> '<STR_LIT:size>' : { '<STR_LIT:width>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : creative_template_id , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : image_data , <EOL> '<STR_LIT>' : '<STR_LIT>' % uuid . uuid4 ( ) <EOL> } , <EOL> { <EOL>", "answer": "'<STR_LIT>' : '<STR_LIT>' ,"}, {"prompt": "<s> from django . conf import settings <EOL> from django . conf . urls import patterns , url <EOL> from django . http import HttpResponsePermanentRedirect as perma_redirect <EOL> from django . views . generic . base import TemplateView <EOL> from olympia . amo . urlresolvers import reverse <EOL> from . import views <EOL> urlpatterns = patterns ( <EOL> '<STR_LIT>' , <EOL> url ( '<STR_LIT>' , <EOL> TemplateView . as_view ( template_name = '<STR_LIT>' ) , <EOL> name = '<STR_LIT>' ) , <EOL> url ( '<STR_LIT>' , views . credits , name = '<STR_LIT>' ) , <EOL> url ( '<STR_LIT>' , <EOL> TemplateView . as_view ( template_name = '<STR_LIT>' ) , <EOL> name = '<STR_LIT>' ) , <EOL> url ( '<STR_LIT>' , <EOL> TemplateView . as_view ( <EOL> template_name = '<STR_LIT>' ) ) , <EOL> url ( '<STR_LIT>' , <EOL> TemplateView . as_view ( template_name = '<STR_LIT>' ) , <EOL> name = '<STR_LIT>' ) , <EOL> url ( '<STR_LIT>' , <EOL> TemplateView . as_view ( template_name = '<STR_LIT>' ) , <EOL> name = '<STR_LIT>' ) , <EOL> url ( '<STR_LIT>' , <EOL> TemplateView . as_view ( template_name = '<STR_LIT>' ) , <EOL> name = '<STR_LIT>' ) , <EOL> url ( '<STR_LIT>' , <EOL> lambda r : perma_redirect ( reverse ( '<STR_LIT>' ) ) ) , <EOL> url ( '<STR_LIT>' , <EOL> lambda r : perma_redirect ( reverse ( '<STR_LIT>' ) ) ) , <EOL> url ( '<STR_LIT>' , <EOL> lambda r : perma_redirect ( reverse ( '<STR_LIT>' ) ) ) , <EOL> url ( '<STR_LIT>' , <EOL> lambda r : perma_redirect ( reverse ( '<STR_LIT>' , <EOL> args = [ '<STR_LIT>' ] ) ) ) , <EOL> url ( '<STR_LIT>' , <EOL> lambda r : perma_redirect ( settings . VALIDATION_FAQ_URL ) ) , <EOL> url ( '<STR_LIT>' , <EOL> TemplateView . as_view ( template_name = '<STR_LIT>' ) , <EOL> name = '<STR_LIT>' ) , <EOL>", "answer": "url ( '<STR_LIT>' , lambda r : perma_redirect ( reverse ( '<STR_LIT>' ) ) ) ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> def f ( x , y , z ) : <EOL> return ( x + y ) / float ( z ) <EOL> print f ( <NUM_LIT:10> , <NUM_LIT:5> , <NUM_LIT:3> ) <EOL> x = <NUM_LIT:20> <EOL> y = <NUM_LIT:10> <EOL> z = <NUM_LIT:3> <EOL> print f ( x = x , y = y , z = z ) <EOL> print f ( y , x , z = <NUM_LIT:2> ) <EOL> print f ( z = <NUM_LIT:3> , y = x , x = y ) <EOL> print f ( z = x , y = x , x = x ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def ff ( x = <NUM_LIT:20> , y = <NUM_LIT:10> , z = <NUM_LIT:3> ) : <EOL> return ( x + y ) / float ( z ) <EOL> print ff ( <NUM_LIT:10> , <NUM_LIT:5> , <NUM_LIT:3> ) <EOL>", "answer": "print ff ( <NUM_LIT:10> )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __version__ = \"<STR_LIT>\" <EOL>", "answer": "__license__ = \"<STR_LIT>\" "}, {"prompt": "<s> import json <EOL> import unittest <EOL> from libsaas import port <EOL> from libsaas . services . base import MethodNotSupported <EOL> from libsaas . executors import test_executor <EOL> from libsaas . services import basecamp <EOL> class BasecampTestCase ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . executor = test_executor . use ( ) <EOL> self . executor . set_response ( b'<STR_LIT:{}>' , <NUM_LIT:200> , { } ) <EOL> self . service = basecamp . Basecamp ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def expect ( self , method = None , uri = None , params = { } ) : <EOL> if method : <EOL> self . assertEqual ( method , self . executor . request . method ) <EOL> if uri : <EOL> self . assertEqual ( <EOL> self . executor . request . uri , <EOL> '<STR_LIT>' + uri + '<STR_LIT>' ) <EOL> if params : <EOL> self . assertEqual ( self . executor . request . params , params ) <EOL> def test_projects ( self ) : <EOL> self . service . projects ( ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . projects ( ) . archived ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( '<STR_LIT>' ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> obj = { '<STR_LIT:foo>' : '<STR_LIT:bar>' } <EOL> self . service . projects ( ) . create ( obj ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , json . dumps ( obj ) ) <EOL> self . service . project ( <NUM_LIT> ) . update ( obj ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , json . dumps ( obj ) ) <EOL> self . service . project ( <NUM_LIT> ) . delete ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( '<STR_LIT>' ) . accesses ( ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . project ( <NUM_LIT> ) . accesses ( ) . create ( { } ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . project ( <NUM_LIT> ) . access ( <NUM_LIT> ) . update ( { } ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . project ( <NUM_LIT> ) . access ( <NUM_LIT> ) . delete ( { } ) <EOL> self . service . project ( <NUM_LIT> ) . accesses ( ) . grant ( obj ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , json . dumps ( obj ) ) <EOL> self . service . project ( <NUM_LIT> ) . access ( <NUM_LIT> ) . revoke ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( '<STR_LIT>' ) . events ( ) . get ( since = '<STR_LIT>' ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> self . service . project ( '<STR_LIT>' ) . topics ( ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( '<STR_LIT>' ) . topics ( ) . get ( page = <NUM_LIT:2> ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT>' : <NUM_LIT:2> } ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . project ( <NUM_LIT> ) . topics ( ) . create ( { } ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . project ( <NUM_LIT> ) . messages ( ) . get ( ) <EOL> self . service . project ( <NUM_LIT> ) . messages ( ) . create ( obj ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , json . dumps ( obj ) ) <EOL> self . service . project ( '<STR_LIT>' ) . message ( <NUM_LIT> ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( '<STR_LIT>' ) . message ( <NUM_LIT> ) . update ( obj ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , json . dumps ( obj ) ) <EOL> self . service . project ( '<STR_LIT>' ) . message ( <NUM_LIT> ) . delete ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , { } ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . project ( <NUM_LIT> ) . message ( <NUM_LIT> ) . comments ( ) . get ( ) <EOL> self . service . project ( <NUM_LIT> ) . message ( <NUM_LIT> ) . comments ( ) . create ( obj ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , <EOL> json . dumps ( obj ) ) <EOL> self . service . project ( <NUM_LIT> ) . comment ( <NUM_LIT> ) . delete ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , { } ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . project ( <NUM_LIT> ) . comment ( <NUM_LIT> ) . get ( ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . project ( <NUM_LIT> ) . comment ( <NUM_LIT> ) . update ( obj ) <EOL> self . service . project ( <NUM_LIT> ) . todolists ( ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( <NUM_LIT> ) . todolists ( ) . completed ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( <NUM_LIT> ) . todolists ( ) . create ( obj ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , json . dumps ( obj ) ) <EOL> self . service . project ( <NUM_LIT> ) . todolist ( <NUM_LIT> ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( <NUM_LIT> ) . todolist ( <NUM_LIT> ) . update ( obj ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , json . dumps ( obj ) ) <EOL> self . service . project ( <NUM_LIT> ) . todolist ( <NUM_LIT> ) . delete ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , { } ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . project ( <NUM_LIT> ) . todolist ( <NUM_LIT> ) . todos ( ) . get ( ) <EOL> self . service . project ( <NUM_LIT> ) . todolist ( <NUM_LIT> ) . todos ( ) . create ( obj ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , <EOL> json . dumps ( obj ) ) <EOL> self . service . project ( <NUM_LIT> ) . todo ( <NUM_LIT> ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( <NUM_LIT> ) . todo ( <NUM_LIT> ) . update ( obj ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , json . dumps ( obj ) ) <EOL> self . service . project ( <NUM_LIT> ) . todo ( <NUM_LIT> ) . delete ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( <NUM_LIT> ) . documents ( ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( <NUM_LIT> ) . documents ( ) . create ( obj ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , json . dumps ( obj ) ) <EOL> self . service . project ( <NUM_LIT> ) . document ( <NUM_LIT> ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( <NUM_LIT> ) . document ( <NUM_LIT> ) . update ( obj ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , json . dumps ( obj ) ) <EOL> self . service . project ( <NUM_LIT> ) . document ( <NUM_LIT> ) . delete ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , { } ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . project ( <NUM_LIT> ) . document ( <NUM_LIT> ) . comments ( ) . get ( ) <EOL> self . service . project ( <NUM_LIT> ) . document ( <NUM_LIT> ) . comments ( ) . create ( obj ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , <EOL> json . dumps ( obj ) ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . project ( <NUM_LIT> ) . uploads ( ) . get ( ) <EOL> self . service . project ( <NUM_LIT> ) . uploads ( ) . create ( obj ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , json . dumps ( obj ) ) <EOL> self . service . project ( <NUM_LIT> ) . upload ( <NUM_LIT> ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . project ( <NUM_LIT> ) . upload ( <NUM_LIT> ) . comments ( ) . get ( ) <EOL> self . service . project ( <NUM_LIT> ) . upload ( <NUM_LIT> ) . comments ( ) . create ( obj ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , <EOL> json . dumps ( obj ) ) <EOL> self . service . project ( <NUM_LIT> ) . attachments ( ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . project ( <NUM_LIT> ) . attachments ( ) . create ( obj ) <EOL> self . service . project ( '<STR_LIT>' ) . calendar_events ( ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( <NUM_LIT> ) . calendar_events ( ) . create ( obj ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , json . dumps ( obj ) ) <EOL> self . service . project ( '<STR_LIT>' ) . calendar_events ( ) . past ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( '<STR_LIT>' ) . calendar_event ( <NUM_LIT> ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . project ( '<STR_LIT>' ) . calendar_event ( <NUM_LIT> ) . update ( obj ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , <EOL> json . dumps ( obj ) ) <EOL> self . service . project ( '<STR_LIT>' ) . calendar_event ( <NUM_LIT> ) . delete ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , { } ) <EOL> def test_people ( self ) : <EOL> self . service . people ( ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . person ( ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> self . service . person ( '<STR_LIT>' ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . people ( ) . create ( { } ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . person ( <NUM_LIT> ) . update ( { } ) <EOL> self . service . person ( <NUM_LIT> ) . delete ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , { } ) <EOL> self . service . person ( '<STR_LIT>' ) . events ( ) . get ( since = '<STR_LIT>' ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> def test_events ( self ) : <EOL> self . service . events ( ) . get ( since = '<STR_LIT>' ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> self . service . events ( ) . get ( since = '<STR_LIT>' , page = <NUM_LIT:3> ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : <NUM_LIT:3> } ) <EOL> with port . assertRaises ( MethodNotSupported ) : <EOL> self . service . events ( ) . create ( { } ) <EOL> def test_calendars ( self ) : <EOL> self . service . calendars ( ) . get ( ) <EOL>", "answer": "self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } )"}, {"prompt": "<s> from django . contrib . admin . sites import AdminSite <EOL> class AdminMixin ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> return super ( AdminMixin , self ) . __init__ ( * args , ** kwargs ) <EOL> def get_urls ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from django . conf . urls import patterns , url <EOL> from views import DashboardCustomize , DashboardDynamicView , SimulatorView , LoggedInView , DashboardUserSiteView , TenantViewData , TenantCreateSlice , TenantAddUser , TenantAddOrRemoveInstanceView , TenantPickSitesView , TenantDeleteSliceView , TenantUpdateSlice , DashboardSliceInteractions , RequestAccessView <EOL> from views import view_urls <EOL> urls = super ( AdminMixin , self ) . get_urls ( ) <EOL> del urls [ <NUM_LIT:0> ] <EOL> dashboard_urls = [ <EOL> url ( r'<STR_LIT>' , self . admin_view ( DashboardDynamicView . as_view ( ) ) , <EOL> name = \"<STR_LIT:index>\" ) , <EOL> url ( r'<STR_LIT>' , self . admin_view ( LoggedInView . as_view ( ) ) , <EOL> name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , self . admin_view ( DashboardUserSiteView . as_view ( ) ) , <EOL> name = \"<STR_LIT:test>\" ) , <EOL> url ( r'<STR_LIT>' , self . admin_view ( DashboardSliceInteractions . as_view ( ) ) , <EOL> name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , self . admin_view ( DashboardDynamicView . as_view ( ) ) , <EOL> name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , self . admin_view ( DashboardDynamicView . as_view ( ) ) , <EOL> { \"<STR_LIT>\" : True } , <EOL> name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , self . admin_view ( DashboardCustomize . as_view ( ) ) , <EOL> name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , self . admin_view ( DashboardUserSiteView . as_view ( ) ) , <EOL> name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , self . admin_view ( DashboardDynamicView . as_view ( ) ) , <EOL> name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , self . admin_view ( SimulatorView . as_view ( ) ) , <EOL> name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , self . admin_view ( TenantAddOrRemoveInstanceView . as_view ( ) ) , <EOL> name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , self . admin_view ( TenantViewData . as_view ( ) ) , <EOL> name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , self . admin_view ( TenantCreateSlice . as_view ( ) ) , <EOL> name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , self . admin_view ( TenantAddUser . as_view ( ) ) , <EOL> name = \"<STR_LIT>\" ) , <EOL> url ( r'<STR_LIT>' , RequestAccessView . as_view ( ) , <EOL>", "answer": "name = \"<STR_LIT>\" ) ,"}, {"prompt": "<s> import re <EOL> import decimal <EOL> import datetime <EOL> from uuid import uuid4 <EOL> from functools import wraps <EOL> from werkzeug . exceptions import HTTPException <EOL> from flask . wrappers import Response <EOL> from flask import json , jsonify , request , make_response , current_app <EOL> from flask_jsonrpc . types import Object , Array , Any <EOL> from flask_jsonrpc . helpers import extract_raw_data_request <EOL> from flask_jsonrpc . _compat import ( text_type , string_types , integer_types , <EOL> iteritems , iterkeys ) <EOL> from flask_jsonrpc . exceptions import ( Error , ParseError , InvalidRequestError , <EOL> MethodNotFoundError , InvalidParamsError , <EOL> ServerError , RequestPostError , <EOL> InvalidCredentialsError , OtherError ) <EOL> JSONRPC_VERSION_DEFAULT = '<STR_LIT>' <EOL> empty_dec = lambda f : f <EOL> try : <EOL> csrf_exempt = empty_dec <EOL> except ( NameError , ImportError ) : <EOL> csrf_exempt = empty_dec <EOL> NoneType = type ( None ) <EOL> encode_kw = lambda p : dict ( [ ( text_type ( k ) , v ) for k , v in iteritems ( p ) ] ) <EOL> def encode_kw11 ( p ) : <EOL> if not type ( p ) is dict : <EOL> return { } <EOL> ret = p . copy ( ) <EOL> removes = [ ] <EOL> for k , v in iteritems ( ret ) : <EOL> try : <EOL> int ( k ) <EOL> except ValueError : <EOL> pass <EOL> else : <EOL> removes . append ( k ) <EOL> for k in removes : <EOL> ret . pop ( k ) <EOL> return ret <EOL> def encode_arg11 ( p ) : <EOL> if type ( p ) is list : <EOL> return p <EOL> elif not type ( p ) is dict : <EOL> return [ ] <EOL> else : <EOL> pos = [ ] <EOL> d = encode_kw ( p ) <EOL> for k , v in iteritems ( d ) : <EOL> try : <EOL> pos . append ( int ( k ) ) <EOL> except ValueError : <EOL> pass <EOL> pos = list ( set ( pos ) ) <EOL> pos . sort ( ) <EOL> return [ d [ text_type ( i ) ] for i in pos ] <EOL> def validate_params ( method , D ) : <EOL> if type ( D [ '<STR_LIT>' ] ) == Object : <EOL> keys = method . json_arg_types . keys ( ) <EOL> if len ( keys ) != len ( D [ '<STR_LIT>' ] ) : <EOL> raise InvalidParamsError ( '<STR_LIT>' . format ( method . json_sig ) ) <EOL> for k in keys : <EOL> if not k in D [ '<STR_LIT>' ] : <EOL> raise InvalidParamsError ( '<STR_LIT>' . format ( k , method . json_sig ) ) <EOL> if not Any . kind ( D [ '<STR_LIT>' ] [ k ] ) == method . json_arg_types [ k ] : <EOL> raise InvalidParamsError ( '<STR_LIT>' . format ( type ( D [ '<STR_LIT>' ] [ k ] ) , method . json_arg_types [ k ] , method . json_sig ) ) <EOL> elif type ( D [ '<STR_LIT>' ] ) == Array : <EOL> arg_types = list ( method . json_arg_types . values ( ) ) <EOL> try : <EOL> for i , arg in enumerate ( D [ '<STR_LIT>' ] ) : <EOL> if not Any . kind ( arg ) == arg_types [ i ] : <EOL> raise InvalidParamsError ( '<STR_LIT>' . format ( type ( arg ) , arg_types [ i ] , method . json_sig ) ) <EOL> except IndexError : <EOL> raise InvalidParamsError ( '<STR_LIT>' . format ( method . json_sig ) ) <EOL> else : <EOL> if len ( D [ '<STR_LIT>' ] ) != len ( arg_types ) : <EOL> raise InvalidParamsError ( '<STR_LIT>' . format ( method . json_sig ) ) <EOL> class JSONRPCSite ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> self . urls = { } <EOL> self . uuid = text_type ( uuid4 ( ) ) <EOL> self . version = JSONRPC_VERSION_DEFAULT <EOL> self . name = '<STR_LIT>' <EOL> self . register ( '<STR_LIT>' , self . describe ) <EOL> def register ( self , name , method ) : <EOL> self . urls [ text_type ( name ) ] = method <EOL> def extract_id_request ( self , raw_data ) : <EOL> try : <EOL> D = json . loads ( raw_data ) <EOL> return D . get ( '<STR_LIT:id>' ) <EOL> except Exception as e : <EOL> if not raw_data is None and raw_data . find ( '<STR_LIT:id>' ) != - <NUM_LIT:1> : <EOL> find_id = re . findall ( r'<STR_LIT>' , <EOL> raw_data . replace ( '<STR_LIT:U+0020>' , '<STR_LIT>' ) , re . U ) <EOL> if find_id : <EOL> g1 , g2 = find_id [ <NUM_LIT:0> ] <EOL> raw_id = g1 if g1 else g2 <EOL> if text_type ( raw_id ) . isnumeric ( ) : <EOL> return int ( raw_id ) <EOL> return raw_id <EOL> return None <EOL> def empty_response ( self , version = JSONRPC_VERSION_DEFAULT ) : <EOL> resp = { '<STR_LIT:id>' : None } <EOL> if version == '<STR_LIT>' : <EOL> resp [ '<STR_LIT:version>' ] = version <EOL> return resp <EOL> if version == '<STR_LIT>' : <EOL> resp [ '<STR_LIT>' ] = version <EOL> resp . update ( { '<STR_LIT:error>' : None , '<STR_LIT:result>' : None } ) <EOL> return resp <EOL> def validate_get ( self , request , method ) : <EOL> encode_get_params = lambda r : dict ( [ ( k , v [ <NUM_LIT:0> ] if len ( v ) == <NUM_LIT:1> else v ) for k , v in r ] ) <EOL> if request . method == '<STR_LIT:GET>' : <EOL> method = text_type ( method ) <EOL> if method in self . urls and getattr ( self . urls [ method ] , '<STR_LIT>' , False ) : <EOL> D = { <EOL> '<STR_LIT>' : request . args . to_dict ( ) , <EOL> '<STR_LIT>' : method , <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> '<STR_LIT:version>' : '<STR_LIT>' <EOL> } <EOL> return True , D <EOL> return False , { } <EOL> def apply_version_2_0 ( self , f , p ) : <EOL> return f ( ** encode_kw ( p ) ) if type ( p ) is dict else f ( * p ) <EOL> def apply_version_1_1 ( self , f , p ) : <EOL> return f ( * encode_arg11 ( p ) , ** encode_kw ( encode_kw11 ( p ) ) ) <EOL> def apply_version_1_0 ( self , f , p ) : <EOL> return f ( * p ) <EOL> def response_obj ( self , request , D , version_hint = JSONRPC_VERSION_DEFAULT ) : <EOL> version = version_hint <EOL> response = self . empty_response ( version = version ) <EOL> apply_version = { <EOL> '<STR_LIT>' : self . apply_version_2_0 , <EOL> '<STR_LIT>' : self . apply_version_1_1 , <EOL> '<STR_LIT:1.0>' : self . apply_version_1_0 <EOL> } <EOL> try : <EOL> try : <EOL> iter ( D ) <EOL> except TypeError as e : <EOL> raise InvalidRequestError ( getattr ( e , '<STR_LIT:message>' , e . args [ <NUM_LIT:0> ] if len ( e . args ) > <NUM_LIT:0> else None ) ) <EOL> if '<STR_LIT>' in D : <EOL> if text_type ( D [ '<STR_LIT>' ] ) not in apply_version : <EOL> raise InvalidRequestError ( '<STR_LIT>' . format ( D [ '<STR_LIT>' ] ) ) <EOL> version = request . jsonrpc_version = response [ '<STR_LIT>' ] = text_type ( D [ '<STR_LIT>' ] ) <EOL> elif '<STR_LIT:version>' in D : <EOL> if text_type ( D [ '<STR_LIT:version>' ] ) not in apply_version : <EOL> raise InvalidRequestError ( '<STR_LIT>' . format ( D [ '<STR_LIT:version>' ] ) ) <EOL> version = request . jsonrpc_version = response [ '<STR_LIT:version>' ] = text_type ( D [ '<STR_LIT:version>' ] ) <EOL> else : <EOL> version = request . jsonrpc_version = JSONRPC_VERSION_DEFAULT <EOL> if '<STR_LIT>' not in D or not D [ '<STR_LIT>' ] : <EOL> D [ '<STR_LIT>' ] = [ ] <EOL> if '<STR_LIT>' not in D or '<STR_LIT>' not in D : <EOL> raise InvalidParamsError ( '<STR_LIT>' ) <EOL> if D [ '<STR_LIT>' ] not in self . urls : <EOL> raise MethodNotFoundError ( '<STR_LIT>' . format ( '<STR_LIT:\\n>' . join ( list ( self . urls . keys ( ) ) ) ) ) <EOL> method = self . urls [ text_type ( D [ '<STR_LIT>' ] ) ] <EOL> if getattr ( method , '<STR_LIT>' , False ) : <EOL> validate_params ( method , D ) <EOL> if '<STR_LIT:id>' in D and D [ '<STR_LIT:id>' ] is not None : <EOL> response [ '<STR_LIT:id>' ] = D [ '<STR_LIT:id>' ] <EOL> if version in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> response . pop ( '<STR_LIT:error>' , None ) <EOL> else : <EOL> return None , <NUM_LIT> <EOL> R = apply_version [ version ] ( method , D [ '<STR_LIT>' ] ) <EOL> if '<STR_LIT:id>' not in D or ( '<STR_LIT:id>' in D and D [ '<STR_LIT:id>' ] is None ) : <EOL> return None , <NUM_LIT> <EOL> if isinstance ( R , Response ) : <EOL> if R . status_code == <NUM_LIT:200> : <EOL> return R , R . status_code <EOL> if R . status_code == <NUM_LIT> : <EOL> raise InvalidCredentialsError ( R . status ) <EOL> raise OtherError ( R . status , R . status_code ) <EOL> try : <EOL> encoder = current_app . json_encoder ( ) <EOL> except AttributeError : <EOL> encoder = json . JSONEncoder ( ) <EOL> if not sum ( [ isinstance ( R , e ) for e in string_types + integer_types + ( float , complex , dict , list , tuple , set , frozenset , NoneType , bool ) ] ) : <EOL> try : <EOL> rs = encoder . default ( R ) <EOL> except TypeError as exc : <EOL> raise TypeError ( '<STR_LIT>' . format ( R ) ) <EOL> response [ '<STR_LIT:result>' ] = R <EOL> status = <NUM_LIT:200> <EOL> except Error as e : <EOL> response [ '<STR_LIT:error>' ] = e . json_rpc_format <EOL> if version in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> response . pop ( '<STR_LIT:result>' , None ) <EOL> status = e . status <EOL> except HTTPException as e : <EOL> other_error = OtherError ( e ) <EOL> response [ '<STR_LIT:error>' ] = other_error . json_rpc_format <EOL> response [ '<STR_LIT:error>' ] [ '<STR_LIT:code>' ] = e . code <EOL> if version in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> response . pop ( '<STR_LIT:result>' , None ) <EOL> status = e . code <EOL> except Exception as e : <EOL> other_error = OtherError ( e ) <EOL> response [ '<STR_LIT:error>' ] = other_error . json_rpc_format <EOL> status = other_error . status <EOL> if version in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> response . pop ( '<STR_LIT:result>' , None ) <EOL> if version in ( '<STR_LIT>' , '<STR_LIT>' ) and '<STR_LIT:result>' in response : <EOL> response . pop ( '<STR_LIT:error>' , None ) <EOL> return response , status <EOL> def batch_response_obj ( self , request , D ) : <EOL> status = <NUM_LIT:200> <EOL> try : <EOL> responses = [ self . response_obj ( request , d ) [ <NUM_LIT:0> ] for d in D ] <EOL> if not responses : <EOL> raise InvalidRequestError ( '<STR_LIT>' ) <EOL> except Error as e : <EOL> for response in responses : <EOL> response . pop ( '<STR_LIT:result>' , None ) <EOL> response [ '<STR_LIT:error>' ] = e . json_rpc_format <EOL> except Exception as e : <EOL> other_error = OtherError ( e ) <EOL> for response in responses : <EOL> response . pop ( '<STR_LIT:result>' , None ) <EOL> response [ '<STR_LIT:error>' ] = other_error . json_rpc_format <EOL> for response in responses : <EOL> if response is None : <EOL> continue <EOL> if '<STR_LIT:result>' in response : <EOL> response . pop ( '<STR_LIT:error>' , None ) <EOL> if not responses : <EOL> response = self . empty_response ( version = '<STR_LIT>' ) <EOL> response [ '<STR_LIT:error>' ] = InvalidRequestError ( ) . json_rpc_format <EOL> response . pop ( '<STR_LIT:result>' , None ) <EOL> responses = response <EOL> if not all ( responses ) : <EOL> return '<STR_LIT>' , <NUM_LIT> <EOL> return responses , status <EOL> def make_response ( self , rv ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> status_or_headers = headers = None <EOL> if isinstance ( rv , tuple ) : <EOL> rv , status_or_headers , headers = rv + ( None , ) * ( <NUM_LIT:3> - len ( rv ) ) <EOL> if rv is None : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> if isinstance ( status_or_headers , ( dict , list ) ) : <EOL> headers , status_or_headers = status_or_headers , None <EOL> D = json . loads ( extract_raw_data_request ( request ) ) <EOL> if type ( D ) is list : <EOL> raise InvalidRequestError ( '<STR_LIT>' ) <EOL> else : <EOL> response_obj = self . empty_response ( version = D [ '<STR_LIT>' ] ) <EOL> response_obj [ '<STR_LIT:id>' ] = D [ '<STR_LIT:id>' ] <EOL> response_obj [ '<STR_LIT:result>' ] = rv <EOL> response_obj . pop ( '<STR_LIT:error>' , None ) <EOL> rv = jsonify ( response_obj ) <EOL> if status_or_headers is not None : <EOL> if isinstance ( status_or_headers , string_types ) : <EOL> rv . status = status_or_headers <EOL> else : <EOL> rv . status_code = status_or_headers <EOL>", "answer": "if headers :"}, {"prompt": "<s> from __future__ import print_function <EOL> from optparse import make_option <EOL> from django . core . management . base import BaseCommand , CommandError <EOL> from waffle . models import Sample <EOL> class Command ( BaseCommand ) : <EOL> option_list = BaseCommand . option_list + ( <EOL> make_option ( '<STR_LIT>' , '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , dest = '<STR_LIT>' , default = False , <EOL> help = '<STR_LIT>' ) , <EOL> make_option ( '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> dest = '<STR_LIT>' , <EOL> default = False , <EOL> help = \"<STR_LIT>\" ) , <EOL> ) <EOL> help = '<STR_LIT>' <EOL> args = '<STR_LIT>' <EOL> def handle ( self , sample_name = None , percent = None , * args , ** options ) : <EOL> list_sample = options [ '<STR_LIT>' ] <EOL> if list_sample : <EOL> print ( '<STR_LIT>' ) <EOL> for sample in Sample . objects . iterator ( ) : <EOL> print ( '<STR_LIT>' % ( sample . name , sample . percent ) ) <EOL> return <EOL> if not ( sample_name and percent ) : <EOL> raise CommandError ( '<STR_LIT>' <EOL>", "answer": "'<STR_LIT>' )"}, {"prompt": "<s> from hazelcast . serialization . bits import * <EOL> from hazelcast . protocol . client_message import ClientMessage <EOL> from hazelcast . protocol . custom_codec import * <EOL> from hazelcast . util import ImmutableLazyDataList <EOL> from hazelcast . protocol . codec . transaction_message_type import * <EOL> REQUEST_TYPE = TRANSACTION_COMMIT <EOL> RESPONSE_TYPE = <NUM_LIT:100> <EOL> RETRYABLE = False <EOL> def calculate_size ( transaction_id , thread_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> data_size = <NUM_LIT:0> <EOL> data_size += calculate_size_str ( transaction_id ) <EOL> data_size += LONG_SIZE_IN_BYTES <EOL> return data_size <EOL> def encode_request ( transaction_id , thread_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "client_message = ClientMessage ( payload_size = calculate_size ( transaction_id , thread_id ) )"}, {"prompt": "<s> from loads import * <EOL>", "answer": "from subcases import * "}, {"prompt": "<s> import httplib <EOL> import requests <EOL> from st2actions . runners . pythonrunner import Action <EOL> class BaseAction ( Action ) : <EOL> def __init__ ( self , config ) : <EOL>", "answer": "super ( BaseAction , self ) . __init__ ( config )"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import re <EOL> from comments import Comments <EOL> def strip_dangling_commas ( text , preserve_lines = False ) : <EOL> regex = re . compile ( <EOL> r\"\"\"<STR_LIT>\"\"\" , <EOL> re . MULTILINE | re . DOTALL <EOL> ) <EOL> def remove_comma ( m , preserve_lines = False ) : <EOL> if preserve_lines : <EOL> return m . group ( <NUM_LIT:3> ) + m . group ( <NUM_LIT:4> ) if m . group ( <NUM_LIT:2> ) else m . group ( <NUM_LIT:6> ) + m . group ( <NUM_LIT:7> ) <EOL>", "answer": "else :"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from ming . odm import mapper <EOL> from ming . odm . property import FieldProperty <EOL> from ming . odm . base import session , state , ObjectState <EOL> from ming . odm . odmsession import SessionExtension <EOL> from ming . schema import Anything <EOL> from depot . manager import DepotManager <EOL> from . upload import UploadedFile <EOL> class _UploadedFileSchema ( Anything ) : <EOL> pass <EOL> class UploadedFileProperty ( FieldProperty ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , filters = tuple ( ) , upload_type = UploadedFile , upload_storage = None ) : <EOL> FieldProperty . __init__ ( self , _UploadedFileSchema ( ) ) <EOL> self . _filters = filters <EOL> self . _upload_type = upload_type <EOL> self . _upload_storage = upload_storage <EOL> def __set__ ( self , instance , value ) : <EOL> if value is not None and not isinstance ( value , UploadedFile ) : <EOL> upload_type = self . _upload_type <EOL> value = upload_type ( value , self . _upload_storage ) <EOL> if isinstance ( value , UploadedFile ) : <EOL> value . _apply_filters ( self . _filters ) <EOL> old_value = self . __get__ ( instance , instance . __class__ ) <EOL> DepotExtension . get_depot_history ( instance ) . swap ( old_value , value ) <EOL> return FieldProperty . __set__ ( self , instance , value ) <EOL> def __get__ ( self , instance , owner = None ) : <EOL> try : <EOL> value = FieldProperty . __get__ ( self , instance , owner ) <EOL> except AttributeError : <EOL> value = None <EOL> if not value : <EOL> return None <EOL> if instance is None : <EOL> return value <EOL> return self . _upload_type ( value ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class DepotExtension ( SessionExtension ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ classmethod <EOL> def get_depot_history ( cls , instance ) : <EOL> istate = state ( instance ) <EOL> if not hasattr ( istate , '<STR_LIT>' ) : <EOL> istate . _depot_history = _DepotHistory ( ) <EOL> return istate . _depot_history <EOL> def _check_object_deleted ( self , obj ) : <EOL> hist = self . get_depot_history ( obj ) <EOL> if state ( obj ) . status == ObjectState . deleted : <EOL> for prop in mapper ( obj ) . properties : <EOL> if isinstance ( prop , UploadedFileProperty ) : <EOL> current_value = prop . __get__ ( obj , obj . __class__ ) <EOL> hist . delete ( current_value ) <EOL> self . _flush_object ( obj ) <EOL> def _flush_object ( self , obj ) : <EOL> history = self . get_depot_history ( obj ) <EOL> for entry in history . deleted : <EOL> depot , fileid = entry . split ( '<STR_LIT:/>' , <NUM_LIT:1> ) <EOL> depot = DepotManager . get ( depot ) <EOL> depot . delete ( fileid ) <EOL> history . clear ( ) <EOL> def before_flush ( self , obj = None ) : <EOL> if obj : <EOL> self . _check_object_deleted ( obj ) <EOL> else : <EOL> for class_ , id_ , obj in self . session . imap : <EOL> self . _check_object_deleted ( obj ) <EOL> def after_flush ( self , obj = None ) : <EOL> if obj : <EOL> self . _flush_object ( obj ) <EOL> else : <EOL> for class_ , id_ , obj in self . session . imap : <EOL> self . _flush_object ( obj ) <EOL> class _DepotHistory ( object ) : <EOL> def __init__ ( self ) : <EOL>", "answer": "self . clear ( )"}, {"prompt": "<s> import xml . sax <EOL> import xml . sax . handler <EOL> import types <EOL> try : <EOL> _StringTypes = [ types . StringType , types . UnicodeType ] <EOL> except AttributeError : <EOL> _StringTypes = [ types . StringType ] <EOL> START_ELEMENT = \"<STR_LIT>\" <EOL> END_ELEMENT = \"<STR_LIT>\" <EOL> COMMENT = \"<STR_LIT>\" <EOL> START_DOCUMENT = \"<STR_LIT>\" <EOL> END_DOCUMENT = \"<STR_LIT>\" <EOL> PROCESSING_INSTRUCTION = \"<STR_LIT>\" <EOL> IGNORABLE_WHITESPACE = \"<STR_LIT>\" <EOL> CHARACTERS = \"<STR_LIT>\" <EOL> class PullDOM ( xml . sax . ContentHandler ) : <EOL> _locator = None <EOL> document = None <EOL> def __init__ ( self , documentFactory = None ) : <EOL> from xml . dom import XML_NAMESPACE <EOL> self . documentFactory = documentFactory <EOL> self . firstEvent = [ None , None ] <EOL> self . lastEvent = self . firstEvent <EOL> self . elementStack = [ ] <EOL> self . push = self . elementStack . append <EOL> try : <EOL> self . pop = self . elementStack . pop <EOL> except AttributeError : <EOL> pass <EOL> self . _ns_contexts = [ { XML_NAMESPACE : '<STR_LIT>' } ] <EOL> self . _current_context = self . _ns_contexts [ - <NUM_LIT:1> ] <EOL> self . pending_events = [ ] <EOL> def pop ( self ) : <EOL> result = self . elementStack [ - <NUM_LIT:1> ] <EOL> del self . elementStack [ - <NUM_LIT:1> ] <EOL> return result <EOL> def setDocumentLocator ( self , locator ) : <EOL> self . _locator = locator <EOL> def startPrefixMapping ( self , prefix , uri ) : <EOL>", "answer": "if not hasattr ( self , '<STR_LIT>' ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import unicode_literals <EOL> from django . template import ( <EOL> loader , <EOL> RequestContext , <EOL> ) <EOL> from django . utils . encoding import iri_to_uri <EOL> from el_pagination import ( <EOL> loaders , <EOL> settings , <EOL> utils , <EOL> ) <EOL> _template_cache = { } <EOL> class ELPage ( utils . UnicodeMixin ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( <EOL>", "answer": "self , request , number , current_number , total_number ,"}, {"prompt": "<s> from aliyunsdkcore . request import RoaRequest <EOL> class DeleteImageRequest ( RoaRequest ) : <EOL> def __init__ ( self ) : <EOL> RoaRequest . __init__ ( self , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . set_uri_pattern ( self , '<STR_LIT>' ) <EOL> self . set_method ( self , '<STR_LIT>' ) <EOL>", "answer": "def get_ResourceName ( self ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __all__ = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> import struct <EOL> import binascii <EOL> from . yubico_version import __version__ <EOL> from . yubikey_defs import SLOT , MODE <EOL> from . import yubikey_usb_hid <EOL> from . import yubikey_base <EOL> from . import yubikey_frame <EOL> from . import yubico_exception <EOL> from . import yubico_util <EOL> _ACC_CODE_SIZE = <NUM_LIT:6> <EOL> _NDEF_DATA_SIZE = <NUM_LIT> <EOL> _NDEF_URI_TYPE = ord ( '<STR_LIT>' ) <EOL> _NDEF_TEXT_TYPE = ord ( '<STR_LIT:T>' ) <EOL> uri_identifiers = [ <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL> ( <NUM_LIT> , \"<STR_LIT>\" , ) , <EOL>", "answer": "( <NUM_LIT> , \"<STR_LIT>\" , ) ,"}, {"prompt": "<s> from hazelcast . serialization . bits import * <EOL> from hazelcast . protocol . client_message import ClientMessage <EOL> from hazelcast . protocol . custom_codec import * <EOL> from hazelcast . util import ImmutableLazyDataList <EOL> from hazelcast . protocol . codec . atomic_reference_message_type import * <EOL> REQUEST_TYPE = ATOMICREFERENCE_GET <EOL>", "answer": "RESPONSE_TYPE = <NUM_LIT>"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "from . api import slack_message "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function , division <EOL> from sympy . polys . densebasic import ( <EOL> dup_strip , dmp_raise , <EOL> dmp_zero , dmp_one , dmp_ground , <EOL> dmp_one_p , dmp_zero_p , <EOL> dmp_zeros , <EOL> dup_degree , dmp_degree , dmp_degree_in , <EOL> dup_LC , dmp_LC , dmp_ground_LC , <EOL> dmp_multi_deflate , dmp_inflate , <EOL> dup_convert , dmp_convert , <EOL> dmp_apply_pairs ) <EOL> from sympy . polys . densearith import ( <EOL> dup_sub_mul , <EOL> dup_neg , dmp_neg , <EOL> dmp_add , <EOL> dmp_sub , <EOL> dup_mul , dmp_mul , <EOL> dmp_pow , <EOL> dup_div , dmp_div , <EOL> dup_rem , <EOL> dup_quo , dmp_quo , <EOL> dup_prem , dmp_prem , <EOL> dup_mul_ground , dmp_mul_ground , <EOL> dmp_mul_term , <EOL> dup_quo_ground , dmp_quo_ground , <EOL> dup_max_norm , dmp_max_norm ) <EOL> from sympy . polys . densetools import ( <EOL> dup_clear_denoms , dmp_clear_denoms , <EOL> dup_diff , dmp_diff , <EOL> dup_eval , dmp_eval , dmp_eval_in , <EOL> dup_trunc , dmp_ground_trunc , <EOL> dup_monic , dmp_ground_monic , <EOL> dup_primitive , dmp_ground_primitive , <EOL> dup_extract , dmp_ground_extract ) <EOL> from sympy . polys . galoistools import ( <EOL> gf_int , gf_crt ) <EOL> from sympy . polys . polyerrors import ( <EOL> MultivariatePolynomialError , <EOL> HeuristicGCDFailed , <EOL> HomomorphismFailed , <EOL> NotInvertible , <EOL> DomainError ) <EOL> from sympy . polys . polyconfig import query <EOL> from sympy . ntheory import nextprime <EOL> from sympy . core . compatibility import range <EOL> def dup_half_gcdex ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not K . has_Field : <EOL> raise DomainError ( \"<STR_LIT>\" % K ) <EOL> a , b = [ K . one ] , [ ] <EOL> while g : <EOL> q , r = dup_div ( f , g , K ) <EOL> f , g = g , r <EOL> a , b = b , dup_sub_mul ( a , q , b , K ) <EOL> a = dup_quo_ground ( a , dup_LC ( f , K ) , K ) <EOL> f = dup_monic ( f , K ) <EOL> return a , f <EOL> def dmp_half_gcdex ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not u : <EOL> return dup_half_gcdex ( f , g , K ) <EOL> else : <EOL> raise MultivariatePolynomialError ( f , g ) <EOL> def dup_gcdex ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> s , h = dup_half_gcdex ( f , g , K ) <EOL> F = dup_sub_mul ( h , s , f , K ) <EOL> t = dup_quo ( F , g , K ) <EOL> return s , t , h <EOL> def dmp_gcdex ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not u : <EOL> return dup_gcdex ( f , g , K ) <EOL> else : <EOL> raise MultivariatePolynomialError ( f , g ) <EOL> def dup_invert ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> s , h = dup_half_gcdex ( f , g , K ) <EOL> if h == [ K . one ] : <EOL> return dup_rem ( s , g , K ) <EOL> else : <EOL> raise NotInvertible ( \"<STR_LIT>\" ) <EOL> def dmp_invert ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not u : <EOL> return dup_invert ( f , g , K ) <EOL> else : <EOL> raise MultivariatePolynomialError ( f , g ) <EOL> def dup_euclidean_prs ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> prs = [ f , g ] <EOL> h = dup_rem ( f , g , K ) <EOL> while h : <EOL> prs . append ( h ) <EOL> f , g = g , h <EOL> h = dup_rem ( f , g , K ) <EOL> return prs <EOL> def dmp_euclidean_prs ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not u : <EOL> return dup_euclidean_prs ( f , g , K ) <EOL> else : <EOL> raise MultivariatePolynomialError ( f , g ) <EOL> def dup_primitive_prs ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> prs = [ f , g ] <EOL> _ , h = dup_primitive ( dup_prem ( f , g , K ) , K ) <EOL> while h : <EOL> prs . append ( h ) <EOL> f , g = g , h <EOL> _ , h = dup_primitive ( dup_prem ( f , g , K ) , K ) <EOL> return prs <EOL> def dmp_primitive_prs ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not u : <EOL> return dup_primitive_prs ( f , g , K ) <EOL> else : <EOL> raise MultivariatePolynomialError ( f , g ) <EOL> def dup_inner_subresultants ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> n = dup_degree ( f ) <EOL> m = dup_degree ( g ) <EOL> if n < m : <EOL> f , g = g , f <EOL> n , m = m , n <EOL> if not f : <EOL> return [ ] , [ ] <EOL> if not g : <EOL> return [ f ] , [ K . one ] <EOL> R = [ f , g ] <EOL> d = n - m <EOL> b = ( - K . one ) ** ( d + <NUM_LIT:1> ) <EOL> h = dup_prem ( f , g , K ) <EOL> h = dup_mul_ground ( h , b , K ) <EOL> lc = dup_LC ( g , K ) <EOL> c = lc ** d <EOL> S = [ K . one , c ] <EOL> c = - c <EOL> while h : <EOL> k = dup_degree ( h ) <EOL> R . append ( h ) <EOL> f , g , m , d = g , h , k , m - k <EOL> b = - lc * c ** d <EOL> h = dup_prem ( f , g , K ) <EOL> h = dup_quo_ground ( h , b , K ) <EOL> lc = dup_LC ( g , K ) <EOL> if d > <NUM_LIT:1> : <EOL> q = c ** ( d - <NUM_LIT:1> ) <EOL> c = K . quo ( ( - lc ) ** d , q ) <EOL> else : <EOL> c = - lc <EOL> S . append ( - c ) <EOL> return R , S <EOL> def dup_subresultants ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return dup_inner_subresultants ( f , g , K ) [ <NUM_LIT:0> ] <EOL> def dup_prs_resultant ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not f or not g : <EOL> return ( K . zero , [ ] ) <EOL> R , S = dup_inner_subresultants ( f , g , K ) <EOL> if dup_degree ( R [ - <NUM_LIT:1> ] ) > <NUM_LIT:0> : <EOL> return ( K . zero , R ) <EOL> return S [ - <NUM_LIT:1> ] , R <EOL> def dup_resultant ( f , g , K , includePRS = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if includePRS : <EOL> return dup_prs_resultant ( f , g , K ) <EOL> return dup_prs_resultant ( f , g , K ) [ <NUM_LIT:0> ] <EOL> def dmp_inner_subresultants ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not u : <EOL> return dup_inner_subresultants ( f , g , K ) <EOL> n = dmp_degree ( f , u ) <EOL> m = dmp_degree ( g , u ) <EOL> if n < m : <EOL> f , g = g , f <EOL> n , m = m , n <EOL> if dmp_zero_p ( f , u ) : <EOL> return [ ] , [ ] <EOL> v = u - <NUM_LIT:1> <EOL> if dmp_zero_p ( g , u ) : <EOL> return [ f ] , [ dmp_ground ( K . one , v ) ] <EOL> R = [ f , g ] <EOL> d = n - m <EOL> b = dmp_pow ( dmp_ground ( - K . one , v ) , d + <NUM_LIT:1> , v , K ) <EOL> h = dmp_prem ( f , g , u , K ) <EOL> h = dmp_mul_term ( h , b , <NUM_LIT:0> , u , K ) <EOL> lc = dmp_LC ( g , K ) <EOL> c = dmp_pow ( lc , d , v , K ) <EOL> S = [ dmp_ground ( K . one , v ) , c ] <EOL> c = dmp_neg ( c , v , K ) <EOL> while not dmp_zero_p ( h , u ) : <EOL> k = dmp_degree ( h , u ) <EOL> R . append ( h ) <EOL> f , g , m , d = g , h , k , m - k <EOL> b = dmp_mul ( dmp_neg ( lc , v , K ) , <EOL> dmp_pow ( c , d , v , K ) , v , K ) <EOL> h = dmp_prem ( f , g , u , K ) <EOL> h = [ dmp_quo ( ch , b , v , K ) for ch in h ] <EOL> lc = dmp_LC ( g , K ) <EOL> if d > <NUM_LIT:1> : <EOL> p = dmp_pow ( dmp_neg ( lc , v , K ) , d , v , K ) <EOL> q = dmp_pow ( c , d - <NUM_LIT:1> , v , K ) <EOL> c = dmp_quo ( p , q , v , K ) <EOL> else : <EOL> c = dmp_neg ( lc , v , K ) <EOL> S . append ( dmp_neg ( c , v , K ) ) <EOL> return R , S <EOL> def dmp_subresultants ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return dmp_inner_subresultants ( f , g , u , K ) [ <NUM_LIT:0> ] <EOL> def dmp_prs_resultant ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not u : <EOL> return dup_prs_resultant ( f , g , K ) <EOL> if dmp_zero_p ( f , u ) or dmp_zero_p ( g , u ) : <EOL> return ( dmp_zero ( u - <NUM_LIT:1> ) , [ ] ) <EOL> R , S = dmp_inner_subresultants ( f , g , u , K ) <EOL> if dmp_degree ( R [ - <NUM_LIT:1> ] , u ) > <NUM_LIT:0> : <EOL> return ( dmp_zero ( u - <NUM_LIT:1> ) , R ) <EOL> return S [ - <NUM_LIT:1> ] , R <EOL> def dmp_zz_modular_resultant ( f , g , p , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not u : <EOL> return gf_int ( dup_prs_resultant ( f , g , K ) [ <NUM_LIT:0> ] % p , p ) <EOL> v = u - <NUM_LIT:1> <EOL> n = dmp_degree ( f , u ) <EOL> m = dmp_degree ( g , u ) <EOL> N = dmp_degree_in ( f , <NUM_LIT:1> , u ) <EOL> M = dmp_degree_in ( g , <NUM_LIT:1> , u ) <EOL> B = n * M + m * N <EOL> D , a = [ K . one ] , - K . one <EOL> r = dmp_zero ( v ) <EOL> while dup_degree ( D ) <= B : <EOL> while True : <EOL> a += K . one <EOL> if a == p : <EOL> raise HomomorphismFailed ( '<STR_LIT>' ) <EOL> F = dmp_eval_in ( f , gf_int ( a , p ) , <NUM_LIT:1> , u , K ) <EOL> if dmp_degree ( F , v ) == n : <EOL> G = dmp_eval_in ( g , gf_int ( a , p ) , <NUM_LIT:1> , u , K ) <EOL> if dmp_degree ( G , v ) == m : <EOL> break <EOL> R = dmp_zz_modular_resultant ( F , G , p , v , K ) <EOL> e = dmp_eval ( r , a , v , K ) <EOL> if not v : <EOL> R = dup_strip ( [ R ] ) <EOL> e = dup_strip ( [ e ] ) <EOL> else : <EOL> R = [ R ] <EOL> e = [ e ] <EOL> d = K . invert ( dup_eval ( D , a , K ) , p ) <EOL> d = dup_mul_ground ( D , d , K ) <EOL> d = dmp_raise ( d , v , <NUM_LIT:0> , K ) <EOL> c = dmp_mul ( d , dmp_sub ( R , e , v , K ) , v , K ) <EOL> r = dmp_add ( r , c , v , K ) <EOL> r = dmp_ground_trunc ( r , p , v , K ) <EOL> D = dup_mul ( D , [ K . one , - a ] , K ) <EOL> D = dup_trunc ( D , p , K ) <EOL> return r <EOL> def _collins_crt ( r , R , P , p , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return gf_int ( gf_crt ( [ r , R ] , [ P , p ] , K ) , P * p ) <EOL> def dmp_zz_collins_resultant ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> n = dmp_degree ( f , u ) <EOL> m = dmp_degree ( g , u ) <EOL> if n < <NUM_LIT:0> or m < <NUM_LIT:0> : <EOL> return dmp_zero ( u - <NUM_LIT:1> ) <EOL> A = dmp_max_norm ( f , u , K ) <EOL> B = dmp_max_norm ( g , u , K ) <EOL> a = dmp_ground_LC ( f , u , K ) <EOL> b = dmp_ground_LC ( g , u , K ) <EOL> v = u - <NUM_LIT:1> <EOL> B = K ( <NUM_LIT:2> ) * K . factorial ( K ( n + m ) ) * A ** m * B ** n <EOL> r , p , P = dmp_zero ( v ) , K . one , K . one <EOL> while P <= B : <EOL> p = K ( nextprime ( p ) ) <EOL> while not ( a % p ) or not ( b % p ) : <EOL> p = K ( nextprime ( p ) ) <EOL> F = dmp_ground_trunc ( f , p , u , K ) <EOL> G = dmp_ground_trunc ( g , p , u , K ) <EOL> try : <EOL> R = dmp_zz_modular_resultant ( F , G , p , u , K ) <EOL> except HomomorphismFailed : <EOL> continue <EOL> if K . is_one ( P ) : <EOL> r = R <EOL> else : <EOL> r = dmp_apply_pairs ( r , R , _collins_crt , ( P , p , K ) , v , K ) <EOL> P *= p <EOL> return r <EOL> def dmp_qq_collins_resultant ( f , g , u , K0 ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> n = dmp_degree ( f , u ) <EOL> m = dmp_degree ( g , u ) <EOL> if n < <NUM_LIT:0> or m < <NUM_LIT:0> : <EOL> return dmp_zero ( u - <NUM_LIT:1> ) <EOL> K1 = K0 . get_ring ( ) <EOL> cf , f = dmp_clear_denoms ( f , u , K0 , K1 ) <EOL> cg , g = dmp_clear_denoms ( g , u , K0 , K1 ) <EOL> f = dmp_convert ( f , u , K0 , K1 ) <EOL> g = dmp_convert ( g , u , K0 , K1 ) <EOL> r = dmp_zz_collins_resultant ( f , g , u , K1 ) <EOL> r = dmp_convert ( r , u - <NUM_LIT:1> , K1 , K0 ) <EOL> c = K0 . convert ( cf ** m * cg ** n , K1 ) <EOL> return dmp_quo_ground ( r , c , u - <NUM_LIT:1> , K0 ) <EOL> def dmp_resultant ( f , g , u , K , includePRS = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not u : <EOL> return dup_resultant ( f , g , K , includePRS = includePRS ) <EOL> if includePRS : <EOL> return dmp_prs_resultant ( f , g , u , K ) <EOL> if K . has_Field : <EOL> if K . is_QQ and query ( '<STR_LIT>' ) : <EOL> return dmp_qq_collins_resultant ( f , g , u , K ) <EOL> else : <EOL> if K . is_ZZ and query ( '<STR_LIT>' ) : <EOL> return dmp_zz_collins_resultant ( f , g , u , K ) <EOL> return dmp_prs_resultant ( f , g , u , K ) [ <NUM_LIT:0> ] <EOL> def dup_discriminant ( f , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> d = dup_degree ( f ) <EOL> if d <= <NUM_LIT:0> : <EOL> return K . zero <EOL> else : <EOL> s = ( - <NUM_LIT:1> ) ** ( ( d * ( d - <NUM_LIT:1> ) ) // <NUM_LIT:2> ) <EOL> c = dup_LC ( f , K ) <EOL> r = dup_resultant ( f , dup_diff ( f , <NUM_LIT:1> , K ) , K ) <EOL> return K . quo ( r , c * K ( s ) ) <EOL> def dmp_discriminant ( f , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not u : <EOL> return dup_discriminant ( f , K ) <EOL> d , v = dmp_degree ( f , u ) , u - <NUM_LIT:1> <EOL> if d <= <NUM_LIT:0> : <EOL> return dmp_zero ( v ) <EOL> else : <EOL> s = ( - <NUM_LIT:1> ) ** ( ( d * ( d - <NUM_LIT:1> ) ) // <NUM_LIT:2> ) <EOL> c = dmp_LC ( f , K ) <EOL> r = dmp_resultant ( f , dmp_diff ( f , <NUM_LIT:1> , u , K ) , u , K ) <EOL> c = dmp_mul_ground ( c , K ( s ) , v , K ) <EOL> return dmp_quo ( r , c , v , K ) <EOL> def _dup_rr_trivial_gcd ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not ( f or g ) : <EOL> return [ ] , [ ] , [ ] <EOL> elif not f : <EOL> if K . is_nonnegative ( dup_LC ( g , K ) ) : <EOL> return g , [ ] , [ K . one ] <EOL> else : <EOL> return dup_neg ( g , K ) , [ ] , [ - K . one ] <EOL> elif not g : <EOL> if K . is_nonnegative ( dup_LC ( f , K ) ) : <EOL> return f , [ K . one ] , [ ] <EOL> else : <EOL> return dup_neg ( f , K ) , [ - K . one ] , [ ] <EOL> return None <EOL> def _dup_ff_trivial_gcd ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not ( f or g ) : <EOL> return [ ] , [ ] , [ ] <EOL> elif not f : <EOL> return dup_monic ( g , K ) , [ ] , [ dup_LC ( g , K ) ] <EOL> elif not g : <EOL> return dup_monic ( f , K ) , [ dup_LC ( f , K ) ] , [ ] <EOL> else : <EOL> return None <EOL> def _dmp_rr_trivial_gcd ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> zero_f = dmp_zero_p ( f , u ) <EOL> zero_g = dmp_zero_p ( g , u ) <EOL> if_contain_one = dmp_one_p ( f , u , K ) or dmp_one_p ( g , u , K ) <EOL> if zero_f and zero_g : <EOL> return tuple ( dmp_zeros ( <NUM_LIT:3> , u , K ) ) <EOL> elif zero_f : <EOL> if K . is_nonnegative ( dmp_ground_LC ( g , u , K ) ) : <EOL> return g , dmp_zero ( u ) , dmp_one ( u , K ) <EOL> else : <EOL> return dmp_neg ( g , u , K ) , dmp_zero ( u ) , dmp_ground ( - K . one , u ) <EOL> elif zero_g : <EOL> if K . is_nonnegative ( dmp_ground_LC ( f , u , K ) ) : <EOL> return f , dmp_one ( u , K ) , dmp_zero ( u ) <EOL> else : <EOL> return dmp_neg ( f , u , K ) , dmp_ground ( - K . one , u ) , dmp_zero ( u ) <EOL> elif if_contain_one : <EOL> return dmp_one ( u , K ) , f , g <EOL> elif query ( '<STR_LIT>' ) : <EOL> return _dmp_simplify_gcd ( f , g , u , K ) <EOL> else : <EOL> return None <EOL> def _dmp_ff_trivial_gcd ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> zero_f = dmp_zero_p ( f , u ) <EOL> zero_g = dmp_zero_p ( g , u ) <EOL> if zero_f and zero_g : <EOL> return tuple ( dmp_zeros ( <NUM_LIT:3> , u , K ) ) <EOL> elif zero_f : <EOL> return ( dmp_ground_monic ( g , u , K ) , <EOL> dmp_zero ( u ) , <EOL> dmp_ground ( dmp_ground_LC ( g , u , K ) , u ) ) <EOL> elif zero_g : <EOL> return ( dmp_ground_monic ( f , u , K ) , <EOL> dmp_ground ( dmp_ground_LC ( f , u , K ) , u ) , <EOL> dmp_zero ( u ) ) <EOL> elif query ( '<STR_LIT>' ) : <EOL> return _dmp_simplify_gcd ( f , g , u , K ) <EOL> else : <EOL> return None <EOL> def _dmp_simplify_gcd ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> df = dmp_degree ( f , u ) <EOL> dg = dmp_degree ( g , u ) <EOL> if df > <NUM_LIT:0> and dg > <NUM_LIT:0> : <EOL> return None <EOL> if not ( df or dg ) : <EOL> F = dmp_LC ( f , K ) <EOL> G = dmp_LC ( g , K ) <EOL> else : <EOL> if not df : <EOL> F = dmp_LC ( f , K ) <EOL> G = dmp_content ( g , u , K ) <EOL> else : <EOL> F = dmp_content ( f , u , K ) <EOL> G = dmp_LC ( g , K ) <EOL> v = u - <NUM_LIT:1> <EOL> h = dmp_gcd ( F , G , v , K ) <EOL> cff = [ dmp_quo ( cf , h , v , K ) for cf in f ] <EOL> cfg = [ dmp_quo ( cg , h , v , K ) for cg in g ] <EOL> return [ h ] , cff , cfg <EOL> def dup_rr_prs_gcd ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = _dup_rr_trivial_gcd ( f , g , K ) <EOL> if result is not None : <EOL> return result <EOL> fc , F = dup_primitive ( f , K ) <EOL> gc , G = dup_primitive ( g , K ) <EOL> c = K . gcd ( fc , gc ) <EOL> h = dup_subresultants ( F , G , K ) [ - <NUM_LIT:1> ] <EOL> _ , h = dup_primitive ( h , K ) <EOL> if K . is_negative ( dup_LC ( h , K ) ) : <EOL> c = - c <EOL> h = dup_mul_ground ( h , c , K ) <EOL> cff = dup_quo ( f , h , K ) <EOL> cfg = dup_quo ( g , h , K ) <EOL> return h , cff , cfg <EOL> def dup_ff_prs_gcd ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = _dup_ff_trivial_gcd ( f , g , K ) <EOL> if result is not None : <EOL> return result <EOL> h = dup_subresultants ( f , g , K ) [ - <NUM_LIT:1> ] <EOL> h = dup_monic ( h , K ) <EOL> cff = dup_quo ( f , h , K ) <EOL> cfg = dup_quo ( g , h , K ) <EOL> return h , cff , cfg <EOL> def dmp_rr_prs_gcd ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not u : <EOL> return dup_rr_prs_gcd ( f , g , K ) <EOL> result = _dmp_rr_trivial_gcd ( f , g , u , K ) <EOL> if result is not None : <EOL> return result <EOL> fc , F = dmp_primitive ( f , u , K ) <EOL> gc , G = dmp_primitive ( g , u , K ) <EOL> h = dmp_subresultants ( F , G , u , K ) [ - <NUM_LIT:1> ] <EOL> c , _ , _ = dmp_rr_prs_gcd ( fc , gc , u - <NUM_LIT:1> , K ) <EOL> if K . is_negative ( dmp_ground_LC ( h , u , K ) ) : <EOL> h = dmp_neg ( h , u , K ) <EOL> _ , h = dmp_primitive ( h , u , K ) <EOL> h = dmp_mul_term ( h , c , <NUM_LIT:0> , u , K ) <EOL> cff = dmp_quo ( f , h , u , K ) <EOL> cfg = dmp_quo ( g , h , u , K ) <EOL> return h , cff , cfg <EOL> def dmp_ff_prs_gcd ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not u : <EOL> return dup_ff_prs_gcd ( f , g , K ) <EOL> result = _dmp_ff_trivial_gcd ( f , g , u , K ) <EOL> if result is not None : <EOL> return result <EOL> fc , F = dmp_primitive ( f , u , K ) <EOL> gc , G = dmp_primitive ( g , u , K ) <EOL> h = dmp_subresultants ( F , G , u , K ) [ - <NUM_LIT:1> ] <EOL> c , _ , _ = dmp_ff_prs_gcd ( fc , gc , u - <NUM_LIT:1> , K ) <EOL> _ , h = dmp_primitive ( h , u , K ) <EOL> h = dmp_mul_term ( h , c , <NUM_LIT:0> , u , K ) <EOL> h = dmp_ground_monic ( h , u , K ) <EOL> cff = dmp_quo ( f , h , u , K ) <EOL> cfg = dmp_quo ( g , h , u , K ) <EOL> return h , cff , cfg <EOL> HEU_GCD_MAX = <NUM_LIT:6> <EOL> def _dup_zz_gcd_interpolate ( h , x , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> f = [ ] <EOL> while h : <EOL> g = h % x <EOL> if g > x // <NUM_LIT:2> : <EOL> g -= x <EOL> f . insert ( <NUM_LIT:0> , g ) <EOL> h = ( h - g ) // x <EOL> return f <EOL> def dup_zz_heu_gcd ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = _dup_rr_trivial_gcd ( f , g , K ) <EOL> if result is not None : <EOL> return result <EOL> df = dup_degree ( f ) <EOL> dg = dup_degree ( g ) <EOL> gcd , f , g = dup_extract ( f , g , K ) <EOL> if df == <NUM_LIT:0> or dg == <NUM_LIT:0> : <EOL> return [ gcd ] , f , g <EOL> f_norm = dup_max_norm ( f , K ) <EOL> g_norm = dup_max_norm ( g , K ) <EOL> B = K ( <NUM_LIT:2> * min ( f_norm , g_norm ) + <NUM_LIT> ) <EOL> x = max ( min ( B , <NUM_LIT> * K . sqrt ( B ) ) , <EOL> <NUM_LIT:2> * min ( f_norm // abs ( dup_LC ( f , K ) ) , <EOL> g_norm // abs ( dup_LC ( g , K ) ) ) + <NUM_LIT:2> ) <EOL> for i in range ( <NUM_LIT:0> , HEU_GCD_MAX ) : <EOL> ff = dup_eval ( f , x , K ) <EOL> gg = dup_eval ( g , x , K ) <EOL> if ff and gg : <EOL> h = K . gcd ( ff , gg ) <EOL> cff = ff // h <EOL> cfg = gg // h <EOL> h = _dup_zz_gcd_interpolate ( h , x , K ) <EOL> h = dup_primitive ( h , K ) [ <NUM_LIT:1> ] <EOL> cff_ , r = dup_div ( f , h , K ) <EOL> if not r : <EOL> cfg_ , r = dup_div ( g , h , K ) <EOL> if not r : <EOL> h = dup_mul_ground ( h , gcd , K ) <EOL> return h , cff_ , cfg_ <EOL> cff = _dup_zz_gcd_interpolate ( cff , x , K ) <EOL> h , r = dup_div ( f , cff , K ) <EOL> if not r : <EOL> cfg_ , r = dup_div ( g , h , K ) <EOL> if not r : <EOL> h = dup_mul_ground ( h , gcd , K ) <EOL> return h , cff , cfg_ <EOL> cfg = _dup_zz_gcd_interpolate ( cfg , x , K ) <EOL> h , r = dup_div ( g , cfg , K ) <EOL> if not r : <EOL> cff_ , r = dup_div ( f , h , K ) <EOL> if not r : <EOL> h = dup_mul_ground ( h , gcd , K ) <EOL> return h , cff_ , cfg <EOL> x = <NUM_LIT> * x * K . sqrt ( K . sqrt ( x ) ) // <NUM_LIT> <EOL> raise HeuristicGCDFailed ( '<STR_LIT>' ) <EOL> def _dmp_zz_gcd_interpolate ( h , x , v , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> f = [ ] <EOL> while not dmp_zero_p ( h , v ) : <EOL> g = dmp_ground_trunc ( h , x , v , K ) <EOL> f . insert ( <NUM_LIT:0> , g ) <EOL> h = dmp_sub ( h , g , v , K ) <EOL> h = dmp_quo_ground ( h , x , v , K ) <EOL> if K . is_negative ( dmp_ground_LC ( f , v + <NUM_LIT:1> , K ) ) : <EOL> return dmp_neg ( f , v + <NUM_LIT:1> , K ) <EOL> else : <EOL> return f <EOL> def dmp_zz_heu_gcd ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not u : <EOL> return dup_zz_heu_gcd ( f , g , K ) <EOL> result = _dmp_rr_trivial_gcd ( f , g , u , K ) <EOL> if result is not None : <EOL> return result <EOL> gcd , f , g = dmp_ground_extract ( f , g , u , K ) <EOL> f_norm = dmp_max_norm ( f , u , K ) <EOL> g_norm = dmp_max_norm ( g , u , K ) <EOL> B = K ( <NUM_LIT:2> * min ( f_norm , g_norm ) + <NUM_LIT> ) <EOL> x = max ( min ( B , <NUM_LIT> * K . sqrt ( B ) ) , <EOL> <NUM_LIT:2> * min ( f_norm // abs ( dmp_ground_LC ( f , u , K ) ) , <EOL> g_norm // abs ( dmp_ground_LC ( g , u , K ) ) ) + <NUM_LIT:2> ) <EOL> for i in range ( <NUM_LIT:0> , HEU_GCD_MAX ) : <EOL> ff = dmp_eval ( f , x , u , K ) <EOL> gg = dmp_eval ( g , x , u , K ) <EOL> v = u - <NUM_LIT:1> <EOL> if not ( dmp_zero_p ( ff , v ) or dmp_zero_p ( gg , v ) ) : <EOL> h , cff , cfg = dmp_zz_heu_gcd ( ff , gg , v , K ) <EOL> h = _dmp_zz_gcd_interpolate ( h , x , v , K ) <EOL> h = dmp_ground_primitive ( h , u , K ) [ <NUM_LIT:1> ] <EOL> cff_ , r = dmp_div ( f , h , u , K ) <EOL> if dmp_zero_p ( r , u ) : <EOL> cfg_ , r = dmp_div ( g , h , u , K ) <EOL> if dmp_zero_p ( r , u ) : <EOL> h = dmp_mul_ground ( h , gcd , u , K ) <EOL> return h , cff_ , cfg_ <EOL> cff = _dmp_zz_gcd_interpolate ( cff , x , v , K ) <EOL> h , r = dmp_div ( f , cff , u , K ) <EOL> if dmp_zero_p ( r , u ) : <EOL> cfg_ , r = dmp_div ( g , h , u , K ) <EOL> if dmp_zero_p ( r , u ) : <EOL> h = dmp_mul_ground ( h , gcd , u , K ) <EOL> return h , cff , cfg_ <EOL> cfg = _dmp_zz_gcd_interpolate ( cfg , x , v , K ) <EOL> h , r = dmp_div ( g , cfg , u , K ) <EOL> if dmp_zero_p ( r , u ) : <EOL> cff_ , r = dmp_div ( f , h , u , K ) <EOL> if dmp_zero_p ( r , u ) : <EOL> h = dmp_mul_ground ( h , gcd , u , K ) <EOL> return h , cff_ , cfg <EOL> x = <NUM_LIT> * x * K . sqrt ( K . sqrt ( x ) ) // <NUM_LIT> <EOL> raise HeuristicGCDFailed ( '<STR_LIT>' ) <EOL> def dup_qq_heu_gcd ( f , g , K0 ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = _dup_ff_trivial_gcd ( f , g , K0 ) <EOL> if result is not None : <EOL> return result <EOL> K1 = K0 . get_ring ( ) <EOL> cf , f = dup_clear_denoms ( f , K0 , K1 ) <EOL> cg , g = dup_clear_denoms ( g , K0 , K1 ) <EOL> f = dup_convert ( f , K0 , K1 ) <EOL> g = dup_convert ( g , K0 , K1 ) <EOL> h , cff , cfg = dup_zz_heu_gcd ( f , g , K1 ) <EOL> h = dup_convert ( h , K1 , K0 ) <EOL> c = dup_LC ( h , K0 ) <EOL> h = dup_monic ( h , K0 ) <EOL> cff = dup_convert ( cff , K1 , K0 ) <EOL> cfg = dup_convert ( cfg , K1 , K0 ) <EOL> cff = dup_mul_ground ( cff , K0 . quo ( c , cf ) , K0 ) <EOL> cfg = dup_mul_ground ( cfg , K0 . quo ( c , cg ) , K0 ) <EOL> return h , cff , cfg <EOL> def dmp_qq_heu_gcd ( f , g , u , K0 ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = _dmp_ff_trivial_gcd ( f , g , u , K0 ) <EOL> if result is not None : <EOL> return result <EOL> K1 = K0 . get_ring ( ) <EOL> cf , f = dmp_clear_denoms ( f , u , K0 , K1 ) <EOL> cg , g = dmp_clear_denoms ( g , u , K0 , K1 ) <EOL> f = dmp_convert ( f , u , K0 , K1 ) <EOL> g = dmp_convert ( g , u , K0 , K1 ) <EOL> h , cff , cfg = dmp_zz_heu_gcd ( f , g , u , K1 ) <EOL> h = dmp_convert ( h , u , K1 , K0 ) <EOL> c = dmp_ground_LC ( h , u , K0 ) <EOL> h = dmp_ground_monic ( h , u , K0 ) <EOL> cff = dmp_convert ( cff , u , K1 , K0 ) <EOL> cfg = dmp_convert ( cfg , u , K1 , K0 ) <EOL> cff = dmp_mul_ground ( cff , K0 . quo ( c , cf ) , u , K0 ) <EOL> cfg = dmp_mul_ground ( cfg , K0 . quo ( c , cg ) , u , K0 ) <EOL> return h , cff , cfg <EOL> def dup_inner_gcd ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not K . is_Exact : <EOL> try : <EOL> exact = K . get_exact ( ) <EOL> except DomainError : <EOL> return [ K . one ] , f , g <EOL> f = dup_convert ( f , K , exact ) <EOL> g = dup_convert ( g , K , exact ) <EOL> h , cff , cfg = dup_inner_gcd ( f , g , exact ) <EOL> h = dup_convert ( h , exact , K ) <EOL> cff = dup_convert ( cff , exact , K ) <EOL> cfg = dup_convert ( cfg , exact , K ) <EOL> return h , cff , cfg <EOL> elif K . has_Field : <EOL> if K . is_QQ and query ( '<STR_LIT>' ) : <EOL> try : <EOL> return dup_qq_heu_gcd ( f , g , K ) <EOL> except HeuristicGCDFailed : <EOL> pass <EOL> return dup_ff_prs_gcd ( f , g , K ) <EOL> else : <EOL> if K . is_ZZ and query ( '<STR_LIT>' ) : <EOL> try : <EOL> return dup_zz_heu_gcd ( f , g , K ) <EOL> except HeuristicGCDFailed : <EOL> pass <EOL> return dup_rr_prs_gcd ( f , g , K ) <EOL> def _dmp_inner_gcd ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not K . is_Exact : <EOL> try : <EOL> exact = K . get_exact ( ) <EOL> except DomainError : <EOL> return dmp_one ( u , K ) , f , g <EOL> f = dmp_convert ( f , u , K , exact ) <EOL> g = dmp_convert ( g , u , K , exact ) <EOL> h , cff , cfg = _dmp_inner_gcd ( f , g , u , exact ) <EOL> h = dmp_convert ( h , u , exact , K ) <EOL> cff = dmp_convert ( cff , u , exact , K ) <EOL> cfg = dmp_convert ( cfg , u , exact , K ) <EOL> return h , cff , cfg <EOL> elif K . has_Field : <EOL> if K . is_QQ and query ( '<STR_LIT>' ) : <EOL> try : <EOL> return dmp_qq_heu_gcd ( f , g , u , K ) <EOL> except HeuristicGCDFailed : <EOL> pass <EOL> return dmp_ff_prs_gcd ( f , g , u , K ) <EOL> else : <EOL> if K . is_ZZ and query ( '<STR_LIT>' ) : <EOL> try : <EOL> return dmp_zz_heu_gcd ( f , g , u , K ) <EOL> except HeuristicGCDFailed : <EOL> pass <EOL> return dmp_rr_prs_gcd ( f , g , u , K ) <EOL> def dmp_inner_gcd ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not u : <EOL> return dup_inner_gcd ( f , g , K ) <EOL> J , ( f , g ) = dmp_multi_deflate ( ( f , g ) , u , K ) <EOL> h , cff , cfg = _dmp_inner_gcd ( f , g , u , K ) <EOL> return ( dmp_inflate ( h , J , u , K ) , <EOL> dmp_inflate ( cff , J , u , K ) , <EOL> dmp_inflate ( cfg , J , u , K ) ) <EOL> def dup_gcd ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return dup_inner_gcd ( f , g , K ) [ <NUM_LIT:0> ] <EOL> def dmp_gcd ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return dmp_inner_gcd ( f , g , u , K ) [ <NUM_LIT:0> ] <EOL> def dup_rr_lcm ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fc , f = dup_primitive ( f , K ) <EOL> gc , g = dup_primitive ( g , K ) <EOL> c = K . lcm ( fc , gc ) <EOL> h = dup_quo ( dup_mul ( f , g , K ) , <EOL> dup_gcd ( f , g , K ) , K ) <EOL> return dup_mul_ground ( h , c , K ) <EOL> def dup_ff_lcm ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> h = dup_quo ( dup_mul ( f , g , K ) , <EOL> dup_gcd ( f , g , K ) , K ) <EOL> return dup_monic ( h , K ) <EOL> def dup_lcm ( f , g , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if K . has_Field : <EOL> return dup_ff_lcm ( f , g , K ) <EOL> else : <EOL> return dup_rr_lcm ( f , g , K ) <EOL> def dmp_rr_lcm ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fc , f = dmp_ground_primitive ( f , u , K ) <EOL> gc , g = dmp_ground_primitive ( g , u , K ) <EOL> c = K . lcm ( fc , gc ) <EOL> h = dmp_quo ( dmp_mul ( f , g , u , K ) , <EOL> dmp_gcd ( f , g , u , K ) , u , K ) <EOL> return dmp_mul_ground ( h , c , u , K ) <EOL> def dmp_ff_lcm ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> h = dmp_quo ( dmp_mul ( f , g , u , K ) , <EOL> dmp_gcd ( f , g , u , K ) , u , K ) <EOL> return dmp_ground_monic ( h , u , K ) <EOL> def dmp_lcm ( f , g , u , K ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "if not u :"}, {"prompt": "<s> from django . conf import settings <EOL> import column_schema <EOL> import csvdata as csv <EOL>", "answer": "import email"}, {"prompt": "<s> import datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . delete_unique ( '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> db . delete_table ( '<STR_LIT>' ) <EOL> def backwards ( self , orm ) : <EOL> db . create_table ( '<STR_LIT>' , ( <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( to = orm [ '<STR_LIT>' ] ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = datetime . datetime . now ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = datetime . datetime . now ) ) , <EOL> ( '<STR_LIT:user>' , self . gf ( '<STR_LIT>' ) ( to = orm [ '<STR_LIT>' ] ) ) , <EOL> ( '<STR_LIT:id>' , self . gf ( '<STR_LIT>' ) ( primary_key = True ) ) , <EOL> ) ) <EOL> db . send_create_signal ( '<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> db . create_unique ( '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> models = { <EOL> } <EOL>", "answer": "complete_apps = [ '<STR_LIT>' ] "}, {"prompt": "<s> import bayeslite <EOL> import bayeslite . geweke_testing as geweke <EOL> import bayeslite . metamodels . troll_rng as troll <EOL> import bayeslite . metamodels . iid_gaussian as gauss <EOL> import bayeslite . metamodels . nig_normal as normal <EOL> def test_geweke_troll ( ) : <EOL> with bayeslite . bayesdb_open ( builtin_metamodels = False ) as bdb : <EOL> bayeslite . bayesdb_register_metamodel ( bdb , troll . TrollMetamodel ( ) ) <EOL> kl_est = geweke . geweke_kl ( bdb , \"<STR_LIT>\" , [ [ '<STR_LIT>' , '<STR_LIT>' ] ] , <EOL> [ '<STR_LIT>' ] , [ ( <NUM_LIT:1> , <NUM_LIT:0> ) ] , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> ) <EOL> assert kl_est == ( <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> def test_geweke_iid_gaussian ( ) : <EOL> with bayeslite . bayesdb_open ( builtin_metamodels = False ) as bdb : <EOL> bayeslite . bayesdb_register_metamodel ( bdb , gauss . StdNormalMetamodel ( ) ) <EOL> kl_est = geweke . geweke_kl ( bdb , \"<STR_LIT>\" , <EOL> [ [ '<STR_LIT>' , '<STR_LIT>' ] ] , [ '<STR_LIT>' ] , <EOL> [ ( <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:2> , <NUM_LIT:0> ) ] , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> ) <EOL> assert kl_est == ( <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> def test_geweke_nig_normal ( ) : <EOL> with bayeslite . bayesdb_open ( builtin_metamodels = False ) as bdb : <EOL> nig = normal . NIGNormalMetamodel ( seed = <NUM_LIT:1> ) <EOL> bayeslite . bayesdb_register_metamodel ( bdb , nig ) <EOL> ( ct , kl , error ) = geweke . geweke_kl ( bdb , \"<STR_LIT>\" , <EOL> [ [ '<STR_LIT>' , '<STR_LIT>' ] ] , [ '<STR_LIT>' ] , <EOL> [ ( <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:2> , <NUM_LIT:0> ) ] , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> ) <EOL> assert ct == <NUM_LIT:2> <EOL> assert <NUM_LIT:0> < kl and kl < <NUM_LIT:10> <EOL> assert <NUM_LIT:0> < error and error < <NUM_LIT:10> <EOL> def test_geweke_nig_normal_seriously__ci_slow ( ) : <EOL> with bayeslite . bayesdb_open ( builtin_metamodels = False ) as bdb : <EOL> nig = normal . NIGNormalMetamodel ( seed = <NUM_LIT:1> ) <EOL> bayeslite . bayesdb_register_metamodel ( bdb , nig ) <EOL> cells = [ ( i , <NUM_LIT:0> ) for i in range ( <NUM_LIT:4> ) ] <EOL> for chain_ct in ( <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:5> ) : <EOL> ( ct , kl , error ) = geweke . geweke_kl ( bdb , \"<STR_LIT>\" , <EOL> [ [ '<STR_LIT>' , '<STR_LIT>' ] ] , [ '<STR_LIT>' ] , cells , <EOL> <NUM_LIT:200> , <NUM_LIT:200> , chain_ct , <NUM_LIT> ) <EOL> assert ct == <NUM_LIT> <EOL> assert <NUM_LIT:0> < kl and kl < <NUM_LIT:0.1> <EOL> assert <NUM_LIT:0> < error and error < <NUM_LIT> <EOL> class DoctoredNIGNormal ( normal . NIGNormalMetamodel ) : <EOL> def _inv_gamma ( self , shape , scale ) : <EOL> return float ( <NUM_LIT:1.0> / scale ) / self . prng . gammavariate ( shape , <NUM_LIT:1.0> ) <EOL> def test_geweke_catches_nig_normal_bug__ci_slow ( ) : <EOL> with bayeslite . bayesdb_open ( builtin_metamodels = False ) as bdb : <EOL>", "answer": "bayeslite . bayesdb_register_metamodel ( bdb , DoctoredNIGNormal ( seed = <NUM_LIT:1> ) )"}, {"prompt": "<s> import nose <EOL> import dpath . util <EOL> from nose . tools import assert_raises <EOL> from collections import MutableMapping , MutableSequence <EOL> class TestMapping ( MutableMapping ) : <EOL> def __init__ ( self , data = { } ) : <EOL> self . _mapping = { } <EOL> self . _mapping . update ( data ) <EOL> def __len__ ( self ) : <EOL>", "answer": "return len ( self . _mapping )"}, {"prompt": "<s> import errno <EOL> import termios <EOL> import struct <EOL>", "answer": "import fcntl"}, {"prompt": "<s> from sublime import Region , Settings , load_settings <EOL> import sublime_plugin <EOL> from itertools import tee , chain <EOL> try : <EOL> from itertools import izip as zip <EOL> except ImportError : <EOL> pass <EOL> def previous_and_current ( iterable , * iterables ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> prevs , items = tee ( iterable , <NUM_LIT:2> ) <EOL> prevs = chain ( [ None ] , prevs ) <EOL> return zip ( prevs , items , * iterables ) <EOL> def is_comment_multi_line ( view , region ) : <EOL> return len ( view . lines ( region ) ) > <NUM_LIT:1> <EOL> def normalize_comment ( view , region ) : <EOL> if is_comment_multi_line ( view , region ) : <EOL> return normalize_multiline_comment ( view , region ) <EOL> else : <EOL> return normalize_singleline_comment ( view , region ) <EOL> def normalize_singleline_comment ( view , region ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> region_str = view . substr ( region ) <EOL> last_newline = region_str . rfind ( '<STR_LIT:\\n>' ) <EOL> if ( last_newline == - <NUM_LIT:1> ) : <EOL> return region <EOL> else : <EOL> return Region ( region . begin ( ) , region . begin ( ) + last_newline ) <EOL> def normalize_multiline_comment ( view , region ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> lines = view . lines ( region ) <EOL> last_line = lines [ - <NUM_LIT:1> ] <EOL> last_point = last_line . b <EOL> return Region ( region . a , last_point ) <EOL> class CommentNodes : <EOL> def __init__ ( self , view ) : <EOL> self . comments = None <EOL> self . settings = load_settings ( \"<STR_LIT>\" ) <EOL> self . view = view <EOL> self . find_comments ( ) <EOL> self . apply_settings ( ) <EOL> def find_comments ( self ) : <EOL> self . comments = [ <EOL> normalize_comment ( self . view , c ) for c in self . view . find_by_selector ( '<STR_LIT>' ) <EOL> ] <EOL> def apply_settings ( self ) : <EOL> if not self . settings . get ( '<STR_LIT>' ) : <EOL> self . remove_single_line_comments ( ) <EOL> if self . settings . get ( '<STR_LIT>' ) : <EOL> self . concatenate_adjacent_comments ( ) <EOL> def remove_single_line_comments ( self ) : <EOL> self . comments = [ c for c in self . comments if is_comment_multi_line ( self . view , c ) ] <EOL> def concatenate_adjacent_comments ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def concatenate ( region1 , region2 ) : <EOL> return region1 . cover ( region2 ) <EOL> def is_adjacent ( region1 , region2 ) : <EOL> region_inbetween = Region ( region1 . end ( ) , region2 . begin ( ) ) <EOL>", "answer": "return len ( self . view . substr ( region_inbetween ) . strip ( ) ) == <NUM_LIT:0>"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> from datetime import timedelta <EOL> from uuid import UUID , uuid4 <EOL> from unittest import SkipTest , skipIf <EOL> from testtools import run_test_with <EOL> from testtools . matchers import MatchesListwise , AfterPreprocessing , Equals <EOL> from twisted . internet import reactor <EOL> from flocker import __version__ as HEAD_FLOCKER_VERSION <EOL> from flocker . common . version import get_installable_version <EOL> from ... common import loop_until <EOL> from ... testtools import AsyncTestCase , flaky , async_runner <EOL> from ... node . agents . blockdevice import ICloudAPI <EOL> from ... provision import PackageSource <EOL> from ... node import backends <EOL> from . . testtools import ( <EOL> require_cluster , require_moving_backend , create_dataset , <EOL> skip_backend , get_backend_api , verify_socket , <EOL> get_default_volume_size , ACCEPTANCE_TEST_TIMEOUT <EOL> ) <EOL> class DatasetAPITests ( AsyncTestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> run_tests_with = async_runner ( timeout = ACCEPTANCE_TEST_TIMEOUT ) <EOL> @ flaky ( u'<STR_LIT>' ) <EOL> @ require_cluster ( <NUM_LIT:1> ) <EOL> def test_dataset_creation ( self , cluster ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return create_dataset ( self , cluster ) <EOL> def _get_package_source ( self , default_version = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> env_vars = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> defaultable = frozenset ( [ '<STR_LIT>' , <EOL> '<STR_LIT>' ] ) <EOL> missing_vars = list ( var for var in env_vars if var not in os . environ ) <EOL> if missing_vars : <EOL> message = ( '<STR_LIT>' % <EOL> '<STR_LIT:U+002CU+0020>' . join ( missing_vars ) ) <EOL> missing_defaultable = list ( var for var in missing_vars <EOL> if var in defaultable ) <EOL> if missing_defaultable : <EOL> message += ( '<STR_LIT>' <EOL> '<STR_LIT>' % <EOL> '<STR_LIT:U+002CU+0020>' . join ( missing_defaultable ) ) <EOL> raise SkipTest ( message ) <EOL> version = ( os . environ [ '<STR_LIT>' ] or <EOL> default_version ) <EOL> return PackageSource ( <EOL> version = version , <EOL> branch = os . environ [ '<STR_LIT>' ] , <EOL> build_server = os . environ [ '<STR_LIT>' ] ) <EOL> @ skip_backend ( <EOL> unsupported = { backends . LOOPBACK } , <EOL> reason = \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> @ skip_backend ( <EOL> unsupported = { backends . GCE } , <EOL> reason = \"<STR_LIT>\" ) <EOL> @ run_test_with ( async_runner ( timeout = timedelta ( minutes = <NUM_LIT:6> ) ) ) <EOL> @ require_cluster ( <NUM_LIT:1> ) <EOL> def test_upgrade ( self , cluster ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> node = cluster . nodes [ <NUM_LIT:0> ] <EOL> SAMPLE_STR = '<STR_LIT>' * <NUM_LIT:100> <EOL> upgrade_from_version = get_installable_version ( HEAD_FLOCKER_VERSION ) <EOL> d = cluster . client . version ( ) <EOL> original_package_source = [ None ] <EOL> def setup_restore_original_flocker ( version ) : <EOL> version_bytes = version . get ( '<STR_LIT>' , u'<STR_LIT>' ) . encode ( '<STR_LIT:ascii>' ) <EOL> original_package_source [ <NUM_LIT:0> ] = ( <EOL> self . _get_package_source ( <EOL> default_version = version_bytes or None ) <EOL> ) <EOL> self . addCleanup ( <EOL> lambda : cluster . install_flocker_version ( <EOL> original_package_source [ <NUM_LIT:0> ] ) ) <EOL> return version <EOL> d . addCallback ( setup_restore_original_flocker ) <EOL> d . addCallback ( lambda _ : cluster . clean_nodes ( ) ) <EOL> d . addCallback ( <EOL>", "answer": "lambda _ : cluster . install_flocker_version ("}, {"prompt": "<s> import braintree <EOL> from braintree . resource import Resource <EOL> class VenmoAccount ( Resource ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , gateway , attributes ) : <EOL> Resource . __init__ ( self , gateway , attributes ) <EOL>", "answer": "if \"<STR_LIT>\" in attributes :"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> def read4 ( buf ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return <NUM_LIT:0> <EOL>", "answer": "class Solution ( object ) :"}, {"prompt": "<s> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> import unittest <EOL> from pycopia . doc import apigen <EOL> class DocTest ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> pass <EOL> def test_apigen ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . assertTrue ( hasattr ( apigen , \"<STR_LIT>\" ) ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL>", "answer": "unittest . main ( ) "}, {"prompt": "<s> from __future__ import unicode_literals , absolute_import , division <EOL> from flask . ext . script import Command , Option <EOL> from alchemist import db <EOL> common_options = [ <EOL> Option ( dest = '<STR_LIT>' , nargs = '<STR_LIT:*>' , <EOL> help = '<STR_LIT>' ) , <EOL> Option ( '<STR_LIT>' , action = '<STR_LIT:store_true>' , required = False , default = False , <EOL> help = '<STR_LIT>' ) , <EOL> Option ( '<STR_LIT>' , action = '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , default = True , <EOL> help = '<STR_LIT>' ) , <EOL> Option ( '<STR_LIT>' , action = '<STR_LIT:store_true>' , required = False , default = False , <EOL> help = '<STR_LIT>' ) , <EOL> Option ( '<STR_LIT>' , '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> action = '<STR_LIT>' , required = False , default = True ) , <EOL> ] <EOL> class Initialize ( Command ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = '<STR_LIT>' <EOL> namespace = '<STR_LIT>' <EOL> option_list = common_options + [ <EOL> Option ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , required = False , default = False , <EOL> help = '<STR_LIT>' ) , <EOL> ] <EOL> def run ( self , * args , ** kwargs ) : <EOL> db . init ( * args , ** kwargs ) <EOL> class Clear ( Command ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = '<STR_LIT>' <EOL> namespace = '<STR_LIT>' <EOL> option_list = common_options + [ <EOL> Option ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , required = False , default = False , <EOL> help = '<STR_LIT>' ) , <EOL> ] <EOL> def run ( self , * args , ** kwargs ) : <EOL> db . clear ( * args , ** kwargs ) <EOL> class Flush ( Command ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = '<STR_LIT>' <EOL> namespace = '<STR_LIT>' <EOL>", "answer": "option_list = common_options"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> import copy <EOL> from copy import deepcopy <EOL> from time import time <EOL> from django . conf import settings <EOL> from django . db . models import Q <EOL> from django . db . models . base import ModelBase <EOL> from django . utils import six <EOL> from django . utils import tree <EOL> from django . utils . encoding import force_text <EOL> from haystack . constants import VALID_FILTERS , FILTER_SEPARATOR , DEFAULT_ALIAS <EOL> from haystack . exceptions import MoreLikeThisError , FacetingError <EOL> from haystack . models import SearchResult <EOL> from haystack . utils . loading import UnifiedIndex <EOL> from haystack . utils import get_model_ct <EOL> VALID_GAPS = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def log_query ( func ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def wrapper ( obj , query_string , * args , ** kwargs ) : <EOL> start = time ( ) <EOL> try : <EOL> return func ( obj , query_string , * args , ** kwargs ) <EOL> finally : <EOL> stop = time ( ) <EOL> if settings . DEBUG : <EOL> from haystack import connections <EOL> connections [ obj . connection_alias ] . queries . append ( { <EOL> '<STR_LIT>' : query_string , <EOL> '<STR_LIT>' : args , <EOL> '<STR_LIT>' : kwargs , <EOL> '<STR_LIT:time>' : \"<STR_LIT>\" % ( stop - start ) , <EOL> '<STR_LIT:start>' : start , <EOL> '<STR_LIT>' : stop , <EOL> } ) <EOL> return wrapper <EOL> class EmptyResults ( object ) : <EOL> hits = <NUM_LIT:0> <EOL> docs = [ ] <EOL> def __len__ ( self ) : <EOL> return <NUM_LIT:0> <EOL> def __getitem__ ( self , k ) : <EOL> if isinstance ( k , slice ) : <EOL> return [ ] <EOL> else : <EOL> raise IndexError ( \"<STR_LIT>\" ) <EOL> class BaseSearchBackend ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> RESERVED_WORDS = [ ] <EOL> RESERVED_CHARACTERS = [ ] <EOL> def __init__ ( self , connection_alias , ** connection_options ) : <EOL> self . connection_alias = connection_alias <EOL> self . timeout = connection_options . get ( '<STR_LIT>' , <NUM_LIT:10> ) <EOL> self . include_spelling = connection_options . get ( '<STR_LIT>' , False ) <EOL> self . batch_size = connection_options . get ( '<STR_LIT>' , <NUM_LIT:1000> ) <EOL> self . silently_fail = connection_options . get ( '<STR_LIT>' , True ) <EOL> self . distance_available = connection_options . get ( '<STR_LIT>' , False ) <EOL> def update ( self , index , iterable ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> def remove ( self , obj_or_string ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> def clear ( self , models = None , commit = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> @ log_query <EOL> def search ( self , query_string , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> def build_search_kwargs ( self , query_string , sort_by = None , start_offset = <NUM_LIT:0> , end_offset = None , <EOL> fields = '<STR_LIT>' , highlight = False , facets = None , <EOL> date_facets = None , query_facets = None , <EOL> narrow_queries = None , spelling_query = None , <EOL> within = None , dwithin = None , distance_point = None , <EOL> models = None , limit_to_registered_models = None , <EOL> result_class = None ) : <EOL> raise NotImplementedError <EOL> def prep_value ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return force_text ( value ) <EOL> def more_like_this ( self , model_instance , additional_query_string = None , result_class = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "raise NotImplementedError ( \"<STR_LIT>\" )"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Static ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "<s> import sys <EOL> import os <EOL> extensions = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> templates_path = [ '<STR_LIT>' ] <EOL> source_suffix = '<STR_LIT>' <EOL> master_doc = '<STR_LIT:index>' <EOL> project = u'<STR_LIT>' <EOL> copyright = u'<STR_LIT>' <EOL> version = '<STR_LIT>' <EOL> release = '<STR_LIT>' <EOL> exclude_patterns = [ '<STR_LIT>' ] <EOL> pygments_style = '<STR_LIT>' <EOL> html_theme = '<STR_LIT:default>' <EOL> html_static_path = [ '<STR_LIT>' ] <EOL> htmlhelp_basename = '<STR_LIT>' <EOL> latex_elements = { <EOL> } <EOL> latex_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> man_pages = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> [ u'<STR_LIT>' ] , <NUM_LIT:1> ) <EOL> ] <EOL> texinfo_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) , <EOL>", "answer": "] "}, {"prompt": "<s> from magnumclient . common import base <EOL> from magnumclient . common import utils <EOL> from magnumclient import exceptions <EOL> CREATION_ATTRIBUTES = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class Service ( base . Resource ) : <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % self . _info <EOL> class ServiceManager ( base . Manager ) : <EOL> resource_class = Service <EOL> @ staticmethod <EOL> def _path ( id = None , bay_ident = None ) : <EOL> if id and bay_ident : <EOL> return '<STR_LIT>' % ( id , bay_ident ) <EOL> elif bay_ident : <EOL> return '<STR_LIT>' % ( bay_ident ) <EOL> else : <EOL> return '<STR_LIT>' <EOL>", "answer": "def list ( self , bay_ident , marker = None , limit = None , sort_key = None ,"}, {"prompt": "<s> from django . contrib import admin <EOL> from django . core . urlresolvers import reverse , NoReverseMatch <EOL> from positions import settings <EOL> from positions . models import Position , PositionContent <EOL> class PositionContentInline ( admin . TabularInline ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> model = PositionContent <EOL> extra = <NUM_LIT:0> <EOL> max_num = <NUM_LIT:0> <EOL> readonly_fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) <EOL> fields = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) <EOL> ordering = ( '<STR_LIT>' , ) <EOL> class PositionAdmin ( admin . ModelAdmin ) : <EOL> list_display = ( '<STR_LIT:name>' , '<STR_LIT:description>' , '<STR_LIT:count>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , ) <EOL>", "answer": "search_fields = ( '<STR_LIT:name>' , '<STR_LIT:description>' )"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from rest_framework . response import Response <EOL> from sentry . api import client <EOL> from sentry . api . base import DocSection <EOL> from sentry . api . bases . group import GroupEndpoint <EOL>", "answer": "from sentry . models import Group"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import os <EOL> import sys <EOL> import json <EOL> from . docs_utils import * <EOL> class ReachFrequencyPredictionDocsTestCase ( DocsTestCase ) : <EOL> def setUp ( self ) : <EOL> rfp = self . create_reach_frequency_prediction ( ) <EOL>", "answer": "DocsDataStore . set ( '<STR_LIT>' , rfp . get_id ( ) )"}, {"prompt": "<s> import csv <EOL> import socket <EOL> from util . scandata import ScanData <EOL> __author__ = \"<STR_LIT>\" <EOL> def read ( filename ) : <EOL> PID = <NUM_LIT:0> <EOL> CVE = <NUM_LIT:1> <EOL> CVSS = <NUM_LIT:2> <EOL> RISK = <NUM_LIT:3> <EOL> HOST = <NUM_LIT:4> <EOL> PROTOCOL = <NUM_LIT:5> <EOL> PORT = <NUM_LIT:6> <EOL> NAME = <NUM_LIT:7> <EOL> SYNOPSIS = <NUM_LIT:8> <EOL> DESCRIPTION = <NUM_LIT:9> <EOL> SOLUTION = <NUM_LIT:10> <EOL> OUTPUT = <NUM_LIT:11> <EOL> host_to_vulns = { } <EOL> vuln_to_hosts = { } <EOL> id_to_name = { } <EOL> host_to_ip = { } <EOL> id_to_severity = { } <EOL> try : <EOL> with open ( filename , '<STR_LIT:rb>' ) as csvfile : <EOL> scanreader = csv . reader ( csvfile , delimiter = \"<STR_LIT:U+002C>\" , quotechar = \"<STR_LIT>\" ) <EOL> for row in scanreader : <EOL> if row [ HOST ] not in host_to_ip : <EOL> try : <EOL> host_to_ip [ row [ HOST ] ] = socket . getaddrinfo ( row [ HOST ] , <NUM_LIT> ) [ <NUM_LIT:0> ] [ <NUM_LIT:4> ] [ <NUM_LIT:0> ] <EOL> except : <EOL> host_to_ip [ row [ HOST ] ] = \"<STR_LIT>\" <EOL> if row [ PID ] not in id_to_name : <EOL> id_to_name [ row [ PID ] ] = row [ NAME ] <EOL> if row [ PID ] not in id_to_severity : <EOL>", "answer": "id_to_severity [ row [ PID ] ] = row [ RISK ]"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __init__ import Mongrel2JSONRPCService , jsonremote <EOL> from mongrel2 import handler <EOL> sender_id = \"<STR_LIT>\" <EOL> conn = handler . Connection ( sender_id , \"<STR_LIT>\" , <EOL>", "answer": "\"<STR_LIT>\" )"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = <NUM_LIT:1>"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Creature ( )"}, {"prompt": "<s> import os <EOL> import sys <EOL> from unittest import TestCase <EOL> from openelex . config import Settings <EOL> TEST_SETTING_1 = \"<STR_LIT:foo>\" <EOL> TEST_SETTING_2 = \"<STR_LIT:bar>\" <EOL> class TestSettings ( TestCase ) : <EOL> def tearDown ( self ) : <EOL> try : <EOL> os . environ = self . env <EOL> except AttributeError : <EOL> pass <EOL> def _test_object_keys ( self , settings_obj ) : <EOL> self . assertEqual ( settings_obj . TEST_SETTING_1 , \"<STR_LIT:foo>\" ) <EOL> self . assertEqual ( settings_obj . TEST_SETTING_2 , \"<STR_LIT:bar>\" ) <EOL> def _fix_filename ( self , filename ) : <EOL> return filename . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def test_from_object ( self ) : <EOL>", "answer": "settings = Settings ( )"}, {"prompt": "<s> from django . dispatch import Signal <EOL> structure_role_granted = Signal ( providing_args = [ '<STR_LIT>' , '<STR_LIT:user>' , '<STR_LIT>' ] ) <EOL> structure_role_revoked = Signal ( providing_args = [ '<STR_LIT>' , '<STR_LIT:user>' , '<STR_LIT>' ] ) <EOL> project_resource_added = Signal ( providing_args = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> project_resource_removed = Signal ( providing_args = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> customer_account_credited = Signal ( providing_args = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL>", "answer": "customer_account_debited = Signal ( providing_args = [ '<STR_LIT>' , '<STR_LIT>' ] )"}, {"prompt": "<s> import os <EOL> import shutil <EOL>", "answer": "from . . import ( error , locations )"}, {"prompt": "<s> from sahara import exceptions as exc <EOL> from sahara . i18n import _ <EOL> from sahara . plugins . ambari import common as p_common <EOL> from sahara . plugins import exceptions as pex <EOL> from sahara . plugins import utils as plugin_utils <EOL> from sahara . service . edp import hdfs_helper <EOL> from sahara . service . edp . oozie import engine as oozie_engine <EOL> from sahara . service . edp . spark import engine as spark_engine <EOL> def _get_lib_location ( instance , lib_name ) : <EOL> with instance . remote ( ) as r : <EOL> code , jar_path = r . execute_command ( <EOL> ( '<STR_LIT>' <EOL> '<STR_LIT>' . format ( lib_name = lib_name ) ) , <EOL> run_as_root = True ) <EOL> return jar_path . rstrip ( ) <EOL> def _get_hadoop_openstack_jar_location ( instance ) : <EOL> return _get_lib_location ( instance , \"<STR_LIT>\" ) <EOL> def _get_jackson_core ( instance ) : <EOL> return _get_lib_location ( instance , \"<STR_LIT>\" ) <EOL> class EDPOozieEngine ( oozie_engine . OozieJobEngine ) : <EOL> def get_hdfs_user ( self ) : <EOL> return \"<STR_LIT>\" <EOL> def create_hdfs_dir ( self , remote , dir_name ) : <EOL> hdfs_helper . create_dir_hadoop2 ( remote , dir_name , self . get_hdfs_user ( ) ) <EOL> def get_oozie_server_uri ( self , cluster ) : <EOL> oozie = plugin_utils . get_instance ( cluster , p_common . OOZIE_SERVER ) <EOL> return \"<STR_LIT>\" % oozie . management_ip <EOL> def get_name_node_uri ( self , cluster ) : <EOL> namenodes = plugin_utils . get_instances ( cluster , p_common . NAMENODE ) <EOL> if len ( namenodes ) == <NUM_LIT:1> : <EOL> return \"<STR_LIT>\" % namenodes [ <NUM_LIT:0> ] . fqdn ( ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> def get_resource_manager_uri ( self , cluster ) : <EOL> resourcemanagers = plugin_utils . get_instances ( cluster , <EOL> p_common . RESOURCEMANAGER ) <EOL> return \"<STR_LIT>\" % resourcemanagers [ <NUM_LIT:0> ] . fqdn ( ) <EOL> def get_oozie_server ( self , cluster ) : <EOL> return plugin_utils . get_instance ( cluster , p_common . OOZIE_SERVER ) <EOL> def validate_job_execution ( self , cluster , job , data ) : <EOL> oozie_count = plugin_utils . get_instances_count ( cluster , <EOL> p_common . OOZIE_SERVER ) <EOL> if oozie_count != <NUM_LIT:1> : <EOL> raise pex . InvalidComponentCountException ( <EOL> p_common . OOZIE_SERVER , \"<STR_LIT:1>\" , oozie_count ) <EOL> super ( EDPOozieEngine , self ) . validate_job_execution ( cluster , job , data ) <EOL> @ staticmethod <EOL> def get_possible_job_config ( job_type ) : <EOL> return { \"<STR_LIT>\" : [ ] } <EOL> class EDPSparkEngine ( spark_engine . SparkJobEngine ) : <EOL> edp_base_version = \"<STR_LIT>\" <EOL> def __init__ ( self , cluster ) : <EOL> super ( EDPSparkEngine , self ) . __init__ ( cluster ) <EOL> self . master = plugin_utils . get_instance ( <EOL> cluster , p_common . SPARK_JOBHISTORYSERVER ) <EOL> self . plugin_params [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> self . plugin_params [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> self . plugin_params [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> self . plugin_params [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def edp_supported ( version ) : <EOL> return version >= EDPSparkEngine . edp_base_version <EOL> def run_job ( self , job_execution ) : <EOL> driver_classpath = [ <EOL> _get_hadoop_openstack_jar_location ( self . master ) , <EOL> _get_jackson_core ( self . master ) ] <EOL> self . plugin_params [ '<STR_LIT>' ] = \"<STR_LIT::>\" . join ( driver_classpath ) <EOL> self . plugin_params [ '<STR_LIT>' ] = driver_classpath <EOL> return super ( EDPSparkEngine , self ) . run_job ( job_execution ) <EOL> def validate_job_execution ( self , cluster , job , data ) : <EOL> if not self . edp_supported ( cluster . hadoop_version ) : <EOL> raise exc . InvalidDataException ( <EOL> _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) . format ( <EOL> base = EDPSparkEngine . edp_base_version , type = job . type ) ) <EOL> spark_nodes_count = plugin_utils . get_instances_count ( <EOL> cluster , p_common . SPARK_JOBHISTORYSERVER ) <EOL> if spark_nodes_count != <NUM_LIT:1> : <EOL> raise pex . InvalidComponentCountException ( <EOL> p_common . SPARK_JOBHISTORYSERVER , '<STR_LIT:1>' , spark_nodes_count ) <EOL>", "answer": "super ( EDPSparkEngine , self ) . validate_job_execution ("}, {"prompt": "<s> from django . core . management . commands import test <EOL> from south . management . commands import patch_for_test_db_setup <EOL> class Command ( test . Command ) : <EOL>", "answer": "def handle ( self , * args , ** kwargs ) :"}, {"prompt": "<s> from django . contrib import admin <EOL> from timepiece . entries . models import ( <EOL> Activity , ActivityGroup , Entry , Location , ProjectHours ) <EOL> class ActivityAdmin ( admin . ModelAdmin ) : <EOL> model = Activity <EOL> list_display = ( '<STR_LIT:code>' , '<STR_LIT:name>' , '<STR_LIT>' ) <EOL> list_filter = ( '<STR_LIT>' , ) <EOL> class ActivityGroupAdmin ( admin . ModelAdmin ) : <EOL> model = ActivityGroup <EOL> list_display = ( '<STR_LIT:name>' , ) <EOL> list_filter = ( '<STR_LIT>' , ) <EOL> filter_horizontal = ( '<STR_LIT>' , ) <EOL> class EntryAdmin ( admin . ModelAdmin ) : <EOL> model = Entry <EOL> list_display = ( '<STR_LIT:user>' , '<STR_LIT>' , '<STR_LIT:location>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> list_filter = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:user>' , '<STR_LIT>' ] <EOL> search_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] <EOL> date_hierarchy = '<STR_LIT>' <EOL> ordering = ( '<STR_LIT>' , ) <EOL> def project_type ( self , entry ) : <EOL> return entry . project . type <EOL> def _project ( self , obj ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return obj . __str__ ( ) <EOL> _project . admin_order_field = '<STR_LIT>' <EOL>", "answer": "_project . short_description = '<STR_LIT>'"}, {"prompt": "<s> def print_help ( ) : <EOL> print '<STR_LIT>' <EOL> print <EOL> print '<STR_LIT>' <EOL> print <EOL> print '<STR_LIT>' <EOL> print <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL> print <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' <EOL>", "answer": "print '<STR_LIT>'"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL> from django . conf import settings <EOL> import django . db . models . deletion <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AlterField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field = models . ForeignKey ( to = settings . AUTH_USER_MODEL , editable = False , verbose_name = '<STR_LIT>' , null = True , on_delete = django . db . models . deletion . SET_NULL , blank = True , related_name = '<STR_LIT:+>' ) , <EOL> preserve_default = True , <EOL>", "answer": ") ,"}, {"prompt": "<s> from django . http import HttpResponse <EOL> from django . middleware . doc import XViewMiddleware <EOL> from django . template import Template , Context <EOL> from django . template . response import TemplateResponse <EOL> from django . test import TestCase , RequestFactory <EOL> from django . utils . decorators import decorator_from_middleware <EOL> xview_dec = decorator_from_middleware ( XViewMiddleware ) <EOL> @ xview_dec <EOL> def xview ( request ) : <EOL> return HttpResponse ( ) <EOL> class ClassXView ( object ) : <EOL> def __call__ ( self , request ) : <EOL> return HttpResponse ( ) <EOL> class_xview = xview_dec ( ClassXView ( ) ) <EOL> class FullMiddleware ( object ) : <EOL> def process_request ( self , request ) : <EOL> request . process_request_reached = True <EOL> def process_view ( sef , request , view_func , view_args , view_kwargs ) : <EOL> request . process_view_reached = True <EOL> def process_template_response ( self , request , response ) : <EOL>", "answer": "request . process_template_response_reached = True"}, {"prompt": "<s> from . . excel_comparsion_test import ExcelComparisonTest <EOL> from ... workbook import Workbook <EOL> class TestCompareXLSXFiles ( ExcelComparisonTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . maxDiff = None <EOL> filename = '<STR_LIT>' <EOL> test_dir = '<STR_LIT>' <EOL> self . got_filename = test_dir + '<STR_LIT>' + filename <EOL> self . exp_filename = test_dir + '<STR_LIT>' + filename <EOL> self . ignore_files = [ ] <EOL> self . ignore_elements = { } <EOL> def test_create_file ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> workbook = Workbook ( self . got_filename ) <EOL> worksheet = workbook . add_worksheet ( ) <EOL> chart = workbook . add_chart ( { '<STR_LIT:type>' : '<STR_LIT>' } ) <EOL> chart . axis_ids = [ <NUM_LIT> , <NUM_LIT> ] <EOL> data = [ <EOL> [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> ] , <EOL> [ <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:6> , <NUM_LIT:8> , <NUM_LIT:10> ] , <EOL>", "answer": "[ <NUM_LIT:3> , <NUM_LIT:6> , <NUM_LIT:9> , <NUM_LIT:12> , <NUM_LIT:15> ] ,"}, {"prompt": "<s> import re <EOL> from . aligners import FirstColumnAligner , ColumnAligner , NullAligner <EOL> from . dataextractor import DataExtractor <EOL> from . rowsplitter import RowSplitter <EOL> class _DataFileFormatter ( object ) : <EOL> _whitespace = re . compile ( '<STR_LIT>' ) <EOL> def __init__ ( self , column_count ) : <EOL> self . _splitter = RowSplitter ( column_count ) <EOL> self . _column_count = column_count <EOL> self . _extractor = DataExtractor ( self . _want_names_on_first_content_row ) <EOL> def _want_names_on_first_content_row ( self , table , name ) : <EOL> return True <EOL> def empty_row_after ( self , table ) : <EOL> return self . _format_row ( [ ] , table ) <EOL> def format_header ( self , table ) : <EOL> header = self . _format_row ( table . header ) <EOL> return self . _format_header ( header , table ) <EOL> def format_table ( self , table ) : <EOL> rows = self . _extractor . rows_from_table ( table ) <EOL> if self . _should_split_rows ( table ) : <EOL> return self . _split_rows ( rows , table ) <EOL> return ( self . _format_row ( r , table ) for r in rows ) <EOL> def _should_split_rows ( self , table ) : <EOL> return not self . _should_align_columns ( table ) <EOL> def _split_rows ( self , rows , table ) : <EOL> indented = self . _is_indented_table ( table ) <EOL> for row in rows : <EOL> for r in self . _splitter . split ( row , indented ) : <EOL> yield self . _format_row ( r , table ) <EOL> def _should_align_columns ( self , table ) : <EOL> return self . _is_indented_table ( table ) and bool ( table . header [ <NUM_LIT:1> : ] ) <EOL> def _is_indented_table ( self , table ) : <EOL> return table is not None and table . type in [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def _escape_consecutive_whitespace ( self , row ) : <EOL> return [ self . _whitespace . sub ( self . _whitespace_escaper , <EOL> cell . replace ( '<STR_LIT:\\n>' , '<STR_LIT:U+0020>' ) ) for cell in row ] <EOL> def _whitespace_escaper ( self , match ) : <EOL> return '<STR_LIT:\\\\>' . join ( match . group ( <NUM_LIT:0> ) ) <EOL> def _format_row ( self , row , table = None ) : <EOL> raise NotImplementedError <EOL> def _format_header ( self , header , table ) : <EOL> raise NotImplementedError <EOL> class TsvFormatter ( _DataFileFormatter ) : <EOL> def _format_header ( self , header , table ) : <EOL> return [ self . _format_header_cell ( cell ) for cell in header ] <EOL> def _format_header_cell ( self , cell ) : <EOL> return '<STR_LIT>' % cell if cell else '<STR_LIT>' <EOL> def _format_row ( self , row , table = None ) : <EOL> return self . _pad ( self . _escape ( row ) ) <EOL> def _escape ( self , row ) : <EOL> return self . _escape_consecutive_whitespace ( self . _escape_tabs ( row ) ) <EOL> def _escape_tabs ( self , row ) : <EOL> return [ c . replace ( '<STR_LIT:\\t>' , '<STR_LIT>' ) for c in row ] <EOL> def _pad ( self , row ) : <EOL> row = [ cell . replace ( '<STR_LIT:\\n>' , '<STR_LIT:U+0020>' ) for cell in row ] <EOL> return row + [ '<STR_LIT>' ] * ( self . _column_count - len ( row ) ) <EOL> class TxtFormatter ( _DataFileFormatter ) : <EOL> _test_or_keyword_name_width = <NUM_LIT> <EOL> _setting_and_variable_name_width = <NUM_LIT> <EOL> def _format_row ( self , row , table = None ) : <EOL> row = self . _escape ( row ) <EOL> aligner = self . _aligner_for ( table ) <EOL> return aligner . align_row ( row ) <EOL> def _aligner_for ( self , table ) : <EOL> if table and table . type in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return FirstColumnAligner ( self . _setting_and_variable_name_width ) <EOL> if self . _should_align_columns ( table ) : <EOL> return ColumnAligner ( self . _test_or_keyword_name_width , table ) <EOL> return NullAligner ( ) <EOL> def _format_header ( self , header , table ) : <EOL> header = [ '<STR_LIT>' % header [ <NUM_LIT:0> ] ] + header [ <NUM_LIT:1> : ] <EOL> aligner = self . _aligner_for ( table ) <EOL> return aligner . align_row ( header ) <EOL> def _want_names_on_first_content_row ( self , table , name ) : <EOL> return self . _should_align_columns ( table ) and len ( name ) <= self . _test_or_keyword_name_width <EOL> def _escape ( self , row ) : <EOL> if not row : <EOL> return row <EOL> return self . _escape_cells ( self . _escape_consecutive_whitespace ( row ) ) <EOL> def _escape_cells ( self , row ) : <EOL> return [ row [ <NUM_LIT:0> ] ] + [ self . _escape_empty ( cell ) for cell in row [ <NUM_LIT:1> : ] ] <EOL> def _escape_empty ( self , cell ) : <EOL> return cell or '<STR_LIT:\\\\>' <EOL> class PipeFormatter ( TxtFormatter ) : <EOL> def _escape_cells ( self , row ) : <EOL> return [ self . _escape_empty ( self . _escape_pipes ( cell ) ) for cell in row ] <EOL> def _escape_empty ( self , cell ) : <EOL> return cell or '<STR_LIT:U+0020>' <EOL> def _escape_pipes ( self , cell ) : <EOL> if '<STR_LIT>' in cell : <EOL> cell = cell . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if cell . startswith ( '<STR_LIT>' ) : <EOL> cell = '<STR_LIT:\\\\>' + cell <EOL> if cell . endswith ( '<STR_LIT>' ) : <EOL>", "answer": "cell = cell [ : - <NUM_LIT:1> ] + '<STR_LIT>'"}, {"prompt": "<s> from gettext import gettext as _ <EOL> from functools import wraps <EOL> import bottle <EOL> from bottle import request , redirect <EOL> import plugin as lib_plugin <EOL> from errors import ValidationError <EOL> from . import jsonvalidation <EOL> def route ( path = None , method = '<STR_LIT:GET>' , func = None , name = None , apply = None , skip = None , ** config ) : <EOL> def decorator ( callback ) : <EOL> plugins = [ ] <EOL> def apply_plugin ( plugin ) : <EOL> cls = '<STR_LIT>' . join ( [ plugin . capitalize ( ) , '<STR_LIT>' ] ) <EOL> cls = getattr ( lib_plugin , cls ) <EOL> plugins . append ( cls ( ) ) <EOL> if isinstance ( apply , str ) : <EOL> apply_plugin ( apply ) <EOL> elif isinstance ( apply , list ) : <EOL> for plugin in apply : <EOL> apply_plugin ( plugin ) <EOL> rpath = path <EOL> if rpath != '<STR_LIT:/>' : <EOL> rpath = rpath . rstrip ( '<STR_LIT:/>' ) <EOL> callback = bottle . route ( <EOL> path = rpath , method = method , callback = func , name = name , <EOL> apply = plugins , skip = skip , ** config ) ( callback ) <EOL> @ wraps ( callback ) <EOL> def wrapper ( * args , ** kwargs ) : <EOL> return callback ( * args , ** kwargs ) <EOL> return wrapper <EOL> return decorator <EOL> def get ( path = None , ** kwargs ) : <EOL> return route ( path = path , method = '<STR_LIT:GET>' , ** kwargs ) <EOL> def post ( path = None , ** kwargs ) : <EOL> return route ( path = path , method = '<STR_LIT:POST>' , ** kwargs ) <EOL> def put ( path = None , ** kwargs ) : <EOL> return route ( path = path , method = '<STR_LIT>' , ** kwargs ) <EOL> def delete ( path = None , ** kwargs ) : <EOL> return route ( path = path , method = '<STR_LIT>' , ** kwargs ) <EOL> def validate_schema ( schema , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def decorator ( callback ) : <EOL> def convert_to_dict ( bottle_form ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> d = { } <EOL> for key , value in bottle_form . iterallitems ( ) : <EOL> if key not in d : <EOL>", "answer": "d [ key ] = value"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = <NUM_LIT:9> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> class Achievement ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = '<STR_LIT>' <EOL> category = '<STR_LIT>' <EOL> keywords = tuple ( ) <EOL> goals = tuple ( ) <EOL> def __init__ ( self , current = <NUM_LIT:0> ) : <EOL> self . _current = current <EOL> self . goals = sorted ( self . goals , key = lambda g : g [ '<STR_LIT>' ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' . format ( self . name , self . category , <EOL> self . keywords , self . _current ) <EOL> @ property <EOL> def current ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> g = [ _ for _ in self . goals if self . _current < _ [ '<STR_LIT>' ] ] <EOL> if g : <EOL> return ( self . _current , g [ <NUM_LIT:0> ] ) <EOL> return ( self . _current , None ) <EOL> @ property <EOL> def achieved ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return [ _ for _ in self . goals if self . _current >= _ [ '<STR_LIT>' ] ] <EOL> @ property <EOL> def unachieved ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return [ _ for _ in self . goals if self . _current < _ [ '<STR_LIT>' ] ] <EOL> def increment ( self , amount = <NUM_LIT:1> , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _current = self . _current + amount <EOL> def evaluate ( self , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "return self . achieved"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import inspect <EOL> from core import jobs_registry <EOL> from core . domain import exp_domain <EOL> from core . platform import models <EOL> import feconf <EOL> ( stats_models , feedback_models ) = models . Registry . import_models ( [ <EOL> models . NAMES . statistics , models . NAMES . feedback ] ) <EOL> taskqueue_services = models . Registry . import_taskqueue_services ( ) <EOL> class BaseEventHandler ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> EVENT_TYPE = None <EOL> @ classmethod <EOL> def _notify_continuous_computation_listeners_async ( cls , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> taskqueue_services . defer_to_events_queue ( <EOL> jobs_registry . ContinuousComputationEventDispatcher . dispatch_event , <EOL> cls . EVENT_TYPE , * args , ** kwargs ) <EOL> @ classmethod <EOL> def _handle_event ( cls , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> @ classmethod <EOL> def record ( cls , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cls . _notify_continuous_computation_listeners_async ( * args , ** kwargs ) <EOL> cls . _handle_event ( * args , ** kwargs ) <EOL> class AnswerSubmissionEventHandler ( BaseEventHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> EVENT_TYPE = feconf . EVENT_TYPE_ANSWER_SUBMITTED <EOL> @ classmethod <EOL> def _notify_continuous_computation_listeners_async ( cls , * args , ** kwargs ) : <EOL> pass <EOL> @ classmethod <EOL> def _handle_event ( cls , exploration_id , exploration_version , state_name , <EOL> rule_spec_string , answer ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> stats_models . process_submitted_answer ( <EOL> exploration_id , exploration_version , state_name , <EOL> rule_spec_string , answer ) <EOL> class DefaultRuleAnswerResolutionEventHandler ( BaseEventHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> EVENT_TYPE = feconf . EVENT_TYPE_DEFAULT_ANSWER_RESOLVED <EOL> @ classmethod <EOL> def _handle_event ( cls , exploration_id , state_name , answers ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> stats_models . resolve_answers ( <EOL> exploration_id , state_name , <EOL> exp_domain . DEFAULT_RULESPEC_STR , answers ) <EOL> class StartExplorationEventHandler ( BaseEventHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> EVENT_TYPE = feconf . EVENT_TYPE_START_EXPLORATION <EOL> @ classmethod <EOL> def _handle_event ( cls , exp_id , exp_version , state_name , session_id , <EOL> params , play_type ) : <EOL> stats_models . StartExplorationEventLogEntryModel . create ( <EOL> exp_id , exp_version , state_name , session_id , params , <EOL> play_type ) <EOL> class MaybeLeaveExplorationEventHandler ( BaseEventHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "EVENT_TYPE = feconf . EVENT_TYPE_MAYBE_LEAVE_EXPLORATION"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . conf . urls import include , patterns , url <EOL> from django . contrib import admin <EOL> from django . views . generic import RedirectView <EOL> from reviewboard . admin import forms <EOL> NEWS_FEED = \"<STR_LIT>\" <EOL> settings_urlpatterns = patterns ( <EOL> '<STR_LIT>' , <EOL> url ( r'<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> { <EOL> '<STR_LIT>' : forms . GeneralSettingsForm , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL>", "answer": "name = '<STR_LIT>' ) ,"}, {"prompt": "<s> from . sub_resource import SubResource <EOL> class VirtualNetworkGatewayIPConfiguration ( SubResource ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _attribute_map = { <EOL> '<STR_LIT:id>' : { '<STR_LIT:key>' : '<STR_LIT:id>' , '<STR_LIT:type>' : '<STR_LIT:str>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:type>' : '<STR_LIT:str>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:type>' : '<STR_LIT>' } , <EOL>", "answer": "'<STR_LIT>' : { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:type>' : '<STR_LIT>' } ,"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from __future__ import division <EOL> import math <EOL> import wx <EOL> import pkg_resources <EOL> from python_toolbox import math_tools <EOL> from python_toolbox import wx_tools <EOL> from python_toolbox import binary_search <EOL> from python_toolbox import cute_iter_tools <EOL> from python_toolbox . wx_tools . widgets . cute_panel import CutePanel <EOL> from . snap_map import SnapMap <EOL> from . import images as __images_package <EOL> images_package = __images_package . __name__ <EOL> class Knob ( CutePanel ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , parent , getter , setter , * args , ** kwargs ) : <EOL> '''<STR_LIT>''' <EOL> assert '<STR_LIT:size>' not in kwargs <EOL> kwargs [ '<STR_LIT:size>' ] = ( <NUM_LIT> , <NUM_LIT> ) <EOL> assert callable ( setter ) and callable ( getter ) <EOL> self . value_getter , self . value_setter = getter , setter <EOL> CutePanel . __init__ ( self , parent , * args , ** kwargs ) <EOL> self . SetBackgroundStyle ( wx . BG_STYLE_CUSTOM ) <EOL> self . original_bitmap = wx_tools . bitmap_tools . bitmap_from_pkg_resources ( <EOL> images_package , <EOL> '<STR_LIT>' <EOL> ) <EOL> self . bind_event_handlers ( Knob ) <EOL> self . SetCursor ( wx_tools . cursors . collection . get_open_grab ( ) ) <EOL> self . _knob_house_brush = wx . Brush ( wx . Colour ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ) ) <EOL> '''<STR_LIT>''' <EOL> self . current_angle = <NUM_LIT:0> <EOL> '''<STR_LIT>''' <EOL> self . current_ratio = <NUM_LIT:0> <EOL> '''<STR_LIT>''' <EOL> self . sensitivity = <NUM_LIT> <EOL> '''<STR_LIT>''' <EOL> self . angle_resolution = math . pi / <NUM_LIT> <EOL> '''<STR_LIT>''' <EOL> self . snap_points = [ ] <EOL> '''<STR_LIT>''' <EOL> self . base_drag_radius = <NUM_LIT:50> <EOL> '''<STR_LIT>''' <EOL> self . snap_point_drag_well = <NUM_LIT:20> <EOL> '''<STR_LIT>''' <EOL> self . being_dragged = False <EOL> '''<STR_LIT>''' <EOL> self . snap_map = None <EOL> '''<STR_LIT>''' <EOL> self . needs_recalculation_flag = True <EOL> '''<STR_LIT>''' <EOL> self . _recalculate ( ) <EOL> def _angle_to_ratio ( self , angle ) : <EOL> '''<STR_LIT>''' <EOL> return angle / ( math . pi * <NUM_LIT:5> / <NUM_LIT:6> ) <EOL> def _ratio_to_value ( self , ratio ) : <EOL> '''<STR_LIT>''' <EOL> return self . sensitivity * math_tools . get_sign ( ratio ) * ( <NUM_LIT:4> / math . pi ** <NUM_LIT:2> ) * math . log ( math . cos ( ratio * math . pi / <NUM_LIT:2> ) ) ** <NUM_LIT:2> <EOL> def _value_to_ratio ( self , value ) : <EOL> '''<STR_LIT>''' <EOL> return math_tools . get_sign ( value ) * ( <NUM_LIT:2> / math . pi ) * math . acos ( <EOL> math . exp ( <EOL> - ( math . pi * math . sqrt ( abs ( value ) ) ) / ( <NUM_LIT:2> * math . sqrt ( self . sensitivity ) ) <EOL> ) <EOL> ) <EOL> def _ratio_to_angle ( self , ratio ) : <EOL> '''<STR_LIT>''' <EOL> return ratio * ( math . pi * <NUM_LIT:5> / <NUM_LIT:6> ) <EOL> def _get_snap_points_as_ratios ( self ) : <EOL> '''<STR_LIT>''' <EOL> return [ self . _value_to_ratio ( value ) for value in self . snap_points ] <EOL> def set_snap_point ( self , value ) : <EOL> '''<STR_LIT>''' <EOL> self . snap_points . append ( value ) <EOL> self . snap_points . sort ( ) <EOL> def remove_snap_point ( self , value ) : <EOL> '''<STR_LIT>''' <EOL> self . snap_points . remove ( value ) <EOL> def _recalculate ( self ) : <EOL> '''<STR_LIT>''' <EOL> value = self . value_getter ( ) <EOL> self . current_ratio = self . _value_to_ratio ( value ) <EOL> angle = self . _ratio_to_angle ( self . current_ratio ) <EOL> d_angle = angle - self . current_angle <EOL> if abs ( d_angle ) > self . angle_resolution : <EOL> self . current_angle = angle <EOL> self . Refresh ( ) <EOL> self . needs_recalculation_flag = False <EOL> def _on_paint ( self , event ) : <EOL> '''<STR_LIT>''' <EOL> dc = wx . BufferedPaintDC ( self ) <EOL> dc . SetBackground ( wx_tools . colors . get_background_brush ( ) ) <EOL> dc . Clear ( ) <EOL> w , h = self . GetClientSize ( ) <EOL> gc = wx . GraphicsContext . Create ( dc ) <EOL> gc . SetPen ( wx . TRANSPARENT_PEN ) <EOL> gc . SetBrush ( self . _knob_house_brush ) <EOL> assert isinstance ( gc , wx . GraphicsContext ) <EOL> gc . Translate ( w / <NUM_LIT:2> , h / <NUM_LIT:2> ) <EOL> gc . Rotate ( self . current_angle ) <EOL> gc . DrawEllipse ( - <NUM_LIT> , - <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) <EOL> gc . DrawBitmap ( self . original_bitmap , - <NUM_LIT> , - <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) <EOL> def _on_size ( self , event ) : <EOL> '''<STR_LIT>''' <EOL> event . Skip ( ) <EOL> self . Refresh ( ) <EOL> def _on_mouse_events ( self , event ) : <EOL> '''<STR_LIT>''' <EOL> self . Refresh ( ) <EOL> ( w , h ) = self . GetClientSize ( ) <EOL> ( x , y ) = event . GetPositionTuple ( ) <EOL> if event . LeftDown ( ) : <EOL> self . being_dragged = True <EOL> self . snap_map = SnapMap ( <EOL> snap_point_ratios = self . _get_snap_points_as_ratios ( ) , <EOL> base_drag_radius = self . base_drag_radius , <EOL>", "answer": "snap_point_drag_well = self . snap_point_drag_well ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from social . backends . open_id import OpenIdAuth <EOL> class BelgiumEIDOpenId ( OpenIdAuth ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "name = '<STR_LIT>'"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from __future__ import absolute_import <EOL> import re <EOL> import string <EOL> import random <EOL> try : <EOL> import Crypto . Random <EOL> HAS_RANDOM = True <EOL> except ImportError : <EOL> HAS_RANDOM = False <EOL> try : <EOL> import crypt <EOL> HAS_CRYPT = True <EOL> except ImportError : <EOL> HAS_CRYPT = False <EOL> from salt . exceptions import SaltInvocationError <EOL> def secure_password ( length = <NUM_LIT:20> , use_random = True ) : <EOL> '''<STR_LIT>''' <EOL> length = int ( length ) <EOL> pw = '<STR_LIT>' <EOL> while len ( pw ) < length : <EOL> if HAS_RANDOM and use_random : <EOL> pw += re . sub ( r'<STR_LIT>' , '<STR_LIT>' , Crypto . Random . get_random_bytes ( <NUM_LIT:1> ) ) <EOL>", "answer": "else :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from . _common import unittest , WarningTestMixin , NotAValue <EOL> import calendar <EOL> from datetime import datetime , date <EOL> from dateutil . relativedelta import * <EOL> class RelativeDeltaTest ( WarningTestMixin , unittest . TestCase ) : <EOL> now = datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT> , <NUM_LIT:20> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) <EOL> today = date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT> ) <EOL> def testInheritance ( self ) : <EOL> class rdChildClass ( relativedelta ) : <EOL> pass <EOL> ccRD = rdChildClass ( years = <NUM_LIT:1> , months = <NUM_LIT:1> , days = <NUM_LIT:1> , leapdays = <NUM_LIT:1> , weeks = <NUM_LIT:1> , <EOL> hours = <NUM_LIT:1> , minutes = <NUM_LIT:1> , seconds = <NUM_LIT:1> , microseconds = <NUM_LIT:1> ) <EOL> rd = relativedelta ( years = <NUM_LIT:1> , months = <NUM_LIT:1> , days = <NUM_LIT:1> , leapdays = <NUM_LIT:1> , weeks = <NUM_LIT:1> , <EOL> hours = <NUM_LIT:1> , minutes = <NUM_LIT:1> , seconds = <NUM_LIT:1> , microseconds = <NUM_LIT:1> ) <EOL> self . assertEqual ( type ( ccRD + rd ) , type ( ccRD ) , <EOL> msg = '<STR_LIT>' ) <EOL> self . assertEqual ( type ( ccRD - rd ) , type ( ccRD ) , <EOL> msg = '<STR_LIT>' ) <EOL> self . assertEqual ( type ( - ccRD ) , type ( ccRD ) , <EOL> msg = '<STR_LIT>' ) <EOL> self . assertEqual ( type ( ccRD * <NUM_LIT> ) , type ( ccRD ) , <EOL> msg = '<STR_LIT>' ) <EOL> self . assertEqual ( type ( ccRD / <NUM_LIT> ) , type ( ccRD ) , <EOL> msg = '<STR_LIT>' ) <EOL> def testMonthEndMonthBeginning ( self ) : <EOL> self . assertEqual ( relativedelta ( datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ) ) , <EOL> relativedelta ( months = - <NUM_LIT:1> , seconds = - <NUM_LIT:1> ) ) <EOL> self . assertEqual ( relativedelta ( datetime ( <NUM_LIT> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) , <EOL> relativedelta ( months = <NUM_LIT:1> , seconds = <NUM_LIT:1> ) ) <EOL> def testMonthEndMonthBeginningLeapYear ( self ) : <EOL> self . assertEqual ( relativedelta ( datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ) ) , <EOL> relativedelta ( months = - <NUM_LIT:1> , seconds = - <NUM_LIT:1> ) ) <EOL> self . assertEqual ( relativedelta ( datetime ( <NUM_LIT> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) , <EOL> relativedelta ( months = <NUM_LIT:1> , seconds = <NUM_LIT:1> ) ) <EOL> def testNextMonth ( self ) : <EOL> self . assertEqual ( self . now + relativedelta ( months = + <NUM_LIT:1> ) , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:10> , <NUM_LIT> , <NUM_LIT:20> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) <EOL> def testNextMonthPlusOneWeek ( self ) : <EOL> self . assertEqual ( self . now + relativedelta ( months = + <NUM_LIT:1> , weeks = + <NUM_LIT:1> ) , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:10> , <NUM_LIT> , <NUM_LIT:20> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) <EOL> def testNextMonthPlusOneWeek10am ( self ) : <EOL> self . assertEqual ( self . today + <EOL> relativedelta ( months = + <NUM_LIT:1> , weeks = + <NUM_LIT:1> , hour = <NUM_LIT:10> ) , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:10> , <NUM_LIT> , <NUM_LIT:10> , <NUM_LIT:0> ) ) <EOL> def testNextMonthPlusOneWeek10amDiff ( self ) : <EOL> self . assertEqual ( relativedelta ( datetime ( <NUM_LIT> , <NUM_LIT:10> , <NUM_LIT> , <NUM_LIT:10> , <NUM_LIT:0> ) , <EOL> self . today ) , <EOL> relativedelta ( months = + <NUM_LIT:1> , days = + <NUM_LIT:7> , hours = + <NUM_LIT:10> ) ) <EOL> def testOneMonthBeforeOneYear ( self ) : <EOL> self . assertEqual ( self . now + relativedelta ( years = + <NUM_LIT:1> , months = - <NUM_LIT:1> ) , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:8> , <NUM_LIT> , <NUM_LIT:20> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) <EOL> def testMonthsOfDiffNumOfDays ( self ) : <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT> ) + relativedelta ( months = + <NUM_LIT:1> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:2> , <NUM_LIT> ) ) <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT> ) + relativedelta ( months = + <NUM_LIT:1> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:2> , <NUM_LIT> ) ) <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT> ) + relativedelta ( months = + <NUM_LIT:2> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:3> , <NUM_LIT> ) ) <EOL> def testMonthsOfDiffNumOfDaysWithYears ( self ) : <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:2> , <NUM_LIT> ) + relativedelta ( years = + <NUM_LIT:1> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:2> , <NUM_LIT> ) ) <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:2> , <NUM_LIT> ) + relativedelta ( years = + <NUM_LIT:1> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:2> , <NUM_LIT> ) ) <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:2> , <NUM_LIT> ) + relativedelta ( years = + <NUM_LIT:1> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:2> , <NUM_LIT> ) ) <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:3> , <NUM_LIT:1> ) + relativedelta ( years = + <NUM_LIT:1> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:3> , <NUM_LIT:1> ) ) <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:3> , <NUM_LIT:1> ) + relativedelta ( years = + <NUM_LIT:1> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:3> , <NUM_LIT:1> ) ) <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:2> , <NUM_LIT> ) + relativedelta ( years = - <NUM_LIT:1> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:2> , <NUM_LIT> ) ) <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:3> , <NUM_LIT:1> ) + relativedelta ( years = - <NUM_LIT:1> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:3> , <NUM_LIT:1> ) ) <EOL> def testNextFriday ( self ) : <EOL> self . assertEqual ( self . today + relativedelta ( weekday = FR ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT> ) ) <EOL> def testNextFridayInt ( self ) : <EOL> self . assertEqual ( self . today + relativedelta ( weekday = calendar . FRIDAY ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT> ) ) <EOL> def testLastFridayInThisMonth ( self ) : <EOL> self . assertEqual ( self . today + relativedelta ( day = <NUM_LIT> , weekday = FR ( - <NUM_LIT:1> ) ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT> ) ) <EOL> def testNextWednesdayIsToday ( self ) : <EOL> self . assertEqual ( self . today + relativedelta ( weekday = WE ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT> ) ) <EOL> def testNextWenesdayNotToday ( self ) : <EOL> self . assertEqual ( self . today + relativedelta ( days = + <NUM_LIT:1> , weekday = WE ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT> ) ) <EOL> def test15thISOYearWeek ( self ) : <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) + <EOL> relativedelta ( day = <NUM_LIT:4> , weeks = + <NUM_LIT> , weekday = MO ( - <NUM_LIT:1> ) ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:4> , <NUM_LIT:7> ) ) <EOL> def testMillenniumAge ( self ) : <EOL> self . assertEqual ( relativedelta ( self . now , date ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) ) , <EOL> relativedelta ( years = + <NUM_LIT:2> , months = + <NUM_LIT:8> , days = + <NUM_LIT:16> , <EOL> hours = + <NUM_LIT:20> , minutes = + <NUM_LIT> , seconds = + <NUM_LIT> , <EOL> microseconds = + <NUM_LIT> ) ) <EOL> def testJohnAge ( self ) : <EOL> self . assertEqual ( relativedelta ( self . now , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:4> , <NUM_LIT:5> , <NUM_LIT:12> , <NUM_LIT:0> ) ) , <EOL> relativedelta ( years = + <NUM_LIT> , months = + <NUM_LIT:5> , days = + <NUM_LIT:12> , <EOL> hours = + <NUM_LIT:8> , minutes = + <NUM_LIT> , seconds = + <NUM_LIT> , <EOL> microseconds = + <NUM_LIT> ) ) <EOL> def testJohnAgeWithDate ( self ) : <EOL> self . assertEqual ( relativedelta ( self . today , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:4> , <NUM_LIT:5> , <NUM_LIT:12> , <NUM_LIT:0> ) ) , <EOL> relativedelta ( years = + <NUM_LIT> , months = + <NUM_LIT:5> , days = + <NUM_LIT:11> , <EOL> hours = + <NUM_LIT:12> ) ) <EOL> def testYearDay ( self ) : <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) + relativedelta ( yearday = <NUM_LIT> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT> ) ) <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) + relativedelta ( yearday = <NUM_LIT> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT> ) ) <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) + relativedelta ( yearday = <NUM_LIT> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:16> ) ) <EOL> self . assertEqual ( self . today + relativedelta ( yearday = <NUM_LIT> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT> ) ) <EOL> def testYearDayBug ( self ) : <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) + relativedelta ( yearday = <NUM_LIT:15> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:15> ) ) <EOL> def testNonLeapYearDay ( self ) : <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) + relativedelta ( nlyearday = <NUM_LIT> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT> ) ) <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) + relativedelta ( nlyearday = <NUM_LIT> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT> ) ) <EOL> self . assertEqual ( date ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) + relativedelta ( nlyearday = <NUM_LIT> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT> ) ) <EOL> self . assertEqual ( self . today + relativedelta ( yearday = <NUM_LIT> ) , <EOL> date ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT> ) ) <EOL> def testAddition ( self ) : <EOL> self . assertEqual ( relativedelta ( days = <NUM_LIT:10> ) + <EOL> relativedelta ( years = <NUM_LIT:1> , months = <NUM_LIT:2> , days = <NUM_LIT:3> , hours = <NUM_LIT:4> , <EOL> minutes = <NUM_LIT:5> , microseconds = <NUM_LIT:6> ) , <EOL> relativedelta ( years = <NUM_LIT:1> , months = <NUM_LIT:2> , days = <NUM_LIT> , hours = <NUM_LIT:4> , <EOL> minutes = <NUM_LIT:5> , microseconds = <NUM_LIT:6> ) ) <EOL> def testAdditionToDatetime ( self ) : <EOL> self . assertEqual ( datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) + relativedelta ( days = <NUM_LIT:1> ) , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> def testRightAdditionToDatetime ( self ) : <EOL> self . assertEqual ( relativedelta ( days = <NUM_LIT:1> ) + datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> def testAdditionInvalidType ( self ) : <EOL> with self . assertRaises ( TypeError ) : <EOL> relativedelta ( days = <NUM_LIT:3> ) + <NUM_LIT:9> <EOL> def testAdditionUnsupportedType ( self ) : <EOL> self . assertIs ( relativedelta ( days = <NUM_LIT:1> ) + NotAValue , NotAValue ) <EOL> def testSubtraction ( self ) : <EOL> self . assertEqual ( relativedelta ( days = <NUM_LIT:10> ) - <EOL> relativedelta ( years = <NUM_LIT:1> , months = <NUM_LIT:2> , days = <NUM_LIT:3> , hours = <NUM_LIT:4> , <EOL> minutes = <NUM_LIT:5> , microseconds = <NUM_LIT:6> ) , <EOL> relativedelta ( years = - <NUM_LIT:1> , months = - <NUM_LIT:2> , days = <NUM_LIT:7> , hours = - <NUM_LIT:4> , <EOL> minutes = - <NUM_LIT:5> , microseconds = - <NUM_LIT:6> ) ) <EOL> def testRightSubtractionFromDatetime ( self ) : <EOL> self . assertEqual ( datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:2> ) - relativedelta ( days = <NUM_LIT:1> ) , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) ) <EOL> def testSubractionWithDatetime ( self ) : <EOL> self . assertRaises ( TypeError , lambda x , y : x - y , <EOL> ( relativedelta ( days = <NUM_LIT:1> ) , datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) ) ) <EOL> def testSubtractionInvalidType ( self ) : <EOL> with self . assertRaises ( TypeError ) : <EOL> relativedelta ( hours = <NUM_LIT:12> ) - <NUM_LIT> <EOL> def testSubtractionUnsupportedType ( self ) : <EOL> self . assertIs ( relativedelta ( days = <NUM_LIT:1> ) + NotAValue , NotAValue ) <EOL> def testMultiplication ( self ) : <EOL> self . assertEqual ( datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) + relativedelta ( days = <NUM_LIT:1> ) * <NUM_LIT> , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT> ) ) <EOL> self . assertEqual ( datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) + <NUM_LIT> * relativedelta ( days = <NUM_LIT:1> ) , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT> ) ) <EOL> def testMultiplicationUnsupportedType ( self ) : <EOL> self . assertIs ( relativedelta ( days = <NUM_LIT:1> ) * NotAValue , NotAValue ) <EOL> def testDivision ( self ) : <EOL> self . assertEqual ( datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> ) + relativedelta ( days = <NUM_LIT> ) / <NUM_LIT> , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:2> ) ) <EOL> def testDivisionUnsupportedType ( self ) : <EOL> self . assertIs ( relativedelta ( days = <NUM_LIT:1> ) / NotAValue , NotAValue ) <EOL> def testBoolean ( self ) : <EOL> self . assertFalse ( relativedelta ( days = <NUM_LIT:0> ) ) <EOL> self . assertTrue ( relativedelta ( days = <NUM_LIT:1> ) ) <EOL> def testComparison ( self ) : <EOL> d1 = relativedelta ( years = <NUM_LIT:1> , months = <NUM_LIT:1> , days = <NUM_LIT:1> , leapdays = <NUM_LIT:0> , hours = <NUM_LIT:1> , <EOL> minutes = <NUM_LIT:1> , seconds = <NUM_LIT:1> , microseconds = <NUM_LIT:1> ) <EOL> d2 = relativedelta ( years = <NUM_LIT:1> , months = <NUM_LIT:1> , days = <NUM_LIT:1> , leapdays = <NUM_LIT:0> , hours = <NUM_LIT:1> , <EOL> minutes = <NUM_LIT:1> , seconds = <NUM_LIT:1> , microseconds = <NUM_LIT:1> ) <EOL> d3 = relativedelta ( years = <NUM_LIT:1> , months = <NUM_LIT:1> , days = <NUM_LIT:1> , leapdays = <NUM_LIT:0> , hours = <NUM_LIT:1> , <EOL> minutes = <NUM_LIT:1> , seconds = <NUM_LIT:1> , microseconds = <NUM_LIT:2> ) <EOL> self . assertEqual ( d1 , d2 ) <EOL> self . assertNotEqual ( d1 , d3 ) <EOL> def testInequalityTypeMismatch ( self ) : <EOL> self . assertFalse ( relativedelta ( year = <NUM_LIT:1> ) == <NUM_LIT> ) <EOL> def testInequalityUnsupportedType ( self ) : <EOL> self . assertIs ( relativedelta ( hours = <NUM_LIT:3> ) == NotAValue , NotAValue ) <EOL> def testInequalityWeekdays ( self ) : <EOL> no_wday = relativedelta ( year = <NUM_LIT> , month = <NUM_LIT:4> ) <EOL> wday_mo_1 = relativedelta ( year = <NUM_LIT> , month = <NUM_LIT:4> , weekday = MO ( + <NUM_LIT:1> ) ) <EOL> wday_mo_2 = relativedelta ( year = <NUM_LIT> , month = <NUM_LIT:4> , weekday = MO ( + <NUM_LIT:2> ) ) <EOL> wday_tu = relativedelta ( year = <NUM_LIT> , month = <NUM_LIT:4> , weekday = TU ) <EOL> self . assertTrue ( wday_mo_1 == wday_mo_1 ) <EOL> self . assertFalse ( no_wday == wday_mo_1 ) <EOL> self . assertFalse ( wday_mo_1 == no_wday ) <EOL> self . assertFalse ( wday_mo_1 == wday_mo_2 ) <EOL> self . assertFalse ( wday_mo_2 == wday_mo_1 ) <EOL> self . assertFalse ( wday_mo_1 == wday_tu ) <EOL> self . assertFalse ( wday_tu == wday_mo_1 ) <EOL> def testMonthOverflow ( self ) : <EOL> self . assertEqual ( relativedelta ( months = <NUM_LIT> ) , <EOL> relativedelta ( years = <NUM_LIT> , months = <NUM_LIT:9> ) ) <EOL> def testWeeks ( self ) : <EOL> rd = relativedelta ( years = <NUM_LIT:4> , months = <NUM_LIT:2> , weeks = <NUM_LIT:8> , days = <NUM_LIT:6> ) <EOL> self . assertEqual ( ( rd . weeks , rd . days ) , ( <NUM_LIT:8> , <NUM_LIT:8> * <NUM_LIT:7> + <NUM_LIT:6> ) ) <EOL> rd . weeks = <NUM_LIT:3> <EOL> self . assertEqual ( ( rd . weeks , rd . days ) , ( <NUM_LIT:3> , <NUM_LIT:3> * <NUM_LIT:7> + <NUM_LIT:6> ) ) <EOL> def testRelativeDeltaRepr ( self ) : <EOL> self . assertEqual ( repr ( relativedelta ( years = <NUM_LIT:1> , months = - <NUM_LIT:1> , days = <NUM_LIT:15> ) ) , <EOL> '<STR_LIT>' ) <EOL> self . assertEqual ( repr ( relativedelta ( months = <NUM_LIT> , seconds = - <NUM_LIT> ) ) , <EOL> '<STR_LIT>' ) <EOL> self . assertEqual ( repr ( relativedelta ( month = <NUM_LIT:3> , hour = <NUM_LIT:3> , weekday = SU ( <NUM_LIT:3> ) ) ) , <EOL> '<STR_LIT>' ) <EOL> def testRelativeDeltaFractionalYear ( self ) : <EOL> with self . assertRaises ( ValueError ) : <EOL> relativedelta ( years = <NUM_LIT> ) <EOL> def testRelativeDeltaFractionalMonth ( self ) : <EOL> with self . assertRaises ( ValueError ) : <EOL> relativedelta ( months = <NUM_LIT> ) <EOL> def testRelativeDeltaFractionalAbsolutes ( self ) : <EOL> with self . assertWarns ( DeprecationWarning ) : <EOL> relativedelta ( year = <NUM_LIT> ) <EOL> with self . assertWarns ( DeprecationWarning ) : <EOL> relativedelta ( month = <NUM_LIT> ) <EOL> with self . assertWarns ( DeprecationWarning ) : <EOL> relativedelta ( day = <NUM_LIT> ) <EOL> with self . assertWarns ( DeprecationWarning ) : <EOL> relativedelta ( hour = <NUM_LIT> ) <EOL> with self . assertWarns ( DeprecationWarning ) : <EOL> relativedelta ( minute = <NUM_LIT> ) <EOL> with self . assertWarns ( DeprecationWarning ) : <EOL> relativedelta ( second = <NUM_LIT> ) <EOL> with self . assertWarns ( DeprecationWarning ) : <EOL> relativedelta ( microsecond = <NUM_LIT> ) <EOL> def testRelativeDeltaFractionalRepr ( self ) : <EOL> rd = relativedelta ( years = <NUM_LIT:3> , months = - <NUM_LIT:2> , days = <NUM_LIT> ) <EOL> self . assertEqual ( repr ( rd ) , <EOL> '<STR_LIT>' ) <EOL> rd = relativedelta ( hours = <NUM_LIT:0.5> , seconds = <NUM_LIT> ) <EOL> self . assertEqual ( repr ( rd ) , <EOL> '<STR_LIT>' ) <EOL> def testRelativeDeltaFractionalWeeks ( self ) : <EOL> rd = relativedelta ( weeks = <NUM_LIT> ) <EOL> d1 = datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> self . assertEqual ( d1 + rd , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:11> , <NUM_LIT> ) ) <EOL> def testRelativeDeltaFractionalDays ( self ) : <EOL> rd1 = relativedelta ( days = <NUM_LIT> ) <EOL> d1 = datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> self . assertEqual ( d1 + rd1 , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:4> , <NUM_LIT:11> , <NUM_LIT> , <NUM_LIT:12> ) ) <EOL> rd2 = relativedelta ( days = <NUM_LIT> ) <EOL> self . assertEqual ( d1 + rd2 , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:4> , <NUM_LIT:12> , <NUM_LIT:0> , <NUM_LIT:0> ) ) <EOL> def testRelativeDeltaFractionalHours ( self ) : <EOL> rd = relativedelta ( days = <NUM_LIT:1> , hours = <NUM_LIT> ) <EOL> d1 = datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> self . assertEqual ( d1 + rd , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:4> , <NUM_LIT:12> , <NUM_LIT:30> , <NUM_LIT:0> ) ) <EOL> def testRelativeDeltaFractionalMinutes ( self ) : <EOL> rd = relativedelta ( hours = <NUM_LIT:1> , minutes = <NUM_LIT> ) <EOL> d1 = datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> self . assertEqual ( d1 + rd , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:30> , <NUM_LIT:30> ) ) <EOL> def testRelativeDeltaFractionalSeconds ( self ) : <EOL> rd = relativedelta ( hours = <NUM_LIT:5> , minutes = <NUM_LIT:30> , seconds = <NUM_LIT> ) <EOL> d1 = datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> self . assertEqual ( d1 + rd , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:3> , <NUM_LIT:5> , <NUM_LIT:30> , <NUM_LIT:30> , <NUM_LIT> ) ) <EOL> def testRelativeDeltaFractionalPositiveOverflow ( self ) : <EOL> rd1 = relativedelta ( days = <NUM_LIT> , hours = <NUM_LIT:2> ) <EOL> d1 = datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> self . assertEqual ( d1 + rd1 , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:4> , <NUM_LIT> , <NUM_LIT:0> , <NUM_LIT:0> ) ) <EOL> rd2 = relativedelta ( days = <NUM_LIT> , hours = <NUM_LIT> , minutes = <NUM_LIT:15> ) <EOL> d1 = datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> self . assertEqual ( d1 + rd2 , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:4> , <NUM_LIT> , <NUM_LIT> ) ) <EOL> rd3 = relativedelta ( days = <NUM_LIT> , hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) <EOL> self . assertEqual ( d1 + rd3 , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:5> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:1> ) ) <EOL> def testRelativeDeltaFractionalNegativeDays ( self ) : <EOL> rd1 = relativedelta ( days = - <NUM_LIT> , hours = <NUM_LIT:11> ) <EOL> d1 = datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:3> , <NUM_LIT:12> , <NUM_LIT:0> ) <EOL> self . assertEqual ( d1 + rd1 , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:2> , <NUM_LIT:11> , <NUM_LIT:0> , <NUM_LIT:0> ) ) <EOL> rd2 = relativedelta ( days = - <NUM_LIT> , hours = - <NUM_LIT:3> ) <EOL> self . assertEqual ( d1 + rd2 , <EOL> datetime ( <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> def testRelativeDeltaNormalizeFractionalDays ( self ) : <EOL> rd1 = relativedelta ( days = <NUM_LIT> ) <EOL> self . assertEqual ( rd1 . normalized ( ) , relativedelta ( days = <NUM_LIT:2> , hours = <NUM_LIT> ) ) <EOL> rd2 = relativedelta ( days = <NUM_LIT> ) <EOL> self . assertEqual ( rd2 . normalized ( ) , <EOL> relativedelta ( days = <NUM_LIT:1> , hours = <NUM_LIT:11> , minutes = <NUM_LIT> , seconds = <NUM_LIT:12> ) ) <EOL> def testRelativeDeltaNormalizeFractionalDays ( self ) : <EOL> rd1 = relativedelta ( hours = <NUM_LIT> ) <EOL> self . assertEqual ( rd1 . normalized ( ) , relativedelta ( hours = <NUM_LIT:1> , minutes = <NUM_LIT:30> ) ) <EOL> rd2 = relativedelta ( hours = <NUM_LIT> ) <EOL> self . assertEqual ( rd2 . normalized ( ) , <EOL> relativedelta ( hours = <NUM_LIT:3> , minutes = <NUM_LIT> , seconds = <NUM_LIT:5> , microseconds = <NUM_LIT:100> ) ) <EOL> def testRelativeDeltaNormalizeFractionalMinutes ( self ) : <EOL> rd1 = relativedelta ( minutes = <NUM_LIT> ) <EOL> self . assertEqual ( rd1 . normalized ( ) , <EOL> relativedelta ( minutes = <NUM_LIT:15> , seconds = <NUM_LIT> ) ) <EOL> rd2 = relativedelta ( minutes = <NUM_LIT> ) <EOL> self . assertEqual ( rd2 . normalized ( ) , <EOL> relativedelta ( minutes = <NUM_LIT> , seconds = <NUM_LIT:20> , microseconds = <NUM_LIT> ) ) <EOL> def testRelativeDeltaNormalizeFractionalSeconds ( self ) : <EOL> rd1 = relativedelta ( seconds = <NUM_LIT> ) <EOL> self . assertEqual ( rd1 . normalized ( ) , <EOL>", "answer": "relativedelta ( seconds = <NUM_LIT> , microseconds = <NUM_LIT> ) )"}, {"prompt": "<s> from ConfigParser import SafeConfigParser , NoSectionError <EOL> import sys <EOL> import socket <EOL> import os <EOL> from . . exceptions import UserException <EOL> import logging <EOL> import logging . handlers <EOL> from time import strftime <EOL> from loghandlers import LogglyHandler <EOL> def CONFIG_DEFAULTS ( ) : <EOL> return { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : socket . gethostname ( ) , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT:false>' , <EOL> } <EOL> CONFIG_PATHS = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> os . path . expanduser ( '<STR_LIT>' ) , <EOL> ] <EOL> CONFIG_SECTIONS = set ( [ '<STR_LIT>' , '<STR_LIT:status>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> LOG_FORMAT = logging . Formatter ( '<STR_LIT>' ) <EOL> def log_file_parse ( log , logline , level ) : <EOL> if len ( logline ) < <NUM_LIT:3> : <EOL> raise _log_throw ( log , '<STR_LIT>' , logline ) <EOL> param = logline [ <NUM_LIT:2> ] <EOL> fh = logging . FileHandler ( param , '<STR_LIT:a>' , None , False ) <EOL> fh . setLevel ( level ) <EOL> fh . setFormatter ( LOG_FORMAT ) <EOL> timestr = strftime ( \"<STR_LIT>\" ) <EOL> breaker = '<STR_LIT>' <EOL> args = breaker , timestr , breaker <EOL> record = logging . LogRecord ( '<STR_LIT>' , <NUM_LIT:10> , '<STR_LIT>' , <NUM_LIT:0> , '<STR_LIT>' , args , None ) <EOL> fh . handle ( record ) <EOL> return fh <EOL> def log_stream_parse ( log , logline , level ) : <EOL> VALID_STREAMS = set ( [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> if len ( logline ) < <NUM_LIT:3> : <EOL> raise _log_throw ( log , '<STR_LIT>' , logline ) <EOL> param = logline [ <NUM_LIT:2> ] . lower ( ) <EOL> if param not in VALID_STREAMS : <EOL> raise _log_throw ( log , '<STR_LIT>' , logline ) <EOL> if param == '<STR_LIT>' : <EOL> param = sys . stdout <EOL> if param == '<STR_LIT>' : <EOL> param = sys . stderr <EOL> sh = logging . StreamHandler ( param ) <EOL>", "answer": "sh . setLevel ( level )"}, {"prompt": "<s> from migen import * <EOL>", "answer": "from migen . fhdl . specials import SynthesisDirective"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "__author__ = \"<STR_LIT>\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . core . files . uploadhandler import FileUploadHandler , StopUpload <EOL> class QuotaUploadHandler ( FileUploadHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "QUOTA = <NUM_LIT:5> * <NUM_LIT:2> ** <NUM_LIT:20>"}, {"prompt": "<s> from rockstar import RockStar <EOL> apl_code = \"<STR_LIT>\" <EOL>", "answer": "rock_it_bro = RockStar ( days = <NUM_LIT> , file_name = '<STR_LIT>' , code = apl_code )"}, {"prompt": "<s> import sys <EOL> from StringIO import StringIO <EOL> from nose . tools import with_setup , assert_equals <EOL> import couleur <EOL> def prepare_stderr ( ) : <EOL> if isinstance ( sys . stderr , StringIO ) : <EOL> del sys . stderr <EOL> std = StringIO ( ) <EOL> sys . stderr = std <EOL> def assert_stderr ( expected ) : <EOL> string = sys . stderr . getvalue ( ) <EOL> sys . stderr . seek ( <NUM_LIT:0> ) <EOL> sys . stderr . truncate ( ) <EOL> assert_equals ( string , expected ) <EOL> @ with_setup ( prepare_stderr ) <EOL> def test_output_black_foreground ( ) : <EOL> \"<STR_LIT>\" <EOL> couleur . proxy ( sys . stderr ) . enable ( ) <EOL> sys . stderr . write ( \"<STR_LIT>\" ) <EOL> assert_stderr ( '<STR_LIT>' ) <EOL> couleur . proxy ( sys . stderr ) . disable ( ) <EOL> sys . stderr . write ( \"<STR_LIT>\" ) <EOL> assert_stderr ( '<STR_LIT>' ) <EOL> @ with_setup ( prepare_stderr ) <EOL> def test_output_black_on_white_foreground ( ) : <EOL> \"<STR_LIT>\" <EOL> couleur . proxy ( sys . stderr ) . enable ( ) <EOL> sys . stderr . write ( \"<STR_LIT>\" ) <EOL> assert_stderr ( '<STR_LIT>' ) <EOL> couleur . proxy ( sys . stderr ) . disable ( ) <EOL> sys . stderr . write ( \"<STR_LIT>\" ) <EOL> assert_stderr ( '<STR_LIT>' ) <EOL> @ with_setup ( prepare_stderr ) <EOL> def test_output_green_foreground ( ) : <EOL> \"<STR_LIT>\" <EOL> couleur . proxy ( sys . stderr ) . enable ( ) <EOL> sys . stderr . write ( \"<STR_LIT>\" ) <EOL>", "answer": "assert_stderr ( '<STR_LIT>' )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import sys <EOL> from shutil import rmtree <EOL> from tempfile import mkdtemp <EOL> from multiprocessing import Pool <EOL> import scipy . sparse as sp <EOL> from scipy . io import loadmat <EOL> from multimodal . experiment import TwoModalitiesExperiment <EOL> from multimodal . db . objects import ObjectsLoader <EOL> from multimodal . db . acorns import Year1Loader as AcornsLoader <EOL> from multimodal . lib . window import ( concat_from_list_of_wavs , BasicTimeWindow , <EOL> ConcatTimeWindow , slider ) <EOL> from multimodal . learner import MultimodalLearner <EOL> from multimodal . lib . metrics import cosine_diff <EOL> from multimodal . evaluation import all_distances <EOL> from multimodal . features . hac import hac <EOL> from multimodal . local import CONFIG <EOL> CODEBOOK_PATH = os . path . join ( CONFIG [ '<STR_LIT>' ] , \"<STR_LIT>\" ) <EOL> DEBUG = False <EOL> if len ( sys . argv ) > <NUM_LIT:1> and sys . argv [ <NUM_LIT:1> ] == '<STR_LIT>' : <EOL> DEBUG = True <EOL> sys . argv . pop ( <NUM_LIT:1> ) <EOL> exp = TwoModalitiesExperiment ( { '<STR_LIT>' : ObjectsLoader ( [ '<STR_LIT>' , '<STR_LIT>' ] ) , <EOL> '<STR_LIT>' : AcornsLoader ( <NUM_LIT:1> ) } , <EOL> <NUM_LIT:50> , <NUM_LIT:50> , <NUM_LIT:50> , debug = DEBUG , run_mode = '<STR_LIT>' ) <EOL> if len ( sys . argv ) > <NUM_LIT:1> : <EOL> path = '<STR_LIT>' <EOL> if len ( sys . argv ) > <NUM_LIT:2> : <EOL> path = os . path . expanduser ( sys . argv [ <NUM_LIT:2> ] ) <EOL> path = os . path . join ( os . getcwd ( ) , path ) <EOL> exp . set_out_path_and_name ( path , sys . argv [ <NUM_LIT:1> ] ) <EOL> exp . run ( ) <EOL> exp . print_result_table ( ) <EOL> WIDTH = <NUM_LIT> <EOL> SHIFT = <NUM_LIT> <EOL> sound_modality = exp . modalities . index ( '<STR_LIT>' ) <EOL> objects_modality = exp . modalities . index ( '<STR_LIT>' ) <EOL> test_idx = exp . logger . get_last_value ( '<STR_LIT:test>' ) <EOL> test_labels = [ exp . labels [ t ] for t in test_idx ] <EOL> assoc_idx = exp . logger . get_value ( '<STR_LIT>' ) <EOL> if DEBUG : <EOL> test_idx = test_idx [ : <NUM_LIT:10> ] <EOL> test_labels = test_labels [ : <NUM_LIT:10> ] <EOL> assoc_idx = assoc_idx [ : <NUM_LIT:10> ] <EOL> sound_loader = exp . loaders [ sound_modality ] <EOL> test_wavs = [ sound_loader . records [ i [ sound_modality ] ] . get_audio_path ( ) <EOL> for i in assoc_idx ] <EOL> print ( '<STR_LIT>' ) <EOL> test_sound_wins = concat_from_list_of_wavs ( test_wavs ) <EOL> test_sound_idx_wins = ConcatTimeWindow ( [ <EOL> BasicTimeWindow ( w . absolute_start , w . absolute_end , obj = i [ sound_modality ] ) <EOL>", "answer": "for i , w in zip ( assoc_idx , test_sound_wins . windows )"}, {"prompt": "<s> from django import forms <EOL> from etc . entities import create_handle <EOL> from entity_items . models import ContentItem <EOL> from org . models import Org , OrgIssueRelationship <EOL> from issue . models import Issue <EOL> from users . models import Location <EOL> from django . contrib . admin . widgets import FilteredSelectMultiple <EOL> from django . core . exceptions import ValidationError <EOL> from utils . widgets import MultipleLocationWidget , LocationWidget <EOL> import json <EOL> class OrgForm ( forms . ModelForm ) : <EOL> class Meta : <EOL> model = Org <EOL> widgets = { <EOL> '<STR_LIT:location>' : LocationWidget ( ) , <EOL> '<STR_LIT>' : MultipleLocationWidget ( ) , <EOL> '<STR_LIT>' : forms . TextInput ( attrs = { '<STR_LIT>' : <NUM_LIT> } ) , <EOL> '<STR_LIT>' : forms . TextInput ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:email>' : forms . TextInput ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : forms . TextInput ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : forms . TextInput ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : forms . TextInput ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : forms . TextInput ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : forms . TextInput ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : forms . Textarea ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> } <EOL> class Media : <EOL> css = { <EOL> '<STR_LIT:all>' : [ '<STR_LIT>' , ] <EOL> } <EOL> js = [ '<STR_LIT>' , ] <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( OrgForm , self ) . __init__ ( * args , ** kwargs ) <EOL> if '<STR_LIT>' in self . fields : <EOL> self . fields [ '<STR_LIT>' ] . help_text = '<STR_LIT>' <EOL> if '<STR_LIT>' in self . fields : <EOL> self . fields [ '<STR_LIT>' ] . widget = FilteredSelectMultiple ( '<STR_LIT>' , False ) <EOL> self . fields [ '<STR_LIT>' ] . queryset = Issue . objects . order_by ( '<STR_LIT:name>' ) <EOL> self . fields [ '<STR_LIT>' ] . help_text = '<STR_LIT>' <EOL> def save ( self , commit = True ) : <EOL> instance = super ( OrgForm , self ) . save ( commit = False ) <EOL> if '<STR_LIT>' in self . fields : <EOL> old_issues = instance . issues . all ( ) <EOL> new_issues = self . cleaned_data [ '<STR_LIT>' ] <EOL> to_delete = set ( old_issues ) - set ( new_issues ) <EOL> to_create = set ( new_issues ) - set ( old_issues ) <EOL> OrgIssueRelationship . objects . filter ( org = instance , issue__in = to_delete ) . delete ( ) <EOL> for issue in to_create : <EOL> relationship = OrgIssueRelationship ( org = instance , issue = issue ) <EOL> try : <EOL> relationship . full_clean ( ) <EOL> relationship . save ( ) <EOL> except ValidationError , e : <EOL> pass <EOL> del ( self . cleaned_data [ '<STR_LIT>' ] ) <EOL> if commit : <EOL> instance . save ( ) <EOL> self . save_m2m ( ) <EOL> return instance <EOL> class ManageOrgForm ( OrgForm ) : <EOL> mission = forms . CharField ( label = \"<STR_LIT>\" , widget = forms . Textarea ) <EOL> class Meta ( OrgForm . Meta ) : <EOL> fields = [ '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:location>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ManageOrgForm , self ) . __init__ ( * args , ** kwargs ) <EOL> try : <EOL> content_item = self . instance . content . center ( ) . mission_statement ( ) <EOL> self . fields [ '<STR_LIT>' ] . initial = content_item . rich_text_body <EOL> except ContentItem . DoesNotExist : <EOL> pass <EOL> def save ( self , commit = True ) : <EOL> instance = super ( ManageOrgForm , self ) . save ( False ) <EOL> try : <EOL> content_item = instance . content . center ( ) . mission_statement ( ) <EOL> except ContentItem . DoesNotExist : <EOL>", "answer": "content_item = ContentItem ( entity = instance , section = ContentItem . ContentSection . CENTER , title = ContentItem . MISSION_STATEMENT )"}, {"prompt": "<s> from axelrod import Actions , Player <EOL> C , D = Actions . C , Actions . D <EOL> class MindController ( Player ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = '<STR_LIT>' <EOL> classifier = { <EOL> '<STR_LIT>' : - <NUM_LIT:10> , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : set ( ) , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : False <EOL> } <EOL> @ staticmethod <EOL> def strategy ( opponent ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> opponent . strategy = lambda opponent : C <EOL> return D <EOL> class MindWarper ( Player ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = '<STR_LIT>' <EOL> classifier = { <EOL> '<STR_LIT>' : - <NUM_LIT:10> , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : set ( ) , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : False <EOL>", "answer": "}"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from py4j . java_gateway import JavaGateway <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL> gateway = JavaGateway ( ) <EOL> buffer = gateway . getStringBuffer ( ) <EOL> buffer . append ( True ) <EOL>", "answer": "buffer . append ( <NUM_LIT:1.0> )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . . phonemetadata import NumberFormat , PhoneNumberDesc , PhoneMetadata <EOL> PHONE_METADATA_JE = PhoneMetadata ( id = '<STR_LIT>' , country_code = None , international_prefix = None , <EOL> general_desc = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> toll_free = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> premium_rate = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) , <EOL> emergency = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' , example_number = '<STR_LIT>' ) , <EOL> short_code = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' , example_number = '<STR_LIT>' ) , <EOL>", "answer": "standard_rate = PhoneNumberDesc ( national_number_pattern = '<STR_LIT>' , possible_number_pattern = '<STR_LIT>' ) ,"}, {"prompt": "<s> import idaapi <EOL> import idc <EOL> from idaapi import Choose2 <EOL> def parse_pte ( str ) : <EOL> try : <EOL> parse_pte . re <EOL> except : <EOL>", "answer": "parse_pte . re = re . compile ( '<STR_LIT>' , re . I | re . M )"}, {"prompt": "<s> import logging <EOL> from time import sleep <EOL> from util import full_stack <EOL> from util import exec_remote_command <EOL> from util import build_context_script <EOL> from dbaas_cloudstack . models import HostAttr as CS_HostAttr <EOL> from workflow . steps . util . base import BaseStep <EOL> from workflow . exceptions . error_codes import DBAAS_0020 <EOL> from workflow . steps . util import test_bash_script_error <EOL> from workflow . steps . redis . util import build_start_stop_scripts <EOL> from workflow . steps . redis . util import build_start_database_script <EOL> from workflow . steps . redis . util import build_stop_database_script <EOL> from workflow . steps . redis . util import build_start_sentinel_script <EOL> from workflow . steps . redis . util import build_stop_sentinel_script <EOL> from workflow . steps . redis . util import build_start_http_script <EOL> from workflow . steps . redis . util import reset_sentinel <EOL> LOG = logging . getLogger ( __name__ ) <EOL> class StartDatabaseReplication ( BaseStep ) : <EOL> def __unicode__ ( self ) : <EOL> return \"<STR_LIT>\" <EOL> def do ( self , workflow_dict ) : <EOL> try : <EOL> databaseinfra = workflow_dict [ '<STR_LIT>' ] <EOL> driver = databaseinfra . get_driver ( ) <EOL> sentinel = driver . get_sentinel_client ( ) <EOL> master = sentinel . discover_master ( databaseinfra . name ) <EOL> master_host = master [ <NUM_LIT:0> ] <EOL> master_port = master [ <NUM_LIT:1> ] <EOL>", "answer": "for index , source_host in enumerate ( workflow_dict [ '<STR_LIT>' ] ) :"}, {"prompt": "<s> from __future__ import absolute_import , division <EOL> from behave . formatter . ansi_escapes import escapes , up <EOL> from behave . formatter . base import Formatter <EOL> from behave . model_describe import escape_cell , escape_triple_quotes <EOL> from behave . textutil import indent , text as _text <EOL> import sys <EOL> import six <EOL> from six . moves import range <EOL> from six . moves import zip <EOL> DEFAULT_WIDTH = <NUM_LIT> <EOL> DEFAULT_HEIGHT = <NUM_LIT> <EOL> def get_terminal_size ( ) : <EOL> if sys . platform == '<STR_LIT>' : <EOL> return ( DEFAULT_WIDTH , DEFAULT_HEIGHT ) <EOL> try : <EOL> import fcntl <EOL> import termios <EOL> import struct <EOL> zero_struct = struct . pack ( '<STR_LIT>' , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> result = fcntl . ioctl ( <NUM_LIT:0> , termios . TIOCGWINSZ , zero_struct ) <EOL> h , w , hp , wp = struct . unpack ( '<STR_LIT>' , result ) <EOL> return w or DEFAULT_WIDTH , h or DEFAULT_HEIGHT <EOL> except : <EOL> return ( DEFAULT_WIDTH , DEFAULT_HEIGHT ) <EOL> class MonochromeFormat ( object ) : <EOL> def text ( self , text ) : <EOL> assert isinstance ( text , six . text_type ) <EOL> return text <EOL> class ColorFormat ( object ) : <EOL> def __init__ ( self , status ) : <EOL> self . status = status <EOL> def text ( self , text ) : <EOL> assert isinstance ( text , six . text_type ) <EOL> return escapes [ self . status ] + text + escapes [ '<STR_LIT>' ] <EOL> class PrettyFormatter ( Formatter ) : <EOL> name = '<STR_LIT>' <EOL> description = '<STR_LIT>' <EOL> def __init__ ( self , stream_opener , config ) : <EOL> super ( PrettyFormatter , self ) . __init__ ( stream_opener , config ) <EOL> self . stream = self . open ( ) <EOL> isatty = getattr ( self . stream , \"<STR_LIT>\" , lambda : True ) <EOL> stream_supports_colors = isatty ( ) <EOL> self . monochrome = not config . color or not stream_supports_colors <EOL> self . show_source = config . show_source <EOL> self . show_timings = config . show_timings <EOL> self . show_multiline = config . show_multiline <EOL> self . formats = None <EOL> self . display_width = get_terminal_size ( ) [ <NUM_LIT:0> ] <EOL> self . steps = [ ] <EOL> self . _uri = None <EOL> self . _match = None <EOL> self . statement = None <EOL> self . indentations = [ ] <EOL> self . step_lines = <NUM_LIT:0> <EOL> def reset ( self ) : <EOL> self . steps = [ ] <EOL> self . _uri = None <EOL> self . _match = None <EOL> self . statement = None <EOL> self . indentations = [ ] <EOL> self . step_lines = <NUM_LIT:0> <EOL> def uri ( self , uri ) : <EOL> self . reset ( ) <EOL> self . _uri = uri <EOL> def feature ( self , feature ) : <EOL> self . print_tags ( feature . tags , '<STR_LIT>' ) <EOL> self . stream . write ( u\"<STR_LIT>\" % ( feature . keyword , feature . name ) ) <EOL> if self . show_source : <EOL> format = self . format ( '<STR_LIT>' ) <EOL> self . stream . write ( format . text ( u\"<STR_LIT>\" % feature . location ) ) <EOL> self . stream . write ( \"<STR_LIT:\\n>\" ) <EOL> self . print_description ( feature . description , '<STR_LIT:U+0020>' , False ) <EOL> self . stream . flush ( ) <EOL> def background ( self , background ) : <EOL> self . replay ( ) <EOL> self . statement = background <EOL> def scenario ( self , scenario ) : <EOL> self . replay ( ) <EOL> self . statement = scenario <EOL> def scenario_outline ( self , scenario_outline ) : <EOL> self . replay ( ) <EOL> self . statement = scenario_outline <EOL> def replay ( self ) : <EOL> self . print_statement ( ) <EOL> self . print_steps ( ) <EOL> self . stream . flush ( ) <EOL> def examples ( self , examples ) : <EOL> self . replay ( ) <EOL> self . stream . write ( \"<STR_LIT:\\n>\" ) <EOL> self . print_comments ( examples . comments , '<STR_LIT:U+0020>' ) <EOL> self . print_tags ( examples . tags , '<STR_LIT:U+0020>' ) <EOL> self . stream . write ( '<STR_LIT>' % ( examples . keyword , examples . name ) ) <EOL> self . print_description ( examples . description , '<STR_LIT:U+0020>' ) <EOL> self . table ( examples . rows ) <EOL> self . stream . flush ( ) <EOL> def step ( self , step ) : <EOL> self . steps . append ( step ) <EOL> def match ( self , match ) : <EOL> self . _match = match <EOL> self . print_statement ( ) <EOL> self . print_step ( '<STR_LIT>' , self . _match . arguments , <EOL> self . _match . location , self . monochrome ) <EOL> self . stream . flush ( ) <EOL> def result ( self , result ) : <EOL> if not self . monochrome : <EOL> lines = self . step_lines + <NUM_LIT:1> <EOL> if self . show_multiline : <EOL> if result . table : <EOL> lines += len ( result . table . rows ) + <NUM_LIT:1> <EOL> if result . text : <EOL> lines += len ( result . text . splitlines ( ) ) + <NUM_LIT:2> <EOL> self . stream . write ( up ( lines ) ) <EOL> arguments = [ ] <EOL> location = None <EOL> if self . _match : <EOL> arguments = self . _match . arguments <EOL> location = self . _match . location <EOL> self . print_step ( result . status , arguments , location , True ) <EOL> if result . error_message : <EOL> self . stream . write ( indent ( result . error_message . strip ( ) , u'<STR_LIT:U+0020>' ) ) <EOL> self . stream . write ( '<STR_LIT>' ) <EOL> self . stream . flush ( ) <EOL> def arg_format ( self , key ) : <EOL> return self . format ( key + '<STR_LIT>' ) <EOL> def format ( self , key ) : <EOL> if self . monochrome : <EOL>", "answer": "if self . formats is None :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import sys <EOL> import stat <EOL> import time <EOL> import fcntl <EOL> import socket <EOL> import fnmatch <EOL> import logging <EOL> import argparse <EOL> import tempfile <EOL> import Bcfg2 . Logger <EOL> import Bcfg2 . Options <EOL> from Bcfg2 . Client import XML <EOL> from Bcfg2 . Client import Proxy <EOL> from Bcfg2 . Client import Tools <EOL> from Bcfg2 . Utils import locked , Executor , safe_input <EOL> from Bcfg2 . version import __version__ <EOL> from Bcfg2 . Compat import xmlrpclib , walk_packages , any , all , cmp <EOL> def cmpent ( ent1 , ent2 ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ent1 . tag != ent2 . tag : <EOL> return cmp ( ent1 . tag , ent2 . tag ) <EOL> else : <EOL> return cmp ( ent1 . get ( '<STR_LIT:name>' ) , ent2 . get ( '<STR_LIT:name>' ) ) <EOL> def matches_entry ( entryspec , entry ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if entryspec == entry : <EOL> return True <EOL> return all ( fnmatch . fnmatch ( entry [ i ] , entryspec [ i ] ) for i in [ <NUM_LIT:0> , <NUM_LIT:1> ] ) <EOL> def matches_white_list ( entry , whitelist ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return any ( matches_entry ( we , ( entry . tag , entry . get ( '<STR_LIT:name>' ) ) ) <EOL> for we in whitelist ) <EOL> def passes_black_list ( entry , blacklist ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return not any ( matches_entry ( be , ( entry . tag , entry . get ( '<STR_LIT:name>' ) ) ) <EOL> for be in blacklist ) <EOL> def prompt ( msg ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> ans = safe_input ( msg ) <EOL> return ans in [ '<STR_LIT:y>' , '<STR_LIT:Y>' ] <EOL> except UnicodeEncodeError : <EOL> ans = input ( msg . encode ( '<STR_LIT:utf-8>' ) ) <EOL> return ans in [ '<STR_LIT:y>' , '<STR_LIT:Y>' ] <EOL> except ( EOFError , KeyboardInterrupt ) : <EOL> raise SystemExit ( <NUM_LIT:1> ) <EOL> except : <EOL> print ( \"<STR_LIT>\" % sys . exc_info ( ) [ <NUM_LIT:1> ] ) <EOL> return False <EOL> class ClientDriverAction ( Bcfg2 . Options . ComponentAction ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> bases = [ '<STR_LIT>' ] <EOL> fail_silently = True <EOL> class Client ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> options = Proxy . ComponentProxy . options + [ <EOL> Bcfg2 . Options . Common . syslog , <EOL> Bcfg2 . Options . Common . interactive , <EOL> Bcfg2 . Options . BooleanOption ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , help = \"<STR_LIT>\" ) , <EOL> Bcfg2 . Options . Option ( <EOL> cf = ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> type = Bcfg2 . Options . Types . timeout , <EOL> help = \"<STR_LIT>\" ) , <EOL> Bcfg2 . Options . Option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , default = [ ] , <EOL> type = Bcfg2 . Options . Types . colon_list , <EOL> help = '<STR_LIT>' ) , <EOL> Bcfg2 . Options . Option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , default = [ ] , <EOL> type = Bcfg2 . Options . Types . colon_list , <EOL> help = '<STR_LIT>' ) , <EOL> Bcfg2 . Options . ExclusiveOptionGroup ( <EOL> Bcfg2 . Options . BooleanOption ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> help = '<STR_LIT>' ) , <EOL> Bcfg2 . Options . Option ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> choices = [ '<STR_LIT:all>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> help = '<STR_LIT>' ) ) , <EOL> Bcfg2 . Options . ExclusiveOptionGroup ( <EOL> Bcfg2 . Options . PathOption ( <EOL> '<STR_LIT>' , '<STR_LIT>' , type = argparse . FileType ( '<STR_LIT:rb>' ) , <EOL> help = '<STR_LIT>' ) , <EOL> Bcfg2 . Options . PathOption ( <EOL> '<STR_LIT:-c>' , '<STR_LIT>' , type = argparse . FileType ( '<STR_LIT:wb>' ) , <EOL> help = '<STR_LIT>' ) ) , <EOL> Bcfg2 . Options . BooleanOption ( <EOL> '<STR_LIT>' , default = True , <EOL> cf = ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> help = \"<STR_LIT>\" ) , <EOL> Bcfg2 . Options . Option ( <EOL> '<STR_LIT>' , '<STR_LIT>' , cf = ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> help = '<STR_LIT>' ) , <EOL> Bcfg2 . Options . Option ( <EOL> '<STR_LIT>' , '<STR_LIT>' , cf = ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> choices = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:none>' ] , <EOL> help = '<STR_LIT>' ) , <EOL> Bcfg2 . Options . BooleanOption ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , help = '<STR_LIT>' ) , <EOL> Bcfg2 . Options . PathOption ( <EOL> cf = ( '<STR_LIT>' , '<STR_LIT>' ) , default = '<STR_LIT>' , <EOL> help = '<STR_LIT>' ) , <EOL> Bcfg2 . Options . BooleanOption ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , help = '<STR_LIT>' ) , <EOL> Bcfg2 . Options . Option ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , cf = ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> type = Bcfg2 . Options . Types . comma_list , <EOL> default = [ m [ <NUM_LIT:1> ] for m in walk_packages ( path = Tools . __path__ ) ] , <EOL> action = ClientDriverAction , help = '<STR_LIT>' ) , <EOL> Bcfg2 . Options . BooleanOption ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , help = '<STR_LIT>' ) , <EOL> Bcfg2 . Options . BooleanOption ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , help = '<STR_LIT>' ) , <EOL> Bcfg2 . Options . BooleanOption ( <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> help = '<STR_LIT>' ) ] <EOL> def __init__ ( self ) : <EOL> self . config = None <EOL> self . _proxy = None <EOL> self . logger = logging . getLogger ( '<STR_LIT>' ) <EOL> self . cmd = Executor ( Bcfg2 . Options . setup . probe_timeout ) <EOL> self . tools = [ ] <EOL> self . times = dict ( ) <EOL> self . times [ '<STR_LIT>' ] = time . time ( ) <EOL> if Bcfg2 . Options . setup . bundle_quick : <EOL> if ( not Bcfg2 . Options . setup . only_bundles and <EOL> not Bcfg2 . Options . setup . except_bundles ) : <EOL> self . logger . error ( \"<STR_LIT>\" ) <EOL> raise SystemExit ( <NUM_LIT:1> ) <EOL> if Bcfg2 . Options . setup . remove == '<STR_LIT>' : <EOL> self . logger . error ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> if not Bcfg2 . Options . setup . server . startswith ( '<STR_LIT>' ) : <EOL> Bcfg2 . Options . setup . server = '<STR_LIT>' + Bcfg2 . Options . setup . server <EOL> self . states = { } <EOL> self . whitelist = [ ] <EOL> self . blacklist = [ ] <EOL> self . removal = [ ] <EOL> self . unhandled = [ ] <EOL> self . logger = logging . getLogger ( __name__ ) <EOL> def _probe_failure ( self , probename , msg ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> message = \"<STR_LIT>\" % ( probename , msg ) <EOL> if Bcfg2 . Options . setup . exit_on_probe_failure : <EOL> self . fatal_error ( message ) <EOL> else : <EOL> self . logger . error ( message ) <EOL> def run_probe ( self , probe ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = probe . get ( '<STR_LIT:name>' ) <EOL> self . logger . info ( \"<STR_LIT>\" % name ) <EOL> ret = XML . Element ( \"<STR_LIT>\" , name = name , source = probe . get ( '<STR_LIT:source>' ) ) <EOL> try : <EOL> scripthandle , scriptname = tempfile . mkstemp ( ) <EOL> if sys . hexversion >= <NUM_LIT> : <EOL> script = os . fdopen ( scripthandle , '<STR_LIT:w>' , <EOL> encoding = Bcfg2 . Options . setup . encoding ) <EOL> else : <EOL> script = os . fdopen ( scripthandle , '<STR_LIT:w>' ) <EOL> try : <EOL> script . write ( \"<STR_LIT>\" % <EOL>", "answer": "( probe . attrib . get ( '<STR_LIT>' , '<STR_LIT>' ) ) )"}, {"prompt": "<s> from steamapiwrapper . GameItems import GameItems <EOL> from steamapiwrapper . Users import SteamUser <EOL> from steamapiwrapper . SteamGames import Games <EOL> from steamapiwrapper import SteamBase <EOL> import unittest <EOL> import json <EOL> from mock import Mock , patch <EOL> class MockUrllib2Resp : <EOL> def __init__ ( self , response ) : <EOL> self . response = response <EOL> def read ( self ) : <EOL> return self . response <EOL> class GameItemsTests ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> pass <EOL> class SteamBaseTests ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . api = SteamBase . SteamAPI ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . urllib2resp = MockUrllib2Resp ( '<STR_LIT>' ) <EOL> self . url = '<STR_LIT>' <EOL> self . url_params = '<STR_LIT>' <EOL> self . params = '<STR_LIT>' <EOL> @ patch . object ( SteamBase . SteamAPI , '<STR_LIT>' ) <EOL> def test_get_json_no_params ( self , mock_open ) : <EOL> mock_open . return_value = self . urllib2resp <EOL>", "answer": "self . api . _get_json ( self . url )"}, {"prompt": "<s> from urllib import urlencode <EOL> from django . utils import translation <EOL> from django . utils . translation import ugettext as _ <EOL> from django . utils . translation import pgettext <EOL> from twilio . rest import TwilioRestClient <EOL> from django . contrib . sites . models import Site <EOL> from django . core . urlresolvers import reverse <EOL> from corehq . messaging . smsbackends . twilio . models import SQLTwilioBackend <EOL> VOICE_LANGUAGES = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ,"}, {"prompt": "<s> import pytest <EOL> from keras . utils . test_utils import layer_test <EOL> from keras . layers import noise <EOL> def test_GaussianNoise ( ) : <EOL> layer_test ( noise . GaussianNoise , <EOL> kwargs = { '<STR_LIT>' : <NUM_LIT:1.> } , <EOL> input_shape = ( <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> def test_GaussianDropout ( ) : <EOL> layer_test ( noise . GaussianDropout , <EOL> kwargs = { '<STR_LIT:p>' : <NUM_LIT:0.5> } , <EOL>", "answer": "input_shape = ( <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> ) )"}, {"prompt": "<s> from armstrong . apps . articles . models import Article <EOL>", "answer": "from django . contrib . auth . models import User"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import ConfigParser <EOL> import datetime <EOL> import logging <EOL> import multiprocessing <EOL> import os . path <EOL> import pkg_resources <EOL> import Queue <EOL> import re <EOL> import socket <EOL> import sys <EOL> import threading <EOL> import time <EOL> import traceback <EOL> from openmdao . main import mp_distributing <EOL> from openmdao . main . mp_support import register <EOL> from openmdao . main . objserverfactory import ObjServerFactory <EOL> from openmdao . main . rbac import get_credentials , set_credentials , rbac <EOL> from openmdao . util . eggloader import check_requirements <EOL> from openmdao . util . wrkpool import WorkerPool <EOL> QUEUING_SYSTEM_KEYS = set ( ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT:args>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT:email>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) ) <EOL> JOB_CATEGORIES = set ( ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) ) <EOL> RESOURCE_LIMITS = set ( ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) ) <EOL> HOME_DIRECTORY = '<STR_LIT>' <EOL> WORKING_DIRECTORY = '<STR_LIT>' <EOL> _LEGAL_NAME = re . compile ( r'<STR_LIT>' ) <EOL> _IPV4_HOST = re . compile ( r'<STR_LIT>' ) <EOL> class ResourceAllocationManager ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _lock = threading . Lock ( ) <EOL> _lock_pid = os . getpid ( ) <EOL> _RAM = None <EOL> def __init__ ( self , config_filename = None ) : <EOL> self . _logger = logging . getLogger ( '<STR_LIT>' ) <EOL> self . _pid = os . getpid ( ) <EOL> self . _allocations = <NUM_LIT:0> <EOL> self . _allocators = [ ] <EOL> self . _deployed_servers = { } <EOL> self . _allocators . append ( LocalAllocator ( '<STR_LIT>' , <EOL> authkey = '<STR_LIT>' , <EOL> allow_shell = True ) ) <EOL> if config_filename is None : <EOL> config_filename = os . environ . get ( '<STR_LIT>' ) <EOL> if config_filename is not None : <EOL> if config_filename and not os . path . exists ( config_filename ) : <EOL> self . _logger . error ( '<STR_LIT>' , <EOL> config_filename ) <EOL> if config_filename is None : <EOL> config_filename = os . path . join ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> config_filename = os . path . expanduser ( config_filename ) <EOL> if not os . path . exists ( config_filename ) : <EOL> return <EOL> if config_filename : <EOL> self . _configure ( config_filename ) <EOL> @ staticmethod <EOL> def configure ( config_filename ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> orig = ResourceAllocationManager . _RAM <EOL> ram = ResourceAllocationManager . _get_instance ( config_filename ) <EOL> if ram is orig : <EOL> with ResourceAllocationManager . _lock : <EOL> ram . _configure ( config_filename ) <EOL> def _configure ( self , config_filename ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _logger . debug ( '<STR_LIT>' , config_filename ) <EOL> with open ( config_filename , '<STR_LIT:r>' ) as inp : <EOL> cfg = ConfigParser . ConfigParser ( ) <EOL> cfg . readfp ( inp ) <EOL> for name in cfg . sections ( ) : <EOL> self . _logger . debug ( '<STR_LIT>' , name ) <EOL> for allocator in self . _allocators : <EOL> if allocator . name == name : <EOL> self . _logger . debug ( '<STR_LIT>' ) <EOL> allocator . configure ( cfg ) <EOL> break <EOL> else : <EOL> if not cfg . has_option ( name , '<STR_LIT>' ) : <EOL> self . _logger . debug ( '<STR_LIT>' , name ) <EOL> continue <EOL> classname = cfg . get ( name , '<STR_LIT>' ) <EOL> self . _logger . debug ( '<STR_LIT>' , classname ) <EOL> mod_name , _ , cls_name = classname . rpartition ( '<STR_LIT:.>' ) <EOL> try : <EOL> __import__ ( mod_name ) <EOL> except ImportError as exc : <EOL> raise RuntimeError ( \"<STR_LIT>\" <EOL> % ( name , mod_name , exc ) ) <EOL> module = sys . modules [ mod_name ] <EOL> if not hasattr ( module , cls_name ) : <EOL> raise RuntimeError ( '<STR_LIT>' <EOL> % ( name , cls_name , mod_name ) ) <EOL> cls = getattr ( module , cls_name ) <EOL> allocator = cls ( name ) <EOL> allocator . configure ( cfg ) <EOL> self . _allocators . append ( allocator ) <EOL> @ staticmethod <EOL> def _get_instance ( config_filename = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ResourceAllocationManager . _lock_pid != os . getpid ( ) : <EOL> try : <EOL> ResourceAllocationManager . _lock . release ( ) <EOL> except threading . ThreadError : <EOL> pass <EOL> else : <EOL> logging . warning ( '<STR_LIT>' ) <EOL> ResourceAllocationManager . _lock_pid = os . getpid ( ) <EOL> with ResourceAllocationManager . _lock : <EOL> ram = ResourceAllocationManager . _RAM <EOL> if ram is None : <EOL> ram = ResourceAllocationManager . _RAM = ResourceAllocationManager ( config_filename ) <EOL> elif ram . _pid != os . getpid ( ) : <EOL> for allocator in ram . _allocators : <EOL> allocator . invalidate ( ) <EOL> ram = ResourceAllocationManager . _RAM = ResourceAllocationManager ( config_filename ) <EOL> return ram <EOL> @ staticmethod <EOL> def add_allocator ( allocator ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ram = ResourceAllocationManager . _get_instance ( ) <EOL> with ResourceAllocationManager . _lock : <EOL> name = allocator . name <EOL> for alloc in ram . _allocators : <EOL> if alloc . name == name : <EOL> raise RuntimeError ( '<STR_LIT>' % name ) <EOL> ram . _allocators . append ( allocator ) <EOL> @ staticmethod <EOL> def insert_allocator ( index , allocator ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ram = ResourceAllocationManager . _get_instance ( ) <EOL> with ResourceAllocationManager . _lock : <EOL> name = allocator . name <EOL> for alloc in ram . _allocators : <EOL> if alloc . name == name : <EOL> raise RuntimeError ( '<STR_LIT>' % name ) <EOL> ram . _allocators . insert ( index , allocator ) <EOL> @ staticmethod <EOL> def get_allocator ( selector ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ram = ResourceAllocationManager . _get_instance ( ) <EOL> with ResourceAllocationManager . _lock : <EOL> if isinstance ( selector , basestring ) : <EOL> for allocator in ram . _allocators : <EOL> if allocator . name == selector : <EOL> return allocator <EOL> raise ValueError ( '<STR_LIT>' % selector ) <EOL> else : <EOL> return ram . _allocators [ selector ] <EOL> @ staticmethod <EOL> def remove_allocator ( selector ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ram = ResourceAllocationManager . _get_instance ( ) <EOL> with ResourceAllocationManager . _lock : <EOL> if isinstance ( selector , basestring ) : <EOL> for i , allocator in enumerate ( ram . _allocators ) : <EOL> if allocator . name == selector : <EOL> return ram . _allocators . pop ( i ) <EOL> raise ValueError ( '<STR_LIT>' % selector ) <EOL> else : <EOL> return ram . _allocators . pop ( selector ) <EOL> @ staticmethod <EOL> def list_allocators ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ram = ResourceAllocationManager . _get_instance ( ) <EOL> with ResourceAllocationManager . _lock : <EOL> return ram . _allocators <EOL> @ staticmethod <EOL> def max_servers ( resource_desc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ResourceAllocationManager . validate_resources ( resource_desc ) <EOL> ram = ResourceAllocationManager . _get_instance ( ) <EOL> with ResourceAllocationManager . _lock : <EOL> return ram . _max_servers ( resource_desc ) <EOL> def _max_servers ( self , resource_desc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> total = <NUM_LIT:0> <EOL> for allocator in self . _allocators : <EOL> count , criteria = allocator . max_servers ( resource_desc ) <EOL> if count <= <NUM_LIT:0> : <EOL> keys = criteria . keys ( ) <EOL> if keys : <EOL> info = '<STR_LIT>' % ( keys [ <NUM_LIT:0> ] , criteria [ keys [ <NUM_LIT:0> ] ] ) <EOL> else : <EOL> info = '<STR_LIT>' <EOL> self . _logger . debug ( '<STR_LIT>' , allocator . name , info ) <EOL> else : <EOL> self . _logger . debug ( '<STR_LIT>' , allocator . _name , count ) <EOL> total += count <EOL> return total <EOL> @ staticmethod <EOL> def allocate ( resource_desc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ResourceAllocationManager . validate_resources ( resource_desc ) <EOL> ram = ResourceAllocationManager . _get_instance ( ) <EOL> with ResourceAllocationManager . _lock : <EOL> return ram . _allocate ( resource_desc ) <EOL> def _allocate ( self , resource_desc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> deployment_retries = <NUM_LIT:0> <EOL> best_estimate = - <NUM_LIT:1> <EOL> while best_estimate == - <NUM_LIT:1> : <EOL> best_estimate , best_criteria , best_allocator = self . _get_estimates ( resource_desc ) <EOL> if best_estimate >= <NUM_LIT:0> : <EOL> self . _allocations += <NUM_LIT:1> <EOL> name = '<STR_LIT>' % self . _allocations <EOL> self . _logger . debug ( '<STR_LIT>' , best_allocator . _name ) <EOL> server = best_allocator . deploy ( name , resource_desc , <EOL> best_criteria ) <EOL> if server is not None : <EOL> server_info = { <EOL> '<STR_LIT:name>' : name , <EOL> '<STR_LIT>' : server . pid , <EOL> '<STR_LIT:host>' : server . host <EOL> } <EOL> self . _logger . info ( '<STR_LIT>' , <EOL> name , server_info [ '<STR_LIT>' ] , <EOL> server_info [ '<STR_LIT:host>' ] ) <EOL> self . _deployed_servers [ id ( server ) ] = ( best_allocator , server , server_info ) <EOL> return ( server , server_info ) <EOL> else : <EOL> deployment_retries += <NUM_LIT:1> <EOL> if deployment_retries > <NUM_LIT:10> : <EOL> self . _logger . error ( '<STR_LIT>' ) <EOL> return ( None , None ) <EOL> self . _logger . warning ( '<STR_LIT>' ) <EOL> best_estimate = - <NUM_LIT:1> <EOL> elif best_estimate != - <NUM_LIT:1> : <EOL> return ( None , None ) <EOL> else : <EOL> time . sleep ( <NUM_LIT:1> ) <EOL> @ staticmethod <EOL> def get_hostnames ( resource_desc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ResourceAllocationManager . validate_resources ( resource_desc ) <EOL> ram = ResourceAllocationManager . _get_instance ( ) <EOL> with ResourceAllocationManager . _lock : <EOL> return ram . _get_hostnames ( resource_desc ) <EOL> def _get_hostnames ( self , resource_desc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> best_score = - <NUM_LIT:1> <EOL> while best_score == - <NUM_LIT:1> : <EOL> best_score , best_criteria , best_allocator = self . _get_estimates ( resource_desc , need_hostnames = True ) <EOL> if best_score >= <NUM_LIT:0> : <EOL> self . _logger . debug ( '<STR_LIT>' , best_criteria [ '<STR_LIT>' ] ) <EOL> return best_criteria [ '<STR_LIT>' ] <EOL> elif best_score != - <NUM_LIT:1> : <EOL> return None <EOL> else : <EOL> time . sleep ( <NUM_LIT:1> ) <EOL> def _get_estimates ( self , resource_desc , need_hostnames = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> best_estimate = - <NUM_LIT:2> <EOL> best_criteria = None <EOL> best_allocator = None <EOL> for allocator in self . _allocators : <EOL> estimate , criteria = allocator . time_estimate ( resource_desc ) <EOL> if estimate == - <NUM_LIT:2> : <EOL> key = criteria . keys ( ) [ <NUM_LIT:0> ] <EOL> info = criteria [ key ] <EOL> self . _logger . debug ( '<STR_LIT>' , <EOL> allocator . name , key , info ) <EOL> else : <EOL> msg = '<STR_LIT:OK>' if estimate == <NUM_LIT:0> else '<STR_LIT>' % estimate <EOL> self . _logger . debug ( '<STR_LIT>' , allocator . name , msg ) <EOL> if ( best_estimate == - <NUM_LIT:2> and estimate >= - <NUM_LIT:1> ) or ( best_estimate == <NUM_LIT:0> and estimate > <NUM_LIT:0> ) or ( best_estimate > <NUM_LIT:0> and estimate < best_estimate ) : <EOL> if estimate >= <NUM_LIT:0> and need_hostnames and not '<STR_LIT>' in criteria : <EOL> self . _logger . debug ( \"<STR_LIT>\" , <EOL> allocator . name ) <EOL> else : <EOL> best_estimate = estimate <EOL> best_criteria = criteria <EOL> best_allocator = allocator <EOL> return ( best_estimate , best_criteria , best_allocator ) <EOL> @ staticmethod <EOL> def release ( server ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ram = ResourceAllocationManager . _get_instance ( ) <EOL> return ram . _release ( server ) <EOL> def _release ( self , server ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with ResourceAllocationManager . _lock : <EOL> try : <EOL> allocator , server , server_info = self . _deployed_servers [ id ( server ) ] <EOL> except KeyError : <EOL> self . _logger . error ( '<STR_LIT>' , server ) <EOL> return <EOL> del self . _deployed_servers [ id ( server ) ] <EOL> self . _logger . info ( '<STR_LIT>' , server_info [ '<STR_LIT:name>' ] , <EOL> server_info [ '<STR_LIT>' ] , server_info [ '<STR_LIT:host>' ] ) <EOL> try : <EOL> allocator . release ( server ) <EOL> except Exception as exc : <EOL> self . _logger . error ( \"<STR_LIT>\" , server_info [ '<STR_LIT:name>' ] , exc ) <EOL> server . _close . cancel ( ) <EOL> @ staticmethod <EOL> def add_remotes ( server , prefix = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> remote_ram = server . get_ram ( ) <EOL> total = remote_ram . get_total_allocators ( ) <EOL> if not prefix : <EOL> prefix = ResourceAllocationManager . _make_prefix ( server . host ) <EOL> proxies = [ ] <EOL> for i in range ( total ) : <EOL> allocator = remote_ram . get_allocator_proxy ( i ) <EOL> proxy = RemoteAllocator ( '<STR_LIT>' % ( prefix , allocator . name ) , <EOL> allocator ) <EOL> proxies . append ( proxy ) <EOL> ram = ResourceAllocationManager . _get_instance ( ) <EOL> with ResourceAllocationManager . _lock : <EOL> ram . _allocators . extend ( proxies ) <EOL> @ staticmethod <EOL> def _make_prefix ( hostid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if _IPV4_HOST . match ( hostid ) : <EOL> prefix = hostid . replace ( '<STR_LIT:.>' , '<STR_LIT>' ) <EOL> else : <EOL> prefix , _ , rest = hostid . partition ( '<STR_LIT:.>' ) <EOL> prefix = prefix . replace ( '<STR_LIT:->' , '<STR_LIT>' ) <EOL> return prefix <EOL> @ rbac ( '<STR_LIT:*>' ) <EOL> def get_total_allocators ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return len ( self . _allocators ) <EOL> @ rbac ( '<STR_LIT:*>' , proxy_types = [ object ] ) <EOL> def get_allocator_proxy ( self , index ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _allocators [ index ] <EOL> @ staticmethod <EOL> def max_request ( assembly ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> req = { } <EOL> for path , obj in assembly . items ( recurse = True ) : <EOL> prefix , _ , name = path . rpartition ( '<STR_LIT:.>' ) <EOL> if name == '<STR_LIT>' and isinstance ( obj , dict ) : <EOL> req = ResourceAllocationManager . _max_request ( req , obj ) <EOL> return req <EOL> @ staticmethod <EOL> def _max_request ( base , new ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> req = base . copy ( ) <EOL> for item in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if item in new : <EOL> req [ item ] = max ( req . get ( item , <NUM_LIT:0> ) , new [ item ] ) <EOL> if req . get ( '<STR_LIT>' , <NUM_LIT:0> ) > req . get ( '<STR_LIT>' , <NUM_LIT:0> ) : <EOL> req [ '<STR_LIT>' ] = req [ '<STR_LIT>' ] <EOL> if '<STR_LIT>' in new : <EOL> new_limits = new [ '<STR_LIT>' ] <EOL> req_limits = base . get ( '<STR_LIT>' , { } ) . copy ( ) <EOL> for item in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if item in new_limits : <EOL> req_limits [ item ] = max ( req_limits . get ( item , <NUM_LIT:0> ) , <EOL> new_limits [ item ] ) <EOL> req [ '<STR_LIT>' ] = req_limits <EOL> return req <EOL> @ staticmethod <EOL> def total_request ( assembly ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> req = { } <EOL> for path , obj in assembly . items ( recurse = True ) : <EOL> prefix , _ , name = path . rpartition ( '<STR_LIT:.>' ) <EOL> if name == '<STR_LIT>' and isinstance ( obj , dict ) : <EOL> req = ResourceAllocationManager . _total_request ( req , obj ) <EOL> return req <EOL> @ staticmethod <EOL> def _total_request ( base , new ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> req = ResourceAllocationManager . _max_request ( base , new ) <EOL> if '<STR_LIT>' in new : <EOL> req [ '<STR_LIT>' ] = base . get ( '<STR_LIT>' , True ) and new [ '<STR_LIT>' ] <EOL> for item in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:localhost>' ) : <EOL> if item in new : <EOL> if item in base : <EOL> if new [ item ] != base [ item ] : <EOL> raise ValueError ( '<STR_LIT>' <EOL> % ( item , new [ item ] , base [ item ] ) ) <EOL> else : <EOL> req [ item ] = new [ item ] <EOL> if '<STR_LIT>' in new : <EOL> req_limits = req [ '<STR_LIT>' ] <EOL> new_limits = new [ '<STR_LIT>' ] <EOL> base_limits = base . get ( '<STR_LIT>' , { } ) <EOL> for item in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if item in new_limits : <EOL> req_limits [ item ] = base_limits . get ( item , <NUM_LIT:0> ) + new_limits [ item ] <EOL> req [ '<STR_LIT>' ] = req_limits <EOL> return req <EOL> @ staticmethod <EOL> def validate_resources ( resource_desc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for key , value in resource_desc . items ( ) : <EOL> try : <EOL> if not _VALIDATORS [ key ] ( value ) : <EOL> raise ValueError ( '<STR_LIT>' <EOL> % ( key , value ) ) <EOL> except KeyError : <EOL> raise KeyError ( '<STR_LIT>' % key ) <EOL> if '<STR_LIT>' in resource_desc : <EOL> if '<STR_LIT>' not in resource_desc : <EOL> raise KeyError ( '<STR_LIT>' ) <EOL> min_cpus = resource_desc [ '<STR_LIT>' ] <EOL> max_cpus = resource_desc [ '<STR_LIT>' ] <EOL> if max_cpus < min_cpus : <EOL> raise ValueError ( '<STR_LIT>' <EOL> % ( max_cpus , min_cpus ) ) <EOL> def _true ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return True <EOL> def _bool ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return isinstance ( value , bool ) <EOL> def _datetime ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return isinstance ( value , datetime . datetime ) <EOL> def _int ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return isinstance ( value , int ) <EOL> def _positive ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return isinstance ( value , int ) and value > <NUM_LIT:0> <EOL> def _string ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return isinstance ( value , basestring ) <EOL> def _no_whitespace ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return isinstance ( value , basestring ) and len ( value . split ( '<STR_LIT>' ) ) == <NUM_LIT:1> <EOL> def _stringlist ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( value , ( list , tuple ) ) : <EOL> return False <EOL> for item in value : <EOL> if not isinstance ( item , basestring ) : <EOL> return False <EOL> return True <EOL> def _allocator ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for allocator in ResourceAllocationManager . list_allocators ( ) : <EOL> if allocator . name == value : <EOL> return True <EOL> return False <EOL> def _job_environment ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( value , dict ) : <EOL> return False <EOL> for key , val in value . items ( ) : <EOL> if not isinstance ( key , basestring ) or len ( key . split ( ) ) > <NUM_LIT:1> : <EOL> return False <EOL> if not isinstance ( val , basestring ) : <EOL> return False <EOL> return True <EOL> def _job_category ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return value in JOB_CATEGORIES <EOL> def _resource_limits ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( value , dict ) : <EOL> return False <EOL> for key , val in value . items ( ) : <EOL> if key not in RESOURCE_LIMITS : <EOL> return False <EOL> if not isinstance ( val , int ) : <EOL> return False <EOL> if val < <NUM_LIT:0> : <EOL> return False <EOL> return True <EOL> _VALIDATORS = { '<STR_LIT>' : _allocator , <EOL> '<STR_LIT:localhost>' : _bool , <EOL> '<STR_LIT>' : _stringlist , <EOL> '<STR_LIT>' : _true , <EOL> '<STR_LIT>' : _stringlist , <EOL> '<STR_LIT>' : _true , <EOL> '<STR_LIT>' : _true , <EOL> '<STR_LIT>' : _positive , <EOL> '<STR_LIT>' : _positive , <EOL> '<STR_LIT>' : _positive , <EOL> '<STR_LIT>' : _no_whitespace , <EOL> '<STR_LIT:args>' : _stringlist , <EOL> '<STR_LIT>' : _bool , <EOL> '<STR_LIT>' : _bool , <EOL> '<STR_LIT>' : _job_environment , <EOL> '<STR_LIT>' : _string , <EOL> '<STR_LIT>' : _job_category , <EOL> '<STR_LIT:email>' : _stringlist , <EOL> '<STR_LIT>' : _bool , <EOL> '<STR_LIT>' : _bool , <EOL> '<STR_LIT>' : _string , <EOL> '<STR_LIT>' : _string , <EOL> '<STR_LIT>' : _string , <EOL> '<STR_LIT>' : _string , <EOL> '<STR_LIT>' : _bool , <EOL> '<STR_LIT>' : _no_whitespace , <EOL> '<STR_LIT>' : _no_whitespace , <EOL> '<STR_LIT>' : _int , <EOL> '<STR_LIT>' : _datetime , <EOL> '<STR_LIT>' : _datetime , <EOL> '<STR_LIT>' : _resource_limits , <EOL> '<STR_LIT>' : _no_whitespace , <EOL> '<STR_LIT>' : _stringlist } <EOL> class ResourceAllocator ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , name ) : <EOL> match = _LEGAL_NAME . match ( name ) <EOL> if match is None : <EOL> raise NameError ( '<STR_LIT>' % name ) <EOL> self . _name = name <EOL> self . _logger = logging . getLogger ( name ) <EOL> @ property <EOL> def name ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _name <EOL> def invalidate ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return <EOL> def configure ( self , cfg ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return <EOL> def max_servers ( self , resource_desc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( '<STR_LIT>' ) <EOL> def time_estimate ( self , resource_desc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( '<STR_LIT>' ) <EOL> def check_compatibility ( self , resource_desc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> keys = [ ] <EOL> for key , value in resource_desc . items ( ) : <EOL> if key in QUEUING_SYSTEM_KEYS : <EOL> pass <EOL> elif key == '<STR_LIT>' : <EOL> missing = self . check_required_distributions ( value ) <EOL> if missing : <EOL> return ( - <NUM_LIT:2> , { key : '<STR_LIT>' % missing } ) <EOL> elif key == '<STR_LIT>' : <EOL> missing = self . check_orphan_modules ( value ) <EOL> if missing : <EOL> return ( - <NUM_LIT:2> , { key : '<STR_LIT>' % missing } ) <EOL> elif key == '<STR_LIT>' : <EOL> req_ver = float ( value ) <EOL> sys_ver = float ( sys . version [ : <NUM_LIT:3> ] ) <EOL> if int ( sys_ver ) != int ( req_ver ) or sys_ver < req_ver : <EOL> return ( - <NUM_LIT:2> , { key : '<STR_LIT>' % ( req_ver , sys_ver ) } ) <EOL> elif key == '<STR_LIT>' : <EOL> if socket . gethostname ( ) in value : <EOL> return ( - <NUM_LIT:2> , { key : '<STR_LIT>' % socket . gethostname ( ) } ) <EOL> elif key == '<STR_LIT>' : <EOL> if self . name != value : <EOL> return ( - <NUM_LIT:2> , { key : '<STR_LIT>' } ) <EOL> else : <EOL> keys . append ( key ) <EOL> return ( <NUM_LIT:0> , keys ) <EOL> def check_required_distributions ( self , resource_value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> required = [ ] <EOL> for item in resource_value : <EOL> if isinstance ( item , pkg_resources . Distribution ) : <EOL> required . append ( item . as_requirement ( ) ) <EOL> else : <EOL> required . append ( item ) <EOL> return check_requirements ( sorted ( required ) ) <EOL> def check_orphan_modules ( self , resource_value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> not_found = [ ] <EOL> for module in sorted ( resource_value ) : <EOL> if module : <EOL> try : <EOL> __import__ ( module ) <EOL> except ImportError : <EOL> not_found . append ( module ) <EOL> return not_found <EOL> def deploy ( self , name , resource_desc , criteria ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( '<STR_LIT>' ) <EOL> def release ( self , server ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( '<STR_LIT>' ) <EOL> class FactoryAllocator ( ResourceAllocator ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , name , authkey = None , allow_shell = False ) : <EOL> super ( FactoryAllocator , self ) . __init__ ( name ) <EOL> self . _deployed_servers = [ ] <EOL> if authkey is None : <EOL> authkey = multiprocessing . current_process ( ) . authkey <EOL> if authkey is None : <EOL> authkey = '<STR_LIT>' <EOL> multiprocessing . current_process ( ) . authkey = authkey <EOL> self . factory = ObjServerFactory ( name , authkey , allow_shell ) <EOL> def configure ( self , cfg ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if cfg . has_option ( self . name , '<STR_LIT>' ) : <EOL> value = cfg . get ( self . name , '<STR_LIT>' ) <EOL> self . _logger . debug ( '<STR_LIT>' , value ) <EOL> self . factory . _authkey = value <EOL> if cfg . has_option ( self . name , '<STR_LIT>' ) : <EOL> value = cfg . getboolean ( self . name , '<STR_LIT>' ) <EOL> self . _logger . debug ( '<STR_LIT>' , value ) <EOL> self . factory . _allow_shell = value <EOL> @ rbac ( '<STR_LIT:*>' ) <EOL> def deploy ( self , name , resource_desc , criteria ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> credentials = get_credentials ( ) <EOL> allowed_users = { credentials . user : credentials . public_key } <EOL>", "answer": "try :"}, {"prompt": "<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from builtins import range <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> import sys <EOL> PYTHON_VERSION = sys . version_info [ : <NUM_LIT:3> ] <EOL> PY2 = ( PYTHON_VERSION [ <NUM_LIT:0> ] == <NUM_LIT:2> ) <EOL> if PY2 : <EOL> if PYTHON_VERSION < ( <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:9> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> elif PYTHON_VERSION < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> import hpOneView as hpov <EOL> from pprint import pprint <EOL> def acceptEULA ( con ) : <EOL> con . get_eula_status ( ) <EOL> try : <EOL> if con . get_eula_status ( ) is True : <EOL> print ( \"<STR_LIT>\" ) <EOL> con . set_eula ( '<STR_LIT>' ) <EOL> except Exception as e : <EOL> print ( '<STR_LIT>' ) <EOL> print ( e ) <EOL> def login ( con , credential ) : <EOL> try : <EOL> con . login ( credential ) <EOL> except : <EOL> print ( '<STR_LIT>' ) <EOL> def geturi ( con , uri ) : <EOL> resource = con . get_by_uri ( uri ) <EOL> pprint ( resource ) <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( add_help = True , <EOL> formatter_class = argparse . RawTextHelpFormatter , <EOL> description = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:host>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:user>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL>", "answer": "parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __license__ = \"<STR_LIT>\" <EOL> import datetime <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> EASTER_JULIAN = <NUM_LIT:1> <EOL> EASTER_ORTHODOX = <NUM_LIT:2> <EOL> EASTER_WESTERN = <NUM_LIT:3> <EOL> def easter ( year , method = EASTER_WESTERN ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not ( <NUM_LIT:1> <= method <= <NUM_LIT:3> ) : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> y = year <EOL> g = y % <NUM_LIT> <EOL> e = <NUM_LIT:0> <EOL> if method < <NUM_LIT:3> : <EOL> i = ( <NUM_LIT> * g + <NUM_LIT:15> ) % <NUM_LIT:30> <EOL> j = ( y + y // <NUM_LIT:4> + i ) % <NUM_LIT:7> <EOL> if method == <NUM_LIT:2> : <EOL> e = <NUM_LIT:10> <EOL> if y > <NUM_LIT> : <EOL> e = e + y // <NUM_LIT:100> - <NUM_LIT:16> - ( y // <NUM_LIT:100> - <NUM_LIT:16> ) // <NUM_LIT:4> <EOL> else : <EOL> c = y // <NUM_LIT:100> <EOL>", "answer": "h = ( c - c // <NUM_LIT:4> - ( <NUM_LIT:8> * c + <NUM_LIT> ) // <NUM_LIT> + <NUM_LIT> * g + <NUM_LIT:15> ) % <NUM_LIT:30>"}, {"prompt": "<s> from django . forms import TextInput , fields <EOL> from oscar . core import validators <EOL> class ExtendedURLField ( fields . URLField ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> default_validators = [ ] <EOL> widget = TextInput <EOL> def __init__ ( self , max_length = None , min_length = None , verify_exists = None , <EOL> * args , ** kwargs ) : <EOL>", "answer": "super ( fields . URLField , self ) . __init__ ("}, {"prompt": "<s> from rx import Observable , AnonymousObservable <EOL>", "answer": "from rx . disposables import CompositeDisposable"}, {"prompt": "<s> import sys , os , xmpp , time <EOL> if len ( sys . argv ) < <NUM_LIT:2> : <EOL> print \"<STR_LIT>\" <EOL> sys . exit ( <NUM_LIT:0> ) <EOL> tojid = sys . argv [ <NUM_LIT:1> ] <EOL> text = '<STR_LIT:U+0020>' . join ( sys . argv [ <NUM_LIT:2> : ] ) <EOL> jidparams = { } <EOL> if os . access ( os . environ [ '<STR_LIT>' ] + '<STR_LIT>' , os . R_OK ) : <EOL> for ln in open ( os . environ [ '<STR_LIT>' ] + '<STR_LIT>' ) . readlines ( ) : <EOL> if not ln [ <NUM_LIT:0> ] in ( '<STR_LIT:#>' , '<STR_LIT:;>' ) : <EOL> key , val = ln . strip ( ) . split ( '<STR_LIT:=>' , <NUM_LIT:1> ) <EOL> jidparams [ key . lower ( ) ] = val <EOL> for mandatory in [ '<STR_LIT>' , '<STR_LIT:password>' ] : <EOL>", "answer": "if mandatory not in jidparams . keys ( ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from sympy import var , sqrt , integrate , conjugate , seterr , Abs , pprint , I , pi , sin , cos , sign , lambdify , Integral , S <EOL>", "answer": "x = var ( \"<STR_LIT:x>\" , real = True )"}, {"prompt": "<s> import os <EOL> import sys <EOL>", "answer": "if \"<STR_LIT>\" in sys . argv :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> DATE_FORMAT = r'<STR_LIT>' <EOL> TIME_FORMAT = '<STR_LIT>' <EOL> DATETIME_FORMAT = r'<STR_LIT>' <EOL> YEAR_MONTH_FORMAT = r'<STR_LIT>' <EOL> MONTH_DAY_FORMAT = r'<STR_LIT>' <EOL> SHORT_DATE_FORMAT = '<STR_LIT>' <EOL> SHORT_DATETIME_FORMAT = '<STR_LIT>' <EOL> FIRST_DAY_OF_WEEK = <NUM_LIT:1> <EOL> DATE_INPUT_FORMATS = ( <EOL> '<STR_LIT>' , '<STR_LIT>' <EOL> ) <EOL> DATETIME_INPUT_FORMATS = ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) <EOL>", "answer": "DECIMAL_SEPARATOR = '<STR_LIT:U+002C>'"}, {"prompt": "<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> from collections import defaultdict <EOL> from pants . option . arg_splitter import GLOBAL_SCOPE <EOL> from pants . option . global_options import GlobalOptionsRegistrar <EOL> from pants . option . optionable import Optionable <EOL> from pants . option . parser_hierarchy import enclosing_scope <EOL> from pants . option . ranked_value import RankedValue <EOL> class _FakeOptionValues ( object ) : <EOL> def __init__ ( self , option_values ) : <EOL> self . _option_values = option_values <EOL> def __getitem__ ( self , key ) : <EOL> return getattr ( self , key ) <EOL> def get ( self , key , default = None ) : <EOL> if hasattr ( self , key ) : <EOL> return getattr ( self , key , default ) <EOL> return default <EOL> def __getattr__ ( self , key ) : <EOL> value = self . _option_values [ key ] <EOL> return value . value if isinstance ( value , RankedValue ) else value <EOL> def get_rank ( self , key ) : <EOL> value = self . _option_values [ key ] <EOL> return value . rank if isinstance ( value , RankedValue ) else RankedValue . FLAG <EOL>", "answer": "def is_flagged ( self , key ) :"}, {"prompt": "<s> from __future__ import absolute_import , unicode_literals <EOL> from django . conf import settings <EOL> import os <EOL> import sys <EOL> import unittest <EOL> APP_ROOT = os . path . realpath ( os . path . dirname ( __file__ ) + '<STR_LIT>' ) <EOL> sys . path . insert ( <NUM_LIT:0> , APP_ROOT ) <EOL> def load_tests ( loader , standard_tests , throwaway ) : <EOL> return loader . discover ( <EOL> start_dir = os . path . realpath ( os . path . dirname ( __file__ ) ) , <EOL> ) <EOL> settings . configure ( <EOL> ALLOWED_HOSTS = [ '<STR_LIT>' ] , <EOL> REST_FRAMEWORK = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": ") ,"}, {"prompt": "<s> from django import forms <EOL> from django . core . exceptions import NON_FIELD_ERRORS <EOL> class MonospaceForm ( forms . Form ) : <EOL> def addError ( self , message ) : <EOL> self . _errors [ NON_FIELD_ERRORS ] = self . error_class ( [ message ] ) <EOL> class SignInForm ( MonospaceForm ) : <EOL> email = forms . EmailField ( <EOL> required = True <EOL> ) <EOL> password = forms . CharField ( <EOL> required = True , <EOL> widget = forms . PasswordInput ( render_value = False ) <EOL> ) <EOL> class CardForm ( MonospaceForm ) : <EOL> last_4_digits = forms . CharField ( <EOL>", "answer": "required = True ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from security_monkey . watcher import Watcher <EOL> from security_monkey . watcher import ChangeItem <EOL> from security_monkey . constants import TROUBLE_REGIONS <EOL>", "answer": "from security_monkey . exceptions import BotoConnectionIssue"}, {"prompt": "<s> from django . dispatch import Signal <EOL>", "answer": "content_published = Signal ( providing_args = [ '<STR_LIT>' ] )"}, {"prompt": "<s> from django . core . handlers . base import BaseHandler <EOL> from django . core import signals <EOL> from django . dispatch import dispatcher <EOL> from django . utils import datastructures <EOL> from django import http <EOL> from pprint import pformat <EOL> import os <EOL> class ModPythonRequest ( http . HttpRequest ) : <EOL> def __init__ ( self , req ) : <EOL> self . _req = req <EOL> self . path = req . uri <EOL> def __repr__ ( self ) : <EOL> try : <EOL> get = pformat ( self . GET ) <EOL> except : <EOL> get = '<STR_LIT>' <EOL> try : <EOL> post = pformat ( self . POST ) <EOL> except : <EOL> post = '<STR_LIT>' <EOL> try : <EOL> cookies = pformat ( self . COOKIES ) <EOL> except : <EOL> cookies = '<STR_LIT>' <EOL> try : <EOL> meta = pformat ( self . META ) <EOL> except : <EOL> meta = '<STR_LIT>' <EOL> return '<STR_LIT>' % ( self . path , get , post , cookies , meta ) <EOL> def get_full_path ( self ) : <EOL> return '<STR_LIT>' % ( self . path , self . _req . args and ( '<STR_LIT:?>' + self . _req . args ) or '<STR_LIT>' ) <EOL> def is_secure ( self ) : <EOL> return self . _req . subprocess_env . has_key ( '<STR_LIT>' ) and self . _req . subprocess_env [ '<STR_LIT>' ] == '<STR_LIT>' <EOL> def _load_post_and_files ( self ) : <EOL> \"<STR_LIT>\" <EOL> if self . _req . headers_in . has_key ( '<STR_LIT>' ) and self . _req . headers_in [ '<STR_LIT>' ] . startswith ( '<STR_LIT>' ) : <EOL> self . _post , self . _files = http . parse_file_upload ( self . _req . headers_in , self . raw_post_data ) <EOL> else : <EOL> self . _post , self . _files = http . QueryDict ( self . raw_post_data ) , datastructures . MultiValueDict ( ) <EOL> def _get_request ( self ) : <EOL> if not hasattr ( self , '<STR_LIT>' ) : <EOL> self . _request = datastructures . MergeDict ( self . POST , self . GET ) <EOL> return self . _request <EOL> def _get_get ( self ) : <EOL>", "answer": "if not hasattr ( self , '<STR_LIT>' ) :"}, {"prompt": "<s> from eventlet import patcher <EOL> from eventlet . green import asyncore <EOL> from eventlet . green import socket <EOL>", "answer": "patcher . inject ("}, {"prompt": "<s> r'''<STR_LIT>''' <EOL> from __future__ import print_function <EOL> import sys <EOL> import inspect <EOL> import getopt <EOL> from os . path import basename <EOL> from werkzeug . _compat import iteritems <EOL> argument_types = { <EOL> bool : '<STR_LIT>' , <EOL> str : '<STR_LIT:string>' , <EOL> int : '<STR_LIT>' , <EOL> float : '<STR_LIT:float>' <EOL> } <EOL> converters = { <EOL> '<STR_LIT>' : lambda x : x . lower ( ) in ( '<STR_LIT:1>' , '<STR_LIT:true>' , '<STR_LIT:yes>' , '<STR_LIT>' ) , <EOL> '<STR_LIT:string>' : str , <EOL> '<STR_LIT>' : int , <EOL> '<STR_LIT:float>' : float <EOL> } <EOL> def run ( namespace = None , action_prefix = '<STR_LIT>' , args = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if namespace is None : <EOL> namespace = sys . _getframe ( <NUM_LIT:1> ) . f_locals <EOL> actions = find_actions ( namespace , action_prefix ) <EOL> if args is None : <EOL> args = sys . argv [ <NUM_LIT:1> : ] <EOL> if not args or args [ <NUM_LIT:0> ] in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> return print_usage ( actions ) <EOL> elif args [ <NUM_LIT:0> ] not in actions : <EOL> fail ( '<STR_LIT>' % args [ <NUM_LIT:0> ] ) <EOL> arguments = { } <EOL> types = { } <EOL> key_to_arg = { } <EOL> long_options = [ ] <EOL> formatstring = '<STR_LIT>' <EOL> func , doc , arg_def = actions [ args . pop ( <NUM_LIT:0> ) ] <EOL> for idx , ( arg , shortcut , default , option_type ) in enumerate ( arg_def ) : <EOL> real_arg = arg . replace ( '<STR_LIT:->' , '<STR_LIT:_>' ) <EOL> if shortcut : <EOL> formatstring += shortcut <EOL> if not isinstance ( default , bool ) : <EOL> formatstring += '<STR_LIT::>' <EOL> key_to_arg [ '<STR_LIT:->' + shortcut ] = real_arg <EOL> long_options . append ( isinstance ( default , bool ) and arg or arg + '<STR_LIT:=>' ) <EOL> key_to_arg [ '<STR_LIT>' + arg ] = real_arg <EOL> key_to_arg [ idx ] = real_arg <EOL>", "answer": "types [ real_arg ] = option_type"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . cryptomath import * <EOL> from . rsakey import * <EOL> from . python_rsakey import Python_RSAKey <EOL> def password_callback ( v , prompt1 = '<STR_LIT>' , <EOL> prompt2 = '<STR_LIT>' ) : <EOL> from getpass import getpass <EOL> while <NUM_LIT:1> : <EOL> try : <EOL> p1 = getpass ( prompt1 ) <EOL> if v : <EOL> p2 = getpass ( prompt2 ) <EOL> if p1 == p2 : <EOL> break <EOL> else : <EOL> break <EOL>", "answer": "except KeyboardInterrupt :"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> USAGE = \"\"\"<STR_LIT>\"\"\" <EOL> import sys , re , os , string , getopt <EOL> import alignlib <EOL> param_master = <NUM_LIT:0> <EOL> param_format = None <EOL> param_multiple_alignment = None <EOL> GAPCHARS = ( \"<STR_LIT:.>\" , \"<STR_LIT:->\" ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL>", "answer": "try :"}, {"prompt": "<s> import os <EOL> from collections import OrderedDict <EOL> import logbook <EOL> import pandas as pd <EOL> from pandas . io . data import DataReader <EOL> import pytz <EOL> from six import iteritems <EOL> from six . moves . urllib_error import HTTPError <EOL> from . benchmarks import get_benchmark_returns <EOL> from . import treasuries , treasuries_can <EOL> from . paths import ( <EOL> cache_root , <EOL> data_root , <EOL> ) <EOL> from zipline . utils . tradingcalendar import ( <EOL> trading_day as trading_day_nyse , <EOL> trading_days as trading_days_nyse , <EOL> ) <EOL> logger = logbook . Logger ( '<STR_LIT>' ) <EOL> INDEX_MAPPING = { <EOL> '<STR_LIT>' : <EOL> ( treasuries , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <EOL> ( treasuries_can , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <EOL> ( treasuries , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> } <EOL> ONE_HOUR = pd . Timedelta ( hours = <NUM_LIT:1> ) <EOL> def last_modified_time ( path ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return pd . Timestamp ( os . path . getmtime ( path ) , unit = '<STR_LIT:s>' , tz = '<STR_LIT>' ) <EOL> def get_data_filepath ( name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dr = data_root ( ) <EOL> if not os . path . exists ( dr ) : <EOL> os . makedirs ( dr ) <EOL> return os . path . join ( dr , name ) <EOL> def get_cache_filepath ( name ) : <EOL> cr = cache_root ( ) <EOL> if not os . path . exists ( cr ) : <EOL> os . makedirs ( cr ) <EOL> return os . path . join ( cr , name ) <EOL> def get_benchmark_filename ( symbol ) : <EOL> return \"<STR_LIT>\" % symbol <EOL> def has_data_for_dates ( series_or_df , first_date , last_date ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dts = series_or_df . index <EOL> if not isinstance ( dts , pd . DatetimeIndex ) : <EOL> raise TypeError ( \"<STR_LIT>\" % type ( dts ) ) <EOL> first , last = dts [ [ <NUM_LIT:0> , - <NUM_LIT:1> ] ] <EOL> return ( first <= first_date ) and ( last >= last_date ) <EOL> def load_market_data ( trading_day = trading_day_nyse , <EOL> trading_days = trading_days_nyse , <EOL> bm_symbol = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> first_date = trading_days [ <NUM_LIT:0> ] <EOL> now = pd . Timestamp . utcnow ( ) <EOL> last_date = trading_days [ trading_days . get_loc ( now , method = '<STR_LIT>' ) - <NUM_LIT:2> ] <EOL> br = ensure_benchmark_data ( <EOL> bm_symbol , <EOL> first_date , <EOL> last_date , <EOL> now , <EOL> trading_day , <EOL> ) <EOL> tc = ensure_treasury_data ( <EOL> bm_symbol , <EOL> first_date , <EOL> last_date , <EOL> now , <EOL> ) <EOL> benchmark_returns = br [ br . index . slice_indexer ( first_date , last_date ) ] <EOL> treasury_curves = tc [ tc . index . slice_indexer ( first_date , last_date ) ] <EOL> return benchmark_returns , treasury_curves <EOL> def ensure_benchmark_data ( symbol , first_date , last_date , now , trading_day ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = get_data_filepath ( get_benchmark_filename ( symbol ) ) <EOL> if os . path . exists ( path ) : <EOL> try : <EOL> data = pd . Series . from_csv ( path ) . tz_localize ( '<STR_LIT>' ) <EOL> if has_data_for_dates ( data , first_date , last_date ) : <EOL> return data <EOL> last_download_time = last_modified_time ( path ) <EOL> if ( now - last_download_time ) <= ONE_HOUR : <EOL> logger . warn ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % last_download_time <EOL> ) <EOL> return data <EOL> except ( OSError , IOError , ValueError ) as e : <EOL> logger . info ( <EOL> \"<STR_LIT>\" . format ( <EOL> path = path , error = e , <EOL> ) <EOL> ) <EOL> logger . info ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> start = first_date , <EOL> end = last_date , <EOL> symbol = symbol , <EOL> path = path , <EOL> ) <EOL> try : <EOL> data = get_benchmark_returns ( <EOL> symbol , <EOL> first_date - trading_day , <EOL> last_date , <EOL> ) <EOL> data . to_csv ( path ) <EOL> except ( OSError , IOError , HTTPError ) : <EOL> logger . exception ( '<STR_LIT>' ) <EOL> if not has_data_for_dates ( data , first_date , last_date ) : <EOL> logger . warn ( \"<STR_LIT>\" ) <EOL> return data <EOL> def ensure_treasury_data ( bm_symbol , first_date , last_date , now ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> loader_module , filename , source = INDEX_MAPPING . get ( <EOL> bm_symbol , INDEX_MAPPING [ '<STR_LIT>' ] <EOL> ) <EOL> first_date = max ( first_date , loader_module . earliest_possible_date ( ) ) <EOL> path = get_data_filepath ( filename ) <EOL>", "answer": "if os . path . exists ( path ) :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> import re <EOL> from django . core . validators import EMPTY_VALUES <EOL> from django . forms import ValidationError <EOL> from django . forms . fields import CharField , Field , RegexField , Select <EOL> from django . utils . encoding import force_text <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from . tr_provinces import PROVINCE_CHOICES <EOL> phone_digits_re = re . compile ( r'<STR_LIT>' ) <EOL> class TRPostalCodeField ( RegexField ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> default_error_messages = { <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> } <EOL> def __init__ ( self , max_length = <NUM_LIT:5> , min_length = <NUM_LIT:5> , * args , ** kwargs ) : <EOL> super ( TRPostalCodeField , self ) . __init__ ( r'<STR_LIT>' , <EOL> max_length , min_length , * args , ** kwargs ) <EOL> def clean ( self , value ) : <EOL> value = super ( TRPostalCodeField , self ) . clean ( value ) <EOL> if value in EMPTY_VALUES : <EOL> return '<STR_LIT>' <EOL> if len ( value ) != <NUM_LIT:5> : <EOL> raise ValidationError ( self . error_messages [ '<STR_LIT>' ] ) <EOL> province_code = int ( value [ : <NUM_LIT:2> ] ) <EOL> if province_code == <NUM_LIT:0> or province_code > <NUM_LIT> : <EOL> raise ValidationError ( self . error_messages [ '<STR_LIT>' ] ) <EOL> return value <EOL> class TRPhoneNumberField ( CharField ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> default_error_messages = { <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> } <EOL> def clean ( self , value ) : <EOL> super ( TRPhoneNumberField , self ) . clean ( value ) <EOL>", "answer": "if value in EMPTY_VALUES :"}, {"prompt": "<s> from muntjac . demo . sampler . ExampleUtil import ExampleUtil <EOL> from muntjac . api import VerticalLayout , ComboBox <EOL> from muntjac . data . property import IValueChangeListener <EOL> from muntjac . ui . abstract_select import AbstractSelect , IFiltering <EOL> class ComboBoxStartsWithExample ( VerticalLayout , IValueChangeListener ) : <EOL> def __init__ ( self ) : <EOL> super ( ComboBoxStartsWithExample , self ) . __init__ ( ) <EOL> self . setSpacing ( True ) <EOL> l = ComboBox ( '<STR_LIT>' , <EOL> ExampleUtil . getISO3166Container ( ) ) <EOL> l . setItemCaptionPropertyId ( ExampleUtil . iso3166_PROPERTY_NAME ) <EOL> l . setItemCaptionMode ( AbstractSelect . ITEM_CAPTION_MODE_PROPERTY ) <EOL> l . setItemIconPropertyId ( ExampleUtil . iso3166_PROPERTY_FLAG ) <EOL> l . setWidth ( <NUM_LIT> , self . UNITS_PIXELS ) <EOL> l . setFilteringMode ( IFiltering . FILTERINGMODE_STARTSWITH ) <EOL> l . setImmediate ( True ) <EOL> l . addListener ( self , IValueChangeListener ) <EOL> l . setNullSelectionAllowed ( False ) <EOL> self . addComponent ( l ) <EOL> def valueChange ( self , event ) : <EOL> selected = ExampleUtil . getISO3166Container ( ) . getContainerProperty ( <EOL> str ( event . getProperty ( ) ) , '<STR_LIT:name>' ) <EOL>", "answer": "self . getWindow ( ) . showNotification ( '<STR_LIT>' + str ( selected ) ) "}, {"prompt": "<s> from unittest import TestCase <EOL> from dateparser . conf import settings <EOL> class BaseTestCase ( TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( BaseTestCase , self ) . setUp ( ) <EOL> self . __patches = [ ] <EOL> self . error = NotImplemented <EOL> def add_patch ( self , patch ) : <EOL> patch . start ( ) <EOL> self . __patches . append ( patch ) <EOL> def tearDown ( self ) : <EOL> super ( BaseTestCase , self ) . tearDown ( ) <EOL> for patch in reversed ( self . __patches ) : <EOL> patch . stop ( ) <EOL> def then_error_was_raised ( self , error_cls , allowed_substrings = ( ) ) : <EOL> self . assertIsInstance ( self . error , error_cls ) <EOL> self . assertTrue ( any ( mesg in str ( self . error ) for mesg in allowed_substrings ) , <EOL>", "answer": "\"<STR_LIT>\" % ("}, {"prompt": "<s> from dateutil . relativedelta import relativedelta <EOL> from django . utils import timezone <EOL> from django . test import TestCase <EOL> from timepiece import utils <EOL> from timepiece . management . commands import check_entries <EOL> from timepiece . entries . models import Entry <EOL> from . import factories <EOL> class CheckEntries ( TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( CheckEntries , self ) . setUp ( ) <EOL> self . user = factories . User ( ) <EOL> self . user2 = factories . User ( ) <EOL> self . superuser = factories . Superuser ( ) <EOL> self . project = factories . Project ( <EOL> type__enable_timetracking = True , status__enable_timetracking = True , <EOL> point_person = self . user ) <EOL> self . default_data = { <EOL> '<STR_LIT:user>' : self . user , <EOL> '<STR_LIT>' : self . project , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT:status>' : Entry . VERIFIED , <EOL> } <EOL> self . good_start = timezone . now ( ) - relativedelta ( days = <NUM_LIT:0> , hours = <NUM_LIT:8> ) <EOL> self . good_end = timezone . now ( ) - relativedelta ( days = <NUM_LIT:0> ) <EOL> self . bad_start = timezone . now ( ) - relativedelta ( days = <NUM_LIT:1> , hours = <NUM_LIT:8> ) <EOL> self . bad_end = timezone . now ( ) - relativedelta ( days = <NUM_LIT:1> ) <EOL> self . user . first_name = '<STR_LIT>' <EOL> self . user . last_name = '<STR_LIT>' <EOL> self . user . save ( ) <EOL> self . user2 . first_name = '<STR_LIT>' <EOL> self . user2 . last_name = '<STR_LIT>' <EOL> self . user2 . save ( ) <EOL> self . all_users = [ self . user , self . user2 , self . superuser ] <EOL> self . make_entry_bulk ( self . all_users , <NUM_LIT> ) <EOL> def make_entry ( self , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> valid = kwargs . get ( '<STR_LIT>' , True ) <EOL> if valid : <EOL> default_start = self . good_start <EOL> default_end = self . good_end <EOL> else : <EOL> default_start = self . bad_start <EOL> default_end = self . bad_end <EOL> user = kwargs . get ( '<STR_LIT:user>' , self . user ) <EOL> start = kwargs . get ( '<STR_LIT>' , default_start ) <EOL> if '<STR_LIT>' in kwargs : <EOL> end = kwargs . get ( '<STR_LIT>' , default_end ) <EOL> else : <EOL> if '<STR_LIT>' in kwargs : <EOL> end = start + relativedelta ( minutes = <NUM_LIT:10> ) <EOL> else : <EOL> end = default_end <EOL> data = self . default_data <EOL> data . update ( { <EOL> '<STR_LIT:user>' : user , <EOL> '<STR_LIT>' : start , <EOL> '<STR_LIT>' : end , <EOL> } ) <EOL> factories . Entry ( ** data ) <EOL> def make_entry_bulk ( self , users , days , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for user in users : <EOL> self . default_data . update ( { '<STR_LIT:user>' : user } ) <EOL> for day in range ( <NUM_LIT:1> , days + <NUM_LIT:1> ) : <EOL> self . default_data . update ( { <EOL> '<STR_LIT>' : timezone . now ( ) - relativedelta ( days = day , minutes = <NUM_LIT:1> ) , <EOL> '<STR_LIT>' : timezone . now ( ) - relativedelta ( days = day , ) <EOL> } ) <EOL> factories . Entry ( ** self . default_data ) <EOL> def testFindStart ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> now = timezone . now ( ) <EOL> today = now - relativedelta ( <EOL> hour = <NUM_LIT:0> , minute = <NUM_LIT:0> , second = <NUM_LIT:0> , microsecond = <NUM_LIT:0> ) <EOL> last_billing = today - relativedelta ( months = <NUM_LIT:1> , day = <NUM_LIT:1> ) <EOL> yesterday = today - relativedelta ( days = <NUM_LIT:1> ) <EOL> ten_days_ago = today - relativedelta ( days = <NUM_LIT:10> ) <EOL> thisweek = utils . get_week_start ( today ) <EOL> thismonth = today - relativedelta ( day = <NUM_LIT:1> ) <EOL> thisyear = today - relativedelta ( month = <NUM_LIT:1> , day = <NUM_LIT:1> ) <EOL> start_default = check_entries . Command ( ) . find_start ( ) <EOL> start_yesterday = check_entries . Command ( ) . find_start ( days = <NUM_LIT:1> ) <EOL> start_ten_days_ago = check_entries . Command ( ) . find_start ( days = <NUM_LIT:10> ) <EOL> start_of_week = check_entries . Command ( ) . find_start ( week = True ) <EOL> start_of_month = check_entries . Command ( ) . find_start ( month = True ) <EOL> start_of_year = check_entries . Command ( ) . find_start ( year = True ) <EOL> self . assertEqual ( start_default , last_billing ) <EOL> self . assertEqual ( start_yesterday , yesterday ) <EOL> self . assertEqual ( start_ten_days_ago , ten_days_ago ) <EOL> self . assertEqual ( start_of_week , thisweek ) <EOL> self . assertEqual ( start_of_month , thismonth ) <EOL> self . assertEqual ( start_of_year , thisyear ) <EOL> def testFindUsers ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> users1 = check_entries . Command ( ) . find_users ( '<STR_LIT>' ) <EOL> users2 = check_entries . Command ( ) . find_users ( '<STR_LIT>' ) <EOL> all_users = check_entries . Command ( ) . find_users ( ) <EOL> user1 = users1 . get ( pk = self . user . pk ) <EOL> user2 = users2 . get ( pk = self . user2 . pk ) <EOL> all_1 = all_users . get ( pk = self . user . pk ) <EOL> all_2 = all_users . get ( pk = self . user2 . pk ) <EOL> all_3 = all_users . get ( pk = self . superuser . pk ) <EOL> self . assertEqual ( users1 . count ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( users2 . count ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( all_users . count ( ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( user1 , self . user ) <EOL> self . assertEqual ( user2 , self . user2 ) <EOL> self . assertEqual ( all_1 , user1 ) <EOL> self . assertEqual ( all_2 , user2 ) <EOL> self . assertEqual ( all_3 , self . superuser ) <EOL> def testFindEntries ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> start = check_entries . Command ( ) . find_start ( ) <EOL> if start . day == <NUM_LIT:1> : <EOL> start += relativedelta ( days = <NUM_LIT:1> ) <EOL> all_users = check_entries . Command ( ) . find_users ( ) <EOL> entries = check_entries . Command ( ) . find_entries ( all_users , start ) <EOL> today = timezone . now ( ) - relativedelta ( hour = <NUM_LIT:0> , minute = <NUM_LIT:0> , second = <NUM_LIT:0> , microsecond = <NUM_LIT:0> ) <EOL> diff = today - start <EOL> days_checked = diff . days <EOL> total_entries = <NUM_LIT:0> <EOL> while True : <EOL> try : <EOL> user_entries = next ( entries ) <EOL> for entry in user_entries : <EOL> total_entries += <NUM_LIT:1> <EOL> except StopIteration : <EOL> expected_total = days_checked * len ( self . all_users ) <EOL>", "answer": "self . assertEqual ( total_entries , expected_total )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> import os <EOL> import sys <EOL> import gslib <EOL> from gslib . exception import CommandException <EOL> from gslib . exception import NO_URLS_MATCHED_GENERIC <EOL> from gslib . exception import NO_URLS_MATCHED_TARGET <EOL> from gslib . plurality_checkable_iterator import PluralityCheckableIterator <EOL> import gslib . wildcard_iterator <EOL> from gslib . wildcard_iterator import StorageUrlFromString <EOL> class NameExpansionResult ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , source_storage_url , is_multi_source_request , <EOL> names_container , expanded_storage_url ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . source_storage_url = source_storage_url <EOL> self . is_multi_source_request = is_multi_source_request <EOL> self . names_container = names_container <EOL> self . expanded_storage_url = expanded_storage_url <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT:%s>' % self . expanded_storage_url <EOL> class _NameExpansionIterator ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , command_name , debug , logger , gsutil_api , url_strs , <EOL> recursion_requested , all_versions = False , <EOL> cmd_supports_recursion = True , project_id = None , <EOL> continue_on_error = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . command_name = command_name <EOL> self . debug = debug <EOL> self . logger = logger <EOL> self . gsutil_api = gsutil_api <EOL> self . url_strs = url_strs <EOL> self . recursion_requested = recursion_requested <EOL> self . all_versions = all_versions <EOL> self . url_strs . has_plurality = self . url_strs . HasPlurality ( ) <EOL> self . cmd_supports_recursion = cmd_supports_recursion <EOL> self . project_id = project_id <EOL> self . continue_on_error = continue_on_error <EOL> self . _flatness_wildcard = { True : '<STR_LIT>' , False : '<STR_LIT:*>' } <EOL> def __iter__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for url_str in self . url_strs : <EOL> storage_url = StorageUrlFromString ( url_str ) <EOL> if storage_url . IsFileUrl ( ) and storage_url . IsStream ( ) : <EOL> if self . url_strs . has_plurality : <EOL> raise CommandException ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> yield NameExpansionResult ( storage_url , False , False , storage_url ) <EOL> continue <EOL> src_names_bucket = False <EOL> if ( storage_url . IsCloudUrl ( ) and storage_url . IsBucket ( ) <EOL> and not self . recursion_requested ) : <EOL> post_step1_iter = PluralityCheckableIterator ( <EOL> self . WildcardIterator ( url_str ) . IterBuckets ( <EOL> bucket_fields = [ '<STR_LIT:id>' ] ) ) <EOL> else : <EOL> post_step1_iter = PluralityCheckableIterator ( <EOL> self . WildcardIterator ( url_str ) . IterAll ( <EOL> bucket_listing_fields = [ '<STR_LIT:name>' ] , <EOL> expand_top_level_buckets = True ) ) <EOL> if storage_url . IsCloudUrl ( ) and storage_url . IsBucket ( ) : <EOL> src_names_bucket = True <EOL> subdir_exp_wildcard = self . _flatness_wildcard [ self . recursion_requested ] <EOL> if self . recursion_requested : <EOL> post_step2_iter = _ImplicitBucketSubdirIterator ( <EOL> self , post_step1_iter , subdir_exp_wildcard ) <EOL> else : <EOL> post_step2_iter = _NonContainerTuplifyIterator ( post_step1_iter ) <EOL> post_step2_iter = PluralityCheckableIterator ( post_step2_iter ) <EOL> if post_step2_iter . IsEmpty ( ) : <EOL> if self . continue_on_error : <EOL> try : <EOL> raise CommandException ( NO_URLS_MATCHED_TARGET % url_str ) <EOL> except CommandException , e : <EOL> yield ( e , sys . exc_info ( ) [ <NUM_LIT:2> ] ) <EOL> else : <EOL> raise CommandException ( NO_URLS_MATCHED_TARGET % url_str ) <EOL> post_step3_iter = PluralityCheckableIterator ( _OmitNonRecursiveIterator ( <EOL> post_step2_iter , self . recursion_requested , self . command_name , <EOL> self . cmd_supports_recursion , self . logger ) ) <EOL> src_url_expands_to_multi = post_step3_iter . HasPlurality ( ) <EOL> is_multi_source_request = ( self . url_strs . has_plurality <EOL> or src_url_expands_to_multi ) <EOL> for ( names_container , blr ) in post_step3_iter : <EOL> src_names_container = src_names_bucket or names_container <EOL> if blr . IsObject ( ) : <EOL> yield NameExpansionResult ( <EOL> storage_url , is_multi_source_request , src_names_container , <EOL> blr . storage_url ) <EOL> else : <EOL> expanded_url = StorageUrlFromString ( blr . url_string ) <EOL> if expanded_url . IsFileUrl ( ) : <EOL> url_to_iterate = '<STR_LIT>' % ( blr , os . sep , subdir_exp_wildcard ) <EOL> else : <EOL> url_to_iterate = expanded_url . CreatePrefixUrl ( <EOL> wildcard_suffix = subdir_exp_wildcard ) <EOL> wc_iter = PluralityCheckableIterator ( <EOL> self . WildcardIterator ( url_to_iterate ) . IterObjects ( <EOL> bucket_listing_fields = [ '<STR_LIT:name>' ] ) ) <EOL> src_url_expands_to_multi = ( src_url_expands_to_multi <EOL> or wc_iter . HasPlurality ( ) ) <EOL> is_multi_source_request = ( self . url_strs . has_plurality <EOL> or src_url_expands_to_multi ) <EOL> for blr in wc_iter : <EOL> yield NameExpansionResult ( <EOL> storage_url , is_multi_source_request , True , blr . storage_url ) <EOL> def WildcardIterator ( self , url_string ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return gslib . wildcard_iterator . CreateWildcardIterator ( <EOL> url_string , self . gsutil_api , debug = self . debug , <EOL> all_versions = self . all_versions , <EOL> project_id = self . project_id ) <EOL> def NameExpansionIterator ( command_name , debug , logger , gsutil_api , url_strs , <EOL> recursion_requested , all_versions = False , <EOL> cmd_supports_recursion = True , project_id = None , <EOL> continue_on_error = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url_strs = PluralityCheckableIterator ( url_strs ) <EOL> name_expansion_iterator = _NameExpansionIterator ( <EOL> command_name , debug , logger , gsutil_api , url_strs , recursion_requested , <EOL> all_versions = all_versions , cmd_supports_recursion = cmd_supports_recursion , <EOL> project_id = project_id , continue_on_error = continue_on_error ) <EOL> name_expansion_iterator = PluralityCheckableIterator ( name_expansion_iterator ) <EOL> if name_expansion_iterator . IsEmpty ( ) : <EOL> raise CommandException ( NO_URLS_MATCHED_GENERIC ) <EOL> return name_expansion_iterator <EOL> class NameExpansionIteratorQueue ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , name_expansion_iterator , final_value ) : <EOL> self . name_expansion_iterator = name_expansion_iterator <EOL> self . final_value = final_value <EOL> self . lock = gslib . util . manager . Lock ( ) <EOL> def qsize ( self ) : <EOL> raise NotImplementedError ( <EOL> '<STR_LIT>' ) <EOL> def empty ( self ) : <EOL> raise NotImplementedError ( <EOL> '<STR_LIT>' ) <EOL> def full ( self ) : <EOL> raise NotImplementedError ( <EOL> '<STR_LIT>' ) <EOL> def put ( self , obj = None , block = None , timeout = None ) : <EOL> raise NotImplementedError ( <EOL> '<STR_LIT>' ) <EOL> def put_nowait ( self , obj ) : <EOL> raise NotImplementedError ( <EOL> '<STR_LIT>' ) <EOL> def get ( self , block = None , timeout = None ) : <EOL> self . lock . acquire ( ) <EOL>", "answer": "try :"}, {"prompt": "<s> import os <EOL> import sys <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL>", "answer": "os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "<s> from helpers import unittest <EOL> from luigi . tools . range import most_common <EOL> class MostCommonTest ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . runs = [ <EOL> ( [ <NUM_LIT:1> ] , ( <NUM_LIT:1> , <NUM_LIT:1> ) ) , <EOL> ( [ <NUM_LIT:1> , <NUM_LIT:1> ] , ( <NUM_LIT:1> , <NUM_LIT:2> ) ) , <EOL> ( [ <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:2> ] , ( <NUM_LIT:1> , <NUM_LIT:2> ) ) , <EOL>", "answer": "( [ <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> ] , ( <NUM_LIT:2> , <NUM_LIT:3> ) )"}, {"prompt": "<s> import wee_slack <EOL> import pytest <EOL> import json <EOL> from collections import defaultdict <EOL> def test_process_message ( slack_debug , monkeypatch , myservers , mychannels , myusers ) : <EOL> called = defaultdict ( int ) <EOL> wee_slack . servers = myservers <EOL> wee_slack . channels = mychannels <EOL> wee_slack . users = myusers <EOL> wee_slack . message_cache = { } <EOL> wee_slack . servers [ <NUM_LIT:0> ] . users = myusers <EOL> wee_slack . unfurl_ignore_alt_text = False <EOL> def mock_buffer_prnt ( * args ) : <EOL> called [ '<STR_LIT>' ] += <NUM_LIT:1> <EOL> monkeypatch . setattr ( wee_slack . Channel , '<STR_LIT>' , mock_buffer_prnt ) <EOL> messages = [ ] <EOL> messages . append ( json . loads ( open ( '<STR_LIT>' , '<STR_LIT:r>' ) . read ( ) ) ) <EOL> messages . append ( json . loads ( open ( '<STR_LIT>' , '<STR_LIT:r>' ) . read ( ) ) ) <EOL> messages . append ( json . loads ( open ( '<STR_LIT>' , '<STR_LIT:r>' ) . read ( ) ) ) <EOL> messages . append ( json . loads ( open ( '<STR_LIT>' , '<STR_LIT:r>' ) . read ( ) ) ) <EOL> for m in messages : <EOL> wee_slack . process_message ( m ) <EOL>", "answer": "print \"<STR_LIT>\""}, {"prompt": "<s> from unittest import TestCase <EOL> import gevent <EOL> from gevent . queue import Queue <EOL> import gevent . server <EOL> import mock <EOL> import json <EOL> import gzip <EOL> import os <EOL> import random <EOL> import struct <EOL> import time <EOL> from datetime import datetime <EOL> import cPickle as pickle <EOL> import zmq . green as zmq <EOL> import urllib2 <EOL> from logcabin . event import Event <EOL> from logcabin . context import DummyContext <EOL> from logcabin . outputs import elasticsearch , file as fileoutput , graphite , log , mongodb , perf , s3 , zeromq <EOL> from testhelper import TempDirectory , assertEventEquals , ANY <EOL> class OutputTests ( TestCase ) : <EOL> def create ( self , conf = { } ) : <EOL> with DummyContext ( ) : <EOL> self . i = i = self . cls ( ** conf ) <EOL> self . output = Queue ( ) <EOL> self . input = i . setup ( self . output ) <EOL> i . start ( ) <EOL> return i <EOL> def waitForEmpty ( self , timeout = <NUM_LIT:1.0> ) : <EOL> with gevent . Timeout ( timeout ) : <EOL> while self . input . qsize ( ) : <EOL> gevent . sleep ( ) <EOL> def tearDown ( self ) : <EOL> self . i . stop ( ) <EOL> class LogTests ( OutputTests ) : <EOL> cls = log . Log <EOL> def test_log ( self ) : <EOL> self . create ( ) <EOL> self . input . put ( Event ( field = '<STR_LIT:x>' ) ) <EOL> self . waitForEmpty ( ) <EOL> self . assertEquals ( <NUM_LIT:0> , self . input . qsize ( ) ) <EOL> class ElasticsearchTests ( OutputTests ) : <EOL> cls = elasticsearch . Elasticsearch <EOL> def test_log ( self ) : <EOL> with mock . patch ( '<STR_LIT>' ) as urlopen_mock : <EOL> urlopen_mock . return_value . read . return_value = json . dumps ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : <NUM_LIT:1> , '<STR_LIT>' : '<STR_LIT:test>' } ) <EOL> i = self . create ( { '<STR_LIT:index>' : '<STR_LIT:test>' , '<STR_LIT:type>' : '<STR_LIT>' } ) <EOL> self . input . put ( Event ( field = '<STR_LIT:x>' ) ) <EOL> self . waitForEmpty ( ) <EOL> i . stop ( ) <EOL> urlopen_mock . assert_called_once_with ( '<STR_LIT>' , data = ANY ) <EOL>", "answer": "def test_400_bad_request ( self ) :"}, {"prompt": "<s> import math <EOL> from metrology . exceptions import ArgumentException <EOL> class Snapshot ( object ) : <EOL> MEDIAN_Q = <NUM_LIT:0.5> <EOL> P75_Q = <NUM_LIT> <EOL> P95_Q = <NUM_LIT> <EOL> P98_Q = <NUM_LIT> <EOL> P99_Q = <NUM_LIT> <EOL> P999_Q = <NUM_LIT> <EOL> def __init__ ( self , values ) : <EOL> self . values = sorted ( values ) <EOL> def value ( self , quantile ) : <EOL> if <NUM_LIT:0.0> > quantile > <NUM_LIT:1.0> : <EOL> raise ArgumentException ( \"<STR_LIT>\" ) <EOL> if not self . values : <EOL> return <NUM_LIT:0.0> <EOL> pos = quantile * ( len ( self . values ) + <NUM_LIT:1> ) <EOL> if pos < <NUM_LIT:1> : <EOL> return self . values [ <NUM_LIT:0> ] <EOL> if pos >= len ( self . values ) : <EOL>", "answer": "return self . values [ - <NUM_LIT:1> ]"}, {"prompt": "<s> from distutils . core import setup <EOL> setup ( name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL>", "answer": "author_email = '<STR_LIT>' ,"}, {"prompt": "<s> import math <EOL> import numpy <EOL> from ginga . misc import Callback <EOL> from ginga import ColorDist <EOL> class RGBMapError ( Exception ) : <EOL> pass <EOL> class RGBPlanes ( object ) : <EOL> def __init__ ( self , rgbarr , order ) : <EOL> self . rgbarr = rgbarr <EOL> order = order . upper ( ) <EOL> self . order = order <EOL> self . hasAlpha = '<STR_LIT:A>' in order <EOL> def get_slice ( self , ch ) : <EOL> return self . rgbarr [ ... , self . order . index ( ch . upper ( ) ) ] <EOL> def has_slice ( self , ch ) : <EOL> return ch . upper ( ) in self . order <EOL> def get_order ( self ) : <EOL> return self . order <EOL> def get_order_indexes ( self , cs ) : <EOL> cs = cs . upper ( ) <EOL> return [ self . order . index ( c ) for c in cs ] <EOL> def get_array ( self , order ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> order = order . upper ( ) <EOL> if order == self . order : <EOL> return self . rgbarr <EOL> l = [ self . get_slice ( c ) for c in order ] <EOL> return numpy . dstack ( l ) <EOL> def get_size ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . get_slice ( '<STR_LIT:R>' ) . shape <EOL> class RGBMapper ( Callback . Callbacks ) : <EOL> def __init__ ( self , logger , dist = None ) : <EOL> Callback . Callbacks . __init__ ( self ) <EOL> self . logger = logger <EOL> self . cmap = None <EOL> self . imap = None <EOL> self . arr = None <EOL> self . iarr = None <EOL> self . carr = None <EOL> self . sarr = None <EOL> self . scale_pct = <NUM_LIT:1.0> <EOL> hashsize = <NUM_LIT> <EOL> if dist is None : <EOL> dist = ColorDist . LinearDist ( hashsize ) <EOL> self . dist = dist <EOL> for name in ( '<STR_LIT>' , ) : <EOL> self . enable_callback ( name ) <EOL> def set_cmap ( self , cmap , callback = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . cmap = cmap <EOL> self . calc_cmap ( ) <EOL> self . recalc ( callback = callback ) <EOL> def get_cmap ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . cmap <EOL> def calc_cmap ( self ) : <EOL> clst = self . cmap . clst <EOL> arr = numpy . array ( clst ) . transpose ( ) * <NUM_LIT> <EOL> self . carr = numpy . round ( arr ) . astype ( '<STR_LIT>' ) <EOL> def get_rgb ( self , index ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return tuple ( self . arr [ index ] ) <EOL> def get_rgbval ( self , index ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert ( index >= <NUM_LIT:0> ) and ( index < <NUM_LIT> ) , RGBMapError ( \"<STR_LIT>\" ) <EOL> index = self . sarr [ index ] . clip ( <NUM_LIT:0> , <NUM_LIT:255> ) <EOL> return ( self . arr [ <NUM_LIT:0> ] [ index ] , <EOL> self . arr [ <NUM_LIT:1> ] [ index ] , <EOL> self . arr [ <NUM_LIT:2> ] [ index ] ) <EOL> def set_imap ( self , imap , callback = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . imap = imap <EOL> self . calc_imap ( ) <EOL> self . recalc ( callback = callback ) <EOL> def get_imap ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . imap <EOL> def calc_imap ( self ) : <EOL> arr = numpy . array ( self . imap . ilst ) * <NUM_LIT> <EOL> self . iarr = numpy . round ( arr ) . astype ( '<STR_LIT>' ) <EOL> def reset_sarr ( self , callback = True ) : <EOL> self . sarr = numpy . arange ( <NUM_LIT> ) <EOL> self . scale_pct = <NUM_LIT:1.0> <EOL> if callback : <EOL> self . make_callback ( '<STR_LIT>' ) <EOL> def set_sarr ( self , sarr , callback = True ) : <EOL> assert len ( sarr ) == <NUM_LIT> , RGBMapError ( \"<STR_LIT>\" % ( len ( sarr ) ) ) <EOL> self . sarr = sarr . astype ( '<STR_LIT>' ) <EOL> self . scale_pct = <NUM_LIT:1.0> <EOL> if callback : <EOL> self . make_callback ( '<STR_LIT>' ) <EOL> def get_sarr ( self ) : <EOL> return self . sarr <EOL> def recalc ( self , callback = True ) : <EOL> self . arr = numpy . copy ( self . carr ) <EOL> if self . iarr is not None : <EOL> idx = self . iarr <EOL> self . arr [ <NUM_LIT:0> ] = self . arr [ <NUM_LIT:0> ] [ idx ] <EOL> self . arr [ <NUM_LIT:1> ] = self . arr [ <NUM_LIT:1> ] [ idx ] <EOL> self . arr [ <NUM_LIT:2> ] = self . arr [ <NUM_LIT:2> ] [ idx ] <EOL> self . reset_sarr ( callback = callback ) <EOL> def get_hash_size ( self ) : <EOL> return self . dist . get_hash_size ( ) <EOL> def set_hash_size ( self , size , callback = True ) : <EOL> self . dist . set_hash_size ( size ) <EOL> if callback : <EOL> self . make_callback ( '<STR_LIT>' ) <EOL> def get_hash_algorithms ( self ) : <EOL> return ColorDist . get_dist_names ( ) <EOL> def get_hash_algorithm ( self ) : <EOL> return str ( self . dist ) <EOL> def get_dist ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . dist <EOL> def set_dist ( self , dist , callback = True ) : <EOL> self . dist = dist <EOL> if callback : <EOL> self . make_callback ( '<STR_LIT>' ) <EOL> def set_hash_algorithm ( self , name , callback = True , ** kwdargs ) : <EOL> hashsize = self . dist . get_hash_size ( ) <EOL> dist = ColorDist . get_dist ( name ) ( hashsize , ** kwdargs ) <EOL> self . set_dist ( dist , callback = callback ) <EOL> def get_order_indexes ( self , order , cs ) : <EOL> order = order . upper ( ) <EOL> if order == '<STR_LIT>' : <EOL> return [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> ] <EOL> cs = cs . upper ( ) <EOL> return [ order . index ( c ) for c in cs ] <EOL> def _get_rgbarray ( self , idx , rgbobj , image_order ) : <EOL> idx . clip ( <NUM_LIT:0> , <NUM_LIT:255> , out = idx ) <EOL> idx = self . sarr [ idx ] <EOL> idx . clip ( <NUM_LIT:0> , <NUM_LIT:255> , out = idx ) <EOL> ri , gi , bi = self . get_order_indexes ( rgbobj . get_order ( ) , '<STR_LIT>' ) <EOL> out = rgbobj . rgbarr <EOL> if len ( idx . shape ) == <NUM_LIT:2> : <EOL> out [ ... , ri ] = self . arr [ <NUM_LIT:0> ] [ idx ] <EOL> out [ ... , gi ] = self . arr [ <NUM_LIT:1> ] [ idx ] <EOL> out [ ... , bi ] = self . arr [ <NUM_LIT:2> ] [ idx ] <EOL> else : <EOL> rj , gj , bj = self . get_order_indexes ( image_order , '<STR_LIT>' ) <EOL> out [ ... , ri ] = self . arr [ <NUM_LIT:0> ] [ idx [ ... , rj ] ] <EOL> out [ ... , gi ] = self . arr [ <NUM_LIT:1> ] [ idx [ ... , gj ] ] <EOL> out [ ... , bi ] = self . arr [ <NUM_LIT:2> ] [ idx [ ... , bj ] ] <EOL> def get_rgbarray ( self , idx , out = None , order = '<STR_LIT>' , image_order = '<STR_LIT>' ) : <EOL> shape = idx . shape <EOL> depth = len ( order ) <EOL> res_shape = ( shape [ <NUM_LIT:0> ] , shape [ <NUM_LIT:1> ] , depth ) <EOL> if out is None : <EOL> out = numpy . empty ( res_shape , dtype = numpy . uint8 , order = '<STR_LIT:C>' ) <EOL> else : <EOL> assert res_shape == out . shape , RGBMapError ( \"<STR_LIT>\" % ( <EOL> str ( out . shape ) , str ( res_shape ) ) ) <EOL> res = RGBPlanes ( out , order ) <EOL> if res . hasAlpha : <EOL> aa = res . get_slice ( '<STR_LIT:A>' ) <EOL> aa . fill ( <NUM_LIT:255> ) <EOL> idx = self . get_hasharray ( idx ) <EOL> self . _get_rgbarray ( idx , res , image_order ) <EOL> return res <EOL> def get_hasharray ( self , idx ) : <EOL> return self . dist . hash_array ( idx ) <EOL> def _shift ( self , sarr , pct , rotate = False ) : <EOL> n = len ( sarr ) <EOL> num = int ( n * pct ) <EOL> arr = numpy . roll ( sarr , num ) <EOL> if not rotate : <EOL> if num > <NUM_LIT:0> : <EOL> arr [ <NUM_LIT:0> : num ] = sarr [ <NUM_LIT:0> ] <EOL> elif num < <NUM_LIT:0> : <EOL> arr [ n + num : n ] = sarr [ - <NUM_LIT:1> ] <EOL> return arr <EOL> def _stretch ( self , sarr , scale ) : <EOL> old_wd = len ( sarr ) <EOL> new_wd = int ( round ( scale * old_wd ) ) <EOL> xi = numpy . mgrid [ <NUM_LIT:0> : new_wd ] <EOL> iscale_x = float ( old_wd ) / float ( new_wd ) <EOL> xi = ( xi * iscale_x ) . astype ( '<STR_LIT:int>' ) <EOL> xi = xi . clip ( <NUM_LIT:0> , old_wd - <NUM_LIT:1> ) <EOL> newdata = sarr [ xi ] <EOL> return newdata <EOL> def shift ( self , pct , rotate = False , callback = True ) : <EOL> work = self . _shift ( self . sarr , pct , rotate = rotate ) <EOL> assert len ( work ) == <NUM_LIT> , RGBMapError ( \"<STR_LIT>\" ) <EOL> self . sarr = work <EOL> if callback : <EOL> self . make_callback ( '<STR_LIT>' ) <EOL> def scale_and_shift ( self , scale_pct , shift_pct , callback = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . sarr = numpy . arange ( <NUM_LIT> ) <EOL> scale = max ( scale_pct , <NUM_LIT> ) <EOL> self . scale_pct = scale <EOL> work = self . _stretch ( self . sarr , scale ) <EOL> n = len ( work ) <EOL> if n < <NUM_LIT> : <EOL> m = ( <NUM_LIT> - n ) // <NUM_LIT:2> + <NUM_LIT:1> <EOL> barr = numpy . array ( [ <NUM_LIT:0> ] * m ) <EOL> tarr = numpy . array ( [ <NUM_LIT:255> ] * m ) <EOL> work = numpy . concatenate ( [ barr , work , tarr ] ) <EOL> work = work [ : <NUM_LIT> ] <EOL> n = len ( work ) // <NUM_LIT:2> <EOL> work = work [ n - <NUM_LIT> : n + <NUM_LIT> ] . astype ( '<STR_LIT>' ) <EOL> assert len ( work ) == <NUM_LIT> , RGBMapError ( \"<STR_LIT>\" ) <EOL> work = self . _shift ( work , shift_pct ) <EOL> assert len ( work ) == <NUM_LIT> , RGBMapError ( \"<STR_LIT>\" ) <EOL> self . sarr = work <EOL> if callback : <EOL> self . make_callback ( '<STR_LIT>' ) <EOL> def stretch ( self , scale_factor , callback = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . scale_pct *= scale_factor <EOL> self . scale_and_shift ( self . scale_pct , <NUM_LIT:0.0> , callback = callback ) <EOL>", "answer": "def copy_attributes ( self , dst_rgbmap ) :"}, {"prompt": "<s> import os <EOL> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> QtGui = GafferUI . _qtImport ( \"<STR_LIT>\" ) <EOL> class screengrab ( Gaffer . Application ) : <EOL> def __init__ ( self ) : <EOL> Gaffer . Application . __init__ ( self , \"<STR_LIT>\" ) <EOL> self . parameters ( ) . addParameters ( <EOL> [ <EOL> IECore . FileNameParameter ( <EOL> name = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> defaultValue = \"<STR_LIT>\" , <EOL> extensions = \"<STR_LIT>\" , <EOL> allowEmptyString = False , <EOL> check = IECore . FileNameParameter . CheckType . MustExist , <EOL> ) , <EOL> IECore . FileNameParameter ( <EOL> name = \"<STR_LIT:image>\" , <EOL> description = \"<STR_LIT>\" , <EOL> defaultValue = \"<STR_LIT>\" , <EOL> extensions = \"<STR_LIT>\" , <EOL> allowEmptyString = False , <EOL> ) , <EOL> IECore . StringParameter ( <EOL> name = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> defaultValue = \"<STR_LIT>\" , <EOL> ) , <EOL> IECore . StringParameter ( <EOL> name = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> defaultValue = \"<STR_LIT>\" , <EOL> ) , <EOL> IECore . StringParameter ( <EOL> name = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> defaultValue = \"<STR_LIT>\" , <EOL> ) , <EOL> ] <EOL> ) <EOL> self . parameters ( ) . userData ( ) [ \"<STR_LIT>\" ] = IECore . CompoundObject ( { <EOL> \"<STR_LIT>\" : IECore . StringVectorData ( [ \"<STR_LIT>\" ] ) <EOL> } ) <EOL> def setGrabWidget ( self , widget ) : <EOL> self . __grabWidget = widget <EOL> def getGrabWidget ( self ) : <EOL> return self . __grabWidget <EOL> def _run ( self , args ) : <EOL> self . _executeStartupFiles ( \"<STR_LIT>\" ) <EOL> GafferUI . ScriptWindow . connect ( self . root ( ) ) <EOL> script = Gaffer . ScriptNode ( ) <EOL> script [ \"<STR_LIT>\" ] . setValue ( os . path . abspath ( args [ \"<STR_LIT>\" ] . value ) ) <EOL> script . load ( ) <EOL> self . root ( ) [ \"<STR_LIT>\" ] . addChild ( script ) <EOL> scriptWindow = GafferUI . ScriptWindow . acquire ( script ) <EOL> self . setGrabWidget ( scriptWindow ) <EOL> if args [ \"<STR_LIT>\" ] . value : <EOL> editor = args [ \"<STR_LIT>\" ] . value <EOL> if \"<STR_LIT:.>\" not in editor : <EOL> editor = \"<STR_LIT>\" + editor <EOL> editorPartition = editor . rpartition ( \"<STR_LIT:.>\" ) <EOL> editor = getattr ( __import__ ( editorPartition [ <NUM_LIT:0> ] ) , editorPartition [ <NUM_LIT:2> ] ) <EOL> editors = scriptWindow . getLayout ( ) . editors ( editor ) <EOL> if not editors : <EOL> IECore . msg ( IECore . Msg . Level . Error , \"<STR_LIT>\" , \"<STR_LIT>\" % editor ) <EOL> return <NUM_LIT:1> <EOL> self . setGrabWidget ( editors [ <NUM_LIT:0> ] ) <EOL> self . __waitForIdle ( ) <EOL> for nodeGraph in scriptWindow . getLayout ( ) . editors ( GafferUI . NodeGraph ) : <EOL> nodeGraph . frame ( script . children ( Gaffer . Node ) ) <EOL> self . __waitForIdle ( ) <EOL> d = { <EOL> \"<STR_LIT>\" : self , <EOL> \"<STR_LIT>\" : script , <EOL> } <EOL> if args [ \"<STR_LIT>\" ] . value : <EOL> exec ( args [ \"<STR_LIT>\" ] . value , d , d ) <EOL> if args [ \"<STR_LIT>\" ] . value : <EOL> execfile ( args [ \"<STR_LIT>\" ] . value , d , d ) <EOL> self . __waitForIdle ( ) <EOL> imageDir = os . path . dirname ( args [ \"<STR_LIT:image>\" ] . value ) <EOL> if imageDir and not os . path . isdir ( imageDir ) : <EOL> IECore . msg ( IECore . Msg . Level . Info , \"<STR_LIT>\" , \"<STR_LIT>\" % imageDir ) <EOL> os . makedirs ( imageDir ) <EOL> pixmap = QtGui . QPixmap . grabWindow ( self . getGrabWidget ( ) . _qtWidget ( ) . winId ( ) ) <EOL> IECore . msg ( IECore . Msg . Level . Info , \"<STR_LIT>\" , \"<STR_LIT>\" % args [ \"<STR_LIT:image>\" ] . value ) <EOL> pixmap . save ( args [ \"<STR_LIT:image>\" ] . value ) <EOL> return <NUM_LIT:0> <EOL> def __waitForIdle ( self , count = <NUM_LIT:1000> ) : <EOL>", "answer": "self . __idleCount = <NUM_LIT:0>"}, {"prompt": "<s> from unittest import TestCase <EOL> from cms . test_utils . util . static_analysis import pyflakes <EOL> class AboveStaticAnalysisCodeTest ( TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def test_pyflakes ( self ) :"}, {"prompt": "<s> from libcloud . compute . types import Provider <EOL> from libcloud . compute . providers import get_driver <EOL> cls = get_driver ( Provider . LIBVIRT ) <EOL>", "answer": "driver = cls ( uri = '<STR_LIT>' ) "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> import os <EOL> from django . contrib . gis . gdal import HAS_GDAL <EOL> from django . contrib . gis . geos import HAS_GEOS <EOL> from django . contrib . gis . measure import D <EOL> from django . contrib . gis . tests . utils import postgis <EOL> from django . test import TestCase <EOL> from django . utils . _os import upath <EOL> from django . utils . unittest import skipUnless <EOL> if HAS_GEOS : <EOL> from . models import City , County , Zipcode <EOL> @ skipUnless ( HAS_GEOS and postgis , \"<STR_LIT>\" ) <EOL> class GeographyTest ( TestCase ) : <EOL> def test01_fixture_load ( self ) : <EOL> \"<STR_LIT>\" <EOL> self . assertEqual ( <NUM_LIT:8> , City . objects . count ( ) ) <EOL> def test02_distance_lookup ( self ) : <EOL> \"<STR_LIT>\" <EOL> z = Zipcode . objects . get ( code = '<STR_LIT>' ) <EOL> cities1 = list ( City . objects <EOL> . filter ( point__distance_lte = ( z . poly , D ( mi = <NUM_LIT> ) ) ) <EOL>", "answer": ". order_by ( '<STR_LIT:name>' )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from dispatcher import * <EOL> from client import PlugIn <EOL> class Browser ( PlugIn ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> PlugIn . __init__ ( self ) <EOL> DBG_LINE = '<STR_LIT>' <EOL> self . _exported_methods = [ ] <EOL> self . _handlers = { '<STR_LIT>' : { } } <EOL> def plugin ( self , owner ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> owner . RegisterHandler ( '<STR_LIT>' , self . _DiscoveryHandler , typ = '<STR_LIT>' , ns = NS_DISCO_INFO ) <EOL> owner . RegisterHandler ( '<STR_LIT>' , self . _DiscoveryHandler , typ = '<STR_LIT>' , ns = NS_DISCO_ITEMS ) <EOL>", "answer": "def plugout ( self ) :"}, {"prompt": "<s> from setuptools import setup <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL>", "answer": "author = '<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from lmi . scripts . common . errors import LmiFailed <EOL> from lmi . scripts . common import get_logger <EOL> LOG = get_logger ( __name__ ) <EOL> from lmi . scripts . storage import common <EOL> def get_raids ( ns ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for raid in ns . LMI_MDRAIDStorageExtent . instances ( ) : <EOL> yield raid <EOL> def create_raid ( ns , devices , level , name = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> devs = [ common . str2device ( ns , device ) for device in devices ] <EOL> args = { '<STR_LIT>' : devs , <EOL> '<STR_LIT>' : level } <EOL> if name : <EOL> args [ '<STR_LIT>' ] = name <EOL> service = ns . LMI_StorageConfigurationService . first_instance ( ) <EOL> ( ret , outparams , err ) = service . SyncCreateOrModifyMDRAID ( ** args ) <EOL> if ret != <NUM_LIT:0> : <EOL> if err : <EOL> raise LmiFailed ( \"<STR_LIT>\" % err ) <EOL> values = service . CreateOrModifyMDRAID . CreateOrModifyMDRAIDValues <EOL> raise LmiFailed ( \"<STR_LIT>\" <EOL> % ( values . value_name ( ret ) , ) ) <EOL> raid = outparams [ '<STR_LIT>' ] . to_instance ( ) <EOL> LOG ( ) . info ( \"<STR_LIT>\" , raid . Name ) <EOL> return raid <EOL> def delete_raid ( ns , raid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raid = common . str2device ( ns , raid ) <EOL> service = ns . LMI_StorageConfigurationService . first_instance ( ) <EOL> ( ret , _outparams , err ) = service . SyncDeleteMDRAID ( TheElement = raid ) <EOL>", "answer": "if ret != <NUM_LIT:0> :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> from string import Template <EOL> from google . appengine . ext import db <EOL> from werkzeug . routing import ( <EOL> Rule , RuleTemplate , EndpointPrefix , Submount , <EOL> ) <EOL> from werkzeug . exceptions import ( <EOL> NotFound , Forbidden <EOL> ) <EOL> from werkzeug import ( <EOL> Response , redirect <EOL> ) <EOL> from werkzeug . utils import import_string <EOL> from werkzeug . routing import RequestRedirect <EOL> from kay . utils import ( <EOL> render_to_response , url_for <EOL> ) <EOL> from kay . db import OwnerProperty <EOL> from kay . utils . flash import ( <EOL> set_flash , get_flash <EOL> ) <EOL> from kay . exceptions import NotAuthorized <EOL> from kay . i18n import gettext as _ <EOL> from kay . i18n import lazy_gettext <EOL> from kay . routing import ViewGroup <EOL> from kay . generics import ( <EOL> OP_LIST , OP_SHOW , OP_CREATE , OP_UPDATE , OP_DELETE <EOL> ) <EOL> endpoints = { <EOL> '<STR_LIT:list>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> } <EOL> per_domain_endpoints = { <EOL> '<STR_LIT:list>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> } <EOL> class CRUDViewGroup ( ViewGroup ) : <EOL> entities_per_page = <NUM_LIT:20> <EOL> templates = { <EOL> OP_LIST : '<STR_LIT>' , <EOL> OP_SHOW : '<STR_LIT>' , <EOL> OP_UPDATE : '<STR_LIT>' , <EOL> } <EOL> forms = { } <EOL> form = None <EOL> owner_attr = None <EOL> rule_template = RuleTemplate ( [ <EOL> Rule ( '<STR_LIT>' , endpoint = endpoints [ OP_LIST ] ) , <EOL> Rule ( '<STR_LIT>' , endpoint = endpoints [ OP_LIST ] ) , <EOL> Rule ( '<STR_LIT>' , endpoint = endpoints [ OP_SHOW ] ) , <EOL> Rule ( '<STR_LIT>' , endpoint = endpoints [ OP_CREATE ] ) , <EOL> Rule ( '<STR_LIT>' , endpoint = endpoints [ OP_UPDATE ] ) , <EOL> Rule ( '<STR_LIT>' , endpoint = endpoints [ OP_DELETE ] ) , <EOL> ] ) <EOL> messages = { <EOL> '<STR_LIT>' : lazy_gettext ( u\"<STR_LIT>\" ) , <EOL> '<STR_LIT>' : lazy_gettext ( u\"<STR_LIT>\" ) , <EOL> '<STR_LIT>' : lazy_gettext ( u\"<STR_LIT>\" ) , <EOL> '<STR_LIT>' : lazy_gettext ( u\"<STR_LIT>\" ) , <EOL> '<STR_LIT>' : lazy_gettext ( u\"<STR_LIT>\" ) , <EOL> } <EOL> def __init__ ( self , model = None , ** kwargs ) : <EOL> super ( CRUDViewGroup , self ) . __init__ ( ** kwargs ) <EOL> self . model = model or self . model <EOL> if isinstance ( self . model , basestring ) : <EOL> self . model_name = self . model . split ( \"<STR_LIT:.>\" ) [ - <NUM_LIT:1> ] <EOL> else : <EOL> self . model_name = self . model . __name__ <EOL> self . model_name_lower = self . model_name . lower ( ) <EOL> def _import_model_if_not ( self ) : <EOL> if isinstance ( self . model , basestring ) : <EOL> self . model = import_string ( self . model ) <EOL> def get_additional_context_on_create ( self , request , form ) : <EOL> if self . owner_attr : <EOL> if request . user . is_anonymous ( ) : <EOL> owner = None <EOL> else : <EOL> owner = request . user . key ( ) <EOL> return { self . owner_attr : owner } <EOL> else : <EOL> return { } <EOL> def get_additional_context_on_update ( self , request , form ) : <EOL> return { } <EOL> def get_query ( self , request ) : <EOL> created_timestamp_name = None <EOL> for k , v in self . model . fields ( ) . iteritems ( ) : <EOL> if isinstance ( v , db . DateTimeProperty ) : <EOL> if hasattr ( v , '<STR_LIT>' ) and v . auto_now_add : <EOL> created_timestamp_name = k <EOL> if created_timestamp_name : <EOL> return self . model . all ( ) . order ( '<STR_LIT>' % created_timestamp_name ) <EOL> else : <EOL> return self . model . all ( ) <EOL> def get_template ( self , request , name ) : <EOL> return self . templates [ name ] <EOL> def get_form ( self , request , name ) : <EOL> try : <EOL> ret = self . forms [ name ] <EOL> except KeyError : <EOL> ret = self . form <EOL> if isinstance ( ret , basestring ) : <EOL> return import_string ( ret ) <EOL> else : <EOL> return ret <EOL> def url_for ( self , * args , ** kwargs ) : <EOL> return url_for ( * args , ** kwargs ) <EOL> def get_list_url ( self , cursor = None ) : <EOL> return self . url_for ( self . get_endpoint ( OP_LIST ) , cursor = cursor ) <EOL> def get_detail_url ( self , obj ) : <EOL> return self . url_for ( self . get_endpoint ( OP_SHOW ) , key = obj . key ( ) ) <EOL> def get_delete_url ( self , obj ) : <EOL> return self . url_for ( self . get_endpoint ( OP_DELETE ) , key = obj . key ( ) ) <EOL>", "answer": "def get_update_url ( self , obj ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> class ITransferable ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def getData ( self , dataFlavor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> def setData ( self , dataFlavor , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL>", "answer": "def getDataFlavors ( self ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import operator <EOL> import sys <EOL> import types <EOL> __author__ = \"<STR_LIT>\" <EOL> __version__ = \"<STR_LIT>\" <EOL> PY3 = sys . version_info [ <NUM_LIT:0> ] == <NUM_LIT:3> <EOL> if PY3 : <EOL> string_types = str , <EOL> integer_types = int , <EOL> class_types = type , <EOL> text_type = str <EOL> binary_type = bytes <EOL> MAXSIZE = sys . maxsize <EOL> else : <EOL> string_types = basestring , <EOL> integer_types = ( int , long ) <EOL> class_types = ( type , types . ClassType ) <EOL> text_type = unicode <EOL> binary_type = str <EOL> if sys . platform . startswith ( \"<STR_LIT>\" ) : <EOL> MAXSIZE = int ( ( <NUM_LIT:1> << <NUM_LIT> ) - <NUM_LIT:1> ) <EOL> else : <EOL> class X ( object ) : <EOL> def __len__ ( self ) : <EOL> return <NUM_LIT:1> << <NUM_LIT> <EOL> try : <EOL> len ( X ( ) ) <EOL> except OverflowError : <EOL> MAXSIZE = int ( ( <NUM_LIT:1> << <NUM_LIT> ) - <NUM_LIT:1> ) <EOL> else : <EOL> MAXSIZE = int ( ( <NUM_LIT:1> << <NUM_LIT> ) - <NUM_LIT:1> ) <EOL> del X <EOL> def _add_doc ( func , doc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> func . __doc__ = doc <EOL> def _import_module ( name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __import__ ( name ) <EOL> return sys . modules [ name ] <EOL> class _LazyDescr ( object ) : <EOL> def __init__ ( self , name ) : <EOL> self . name = name <EOL> def __get__ ( self , obj , tp ) : <EOL> result = self . _resolve ( ) <EOL> setattr ( obj , self . name , result ) <EOL> delattr ( tp , self . name ) <EOL> return result <EOL> class MovedModule ( _LazyDescr ) : <EOL> def __init__ ( self , name , old , new = None ) : <EOL> super ( MovedModule , self ) . __init__ ( name ) <EOL> if PY3 : <EOL> if new is None : <EOL> new = name <EOL> self . mod = new <EOL> else : <EOL> self . mod = old <EOL> def _resolve ( self ) : <EOL> return _import_module ( self . mod ) <EOL> class MovedAttribute ( _LazyDescr ) : <EOL> def __init__ ( self , name , old_mod , new_mod , old_attr = None , new_attr = None ) : <EOL> super ( MovedAttribute , self ) . __init__ ( name ) <EOL> if PY3 : <EOL> if new_mod is None : <EOL> new_mod = name <EOL> self . mod = new_mod <EOL> if new_attr is None : <EOL> if old_attr is None : <EOL> new_attr = name <EOL> else : <EOL> new_attr = old_attr <EOL> self . attr = new_attr <EOL> else : <EOL> self . mod = old_mod <EOL> if old_attr is None : <EOL> old_attr = name <EOL> self . attr = old_attr <EOL> def _resolve ( self ) : <EOL> module = _import_module ( self . mod ) <EOL> return getattr ( module , self . attr ) <EOL> class _MovedItems ( types . ModuleType ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _moved_attributes = [ <EOL> MovedAttribute ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> MovedAttribute ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> MovedAttribute ( \"<STR_LIT:input>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:input>\" ) , <EOL> MovedAttribute ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> MovedAttribute ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> MovedAttribute ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL>", "answer": "MovedAttribute ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ,"}, {"prompt": "<s> import sys <EOL> if sys . version_info < ( <NUM_LIT:2> , <NUM_LIT:7> ) : <EOL> import unittest2 as unittest <EOL> else : <EOL>", "answer": "import unittest "}, {"prompt": "<s> from pypy . conftest import gettestobjspace , skip_on_missing_buildoption <EOL> class AppTest_Greenlet : <EOL> def setup_class ( cls ) : <EOL> space = gettestobjspace ( usemodules = ( '<STR_LIT>' , ) ) <EOL> cls . space = space <EOL> def test_very_simple ( self ) : <EOL> from _stackless import greenlet <EOL> lst = [ ] <EOL> def f ( x ) : <EOL> lst . append ( x ) <EOL> return x + <NUM_LIT:10> <EOL> g = greenlet ( f ) <EOL> assert not g <EOL> res = g . switch ( <NUM_LIT:20> ) <EOL> assert res == <NUM_LIT:30> <EOL> assert lst == [ <NUM_LIT:20> ] <EOL> assert g . dead <EOL> assert not g <EOL> def test_switch_back_to_main ( self ) : <EOL> from _stackless import greenlet <EOL> lst = [ ] <EOL> main = greenlet . getcurrent ( ) <EOL> def f ( x ) : <EOL> lst . append ( x ) <EOL> x = main . switch ( x + <NUM_LIT:10> ) <EOL> return <NUM_LIT> + x <EOL> g = greenlet ( f ) <EOL> res = g . switch ( <NUM_LIT:20> ) <EOL> assert res == <NUM_LIT:30> <EOL> assert lst == [ <NUM_LIT:20> ] <EOL> assert not g . dead <EOL> res = g . switch ( <NUM_LIT:2> ) <EOL> assert res == <NUM_LIT> <EOL> assert g . dead <EOL> def test_simple ( self ) : <EOL> from _stackless import greenlet <EOL> lst = [ ] <EOL> gs = [ ] <EOL> def f ( ) : <EOL> lst . append ( <NUM_LIT:1> ) <EOL> greenlet . getcurrent ( ) . parent . switch ( ) <EOL> lst . append ( <NUM_LIT:3> ) <EOL> g = greenlet ( f ) <EOL> lst . append ( <NUM_LIT:0> ) <EOL> g . switch ( ) <EOL> lst . append ( <NUM_LIT:2> ) <EOL> g . switch ( ) <EOL> lst . append ( <NUM_LIT:4> ) <EOL> assert lst == range ( <NUM_LIT:5> ) <EOL> def test_exception_simple ( self ) : <EOL> from _stackless import greenlet <EOL> def f ( ) : <EOL> raise ValueError <EOL> g1 = greenlet ( f ) <EOL> raises ( ValueError , g1 . switch ) <EOL> def test_exception_propagate ( self ) : <EOL> from _stackless import greenlet <EOL> def f ( ) : <EOL> raise ValueError <EOL> def g ( ) : <EOL> return g1 . switch ( ) <EOL> g1 = greenlet ( f ) <EOL> g2 = greenlet ( g ) <EOL> raises ( ValueError , g1 . switch ) <EOL> g1 = greenlet ( f ) <EOL> raises ( ValueError , g2 . switch ) <EOL> def test_exception ( self ) : <EOL> from _stackless import greenlet <EOL> import sys <EOL> def fmain ( seen ) : <EOL> try : <EOL> greenlet . getcurrent ( ) . parent . switch ( ) <EOL> except : <EOL> seen . append ( sys . exc_info ( ) [ <NUM_LIT:0> ] ) <EOL> raise <EOL> raise ValueError <EOL> seen = [ ] <EOL> g1 = greenlet ( fmain ) <EOL> g2 = greenlet ( fmain ) <EOL> g1 . switch ( seen ) <EOL> g2 . switch ( seen ) <EOL> raises ( TypeError , \"<STR_LIT>\" ) <EOL> g2 . parent = g1 <EOL> assert seen == [ ] <EOL> raises ( ValueError , g2 . switch ) <EOL> assert seen == [ ValueError ] <EOL> g2 . switch ( ) <EOL> assert seen == [ ValueError ] <EOL> def test_send_exception ( self ) : <EOL> from _stackless import greenlet <EOL> import sys <EOL> def send_exception ( g , exc ) : <EOL> def crasher ( exc ) : <EOL> raise exc <EOL> g1 = greenlet ( crasher ) <EOL> g1 . parent = g <EOL> g1 . switch ( exc ) <EOL> def fmain ( seen ) : <EOL> try : <EOL> greenlet . getcurrent ( ) . parent . switch ( ) <EOL> except : <EOL> seen . append ( sys . exc_info ( ) [ <NUM_LIT:0> ] ) <EOL> raise <EOL> raise ValueError <EOL> seen = [ ] <EOL> g1 = greenlet ( fmain ) <EOL> g1 . switch ( seen ) <EOL> raises ( KeyError , \"<STR_LIT>\" ) <EOL> assert seen == [ KeyError ] <EOL> seen = [ ] <EOL> g1 = greenlet ( fmain ) <EOL> g1 . switch ( seen ) <EOL> raises ( KeyError , \"<STR_LIT>\" ) <EOL> assert seen == [ KeyError ] <EOL> assert g1 . dead <EOL> def test_frame ( self ) : <EOL> from _stackless import greenlet <EOL> import sys <EOL> def f1 ( ) : <EOL> f = sys . _getframe ( <NUM_LIT:0> ) <EOL> assert f . f_back is None <EOL> greenlet . getcurrent ( ) . parent . switch ( f ) <EOL> return \"<STR_LIT>\" <EOL> g = greenlet ( f1 ) <EOL> frame = g . switch ( ) <EOL> assert frame is g . gr_frame <EOL> assert g <EOL> next = g . switch ( ) <EOL> assert not g <EOL> assert next == \"<STR_LIT>\" <EOL> assert g . gr_frame is None <EOL> def test_mixing_greenlet_coroutine ( self ) : <EOL> from _stackless import greenlet , coroutine <EOL> lst = [ ] <EOL> def f ( ) : <EOL> lst . append ( <NUM_LIT:1> ) <EOL> greenlet . getcurrent ( ) . parent . switch ( ) <EOL> lst . append ( <NUM_LIT:3> ) <EOL> def make_h ( c ) : <EOL> def h ( ) : <EOL> g = greenlet ( f ) <EOL> lst . append ( <NUM_LIT:0> ) <EOL> g . switch ( ) <EOL> c . switch ( ) <EOL> lst . append ( <NUM_LIT:2> ) <EOL> g . switch ( ) <EOL> c . switch ( ) <EOL> lst . append ( <NUM_LIT:4> ) <EOL> c . switch ( ) <EOL> return h <EOL> c1 = coroutine . getcurrent ( ) <EOL> c2 = coroutine ( ) <EOL> c3 = coroutine ( ) <EOL> c2 . bind ( make_h ( c3 ) ) <EOL> c3 . bind ( make_h ( c2 ) ) <EOL> c2 . switch ( ) <EOL> assert lst == [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:4> ] <EOL> def test_dealloc ( self ) : <EOL> skip ( \"<STR_LIT>\" ) <EOL> from _stackless import greenlet <EOL> import sys <EOL> def fmain ( seen ) : <EOL> try : <EOL> greenlet . getcurrent ( ) . parent . switch ( ) <EOL> except : <EOL> seen . append ( sys . exc_info ( ) [ <NUM_LIT:0> ] ) <EOL> raise <EOL> raise ValueError <EOL> seen = [ ] <EOL> seen = [ ] <EOL> g1 = greenlet ( fmain ) <EOL> g2 = greenlet ( fmain ) <EOL> g1 . switch ( seen ) <EOL> g2 . switch ( seen ) <EOL> assert seen == [ ] <EOL> del g1 <EOL> assert seen == [ greenlet . GreenletExit ] <EOL> del g2 <EOL> assert seen == [ greenlet . GreenletExit , greenlet . GreenletExit ] <EOL> class AppTest_PyMagicTestGreenlet : <EOL> def setup_class ( cls ) : <EOL> space = gettestobjspace ( usemodules = ( '<STR_LIT>' , ) ) <EOL> cls . space = space <EOL> cls . w_glob = space . appexec ( [ ] , \"\"\"<STR_LIT>\"\"\" ) <EOL> def test_simple ( self ) : <EOL> greenlet = self . glob . greenlet <EOL> lst = [ ] <EOL> def f ( ) : <EOL> lst . append ( <NUM_LIT:1> ) <EOL> greenlet . getcurrent ( ) . parent . switch ( ) <EOL> lst . append ( <NUM_LIT:3> ) <EOL> g = greenlet ( f ) <EOL> lst . append ( <NUM_LIT:0> ) <EOL> g . switch ( ) <EOL> lst . append ( <NUM_LIT:2> ) <EOL> g . switch ( ) <EOL> lst . append ( <NUM_LIT:4> ) <EOL> assert lst == range ( <NUM_LIT:5> ) <EOL> def test_exception ( self ) : <EOL> greenlet = self . glob . greenlet <EOL> fmain = self . glob . fmain <EOL> SomeError = self . glob . SomeError <EOL> seen = [ ] <EOL> g1 = greenlet ( fmain ) <EOL> g2 = greenlet ( fmain ) <EOL> g1 . switch ( seen ) <EOL> g2 . switch ( seen ) <EOL> g2 . parent = g1 <EOL> assert seen == [ ] <EOL> raises ( SomeError , g2 . switch ) <EOL> assert seen == [ SomeError ] <EOL> g2 . switch ( ) <EOL> assert seen == [ SomeError ] <EOL> def test_send_exception ( self ) : <EOL> greenlet = self . glob . greenlet <EOL> fmain = self . glob . fmain <EOL> def send_exception ( g , exc ) : <EOL> def crasher ( exc ) : <EOL> raise exc <EOL> g1 = greenlet ( crasher , parent = g ) <EOL> g1 . switch ( exc ) <EOL> seen = [ ] <EOL> g1 = greenlet ( fmain ) <EOL> g1 . switch ( seen ) <EOL> raises ( KeyError , \"<STR_LIT>\" ) <EOL> assert seen == [ KeyError ] <EOL> def test_dealloc ( self ) : <EOL> skip ( \"<STR_LIT>\" ) <EOL> import gc <EOL> greenlet = self . glob . greenlet <EOL> fmain = self . glob . fmain <EOL> seen = [ ] <EOL> g1 = greenlet ( fmain ) <EOL> g2 = greenlet ( fmain ) <EOL> g1 . switch ( seen ) <EOL> g2 . switch ( seen ) <EOL> assert seen == [ ] <EOL> del g1 <EOL> gc . collect ( ) <EOL> assert seen == [ greenlet . GreenletExit ] <EOL> del g2 <EOL> gc . collect ( ) <EOL> assert seen == [ greenlet . GreenletExit , greenlet . GreenletExit ] <EOL> def test_frame ( self ) : <EOL> import sys <EOL> greenlet = self . glob . greenlet <EOL> def f1 ( ) : <EOL> f = sys . _getframe ( <NUM_LIT:0> ) <EOL> assert f . f_back is None <EOL> greenlet . getcurrent ( ) . parent . switch ( f ) <EOL> return \"<STR_LIT>\" <EOL> g = greenlet ( f1 ) <EOL> frame = g . switch ( ) <EOL> assert frame is g . gr_frame <EOL> assert g <EOL> next = g . switch ( ) <EOL> assert not g <EOL> assert next == \"<STR_LIT>\" <EOL> assert g . gr_frame is None <EOL> class AppTest_PyMagicTestThrow : <EOL> def setup_class ( cls ) : <EOL> space = gettestobjspace ( usemodules = ( '<STR_LIT>' , ) ) <EOL> cls . space = space <EOL> def test_class ( self ) : <EOL> from _stackless import greenlet <EOL> def switch ( * args ) : <EOL> return greenlet . getcurrent ( ) . parent . switch ( * args ) <EOL> def f ( ) : <EOL> try : <EOL> switch ( \"<STR_LIT>\" ) <EOL> except RuntimeError : <EOL> switch ( \"<STR_LIT>\" ) <EOL> return <EOL> switch ( \"<STR_LIT>\" ) <EOL> g = greenlet ( f ) <EOL> res = g . switch ( ) <EOL> assert res == \"<STR_LIT>\" <EOL> res = g . throw ( RuntimeError ) <EOL> assert res == \"<STR_LIT>\" <EOL> def test_val ( self ) : <EOL> from _stackless import greenlet <EOL> def switch ( * args ) : <EOL> return greenlet . getcurrent ( ) . parent . switch ( * args ) <EOL> def f ( ) : <EOL> try : <EOL> switch ( \"<STR_LIT>\" ) <EOL> except RuntimeError , val : <EOL> if str ( val ) == \"<STR_LIT>\" : <EOL> switch ( \"<STR_LIT>\" ) <EOL> return <EOL> switch ( \"<STR_LIT>\" ) <EOL> g = greenlet ( f ) <EOL> res = g . switch ( ) <EOL> assert res == \"<STR_LIT>\" <EOL> res = g . throw ( RuntimeError ( \"<STR_LIT>\" ) ) <EOL> assert res == \"<STR_LIT>\" <EOL> g = greenlet ( f ) <EOL> res = g . switch ( ) <EOL> assert res == \"<STR_LIT>\" <EOL> res = g . throw ( RuntimeError , \"<STR_LIT>\" ) <EOL> assert res == \"<STR_LIT>\" <EOL> def test_kill ( self ) : <EOL> from _stackless import greenlet <EOL> def switch ( * args ) : <EOL> return greenlet . getcurrent ( ) . parent . switch ( * args ) <EOL> def f ( ) : <EOL> switch ( \"<STR_LIT>\" ) <EOL> switch ( \"<STR_LIT>\" ) <EOL> g = greenlet ( f ) <EOL> res = g . switch ( ) <EOL> assert res == \"<STR_LIT>\" <EOL> res = g . throw ( ) <EOL> assert isinstance ( res , greenlet . GreenletExit ) <EOL> assert g . dead <EOL> res = g . throw ( ) <EOL> assert isinstance ( res , greenlet . GreenletExit ) <EOL> def test_throw_goes_to_original_parent ( self ) : <EOL> from _stackless import greenlet <EOL> main = greenlet . getcurrent ( ) <EOL> def f1 ( ) : <EOL> try : <EOL> main . switch ( \"<STR_LIT>\" ) <EOL> except IndexError : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> def f2 ( ) : <EOL> main . switch ( \"<STR_LIT>\" ) <EOL> g1 = greenlet ( f1 ) <EOL> g2 = greenlet ( f2 , parent = g1 ) <EOL> raises ( IndexError , g2 . throw , IndexError ) <EOL> assert g2 . dead <EOL> assert g1 . dead <EOL> g1 = greenlet ( f1 ) <EOL> g2 = greenlet ( f2 , parent = g1 ) <EOL> res = g1 . switch ( ) <EOL> assert res == \"<STR_LIT>\" <EOL> res = g2 . throw ( IndexError ) <EOL> assert res == \"<STR_LIT>\" <EOL> assert g2 . dead <EOL> assert g1 . dead <EOL> g1 = greenlet ( f1 ) <EOL> g2 = greenlet ( f2 , parent = g1 ) <EOL> res = g1 . switch ( ) <EOL> assert res == \"<STR_LIT>\" <EOL> res = g2 . switch ( ) <EOL> assert res == \"<STR_LIT>\" <EOL> res = g2 . throw ( IndexError ) <EOL> assert res == \"<STR_LIT>\" <EOL> assert g2 . dead <EOL> assert g1 . dead <EOL> class AppTest_PyMagicTestGenerator : <EOL> def setup_class ( cls ) : <EOL> space = gettestobjspace ( usemodules = ( '<STR_LIT>' , ) ) <EOL> cls . space = space <EOL> def test_generator ( self ) : <EOL> from _stackless import greenlet <EOL> class genlet ( greenlet ) : <EOL> def __init__ ( self , * args , ** kwds ) : <EOL> self . args = args <EOL> self . kwds = kwds <EOL> def run ( self ) : <EOL> fn , = self . fn <EOL> fn ( * self . args , ** self . kwds ) <EOL> def __iter__ ( self ) : <EOL> return self <EOL> def next ( self ) : <EOL> self . parent = greenlet . getcurrent ( ) <EOL> result = self . switch ( ) <EOL> if self : <EOL> return result <EOL> else : <EOL> raise StopIteration <EOL> def Yield ( value ) : <EOL> g = greenlet . getcurrent ( ) <EOL> while not isinstance ( g , genlet ) : <EOL> if g is None : <EOL> raise RuntimeError , '<STR_LIT>' <EOL> g = g . parent <EOL> g . parent . switch ( value ) <EOL> def generator ( func ) : <EOL> class generator ( genlet ) : <EOL> fn = ( func , ) <EOL> return generator <EOL> seen = [ ] <EOL> def g ( n ) : <EOL> for i in range ( n ) : <EOL> seen . append ( i ) <EOL> Yield ( i ) <EOL> g = generator ( g ) <EOL> for k in range ( <NUM_LIT:3> ) : <EOL> for j in g ( <NUM_LIT:5> ) : <EOL> seen . append ( j ) <EOL> assert seen == <NUM_LIT:3> * [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:4> ] <EOL> class AppTest_PyMagicTestGeneratorNested : <EOL> def setup_class ( cls ) : <EOL> space = gettestobjspace ( usemodules = ( '<STR_LIT>' , ) ) <EOL> cls . space = space <EOL> cls . w_glob = space . appexec ( [ ] , \"\"\"<STR_LIT>\"\"\" ) <EOL> def test_genlet_1 ( self ) : <EOL> Genlet = self . glob . Genlet <EOL> Yield = self . glob . Yield <EOL> def g1 ( n , seen ) : <EOL> for i in range ( n ) : <EOL> seen . append ( i + <NUM_LIT:1> ) <EOL> yield i <EOL> def g2 ( n , seen ) : <EOL> for i in range ( n ) : <EOL> seen . append ( i + <NUM_LIT:1> ) <EOL> Yield ( i ) <EOL> g2 = Genlet ( g2 ) <EOL> def nested ( i ) : <EOL> Yield ( i ) <EOL> def g3 ( n , seen ) : <EOL> for i in range ( n ) : <EOL> seen . append ( i + <NUM_LIT:1> ) <EOL> nested ( i ) <EOL> g3 = Genlet ( g3 ) <EOL> raises ( RuntimeError , Yield , <NUM_LIT:10> ) <EOL> for g in [ g1 , g2 , g3 ] : <EOL> seen = [ ] <EOL> for k in range ( <NUM_LIT:3> ) : <EOL> for j in g ( <NUM_LIT:5> , seen ) : <EOL> seen . append ( j ) <EOL> assert seen == <NUM_LIT:3> * [ <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:3> , <NUM_LIT:5> , <NUM_LIT:4> ] <EOL> raises ( RuntimeError , Yield , <NUM_LIT:10> ) <EOL> def test_nested_genlets ( self ) : <EOL> Genlet = self . glob . Genlet <EOL> Yield = self . glob . Yield <EOL> def a ( n ) : <EOL> if n == <NUM_LIT:0> : <EOL> return <EOL> for ii in ax ( n - <NUM_LIT:1> ) : <EOL> Yield ( ii ) <EOL> Yield ( n ) <EOL> ax = Genlet ( a ) <EOL> seen = [ ] <EOL> for ii in ax ( <NUM_LIT:5> ) : <EOL> seen . append ( ii ) <EOL> assert seen == [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> ] <EOL> def test_perms ( self ) : <EOL> Genlet = self . glob . Genlet <EOL> Yield = self . glob . Yield <EOL> def perms ( l ) : <EOL> if len ( l ) > <NUM_LIT:1> : <EOL> for e in l : <EOL> [ Yield ( [ e ] + p ) for p in perms ( [ x for x in l if x != e ] ) ] <EOL> else : <EOL> Yield ( l ) <EOL>", "answer": "perms = Genlet ( perms )"}, {"prompt": "<s> from flask import Flask , render_template , request <EOL> from micawber . providers import bootstrap_basic <EOL> from micawber . contrib . mcflask import add_oembed_filters <EOL> app = Flask ( __name__ ) <EOL> app . config [ '<STR_LIT>' ] = True <EOL> oembed_providers = bootstrap_basic ( ) <EOL> add_oembed_filters ( app , oembed_providers ) <EOL> @ app . route ( '<STR_LIT:/>' ) <EOL> def example_view ( ) : <EOL> text = request . args . get ( '<STR_LIT:text>' , '<STR_LIT>' ) <EOL>", "answer": "html = request . args . get ( '<STR_LIT:html>' , \"\"\"<STR_LIT>\"\"\" )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os , unittest <EOL> from models import Country , City , State , Feature <EOL> from django . contrib . gis import gdal <EOL> from django . contrib . gis . geos import * <EOL> from django . core . exceptions import ImproperlyConfigured <EOL> class GeoModelTest ( unittest . TestCase ) : <EOL> def test01_initial_sql ( self ) : <EOL> \"<STR_LIT>\" <EOL> self . assertEqual ( <NUM_LIT:2> , Country . objects . count ( ) ) <EOL> self . assertEqual ( <NUM_LIT:8> , City . objects . count ( ) ) <EOL> self . assertEqual ( <NUM_LIT:2> , State . objects . count ( ) ) <EOL> def test02_proxy ( self ) : <EOL> \"<STR_LIT>\" <EOL> pnt = Point ( <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> nullcity = City ( name = '<STR_LIT>' , point = pnt ) <EOL> nullcity . save ( ) <EOL> for bad in [ <NUM_LIT:5> , <NUM_LIT> , LineString ( ( <NUM_LIT:0> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:1> ) ) ] : <EOL> try : <EOL> nullcity . point = bad <EOL> except TypeError : <EOL> pass <EOL> else : <EOL> self . fail ( '<STR_LIT>' ) <EOL> new = Point ( <NUM_LIT:5> , <NUM_LIT> ) <EOL> nullcity . point = new <EOL> self . assertEqual ( <NUM_LIT> , nullcity . point . srid ) <EOL> nullcity . save ( ) <EOL> self . assertEqual ( new , City . objects . get ( name = '<STR_LIT>' ) . point ) <EOL> nullcity . point . x = <NUM_LIT> <EOL> nullcity . point . y = <NUM_LIT:5> <EOL> self . assertNotEqual ( Point ( <NUM_LIT> , <NUM_LIT:5> ) , City . objects . get ( name = '<STR_LIT>' ) . point ) <EOL> nullcity . save ( ) <EOL> self . assertEqual ( Point ( <NUM_LIT> , <NUM_LIT:5> ) , City . objects . get ( name = '<STR_LIT>' ) . point ) <EOL> nullcity . delete ( ) <EOL> shell = LinearRing ( ( <NUM_LIT:0> , <NUM_LIT:0> ) , ( <NUM_LIT:0> , <NUM_LIT:100> ) , ( <NUM_LIT:100> , <NUM_LIT:100> ) , ( <NUM_LIT:100> , <NUM_LIT:0> ) , ( <NUM_LIT:0> , <NUM_LIT:0> ) ) <EOL> inner = LinearRing ( ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) ) <EOL> ply = Polygon ( shell , inner ) <EOL> nullstate = State ( name = '<STR_LIT>' , poly = ply ) <EOL> self . assertEqual ( <NUM_LIT> , nullstate . poly . srid ) <EOL> nullstate . save ( ) <EOL> ns = State . objects . get ( name = '<STR_LIT>' ) <EOL>", "answer": "self . assertEqual ( ply , ns . poly )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import datetime <EOL> import decimal <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . contrib . auth import get_user_model <EOL> from django . core . exceptions import ImproperlyConfigured <EOL> from django . test import TestCase <EOL> from django . test . utils import override_settings <EOL> from django . utils import timezone <EOL> from djstripe . models import convert_tstamp , Customer , CurrentSubscription <EOL> from djstripe . utils import subscriber_has_active_subscription , get_supported_currency_choices <EOL> from unittest . case import SkipTest <EOL> from unittest2 import TestCase as AssertWarnsEnabledTestCase <EOL> from mock import patch <EOL> from stripe import api_key <EOL> from tests . apps . testapp . models import Organization <EOL> class TestDeprecationWarning ( AssertWarnsEnabledTestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . user = get_user_model ( ) . objects . create_user ( username = \"<STR_LIT>\" , <EOL> email = \"<STR_LIT>\" ) <EOL> self . customer = Customer . objects . create ( <EOL> subscriber = self . user , <EOL> stripe_id = \"<STR_LIT>\" , <EOL> card_fingerprint = \"<STR_LIT>\" , <EOL> card_last_4 = \"<STR_LIT>\" , <EOL> card_kind = \"<STR_LIT>\" <EOL> ) <EOL> def test_deprecation ( self ) : <EOL> with self . assertWarns ( DeprecationWarning ) : <EOL> from djstripe . utils import user_has_active_subscription <EOL> user_has_active_subscription ( self . user ) <EOL> class TestTimestampConversion ( TestCase ) : <EOL> def test_conversion_without_field_name ( self ) : <EOL> stamp = convert_tstamp ( <NUM_LIT> ) <EOL> self . assertEquals ( <EOL> stamp , <EOL> datetime . datetime ( <NUM_LIT> , <NUM_LIT:4> , <NUM_LIT:10> , <NUM_LIT:4> , <NUM_LIT:16> , <NUM_LIT> , tzinfo = timezone . utc ) <EOL> ) <EOL> def test_conversion_with_field_name ( self ) : <EOL> stamp = convert_tstamp ( { \"<STR_LIT>\" : <NUM_LIT> } , \"<STR_LIT>\" ) <EOL> self . assertEquals ( <EOL> stamp , <EOL> datetime . datetime ( <NUM_LIT> , <NUM_LIT:4> , <NUM_LIT:10> , <NUM_LIT:4> , <NUM_LIT:16> , <NUM_LIT> , tzinfo = timezone . utc ) <EOL> ) <EOL> def test_conversion_with_invalid_field_name ( self ) : <EOL> stamp = convert_tstamp ( { \"<STR_LIT>\" : <NUM_LIT> } , \"<STR_LIT:foo>\" ) <EOL> self . assertEquals ( <EOL> stamp , <EOL> None <EOL> ) <EOL> @ override_settings ( USE_TZ = False ) <EOL> def test_conversion_without_field_name_no_tz ( self ) : <EOL> if settings . DJSTRIPE_TESTS_SKIP_UTC : <EOL> raise SkipTest ( \"<STR_LIT>\" ) <EOL> stamp = convert_tstamp ( <NUM_LIT> ) <EOL> self . assertEquals ( <EOL> stamp , <EOL> datetime . datetime ( <NUM_LIT> , <NUM_LIT:4> , <NUM_LIT:10> , <NUM_LIT:4> , <NUM_LIT:16> , <NUM_LIT> ) , <EOL> \"<STR_LIT>\" <EOL> ) <EOL> @ override_settings ( USE_TZ = False ) <EOL> def test_conversion_with_field_name_no_tz ( self ) : <EOL> if settings . DJSTRIPE_TESTS_SKIP_UTC : <EOL> raise SkipTest ( \"<STR_LIT>\" ) <EOL> stamp = convert_tstamp ( { \"<STR_LIT>\" : <NUM_LIT> } , \"<STR_LIT>\" ) <EOL> self . assertEquals ( <EOL> stamp , <EOL>", "answer": "datetime . datetime ( <NUM_LIT> , <NUM_LIT:4> , <NUM_LIT:10> , <NUM_LIT:4> , <NUM_LIT:16> , <NUM_LIT> ) ,"}, {"prompt": "<s> import copy <EOL> import struct <EOL> def compact_word ( word ) : <EOL> return ( word [ <NUM_LIT:0> ] << <NUM_LIT> ) | ( word [ <NUM_LIT:1> ] << <NUM_LIT:16> ) | ( word [ <NUM_LIT:2> ] << <NUM_LIT:8> ) | word [ <NUM_LIT:3> ] <EOL> class AES ( object ) : <EOL> number_of_rounds = { <NUM_LIT:16> : <NUM_LIT:10> , <NUM_LIT> : <NUM_LIT:12> , <NUM_LIT:32> : <NUM_LIT> } <EOL> rcon = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> S = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> T1 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> T2 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> T3 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> T4 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> def __init__ ( self , key ) : <EOL> if len ( key ) not in ( <NUM_LIT:16> , <NUM_LIT> , <NUM_LIT:32> ) : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> rounds = self . number_of_rounds [ len ( key ) ] <EOL> self . _Ke = [ [ <NUM_LIT:0> ] * <NUM_LIT:4> for i in xrange ( rounds + <NUM_LIT:1> ) ] <EOL> round_key_count = ( rounds + <NUM_LIT:1> ) * <NUM_LIT:4> <EOL> KC = len ( key ) / <NUM_LIT:4> <EOL> tk = [ struct . unpack ( '<STR_LIT>' , key [ i : i + <NUM_LIT:4> ] ) [ <NUM_LIT:0> ] for i in xrange ( <NUM_LIT:0> , len ( key ) , <NUM_LIT:4> ) ] <EOL> for i in xrange ( <NUM_LIT:0> , KC ) : <EOL> self . _Ke [ i / <NUM_LIT:4> ] [ i % <NUM_LIT:4> ] = tk [ i ] <EOL> rconpointer = <NUM_LIT:0> <EOL> t = KC <EOL> while t < round_key_count : <EOL> tt = tk [ KC - <NUM_LIT:1> ] <EOL> tk [ <NUM_LIT:0> ] ^= ( ( self . S [ ( tt >> <NUM_LIT:16> ) & <NUM_LIT> ] << <NUM_LIT> ) ^ <EOL> ( self . S [ ( tt >> <NUM_LIT:8> ) & <NUM_LIT> ] << <NUM_LIT:16> ) ^ <EOL> ( self . S [ tt & <NUM_LIT> ] << <NUM_LIT:8> ) ^ <EOL> self . S [ ( tt >> <NUM_LIT> ) & <NUM_LIT> ] ^ <EOL> ( self . rcon [ rconpointer ] << <NUM_LIT> ) ) <EOL> rconpointer += <NUM_LIT:1> <EOL> if KC != <NUM_LIT:8> : <EOL> for i in xrange ( <NUM_LIT:1> , KC ) : <EOL>", "answer": "tk [ i ] ^= tk [ i - <NUM_LIT:1> ]"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import division , print_function , absolute_import <EOL> import warnings <EOL> import itertools <EOL> import numpy as np <EOL> from numpy . testing import ( assert_raises , assert_allclose , assert_equal , <EOL> assert_ , TestCase , run_module_suite , dec , <EOL> assert_almost_equal , assert_warns ) <EOL> from scipy . _lib . _testutils import suppressed_stdout <EOL> from scipy import optimize <EOL> def test_check_grad ( ) : <EOL> def logit ( x ) : <EOL> return <NUM_LIT:1> / ( <NUM_LIT:1> + np . exp ( - x ) ) <EOL> def der_logit ( x ) : <EOL> return np . exp ( - x ) / ( <NUM_LIT:1> + np . exp ( - x ) ) ** <NUM_LIT:2> <EOL> x0 = np . array ( [ <NUM_LIT> ] ) <EOL> r = optimize . check_grad ( logit , der_logit , x0 ) <EOL> assert_almost_equal ( r , <NUM_LIT:0> ) <EOL> r = optimize . check_grad ( logit , der_logit , x0 , epsilon = <NUM_LIT> ) <EOL> assert_almost_equal ( r , <NUM_LIT:0> ) <EOL> r = abs ( optimize . check_grad ( logit , der_logit , x0 , epsilon = <NUM_LIT> ) - <NUM_LIT:0> ) <EOL> assert_ ( r > <NUM_LIT> ) <EOL> class CheckOptimize ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . F = np . array ( [ [ <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:1> ] , [ <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:0> ] , [ <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> ] , [ <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> ] , [ <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> ] ] ) <EOL> self . K = np . array ( [ <NUM_LIT:1.> , <NUM_LIT> , <NUM_LIT:0.5> ] ) <EOL> self . startparams = np . zeros ( <NUM_LIT:3> , np . float64 ) <EOL> self . solution = np . array ( [ <NUM_LIT:0.> , - <NUM_LIT> , <NUM_LIT> ] ) <EOL> self . maxiter = <NUM_LIT:1000> <EOL> self . funccalls = <NUM_LIT:0> <EOL> self . gradcalls = <NUM_LIT:0> <EOL> self . trace = [ ] <EOL> def func ( self , x ) : <EOL> self . funccalls += <NUM_LIT:1> <EOL> if self . funccalls > <NUM_LIT> : <EOL> raise RuntimeError ( \"<STR_LIT>\" ) <EOL> log_pdot = np . dot ( self . F , x ) <EOL> logZ = np . log ( sum ( np . exp ( log_pdot ) ) ) <EOL> f = logZ - np . dot ( self . K , x ) <EOL> self . trace . append ( x ) <EOL> return f <EOL> def grad ( self , x ) : <EOL> self . gradcalls += <NUM_LIT:1> <EOL> log_pdot = np . dot ( self . F , x ) <EOL> logZ = np . log ( sum ( np . exp ( log_pdot ) ) ) <EOL> p = np . exp ( log_pdot - logZ ) <EOL> return np . dot ( self . F . transpose ( ) , p ) - self . K <EOL> def hess ( self , x ) : <EOL> log_pdot = np . dot ( self . F , x ) <EOL> logZ = np . log ( sum ( np . exp ( log_pdot ) ) ) <EOL> p = np . exp ( log_pdot - logZ ) <EOL> return np . dot ( self . F . T , <EOL> np . dot ( np . diag ( p ) , self . F - np . dot ( self . F . T , p ) ) ) <EOL> def hessp ( self , x , p ) : <EOL> return np . dot ( self . hess ( x ) , p ) <EOL> class CheckOptimizeParameterized ( CheckOptimize ) : <EOL> @ suppressed_stdout <EOL> def test_cg ( self ) : <EOL> if self . use_wrapper : <EOL> opts = { '<STR_LIT>' : self . maxiter , '<STR_LIT>' : self . disp , <EOL> '<STR_LIT>' : False } <EOL> res = optimize . minimize ( self . func , self . startparams , args = ( ) , <EOL> method = '<STR_LIT>' , jac = self . grad , <EOL> options = opts ) <EOL> params , fopt , func_calls , grad_calls , warnflag = res [ '<STR_LIT:x>' ] , res [ '<STR_LIT>' ] , res [ '<STR_LIT>' ] , res [ '<STR_LIT>' ] , res [ '<STR_LIT:status>' ] <EOL> else : <EOL> retval = optimize . fmin_cg ( self . func , self . startparams , <EOL> self . grad , ( ) , maxiter = self . maxiter , <EOL> full_output = True , disp = self . disp , <EOL> retall = False ) <EOL> ( params , fopt , func_calls , grad_calls , warnflag ) = retval <EOL> assert_allclose ( self . func ( params ) , self . func ( self . solution ) , <EOL> atol = <NUM_LIT> ) <EOL> assert_ ( self . funccalls == <NUM_LIT:9> , self . funccalls ) <EOL> assert_ ( self . gradcalls == <NUM_LIT:7> , self . gradcalls ) <EOL> assert_allclose ( self . trace [ <NUM_LIT:2> : <NUM_LIT:4> ] , <EOL> [ [ <NUM_LIT:0> , - <NUM_LIT:0.5> , <NUM_LIT:0.5> ] , <EOL> [ <NUM_LIT:0> , - <NUM_LIT> , <NUM_LIT> ] ] , <EOL> atol = <NUM_LIT> , rtol = <NUM_LIT> ) <EOL> @ suppressed_stdout <EOL> def test_bfgs ( self ) : <EOL> if self . use_wrapper : <EOL> opts = { '<STR_LIT>' : self . maxiter , '<STR_LIT>' : self . disp , <EOL> '<STR_LIT>' : False } <EOL> res = optimize . minimize ( self . func , self . startparams , <EOL> jac = self . grad , method = '<STR_LIT>' , args = ( ) , <EOL> options = opts ) <EOL> params , fopt , gopt , Hopt , func_calls , grad_calls , warnflag = ( <EOL> res [ '<STR_LIT:x>' ] , res [ '<STR_LIT>' ] , res [ '<STR_LIT>' ] , res [ '<STR_LIT>' ] , <EOL> res [ '<STR_LIT>' ] , res [ '<STR_LIT>' ] , res [ '<STR_LIT:status>' ] ) <EOL> else : <EOL> retval = optimize . fmin_bfgs ( self . func , self . startparams , self . grad , <EOL> args = ( ) , maxiter = self . maxiter , <EOL> full_output = True , disp = self . disp , <EOL> retall = False ) <EOL> ( params , fopt , gopt , Hopt , func_calls , grad_calls , warnflag ) = retval <EOL>", "answer": "assert_allclose ( self . func ( params ) , self . func ( self . solution ) ,"}, {"prompt": "<s> try : <EOL> from urllib import urlencode <EOL> except ImportError : <EOL> from urllib . parse import urlencode <EOL> from pyshorteners import Shortener , Shorteners <EOL> from pyshorteners . shorteners import Awsm <EOL> from pyshorteners . exceptions import ( ShorteningErrorException , <EOL> ExpandingErrorException ) <EOL> import responses <EOL> import pytest <EOL> api_key = '<STR_LIT>' <EOL> s = Shortener ( Shorteners . AWSM , api_key = api_key , tool = '<STR_LIT>' ) <EOL> short_url = '<STR_LIT>' <EOL> expanded = '<STR_LIT>' <EOL> @ responses . activate <EOL> def test_awsm_short_method ( ) : <EOL> params = urlencode ( { <EOL> '<STR_LIT:url>' : expanded , <EOL> '<STR_LIT:key>' : api_key , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:v>' : <NUM_LIT:3> <EOL> } ) <EOL> url = '<STR_LIT>' . format ( s . api_url , params ) <EOL> responses . add ( responses . POST , url , body = short_url , match_querystring = True ) <EOL> shorten = s . short ( expanded ) <EOL> assert shorten == short_url <EOL> @ responses . activate <EOL> def test_awsm_short_method_bad_response ( ) : <EOL> url = '<STR_LIT>' . format ( s . api_url ) <EOL> responses . add ( responses . POST , url , body = short_url , status = <NUM_LIT> ) <EOL> with pytest . raises ( ShorteningErrorException ) : <EOL> s . short ( expanded ) <EOL> @ responses . activate <EOL> def test_awsm_expand_method_bad_response ( ) : <EOL> responses . add ( responses . GET , short_url , body = '<STR_LIT>' , status = <NUM_LIT> , <EOL> match_querystring = True ) <EOL>", "answer": "with pytest . raises ( ExpandingErrorException ) :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Static ( )"}, {"prompt": "<s> from __future__ import absolute_import , division , print_function <EOL> from . astropy_table import * <EOL> from . dendrogram import * <EOL> from . excel import * <EOL>", "answer": "from . fits import *"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Tangible ( )"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = - <NUM_LIT:1>"}, {"prompt": "<s> from hazelcast . protocol . codec import multi_map_add_entry_listener_codec , multi_map_add_entry_listener_to_key_codec , multi_map_clear_codec , multi_map_contains_entry_codec , multi_map_contains_key_codec , multi_map_contains_value_codec , multi_map_entry_set_codec , multi_map_force_unlock_codec , multi_map_get_codec , multi_map_is_locked_codec , multi_map_key_set_codec , multi_map_lock_codec , multi_map_put_codec , multi_map_remove_codec , multi_map_remove_entry_codec , multi_map_remove_entry_listener_codec , multi_map_size_codec , multi_map_try_lock_codec , multi_map_unlock_codec , multi_map_value_count_codec , multi_map_values_codec <EOL> from hazelcast . proxy . base import Proxy , EntryEvent , EntryEventType <EOL> from hazelcast . util import check_not_none , thread_id , to_millis <EOL> class MultiMap ( Proxy ) : <EOL> def add_entry_listener ( self , include_value = False , key = None , added = None , removed = None , clear_all = None ) : <EOL> if key : <EOL> key_data = self . _to_data ( key ) <EOL> request = multi_map_add_entry_listener_to_key_codec . encode_request ( name = self . name , key = key_data , <EOL> include_value = include_value , <EOL> local_only = False ) <EOL> else : <EOL> request = multi_map_add_entry_listener_codec . encode_request ( name = self . name , include_value = include_value , <EOL> local_only = False ) <EOL> def handle_event_entry ( ** _kwargs ) : <EOL> event = EntryEvent ( self . _to_object , ** _kwargs ) <EOL> if event . event_type == EntryEventType . added and added : <EOL> added ( event ) <EOL> elif event . event_type == EntryEventType . removed and removed : <EOL> removed ( event ) <EOL> elif event . event_type == EntryEventType . clear_all and clear_all : <EOL> clear_all ( event ) <EOL> return self . _start_listening ( request , <EOL> lambda m : multi_map_add_entry_listener_codec . handle ( m , <EOL> handle_event_entry ) , <EOL> lambda r : multi_map_add_entry_listener_codec . decode_response ( r ) [ <EOL> '<STR_LIT>' ] ) <EOL> def contains_key ( self , key ) : <EOL> check_not_none ( key , \"<STR_LIT>\" ) <EOL> key_data = self . _to_data ( key ) <EOL> return self . _encode_invoke_on_key ( multi_map_contains_key_codec , key_data , key = key_data , <EOL> thread_id = thread_id ( ) ) <EOL> def contains_value ( self , value ) : <EOL> check_not_none ( value , \"<STR_LIT>\" ) <EOL> value_data = self . _to_data ( value ) <EOL> return self . _encode_invoke ( multi_map_contains_value_codec , value = value_data ) <EOL> def contains_entry ( self , key , value ) : <EOL> check_not_none ( key , \"<STR_LIT>\" ) <EOL> check_not_none ( value , \"<STR_LIT>\" ) <EOL> key_data = self . _to_data ( key ) <EOL> value_data = self . _to_data ( value ) <EOL> return self . _encode_invoke_on_key ( multi_map_contains_entry_codec , key_data , key = key_data , <EOL> value = value_data , thread_id = thread_id ( ) ) <EOL> def clear ( self ) : <EOL> return self . _encode_invoke ( multi_map_clear_codec ) <EOL> def entry_set ( self ) : <EOL> return self . _encode_invoke ( multi_map_entry_set_codec ) <EOL> def get ( self , key ) : <EOL> check_not_none ( key , \"<STR_LIT>\" ) <EOL> key_data = self . _to_data ( key ) <EOL> return self . _encode_invoke_on_key ( multi_map_get_codec , key_data , key = key_data , <EOL> thread_id = thread_id ( ) ) <EOL> def is_locked ( self , key ) : <EOL> check_not_none ( key , \"<STR_LIT>\" ) <EOL> key_data = self . _to_data ( key ) <EOL> return self . _encode_invoke_on_key ( multi_map_is_locked_codec , key_data , key = key_data ) <EOL> def force_unlock ( self , key ) : <EOL> check_not_none ( key , \"<STR_LIT>\" ) <EOL> key_data = self . _to_data ( key ) <EOL> return self . _encode_invoke_on_key ( multi_map_force_unlock_codec , key_data , key = key_data ) <EOL> def key_set ( self ) : <EOL>", "answer": "return self . _encode_invoke ( multi_map_key_set_codec )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> from django . conf import settings <EOL> try : <EOL> from html . parser import HTMLParser <EOL> except ImportError : <EOL> from HTMLParser import HTMLParser <EOL> try : <EOL> from bs4 import BeautifulSoup <EOL> except ImportError : <EOL> sys . stderr . write ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> def BeautifulSoup ( x , y ) : <EOL> return x <EOL> class HTML2PlainParser ( HTMLParser ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> try : <EOL> super ( HTML2PlainParser , self ) . __init__ ( ) <EOL> except TypeError : <EOL> self . reset ( ) <EOL> self . text = '<STR_LIT>' <EOL> self . links = [ ] <EOL> self . ignored_elements = getattr ( <EOL> settings , '<STR_LIT>' , <EOL> [ '<STR_LIT:html>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:title>' , '<STR_LIT>' ] <EOL> ) <EOL> self . newline_before_elements = getattr ( <EOL> settings , '<STR_LIT>' , <EOL> [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:p>' , '<STR_LIT>' ] <EOL> ) <EOL> self . newline_after_elements = getattr ( <EOL> settings , '<STR_LIT>' , <EOL> [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:p>' , '<STR_LIT>' ] <EOL> ) <EOL> self . stroke_before_elements = getattr ( <EOL> settings , '<STR_LIT>' , <EOL> [ '<STR_LIT>' ] <EOL> ) <EOL> self . stroke_after_elements = getattr ( <EOL> settings , '<STR_LIT>' , <EOL> [ '<STR_LIT>' ] <EOL> ) <EOL> self . stroke_text = getattr ( settings , '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> def handle_starttag ( self , tag , attrs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ( tag in self . newline_before_elements ) : <EOL> self . text += '<STR_LIT:\\n>' <EOL> if ( tag in self . stroke_before_elements and not <EOL> self . text . endswith ( self . stroke_text ) ) : <EOL> self . text += self . stroke_text <EOL> if tag == '<STR_LIT:a>' : <EOL>", "answer": "for attr in attrs :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import unittest <EOL> import random <EOL> from openmdao . lib . doegenerators . uniform import Uniform <EOL> class TestCase ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> random . seed ( <NUM_LIT:10> ) <EOL> def test_num_cases ( self ) : <EOL> uni = Uniform ( <NUM_LIT:10> ) <EOL> uni . num_parameters = <NUM_LIT:3> <EOL> cases = [ case for case in uni ] <EOL> expected = <NUM_LIT:10> * [ [ <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> ] ] <EOL> self . assertEqual ( len ( expected ) , len ( cases ) ) <EOL> self . assertEqual ( len ( expected [ <NUM_LIT:0> ] ) , len ( cases [ <NUM_LIT:0> ] ) ) <EOL> cases = [ case for case in uni ] <EOL> self . assertEqual ( len ( expected ) , len ( cases ) ) <EOL> self . assertEqual ( len ( expected [ <NUM_LIT:0> ] ) , len ( cases [ <NUM_LIT:0> ] ) ) <EOL> def test_nested_loop ( self ) : <EOL> uni = Uniform ( <NUM_LIT:5> ) <EOL> uni . num_parameters = <NUM_LIT:2> <EOL> inner_count = <NUM_LIT:0> <EOL> outer_count = <NUM_LIT:0> <EOL> for case_outer in uni : <EOL> outer_count += <NUM_LIT:1> <EOL> for case_inner in uni : <EOL> inner_count += <NUM_LIT:1> <EOL> self . assertEqual ( <NUM_LIT:5> , outer_count ) <EOL> self . assertEqual ( <NUM_LIT> , inner_count ) <EOL> def test_low_sample_count ( self ) : <EOL> uni = Uniform ( ) <EOL> uni . num_samples = <NUM_LIT:1> <EOL> try : <EOL> for case in uni : <EOL> pass <EOL> except ValueError as err : <EOL> self . assertEqual ( str ( err ) , \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL>", "answer": "unittest . main ( ) "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import conf <EOL> def is_word ( token ) : <EOL> return not ( token . startswith ( \"<STR_LIT>\" ) or token in conf . PUNCTUATIONS ) <EOL> def is_pause ( token ) : <EOL> return token . startswith ( \"<STR_LIT>\" ) <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL> assert len ( sys . argv ) > <NUM_LIT:1> , \"<STR_LIT>\" <EOL> file_path = sys . argv [ <NUM_LIT:1> ] <EOL> with open ( file_path , '<STR_LIT:r>' ) as source : <EOL>", "answer": "with open ( file_path + \"<STR_LIT>\" , '<STR_LIT:w>' ) as target :"}, {"prompt": "<s> from . pandas_vb_common import * <EOL> from pandas . core import common as com <EOL> try : <EOL> from cStringIO import StringIO <EOL> except ImportError : <EOL> from io import StringIO <EOL> try : <EOL> from pandas . util . testing import test_parallel <EOL> have_real_test_parallel = True <EOL> except ImportError : <EOL> have_real_test_parallel = False <EOL> def test_parallel ( num_threads = <NUM_LIT:1> ) : <EOL> def wrapper ( fname ) : <EOL> return fname <EOL> return wrapper <EOL> class nogil_groupby_count_2 ( object ) : <EOL> goal_time = <NUM_LIT> <EOL> def setup ( self ) : <EOL> self . N = <NUM_LIT> <EOL> self . ngroups = <NUM_LIT:1000> <EOL> np . random . seed ( <NUM_LIT> ) <EOL> self . df = DataFrame ( { '<STR_LIT:key>' : np . random . randint ( <NUM_LIT:0> , self . ngroups , size = self . N ) , '<STR_LIT:data>' : np . random . randn ( self . N ) , } ) <EOL> if ( not have_real_test_parallel ) : <EOL> raise NotImplementedError <EOL> def time_nogil_groupby_count_2 ( self ) : <EOL> self . pg2 ( ) <EOL> @ test_parallel ( num_threads = <NUM_LIT:2> ) <EOL> def pg2 ( self ) : <EOL> self . df . groupby ( '<STR_LIT:key>' ) [ '<STR_LIT:data>' ] . count ( ) <EOL> class nogil_groupby_last_2 ( object ) : <EOL> goal_time = <NUM_LIT> <EOL> def setup ( self ) : <EOL> self . N = <NUM_LIT> <EOL> self . ngroups = <NUM_LIT:1000> <EOL> np . random . seed ( <NUM_LIT> ) <EOL> self . df = DataFrame ( { '<STR_LIT:key>' : np . random . randint ( <NUM_LIT:0> , self . ngroups , size = self . N ) , '<STR_LIT:data>' : np . random . randn ( self . N ) , } ) <EOL> if ( not have_real_test_parallel ) : <EOL> raise NotImplementedError <EOL> def time_nogil_groupby_last_2 ( self ) : <EOL> self . pg2 ( ) <EOL> @ test_parallel ( num_threads = <NUM_LIT:2> ) <EOL> def pg2 ( self ) : <EOL> self . df . groupby ( '<STR_LIT:key>' ) [ '<STR_LIT:data>' ] . last ( ) <EOL> class nogil_groupby_max_2 ( object ) : <EOL> goal_time = <NUM_LIT> <EOL> def setup ( self ) : <EOL> self . N = <NUM_LIT> <EOL> self . ngroups = <NUM_LIT:1000> <EOL> np . random . seed ( <NUM_LIT> ) <EOL> self . df = DataFrame ( { '<STR_LIT:key>' : np . random . randint ( <NUM_LIT:0> , self . ngroups , size = self . N ) , '<STR_LIT:data>' : np . random . randn ( self . N ) , } ) <EOL> if ( not have_real_test_parallel ) : <EOL> raise NotImplementedError <EOL> def time_nogil_groupby_max_2 ( self ) : <EOL> self . pg2 ( ) <EOL> @ test_parallel ( num_threads = <NUM_LIT:2> ) <EOL> def pg2 ( self ) : <EOL> self . df . groupby ( '<STR_LIT:key>' ) [ '<STR_LIT:data>' ] . max ( ) <EOL> class nogil_groupby_mean_2 ( object ) : <EOL> goal_time = <NUM_LIT> <EOL> def setup ( self ) : <EOL> self . N = <NUM_LIT> <EOL> self . ngroups = <NUM_LIT:1000> <EOL> np . random . seed ( <NUM_LIT> ) <EOL> self . df = DataFrame ( { '<STR_LIT:key>' : np . random . randint ( <NUM_LIT:0> , self . ngroups , size = self . N ) , '<STR_LIT:data>' : np . random . randn ( self . N ) , } ) <EOL> if ( not have_real_test_parallel ) : <EOL> raise NotImplementedError <EOL> def time_nogil_groupby_mean_2 ( self ) : <EOL> self . pg2 ( ) <EOL> @ test_parallel ( num_threads = <NUM_LIT:2> ) <EOL> def pg2 ( self ) : <EOL> self . df . groupby ( '<STR_LIT:key>' ) [ '<STR_LIT:data>' ] . mean ( ) <EOL> class nogil_groupby_min_2 ( object ) : <EOL> goal_time = <NUM_LIT> <EOL> def setup ( self ) : <EOL> self . N = <NUM_LIT> <EOL> self . ngroups = <NUM_LIT:1000> <EOL> np . random . seed ( <NUM_LIT> ) <EOL> self . df = DataFrame ( { '<STR_LIT:key>' : np . random . randint ( <NUM_LIT:0> , self . ngroups , size = self . N ) , '<STR_LIT:data>' : np . random . randn ( self . N ) , } ) <EOL> if ( not have_real_test_parallel ) : <EOL> raise NotImplementedError <EOL> def time_nogil_groupby_min_2 ( self ) : <EOL> self . pg2 ( ) <EOL> @ test_parallel ( num_threads = <NUM_LIT:2> ) <EOL> def pg2 ( self ) : <EOL> self . df . groupby ( '<STR_LIT:key>' ) [ '<STR_LIT:data>' ] . min ( ) <EOL> class nogil_groupby_prod_2 ( object ) : <EOL> goal_time = <NUM_LIT> <EOL> def setup ( self ) : <EOL> self . N = <NUM_LIT> <EOL> self . ngroups = <NUM_LIT:1000> <EOL> np . random . seed ( <NUM_LIT> ) <EOL> self . df = DataFrame ( { '<STR_LIT:key>' : np . random . randint ( <NUM_LIT:0> , self . ngroups , size = self . N ) , '<STR_LIT:data>' : np . random . randn ( self . N ) , } ) <EOL> if ( not have_real_test_parallel ) : <EOL> raise NotImplementedError <EOL> def time_nogil_groupby_prod_2 ( self ) : <EOL> self . pg2 ( ) <EOL> @ test_parallel ( num_threads = <NUM_LIT:2> ) <EOL> def pg2 ( self ) : <EOL> self . df . groupby ( '<STR_LIT:key>' ) [ '<STR_LIT:data>' ] . prod ( ) <EOL> class nogil_groupby_sum_2 ( object ) : <EOL> goal_time = <NUM_LIT> <EOL> def setup ( self ) : <EOL> self . N = <NUM_LIT> <EOL> self . ngroups = <NUM_LIT:1000> <EOL> np . random . seed ( <NUM_LIT> ) <EOL> self . df = DataFrame ( { '<STR_LIT:key>' : np . random . randint ( <NUM_LIT:0> , self . ngroups , size = self . N ) , '<STR_LIT:data>' : np . random . randn ( self . N ) , } ) <EOL> if ( not have_real_test_parallel ) : <EOL> raise NotImplementedError <EOL> def time_nogil_groupby_sum_2 ( self ) : <EOL> self . pg2 ( ) <EOL> @ test_parallel ( num_threads = <NUM_LIT:2> ) <EOL> def pg2 ( self ) : <EOL> self . df . groupby ( '<STR_LIT:key>' ) [ '<STR_LIT:data>' ] . sum ( ) <EOL> class nogil_groupby_sum_4 ( object ) : <EOL> goal_time = <NUM_LIT> <EOL> def setup ( self ) : <EOL> self . N = <NUM_LIT> <EOL> self . ngroups = <NUM_LIT:1000> <EOL> np . random . seed ( <NUM_LIT> ) <EOL> self . df = DataFrame ( { '<STR_LIT:key>' : np . random . randint ( <NUM_LIT:0> , self . ngroups , size = self . N ) , '<STR_LIT:data>' : np . random . randn ( self . N ) , } ) <EOL> if ( not have_real_test_parallel ) : <EOL> raise NotImplementedError <EOL> def time_nogil_groupby_sum_4 ( self ) : <EOL> self . pg4 ( ) <EOL> def f ( self ) : <EOL> self . df . groupby ( '<STR_LIT:key>' ) [ '<STR_LIT:data>' ] . sum ( ) <EOL> def g2 ( self ) : <EOL> for i in range ( <NUM_LIT:2> ) : <EOL> self . f ( ) <EOL> def g4 ( self ) : <EOL> for i in range ( <NUM_LIT:4> ) : <EOL> self . f ( ) <EOL> def g8 ( self ) : <EOL> for i in range ( <NUM_LIT:8> ) : <EOL> self . f ( ) <EOL> @ test_parallel ( num_threads = <NUM_LIT:2> ) <EOL> def pg2 ( self ) : <EOL> self . f ( ) <EOL> @ test_parallel ( num_threads = <NUM_LIT:4> ) <EOL> def pg4 ( self ) : <EOL> self . f ( ) <EOL> @ test_parallel ( num_threads = <NUM_LIT:8> ) <EOL> def pg8 ( self ) : <EOL> self . f ( ) <EOL> class nogil_groupby_sum_8 ( object ) : <EOL> goal_time = <NUM_LIT> <EOL> def setup ( self ) : <EOL> self . N = <NUM_LIT> <EOL> self . ngroups = <NUM_LIT:1000> <EOL> np . random . seed ( <NUM_LIT> ) <EOL> self . df = DataFrame ( { '<STR_LIT:key>' : np . random . randint ( <NUM_LIT:0> , self . ngroups , size = self . N ) , '<STR_LIT:data>' : np . random . randn ( self . N ) , } ) <EOL> if ( not have_real_test_parallel ) : <EOL> raise NotImplementedError <EOL> def time_nogil_groupby_sum_8 ( self ) : <EOL>", "answer": "self . pg8 ( )"}, {"prompt": "<s> from datetime import datetime <EOL> from django . conf import settings <EOL> from django . core . servers . basehttp import WSGIRequestHandler <EOL> try : <EOL> from django . db import connections <EOL> except ImportError : <EOL> from django . db import connection <EOL> connections = { '<STR_LIT:default>' : connection } <EOL> from devserver . utils . time import ms_from_timedelta <EOL> class SlimWSGIRequestHandler ( WSGIRequestHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def handle ( self , * args , ** kwargs ) : <EOL> self . _start_request = datetime . now ( ) <EOL> return WSGIRequestHandler . handle ( self , * args , ** kwargs ) <EOL> def get_environ ( self ) : <EOL> env = super ( SlimWSGIRequestHandler , self ) . get_environ ( ) <EOL> env [ '<STR_LIT>' ] = self . client_address [ - <NUM_LIT:1> ] <EOL> return env <EOL> def log_message ( self , format , * args ) : <EOL> duration = datetime . now ( ) - self . _start_request <EOL> env = self . get_environ ( ) <EOL> for url in ( getattr ( settings , '<STR_LIT>' , None ) , settings . MEDIA_URL ) : <EOL> if not url : <EOL>", "answer": "continue"}, {"prompt": "<s> import sublime <EOL>", "answer": "class NoSettingException ( Exception ) :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Building ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "<s> import devon . log , devon . jump , devon . test <EOL> import devon . makers . python , devon . makers . link <EOL> import devon . stream <EOL> from devon . tags import * <EOL> import os . path , sys , types <EOL> disabledLogsFilePath = devon . log . getLogPath ( \"<STR_LIT>\" ) <EOL> catalogInputFilePath = devon . log . getLogPath ( \"<STR_LIT>\" ) <EOL> catalogOutputFilePath = devon . log . getLogPath ( \"<STR_LIT>\" ) <EOL> def wrapArgs ( args ) : <EOL> if sys . platform == \"<STR_LIT:win32>\" : <EOL> for i in range ( len ( args ) ) : <EOL> if ( args [ i ] . find ( \"<STR_LIT:U+0020>\" ) != - <NUM_LIT:1> ) : <EOL> args [ i ] = \"<STR_LIT>\" % args [ i ] <EOL> return args <EOL> def runProjectExecutable ( project , exeName = None , disabledLogs = None , debugger = False , out = None ) : <EOL> if not out : <EOL> out = devon . stream . OutStream ( sys . stdout ) <EOL> if disabledLogs : <EOL> writeDisabledLogs ( project , disabledLogs ) <EOL> handler = TestPrintHandler ( project , out ) <EOL> if not exeName : <EOL> if project . defaultProject : <EOL> defaultProject = project . getChildProject ( project . defaultProject ) <EOL> if defaultProject : <EOL> exeName = defaultProject . getBuildTarget ( ) <EOL> if exeName : <EOL> out << Header ( level = <NUM_LIT:1> ) << \"<STR_LIT>\" % os . path . basename ( exeName ) << Close << Flush <EOL> runCommand ( exeName , [ ] , handler , project , debugger , out ) <EOL> if not handler . exitSucceeded : <EOL> out << Block ( \"<STR_LIT>\" ) << \"<STR_LIT>\" << Close <EOL> elif handler . testErrorCount == <NUM_LIT:0> : <EOL> out << Block ( \"<STR_LIT>\" ) << \"<STR_LIT>\" << Close <EOL> else : <EOL> out << Block ( \"<STR_LIT>\" ) << \"<STR_LIT>\" << Close <EOL> def runProjectPython ( project , exeName = None , disabledLogs = None , debugger = False , out = None ) : <EOL> if not out : <EOL> out = devon . stream . OutStream ( sys . stdout ) <EOL> if disabledLogs : <EOL> writeDisabledLogs ( project , disabledLogs ) <EOL> if exeName : <EOL> out << Header ( level = <NUM_LIT:1> ) << \"<STR_LIT>\" % exeName << Close << Flush <EOL> runner = PythonTestRunner ( project ) <EOL> success = runner . run ( exeName , debugger , out ) <EOL> if not success : <EOL> out << Block ( \"<STR_LIT>\" ) << \"<STR_LIT>\" << Close <EOL> else : <EOL> out << Block ( \"<STR_LIT>\" ) << \"<STR_LIT>\" << Close <EOL> def runProjectTests ( project , targetName , disabledLogs , debugger , out ) : <EOL> if disabledLogs : <EOL> writeDisabledLogs ( project , disabledLogs ) <EOL> out << Header ( level = <NUM_LIT:1> ) << \"<STR_LIT>\" << Close << Flush <EOL> testRunners = getProjectTestRunners ( project ) <EOL> if targetName : <EOL> targetNames = targetName . split ( \"<STR_LIT:/>\" ) <EOL> targetNameRoot = targetNames [ <NUM_LIT:0> ] <EOL> targetNameBase = \"<STR_LIT:/>\" . join ( targetNames [ <NUM_LIT:1> : ] ) <EOL> testRunners = [ runner for runner in testRunners if pathToTestId ( runner . project . path ) == targetNameRoot ] <EOL> else : <EOL> targetNameBase = \"<STR_LIT>\" <EOL> testErrorCount = <NUM_LIT:0> <EOL> exitSucceeded = True <EOL> for testRunner in testRunners : <EOL> testErrorCount , exitSucceeded = testRunner . runTests ( out , targetNameBase , debugger ) <EOL> if not exitSucceeded : <EOL> out << Block ( \"<STR_LIT>\" ) << \"<STR_LIT>\" << Close <EOL> elif testErrorCount == <NUM_LIT:0> : <EOL> out << Block ( \"<STR_LIT>\" ) << \"<STR_LIT>\" << Close <EOL> else : <EOL> out << Block ( \"<STR_LIT>\" ) << \"<STR_LIT>\" << Close <EOL> def writeProjectCatalog ( project , out ) : <EOL> def writeProject ( project , out , alwaysWrite = False ) : <EOL> if not alwaysWrite : <EOL> alwaysWrite = project . build is not None <EOL> if not alwaysWrite : <EOL> for childProject in project . getChildProjects ( True ) : <EOL> if childProject . build : <EOL> alwaysWrite = True <EOL> break <EOL> for childProject in project . getChildProjects ( False ) : <EOL> shouldWrite = alwaysWrite or childProject . dist <EOL> if shouldWrite : <EOL> title = os . path . basename ( childProject . path ) <EOL> path = childProject . path . replace ( \"<STR_LIT:\\\\>\" , \"<STR_LIT:/>\" ) <EOL> out << '<STR_LIT>' % ( title , path ) <EOL> writeProject ( childProject , out ) <EOL> if shouldWrite : <EOL> out << '<STR_LIT>' << Flush <EOL> out << '<STR_LIT:[>' <EOL> writeProject ( project , out , True ) <EOL> out << '<STR_LIT>' <EOL> def writeProjectLogCatalog ( project , out ) : <EOL> out << \"<STR_LIT>\" <EOL> testRunners = getProjectTestRunners ( project ) <EOL> for testRunner in testRunners : <EOL> testRunner . writeLogCatalog ( out ) <EOL> out << \"<STR_LIT>\" <EOL> def writeProjectTestCatalog ( project , out ) : <EOL> out << \"<STR_LIT>\" <EOL> writeProjectExecutablePaths ( project , out ) <EOL> testRunners = getProjectTestRunners ( project ) <EOL> for testRunner in testRunners : <EOL> testRunner . writeTestCatalog ( out ) <EOL> out << \"<STR_LIT>\" <EOL> def writeDisabledLogs ( project , disabledLogs ) : <EOL> for childProject in project . getChildProjects ( ) : <EOL> if isinstance ( childProject . build , devon . makers . link . Link ) : <EOL> linkCommand = devon . makers . link . LinkTestRunner ( ) <EOL> commandName = linkCommand . getTarget ( childProject ) <EOL> buildPath = childProject . getBuildPath ( commandName ) <EOL> logsFile = file ( disabledLogsFilePath , \"<STR_LIT:w>\" ) <EOL> for logName in disabledLogs : <EOL> logsFile . write ( logName + \"<STR_LIT:\\n>\" ) <EOL> logsFile . close ( ) <EOL> def writeProjectExecutablePaths ( project , out ) : <EOL> for childProject in project . getChildProjects ( ) : <EOL> if isinstance ( childProject . build , devon . makers . link . LinkExecutable ) : <EOL> commandPath = childProject . getBuildTarget ( ) <EOL> if commandPath : <EOL> name = os . path . basename ( commandPath ) <EOL> handler = TestCatalogPrintHandler ( childProject , out ) <EOL> handler . declareTest ( \"<STR_LIT:%s>\" % childProject . name , id = \"<STR_LIT>\" ) <EOL> handler . declareTest ( name , id = \"<STR_LIT>\" % commandPath ) <EOL> handler . endDeclareTest ( ) <EOL> handler . endDeclareTest ( ) <EOL> elif isinstance ( childProject . build , devon . makers . python . PythonModules ) : <EOL> handler = TestCatalogPrintHandler ( childProject , out ) <EOL> handler . declareTest ( \"<STR_LIT:%s>\" % childProject . name , id = \"<STR_LIT>\" ) <EOL> for name in childProject . pythonExes : <EOL> handler . declareTest ( name , id = \"<STR_LIT>\" % name , testType = devon . test . ExeType ) <EOL> handler . endDeclareTest ( ) <EOL> handler . endDeclareTest ( ) <EOL> writeProjectExecutablePaths ( childProject , out ) <EOL> def getProjectTestRunners ( project , testRunners = None ) : <EOL> if not testRunners : <EOL> testRunners = [ ] <EOL> if isinstance ( project . build , devon . makers . link . Link ) : <EOL> testRunner = ExeTestRunner ( project ) <EOL> testRunners . append ( testRunner ) <EOL> elif isinstance ( project . build , devon . makers . python . PythonModules ) : <EOL> testRunner = PythonTestRunner ( project ) <EOL> testRunners . append ( testRunner ) <EOL> for childProject in project . getChildProjects ( ) : <EOL> testRunners = getProjectTestRunners ( childProject , testRunners ) <EOL> return testRunners <EOL> def runCommand ( commandPath , args , handler , project , debugger , out ) : <EOL> pyEnv = initPythonEnvironment ( project ) <EOL> print \"<STR_LIT>\" % ( commandPath , \"<STR_LIT:U+0020>\" . join ( args ) ) <EOL> reader = devon . log . LogReader ( commandPath , args , debugger = debugger ) <EOL> if not reader . pid : <EOL> return <EOL> out << Script << ( \"<STR_LIT>\" % reader . pid ) << Close <EOL> reader . process ( handler ) <EOL> out << Script << ( \"<STR_LIT>\" % reader . pid ) << Close <EOL> restorePythonEnvironment ( pyEnv ) <EOL> def initPythonEnvironment ( project ) : <EOL> if sys . platform == \"<STR_LIT:win32>\" : <EOL> delim = \"<STR_LIT:;>\" <EOL> prevPyPath = os . getenv ( \"<STR_LIT>\" ) or \"<STR_LIT>\" <EOL> else : <EOL> delim = \"<STR_LIT::>\" <EOL> prevPyPath = os . getenv ( \"<STR_LIT>\" ) or \"<STR_LIT>\" <EOL> prevPyPath = \"<STR_LIT>\" <EOL> pyPath = prevPyPath <EOL> for path in [ \"<STR_LIT:..>\" ] + project . pythonPaths : <EOL> expandedPath = project . expandString ( path ) <EOL> absPath = os . path . abspath ( os . path . join ( project . path , expandedPath ) ) <EOL> pyPath += \"<STR_LIT>\" % ( delim , absPath ) <EOL> print \"<STR_LIT>\" % pyPath <EOL> os . putenv ( \"<STR_LIT>\" , pyPath ) <EOL> return prevPyPath <EOL> def restorePythonEnvironment ( prevPyPath ) : <EOL> os . putenv ( \"<STR_LIT>\" , prevPyPath ) <EOL> def getPythonPath ( project ) : <EOL> if hasattr ( project . config , \"<STR_LIT>\" ) : <EOL> pythonPath = pythonPathDebug = project . config . pythonBin <EOL> elif sys . platform == \"<STR_LIT:win32>\" : <EOL> pythonPath = \"<STR_LIT>\" <EOL> pythonPathDebug = \"<STR_LIT>\" <EOL> else : <EOL> pythonPath = \"<STR_LIT>\" <EOL> pythonPathDebug = \"<STR_LIT>\" <EOL> if project . debug : <EOL> return pythonPathDebug <EOL> return pythonPath <EOL> class ExeTestRunner : <EOL> def __init__ ( self , project ) : <EOL> self . project = project <EOL> def getCommandPath ( self ) : <EOL> linkCommand = devon . makers . link . LinkTestRunner ( ) <EOL> commandName = linkCommand . getTarget ( self . project ) <EOL> buildPath = self . project . getBuildPath ( commandName ) <EOL> return buildPath <EOL> def writeLogCatalog ( self , out ) : <EOL> commandPath = self . getCommandPath ( ) <EOL> args = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> if not os . path . exists ( commandPath ) : <EOL> return <EOL> reader = devon . log . LogReader ( commandPath , args ) <EOL> if not reader . pid : <EOL> return <EOL> handler = LogCatalogPrintHandler ( self . project , out ) <EOL> projectName = getProjectTargetName ( self . project ) <EOL> handler . declareProject ( projectName ) <EOL> reader . process ( handler ) <EOL> def writeTestCatalog ( self , out ) : <EOL> commandPath = self . getCommandPath ( ) <EOL> if not os . path . exists ( commandPath ) : <EOL> return <EOL> args = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> reader = devon . log . LogReader ( commandPath , args , log = catalogOutputFilePath ) <EOL> if not reader . pid : <EOL> return <EOL> handler = TestCatalogPrintHandler ( self . project , out ) <EOL> reader . process ( handler ) <EOL> def runTests ( self , out , targetName , debugger = False ) : <EOL> commandPath = self . getCommandPath ( ) <EOL> handler = TestPrintHandler ( self . project , out ) <EOL> projectId = pathToTestId ( self . project . path ) <EOL> handler . beginTest ( projectId ) <EOL> args = [ ] <EOL> if targetName : <EOL> args += [ \"<STR_LIT>\" , targetName ] <EOL> runCommand ( commandPath , args , handler , self . project , debugger , out ) <EOL> if not handler . exitSucceeded : <EOL> out << Script << '<STR_LIT>' << Close <EOL> handler . endTest ( ) <EOL> return handler . testErrorCount , handler . exitSucceeded <EOL> def run ( self , out ) : <EOL> pass <EOL> class PythonTestRunner ( ExeTestRunner ) : <EOL> def writeLogCatalog ( self , out ) : <EOL> pass <EOL> def writeTestCatalog ( self , out ) : <EOL> pyEnv = initPythonEnvironment ( self . project ) <EOL> moduleName = getProjectTestModule ( self . project ) <EOL> args = wrapArgs ( [ \"<STR_LIT:-c>\" , \"<STR_LIT>\" % moduleName ] ) <EOL> print \"<STR_LIT>\" % ( getPythonPath ( self . project ) , \"<STR_LIT:U+0020>\" . join ( args ) ) <EOL> reader = devon . log . LogReader ( getPythonPath ( self . project ) , args , log = catalogOutputFilePath ) <EOL> if not reader . pid : <EOL> return <EOL> handler = TestCatalogPrintHandler ( self . project , out ) <EOL> reader . process ( handler ) <EOL> restorePythonEnvironment ( pyEnv ) <EOL> def runTests ( self , out , targetName , debugger = False ) : <EOL> pyEnv = initPythonEnvironment ( self . project ) <EOL> if targetName == \"<STR_LIT>\" : <EOL> targetName = getProjectTestModule ( self . project ) <EOL> handler = TestPrintHandler ( self . project , out ) <EOL> projectId = pathToTestId ( self . project . path ) <EOL> handler . beginTest ( projectId ) <EOL> args = wrapArgs ( [ \"<STR_LIT:-c>\" , \"<STR_LIT>\" % targetName ] ) <EOL> print \"<STR_LIT>\" % ( getPythonPath ( self . project ) , \"<STR_LIT:U+0020>\" . join ( args ) ) <EOL> reader = devon . log . LogReader ( getPythonPath ( self . project ) , args , debugger = debugger ) <EOL> if not reader . pid : <EOL> return <EOL> reader . process ( handler ) <EOL> handler . endTest ( ) <EOL> restorePythonEnvironment ( pyEnv ) <EOL> return handler . testErrorCount , handler . exitSucceeded <EOL> def run ( self , name , debugger , out ) : <EOL> exeName , args = self . project . pythonExes [ name ] <EOL> argValues = [ ] <EOL> for value in args : <EOL> if type ( value ) == str : <EOL> value = \"<STR_LIT>\" % value . replace ( \"<STR_LIT:'>\" , \"<STR_LIT>\" ) <EOL> else : <EOL> value = str ( value ) <EOL> argValues . append ( value ) <EOL> testArgs = \"<STR_LIT:U+002C>\" . join ( argValues ) <EOL> handler = TestPrintHandler ( self . project , out ) <EOL> args = wrapArgs ( [ \"<STR_LIT:-c>\" , \"<STR_LIT>\" % ( exeName , testArgs ) ] ) <EOL> wd = os . getcwd ( ) <EOL> os . chdir ( os . path . dirname ( self . project . path ) ) <EOL> runCommand ( getPythonPath ( self . project ) , args , handler , self . project , debugger , out ) <EOL> os . chdir ( wd ) <EOL> return handler . exitSucceeded <EOL> class LogCatalogPrintHandler : <EOL> def __init__ ( self , project , out ) : <EOL> self . project = project <EOL> self . out = out <EOL> def write ( self , text ) : <EOL> pass <EOL> def close ( self ) : <EOL> pass <EOL> def flush ( self ) : <EOL> pass <EOL> def declareProject ( self , name ) : <EOL> self . out << '<STR_LIT>' % ( name ) << Flush <EOL> def declareCategory ( self , name , disabled ) : <EOL> self . out << '<STR_LIT>' % ( name , disabled ) << Flush <EOL> class TestCatalogPrintHandler : <EOL> def __init__ ( self , project , out ) : <EOL> self . project = project <EOL> self . out = out <EOL> self . testStackCount = <NUM_LIT:0> <EOL> self . rootInfo = None <EOL> def write ( self , text ) : <EOL> pass <EOL> def close ( self ) : <EOL> pass <EOL> def flush ( self ) : <EOL> pass <EOL> def declareTest ( self , name , testType = <NUM_LIT:0> , testStatus = \"<STR_LIT>\" , id = None ) : <EOL> self . testStackCount += <NUM_LIT:1> <EOL> testTypeName = devon . test . testTypeNames [ int ( testType ) ] <EOL> if id == None : <EOL> id = name <EOL> if id == \"<STR_LIT>\" : <EOL> projectName = getProjectTargetName ( self . project ) <EOL> name = projectName <EOL> if self . testStackCount == <NUM_LIT:1> : <EOL> projectId = pathToTestId ( self . project . path ) <EOL> id = \"<STR_LIT:/>\" . join ( ( projectId , id ) ) <EOL> self . rootInfo = ( name , id , testTypeName ) <EOL> else : <EOL> if name . find ( \"<STR_LIT>\" ) == len ( name ) - <NUM_LIT:5> : <EOL> name = name [ <NUM_LIT:0> : - <NUM_LIT:5> ] <EOL> elif name . find ( \"<STR_LIT:test>\" ) == <NUM_LIT:0> : <EOL> name = name [ <NUM_LIT:4> : ] <EOL> elif name . find ( \"<STR_LIT>\" ) == <NUM_LIT:0> : <EOL> name = name [ <NUM_LIT:4> : ] <EOL> if self . rootInfo : <EOL> self . out << ( '<STR_LIT>' % self . rootInfo ) << Flush <EOL> self . rootInfo = None <EOL> self . out << '<STR_LIT>' % ( name , id , testTypeName , testStatus ) << Flush <EOL> def endDeclareTest ( self ) : <EOL> self . testStackCount -= <NUM_LIT:1> <EOL> if self . testStackCount == <NUM_LIT:0> : <EOL> if not self . rootInfo : <EOL> self . out << '<STR_LIT>' << Flush <EOL> else : <EOL> self . out << '<STR_LIT>' << Flush <EOL> class TestPrintHandler : <EOL> uniqueId = <NUM_LIT:0> <EOL> def __init__ ( self , project , out ) : <EOL> self . project = project <EOL> self . out = out <EOL> self . testStack = [ ] <EOL> self . loggedStack = [ ] <EOL> self . inText = False <EOL> self . inBlock = <NUM_LIT:0> <EOL> self . testErrorCount = <NUM_LIT:0> <EOL> self . exitSucceeded = False <EOL> def __getUniqueId ( self ) : <EOL> self . uniqueId += <NUM_LIT:1> <EOL> return self . uniqueId <EOL> def checkLooseEnds ( self ) : <EOL> self . checkEndText ( ) <EOL> self . checkTestHeader ( ) <EOL> def checkEndText ( self ) : <EOL> if self . inText : <EOL> self . inText = False <EOL> self . out << Close << Flush <EOL> def checkTestHeader ( self ) : <EOL> if len ( self . loggedStack ) and not self . loggedStack [ - <NUM_LIT:1> ] : <EOL> self . loggedStack [ - <NUM_LIT:1> ] = <NUM_LIT:1> <EOL> id = \"<STR_LIT>\" % \"<STR_LIT:/>\" . join ( self . testStack ) <EOL> self . out << Header ( level = <NUM_LIT:2> , id = id ) << \"<STR_LIT>\" . join ( self . testStack [ <NUM_LIT:1> : ] ) << Close <EOL> def close ( self ) : <EOL> self . checkEndText ( ) <EOL> def flush ( self ) : <EOL> self . out << Flush <EOL> def writeText ( self , text ) : <EOL> self . out . write ( text ) <EOL> def write ( self , text ) : <EOL> if not text : <EOL> return <EOL> if self . inBlock or self . inText : <EOL> self . out << escapeHTML ( text ) << Flush <EOL> else : <EOL> self . checkTestHeader ( ) <EOL> self . out << CodeBlock ( \"<STR_LIT>\" ) << escapeHTML ( text ) << Close << Flush <EOL> def beginBlock ( self , name = \"<STR_LIT>\" ) : <EOL> self . checkLooseEnds ( ) <EOL> self . inBlock += <NUM_LIT:1> <EOL> classes = \"<STR_LIT:U+0020>\" . join ( [ \"<STR_LIT>\" % name for name in name . split ( \"<STR_LIT:U+0020>\" ) ] ) <EOL> self . out << Block ( \"<STR_LIT>\" % classes ) << Flush <EOL> def endBlock ( self ) : <EOL> self . inBlock -= <NUM_LIT:1> <EOL> self . checkLooseEnds ( ) <EOL> self . out << Close << Flush <EOL> def beginRawText ( self ) : <EOL> self . out << CodeBlock ( \"<STR_LIT>\" ) <EOL> def endRawText ( self ) : <EOL> self . out << Close << Flush <EOL>", "answer": "def beginVariable ( self , name = \"<STR_LIT>\" , value = \"<STR_LIT>\" ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def f ( a , b , c ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import logging <EOL> import glob <EOL> import re <EOL> from EOtools . DatasetDrivers import SceneDataset <EOL> from EOtools . execute import execute <EOL> from agdc . cube_util import DatasetError <EOL> from agdc . abstract_ingester import AbstractDataset <EOL> from landsat_bandstack import LandsatBandstack <EOL> LOGGER = logging . getLogger ( __name__ ) <EOL> LOGGER . setLevel ( logging . INFO ) <EOL> class LandsatDataset ( AbstractDataset ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> PROCESSING_LEVEL_ALIASES = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> def __init__ ( self , dataset_path ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _dataset_path = dataset_path <EOL> LOGGER . info ( '<STR_LIT>' , self . _dataset_path ) <EOL> self . _ds = SceneDataset ( default_metadata_required = False , utm_fix = True ) <EOL> self . _ds = self . _ds . Open ( self . get_dataset_path ( ) ) <EOL> if not self . _ds : <EOL> raise DatasetError ( \"<STR_LIT>\" % self . get_dataset_path ( ) ) <EOL> self . _dataset_size = self . _get_directory_size ( ) <EOL> if self . get_processing_level ( ) in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> LOGGER . debug ( '<STR_LIT>' , self . get_dataset_path ( ) ) <EOL> self . _gcp_count = self . _get_gcp_count ( ) <EOL> self . _mtl_text = self . _get_mtl_text ( ) <EOL> else : <EOL> self . _gcp_count = None <EOL> self . _mtl_text = None <EOL> self . _xml_text = self . _get_xml_text ( ) <EOL> AbstractDataset . __init__ ( self ) <EOL> def _get_directory_size ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> command = \"<STR_LIT>\" % self . get_dataset_path ( ) <EOL> LOGGER . debug ( '<STR_LIT>' , command ) <EOL> result = execute ( command ) <EOL> if result [ '<STR_LIT>' ] != <NUM_LIT:0> : <EOL> raise DatasetError ( '<STR_LIT>' + <EOL> '<STR_LIT>' % ( command , result [ '<STR_LIT>' ] ) ) <EOL> LOGGER . debug ( '<STR_LIT>' , result [ '<STR_LIT>' ] ) <EOL> return int ( result [ '<STR_LIT>' ] ) <EOL> def _get_gcp_count ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> gcp_pattern = os . path . join ( self . get_dataset_path ( ) , '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> return self . _extract_from_file ( gcp_pattern , '<STR_LIT>' , <EOL> self . _extract_gcp_count ) <EOL> def _get_mtl_text ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> mtl_pattern = os . path . join ( self . get_dataset_path ( ) , '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> return self . _extract_from_file ( mtl_pattern , '<STR_LIT>' , <EOL> self . _extract_text ) <EOL> def _get_xml_text ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> xml_pattern = os . path . join ( self . get_dataset_path ( ) , '<STR_LIT>' ) <EOL> return self . _extract_from_file ( xml_pattern , '<STR_LIT>' , <EOL> self . _extract_text ) <EOL> @ staticmethod <EOL> def _extract_from_file ( file_pattern , file_description , extract_function ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> md_path = glob . glob ( file_pattern ) [ <NUM_LIT:0> ] <EOL> md_file = open ( md_path ) <EOL> metadata = extract_function ( md_file ) <EOL> md_file . close ( ) <EOL> except IndexError : <EOL> metadata = None <EOL> LOGGER . debug ( '<STR_LIT>' , file_description ) <EOL> except IOError : <EOL> raise DatasetError ( '<STR_LIT>' % file_description ) <EOL> return metadata <EOL> @ staticmethod <EOL> def _extract_text ( md_file ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return md_file . read ( ) <EOL> @ staticmethod <EOL> def _extract_gcp_count ( md_file ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return len ( [ line for line in md_file . readlines ( ) <EOL> if re . match ( r'<STR_LIT>' , line ) ] ) <EOL> def get_dataset_path ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _dataset_path <EOL> def get_satellite_tag ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . satellite . TAG <EOL> def get_sensor_name ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . satellite . sensor <EOL> def get_processing_level ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> level = self . _ds . processor_level <EOL> if level in self . PROCESSING_LEVEL_ALIASES : <EOL> level = self . PROCESSING_LEVEL_ALIASES [ level ] <EOL> return level . upper ( ) <EOL> def get_x_ref ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . path_number <EOL> def get_y_ref ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . row_number <EOL> def get_start_datetime ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> start_dt = self . _ds . scene_alt_start_datetime <EOL> except AttributeError : <EOL> start_dt = None <EOL> if start_dt is None : <EOL> start_dt = self . _ds . scene_start_datetime <EOL> return start_dt <EOL> def get_end_datetime ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> end_dt = self . _ds . scene_alt_end_datetime <EOL> except AttributeError : <EOL> end_dt = None <EOL> if end_dt is None : <EOL> end_dt = self . _ds . scene_end_datetime <EOL> return end_dt <EOL> def get_datetime_processed ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . completion_datetime <EOL> def get_dataset_size ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _dataset_size <EOL> def get_ll_lon ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . ll_lon <EOL> def get_ll_lat ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . ll_lat <EOL> def get_lr_lon ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . lr_lon <EOL> def get_lr_lat ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . lr_lat <EOL> def get_ul_lon ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . ul_lon <EOL> def get_ul_lat ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . ul_lat <EOL> def get_ur_lon ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . ur_lon <EOL> def get_ur_lat ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . ur_lat <EOL> def get_projection ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . GetProjection ( ) <EOL> def get_ll_x ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . ll_x <EOL> def get_ll_y ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . ll_y <EOL> def get_lr_x ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . lr_x <EOL> def get_lr_y ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . lr_y <EOL> def get_ul_x ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . ul_x <EOL> def get_ul_y ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . ul_y <EOL> def get_ur_x ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . ur_x <EOL> def get_ur_y ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . ur_y <EOL> def get_x_pixels ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . image_pixels <EOL> def get_y_pixels ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . image_lines <EOL> def get_gcp_count ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _gcp_count <EOL> def get_mtl_text ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _mtl_text <EOL> def get_cloud_cover ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _ds . cloud_cover_percentage <EOL> def get_xml_text ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _xml_text <EOL> def get_pq_tests_run ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL>", "answer": "pq_tests_run = self . _ds . pq_tests_run"}, {"prompt": "<s> from functools import partial <EOL> from . . import model_index <EOL> from . . import utils <EOL> from . . inline_documentation import Documentation <EOL> from . . goto_cfml_file import GotoCfmlFile <EOL> from . import cfc_utils <EOL> STYLES = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> def get_inline_documentation ( view , position ) : <EOL> project_name = utils . get_project_name ( view ) <EOL> if not project_name : <EOL> return None <EOL> cfc_path , file_path , dot_path , function_name = find_cfc ( view , position , project_name ) <EOL> if file_path : <EOL> if dot_path : <EOL> if function_name : <EOL> metadata = model_index . get_extended_metadata_by_file_path ( project_name , file_path ) <EOL> if function_name in metadata [ \"<STR_LIT>\" ] : <EOL> header = dot_path . split ( \"<STR_LIT:.>\" ) . pop ( ) + \"<STR_LIT:.>\" + metadata [ \"<STR_LIT>\" ] [ function_name ] . name + \"<STR_LIT>\" <EOL> doc , callback = model_index . get_method_documentation ( view , project_name , file_path , function_name , header ) <EOL> return Documentation ( doc , callback , <NUM_LIT:2> ) <EOL> doc , callback = model_index . get_documentation ( view , project_name , file_path , dot_path ) <EOL> return Documentation ( doc , callback , <NUM_LIT:2> ) <EOL> doc , callback = get_documentation ( view , file_path , cfc_path ) <EOL> return Documentation ( doc , callback , <NUM_LIT:2> ) <EOL> return None <EOL> def get_goto_cfml_file ( view , position ) : <EOL> project_name = utils . get_project_name ( view ) <EOL> if not project_name : <EOL> return None <EOL> cfc_path , file_path , dot_path , function_name = find_cfc ( view , position , project_name ) <EOL> if file_path : <EOL> if function_name : <EOL> metadata = model_index . get_extended_metadata_by_file_path ( project_name , file_path ) <EOL> if function_name in metadata [ \"<STR_LIT>\" ] : <EOL> return GotoCfmlFile ( metadata [ \"<STR_LIT>\" ] [ function_name ] , metadata [ \"<STR_LIT>\" ] [ function_name ] . name ) <EOL> else : <EOL> return GotoCfmlFile ( file_path , None ) <EOL> return None <EOL> def on_navigate ( view , file_path , href ) : <EOL> view . window ( ) . open_file ( file_path ) <EOL> def get_documentation ( view , file_path , header ) : <EOL> cfc_doc = dict ( STYLES ) <EOL> cfc_doc [ \"<STR_LIT>\" ] = [ ] <EOL> cfc_doc [ \"<STR_LIT>\" ] = header <EOL> cfc_doc [ \"<STR_LIT:description>\" ] = \"<STR_LIT>\" + file_path + \"<STR_LIT>\" <EOL> callback = partial ( on_navigate , view , file_path ) <EOL> return cfc_doc , callback <EOL> def find_cfc ( view , position , project_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if view . match_selector ( position , \"<STR_LIT>\" ) : <EOL> r = utils . get_scope_region_containing_point ( view , position , \"<STR_LIT>\" ) <EOL> cfc_path = view . substr ( r ) <EOL> file_path , dot_path = get_cfc_file_info ( view , project_name , cfc_path ) <EOL> return cfc_path , file_path , dot_path , None <EOL> if view . match_selector ( position , \"<STR_LIT>\" ) : <EOL> r = utils . get_scope_region_containing_point ( view , position , \"<STR_LIT>\" ) <EOL> cfc_path = cfc_utils . get_component_name ( view . substr ( r ) ) <EOL> file_path , dot_path = get_cfc_file_info ( view , project_name , cfc_path ) <EOL> return cfc_path , file_path , dot_path , None <EOL> if view . match_selector ( position , \"<STR_LIT>\" ) : <EOL> r = utils . get_scope_region_containing_point ( view , position , \"<STR_LIT>\" ) <EOL> cfc_path = view . substr ( r ) [ <NUM_LIT:4> : ] . split ( \"<STR_LIT:(>\" ) [ <NUM_LIT:0> ] <EOL> file_path , dot_path = get_cfc_file_info ( view , project_name , cfc_path ) <EOL> return cfc_path , file_path , dot_path , None <EOL> if view . match_selector ( position , \"<STR_LIT>\" ) : <EOL> cfc_path = view . substr ( view . extract_scope ( position ) ) <EOL> if cfc_path [ <NUM_LIT:0> ] in [ \"<STR_LIT>\" , \"<STR_LIT:'>\" ] : <EOL> cfc_path = cfc_path [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> if cfc_utils . is_cfc_dot_path ( cfc_path ) : <EOL> file_path , dot_path = get_cfc_file_info ( view , project_name , cfc_path ) <EOL> return cfc_path , file_path , dot_path , None <EOL> if view . match_selector ( position , \"<STR_LIT>\" ) : <EOL> function_name , function_name_region , function_args_region = utils . get_function_call ( view , position ) <EOL> if view . substr ( function_name_region . begin ( ) - <NUM_LIT:1> ) == \"<STR_LIT:.>\" : <EOL> dot_context = utils . get_dot_context ( view , function_name_region . begin ( ) - <NUM_LIT:1> ) <EOL> if view . match_selector ( dot_context [ - <NUM_LIT:1> ] . name_region . begin ( ) , \"<STR_LIT>\" ) : <EOL>", "answer": "r = utils . get_scope_region_containing_point ( view , dot_context [ - <NUM_LIT:1> ] . name_region . begin ( ) , \"<STR_LIT>\" )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> try : <EOL> import unittest2 <EOL> except ImportError : <EOL> pass <EOL> else : <EOL> sys . modules [ '<STR_LIT>' ] = unittest2 <EOL> import unittest <EOL> if not hasattr ( unittest , '<STR_LIT>' ) : <EOL> sys . stderr . write ( \"<STR_LIT>\" <EOL>", "answer": "\"<STR_LIT>\""}, {"prompt": "<s> import unittest <EOL> from datetime import date <EOL> from libsaas import http , xml <EOL> from libsaas . executors import test_executor <EOL> from libsaas . services import recurly <EOL> class RecurlyTestCase ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . executor = test_executor . use ( ) <EOL> self . executor . set_response ( <EOL> b'<STR_LIT>' , <NUM_LIT:200> , { } ) <EOL> self . service = recurly . Recurly ( '<STR_LIT>' ) <EOL> def expect ( self , method = None , uri = None , params = None , headers = None ) : <EOL> if method : <EOL> self . assertEqual ( method , self . executor . request . method ) <EOL> if uri : <EOL> self . assertEqual ( self . executor . request . uri , <EOL> '<STR_LIT>' + uri ) <EOL> if params : <EOL> self . assertEqual ( self . executor . request . params , params ) <EOL> if headers : <EOL> for key , val in headers . items ( ) : <EOL> self . assertEqual ( self . executor . request . headers [ key ] , val ) <EOL> def test_accounts ( self ) : <EOL> self . service . accounts ( ) . get ( per_page = <NUM_LIT:3> ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT:state>' : '<STR_LIT>' , '<STR_LIT>' : <NUM_LIT:3> } ) <EOL> self . service . accounts ( ) . get ( state = '<STR_LIT>' ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT:state>' : '<STR_LIT>' } ) <EOL> self . service . account ( <NUM_LIT:3> ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> self . service . account ( <NUM_LIT:3> ) . adjustments ( ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> self . service . account ( <NUM_LIT:3> ) . adjustments ( ) . get ( state = '<STR_LIT>' ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT:state>' : '<STR_LIT>' } ) <EOL> self . service . account ( <NUM_LIT:3> ) . adjustments ( ) . get ( type = '<STR_LIT>' ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT:type>' : '<STR_LIT>' } ) <EOL> self . service . account ( <NUM_LIT:3> ) . invoices ( ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> self . service . account ( <NUM_LIT:3> ) . invoices ( ) . get ( per_page = <NUM_LIT> ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT>' : <NUM_LIT> } ) <EOL> self . service . account ( <NUM_LIT:3> ) . subscriptions ( ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> self . service . account ( <NUM_LIT:3> ) . subscriptions ( ) . get ( per_page = <NUM_LIT> ) <EOL> self . expect ( <EOL> '<STR_LIT:GET>' , '<STR_LIT>' , <EOL> { '<STR_LIT>' : <NUM_LIT> , '<STR_LIT:state>' : '<STR_LIT>' } ) <EOL> self . service . account ( <NUM_LIT:3> ) . subscriptions ( ) . get ( state = '<STR_LIT>' ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT:state>' : '<STR_LIT>' } ) <EOL> self . service . account ( <NUM_LIT:3> ) . billing_info ( ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> self . service . account ( <NUM_LIT:3> ) . redemption ( ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> self . service . accounts ( ) . create ( { '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT:x>' } } ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , <EOL> xml . dict_to_xml ( { '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT:x>' } } ) ) <EOL> self . service . account ( <NUM_LIT> ) . update ( { '<STR_LIT>' : { '<STR_LIT:username>' : '<STR_LIT:x>' } } ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , <EOL> xml . dict_to_xml ( { '<STR_LIT>' : { '<STR_LIT:username>' : '<STR_LIT:x>' } } ) ) <EOL> self . service . account ( <NUM_LIT> ) . adjustments ( ) . create ( { <EOL> '<STR_LIT>' : { '<STR_LIT:x>' : '<STR_LIT:x>' } <EOL> } ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , <EOL> xml . dict_to_xml ( { '<STR_LIT>' : { '<STR_LIT:x>' : '<STR_LIT:x>' } } ) ) <EOL> self . service . account ( <NUM_LIT> ) . invoices ( ) . create ( { <EOL> '<STR_LIT>' : { '<STR_LIT>' : [ { <EOL> '<STR_LIT>' : { '<STR_LIT:x>' : '<STR_LIT:a>' } } , { '<STR_LIT>' : { '<STR_LIT:x>' : '<STR_LIT:b>' } <EOL> } ] <EOL> } } ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , <EOL> xml . dict_to_xml ( { <EOL> '<STR_LIT>' : { '<STR_LIT>' : [ { <EOL> '<STR_LIT>' : { '<STR_LIT:x>' : '<STR_LIT:a>' } } , { '<STR_LIT>' : { '<STR_LIT:x>' : '<STR_LIT:b>' } } <EOL> ] } <EOL> } ) ) <EOL> self . service . account ( <NUM_LIT> ) . billing_info ( ) . update ( { <EOL> '<STR_LIT>' : { '<STR_LIT:x>' : '<STR_LIT:x>' } <EOL> } ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' , <EOL> xml . dict_to_xml ( { '<STR_LIT>' : { '<STR_LIT:x>' : '<STR_LIT:x>' } } ) ) <EOL> self . service . account ( <NUM_LIT> ) . billing_info ( ) . delete ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . service . account ( <NUM_LIT> ) . redemption ( ) . create ( { <EOL> '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT:x>' } <EOL> } ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , <EOL> xml . dict_to_xml ( { '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT:x>' } } ) ) <EOL> self . service . account ( <NUM_LIT> ) . redemption ( ) . delete ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . service . account ( <NUM_LIT> ) . delete ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def test_adjustments ( self ) : <EOL> self . service . adjustment ( '<STR_LIT>' ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> self . service . adjustment ( '<STR_LIT>' ) . delete ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def test_coupons ( self ) : <EOL> self . service . coupons ( ) . get ( per_page = <NUM_LIT:3> ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT>' : <NUM_LIT:3> } ) <EOL> self . service . coupons ( ) . get ( state = '<STR_LIT>' ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT:state>' : '<STR_LIT>' } ) <EOL> self . service . coupon ( '<STR_LIT>' ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> self . service . coupons ( ) . create ( { '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT:x>' } } ) <EOL> self . expect ( '<STR_LIT:POST>' , '<STR_LIT>' , <EOL> xml . dict_to_xml ( { '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT:x>' } } ) ) <EOL> self . service . coupon ( '<STR_LIT>' ) . delete ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def test_invoices ( self ) : <EOL> self . service . invoices ( ) . get ( per_page = <NUM_LIT:3> ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT>' : <NUM_LIT:3> } ) <EOL> self . service . invoices ( ) . get ( state = '<STR_LIT>' ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { '<STR_LIT:state>' : '<STR_LIT>' } ) <EOL> self . service . invoice ( '<STR_LIT>' ) . get ( ) <EOL> self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' ) <EOL> self . service . invoice ( '<STR_LIT>' ) . mark_successful ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . service . invoice ( '<STR_LIT>' ) . mark_failed ( ) <EOL> self . expect ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> blob = b'<STR_LIT>' <EOL> self . executor . set_response ( blob , <NUM_LIT:200> , { } ) <EOL> ret = self . service . invoice ( '<STR_LIT>' ) . get_pdf ( language = '<STR_LIT>' ) <EOL>", "answer": "self . expect ( '<STR_LIT:GET>' , '<STR_LIT>' , { } ,"}, {"prompt": "<s> from OSLTestCase import OSLTestCase <EOL> from OSLShaderTest import OSLShaderTest <EOL> from OSLRendererTest import OSLRendererTest <EOL>", "answer": "from OSLImageTest import OSLImageTest"}, {"prompt": "<s> import sys <EOL> import os <EOL> import json <EOL> import webbrowser <EOL> from collections import defaultdict <EOL> import sublime_plugin <EOL> import sublime <EOL> PY2 = sys . version_info < ( <NUM_LIT:3> , <NUM_LIT:0> ) <EOL> try : <EOL> from . floo import sublime_ui <EOL> from . floo . common import api , reactor , msg , shared as G , utils <EOL> from . floo . common . exc_fmt import str_e <EOL> assert api and G and msg and utils <EOL> except ( ImportError , ValueError ) : <EOL> from floo import sublime_ui <EOL> from floo . common import reactor , msg , shared as G , utils <EOL> from floo . common . exc_fmt import str_e <EOL> reactor = reactor . reactor <EOL> SublimeUI = sublime_ui . SublimeUI ( ) <EOL> def disconnect_dialog ( ) : <EOL> if G . AGENT and G . AGENT . joined_workspace : <EOL> disconnect = sublime . ok_cancel_dialog ( '<STR_LIT>' , '<STR_LIT>' % ( G . AGENT . owner , G . AGENT . workspace ) ) <EOL> if disconnect : <EOL> msg . debug ( '<STR_LIT>' ) <EOL> reactor . stop ( ) <EOL> G . AGENT = None <EOL> return disconnect <EOL> return True <EOL> class FloobitsBaseCommand ( sublime_plugin . WindowCommand ) : <EOL> def is_visible ( self ) : <EOL> return True <EOL> def is_enabled ( self ) : <EOL> return bool ( G . AGENT and G . AGENT . is_ready ( ) ) <EOL> class FloobitsOpenSettingsCommand ( sublime_plugin . WindowCommand ) : <EOL> def run ( self ) : <EOL> window = sublime . active_window ( ) <EOL> if window : <EOL> window . open_file ( G . FLOORC_JSON_PATH ) <EOL> class FloobitsShareDirCommand ( FloobitsBaseCommand ) : <EOL> def is_enabled ( self ) : <EOL> return not super ( FloobitsShareDirCommand , self ) . is_enabled ( ) <EOL> def run ( self , dir_to_share = None , paths = None , current_file = False , api_args = None ) : <EOL> if paths : <EOL> if len ( paths ) != <NUM_LIT:1> : <EOL> return sublime . error_message ( '<STR_LIT>' ) <EOL> return SublimeUI . share_dir ( self . window , paths [ <NUM_LIT:0> ] , api_args ) <EOL> if dir_to_share is None : <EOL> folders = self . window . folders ( ) <EOL> if folders : <EOL> dir_to_share = folders [ <NUM_LIT:0> ] <EOL> else : <EOL> dir_to_share = os . path . expanduser ( os . path . join ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> SublimeUI . prompt_share_dir ( self . window , dir_to_share , api_args ) <EOL> class FloobitsDeleteWorkspaceCommand ( FloobitsBaseCommand ) : <EOL> def is_visible ( self ) : <EOL> return True <EOL> def is_enabled ( self ) : <EOL> return utils . can_auth ( ) <EOL> def run ( self , force = False ) : <EOL> SublimeUI . delete_workspace ( self . window , lambda * args , ** kwargs : None ) <EOL> class FloobitsPromptJoinWorkspaceCommand ( sublime_plugin . WindowCommand ) : <EOL> def run ( self , workspace = None ) : <EOL> if workspace is None : <EOL> workspace = '<STR_LIT>' % G . DEFAULT_HOST <EOL> for d in self . window . folders ( ) : <EOL> floo_file = os . path . join ( d , '<STR_LIT>' ) <EOL> try : <EOL> floo_info = open ( floo_file , '<STR_LIT:r>' ) . read ( ) <EOL> wurl = json . loads ( floo_info ) . get ( '<STR_LIT:url>' ) <EOL> utils . parse_url ( wurl ) <EOL> workspace = wurl <EOL> break <EOL> except Exception : <EOL> pass <EOL> self . window . show_input_panel ( '<STR_LIT>' , workspace , self . on_input , None , None ) <EOL> def on_input ( self , workspace_url ) : <EOL> if disconnect_dialog ( ) : <EOL> SublimeUI . join_workspace_by_url ( self . window , workspace_url , self . window . folders ( ) ) <EOL> class FloobitsPinocchioCommand ( sublime_plugin . WindowCommand ) : <EOL> def is_visible ( self ) : <EOL> return self . is_enabled ( ) <EOL> def is_enabled ( self ) : <EOL> return G . AUTO_GENERATED_ACCOUNT <EOL> def run ( self ) : <EOL> floorc = utils . load_floorc_json ( ) <EOL> auth = floorc . get ( '<STR_LIT>' , { } ) . get ( G . DEFAULT_HOST , { } ) <EOL> username = auth . get ( '<STR_LIT:username>' ) <EOL> secret = auth . get ( '<STR_LIT>' ) <EOL> print ( username , secret ) <EOL> if not ( username and secret ) : <EOL> return sublime . error_message ( '<STR_LIT>' ) <EOL> webbrowser . open ( '<STR_LIT>' % ( G . DEFAULT_HOST , username , secret ) ) <EOL> class FloobitsLeaveWorkspaceCommand ( FloobitsBaseCommand ) : <EOL>", "answer": "def run ( self ) :"}, {"prompt": "<s> from . . import vsreenqueue , trigger_pull , is_down <EOL> def enqueue ( fsq_id , trg_queue , data ) : <EOL>", "answer": "'''<STR_LIT>'''"}, {"prompt": "<s> import random <EOL> from tests . integration . cqlengine . base import BaseCassEngTestCase <EOL> from cassandra . cqlengine . management import sync_table <EOL> from cassandra . cqlengine . management import drop_table <EOL> from cassandra . cqlengine . models import Model <EOL> from cassandra . cqlengine import columns <EOL> class TestModel ( Model ) : <EOL> id = columns . Integer ( primary_key = True ) <EOL> clustering_key = columns . Integer ( primary_key = True , clustering_order = '<STR_LIT>' ) <EOL> class TestClusteringComplexModel ( Model ) : <EOL> id = columns . Integer ( primary_key = True ) <EOL> clustering_key = columns . Integer ( primary_key = True , clustering_order = '<STR_LIT>' ) <EOL> some_value = columns . Integer ( ) <EOL> class TestClusteringOrder ( BaseCassEngTestCase ) : <EOL> @ classmethod <EOL>", "answer": "def setUpClass ( cls ) :"}, {"prompt": "<s> import logging <EOL> import os <EOL> import genshi <EOL> from pylons import config <EOL> from shakespeare . lib . base import * <EOL> import shakespeare <EOL> import shakespeare . format <EOL> import shakespeare . model as model <EOL> log = logging . getLogger ( __name__ ) <EOL>", "answer": "class SiteController ( BaseController ) :"}, {"prompt": "<s> import hashlib <EOL> import datetime <EOL> import logging <EOL> import dateutil <EOL> import re <EOL> from django . conf import settings <EOL> from django . db import transaction <EOL> from django . template . defaultfilters import slugify <EOL> from django . utils . functional import memoize <EOL> from django . utils . http import urlquote <EOL> from django . utils . encoding import smart_str , smart_unicode <EOL> from httplib2 import HttpLib2Error <EOL> from jellyroll . providers import utils <EOL> from jellyroll . models import Item , Message , ContentLink <EOL> RECENT_STATUSES_URL = \"<STR_LIT>\" <EOL> USER_URL = \"<STR_LIT>\" <EOL> log = logging . getLogger ( \"<STR_LIT>\" ) <EOL> def enabled ( ) : <EOL> return True <EOL> def update ( ) : <EOL> last_update_date = Item . objects . get_last_update_of_model ( Message ) <EOL> log . debug ( \"<STR_LIT>\" , last_update_date ) <EOL> xml = utils . getxml ( RECENT_STATUSES_URL % settings . TWITTER_USERNAME ) <EOL> for status in xml . getiterator ( \"<STR_LIT>\" ) : <EOL> message = status . find ( '<STR_LIT:title>' ) <EOL> message_text = smart_unicode ( message . text ) <EOL>", "answer": "url = smart_unicode ( status . find ( '<STR_LIT>' ) . text )"}, {"prompt": "<s> from django . contrib import admin <EOL> from . models import * <EOL> class PillowCheckpointAdmin ( admin . ModelAdmin ) : <EOL> model = DjangoPillowCheckpoint <EOL> list_display = [ <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from sqlalchemy import exc as sqla_exc <EOL> from solum import objects <EOL> from solum . objects import assembly <EOL> from solum . openstack . common import log as logging <EOL> LOG = logging . getLogger ( __name__ ) <EOL> ASSEMBLY_STATES = assembly . States <EOL> class Handler ( object ) : <EOL> def __init__ ( self ) : <EOL> super ( Handler , self ) . __init__ ( ) <EOL> objects . load ( ) <EOL> def echo ( self , ctxt , message ) : <EOL> LOG . debug ( \"<STR_LIT:%s>\" % message ) <EOL> def build_job_update ( self , ctxt , build_id , status , description , <EOL> created_image_id , docker_image_name , assembly_id ) : <EOL> to_update = { '<STR_LIT:status>' : status , <EOL> '<STR_LIT>' : created_image_id , <EOL> '<STR_LIT>' : docker_image_name , <EOL> '<STR_LIT:description>' : str ( description ) } <EOL> try : <EOL> objects . registry . Image . update_and_save ( ctxt , build_id , to_update ) <EOL> except sqla_exc . SQLAlchemyError as ex : <EOL> LOG . error ( \"<STR_LIT>\" % build_id ) <EOL> LOG . exception ( ex ) <EOL> if assembly_id is None : <EOL> return <EOL> try : <EOL> assem = objects . registry . Assembly . get_by_id ( ctxt , <EOL> assembly_id ) <EOL> if assem . status == ASSEMBLY_STATES . DELETING : <EOL> return <EOL> if not any ( [ comp for comp in assem . components <EOL> if '<STR_LIT>' in comp . description ] ) : <EOL> comp_name = \"<STR_LIT>\" % assem . name <EOL> stack_id = None <EOL> if assem . heat_stack_component is not None : <EOL> stack_id = assem . heat_stack_component . heat_stack_id <EOL> objects . registry . Component . assign_and_create ( ctxt , assem , <EOL> comp_name , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> created_image_id , <EOL> stack_id ) <EOL> assem_update = { '<STR_LIT>' : build_id } <EOL> objects . registry . Assembly . update_and_save ( ctxt , <EOL> assembly_id , <EOL> assem_update ) <EOL> except sqla_exc . IntegrityError : <EOL> LOG . error ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % assembly_id ) <EOL> def update_assembly ( self , ctxt , assembly_id , data ) : <EOL> try : <EOL>", "answer": "objects . registry . Assembly . update_and_save ( ctxt , assembly_id , data )"}, {"prompt": "<s> import Gaffer <EOL> import GafferScene <EOL> import GafferUI <EOL> Gaffer . Metadata . registerNode ( <EOL> GafferScene . Grid , <EOL> \"<STR_LIT:description>\" , <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> plugs = { <EOL> \"<STR_LIT:name>\" : [ <EOL> \"<STR_LIT:description>\" , <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> ] , <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT:description>\" , <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> ] , <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT:description>\" , <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> ] , <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT:description>\" , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ] , <EOL> \"<STR_LIT>\" : [ <EOL> \"<STR_LIT:description>\" , <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> import random <EOL> import efl . elementary as elm <EOL> elm . init ( ) <EOL> from efl . elementary . window import StandardWindow <EOL> from efl . elementary . label import Label <EOL> from efl . elementary . button import Button <EOL> from efl . evas import EVAS_HINT_EXPAND , EVAS_HINT_FILL <EOL> from elmextensions import FileSelector <EOL> EXPAND_BOTH = EVAS_HINT_EXPAND , EVAS_HINT_EXPAND <EOL> FILL_BOTH = EVAS_HINT_FILL , EVAS_HINT_FILL <EOL> class MainWindow ( object ) : <EOL> def __init__ ( self ) : <EOL> win = StandardWindow ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> win . callback_delete_request_add ( lambda o : elm . exit ( ) ) <EOL> self . fs = fs = FileSelector ( win , size_hint_weight = EXPAND_BOTH , size_hint_align = FILL_BOTH ) <EOL> fs . setMode ( \"<STR_LIT>\" ) <EOL> fs . show ( ) <EOL> fs . callback_activated_add ( self . showFile ) <EOL> fs . callback_cancel_add ( lambda o : elm . exit ( ) ) <EOL> win . resize_object_add ( fs ) <EOL>", "answer": "win . resize ( <NUM_LIT> , <NUM_LIT> )"}, {"prompt": "<s> __doc__ = \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> import codecs <EOL> from rdflib . term import URIRef as URI <EOL> from rdflib . term import BNode as bNode <EOL> from rdflib . term import Literal <EOL> from rdflib . py3compat import cast_bytes , decodeUnicodeEscape <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> uriref = r'<STR_LIT>' <EOL> literal = r'<STR_LIT>' <EOL> litinfo = r'<STR_LIT>' + uriref + r'<STR_LIT>' <EOL> r_line = re . compile ( r'<STR_LIT>' ) <EOL> r_wspace = re . compile ( r'<STR_LIT>' ) <EOL> r_wspaces = re . compile ( r'<STR_LIT>' ) <EOL> r_tail = re . compile ( r'<STR_LIT>' ) <EOL> r_uriref = re . compile ( uriref ) <EOL> r_nodeid = re . compile ( r'<STR_LIT>' ) <EOL> r_literal = re . compile ( literal + litinfo ) <EOL> bufsiz = <NUM_LIT> <EOL> validate = False <EOL> class Node ( unicode ) : <EOL> pass <EOL> class ParseError ( Exception ) : <EOL> pass <EOL> class Sink ( object ) : <EOL> def __init__ ( self ) : <EOL> self . length = <NUM_LIT:0> <EOL> def triple ( self , s , p , o ) : <EOL> self . length += <NUM_LIT:1> <EOL> print ( s , p , o ) <EOL> quot = { '<STR_LIT:t>' : u'<STR_LIT:\\t>' , '<STR_LIT:n>' : u'<STR_LIT:\\n>' , '<STR_LIT:r>' : u'<STR_LIT:\\r>' , '<STR_LIT:\">' : u'<STR_LIT:\">' , '<STR_LIT:\\\\>' : <EOL> u'<STR_LIT:\\\\>' } <EOL> r_safe = re . compile ( r'<STR_LIT>' ) <EOL> r_quot = re . compile ( r'<STR_LIT>' ) <EOL> r_uniquot = re . compile ( r'<STR_LIT>' ) <EOL> def unquote ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not validate : <EOL> if isinstance ( s , unicode ) : <EOL> s = decodeUnicodeEscape ( s ) <EOL> else : <EOL> s = s . decode ( '<STR_LIT>' ) <EOL> return s <EOL> else : <EOL> result = [ ] <EOL> while s : <EOL> m = r_safe . match ( s ) <EOL> if m : <EOL> s = s [ m . end ( ) : ] <EOL> result . append ( m . group ( <NUM_LIT:1> ) ) <EOL> continue <EOL> m = r_quot . match ( s ) <EOL> if m : <EOL> s = s [ <NUM_LIT:2> : ] <EOL> result . append ( quot [ m . group ( <NUM_LIT:1> ) ] ) <EOL> continue <EOL> m = r_uniquot . match ( s ) <EOL> if m : <EOL> s = s [ m . end ( ) : ] <EOL> u , U = m . groups ( ) <EOL> codepoint = int ( u or U , <NUM_LIT:16> ) <EOL> if codepoint > <NUM_LIT> : <EOL> raise ParseError ( \"<STR_LIT>\" % codepoint ) <EOL> result . append ( unichr ( codepoint ) ) <EOL> elif s . startswith ( '<STR_LIT:\\\\>' ) : <EOL> raise ParseError ( \"<STR_LIT>\" % s [ : <NUM_LIT:10> ] ) <EOL> else : <EOL> raise ParseError ( \"<STR_LIT>\" % s [ <NUM_LIT:0> ] ) <EOL> return u'<STR_LIT>' . join ( result ) <EOL> r_hibyte = re . compile ( ur '<STR_LIT>' ) <EOL> def uriquote ( uri ) : <EOL> if not validate : <EOL> return uri <EOL> else : <EOL> return r_hibyte . sub ( <EOL> lambda m : '<STR_LIT>' % ord ( m . group ( <NUM_LIT:1> ) ) , uri ) <EOL> class NTriplesParser ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _bnode_ids = { } <EOL> def __init__ ( self , sink = None ) : <EOL> if sink is not None : <EOL> self . sink = sink <EOL> else : <EOL> self . sink = Sink ( ) <EOL> def parse ( self , f ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not hasattr ( f , '<STR_LIT>' ) : <EOL> raise ParseError ( \"<STR_LIT>\" ) <EOL> f = codecs . getreader ( '<STR_LIT:utf-8>' ) ( f ) <EOL> self . file = f <EOL> self . buffer = '<STR_LIT>' <EOL> while True : <EOL> self . line = self . readline ( ) <EOL> if self . line is None : <EOL> break <EOL> try : <EOL> self . parseline ( ) <EOL> except ParseError : <EOL> raise ParseError ( \"<STR_LIT>\" % self . line ) <EOL> return self . sink <EOL> def parsestring ( self , s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( s , basestring ) : <EOL> raise ParseError ( \"<STR_LIT>\" ) <EOL> try : <EOL> from io import BytesIO <EOL> assert BytesIO <EOL> except ImportError : <EOL> from cStringIO import StringIO as BytesIO <EOL> assert BytesIO <EOL> f = BytesIO ( ) <EOL> f . write ( cast_bytes ( s ) ) <EOL> f . seek ( <NUM_LIT:0> ) <EOL> self . parse ( f ) <EOL> def readline ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . buffer : <EOL> buffer = self . file . read ( bufsiz ) <EOL> if not buffer : <EOL> return None <EOL> self . buffer = buffer <EOL> while True : <EOL> m = r_line . match ( self . buffer ) <EOL> if m : <EOL> self . buffer = self . buffer [ m . end ( ) : ] <EOL> return m . group ( <NUM_LIT:1> ) <EOL> else : <EOL> buffer = self . file . read ( bufsiz ) <EOL> if not buffer and not self . buffer . isspace ( ) : <EOL> buffer += \"<STR_LIT:\\n>\" <EOL> elif not buffer : <EOL> return None <EOL> self . buffer += buffer <EOL> def parseline ( self ) : <EOL> self . eat ( r_wspace ) <EOL> if ( not self . line ) or self . line . startswith ( '<STR_LIT:#>' ) : <EOL> return <EOL> subject = self . subject ( ) <EOL> self . eat ( r_wspaces ) <EOL> predicate = self . predicate ( ) <EOL> self . eat ( r_wspaces ) <EOL> object = self . object ( ) <EOL> self . eat ( r_tail ) <EOL> if self . line : <EOL> raise ParseError ( \"<STR_LIT>\" ) <EOL> self . sink . triple ( subject , predicate , object ) <EOL> def peek ( self , token ) : <EOL> return self . line . startswith ( token ) <EOL> def eat ( self , pattern ) : <EOL>", "answer": "m = pattern . match ( self . line )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import contextlib <EOL> import imp <EOL> import os <EOL> import select <EOL> import signal <EOL> import socket <EOL> import select <EOL> import errno <EOL> import tempfile <EOL> import unittest <EOL> import SocketServer <EOL> import test . test_support <EOL> from test . test_support import reap_children , reap_threads , verbose <EOL> try : <EOL> import threading <EOL> except ImportError : <EOL> threading = None <EOL> test . test_support . requires ( \"<STR_LIT>\" ) <EOL> TEST_STR = \"<STR_LIT>\" <EOL> HOST = test . test_support . HOST <EOL> HAVE_UNIX_SOCKETS = hasattr ( socket , \"<STR_LIT>\" ) <EOL> requires_unix_sockets = unittest . skipUnless ( HAVE_UNIX_SOCKETS , <EOL> '<STR_LIT>' ) <EOL> HAVE_FORKING = hasattr ( os , \"<STR_LIT>\" ) and os . name != \"<STR_LIT>\" <EOL> requires_forking = unittest . skipUnless ( HAVE_FORKING , '<STR_LIT>' ) <EOL> def signal_alarm ( n ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if hasattr ( signal , '<STR_LIT>' ) : <EOL> signal . alarm ( n ) <EOL> _real_select = select . select <EOL> def receive ( sock , n , timeout = <NUM_LIT:20> ) : <EOL> r , w , x = _real_select ( [ sock ] , [ ] , [ ] , timeout ) <EOL> if sock in r : <EOL> return sock . recv ( n ) <EOL> else : <EOL> raise RuntimeError , \"<STR_LIT>\" % ( sock , ) <EOL> if HAVE_UNIX_SOCKETS : <EOL> class ForkingUnixStreamServer ( SocketServer . ForkingMixIn , <EOL> SocketServer . UnixStreamServer ) : <EOL> pass <EOL> class ForkingUnixDatagramServer ( SocketServer . ForkingMixIn , <EOL> SocketServer . UnixDatagramServer ) : <EOL> pass <EOL> @ contextlib . contextmanager <EOL> def simple_subprocess ( testcase ) : <EOL> pid = os . fork ( ) <EOL> if pid == <NUM_LIT:0> : <EOL> os . _exit ( <NUM_LIT> ) <EOL> yield None <EOL> pid2 , status = os . waitpid ( pid , <NUM_LIT:0> ) <EOL> testcase . assertEqual ( pid2 , pid ) <EOL> testcase . assertEqual ( <NUM_LIT> << <NUM_LIT:8> , status ) <EOL> @ unittest . skipUnless ( threading , '<STR_LIT>' ) <EOL> class SocketServerTest ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> signal_alarm ( <NUM_LIT> ) <EOL> self . port_seed = <NUM_LIT:0> <EOL> self . test_files = [ ] <EOL> def tearDown ( self ) : <EOL> signal_alarm ( <NUM_LIT:0> ) <EOL> reap_children ( ) <EOL> for fn in self . test_files : <EOL> try : <EOL> os . remove ( fn ) <EOL> except os . error : <EOL> pass <EOL> self . test_files [ : ] = [ ] <EOL> def pickaddr ( self , proto ) : <EOL> if proto == socket . AF_INET : <EOL> return ( HOST , <NUM_LIT:0> ) <EOL> else : <EOL> dir = None <EOL> if os . name == '<STR_LIT>' : <EOL> dir = '<STR_LIT>' <EOL> fn = tempfile . mktemp ( prefix = '<STR_LIT>' , dir = dir ) <EOL> if os . name == '<STR_LIT>' : <EOL> if fn [ <NUM_LIT:1> ] == '<STR_LIT::>' : <EOL> fn = fn [ <NUM_LIT:2> : ] <EOL> if fn [ <NUM_LIT:0> ] in ( os . sep , os . altsep ) : <EOL> fn = fn [ <NUM_LIT:1> : ] <EOL> if os . sep == '<STR_LIT:/>' : <EOL> fn = fn . replace ( os . sep , os . altsep ) <EOL> else : <EOL> fn = fn . replace ( os . altsep , os . sep ) <EOL> self . test_files . append ( fn ) <EOL>", "answer": "return fn"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import datetime <EOL> import time <EOL> from termsaverlib . screen . base import ScreenBase <EOL> from termsaverlib . screen . helper . position import PositionHelperBase <EOL> from termsaverlib import common <EOL> from termsaverlib . i18n import _ <EOL> class ClockScreen ( ScreenBase , PositionHelperBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ampm = False <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cseparator = \"<STR_LIT::>\" <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> show_separator = True <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> digmap = { <EOL> '<STR_LIT:0>' : '<STR_LIT>' , <EOL> '<STR_LIT:1>' : '<STR_LIT>' , <EOL> '<STR_LIT:2>' : '<STR_LIT>' , <EOL> '<STR_LIT:3>' : '<STR_LIT>' , <EOL> '<STR_LIT:4>' : '<STR_LIT>' , <EOL> '<STR_LIT:5>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT::>' : '<STR_LIT>' , <EOL> '<STR_LIT:m>' : '<STR_LIT>' , <EOL> '<STR_LIT:p>' : '<STR_LIT>' , <EOL> '<STR_LIT:a>' : '<STR_LIT>' , <EOL> '<STR_LIT:U+0020>' : '<STR_LIT>' , <EOL> } <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from itertools import chain <EOL> import numpy as np <EOL> import networkx as nx <EOL> from pgmpy . extern . six . moves import zip <EOL> from pgmpy . extern import six <EOL> class NoisyOrModel ( nx . DiGraph ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , variables , cardinality , inhibitor_probability ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . variables = np . array ( [ ] ) <EOL> self . cardinality = np . array ( [ ] , dtype = np . int ) <EOL> self . inhibitor_probability = [ ] <EOL> self . add_variables ( variables , cardinality , inhibitor_probability ) <EOL> def add_variables ( self , variables , cardinality , inhibitor_probability ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( variables ) == <NUM_LIT:1> : <EOL> if not isinstance ( inhibitor_probability [ <NUM_LIT:0> ] , ( list , tuple ) ) : <EOL> inhibitor_probability = [ inhibitor_probability ] <EOL> if len ( variables ) != len ( cardinality ) : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif any ( cardinal != len ( prob_array ) for prob_array , cardinal in zip ( inhibitor_probability , cardinality ) ) or len ( cardinality ) != len ( inhibitor_probability ) : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> elif not all ( <NUM_LIT:0> <= item <= <NUM_LIT:1> for item in chain . from_iterable ( inhibitor_probability ) ) : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> self . variables = np . concatenate ( ( self . variables , variables ) ) <EOL> self . cardinality = np . concatenate ( ( self . cardinality , cardinality ) ) <EOL> self . inhibitor_probability . extend ( inhibitor_probability ) <EOL> def del_variables ( self , variables ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> variables = [ variables ] if isinstance ( variables , six . string_types ) else set ( variables ) <EOL> indices = [ index for index , variable in enumerate ( self . variables ) if variable in variables ] <EOL> self . variables = np . delete ( self . variables , indices , <NUM_LIT:0> ) <EOL> self . cardinality = np . delete ( self . cardinality , indices , <NUM_LIT:0> ) <EOL>", "answer": "self . inhibitor_probability = [ prob_array for index , prob_array in enumerate ( self . inhibitor_probability )"}, {"prompt": "<s> from __future__ import absolute_import , unicode_literals <EOL> from django_services import admin <EOL>", "answer": "from . . service import BindService"}, {"prompt": "<s> from django . contrib . auth . models import BaseUserManager <EOL> from django . utils import timezone <EOL>", "answer": "from model_utils . managers import InheritanceQuerySet"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import copy <EOL> import yaml <EOL> from . import exceptions <EOL> from . tasks import TaskGraph <EOL> from . decorators import memoize <EOL> CONFIG_FILENAME = \"<STR_LIT>\" <EOL> TASKS_KEY = '<STR_LIT>' <EOL> def find_config_path ( config = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if config is not None : <EOL>", "answer": "config_path = os . path . abspath ( os . path . join ( os . getcwd ( ) , config ) )"}, {"prompt": "<s> import os <EOL> import os . path <EOL> import numpy as np <EOL> from numpy . testing import * <EOL> from numpy . testing . decorators import skipif <EOL> from tempfile import NamedTemporaryFile <EOL> from skimage import data_dir <EOL> from skimage . io import imread , imsave , use_plugin , reset_plugins <EOL> try : <EOL> import imageio as _imageio <EOL> except ImportError : <EOL> imageio_available = False <EOL> else : <EOL> imageio_available = True <EOL> def setup ( ) : <EOL> if imageio_available : <EOL> np . random . seed ( <NUM_LIT:0> ) <EOL> use_plugin ( '<STR_LIT>' ) <EOL> def teardown ( ) : <EOL> reset_plugins ( ) <EOL> @ skipif ( not imageio_available ) <EOL> def test_imageio_flatten ( ) : <EOL> img = imread ( os . path . join ( data_dir , '<STR_LIT>' ) , flatten = True ) <EOL> assert img . ndim == <NUM_LIT:2> <EOL> assert img . dtype == np . float64 <EOL> img = imread ( os . path . join ( data_dir , '<STR_LIT>' ) , flatten = True ) <EOL> assert np . sctype2char ( img . dtype ) in np . typecodes [ '<STR_LIT>' ] <EOL> @ skipif ( not imageio_available ) <EOL> def test_imageio_palette ( ) : <EOL> img = imread ( os . path . join ( data_dir , '<STR_LIT>' ) ) <EOL> assert img . ndim == <NUM_LIT:3> <EOL> @ skipif ( not imageio_available ) <EOL> def test_imageio_truncated_jpg ( ) : <EOL> assert_raises ( ( RuntimeError , ValueError ) , <EOL> imread , <EOL> os . path . join ( data_dir , '<STR_LIT>' ) ) <EOL> class TestSave : <EOL> def roundtrip ( self , x , scaling = <NUM_LIT:1> ) : <EOL> f = NamedTemporaryFile ( suffix = '<STR_LIT>' ) <EOL> fname = f . name <EOL> f . close ( ) <EOL> imsave ( fname , x ) <EOL> y = imread ( fname ) <EOL> assert_array_almost_equal ( ( x * scaling ) . astype ( np . int32 ) , y ) <EOL> @ skipif ( not imageio_available ) <EOL> def test_imsave_roundtrip ( self ) : <EOL> dtype = np . uint8 <EOL> for shape in [ ( <NUM_LIT:10> , <NUM_LIT:10> ) , ( <NUM_LIT:10> , <NUM_LIT:10> , <NUM_LIT:3> ) , ( <NUM_LIT:10> , <NUM_LIT:10> , <NUM_LIT:4> ) ] : <EOL> x = np . ones ( shape , dtype = dtype ) * np . random . rand ( * shape ) <EOL> if np . issubdtype ( dtype , float ) : <EOL> yield self . roundtrip , x , <NUM_LIT:255> <EOL> else : <EOL>", "answer": "x = ( x * <NUM_LIT:255> ) . astype ( dtype )"}, {"prompt": "<s> from migen . fhdl import structure as f <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> def log2_int ( n , need_pow2 = True ) : <EOL> l = <NUM_LIT:1> <EOL> r = <NUM_LIT:0> <EOL> while l < n : <EOL> l *= <NUM_LIT:2> <EOL> r += <NUM_LIT:1> <EOL> if need_pow2 and l != n : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return r <EOL> def bits_for ( n , require_sign_bit = False ) : <EOL> if n > <NUM_LIT:0> : <EOL> r = log2_int ( n + <NUM_LIT:1> , False ) <EOL> else : <EOL> require_sign_bit = True <EOL> r = log2_int ( - n , False ) <EOL> if require_sign_bit : <EOL> r += <NUM_LIT:1> <EOL>", "answer": "return r"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import datetime <EOL> import locale as _locale <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> error = ValueError <EOL> class IllegalMonthError ( ValueError ) : <EOL> def __init__ ( self , month ) : <EOL> self . month = month <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % self . month <EOL> class IllegalWeekdayError ( ValueError ) : <EOL> def __init__ ( self , weekday ) : <EOL> self . weekday = weekday <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % self . weekday <EOL> January = <NUM_LIT:1> <EOL> February = <NUM_LIT:2> <EOL> mdays = [ <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:30> , <NUM_LIT> , <NUM_LIT:30> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:30> , <NUM_LIT> , <NUM_LIT:30> , <NUM_LIT> ] <EOL> class _localized_month : <EOL> _months = [ datetime . date ( <NUM_LIT> , i + <NUM_LIT:1> , <NUM_LIT:1> ) . strftime for i in range ( <NUM_LIT:12> ) ] <EOL> _months . insert ( <NUM_LIT:0> , lambda x : \"<STR_LIT>\" ) <EOL> def __init__ ( self , format ) : <EOL> self . format = format <EOL> def __getitem__ ( self , i ) : <EOL> funcs = self . _months [ i ] <EOL> if isinstance ( i , slice ) : <EOL> return [ f ( self . format ) for f in funcs ] <EOL> else : <EOL> return funcs ( self . format ) <EOL> def __len__ ( self ) : <EOL> return <NUM_LIT> <EOL> class _localized_day : <EOL> _days = [ datetime . date ( <NUM_LIT> , <NUM_LIT:1> , i + <NUM_LIT:1> ) . strftime for i in range ( <NUM_LIT:7> ) ] <EOL> def __init__ ( self , format ) : <EOL> self . format = format <EOL> def __getitem__ ( self , i ) : <EOL> funcs = self . _days [ i ] <EOL> if isinstance ( i , slice ) : <EOL> return [ f ( self . format ) for f in funcs ] <EOL> else : <EOL> return funcs ( self . format ) <EOL> def __len__ ( self ) : <EOL> return <NUM_LIT:7> <EOL> day_name = _localized_day ( '<STR_LIT>' ) <EOL> day_abbr = _localized_day ( '<STR_LIT>' ) <EOL> month_name = _localized_month ( '<STR_LIT>' ) <EOL> month_abbr = _localized_month ( '<STR_LIT>' ) <EOL> ( MONDAY , TUESDAY , WEDNESDAY , THURSDAY , FRIDAY , SATURDAY , SUNDAY ) = range ( <NUM_LIT:7> ) <EOL> def isleap ( year ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return year % <NUM_LIT:4> == <NUM_LIT:0> and ( year % <NUM_LIT:100> != <NUM_LIT:0> or year % <NUM_LIT> == <NUM_LIT:0> ) <EOL> def leapdays ( y1 , y2 ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> y1 -= <NUM_LIT:1> <EOL> y2 -= <NUM_LIT:1> <EOL> return ( y2 // <NUM_LIT:4> - y1 // <NUM_LIT:4> ) - ( y2 // <NUM_LIT:100> - y1 // <NUM_LIT:100> ) + ( y2 // <NUM_LIT> - y1 // <NUM_LIT> ) <EOL> def weekday ( year , month , day ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "return datetime . date ( year , month , day ) . weekday ( )"}, {"prompt": "<s> from django . views . generic . list import ListView as DjangoListView <EOL> from django . contrib . sites . models import Site , get_current_site <EOL> from django . utils import timezone <EOL> from django . conf import settings <EOL> from opps . views . generic . base import View <EOL> from opps . containers . models import Mirror , ContainerBox <EOL> class ListView ( View , DjangoListView ) : <EOL> template_name_suffix = '<STR_LIT>' <EOL> def get_template_list ( self , domain_folder = \"<STR_LIT>\" ) : <EOL> templates = [ ] <EOL> if not self . long_slug : <EOL> templates . append ( '<STR_LIT>' . format ( domain_folder ) ) <EOL> return templates <EOL> list_name = '<STR_LIT:list>' <EOL> if self . template_name_suffix : <EOL> list_name = \"<STR_LIT>\" . format ( list_name , self . template_name_suffix ) <EOL>", "answer": "if self . channel :"}, {"prompt": "<s> import datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . create_table ( '<STR_LIT>' , ( <EOL> ( '<STR_LIT:id>' , self . gf ( '<STR_LIT>' ) ( primary_key = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( related_name = '<STR_LIT>' , to = orm [ '<STR_LIT>' ] ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( related_name = '<STR_LIT>' , to = orm [ '<STR_LIT>' ] ) ) , <EOL> ) ) <EOL> db . send_create_signal ( '<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> db . create_table ( '<STR_LIT>' , ( <EOL> ( '<STR_LIT:id>' , self . gf ( '<STR_LIT>' ) ( primary_key = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( blank = True , related_name = '<STR_LIT>' , null = True , to = orm [ '<STR_LIT>' ] ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( to = orm [ '<STR_LIT>' ] , null = True , blank = True ) ) , <EOL> ( '<STR_LIT:name>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT:255> ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT> , blank = True ) ) , <EOL> ( '<STR_LIT:description>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT> , blank = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT:255> , blank = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = '<STR_LIT>' , max_length = <NUM_LIT:255> , blank = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = '<STR_LIT>' , max_length = <NUM_LIT:255> , blank = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = '<STR_LIT>' , max_length = <NUM_LIT:255> , blank = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = '<STR_LIT>' , max_length = <NUM_LIT:255> , blank = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = '<STR_LIT>' , max_length = <NUM_LIT:255> , blank = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( blank = True ) ) , <EOL> ) ) <EOL> db . send_create_signal ( '<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> m2m_table_name = db . shorten_name ( '<STR_LIT>' ) <EOL> db . create_table ( m2m_table_name , ( <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , primary_key = True , auto_created = True ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( orm [ '<STR_LIT>' ] , null = False ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( orm [ '<STR_LIT>' ] , null = False ) ) <EOL> ) ) <EOL> db . create_unique ( m2m_table_name , [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> m2m_table_name = db . shorten_name ( '<STR_LIT>' ) <EOL> db . create_table ( m2m_table_name , ( <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , primary_key = True , auto_created = True ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( orm [ '<STR_LIT>' ] , null = False ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( orm [ '<STR_LIT>' ] , null = False ) ) <EOL> ) ) <EOL> db . create_unique ( m2m_table_name , [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def backwards ( self , orm ) : <EOL> db . delete_table ( '<STR_LIT>' ) <EOL> db . delete_table ( '<STR_LIT>' ) <EOL> db . delete_table ( db . shorten_name ( '<STR_LIT>' ) ) <EOL> db . delete_table ( db . shorten_name ( '<STR_LIT>' ) ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:description>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT:address>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:version>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT:description>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:2>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:None>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL>", "answer": "'<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:None>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> from re import compile as re_compile <EOL> import diamond . collector <EOL> PROC_ZONEINFO = '<STR_LIT>' <EOL> node_re = re_compile ( r'<STR_LIT>' ) <EOL> class NUMAZoneInfoCollector ( diamond . collector . Collector ) : <EOL> def get_default_config ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> config = super ( NUMAZoneInfoCollector , self ) . get_default_config ( ) <EOL> config . update ( { <EOL>", "answer": "'<STR_LIT:path>' : '<STR_LIT>' ,"}, {"prompt": "<s> from . import unittest , numpy , test_int_types <EOL> from . test_multi import MultiGeometryTestCase <EOL> from shapely . geometry import Point , MultiPoint , asMultiPoint <EOL> from shapely . geometry . base import dump_coords <EOL> class MultiPointTestCase ( MultiGeometryTestCase ) : <EOL> def test_multipoint ( self ) : <EOL> geom = MultiPoint ( ( ( <NUM_LIT:1.0> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) ) ) <EOL> self . assertEqual ( len ( geom . geoms ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( dump_coords ( geom ) , [ [ ( <NUM_LIT:1.0> , <NUM_LIT> ) ] , [ ( <NUM_LIT> , <NUM_LIT> ) ] ] ) <EOL> geom = MultiPoint ( ( Point ( <NUM_LIT:1.0> , <NUM_LIT> ) , Point ( <NUM_LIT> , <NUM_LIT> ) ) ) <EOL> self . assertEqual ( len ( geom . geoms ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( dump_coords ( geom ) , [ [ ( <NUM_LIT:1.0> , <NUM_LIT> ) ] , [ ( <NUM_LIT> , <NUM_LIT> ) ] ] ) <EOL> geom2 = MultiPoint ( geom ) <EOL> self . assertEqual ( len ( geom2 . geoms ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( dump_coords ( geom2 ) , [ [ ( <NUM_LIT:1.0> , <NUM_LIT> ) ] , [ ( <NUM_LIT> , <NUM_LIT> ) ] ] ) <EOL> self . assertIsInstance ( geom . geoms [ <NUM_LIT:0> ] , Point ) <EOL> self . assertEqual ( geom . geoms [ <NUM_LIT:0> ] . x , <NUM_LIT:1.0> ) <EOL> self . assertEqual ( geom . geoms [ <NUM_LIT:0> ] . y , <NUM_LIT> ) <EOL> with self . assertRaises ( IndexError ) : <EOL> geom . geoms [ <NUM_LIT:2> ] <EOL> self . assertEqual ( geom . __geo_interface__ , <EOL> { '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : ( ( <NUM_LIT:1.0> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) ) } ) <EOL> coords = [ [ <NUM_LIT> , <NUM_LIT> ] , [ <NUM_LIT> , <NUM_LIT> ] ] <EOL> geoma = asMultiPoint ( coords ) <EOL> self . assertEqual ( dump_coords ( geoma ) , [ [ ( <NUM_LIT> , <NUM_LIT> ) ] , [ ( <NUM_LIT> , <NUM_LIT> ) ] ] ) <EOL> @ unittest . skipIf ( not numpy , '<STR_LIT>' ) <EOL> def test_numpy ( self ) : <EOL> from numpy import array , asarray <EOL> from numpy . testing import assert_array_equal <EOL> geom = MultiPoint ( array ( [ [ <NUM_LIT:0.0> , <NUM_LIT:0.0> ] , [ <NUM_LIT:1.0> , <NUM_LIT> ] ] ) ) <EOL> self . assertIsInstance ( geom , MultiPoint ) <EOL> self . assertEqual ( len ( geom . geoms ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( dump_coords ( geom ) , [ [ ( <NUM_LIT:0.0> , <NUM_LIT:0.0> ) ] , [ ( <NUM_LIT:1.0> , <NUM_LIT> ) ] ] ) <EOL> geom = MultiPoint ( ( Point ( <NUM_LIT:1.0> , <NUM_LIT> ) , Point ( <NUM_LIT> , <NUM_LIT> ) ) ) <EOL> assert_array_equal ( array ( geom ) , array ( [ [ <NUM_LIT:1.> , <NUM_LIT> ] , [ <NUM_LIT> , <NUM_LIT> ] ] ) ) <EOL> a = array ( [ [ <NUM_LIT:1.0> , <NUM_LIT> ] , [ <NUM_LIT> , <NUM_LIT> ] ] ) <EOL> geoma = asMultiPoint ( a ) <EOL> assert_array_equal ( geoma . context , array ( [ [ <NUM_LIT:1.> , <NUM_LIT> ] , [ <NUM_LIT> , <NUM_LIT> ] ] ) ) <EOL> self . assertEqual ( dump_coords ( geoma ) , [ [ ( <NUM_LIT:1.0> , <NUM_LIT> ) ] , [ ( <NUM_LIT> , <NUM_LIT> ) ] ] ) <EOL> self . assertEqual ( geoma . __array_interface__ , <EOL> geoma . context . __array_interface__ ) <EOL> pas = asarray ( geoma ) <EOL> assert_array_equal ( pas , array ( [ [ <NUM_LIT:1.> , <NUM_LIT> ] , [ <NUM_LIT> , <NUM_LIT> ] ] ) ) <EOL>", "answer": "def test_subgeom_access ( self ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function , unicode_literals , absolute_import <EOL> import json <EOL> import logging <EOL> import os <EOL> import sys <EOL> import time <EOL> import warnings <EOL> from functools import wraps <EOL> from . constants import SIMPLE_BUILD_TYPE , PROD_WITHOUT_KOJI_BUILD_TYPE , PROD_WITH_SECRET_BUILD_TYPE <EOL> from osbs . build . build_request import BuildManager <EOL> from osbs . build . build_response import BuildResponse <EOL> from osbs . build . pod_response import PodResponse <EOL> from osbs . constants import BUILD_RUNNING_STATES , PROD_BUILD_TYPE <EOL> from osbs . core import Openshift <EOL> from osbs . exceptions import OsbsException , OsbsValidationException <EOL> from osbs import utils <EOL> def osbsapi ( func ) : <EOL> @ wraps ( func ) <EOL> def catch_exceptions ( * args , ** kwargs ) : <EOL> if kwargs . pop ( \"<STR_LIT>\" , None ) : <EOL> warnings . warn ( \"<STR_LIT>\" % func . __name__ ) <EOL> try : <EOL> return func ( * args , ** kwargs ) <EOL> except OsbsException : <EOL> raise <EOL> except Exception as ex : <EOL> raise OsbsException ( cause = ex , traceback = sys . exc_info ( ) [ <NUM_LIT:2> ] ) <EOL> return catch_exceptions <EOL> logger = logging . getLogger ( __name__ ) <EOL> class OSBS ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ osbsapi <EOL> def __init__ ( self , openshift_configuration , build_configuration ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> self . os_conf = openshift_configuration <EOL> self . build_conf = build_configuration <EOL> self . os = Openshift ( openshift_api_url = self . os_conf . get_openshift_api_uri ( ) , <EOL> openshift_api_version = self . os_conf . get_openshift_api_version ( ) , <EOL> openshift_oauth_url = self . os_conf . get_openshift_oauth_api_uri ( ) , <EOL> k8s_api_url = self . os_conf . get_k8s_api_uri ( ) , <EOL> verbose = self . os_conf . get_verbosity ( ) , <EOL> username = self . os_conf . get_username ( ) , <EOL> password = self . os_conf . get_password ( ) , <EOL> use_kerberos = self . os_conf . get_use_kerberos ( ) , <EOL> client_cert = self . os_conf . get_client_cert ( ) , <EOL> client_key = self . os_conf . get_client_key ( ) , <EOL> kerberos_keytab = self . os_conf . get_kerberos_keytab ( ) , <EOL> kerberos_principal = self . os_conf . get_kerberos_principal ( ) , <EOL> kerberos_ccache = self . os_conf . get_kerberos_ccache ( ) , <EOL> use_auth = self . os_conf . get_use_auth ( ) , <EOL> verify_ssl = self . os_conf . get_verify_ssl ( ) , <EOL> token = self . os_conf . get_oauth2_token ( ) , <EOL> namespace = self . os_conf . get_namespace ( ) ) <EOL> self . _bm = None <EOL> @ property <EOL> def bm ( self ) : <EOL> if self . _bm is None : <EOL> self . _bm = BuildManager ( build_json_store = self . os_conf . get_build_json_store ( ) ) <EOL> return self . _bm <EOL> @ osbsapi <EOL> def list_builds ( self , field_selector = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> response = self . os . list_builds ( field_selector = field_selector ) <EOL> serialized_response = response . json ( ) <EOL> build_list = [ ] <EOL> for build in serialized_response [ \"<STR_LIT>\" ] : <EOL> build_list . append ( BuildResponse ( build ) ) <EOL> return build_list <EOL> @ osbsapi <EOL> def get_build ( self , build_id ) : <EOL> response = self . os . get_build ( build_id ) <EOL> build_response = BuildResponse ( response . json ( ) ) <EOL> return build_response <EOL> @ osbsapi <EOL> def cancel_build ( self , build_id ) : <EOL> response = self . os . cancel_build ( build_id ) <EOL> build_response = BuildResponse ( response . json ( ) ) <EOL> return build_response <EOL> @ osbsapi <EOL> def get_pod_for_build ( self , build_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pods = self . os . list_pods ( label = '<STR_LIT>' % build_id ) <EOL> serialized_response = pods . json ( ) <EOL> pod_list = [ PodResponse ( pod ) for pod in serialized_response [ \"<STR_LIT>\" ] ] <EOL> if not pod_list : <EOL> raise OsbsException ( \"<STR_LIT>\" ) <EOL> elif len ( pod_list ) != <NUM_LIT:1> : <EOL> raise OsbsException ( \"<STR_LIT>\" , <EOL> len ( pod_list ) ) <EOL> return pod_list [ <NUM_LIT:0> ] <EOL> @ osbsapi <EOL> def get_build_request ( self , build_type = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> build_type = build_type or self . build_conf . get_build_type ( ) <EOL> build_request = self . bm . get_build_request_by_type ( build_type = build_type ) <EOL> cpu_limit = self . build_conf . get_cpu_limit ( ) <EOL> memory_limit = self . build_conf . get_memory_limit ( ) <EOL> storage_limit = self . build_conf . get_storage_limit ( ) <EOL> if ( cpu_limit is not None or <EOL> memory_limit is not None or <EOL> storage_limit is not None ) : <EOL> build_request . set_resource_limits ( cpu = cpu_limit , <EOL> memory = memory_limit , <EOL> storage = storage_limit ) <EOL> return build_request <EOL> @ osbsapi <EOL> def create_build_from_buildrequest ( self , build_request ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> build_request . set_openshift_required_version ( self . os_conf . get_openshift_required_version ( ) ) <EOL> build = build_request . render ( ) <EOL> response = self . os . create_build ( json . dumps ( build ) ) <EOL> build_response = BuildResponse ( response . json ( ) ) <EOL> return build_response <EOL> def _get_running_builds_for_build_config ( self , build_config_id ) : <EOL> all_builds_for_bc = self . os . list_builds ( build_config_id = build_config_id ) . json ( ) [ '<STR_LIT>' ] <EOL> running = [ ] <EOL> for b in all_builds_for_bc : <EOL> br = BuildResponse ( b ) <EOL> if br . is_pending ( ) or br . is_running ( ) : <EOL> running . append ( br ) <EOL> return running <EOL> @ staticmethod <EOL> def _panic_msg_for_more_running_builds ( self , build_config_name , builds ) : <EOL> builds = '<STR_LIT:U+002CU+0020>' . join ( [ '<STR_LIT>' % ( b . get_build_name ( ) , b . status ) for b in builds ] ) <EOL> msg = '<STR_LIT>' % ( build_config_name , builds ) <EOL> return msg <EOL> def _create_build_config_and_build ( self , build_request ) : <EOL> build_json = build_request . render ( ) <EOL> api_version = build_json [ '<STR_LIT>' ] <EOL> if api_version != self . os_conf . get_openshift_api_version ( ) : <EOL> raise OsbsValidationException ( \"<STR_LIT>\" % <EOL> api_version ) <EOL> build_config_name = build_json [ '<STR_LIT>' ] [ '<STR_LIT:name>' ] <EOL> running_builds = self . _get_running_builds_for_build_config ( build_config_name ) <EOL> rb_len = len ( running_builds ) <EOL> if rb_len > <NUM_LIT:0> : <EOL> if rb_len == <NUM_LIT:1> : <EOL> rb = running_builds [ <NUM_LIT:0> ] <EOL> msg = '<STR_LIT>' % ( rb . get_build_name ( ) , build_config_name , rb . status ) <EOL> else : <EOL> msg = self . _panic_msg_for_more_running_builds ( build_config_name , running_builds ) <EOL> raise OsbsException ( msg ) <EOL> try : <EOL> existing_bc = self . os . get_build_config ( build_config_name ) <EOL> except OsbsException : <EOL> existing_bc = None <EOL> build = None <EOL> if existing_bc is not None : <EOL> utils . buildconfig_update ( existing_bc , build_json ) <EOL> logger . debug ( '<STR_LIT>' , build_config_name ) <EOL> self . os . update_build_config ( build_config_name , json . dumps ( existing_bc ) ) <EOL> else : <EOL>", "answer": "logger . debug ( '<STR_LIT>' , build_config_name )"}, {"prompt": "<s> import unittest <EOL> import weakref <EOL> import GafferUI <EOL> import GafferTest <EOL> import GafferUITest <EOL> class MultiLineTextWidgetTest ( GafferUITest . TestCase ) : <EOL> def testLifespan ( self ) : <EOL> w = GafferUI . MultiLineTextWidget ( ) <EOL> r = weakref . ref ( w ) <EOL> self . failUnless ( r ( ) is w ) <EOL> del w <EOL> self . failUnless ( r ( ) is None ) <EOL> def testEditable ( self ) : <EOL> w = GafferUI . MultiLineTextWidget ( editable = False ) <EOL> self . assertEqual ( w . getEditable ( ) , False ) <EOL> w . setEditable ( True ) <EOL> self . assertEqual ( w . getEditable ( ) , True ) <EOL> def testTextChangedSignal ( self ) : <EOL> w = GafferUI . MultiLineTextWidget ( ) <EOL> c = GafferTest . CapturingSlot ( w . textChangedSignal ( ) ) <EOL> w . setText ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( c [ <NUM_LIT:0> ] , ( w , ) ) <EOL> w . setText ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( c [ <NUM_LIT:0> ] , ( w , ) ) <EOL> def testWrapMode ( self ) : <EOL> w = GafferUI . MultiLineTextWidget ( ) <EOL> self . assertEqual ( w . getWrapMode ( ) , w . WrapMode . WordOrCharacter ) <EOL> for wm in w . WrapMode . values ( ) : <EOL> w . setWrapMode ( wm ) <EOL> self . assertEqual ( w . getWrapMode ( ) , wm ) <EOL> def testCursorPosition ( self ) : <EOL> w = GafferUI . MultiLineTextWidget ( ) <EOL> self . assertEqual ( w . getCursorPosition ( ) , <NUM_LIT:0> ) <EOL> w . setText ( \"<STR_LIT:hello>\" ) <EOL> self . assertEqual ( w . getCursorPosition ( ) , <NUM_LIT:0> ) <EOL> w . setCursorPosition ( <NUM_LIT:1> ) <EOL> self . assertEqual ( w . getCursorPosition ( ) , <NUM_LIT:1> ) <EOL> def testInsertText ( self ) : <EOL> w = GafferUI . MultiLineTextWidget ( ) <EOL> w . setText ( \"<STR_LIT>\" ) <EOL> w . setCursorPosition ( <NUM_LIT:1> ) <EOL> w . insertText ( \"<STR_LIT:abc>\" ) <EOL> self . assertEqual ( w . getText ( ) , \"<STR_LIT>\" ) <EOL> def testFixedLineHeight ( self ) : <EOL> window = GafferUI . Window ( ) <EOL> widget = GafferUI . MultiLineTextWidget ( ) <EOL> window . addChild ( widget ) <EOL> window . setVisible ( True ) <EOL>", "answer": "widget . setFixedLineHeight ( <NUM_LIT:5> )"}, {"prompt": "<s> import os <EOL> from distutils . core import setup <EOL> def read ( fname ) : <EOL> return open ( os . path . join ( os . path . dirname ( __file__ ) , fname ) ) . read ( ) <EOL> setup ( name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> description = '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> url = '<STR_LIT>' , <EOL> packages = [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> classifiers = [ <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> single_input = <NUM_LIT> <EOL> file_input = <NUM_LIT> <EOL> eval_input = <NUM_LIT> <EOL> decorator = <NUM_LIT> <EOL> decorators = <NUM_LIT> <EOL> decorated = <NUM_LIT> <EOL> funcdef = <NUM_LIT> <EOL> parameters = <NUM_LIT> <EOL> varargslist = <NUM_LIT> <EOL> fpdef = <NUM_LIT> <EOL> fplist = <NUM_LIT> <EOL> stmt = <NUM_LIT> <EOL> simple_stmt = <NUM_LIT> <EOL> small_stmt = <NUM_LIT> <EOL> expr_stmt = <NUM_LIT> <EOL> augassign = <NUM_LIT> <EOL> print_stmt = <NUM_LIT> <EOL> del_stmt = <NUM_LIT> <EOL> pass_stmt = <NUM_LIT> <EOL> flow_stmt = <NUM_LIT> <EOL> break_stmt = <NUM_LIT> <EOL> continue_stmt = <NUM_LIT> <EOL> return_stmt = <NUM_LIT> <EOL> yield_stmt = <NUM_LIT> <EOL> raise_stmt = <NUM_LIT> <EOL> import_stmt = <NUM_LIT> <EOL> import_name = <NUM_LIT> <EOL> import_from = <NUM_LIT> <EOL> import_as_name = <NUM_LIT> <EOL> dotted_as_name = <NUM_LIT> <EOL> import_as_names = <NUM_LIT> <EOL> dotted_as_names = <NUM_LIT> <EOL> dotted_name = <NUM_LIT> <EOL> global_stmt = <NUM_LIT> <EOL> exec_stmt = <NUM_LIT> <EOL> assert_stmt = <NUM_LIT> <EOL> compound_stmt = <NUM_LIT> <EOL> if_stmt = <NUM_LIT> <EOL> while_stmt = <NUM_LIT> <EOL> for_stmt = <NUM_LIT> <EOL> try_stmt = <NUM_LIT> <EOL> with_stmt = <NUM_LIT> <EOL> with_item = <NUM_LIT> <EOL> except_clause = <NUM_LIT> <EOL> suite = <NUM_LIT> <EOL> testlist_safe = <NUM_LIT> <EOL> old_test = <NUM_LIT> <EOL> old_lambdef = <NUM_LIT> <EOL> test = <NUM_LIT> <EOL> or_test = <NUM_LIT> <EOL>", "answer": "and_test = <NUM_LIT>"}, {"prompt": "<s> import cgi <EOL> import datetime <EOL> import wsgiref . handlers <EOL> from google . appengine . ext import webapp <EOL> class MainPage ( webapp . RequestHandler ) : <EOL> def get ( self ) : <EOL> self . response . out . write ( '<STR_LIT>' ) <EOL> self . response . out . write ( '<STR_LIT>' ) <EOL> self . response . out . write ( '<STR_LIT>' ) <EOL>", "answer": "application = webapp . WSGIApplication ( ["}, {"prompt": "<s> import numpy as np <EOL> from . . import kern <EOL> from . . core . sparse_gp_mpi import SparseGP_MPI <EOL> from . . likelihoods import Gaussian <EOL> from GPy . core . parameterization . variational import NormalPosterior , NormalPrior <EOL> from . . inference . latent_function_inference . var_dtc_parallel import VarDTC_minibatch <EOL> import logging <EOL> class BayesianGPLVM ( SparseGP_MPI ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , Y , input_dim , X = None , X_variance = None , init = '<STR_LIT>' , num_inducing = <NUM_LIT:10> , <EOL> Z = None , kernel = None , inference_method = None , likelihood = None , <EOL> name = '<STR_LIT>' , mpi_comm = None , normalizer = None , <EOL> missing_data = False , stochastic = False , batchsize = <NUM_LIT:1> , Y_metadata = None ) : <EOL> self . logger = logging . getLogger ( self . __class__ . __name__ ) <EOL> if X is None : <EOL> from . . util . initialization import initialize_latent <EOL> self . logger . info ( \"<STR_LIT>\" . format ( init ) ) <EOL> X , fracs = initialize_latent ( init , input_dim , Y ) <EOL> else : <EOL> fracs = np . ones ( input_dim ) <EOL> self . init = init <EOL> if X_variance is None : <EOL> self . logger . info ( \"<STR_LIT>\" ) <EOL> X_variance = np . random . uniform ( <NUM_LIT:0> , <NUM_LIT> , X . shape ) <EOL> if Z is None : <EOL> self . logger . info ( \"<STR_LIT>\" ) <EOL> Z = np . random . permutation ( X . copy ( ) ) [ : num_inducing ] <EOL> assert Z . shape [ <NUM_LIT:1> ] == X . shape [ <NUM_LIT:1> ] <EOL> if kernel is None : <EOL> self . logger . info ( \"<STR_LIT>\" ) <EOL> kernel = kern . RBF ( input_dim , lengthscale = <NUM_LIT:1.> / fracs , ARD = True ) <EOL> if likelihood is None : <EOL> likelihood = Gaussian ( ) <EOL> self . variational_prior = NormalPrior ( ) <EOL> X = NormalPosterior ( X , X_variance ) <EOL> if inference_method is None : <EOL> if mpi_comm is not None : <EOL> inference_method = VarDTC_minibatch ( mpi_comm = mpi_comm ) <EOL> else : <EOL> from . . inference . latent_function_inference . var_dtc import VarDTC <EOL> self . logger . debug ( \"<STR_LIT>\" ) <EOL> inference_method = VarDTC ( limit = <NUM_LIT:3> if not missing_data else Y . shape [ <NUM_LIT:1> ] ) <EOL> if isinstance ( inference_method , VarDTC_minibatch ) : <EOL> inference_method . mpi_comm = mpi_comm <EOL> super ( BayesianGPLVM , self ) . __init__ ( X , Y , Z , kernel , likelihood = likelihood , <EOL> name = name , inference_method = inference_method , <EOL> normalizer = normalizer , mpi_comm = mpi_comm , <EOL> variational_prior = self . variational_prior , <EOL> Y_metadata = Y_metadata <EOL> ) <EOL> self . link_parameter ( self . X , index = <NUM_LIT:0> ) <EOL> def set_X_gradients ( self , X , X_grad ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> X . mean . gradient , X . variance . gradient = X_grad <EOL> def get_X_gradients ( self , X ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return X . mean . gradient , X . variance . gradient <EOL> def parameters_changed ( self ) : <EOL>", "answer": "super ( BayesianGPLVM , self ) . parameters_changed ( )"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import string <EOL> import re <EOL> import os <EOL> import collections <EOL> import glob <EOL> import stat <EOL> import gzip <EOL> import subprocess <EOL> import itertools <EOL> import numpy <EOL> import numpy . ma <EOL> import shutil <EOL> def getFirstLine ( filename , nlines = <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with open ( filename , '<STR_LIT>' ) as f : <EOL> line = \"<STR_LIT>\" . join ( [ f . readline ( ) for x in range ( nlines ) ] ) <EOL> return line <EOL> def getLastLine ( filename , nlines = <NUM_LIT:1> , read_size = <NUM_LIT> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> f = open ( filename , '<STR_LIT>' ) <EOL> offset = read_size <EOL> f . seek ( <NUM_LIT:0> , <NUM_LIT:2> ) <EOL> file_size = f . tell ( ) <EOL> if file_size == <NUM_LIT:0> : <EOL> return \"<STR_LIT>\" <EOL> while <NUM_LIT:1> : <EOL> if file_size < offset : <EOL> offset = file_size <EOL> f . seek ( - <NUM_LIT:1> * offset , <NUM_LIT:2> ) <EOL> read_str = f . read ( offset ) <EOL> if read_str [ offset - <NUM_LIT:1> ] == '<STR_LIT:\\n>' : <EOL> read_str = read_str [ : - <NUM_LIT:1> ] <EOL> lines = read_str . split ( '<STR_LIT:\\n>' ) <EOL> if len ( lines ) >= nlines + <NUM_LIT:1> : <EOL> return \"<STR_LIT:\\n>\" . join ( lines [ - nlines : ] ) <EOL> if offset == file_size : <EOL> return read_str <EOL> offset += read_size <EOL> f . close ( ) <EOL> def getNumLines ( filename , ignore_comments = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ignore_comments : <EOL> filter_cmd = '<STR_LIT>' <EOL> else : <EOL> filter_cmd = \"<STR_LIT>\" <EOL> if filename . endswith ( \"<STR_LIT>\" ) : <EOL> cmd = \"<STR_LIT>\" % locals ( ) <EOL> else : <EOL> cmd = \"<STR_LIT>\" % locals ( ) <EOL> out = subprocess . Popen ( cmd , <EOL> shell = True , <EOL> stdout = subprocess . PIPE , <EOL> stderr = subprocess . STDOUT <EOL> ) . communicate ( ) [ <NUM_LIT:0> ] <EOL> return int ( out . partition ( b'<STR_LIT:U+0020>' ) [ <NUM_LIT:0> ] ) <EOL> def isEmpty ( filename ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if filename == \"<STR_LIT:->\" : <EOL> return False <EOL> return os . stat ( filename ) [ stat . ST_SIZE ] == <NUM_LIT:0> <EOL> def isComplete ( filename ) : <EOL> '''<STR_LIT>''' <EOL> if filename . endswith ( \"<STR_LIT>\" ) : <EOL> raise NotImplementedError ( <EOL> '<STR_LIT>' ) <EOL> if isEmpty ( filename ) : <EOL> return False <EOL> lastline = getLastLine ( filename ) <EOL> return lastline . startswith ( \"<STR_LIT>\" ) <EOL> def touchFile ( filename , times = None ) : <EOL> '''<STR_LIT>''' <EOL> existed = os . path . exists ( filename ) <EOL> fhandle = file ( filename , '<STR_LIT:a>' ) <EOL> if filename . endswith ( \"<STR_LIT>\" ) and not existed : <EOL> fhandle = gzip . GzipFile ( filename , fileobj = fhandle ) <EOL> try : <EOL> os . utime ( filename , times ) <EOL> finally : <EOL> fhandle . close ( ) <EOL> def openFile ( filename , mode = \"<STR_LIT:r>\" , create_dir = False ) : <EOL> '''<STR_LIT>''' <EOL> _ , ext = os . path . splitext ( filename ) <EOL> if create_dir : <EOL> dirname = os . path . dirname ( filename ) <EOL> if dirname and not os . path . exists ( dirname ) : <EOL> os . makedirs ( dirname ) <EOL> if ext . lower ( ) in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> return gzip . open ( filename , mode ) <EOL> else : <EOL> return open ( filename , mode ) <EOL> def zapFile ( filename , outfile = None ) : <EOL> '''<STR_LIT>''' <EOL> if outfile and os . path . getsize ( outfile ) == <NUM_LIT:0> : <EOL> raise ValueError ( '<STR_LIT>' % outfile ) <EOL> original = os . stat ( filename ) <EOL> if original . st_size == <NUM_LIT:0> : <EOL> return None , None <EOL> if os . path . islink ( filename ) : <EOL> linkdest = os . readlink ( filename ) <EOL> os . unlink ( filename ) <EOL> f = open ( filename , \"<STR_LIT:w>\" ) <EOL> f . close ( ) <EOL> else : <EOL> linkdest = None <EOL> f = open ( filename , \"<STR_LIT:w>\" ) <EOL> f . truncate ( ) <EOL> f . close ( ) <EOL> os . utime ( filename , ( original . st_atime , original . st_mtime ) ) <EOL> os . chmod ( filename , original . st_mode ) <EOL> return original , linkdest <EOL> def cloneFile ( infile , outfile ) : <EOL> '''<STR_LIT>''' <EOL> if os . path . dirname ( infile ) != os . path . dirname ( outfile ) : <EOL> relpath = os . path . relpath ( <EOL> os . path . dirname ( infile ) , os . path . dirname ( outfile ) ) <EOL> else : <EOL> relpath = \"<STR_LIT:.>\" <EOL> target = os . path . join ( relpath , os . path . basename ( infile ) ) <EOL> try : <EOL> os . symlink ( target , outfile ) <EOL> except OSError : <EOL> pass <EOL> def shadowFile ( infile , outfile ) : <EOL> '''<STR_LIT>''' <EOL> if outfile != infile : <EOL> shutil . move ( infile , outfile ) <EOL> touchFile ( infile ) <EOL> else : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> def val2str ( val , format = \"<STR_LIT>\" , na = \"<STR_LIT>\" ) : <EOL> '''<STR_LIT>''' <EOL> if type ( val ) == int : <EOL> return format % val <EOL> elif type ( val ) == float : <EOL> return format % val <EOL> try : <EOL> x = format % val <EOL> except ( ValueError , TypeError ) : <EOL> x = na <EOL> return x <EOL> def str2val ( val , format = \"<STR_LIT>\" , na = \"<STR_LIT>\" , list_detection = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if val is None : <EOL> return val <EOL> def _convert ( v ) : <EOL> try : <EOL> x = int ( v ) <EOL> except ValueError : <EOL> try : <EOL> x = float ( v ) <EOL> except ValueError : <EOL> return v <EOL> return x <EOL> if list_detection and \"<STR_LIT:U+002C>\" in val : <EOL> return [ _convert ( v ) for v in val . split ( \"<STR_LIT:U+002C>\" ) ] <EOL> else : <EOL> return _convert ( val ) <EOL> def prettyPercent ( numerator , denominator , format = \"<STR_LIT>\" , na = \"<STR_LIT>\" ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> x = format % ( <NUM_LIT> * numerator / denominator ) <EOL> except ( ValueError , ZeroDivisionError ) : <EOL> x = \"<STR_LIT>\" <EOL> return x <EOL> def prettyString ( val ) : <EOL> '''<STR_LIT>''' <EOL> if val is not None : <EOL> return val <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> def which ( program ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def is_exe ( fpath ) : <EOL> return os . path . exists ( fpath ) and os . access ( fpath , os . X_OK ) <EOL> fpath , fname = os . path . split ( program ) <EOL> if fpath : <EOL> if is_exe ( program ) : <EOL> return program <EOL> else : <EOL> for path in os . environ [ \"<STR_LIT>\" ] . split ( os . pathsep ) : <EOL> exe_file = os . path . join ( path , program ) <EOL> if is_exe ( exe_file ) : <EOL> return exe_file <EOL> return None <EOL> def iterate ( infile ) : <EOL> '''<STR_LIT>''' <EOL> n = <NUM_LIT:0> <EOL> for line in infile : <EOL> if line . startswith ( \"<STR_LIT:#>\" ) : <EOL> continue <EOL> n += <NUM_LIT:1> <EOL> if n == <NUM_LIT:1> : <EOL> header = re . sub ( \"<STR_LIT>\" , \"<STR_LIT:_>\" , line [ : - <NUM_LIT:1> ] ) . split ( ) <EOL> DATA = collections . namedtuple ( \"<STR_LIT>\" , header ) <EOL> continue <EOL> result = DATA ( * line [ : - <NUM_LIT:1> ] . split ( ) ) <EOL> yield result <EOL> def iterate_tabular ( infile , sep = \"<STR_LIT:\\t>\" ) : <EOL> '''<STR_LIT>''' <EOL> for line in infile : <EOL> if line . startswith ( \"<STR_LIT:#>\" ) : <EOL> continue <EOL> yield line [ : - <NUM_LIT:1> ] . split ( sep ) <EOL> def iterator_split ( infile , regex ) : <EOL> '''<STR_LIT>''' <EOL> chunk_list = [ ] <EOL> regex = re . compile ( regex ) <EOL> for x in infile : <EOL> if regex . search ( x ) : <EOL> if len ( chunk_list ) : <EOL> yield chunk_list <EOL> chunk_list = [ ] <EOL> chunk_list . append ( x ) <EOL> else : <EOL> chunk_list . append ( x ) <EOL> yield chunk_list <EOL> def snip ( filename , extension = None , alt_extension = None , <EOL> strip_path = False ) : <EOL> '''<STR_LIT>''' <EOL> if extension : <EOL> if filename . endswith ( extension ) : <EOL> root = filename [ : - len ( extension ) ] <EOL> elif alt_extension and filename . endswith ( alt_extension ) : <EOL> root = filename [ : - len ( alt_extension ) ] <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" % <EOL> ( filename , extension ) ) <EOL> else : <EOL> root , ext = os . path . splitext ( filename ) <EOL> if strip_path : <EOL> snipped = os . path . basename ( root ) <EOL> else : <EOL> snipped = root <EOL> return snipped <EOL> def checkPresenceOfFiles ( filenames ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> missing = [ ] <EOL> for filename in filenames : <EOL> if not os . path . exists ( filename ) : <EOL> missing . append ( filename ) <EOL> return missing <EOL> def human2bytes ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> SYMBOLS = { <EOL> '<STR_LIT>' : ( '<STR_LIT:B>' , '<STR_LIT>' , '<STR_LIT:M>' , '<STR_LIT>' , '<STR_LIT:T>' , '<STR_LIT:P>' , '<STR_LIT:E>' , '<STR_LIT>' , '<STR_LIT:Y>' ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) , <EOL> } <EOL> init = s <EOL> num = \"<STR_LIT>\" <EOL> while s and s [ <NUM_LIT:0> : <NUM_LIT:1> ] . isdigit ( ) or s [ <NUM_LIT:0> : <NUM_LIT:1> ] == '<STR_LIT:.>' : <EOL> num += s [ <NUM_LIT:0> ] <EOL> s = s [ <NUM_LIT:1> : ] <EOL> num = float ( num ) <EOL> letter = s . strip ( ) <EOL> for name , sset in SYMBOLS . items ( ) : <EOL> if letter in sset : <EOL> break <EOL> else : <EOL> if letter == '<STR_LIT:k>' : <EOL> sset = SYMBOLS [ '<STR_LIT>' ] <EOL> letter = letter . upper ( ) <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" % init ) <EOL> prefix = { sset [ <NUM_LIT:0> ] : <NUM_LIT:1> } <EOL> for i , s in enumerate ( sset [ <NUM_LIT:1> : ] ) : <EOL> prefix [ s ] = <NUM_LIT:1> << ( i + <NUM_LIT:1> ) * <NUM_LIT:10> <EOL> return int ( num * prefix [ letter ] ) <EOL> def convertDictionary ( d , map = { } ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rx_int = re . compile ( \"<STR_LIT>\" ) <EOL> rx_float = re . compile ( \"<STR_LIT>\" ) <EOL> if \"<STR_LIT:default>\" in map : <EOL> k = \"<STR_LIT:default>\" <EOL> if map [ k ] == \"<STR_LIT:int>\" : <EOL> default = int <EOL> elif map [ k ] == \"<STR_LIT:float>\" : <EOL> default = float <EOL> elif map [ k ] == \"<STR_LIT:string>\" : <EOL> default = str <EOL> else : <EOL> default = False <EOL> for k , vv in d . items ( ) : <EOL> if vv is None : <EOL> continue <EOL> v = vv . strip ( ) <EOL> try : <EOL> if k in map : <EOL> if map [ k ] == \"<STR_LIT:int>\" : <EOL> d [ k ] = int ( v ) <EOL> elif map [ k ] == \"<STR_LIT:float>\" : <EOL> d [ k ] = float ( v ) <EOL> elif map [ k ] == \"<STR_LIT:string>\" : <EOL> pass <EOL> continue <EOL> elif default : <EOL> if v != \"<STR_LIT>\" : <EOL> d [ k ] = default ( v ) <EOL> else : <EOL> d [ k ] = v <EOL> continue <EOL> except TypeError , msg : <EOL> raise TypeError ( \"<STR_LIT>\" % ( k , msg ) ) <EOL> try : <EOL> if rx_int . match ( v ) : <EOL> d [ k ] = int ( v ) <EOL> elif rx_float . match ( v ) : <EOL> d [ k ] = float ( v ) <EOL> except TypeError , msg : <EOL> raise TypeError ( <EOL> \"<STR_LIT>\" % str ( v ) ) <EOL> except ValueError , msg : <EOL> raise ValueError ( \"<STR_LIT>\" % ( msg , str ( d ) ) ) <EOL> return d <EOL> class nested_dict ( collections . defaultdict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> collections . defaultdict . __init__ ( self , nested_dict ) <EOL> def iterflattened ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for key , value in self . iteritems ( ) : <EOL> if isinstance ( value , nested_dict ) : <EOL> for keykey , value in value . iterflattened ( ) : <EOL> yield ( key , ) + keykey , value <EOL> else : <EOL> yield ( key , ) , value <EOL> def flatten ( l , ltypes = ( list , tuple ) ) : <EOL> '''<STR_LIT>''' <EOL> ltype = type ( l ) <EOL> l = list ( l ) <EOL> i = <NUM_LIT:0> <EOL> while i < len ( l ) : <EOL> while isinstance ( l [ i ] , ltypes ) : <EOL> if not l [ i ] : <EOL> l . pop ( i ) <EOL> i -= <NUM_LIT:1> <EOL> break <EOL> else : <EOL> l [ i : i + <NUM_LIT:1> ] = l [ i ] <EOL> i += <NUM_LIT:1> <EOL> return ltype ( l ) <EOL> def invert_dictionary ( dict , make_unique = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> inv = { } <EOL> if make_unique : <EOL> for k , v in dict . iteritems ( ) : <EOL> inv [ v ] = k <EOL> else : <EOL> for k , v in dict . iteritems ( ) : <EOL> inv . setdefault ( v , [ ] ) . append ( k ) <EOL> return inv <EOL> class FilePool : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> maxopen = <NUM_LIT> <EOL> def __init__ ( self , <EOL> output_pattern = None , <EOL> header = None , <EOL> force = True ) : <EOL> self . mFiles = { } <EOL> self . mOutputPattern = output_pattern <EOL> self . open = open <EOL> if output_pattern : <EOL> _ , ext = os . path . splitext ( output_pattern ) <EOL> if ext . lower ( ) in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : <EOL> self . open = gzip . open <EOL> self . mCounts = collections . defaultdict ( int ) <EOL> self . mHeader = header <EOL> if force and output_pattern : <EOL> for f in glob . glob ( re . sub ( \"<STR_LIT:%s>\" , \"<STR_LIT:*>\" , output_pattern ) ) : <EOL> os . remove ( f ) <EOL> def __del__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for file in self . mFiles . values ( ) : <EOL> file . close ( ) <EOL> def __len__ ( self ) : <EOL> return len ( self . mCounts ) <EOL> def close ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for file in self . mFiles . values ( ) : <EOL> file . close ( ) <EOL> def values ( self ) : <EOL> return self . mCounts . values ( ) <EOL> def keys ( self ) : <EOL> return self . mCounts . keys ( ) <EOL> def iteritems ( self ) : <EOL> return self . mCounts . iteritems ( ) <EOL> def items ( self ) : <EOL> return self . mCounts . items ( ) <EOL> def __iter__ ( self ) : <EOL> return self . mCounts . __iter__ ( ) <EOL> def getFile ( self , identifier ) : <EOL> return identifier <EOL> def getFilename ( self , identifier ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . mOutputPattern : <EOL> return re . sub ( \"<STR_LIT:%s>\" , str ( identifier ) , self . mOutputPattern ) <EOL> else : <EOL> return identifier <EOL> def setHeader ( self , header ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . mHeader = header <EOL> def openFile ( self , filename , mode = \"<STR_LIT:w>\" ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if mode in ( \"<STR_LIT:w>\" , \"<STR_LIT:a>\" ) : <EOL> dirname = os . path . dirname ( filename ) <EOL> if dirname and not os . path . exists ( dirname ) : <EOL> os . makedirs ( dirname ) <EOL> return self . open ( filename , mode ) <EOL> def write ( self , identifier , line ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> filename = self . getFilename ( identifier ) <EOL> if filename not in self . mFiles : <EOL> if self . maxopen and len ( self . mFiles ) > self . maxopen : <EOL> for f in self . mFiles . values ( ) : <EOL> f . close ( ) <EOL> self . mFiles = { } <EOL> self . mFiles [ filename ] = self . openFile ( filename , \"<STR_LIT:a>\" ) <EOL> if self . mHeader : <EOL> self . mFiles [ filename ] . write ( self . mHeader ) <EOL> try : <EOL> self . mFiles [ filename ] . write ( line ) <EOL> except ValueError , msg : <EOL> raise ValueError ( <EOL> \"<STR_LIT>\" % ( filename , msg ) ) <EOL> self . mCounts [ filename ] += <NUM_LIT:1> <EOL> def deleteFiles ( self , min_size = <NUM_LIT:0> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ndeleted = <NUM_LIT:0> <EOL> for filename , counts in self . mCounts . items ( ) : <EOL> if counts < min_size : <EOL> os . remove ( filename ) <EOL> ndeleted += <NUM_LIT:1> <EOL> return ndeleted <EOL> class FilePoolMemory ( FilePool ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> maxopen = <NUM_LIT> <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> FilePool . __init__ ( self , * args , ** kwargs ) <EOL> self . data = collections . defaultdict ( list ) <EOL> self . isClosed = False <EOL> def __del__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . isClosed : <EOL> self . close ( ) <EOL> def close ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . isClosed : <EOL> raise IOError ( \"<STR_LIT>\" ) <EOL> for filename , data in self . data . iteritems ( ) : <EOL> f = self . openFile ( filename , \"<STR_LIT:a>\" ) <EOL> if self . mHeader : <EOL> f . write ( self . mHeader ) <EOL> f . write ( \"<STR_LIT>\" . join ( data ) ) <EOL> f . close ( ) <EOL> self . isClosed = True <EOL> def write ( self , identifier , line ) : <EOL> filename = self . getFilename ( identifier ) <EOL> self . data [ filename ] . append ( line ) <EOL> self . mCounts [ filename ] += <NUM_LIT:1> <EOL> def readMap ( infile , <EOL> columns = ( <NUM_LIT:0> , <NUM_LIT:1> ) , <EOL> map_functions = ( str , str ) , <EOL> both_directions = False , <EOL> has_header = False , <EOL> dtype = dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> m = dtype ( ) <EOL> r = dtype ( ) <EOL> n = <NUM_LIT:0> <EOL> if columns == \"<STR_LIT:all>\" : <EOL> key_column = <NUM_LIT:0> <EOL> value_column = None <EOL> else : <EOL> key_column , value_column = columns <EOL> key_function , value_function = map_functions <EOL> datatype = None <EOL> for l in infile : <EOL> if l [ <NUM_LIT:0> ] == \"<STR_LIT:#>\" : <EOL> continue <EOL> n += <NUM_LIT:1> <EOL> if has_header and n == <NUM_LIT:1> : <EOL> if columns == \"<STR_LIT:all>\" : <EOL> header = l [ : - <NUM_LIT:1> ] . split ( \"<STR_LIT:\\t>\" ) <EOL> datatype = collections . namedtuple ( \"<STR_LIT>\" , header [ <NUM_LIT:1> : ] ) <EOL> continue <EOL> d = l [ : - <NUM_LIT:1> ] . split ( \"<STR_LIT:\\t>\" ) <EOL> if len ( d ) < <NUM_LIT:2> : <EOL> continue <EOL> key = key_function ( d [ key_column ] ) <EOL> if value_column : <EOL> val = value_function ( d [ value_column ] ) <EOL> elif datatype : <EOL> val = datatype . _make ( [ d [ x ] for x in range ( <NUM_LIT:1> , len ( d ) ) ] ) <EOL> else : <EOL> val = tuple ( map ( value_function , [ d [ x ] for x in range ( <NUM_LIT:1> , len ( d ) ) ] ) ) <EOL> m [ key ] = val <EOL> if val not in r : <EOL> r [ val ] = [ ] <EOL> r [ val ] . append ( key ) <EOL> if both_directions : <EOL> return m , r <EOL> else : <EOL> return m <EOL> def readList ( infile , <EOL> column = <NUM_LIT:0> , <EOL> map_function = str , <EOL> map_category = { } , <EOL> with_title = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> m = [ ] <EOL> title = None <EOL> for l in infile : <EOL> if l [ <NUM_LIT:0> ] == \"<STR_LIT:#>\" : <EOL> continue <EOL> if with_title and not title : <EOL> title = l [ : - <NUM_LIT:1> ] . split ( \"<STR_LIT:\\t>\" ) [ column ] <EOL> continue <EOL> try : <EOL> d = map_function ( l [ : - <NUM_LIT:1> ] . split ( \"<STR_LIT:\\t>\" ) [ column ] ) <EOL> except ValueError : <EOL> continue <EOL> if map_category : <EOL> d = map_category [ d ] <EOL> m . append ( d ) <EOL> return m <EOL> def readMultiMap ( infile , <EOL> columns = ( <NUM_LIT:0> , <NUM_LIT:1> ) , <EOL> map_functions = ( str , str ) , <EOL> both_directions = False , <EOL> has_header = False , <EOL> dtype = dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> m = dtype ( ) <EOL> r = dtype ( ) <EOL> n = <NUM_LIT:0> <EOL> for l in infile : <EOL> if l [ <NUM_LIT:0> ] == \"<STR_LIT:#>\" : <EOL> continue <EOL> n += <NUM_LIT:1> <EOL> if has_header and n == <NUM_LIT:1> : <EOL> continue <EOL> d = l [ : - <NUM_LIT:1> ] . split ( \"<STR_LIT:\\t>\" ) <EOL> try : <EOL> key = map_functions [ <NUM_LIT:0> ] ( d [ columns [ <NUM_LIT:0> ] ] ) <EOL> val = map_functions [ <NUM_LIT:1> ] ( d [ columns [ <NUM_LIT:1> ] ] ) <EOL> except ( ValueError , IndexError ) , msg : <EOL> raise ValueError ( \"<STR_LIT>\" % ( l [ : - <NUM_LIT:1> ] , msg ) ) <EOL> if key not in m : <EOL> m [ key ] = [ ] <EOL> m [ key ] . append ( val ) <EOL> if val not in r : <EOL> r [ val ] = [ ] <EOL> r [ val ] . append ( key ) <EOL> if both_directions : <EOL> return m , r <EOL> else : <EOL> return m <EOL> def readMatrix ( infile , dtype = numpy . float ) : <EOL> '''<STR_LIT>''' <EOL> lines = [ l for l in infile . readlines ( ) if not l . startswith ( \"<STR_LIT:#>\" ) ] <EOL> nrows = len ( lines ) - <NUM_LIT:1> <EOL> col_headers = lines [ <NUM_LIT:0> ] [ : - <NUM_LIT:1> ] . split ( \"<STR_LIT:\\t>\" ) [ <NUM_LIT:1> : ] <EOL> ncols = len ( col_headers ) <EOL> matrix = numpy . zeros ( ( nrows , ncols ) , dtype = dtype ) <EOL> row_headers = [ ] <EOL> for row , l in enumerate ( lines [ <NUM_LIT:1> : ] ) : <EOL> data = l [ : - <NUM_LIT:1> ] . split ( \"<STR_LIT:\\t>\" ) <EOL> row_headers . append ( data [ <NUM_LIT:0> ] ) <EOL> matrix [ row ] = numpy . array ( data [ <NUM_LIT:1> : ] , dtype = dtype ) <EOL> return matrix , row_headers , col_headers <EOL> def writeMatrix ( outfile , matrix , row_headers , col_headers , row_header = \"<STR_LIT>\" ) : <EOL> '''<STR_LIT>''' <EOL> outfile . write ( \"<STR_LIT>\" % ( row_header , \"<STR_LIT:\\t>\" . join ( col_headers ) ) ) <EOL> for x , row in enumerate ( matrix ) : <EOL> assert len ( row ) == len ( col_headers ) <EOL> outfile . write ( \"<STR_LIT>\" % ( row_headers [ x ] , \"<STR_LIT:\\t>\" . join ( map ( str , row ) ) ) ) <EOL> def readTable ( file , <EOL> separator = \"<STR_LIT:\\t>\" , <EOL> numeric_type = numpy . float , <EOL> take = \"<STR_LIT:all>\" , <EOL> headers = True , <EOL> truncate = None , <EOL> cumulate_out_of_range = True , <EOL> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> lines = filter ( lambda x : x [ <NUM_LIT:0> ] != \"<STR_LIT:#>\" , file . readlines ( ) ) <EOL> if len ( lines ) == <NUM_LIT:0> : <EOL> return None , [ ] <EOL> if take == \"<STR_LIT:all>\" : <EOL> num_cols = len ( string . split ( lines [ <NUM_LIT:0> ] [ : - <NUM_LIT:1> ] , \"<STR_LIT:\\t>\" ) ) <EOL> take = range ( <NUM_LIT:0> , num_cols ) <EOL> else : <EOL> num_cols = len ( take ) <EOL> if headers : <EOL> headers = lines [ <NUM_LIT:0> ] [ : - <NUM_LIT:1> ] . split ( \"<STR_LIT:\\t>\" ) <EOL> headers = map ( lambda x : headers [ x ] , take ) <EOL> del lines [ <NUM_LIT:0> ] <EOL> num_rows = len ( lines ) <EOL> matrix = numpy . ma . masked_array ( <EOL> numpy . zeros ( ( num_rows , num_cols ) , numeric_type ) ) <EOL> if truncate : <EOL> min_row , max_row = truncate <EOL> nrow = <NUM_LIT:0> <EOL> min_data = [ <NUM_LIT:0> ] * num_cols <EOL> max_data = None <EOL> for l in lines : <EOL> data = l [ : - <NUM_LIT:1> ] . split ( \"<STR_LIT:\\t>\" ) <EOL> data = map ( lambda x : data [ x ] , take ) <EOL> for x in range ( len ( data ) ) : <EOL> try : <EOL> data [ x ] = float ( data [ x ] ) <EOL> except ValueError : <EOL> data [ x ] = numpy . ma . masked <EOL> if truncate is not None : <EOL> if data [ <NUM_LIT:0> ] < min_row : <EOL> if cumulate_out_of_range : <EOL> for x in range ( <NUM_LIT:1> , num_cols ) : <EOL> min_data [ x ] += data [ x ] <EOL> continue <EOL> elif data [ <NUM_LIT:0> ] >= max_row : <EOL> if max_data is None : <EOL> max_data = [ <NUM_LIT:0> ] * num_cols <EOL> max_data [ <NUM_LIT:0> ] = max_row <EOL> for x in range ( <NUM_LIT:1> , num_cols ) : <EOL> try : <EOL> max_data [ x ] += data [ x ] <EOL> except TypeError : <EOL> continue <EOL> continue <EOL> elif min_row is not None : <EOL> if cumulate_out_of_range : <EOL> for x in range ( <NUM_LIT:0> , num_cols ) : <EOL> try : <EOL> min_data [ x ] += data [ x ] <EOL> except TypeError : <EOL> continue <EOL> else : <EOL> min_data = data <EOL> data = min_data <EOL> min_row = None <EOL> for x in range ( len ( data ) ) : <EOL> matrix [ nrow , x ] = data [ x ] <EOL> nrow += <NUM_LIT:1> <EOL> if truncate is not None : <EOL> if cumulate_out_of_range : <EOL> if max_data is not None : <EOL> matrix [ nrow ] = max_data <EOL> matrix = matrix [ <NUM_LIT:0> : nrow + <NUM_LIT:1> , <NUM_LIT:0> : num_cols ] <EOL> return matrix , headers <EOL> def writeTable ( outfile , table , columns = None , fillvalue = \"<STR_LIT>\" ) : <EOL> '''<STR_LIT>''' <EOL> if type ( table ) == dict : <EOL> if columns is None : <EOL> columns = table . keys ( ) <EOL> outfile . write ( \"<STR_LIT:\\t>\" . join ( columns ) + \"<STR_LIT:\\n>\" ) <EOL> data = [ table [ x ] for x in columns ] <EOL> data = list ( itertools . izip_longest ( * data , fillvalue = fillvalue ) ) <EOL> for d in data : <EOL> outfile . write ( \"<STR_LIT:\\t>\" . join ( map ( str , d ) ) + \"<STR_LIT:\\n>\" ) <EOL> else : <EOL> raise NotImplementedError <EOL> def ReadMap ( * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return readMap ( * args , ** kwargs ) <EOL> def ReadList ( * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return readList ( * args , ** kwargs ) <EOL> def writeLines ( outfile , lines , header = False ) : <EOL> '''<STR_LIT>''' <EOL> handle = openFile ( outfile , \"<STR_LIT:w>\" ) <EOL> if header : <EOL> handle . write ( \"<STR_LIT:\\t>\" . join ( [ str ( title ) for title in header ] ) + \"<STR_LIT:\\n>\" ) <EOL> for line in lines : <EOL> handle . write ( \"<STR_LIT:\\t>\" . join ( [ str ( field ) for field in line ] ) + \"<STR_LIT:\\n>\" ) <EOL> handle . close ( ) <EOL> def txtToDict ( filename , key = None , sep = \"<STR_LIT:\\t>\" ) : <EOL> '''<STR_LIT>''' <EOL> count = <NUM_LIT:0> <EOL> result = { } <EOL> valueidx , keyidx = False , False <EOL> field_names = [ ] <EOL> with open ( filename , \"<STR_LIT:r>\" ) as fh : <EOL> for line in fh : <EOL> if line . startswith ( \"<STR_LIT:#>\" ) : <EOL> continue <EOL> if count == <NUM_LIT:0> : <EOL> fieldn = <NUM_LIT:0> <EOL> for rawfield in line . split ( sep ) : <EOL> field = rawfield . strip ( ) <EOL> if field == key : <EOL> keyidx = fieldn <EOL> field_names . append ( field ) <EOL> fieldn += <NUM_LIT:1> <EOL> if not keyidx : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> fields = [ x . strip ( ) for x in line . split ( sep ) ] <EOL> fieldn = <NUM_LIT:0> <EOL> thiskey = fields [ keyidx ] <EOL> result [ thiskey ] = { } <EOL> for field in fields : <EOL> if fieldn == keyidx : <EOL> pass <EOL> else : <EOL> colkey = field_names [ fieldn ] <EOL> result [ thiskey ] [ colkey ] = field <EOL> fieldn += <NUM_LIT:1> <EOL> count += <NUM_LIT:1> <EOL> return ( result ) <EOL> def pickle ( file_name , obj ) : <EOL> '''<STR_LIT>''' <EOL> with open ( file_name , \"<STR_LIT:wb>\" ) as pkl_file : <EOL> pickle . dump ( obj , pkl_file ) <EOL>", "answer": "return"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import nose . tools <EOL> from python_toolbox import import_tools <EOL> from python_toolbox . import_tools import exists <EOL> def test ( ) : <EOL> '''<STR_LIT>''' <EOL> assert not exists ( '<STR_LIT>' ) <EOL> assert not exists ( '<STR_LIT>' ) <EOL> assert not exists ( '<STR_LIT>' ) <EOL> assert exists ( '<STR_LIT:email>' ) <EOL>", "answer": "assert exists ( '<STR_LIT>' )"}, {"prompt": "<s> from numpy import add_newdoc <EOL> add_newdoc ( '<STR_LIT>' , '<STR_LIT>' , <EOL> \"\"\"<STR_LIT>\"\"\" ) <EOL>", "answer": "add_newdoc ( '<STR_LIT>' , '<STR_LIT>' ,"}, {"prompt": "<s> import six <EOL> from neutronclient . _i18n import _ <EOL> from neutronclient . neutron import v2_0 as neutronV20 <EOL> def _format_provider ( pool ) : <EOL> return pool . get ( '<STR_LIT>' ) or '<STR_LIT>' <EOL> class ListPool ( neutronV20 . ListCommand ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> resource = '<STR_LIT>' <EOL> list_columns = [ '<STR_LIT:id>' , '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT:status>' ] <EOL> _formatters = { '<STR_LIT>' : _format_provider } <EOL> pagination_support = True <EOL> sorting_support = True <EOL> class ShowPool ( neutronV20 . ShowCommand ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> resource = '<STR_LIT>' <EOL> class CreatePool ( neutronV20 . CreateCommand ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> resource = '<STR_LIT>' <EOL> def add_known_arguments ( self , parser ) : <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> dest = '<STR_LIT>' , action = '<STR_LIT>' , <EOL> help = _ ( '<STR_LIT>' ) ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> help = _ ( '<STR_LIT>' ) ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> required = True , <EOL> choices = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> help = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> required = True , <EOL>", "answer": "help = _ ( '<STR_LIT>' ) )"}, {"prompt": "<s> import json <EOL> import logging <EOL> from horizon import exceptions <EOL> from horizon import forms <EOL> from horizon import tables <EOL> from horizon import tabs <EOL> from django . core . urlresolvers import reverse <EOL> from django . core . urlresolvers import reverse_lazy <EOL> from django . http import HttpResponse <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from django . views import generic <EOL> from openstack_dashboard import api <EOL> from openstack_dashboard . dashboards . project . stacks import api as project_api <EOL> from openstack_dashboard . dashboards . project . stacks import forms as project_forms <EOL> from openstack_dashboard . dashboards . project . stacks import tables as project_tables <EOL>", "answer": "from openstack_dashboard . dashboards . project . stacks import tabs as project_tabs"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> import logging <EOL> from argparse import ArgumentParser <EOL> from json import loads as json_loads <EOL> from sys import stdout , stderr <EOL> from . v1 . session import GraphDatabase , CypherError <EOL>", "answer": "class ColourFormatter ( logging . Formatter ) :"}, {"prompt": "<s> __import__ ( '<STR_LIT>' ) . declare_namespace ( __name__ ) <EOL> version = \"<STR_LIT>\" <EOL>", "answer": "version_info = ( <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT> )"}, {"prompt": "<s> import os <EOL> import re <EOL> import shutil <EOL> import subprocess <EOL> from uuid import uuid1 <EOL> from xml . dom . minidom import parse <EOL> import pkg_resources <EOL> class PythonVersion ( object ) : <EOL> def __init__ ( self , version , key_root , display_version ) : <EOL> self . version = version <EOL> self . display_version = display_version <EOL> self . id = '<STR_LIT>' + version . replace ( '<STR_LIT:.>' , '<STR_LIT>' ) + key_root <EOL> self . key_root = key_root <EOL> self . key = r'<STR_LIT>' % version <EOL> self . dir_prop = '<STR_LIT>' % self . id <EOL> self . exe_prop = '<STR_LIT>' % self . id <EOL> self . components = [ ] <EOL> PYTHON_VERSIONS = ( <EOL> PythonVersion ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> PythonVersion ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> PythonVersion ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> PythonVersion ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> PythonVersion ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> PythonVersion ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ) <EOL> MISSING_PYTHON_MESSAGE = '<STR_LIT>' '<STR_LIT>' <EOL> exclude_packages = [ ] <EOL> ids = set ( ) <EOL> def id ( name ) : <EOL> num = <NUM_LIT:1> <EOL> id = name <EOL> while id in ids : <EOL> num += <NUM_LIT:1> <EOL> id = '<STR_LIT>' % ( name , num ) <EOL> ids . add ( id ) <EOL> return id <EOL> shortnames = set ( ) <EOL> def shortname ( name , ext ) : <EOL> num = <NUM_LIT:1> <EOL> shortname = '<STR_LIT>' % ( name [ : <NUM_LIT:8> ] , ext ) <EOL> while shortname in shortnames : <EOL> num += <NUM_LIT:1> <EOL> shortname = '<STR_LIT>' % ( name [ : <NUM_LIT:6> ] , num , ext ) <EOL> shortnames . add ( shortname ) <EOL> return shortname <EOL> def node ( doc , node_name , ** kwargs ) : <EOL> node = doc . createElement ( node_name ) <EOL> for key , value in kwargs . items ( ) : <EOL> node . setAttribute ( key , value ) <EOL> return node <EOL> def add_package ( name , src_dir , doc , dest_node , pyver ) : <EOL> if name in exclude_packages : <EOL> return <EOL> src_path = os . path . join ( src_dir , name ) <EOL> directory = node ( doc , '<STR_LIT>' , <EOL> Id = id ( '<STR_LIT>' % name ) , <EOL> Name = name ) <EOL> dest_node . appendChild ( doc . createTextNode ( '<STR_LIT>' ) ) <EOL> dest_node . appendChild ( directory ) <EOL> dest_node . appendChild ( doc . createTextNode ( '<STR_LIT>' ) ) <EOL> directory . appendChild ( doc . createTextNode ( '<STR_LIT:\\n>' ) ) <EOL> for filename in os . listdir ( src_path ) : <EOL> file_path = os . path . join ( src_path , filename ) <EOL> if os . path . isdir ( file_path ) : <EOL> if os . path . exists ( os . path . join ( file_path , '<STR_LIT>' ) ) : <EOL> add_package ( filename , src_path , doc , directory , pyver ) <EOL> elif filename . endswith ( '<STR_LIT>' ) : <EOL> add_module ( filename , src_path , doc , directory , pyver ) <EOL> def component_id ( name , pyver ) : <EOL> component = id ( name ) <EOL> pyver . components . append ( component ) <EOL> return component <EOL> guid_seq = <NUM_LIT:0> <EOL> def guid ( ) : <EOL> global guid_seq <EOL> guid_seq += <NUM_LIT:1> <EOL> return uuid1 ( clock_seq = guid_seq ) . hex . upper ( ) <EOL> def add_module ( name , src_dir , doc , dest_node , pyver ) : <EOL> src_path = os . path . join ( src_dir , name ) <EOL> basefile = os . path . splitext ( name ) [ <NUM_LIT:0> ] <EOL> component = node ( doc , '<STR_LIT>' , <EOL> Id = component_id ( '<STR_LIT>' % basefile , pyver ) , <EOL> Guid = guid ( ) ) <EOL> component . appendChild ( <EOL> node ( doc , '<STR_LIT>' , <EOL> Id = id ( '<STR_LIT>' % basefile ) , <EOL> Name = name , <EOL> DiskId = '<STR_LIT:1>' , <EOL> Source = src_path ) ) <EOL> component . appendChild ( <EOL> node ( doc , '<STR_LIT>' , <EOL> Id = id ( '<STR_LIT>' % basefile ) , <EOL> Name = '<STR_LIT>' % basefile , <EOL> On = '<STR_LIT>' ) ) <EOL> component . appendChild ( <EOL> node ( doc , '<STR_LIT>' , <EOL> Id = id ( '<STR_LIT>' % basefile ) , <EOL> Name = '<STR_LIT>' % basefile , <EOL> On = '<STR_LIT>' ) ) <EOL> dest_node . appendChild ( component ) <EOL> dest_node . appendChild ( doc . createTextNode ( '<STR_LIT:\\n>' ) ) <EOL> def call ( cmd ) : <EOL> print cmd <EOL> return subprocess . call ( cmd , shell = True ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> script_dir = os . path . dirname ( __file__ ) <EOL> root_dir = os . path . join ( script_dir , '<STR_LIT>' ) <EOL> dist_dir = os . path . join ( root_dir , '<STR_LIT>' ) <EOL> try : <EOL> os . makedirs ( dist_dir ) <EOL> except OSError : <EOL> pass <EOL> shutil . copyfile ( '<STR_LIT>' , <EOL> os . path . join ( script_dir , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> version_re = re . compile ( \"<STR_LIT>\" ) <EOL> for line in open ( os . path . join ( root_dir , '<STR_LIT>' ) ) : <EOL> match = version_re . match ( line ) <EOL> if match : <EOL> version = match . groups ( ) [ <NUM_LIT:0> ] <EOL> parts = list ( pkg_resources . parse_version ( version ) ) <EOL> major = int ( parts . pop ( <NUM_LIT:0> ) ) <EOL> minor = patch = tagnum = <NUM_LIT:0> <EOL> if parts [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] != '<STR_LIT:*>' : <EOL> minor = int ( parts . pop ( <NUM_LIT:0> ) ) <EOL> if parts [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] != '<STR_LIT:*>' : <EOL> patch = int ( parts . pop ( <NUM_LIT:0> ) ) <EOL> tag = parts . pop ( <NUM_LIT:0> ) <EOL> if tag == '<STR_LIT>' : <EOL> base = <NUM_LIT:0> <EOL> elif tag == '<STR_LIT>' : <EOL> base = <NUM_LIT:16> <EOL> elif tag == '<STR_LIT>' : <EOL> base = <NUM_LIT:32> <EOL> elif tag == '<STR_LIT>' : <EOL> base = <NUM_LIT> <EOL> else : <EOL> assert False , '<STR_LIT>' % tag <EOL> if parts and parts [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] != '<STR_LIT:*>' : <EOL> tagnum = int ( parts . pop ( <NUM_LIT:0> ) ) <EOL> assert not parts or parts [ <NUM_LIT:0> ] == '<STR_LIT>' <EOL> version_windows = '<STR_LIT>' % ( major , minor , patch , base + tagnum ) <EOL> print '<STR_LIT>' % ( version , version_windows ) <EOL> print '<STR_LIT>' <EOL> wxs = parse ( os . path . join ( script_dir , '<STR_LIT>' ) ) <EOL> Product = wxs . getElementsByTagName ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> Product . setAttribute ( '<STR_LIT>' , version_windows ) <EOL> for pyver in PYTHON_VERSIONS : <EOL> Property = node ( wxs , '<STR_LIT>' , <EOL> Id = pyver . dir_prop ) <EOL> Property . appendChild ( <EOL> node ( wxs , '<STR_LIT>' , <EOL> Id = '<STR_LIT>' % pyver . dir_prop , <EOL> Root = pyver . key_root , <EOL> Key = pyver . key , <EOL> Type = '<STR_LIT>' ) ) <EOL> Product . appendChild ( Property ) <EOL> Condition = node ( wxs , '<STR_LIT>' , <EOL> Message = MISSING_PYTHON_MESSAGE ) <EOL> Condition . appendChild ( wxs . createTextNode ( <EOL> '<STR_LIT>' . join ( [ pyver . dir_prop for pyver in PYTHON_VERSIONS ] ) ) ) <EOL> Product . appendChild ( Condition ) <EOL> for elem in wxs . getElementsByTagName ( '<STR_LIT>' ) : <EOL>", "answer": "if elem . getAttribute ( '<STR_LIT>' ) == '<STR_LIT>' :"}, {"prompt": "<s> from django . db import models <EOL>", "answer": "class DummyModel ( models . Model ) :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL>", "answer": "class Migration ( migrations . Migration ) :"}, {"prompt": "<s> import sys <EOL> from app . master . atomizer import Atomizer <EOL> SETUP_BUILD = '<STR_LIT>' <EOL> TEARDOWN_BUILD = '<STR_LIT>' <EOL> COMMANDS = '<STR_LIT>' <EOL> ATOMIZERS = '<STR_LIT>' <EOL> MAX_EXECUTORS = '<STR_LIT>' <EOL> MAX_EXECUTORS_PER_SLAVE = '<STR_LIT>' <EOL> class JobConfig ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> DEFAULT_MAX_EXECUTORS = sys . maxsize <EOL> def __init__ ( self , name , setup_build , teardown_build , command , atomizer , max_executors , max_executors_per_slave ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . name = name <EOL> self . setup_build = setup_build <EOL> self . teardown_build = teardown_build <EOL> self . command = command <EOL> self . atomizer = atomizer <EOL> self . max_executors = max_executors <EOL> self . max_executors_per_slave = max_executors_per_slave <EOL> @ classmethod <EOL> def construct_from_dict ( cls , name , config_dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cls . _validate ( name , config_dict ) <EOL> return cls . _unpack ( name , config_dict ) <EOL> @ classmethod <EOL> def _validate ( cls , name , config_dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> required_fields = { COMMANDS , ATOMIZERS } <EOL> allowed_fields_expected_types = { <EOL> SETUP_BUILD : [ ( list , str ) ] , <EOL> TEARDOWN_BUILD : [ ( list , str ) ] , <EOL> COMMANDS : [ ( list , str ) ] , <EOL> ATOMIZERS : [ ( list , dict ) ] , <EOL> MAX_EXECUTORS : [ int ] , <EOL> MAX_EXECUTORS_PER_SLAVE : [ int ] , <EOL> } <EOL> if not isinstance ( config_dict , dict ) : <EOL> raise ConfigValidationError ( '<STR_LIT>' . format ( name ) ) <EOL> missing_required_fields = required_fields - config_dict . keys ( ) <EOL> if missing_required_fields : <EOL> raise ConfigValidationError ( '<STR_LIT>' <EOL> . format ( name , missing_required_fields ) ) <EOL> for config_section_name , config_section_value in config_dict . items ( ) : <EOL> if config_section_name not in allowed_fields_expected_types : <EOL> raise ConfigValidationError ( '<STR_LIT>' <EOL> . format ( name , config_section_name ) ) <EOL> expected_section_types = allowed_fields_expected_types [ config_section_name ] <EOL> actual_section_type = type ( config_section_value ) <EOL> if actual_section_type is list : <EOL> actual_section_type = ( list , type ( config_section_value [ <NUM_LIT:0> ] ) ) <EOL> if actual_section_type not in expected_section_types : <EOL> raise ConfigValidationError ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> . format ( name , config_section_name , expected_section_types , actual_section_type ) ) <EOL> @ classmethod <EOL> def _unpack ( cls , name , config_dict ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> import json <EOL> from django . utils . translation import ugettext as _ <EOL> from jsonobject . exceptions import BadValueError <EOL> from corehq . apps . userreports . exceptions import BadSpecError <EOL> from corehq . apps . userreports . transforms . specs import CustomTransform , DateFormatTransform , NumberFormatTransform <EOL> class TransformFactory ( object ) : <EOL> spec_map = { <EOL> '<STR_LIT>' : CustomTransform , <EOL> '<STR_LIT>' : DateFormatTransform , <EOL> '<STR_LIT>' : NumberFormatTransform , <EOL> } <EOL> @ classmethod <EOL> def get_transform ( cls , spec ) : <EOL> try : <EOL> return cls . spec_map [ spec [ '<STR_LIT:type>' ] ] . wrap ( spec ) <EOL> except KeyError : <EOL> raise BadSpecError ( _ ( '<STR_LIT>' ) . format ( <EOL> spec . get ( '<STR_LIT:type>' , None ) , <EOL> '<STR_LIT:U+002CU+0020>' . join ( cls . spec_map . keys ( ) ) , <EOL> ) ) <EOL> except BadValueError as e : <EOL>", "answer": "raise BadSpecError ( _ ( '<STR_LIT>' ) . format ("}, {"prompt": "<s> import datetime <EOL> import os <EOL> import re <EOL> import shutil <EOL> from . import util <EOL> _sourceless_rev_file = re . compile ( r'<STR_LIT>' ) <EOL> _only_source_rev_file = re . compile ( r'<STR_LIT>' ) <EOL> _legacy_rev = re . compile ( r'<STR_LIT>' ) <EOL> _mod_def_re = re . compile ( r'<STR_LIT>' ) <EOL> _slug_re = re . compile ( r'<STR_LIT>' ) <EOL> _default_file_template = \"<STR_LIT>\" <EOL> _relative_destination = re . compile ( r'<STR_LIT>' ) <EOL> class ScriptDirectory ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , dir , file_template = _default_file_template , <EOL> truncate_slug_length = <NUM_LIT> , <EOL> sourceless = False ) : <EOL> self . dir = dir <EOL> self . versions = os . path . join ( self . dir , '<STR_LIT>' ) <EOL> self . file_template = file_template <EOL> self . truncate_slug_length = truncate_slug_length or <NUM_LIT> <EOL> self . sourceless = sourceless <EOL> if not os . access ( dir , os . F_OK ) : <EOL> raise util . CommandError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % dir ) <EOL> @ classmethod <EOL> def from_config ( cls , config ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> script_location = config . get_main_option ( '<STR_LIT>' ) <EOL> if script_location is None : <EOL> raise util . CommandError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> truncate_slug_length = config . get_main_option ( \"<STR_LIT>\" ) <EOL> if truncate_slug_length is not None : <EOL> truncate_slug_length = int ( truncate_slug_length ) <EOL> return ScriptDirectory ( <EOL> util . coerce_resource_to_filename ( script_location ) , <EOL> file_template = config . get_main_option ( <EOL> '<STR_LIT>' , <EOL> _default_file_template ) , <EOL> truncate_slug_length = truncate_slug_length , <EOL> sourceless = config . get_main_option ( \"<STR_LIT>\" ) == \"<STR_LIT:true>\" <EOL> ) <EOL> def walk_revisions ( self , base = \"<STR_LIT>\" , head = \"<STR_LIT>\" ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if head == \"<STR_LIT>\" : <EOL> heads = set ( self . get_heads ( ) ) <EOL> else : <EOL> heads = set ( [ head ] ) <EOL> while heads : <EOL> todo = set ( heads ) <EOL> heads = set ( ) <EOL> for head in todo : <EOL> if head in heads : <EOL> break <EOL> for sc in self . iterate_revisions ( head , base ) : <EOL> if sc . is_branch_point and sc . revision not in todo : <EOL> heads . add ( sc . revision ) <EOL> break <EOL> else : <EOL> yield sc <EOL> def get_revision ( self , id_ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> id_ = self . as_revision_number ( id_ ) <EOL> try : <EOL> return self . _revision_map [ id_ ] <EOL> except KeyError : <EOL> revs = [ x for x in self . _revision_map <EOL> if x is not None and x . startswith ( id_ ) ] <EOL> if not revs : <EOL> raise util . CommandError ( \"<STR_LIT>\" % id_ ) <EOL> elif len ( revs ) > <NUM_LIT:1> : <EOL> raise util . CommandError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % ( <EOL> id_ , <EOL> \"<STR_LIT:U+002CU+0020>\" . join ( \"<STR_LIT>\" % r for r in revs [ <NUM_LIT:0> : <NUM_LIT:3> ] ) <EOL> ) ) <EOL> else : <EOL> return self . _revision_map [ revs [ <NUM_LIT:0> ] ] <EOL> _get_rev = get_revision <EOL> def as_revision_number ( self , id_ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if id_ == '<STR_LIT>' : <EOL> id_ = self . get_current_head ( ) <EOL> elif id_ == '<STR_LIT>' : <EOL> id_ = None <EOL> return id_ <EOL> _as_rev_number = as_revision_number <EOL> def iterate_revisions ( self , upper , lower ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if upper is not None and _relative_destination . match ( upper ) : <EOL> relative = int ( upper ) <EOL> revs = list ( self . _iterate_revisions ( \"<STR_LIT>\" , lower ) ) <EOL> revs = revs [ - relative : ] <EOL> if len ( revs ) != abs ( relative ) : <EOL> raise util . CommandError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % ( upper , abs ( relative ) ) ) <EOL> return iter ( revs ) <EOL> elif lower is not None and _relative_destination . match ( lower ) : <EOL> relative = int ( lower ) <EOL> revs = list ( self . _iterate_revisions ( upper , \"<STR_LIT>\" ) ) <EOL> revs = revs [ <NUM_LIT:0> : - relative ] <EOL> if len ( revs ) != abs ( relative ) : <EOL> raise util . CommandError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % ( lower , abs ( relative ) ) ) <EOL> return iter ( revs ) <EOL> else : <EOL> return self . _iterate_revisions ( upper , lower ) <EOL> def _iterate_revisions ( self , upper , lower ) : <EOL> lower = self . get_revision ( lower ) <EOL> upper = self . get_revision ( upper ) <EOL> orig = lower . revision if lower else '<STR_LIT>' , upper . revision if upper else '<STR_LIT>' <EOL> script = upper <EOL> while script != lower : <EOL> if script is None and lower is not None : <EOL> raise util . CommandError ( <EOL> \"<STR_LIT>\" % orig ) <EOL> yield script <EOL> downrev = script . down_revision <EOL> script = self . _revision_map [ downrev ] <EOL> def _upgrade_revs ( self , destination , current_rev ) : <EOL> revs = self . iterate_revisions ( destination , current_rev ) <EOL> return [ <EOL> ( script . module . upgrade , script . down_revision , script . revision , <EOL> script . doc ) <EOL> for script in reversed ( list ( revs ) ) <EOL> ] <EOL> def _downgrade_revs ( self , destination , current_rev ) : <EOL> revs = self . iterate_revisions ( current_rev , destination ) <EOL> return [ <EOL> ( script . module . downgrade , script . revision , script . down_revision , <EOL> script . doc ) <EOL> for script in revs <EOL> ] <EOL> def run_env ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> util . load_python_file ( self . dir , '<STR_LIT>' ) <EOL> @ property <EOL> def env_py_location ( self ) : <EOL> return os . path . abspath ( os . path . join ( self . dir , \"<STR_LIT>\" ) ) <EOL> @ util . memoized_property <EOL> def _revision_map ( self ) : <EOL> map_ = { } <EOL> for file_ in os . listdir ( self . versions ) : <EOL> script = Script . _from_filename ( self , self . versions , file_ ) <EOL> if script is None : <EOL> continue <EOL> if script . revision in map_ : <EOL> util . warn ( \"<STR_LIT>\" % <EOL> script . revision ) <EOL> map_ [ script . revision ] = script <EOL> for rev in map_ . values ( ) : <EOL> if rev . down_revision is None : <EOL> continue <EOL> if rev . down_revision not in map_ : <EOL> util . warn ( \"<STR_LIT>\" <EOL> % ( rev . down_revision , rev ) ) <EOL> rev . down_revision = None <EOL> else : <EOL> map_ [ rev . down_revision ] . add_nextrev ( rev . revision ) <EOL> map_ [ None ] = None <EOL> return map_ <EOL> def _rev_path ( self , rev_id , message , create_date ) : <EOL> slug = \"<STR_LIT:_>\" . join ( _slug_re . findall ( message or \"<STR_LIT>\" ) ) . lower ( ) <EOL> if len ( slug ) > self . truncate_slug_length : <EOL> slug = slug [ : self . truncate_slug_length ] . rsplit ( '<STR_LIT:_>' , <NUM_LIT:1> ) [ <NUM_LIT:0> ] + '<STR_LIT:_>' <EOL> filename = \"<STR_LIT>\" % ( <EOL> self . file_template % { <EOL> '<STR_LIT>' : rev_id , <EOL> '<STR_LIT>' : slug , <EOL> '<STR_LIT>' : create_date . year , <EOL> '<STR_LIT>' : create_date . month , <EOL> '<STR_LIT>' : create_date . day , <EOL> '<STR_LIT>' : create_date . hour , <EOL> '<STR_LIT>' : create_date . minute , <EOL> '<STR_LIT>' : create_date . second <EOL> } <EOL> ) <EOL> return os . path . join ( self . versions , filename ) <EOL> def get_current_head ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> current_heads = self . get_heads ( ) <EOL> if len ( current_heads ) > <NUM_LIT:1> : <EOL> raise util . CommandError ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> if current_heads : <EOL> return current_heads [ <NUM_LIT:0> ] <EOL> else : <EOL> return None <EOL> _current_head = get_current_head <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def get_heads ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> heads = [ ] <EOL> for script in self . _revision_map . values ( ) : <EOL> if script and script . is_head : <EOL> heads . append ( script . revision ) <EOL> return heads <EOL> def get_base ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for script in self . _revision_map . values ( ) : <EOL> if script and script . down_revision is None and script . revision in self . _revision_map : <EOL> return script . revision <EOL> else : <EOL> return None <EOL> def _generate_template ( self , src , dest , ** kw ) : <EOL> util . status ( \"<STR_LIT>\" % os . path . abspath ( dest ) , <EOL> util . template_to_file , <EOL> src , <EOL> dest , <EOL> ** kw <EOL> ) <EOL> def _copy_file ( self , src , dest ) : <EOL> util . status ( \"<STR_LIT>\" % os . path . abspath ( dest ) , <EOL> shutil . copy , <EOL> src , dest ) <EOL> def generate_revision ( self , revid , message , refresh = False , ** kw ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> current_head = self . get_current_head ( ) <EOL> create_date = datetime . datetime . now ( ) <EOL> path = self . _rev_path ( revid , message , create_date ) <EOL> self . _generate_template ( <EOL> os . path . join ( self . dir , \"<STR_LIT>\" ) , <EOL> path , <EOL> up_revision = str ( revid ) , <EOL> down_revision = current_head , <EOL> create_date = create_date , <EOL> message = message if message is not None else ( \"<STR_LIT>\" ) , <EOL> ** kw <EOL> ) <EOL> if refresh : <EOL> script = Script . _from_path ( self , path ) <EOL> self . _revision_map [ script . revision ] = script <EOL> if script . down_revision : <EOL> self . _revision_map [ script . down_revision ] . add_nextrev ( script . revision ) <EOL> return script <EOL> else : <EOL> return None <EOL> class Script ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> nextrev = frozenset ( ) <EOL> def __init__ ( self , module , rev_id , path ) : <EOL> self . module = module <EOL> self . revision = rev_id <EOL> self . path = path <EOL> self . down_revision = getattr ( module , '<STR_LIT>' , None ) <EOL> revision = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> module = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> down_revision = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ property <EOL> def doc ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return re . split ( \"<STR_LIT>\" , self . longdoc ) [ <NUM_LIT:0> ] <EOL> @ property <EOL> def longdoc ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> doc = self . module . __doc__ <EOL> if doc : <EOL> if hasattr ( self . module , \"<STR_LIT>\" ) : <EOL> doc = doc . decode ( self . module . _alembic_source_encoding ) <EOL> return doc . strip ( ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> def add_nextrev ( self , rev ) : <EOL> self . nextrev = self . nextrev . union ( [ rev ] ) <EOL> @ property <EOL> def is_head ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return not bool ( self . nextrev ) <EOL> @ property <EOL> def is_branch_point ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return len ( self . nextrev ) > <NUM_LIT:1> <EOL> @ property <EOL> def log_entry ( self ) : <EOL> return \"<STR_LIT>\" \"<STR_LIT>\" \"<STR_LIT>\" \"<STR_LIT>\" % ( <EOL> self . revision , <EOL> \"<STR_LIT>\" if self . is_head else \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" if self . is_branch_point else \"<STR_LIT>\" , <EOL> self . down_revision , <EOL> self . path , <EOL> \"<STR_LIT:\\n>\" . join ( <EOL> \"<STR_LIT>\" % para <EOL> for para in self . longdoc . splitlines ( ) <EOL> ) <EOL> ) <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( <EOL> self . down_revision , <EOL> self . revision , <EOL> \"<STR_LIT>\" if self . is_head else \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" if self . is_branch_point else \"<STR_LIT>\" , <EOL> self . doc ) <EOL> @ classmethod <EOL> def _from_path ( cls , scriptdir , path ) : <EOL> dir_ , filename = os . path . split ( path ) <EOL> return cls . _from_filename ( scriptdir , dir_ , filename ) <EOL> @ classmethod <EOL> def _from_filename ( cls , scriptdir , dir_ , filename ) : <EOL> if scriptdir . sourceless : <EOL> py_match = _sourceless_rev_file . match ( filename ) <EOL> else : <EOL> py_match = _only_source_rev_file . match ( filename ) <EOL>", "answer": "if not py_match :"}, {"prompt": "<s> from xml . etree import ElementTree <EOL> from datetime import datetime <EOL> import pytz <EOL> from corehq . apps . callcenter . indicator_sets import CallCenterIndicators <EOL> from corehq . apps . users . models import CommCareUser <EOL> from corehq . util . soft_assert import soft_assert <EOL> from corehq . util . timezones . conversions import UserTime , ServerTime <EOL> from dimagi . utils . logging import notify_exception <EOL> utc = pytz . utc <EOL> def should_sync ( domain , last_sync , utcnow = None ) : <EOL> if not last_sync or not last_sync . date : <EOL> return True <EOL>", "answer": "utcnow = utcnow or datetime . utcnow ( )"}, {"prompt": "<s> from numpy . testing import assert_ <EOL> from statsmodels . base . optimizer import ( _fit_newton , _fit_nm , <EOL> _fit_bfgs , _fit_cg , <EOL> _fit_ncg , _fit_powell , <EOL> _fit_lbfgs , _fit_basinhopping ) <EOL> fit_funcs = { <EOL> '<STR_LIT>' : _fit_newton , <EOL> '<STR_LIT>' : _fit_nm , <EOL> '<STR_LIT>' : _fit_bfgs , <EOL> '<STR_LIT>' : _fit_cg , <EOL> '<STR_LIT>' : _fit_ncg , <EOL> '<STR_LIT>' : _fit_powell , <EOL> '<STR_LIT>' : _fit_lbfgs , <EOL> } <EOL> try : <EOL> from scipy . optimize import basinhopping <EOL> fit_funcs . update ( { '<STR_LIT>' : _fit_basinhopping } ) <EOL> except ImportError : <EOL> pass <EOL> def dummy_func ( x ) : <EOL> return x ** <NUM_LIT:2> <EOL> def dummy_score ( x ) : <EOL> return <NUM_LIT> * x <EOL> def dummy_hess ( x ) : <EOL> return [ [ <NUM_LIT> ] ] <EOL> def test_full_output_false ( ) : <EOL> for method in fit_funcs : <EOL> func = fit_funcs [ method ] <EOL> if method == \"<STR_LIT>\" : <EOL> xopt , retvals = func ( dummy_func , dummy_score , [ <NUM_LIT:1> ] , ( ) , { } , <EOL> hess = dummy_hess , full_output = False , disp = <NUM_LIT:0> ) <EOL> else : <EOL> xopt , retvals = func ( dummy_func , dummy_score , [ <NUM_LIT:1> ] , ( ) , { } , <EOL> full_output = False , disp = <NUM_LIT:0> ) <EOL> assert_ ( retvals is None ) <EOL> if method == \"<STR_LIT>\" : <EOL> assert_ ( xopt . shape == ( ) and xopt . size == <NUM_LIT:1> ) <EOL> else : <EOL> assert_ ( len ( xopt ) == <NUM_LIT:1> ) <EOL> def test_full_output ( ) : <EOL> for method in fit_funcs : <EOL> func = fit_funcs [ method ] <EOL> if method == \"<STR_LIT>\" : <EOL> xopt , retvals = func ( dummy_func , dummy_score , [ <NUM_LIT:1> ] , ( ) , { } , <EOL> hess = dummy_hess , full_output = True , disp = <NUM_LIT:0> ) <EOL> else : <EOL> xopt , retvals = func ( dummy_func , dummy_score , [ <NUM_LIT:1> ] , ( ) , { } , <EOL>", "answer": "full_output = True , disp = <NUM_LIT:0> )"}, {"prompt": "<s> import scipy as sp <EOL> import OpenPNM <EOL> import pytest <EOL> def test_find_connected_pores ( ) : <EOL> pn = OpenPNM . Network . Cubic ( shape = ( <NUM_LIT:10> , <NUM_LIT:10> , <NUM_LIT:10> ) ) <EOL> a = pn . find_connected_pores ( throats = [ <NUM_LIT:0> , <NUM_LIT:1> ] ) <EOL> assert sp . all ( a . flatten ( ) == [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:2> ] ) <EOL> a = pn . find_connected_pores ( throats = [ <NUM_LIT:0> , <NUM_LIT:1> ] , flatten = True ) <EOL> assert sp . all ( a == [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> ] ) <EOL> Tind = sp . zeros ( ( pn . Nt , ) , dtype = bool ) <EOL> Tind [ [ <NUM_LIT:0> , <NUM_LIT:1> ] ] = True <EOL> a = pn . find_connected_pores ( throats = Tind , flatten = True ) <EOL> assert sp . all ( a == [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> ] ) <EOL> a = pn . find_connected_pores ( throats = [ ] , flatten = True ) <EOL> assert sp . shape ( a ) == ( <NUM_LIT:0> , ) <EOL> def test_find_neighbor_pores ( ) : <EOL> pn = OpenPNM . Network . Cubic ( shape = ( <NUM_LIT:10> , <NUM_LIT:10> , <NUM_LIT:10> ) ) <EOL> a = pn . find_neighbor_pores ( pores = [ ] ) <EOL> assert sp . size ( a ) == <NUM_LIT:0> <EOL> Pind = sp . zeros ( ( pn . Np , ) , dtype = bool ) <EOL> Pind [ [ <NUM_LIT:0> , <NUM_LIT:1> ] ] = True <EOL> a = pn . find_neighbor_pores ( pores = Pind ) <EOL> assert sp . all ( a == [ <NUM_LIT:2> , <NUM_LIT:10> , <NUM_LIT:11> , <NUM_LIT:100> , <NUM_LIT> ] ) <EOL> a = pn . find_neighbor_pores ( pores = [ <NUM_LIT:0> , <NUM_LIT:2> ] , mode = '<STR_LIT>' ) <EOL> assert sp . all ( a == [ <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:10> , <NUM_LIT:12> , <NUM_LIT:100> , <NUM_LIT> ] ) <EOL> a = pn . find_neighbor_pores ( pores = [ <NUM_LIT:0> , <NUM_LIT:2> ] , mode = '<STR_LIT>' ) <EOL> assert sp . all ( a == [ <NUM_LIT:1> ] ) <EOL> a = pn . find_neighbor_pores ( pores = [ <NUM_LIT:0> , <NUM_LIT:2> ] , mode = '<STR_LIT>' ) <EOL> assert sp . all ( a == [ <NUM_LIT:3> , <NUM_LIT:10> , <NUM_LIT:12> , <NUM_LIT:100> , <NUM_LIT> ] ) <EOL> a = pn . find_neighbor_pores ( pores = [ <NUM_LIT:0> , <NUM_LIT:2> ] , <EOL> mode = '<STR_LIT>' , <EOL> excl_self = False ) <EOL> assert sp . all ( a == [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:10> , <NUM_LIT:12> , <NUM_LIT:100> , <NUM_LIT> ] ) <EOL> a = pn . find_neighbor_pores ( pores = [ <NUM_LIT:0> , <NUM_LIT:2> ] , <EOL> mode = '<STR_LIT>' , <EOL> excl_self = False ) <EOL> assert sp . all ( a == [ <NUM_LIT:1> ] ) <EOL> a = pn . find_neighbor_pores ( pores = [ <NUM_LIT:0> , <NUM_LIT:2> ] , <EOL> mode = '<STR_LIT>' , <EOL> excl_self = False ) <EOL> assert sp . all ( a == [ <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:10> , <NUM_LIT:12> , <NUM_LIT:100> , <NUM_LIT> ] ) <EOL> def test_find_neighbor_throats ( ) : <EOL> pn = OpenPNM . Network . Cubic ( shape = ( <NUM_LIT:10> , <NUM_LIT:10> , <NUM_LIT:10> ) ) <EOL> a = pn . find_neighbor_throats ( pores = [ ] ) <EOL> assert sp . size ( a ) == <NUM_LIT:0> <EOL> Pind = sp . zeros ( ( pn . Np , ) , dtype = bool ) <EOL> Pind [ [ <NUM_LIT:0> , <NUM_LIT:1> ] ] = True <EOL> a = pn . find_neighbor_throats ( pores = Pind ) <EOL> assert sp . all ( a == [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] ) <EOL> a = pn . find_neighbor_throats ( pores = [ <NUM_LIT:0> , <NUM_LIT:2> ] , mode = '<STR_LIT>' ) <EOL> assert sp . all ( a == [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] ) <EOL> a = pn . find_neighbor_throats ( pores = [ <NUM_LIT:0> , <NUM_LIT:2> ] , mode = '<STR_LIT>' ) <EOL> assert sp . size ( a ) == <NUM_LIT:0> <EOL> a = pn . find_neighbor_throats ( pores = [ <NUM_LIT:0> , <NUM_LIT:2> ] , mode = '<STR_LIT>' ) <EOL> assert sp . all ( a == [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] ) <EOL> def test_num_neighbors ( ) : <EOL> pn = OpenPNM . Network . Cubic ( shape = ( <NUM_LIT:10> , <NUM_LIT:10> , <NUM_LIT:10> ) ) <EOL> a = pn . num_neighbors ( pores = [ ] ) <EOL> assert sp . size ( a ) == <NUM_LIT:0> <EOL> Pind = sp . zeros ( ( pn . Np , ) , dtype = bool ) <EOL> Pind [ <NUM_LIT:0> ] = True <EOL> a = pn . num_neighbors ( pores = Pind ) <EOL> assert a == <NUM_LIT:3> <EOL> a = pn . num_neighbors ( pores = [ <NUM_LIT:0> , <NUM_LIT:2> ] , flatten = True ) <EOL>", "answer": "assert a == <NUM_LIT:6>"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db . models import Manager <EOL> class HostingServiceAccountManager ( Manager ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def accessible ( self , visible_only = True , local_site = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> qs = self . all ( ) <EOL>", "answer": "if visible_only :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = <NUM_LIT:9> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> import abc <EOL> import six <EOL> @ six . add_metaclass ( abc . ABCMeta ) <EOL> class MplsVpnDriver ( object ) : <EOL> def __init__ ( self , service_plugin ) : <EOL> self . service_plugin = service_plugin <EOL> @ property <EOL> def service_type ( self ) : <EOL> pass <EOL> @ abc . abstractmethod <EOL> def create_mplsvpn ( self , context , mplsvpn ) : <EOL> pass <EOL> @ abc . abstractmethod <EOL> def delete_mplsvpn ( self , context , mplsvpn ) : <EOL>", "answer": "pass "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> def Predicate ( predicate ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return lambda modelObjects : [ x for x in modelObjects if predicate ( x ) ] <EOL> def Head ( num ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return lambda modelObjects : modelObjects [ : num ] <EOL> def Tail ( num ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return lambda modelObjects : modelObjects [ - num : ] <EOL> class TextSearch ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , objectListView , columns = ( ) , text = \"<STR_LIT>\" ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from servable import Servable <EOL> from graphserver . graphdb import GraphDatabase <EOL> import cgi <EOL> from graphserver . core import State , WalkOptions <EOL> import time <EOL> import sys <EOL> import graphserver <EOL> from graphserver . util import TimeHelpers <EOL> from graphserver . ext . gtfs . gtfsdb import GTFSDatabase <EOL> try : <EOL> import json <EOL> except ImportError : <EOL> import simplejson as json <EOL> import yaml <EOL> import os <EOL> from fcgi import WSGIServer <EOL> from events import BoardEvent , AlightEvent , HeadwayBoardEvent , HeadwayAlightEvent , StreetEvent , StreetTurnEvent <EOL> class SelfEncoderHelper ( json . JSONEncoder ) : <EOL> def default ( self , obj ) : <EOL> if hasattr ( obj , \"<STR_LIT>\" ) : <EOL> return obj . to_jsonable ( ) <EOL> return json . JSONEncoder . default ( self , obj ) <EOL> def postprocess_path_raw ( vertices , edges ) : <EOL> retbuilder = [ ] <EOL> retbuilder . append ( \"<STR_LIT>\" ) <EOL> for i , vertex in enumerate ( vertices ) : <EOL> retbuilder . append ( \"<STR_LIT>\" % ( i , str ( vertex ) ) ) <EOL> retbuilder . append ( \"<STR_LIT>\" ) <EOL> retbuilder . append ( \"<STR_LIT>\" ) <EOL> for i , vertex in enumerate ( vertices ) : <EOL> retbuilder . append ( \"<STR_LIT>\" % ( i , str ( vertex . state ) ) ) <EOL> retbuilder . append ( \"<STR_LIT>\" ) <EOL> retbuilder . append ( \"<STR_LIT>\" ) <EOL> for i , edge in enumerate ( edges ) : <EOL> retbuilder . append ( \"<STR_LIT>\" % ( i , str ( edge . payload ) ) ) <EOL> return \"<STR_LIT:\\n>\" . join ( retbuilder ) <EOL> def postprocess_path ( vertices , edges , vertex_events , edge_events ) : <EOL> context = { } <EOL> for edge1 , vertex1 , edge2 , vertex2 in zip ( [ None ] + edges , vertices , edges + [ None ] , vertices [ <NUM_LIT:1> : ] + [ None , None ] ) : <EOL> for handler in vertex_events : <EOL> if handler . applies_to ( edge1 , vertex1 , edge2 ) : <EOL> event = handler ( edge1 , vertex1 , edge2 , context = context ) <EOL> if event is not None : <EOL> yield handler . __class__ . __name__ , event <EOL> for handler in edge_events : <EOL> if handler . applies_to ( vertex1 , edge2 , vertex2 ) : <EOL> event = handler ( vertex1 , edge2 , vertex2 , context = context ) <EOL> if event is not None : <EOL> yield handler . __class__ . __name__ , event <EOL> class RouteServer ( Servable ) : <EOL> def __init__ ( self , graphdb_filename , vertex_events , edge_events , vertex_reverse_geocoders ) : <EOL> graphdb = GraphDatabase ( graphdb_filename ) <EOL> self . graph = graphdb . incarnate ( ) <EOL> self . vertex_events = vertex_events <EOL> self . edge_events = edge_events <EOL> self . vertex_reverse_geocoders = vertex_reverse_geocoders <EOL> def bounds ( self , jsoncallback = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> l , b , r , t = None , None , None , None <EOL> for reverse_geocoder in self . vertex_reverse_geocoders : <EOL> gl , gb , gr , gt = reverse_geocoder . bounds ( ) <EOL> l = min ( l , gl ) if l else gl <EOL> b = min ( b , gb ) if b else gb <EOL> r = max ( r , gr ) if r else gr <EOL> t = max ( t , gt ) if t else gt <EOL> if jsoncallback is None : <EOL> return json . dumps ( [ l , b , r , t ] ) <EOL> else : <EOL> return \"<STR_LIT>\" % ( jsoncallback , json . dumps ( [ l , b , r , t ] ) ) <EOL> def vertices ( self ) : <EOL> return \"<STR_LIT:\\n>\" . join ( [ vv . label for vv in self . graph . vertices ] ) <EOL> vertices . mime = \"<STR_LIT>\" <EOL> def get_vertex_id_raw ( self , lat , lon ) : <EOL> for reverse_geocoder in self . vertex_reverse_geocoders : <EOL> ret = reverse_geocoder ( lat , lon ) <EOL> if ret is not None : <EOL> return ret <EOL> return None <EOL> def get_vertex_id ( self , lat , lon ) : <EOL> return json . dumps ( self . get_vertex_id_raw ( lat , lon ) ) <EOL> def path ( self , <EOL> origin , <EOL> dest , <EOL> currtime = None , <EOL> time_offset = None , <EOL> transfer_penalty = <NUM_LIT:0> , <EOL> walking_speed = <NUM_LIT:1.0> , <EOL> hill_reluctance = <NUM_LIT> , <EOL> turn_penalty = None , <EOL> walking_reluctance = None , <EOL> max_walk = None , <EOL> jsoncallback = None ) : <EOL> performance = { } <EOL> if currtime is None : <EOL> currtime = int ( time . time ( ) ) <EOL> if time_offset is not None : <EOL> currtime += time_offset <EOL> t0 = time . time ( ) <EOL> wo = WalkOptions ( ) <EOL> wo . transfer_penalty = transfer_penalty <EOL> wo . walking_speed = walking_speed <EOL> wo . hill_reluctance = hill_reluctance <EOL> if turn_penalty is not None : <EOL> wo . turn_penalty = turn_penalty <EOL> if walking_reluctance is not None : <EOL> wo . walking_reluctance = walking_reluctance <EOL> if max_walk is not None : <EOL> wo . max_walk = max_walk <EOL> spt = self . graph . shortest_path_tree ( origin , dest , State ( <NUM_LIT:1> , currtime ) , wo ) <EOL> try : <EOL> vertices , edges = spt . path ( dest ) <EOL> except Exception , e : <EOL> return json . dumps ( { '<STR_LIT:error>' : str ( e ) } ) <EOL> performance [ '<STR_LIT>' ] = time . time ( ) - t0 <EOL> t0 = time . time ( ) <EOL> narrative = list ( postprocess_path ( vertices , edges , self . vertex_events , self . edge_events ) ) <EOL> performance [ '<STR_LIT>' ] = time . time ( ) - t0 <EOL> t0 = time . time ( ) <EOL> wo . destroy ( ) <EOL> spt . destroy ( ) <EOL> performance [ '<STR_LIT>' ] = time . time ( ) - t0 <EOL> ret = { '<STR_LIT>' : narrative , '<STR_LIT>' : performance } <EOL> if jsoncallback is None : <EOL>", "answer": "return json . dumps ( ret , indent = <NUM_LIT:2> , cls = SelfEncoderHelper )"}, {"prompt": "<s> from mock import call , Mock , patch <EOL> from unittest import TestCase <EOL> from carbon import instrumentation <EOL> from carbon . rewrite import PRE , POST , RewriteRule , RewriteRuleManager <EOL> from carbon . pipeline import Processor <EOL> from carbon . aggregator . buffers import BufferManager <EOL> from carbon . aggregator . rules import AggregationRule , RuleManager <EOL> from carbon . aggregator . processor import AggregationProcessor <EOL> class AggregationProcessorTest ( TestCase ) : <EOL> def setUp ( self ) : <EOL> self . sample_rewrite_rule = RewriteRule ( r'<STR_LIT>' , r'<STR_LIT>' ) <EOL> self . sample_aggregation_rule = AggregationRule ( r'<STR_LIT>' , r'<STR_LIT>' , '<STR_LIT>' , <NUM_LIT:1> ) <EOL> self . sample_overwriting_aggregation_rule = AggregationRule ( r'<STR_LIT>' , r'<STR_LIT>' , '<STR_LIT>' , <NUM_LIT:1> ) <EOL> self . processor = AggregationProcessor ( ) <EOL> def tearDown ( self ) : <EOL> instrumentation . stats . clear ( ) <EOL> BufferManager . clear ( ) <EOL> RuleManager . clear ( ) <EOL> RewriteRuleManager . clear ( ) <EOL> def test_registers_plugin ( self ) : <EOL> self . assertTrue ( '<STR_LIT>' in Processor . plugins ) <EOL> def test_process_increments_datapoints_metric ( self ) : <EOL> list ( self . processor . process ( '<STR_LIT>' , ( <NUM_LIT:0> , <NUM_LIT:0> ) ) ) <EOL> self . assertEqual ( <NUM_LIT:1> , instrumentation . stats [ '<STR_LIT>' ] ) <EOL>", "answer": "def test_pre_rules_applied ( self ) :"}, {"prompt": "<s> from lib . actions import BaseAction <EOL> class UpdateAction ( BaseAction ) : <EOL> def run ( self , table , payload , sysid ) : <EOL> self . client . table = table <EOL>", "answer": "response = self . client . update ( payload , sysid )"}, {"prompt": "<s> import random <EOL> from openstack_dashboard . test . integration_tests import helpers <EOL> from openstack_dashboard . test . integration_tests . regions import messages <EOL> class TestSecuritygroup ( helpers . TestCase ) : <EOL> SEC_GROUP_NAME = helpers . gen_random_resource_name ( \"<STR_LIT>\" ) <EOL> RULE_PORT = str ( random . randint ( <NUM_LIT> , <NUM_LIT> ) ) <EOL> @ property <EOL> def securitygroup_page ( self ) : <EOL> return self . home_pg . go_to_compute_accessandsecurity_securitygroupspage ( ) <EOL> def _create_securitygroup ( self ) : <EOL> page = self . securitygroup_page <EOL> page . create_securitygroup ( self . SEC_GROUP_NAME ) <EOL> self . assertTrue ( page . find_message_and_dismiss ( messages . SUCCESS ) ) <EOL> self . assertFalse ( page . find_message_and_dismiss ( messages . ERROR ) ) <EOL> self . assertTrue ( page . is_securitygroup_present ( self . SEC_GROUP_NAME ) ) <EOL> def _delete_securitygroup ( self ) : <EOL> page = self . securitygroup_page <EOL> page . delete_securitygroup ( self . SEC_GROUP_NAME ) <EOL> self . assertTrue ( page . find_message_and_dismiss ( messages . SUCCESS ) ) <EOL> self . assertFalse ( page . find_message_and_dismiss ( messages . ERROR ) ) <EOL> self . assertFalse ( page . is_securitygroup_present ( self . SEC_GROUP_NAME ) ) <EOL> def _add_rule ( self ) : <EOL> page = self . securitygroup_page <EOL> page = page . go_to_manage_rules ( self . SEC_GROUP_NAME ) <EOL> page . create_rule ( self . RULE_PORT ) <EOL> self . assertTrue ( page . find_message_and_dismiss ( messages . SUCCESS ) ) <EOL>", "answer": "self . assertTrue ( page . is_port_present ( self . RULE_PORT ) )"}, {"prompt": "<s> from sys import stderr <EOL> import logging <EOL> import numpy <EOL> import cPickle <EOL> import base64 <EOL> import zlib <EOL> import wx <EOL> import collections <EOL> import pandas as pd <EOL> from dbconnect import * <EOL> from singleton import Singleton <EOL>", "answer": "db = DBConnect . getInstance ( )"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> import os <EOL>", "answer": "import sys"}, {"prompt": "<s> import calendar <EOL> import math <EOL> import time <EOL> import re <EOL> def timestamp_to_epoch ( timeStringISO8601 ) : <EOL> secondFractionPattern = re . compile ( '<STR_LIT>' ) <EOL> match = secondFractionPattern . search ( timeStringISO8601 ) <EOL> if match : <EOL> fraction = match . group ( <NUM_LIT:1> ) <EOL> else : <EOL> fraction = \"<STR_LIT>\" <EOL> timeStringISO8601 = timeStringISO8601 . replace ( fraction , '<STR_LIT>' ) <EOL> bootTimeTuple = time . strptime ( timeStringISO8601 , \"<STR_LIT>\" ) <EOL> bootTimeSecondsSinceEpoch = \"<STR_LIT:%s>\" % calendar . timegm ( bootTimeTuple ) <EOL> return ( bootTimeSecondsSinceEpoch + fraction ) <EOL> def convertTimeStamp ( absoluteBaselineTime , secondsAfterBaseline ) : <EOL> offsetTime = absoluteBaselineTime + secondsAfterBaseline <EOL> offsetTimeTuple = time . gmtime ( offsetTime ) <EOL> offsetTimeString = time . strftime ( \"<STR_LIT>\" , offsetTimeTuple ) <EOL> fractionSecondsString = '<STR_LIT>' % ( secondsAfterBaseline - math . floor ( secondsAfterBaseline ) ) <EOL> retval = offsetTimeString . replace ( '<STR_LIT:+>' , fractionSecondsString [ <NUM_LIT:1> : ] + '<STR_LIT:+>' ) <EOL> return retval <EOL> def envFileAsDictionary ( fname ) : <EOL> retval = { } <EOL> fp = open ( fname , '<STR_LIT:r>' ) <EOL> for line in fp : <EOL> line = line . rstrip ( '<STR_LIT:\\r\\n>' ) <EOL>", "answer": "try :"}, {"prompt": "<s> from django import template , templatetags <EOL> from django . template import RequestContext <EOL> from django . conf import settings <EOL> from django . contrib . admin . views . decorators import staff_member_required <EOL> from django . db import models <EOL> from django . shortcuts import render_to_response <EOL> from django . core . exceptions import ImproperlyConfigured , ViewDoesNotExist <EOL> from django . http import Http404 , get_host <EOL> from django . core import urlresolvers <EOL> from django . contrib . admin import utils <EOL> from django . contrib . sites . models import Site <EOL> import inspect , os , re <EOL> MODEL_METHODS_EXCLUDE = ( '<STR_LIT:_>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> class GenericSite ( object ) : <EOL> domain = '<STR_LIT>' <EOL> name = '<STR_LIT>' <EOL> def doc_index ( request ) : <EOL> if not utils . docutils_is_available : <EOL> return missing_docutils_page ( request ) <EOL> return render_to_response ( '<STR_LIT>' , context_instance = RequestContext ( request ) ) <EOL> doc_index = staff_member_required ( doc_index ) <EOL> def bookmarklets ( request ) : <EOL> admin_root = request . path [ : - len ( '<STR_LIT>' ) ] <EOL> return render_to_response ( '<STR_LIT>' , { <EOL> '<STR_LIT>' : \"<STR_LIT>\" % ( request . is_secure ( ) and '<STR_LIT>' or '<STR_LIT:http>' , get_host ( request ) , admin_root ) , <EOL> } , context_instance = RequestContext ( request ) ) <EOL> bookmarklets = staff_member_required ( bookmarklets ) <EOL> def template_tag_index ( request ) : <EOL> if not utils . docutils_is_available : <EOL> return missing_docutils_page ( request ) <EOL> load_all_installed_template_libraries ( ) <EOL> tags = [ ] <EOL> for module_name , library in template . libraries . items ( ) : <EOL> for tag_name , tag_func in library . tags . items ( ) : <EOL> title , body , metadata = utils . parse_docstring ( tag_func . __doc__ ) <EOL> if title : <EOL> title = utils . parse_rst ( title , '<STR_LIT>' , _ ( '<STR_LIT>' ) + tag_name ) <EOL> if body : <EOL> body = utils . parse_rst ( body , '<STR_LIT>' , _ ( '<STR_LIT>' ) + tag_name ) <EOL> for key in metadata : <EOL> metadata [ key ] = utils . parse_rst ( metadata [ key ] , '<STR_LIT>' , _ ( '<STR_LIT>' ) + tag_name ) <EOL> if library in template . builtins : <EOL> tag_library = None <EOL> else : <EOL> tag_library = module_name . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] <EOL> tags . append ( { <EOL> '<STR_LIT:name>' : tag_name , <EOL> '<STR_LIT:title>' : title , <EOL> '<STR_LIT:body>' : body , <EOL> '<STR_LIT>' : metadata , <EOL> '<STR_LIT>' : tag_library , <EOL> } ) <EOL> return render_to_response ( '<STR_LIT>' , { '<STR_LIT>' : tags } , context_instance = RequestContext ( request ) ) <EOL> template_tag_index = staff_member_required ( template_tag_index ) <EOL> def template_filter_index ( request ) : <EOL> if not utils . docutils_is_available : <EOL> return missing_docutils_page ( request ) <EOL> load_all_installed_template_libraries ( ) <EOL> filters = [ ] <EOL> for module_name , library in template . libraries . items ( ) : <EOL> for filter_name , filter_func in library . filters . items ( ) : <EOL> title , body , metadata = utils . parse_docstring ( filter_func . __doc__ ) <EOL> if title : <EOL> title = utils . parse_rst ( title , '<STR_LIT>' , _ ( '<STR_LIT>' ) + filter_name ) <EOL> if body : <EOL> body = utils . parse_rst ( body , '<STR_LIT>' , _ ( '<STR_LIT>' ) + filter_name ) <EOL> for key in metadata : <EOL> metadata [ key ] = utils . parse_rst ( metadata [ key ] , '<STR_LIT>' , _ ( '<STR_LIT>' ) + filter_name ) <EOL> if library in template . builtins : <EOL> tag_library = None <EOL> else : <EOL> tag_library = module_name . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] <EOL> filters . append ( { <EOL> '<STR_LIT:name>' : filter_name , <EOL> '<STR_LIT:title>' : title , <EOL> '<STR_LIT:body>' : body , <EOL> '<STR_LIT>' : metadata , <EOL> '<STR_LIT>' : tag_library , <EOL> } ) <EOL> return render_to_response ( '<STR_LIT>' , { '<STR_LIT>' : filters } , context_instance = RequestContext ( request ) ) <EOL> template_filter_index = staff_member_required ( template_filter_index ) <EOL> def view_index ( request ) : <EOL> if not utils . docutils_is_available : <EOL> return missing_docutils_page ( request ) <EOL> if settings . ADMIN_FOR : <EOL> settings_modules = [ __import__ ( m , { } , { } , [ '<STR_LIT>' ] ) for m in settings . ADMIN_FOR ] <EOL> else : <EOL> settings_modules = [ settings ] <EOL> views = [ ] <EOL> for settings_mod in settings_modules : <EOL> urlconf = __import__ ( settings_mod . ROOT_URLCONF , { } , { } , [ '<STR_LIT>' ] ) <EOL> view_functions = extract_views_from_urlpatterns ( urlconf . urlpatterns ) <EOL> if Site . _meta . installed : <EOL> site_obj = Site . objects . get ( pk = settings_mod . SITE_ID ) <EOL> else : <EOL> site_obj = GenericSite ( ) <EOL> for ( func , regex ) in view_functions : <EOL> views . append ( { <EOL> '<STR_LIT:name>' : func . __name__ , <EOL> '<STR_LIT>' : func . __module__ , <EOL> '<STR_LIT>' : settings_mod . SITE_ID , <EOL> '<STR_LIT>' : site_obj , <EOL> '<STR_LIT:url>' : simplify_regex ( regex ) , <EOL> } ) <EOL> return render_to_response ( '<STR_LIT>' , { '<STR_LIT>' : views } , context_instance = RequestContext ( request ) ) <EOL> view_index = staff_member_required ( view_index ) <EOL> def view_detail ( request , view ) : <EOL> if not utils . docutils_is_available : <EOL> return missing_docutils_page ( request ) <EOL> mod , func = urlresolvers . get_mod_func ( view ) <EOL> try : <EOL> view_func = getattr ( __import__ ( mod , { } , { } , [ '<STR_LIT>' ] ) , func ) <EOL> except ( ImportError , AttributeError ) : <EOL> raise Http404 <EOL> title , body , metadata = utils . parse_docstring ( view_func . __doc__ ) <EOL> if title : <EOL> title = utils . parse_rst ( title , '<STR_LIT>' , _ ( '<STR_LIT>' ) + view ) <EOL> if body : <EOL> body = utils . parse_rst ( body , '<STR_LIT>' , _ ( '<STR_LIT>' ) + view ) <EOL> for key in metadata : <EOL> metadata [ key ] = utils . parse_rst ( metadata [ key ] , '<STR_LIT>' , _ ( '<STR_LIT>' ) + view ) <EOL> return render_to_response ( '<STR_LIT>' , { <EOL> '<STR_LIT:name>' : view , <EOL> '<STR_LIT>' : title , <EOL> '<STR_LIT:body>' : body , <EOL> '<STR_LIT>' : metadata , <EOL> } , context_instance = RequestContext ( request ) ) <EOL> view_detail = staff_member_required ( view_detail ) <EOL> def model_index ( request ) : <EOL> if not utils . docutils_is_available : <EOL> return missing_docutils_page ( request ) <EOL> m_list = [ m . _meta for m in models . get_models ( ) ] <EOL> return render_to_response ( '<STR_LIT>' , { '<STR_LIT>' : m_list } , context_instance = RequestContext ( request ) ) <EOL> model_index = staff_member_required ( model_index ) <EOL> def model_detail ( request , app_label , model_name ) : <EOL> if not utils . docutils_is_available : <EOL> return missing_docutils_page ( request ) <EOL> try : <EOL> app_mod = models . get_app ( app_label ) <EOL> except ImproperlyConfigured : <EOL> raise Http404 , _ ( \"<STR_LIT>\" ) % app_label <EOL> model = None <EOL> for m in models . get_models ( app_mod ) : <EOL> if m . _meta . object_name . lower ( ) == model_name : <EOL> model = m <EOL> break <EOL> if model is None : <EOL> raise Http404 , _ ( \"<STR_LIT>\" ) % { '<STR_LIT:name>' : model_name , '<STR_LIT:label>' : app_label } <EOL> opts = model . _meta <EOL> fields = [ ] <EOL> for field in opts . fields : <EOL> if isinstance ( field , models . ForeignKey ) : <EOL> data_type = related_object_name = field . rel . to . __name__ <EOL> app_label = field . rel . to . _meta . app_label <EOL> verbose = utils . parse_rst ( ( _ ( \"<STR_LIT>\" ) % { '<STR_LIT:label>' : app_label , '<STR_LIT:type>' : data_type } ) , '<STR_LIT>' , _ ( '<STR_LIT>' ) + data_type ) <EOL> else : <EOL> data_type = get_readable_field_data_type ( field ) <EOL> verbose = field . verbose_name <EOL> fields . append ( { <EOL> '<STR_LIT:name>' : field . name , <EOL> '<STR_LIT>' : data_type , <EOL> '<STR_LIT>' : verbose , <EOL> '<STR_LIT>' : field . help_text , <EOL> } ) <EOL> for func_name , func in model . __dict__ . items ( ) : <EOL> if ( inspect . isfunction ( func ) and len ( inspect . getargspec ( func ) [ <NUM_LIT:0> ] ) == <NUM_LIT:1> ) : <EOL> try : <EOL> for exclude in MODEL_METHODS_EXCLUDE : <EOL> if func_name . startswith ( exclude ) : <EOL> raise StopIteration <EOL> except StopIteration : <EOL> continue <EOL> verbose = func . __doc__ <EOL> if verbose : <EOL> verbose = utils . parse_rst ( utils . trim_docstring ( verbose ) , '<STR_LIT>' , _ ( '<STR_LIT>' ) + opts . module_name ) <EOL> fields . append ( { <EOL> '<STR_LIT:name>' : func_name , <EOL> '<STR_LIT>' : get_return_data_type ( func_name ) , <EOL> '<STR_LIT>' : verbose , <EOL> } ) <EOL> for rel in opts . get_all_related_objects ( ) : <EOL> verbose = _ ( \"<STR_LIT>\" ) % { '<STR_LIT:label>' : rel . opts . app_label , '<STR_LIT:name>' : rel . opts . object_name } <EOL> accessor = rel . get_accessor_name ( ) <EOL> fields . append ( { <EOL> '<STR_LIT:name>' : \"<STR_LIT>\" % accessor , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : utils . parse_rst ( _ ( \"<STR_LIT>\" ) % verbose , '<STR_LIT>' , _ ( '<STR_LIT>' ) + opts . module_name ) , <EOL> } ) <EOL> fields . append ( { <EOL> '<STR_LIT:name>' : \"<STR_LIT>\" % accessor , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : utils . parse_rst ( _ ( \"<STR_LIT>\" ) % verbose , '<STR_LIT>' , _ ( '<STR_LIT>' ) + opts . module_name ) , <EOL> } ) <EOL> return render_to_response ( '<STR_LIT>' , { <EOL> '<STR_LIT:name>' : '<STR_LIT>' % ( opts . app_label , opts . object_name ) , <EOL> '<STR_LIT>' : _ ( \"<STR_LIT>\" ) % opts . object_name , <EOL> '<STR_LIT:description>' : model . __doc__ , <EOL> '<STR_LIT>' : fields , <EOL> } , context_instance = RequestContext ( request ) ) <EOL> model_detail = staff_member_required ( model_detail ) <EOL> def template_detail ( request , template ) : <EOL> templates = [ ] <EOL> for site_settings_module in settings . ADMIN_FOR : <EOL> settings_mod = __import__ ( site_settings_module , { } , { } , [ '<STR_LIT>' ] ) <EOL> if Site . _meta . installed : <EOL> site_obj = Site . objects . get ( pk = settings_mod . SITE_ID ) <EOL> else : <EOL> site_obj = GenericSite ( ) <EOL> for dir in settings_mod . TEMPLATE_DIRS : <EOL> template_file = os . path . join ( dir , \"<STR_LIT>\" % template ) <EOL> templates . append ( { <EOL> '<STR_LIT:file>' : template_file , <EOL> '<STR_LIT>' : os . path . exists ( template_file ) , <EOL> '<STR_LIT>' : lambda : os . path . exists ( template_file ) and open ( template_file ) . read ( ) or '<STR_LIT>' , <EOL> '<STR_LIT>' : settings_mod . SITE_ID , <EOL> '<STR_LIT>' : site_obj , <EOL> '<STR_LIT>' : list ( settings_mod . TEMPLATE_DIRS ) . index ( dir ) , <EOL> } ) <EOL> return render_to_response ( '<STR_LIT>' , { <EOL> '<STR_LIT:name>' : template , <EOL> '<STR_LIT>' : templates , <EOL> } , context_instance = RequestContext ( request ) ) <EOL> template_detail = staff_member_required ( template_detail ) <EOL> def missing_docutils_page ( request ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return render_to_response ( '<STR_LIT>' ) <EOL> def load_all_installed_template_libraries ( ) : <EOL> for e in templatetags . __path__ : <EOL> libraries = [ os . path . splitext ( p ) [ <NUM_LIT:0> ] for p in os . listdir ( e ) if p . endswith ( '<STR_LIT>' ) and p [ <NUM_LIT:0> ] . isalpha ( ) ] <EOL> for library_name in libraries : <EOL> try : <EOL> lib = template . get_library ( \"<STR_LIT>\" % library_name . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] ) <EOL> except template . InvalidTemplateLibrary : <EOL> pass <EOL> def get_return_data_type ( func_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if func_name . startswith ( '<STR_LIT>' ) : <EOL> if func_name . endswith ( '<STR_LIT>' ) : <EOL> return '<STR_LIT>' <EOL> elif func_name . endswith ( '<STR_LIT>' ) : <EOL> return '<STR_LIT>' <EOL> return '<STR_LIT>' <EOL> DATA_TYPE_MAPPING = { <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : _ ( '<STR_LIT>' ) , <EOL> } <EOL> def get_readable_field_data_type ( field ) : <EOL>", "answer": "return DATA_TYPE_MAPPING [ field . get_internal_type ( ) ] % field . __dict__"}, {"prompt": "<s> from ebs_deploy . commands import usage <EOL>", "answer": "def add_arguments ( parser ) :"}, {"prompt": "<s> from UcsSdk import * <EOL> import xml . dom . minidom <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL> try : <EOL> handle = UcsHandle ( ) <EOL> handle . Login ( \"<STR_LIT>\" , \"<STR_LIT:username>\" , \"<STR_LIT:password>\" ) <EOL> sp = \"<STR_LIT>\" <EOL> spDn = \"<STR_LIT>\" <EOL> bladeDn = \"<STR_LIT>\" <EOL> obj = LsServer ( ) <EOL> obj . setattr ( LsServer . DN , spDn ) <EOL> obj . setattr ( LsServer . NAME , sp ) <EOL> obj . setattr ( LsServer . STATUS , Status . MODIFIED ) <EOL> bindObj = LsBinding ( ) <EOL> bindObj . setattr ( LsBinding . PN_DN , bladeDn ) <EOL> bindObj . setattr ( LsBinding . RN , LsBinding ( ) . MakeRn ( ) ) <EOL> obj . AddChild ( bindObj ) <EOL> inConfig = ConfigConfig ( ) <EOL> inConfig . AddChild ( obj ) <EOL>", "answer": "ccm = handle . ConfigConfMo ( obj . Dn , inConfig )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> from . import QT_API <EOL> from . import PYQT5_API <EOL> from . import PYQT4_API <EOL> from . import PYSIDE_API <EOL> if os . environ [ QT_API ] == PYQT5_API : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL>", "answer": "elif os . environ [ QT_API ] == PYQT4_API :"}, {"prompt": "<s> from BitTornado . bitfield import Bitfield <EOL> from BitTornado . clock import clock <EOL> from binascii import b2a_hex <EOL> try : <EOL> True <EOL> except : <EOL> True = <NUM_LIT:1> <EOL> False = <NUM_LIT:0> <EOL> DEBUG = False <EOL> def toint ( s ) : <EOL> return long ( b2a_hex ( s ) , <NUM_LIT:16> ) <EOL> def tobinary ( i ) : <EOL> return ( chr ( i >> <NUM_LIT> ) + chr ( ( i >> <NUM_LIT:16> ) & <NUM_LIT> ) + <EOL> chr ( ( i >> <NUM_LIT:8> ) & <NUM_LIT> ) + chr ( i & <NUM_LIT> ) ) <EOL> CHOKE = chr ( <NUM_LIT:0> ) <EOL> UNCHOKE = chr ( <NUM_LIT:1> ) <EOL> INTERESTED = chr ( <NUM_LIT:2> ) <EOL> NOT_INTERESTED = chr ( <NUM_LIT:3> ) <EOL> HAVE = chr ( <NUM_LIT:4> ) <EOL> BITFIELD = chr ( <NUM_LIT:5> ) <EOL> REQUEST = chr ( <NUM_LIT:6> ) <EOL> PIECE = chr ( <NUM_LIT:7> ) <EOL> CANCEL = chr ( <NUM_LIT:8> ) <EOL> class Connection : <EOL> def __init__ ( self , connection , connecter ) : <EOL> self . connection = connection <EOL> self . connecter = connecter <EOL> self . got_anything = False <EOL> self . next_upload = None <EOL> self . outqueue = [ ] <EOL> self . partial_message = None <EOL> self . download = None <EOL> self . upload = None <EOL> self . send_choke_queued = False <EOL> self . just_unchoked = None <EOL> def get_ip ( self , real = False ) : <EOL> return self . connection . get_ip ( real ) <EOL> def get_id ( self ) : <EOL> return self . connection . get_id ( ) <EOL> def get_readable_id ( self ) : <EOL> return self . connection . get_readable_id ( ) <EOL> def close ( self ) : <EOL> if DEBUG : <EOL>", "answer": "print '<STR_LIT>'"}, {"prompt": "<s> import os <EOL> import sys <EOL> sys . path . append ( os . path . join ( os . path . abspath ( '<STR_LIT:.>' ) , '<STR_LIT>' ) ) <EOL> sys . path . append ( os . path . dirname ( os . path . abspath ( '<STR_LIT:.>' ) ) ) <EOL> import analytical <EOL> project = u'<STR_LIT>' <EOL> copyright = u'<STR_LIT>' <EOL> release = analytical . __version__ <EOL> version = release . rsplit ( '<STR_LIT:.>' , <NUM_LIT:1> ) [ <NUM_LIT:0> ] <EOL> extensions = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> templates_path = [ '<STR_LIT>' ] <EOL> source_suffix = '<STR_LIT>' <EOL> master_doc = '<STR_LIT:index>' <EOL> add_function_parentheses = True <EOL> pygments_style = '<STR_LIT>' <EOL>", "answer": "intersphinx_mapping = {"}, {"prompt": "<s> import sqlalchemy as sa <EOL> from sqlalchemy . ext . hybrid import hybrid_property <EOL> from tests import ModelFormTestCase <EOL> from wtforms_alchemy import ModelForm <EOL> class TestSynonym ( ModelFormTestCase ) : <EOL> def test_synonym_returning_column_property_with_include ( self ) : <EOL> class ModelTest ( self . base ) : <EOL> __tablename__ = '<STR_LIT>' <EOL> id = sa . Column ( sa . Integer , primary_key = True ) <EOL> _test_column = sa . Column ( '<STR_LIT>' , sa . Integer , nullable = False ) <EOL> @ hybrid_property <EOL> def test_column_hybrid ( self ) : <EOL> return self . test_column * <NUM_LIT:2> <EOL> @ test_column_hybrid . setter <EOL> def test_column_hybrid ( self , value ) : <EOL> self . _test_column = value <EOL> test_column = sa . orm . synonym ( <EOL> '<STR_LIT>' , descriptor = '<STR_LIT>' <EOL> ) <EOL> class ModelTestForm ( ModelForm ) : <EOL> class Meta : <EOL> model = ModelTest <EOL> not_null_str_validator = None <EOL> not_null_validator = None <EOL> include = ( '<STR_LIT>' , ) <EOL> exclude = ( '<STR_LIT>' , ) <EOL> form = ModelTestForm ( ) <EOL> assert form . test_column <EOL> def test_synonym_returning_column_property_with_only ( self ) : <EOL> class ModelTest ( self . base ) : <EOL> __tablename__ = '<STR_LIT>' <EOL> id = sa . Column ( sa . Integer , primary_key = True ) <EOL> _test_column = sa . Column ( '<STR_LIT>' , sa . Integer , nullable = False ) <EOL> @ hybrid_property <EOL> def test_column_hybrid ( self ) : <EOL> return self . test_column * <NUM_LIT:2> <EOL> @ test_column_hybrid . setter <EOL> def test_column_hybrid ( self , value ) : <EOL> self . _test_column = value <EOL> test_column = sa . orm . synonym ( <EOL>", "answer": "'<STR_LIT>' , descriptor = '<STR_LIT>'"}, {"prompt": "<s> from django . shortcuts import * <EOL> from django . http import HttpResponse <EOL> from django . core . urlresolvers import reverse <EOL>", "answer": "def index ( request ) :"}, {"prompt": "<s> import poioapi . io . latex <EOL> import poioapi . annotationgraph <EOL> import os . path <EOL> import filecmp <EOL> class TestWriter ( ) : <EOL> def test_write_with_mandinka ( self ) : <EOL> input = os . path . join ( os . path . dirname ( __file__ ) , \"<STR_LIT:..>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> output = os . path . join ( os . path . dirname ( __file__ ) , \"<STR_LIT:..>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> expected = os . path . join ( os . path . dirname ( __file__ ) , \"<STR_LIT:..>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ag = poioapi . annotationgraph . AnnotationGraph ( ) <EOL> ag = ag . from_mandinka ( input ) <EOL> writer = poioapi . io . latex . Writer ( ) <EOL> writer . write ( output , ag ) <EOL> assert ( os . path . getsize ( output ) == os . path . getsize ( expected ) ) <EOL>", "answer": "assert ( filecmp . cmp ( output , expected , False ) )"}, {"prompt": "<s> import datetime <EOL> from corehq . apps . reports . filters . dates import DatespanFilter <EOL> from corehq . util . dates import iso_string_to_date <EOL> from dimagi . utils . dates import DateSpan <EOL> import json <EOL> from django . utils . translation import ugettext as _ , ugettext_noop <EOL> from corehq . apps . reports . dont_use . fields import ReportField <EOL> class DateRangeField ( DatespanFilter ) : <EOL> name = ugettext_noop ( \"<STR_LIT>\" ) <EOL>", "answer": "template = '<STR_LIT>'"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from googleads import dfp <EOL> LINE_ITEM_ID = '<STR_LIT>' <EOL> def main ( client , line_item_id ) : <EOL> lica_service = client . GetService ( <EOL> '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> values = [ { <EOL> '<STR_LIT:key>' : '<STR_LIT>' , <EOL> '<STR_LIT:value>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT:value>' : line_item_id"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> import argparse <EOL> import datetime <EOL> from operator import itemgetter <EOL> from collections import defaultdict <EOL> from openxc . formats . json import JsonFormatter <EOL> from openxc . sources . trace import TraceDataSource <EOL> from . common import configure_logging <EOL> class BaseSplitter ( object ) : <EOL> def __init__ ( self ) : <EOL> self . records = [ ] <EOL> self . buckets = defaultdict ( list ) <EOL> def _key_for_record ( self , record ) : <EOL> raise NotImplementedError <EOL> def split ( self , files ) : <EOL> for filename in files : <EOL> source = TraceDataSource ( self . receive , filename = filename , <EOL> loop = False , realtime = False ) <EOL> source . start ( ) <EOL> self . records . sort ( key = itemgetter ( '<STR_LIT>' ) ) <EOL> for record in self . records : <EOL> self . buckets [ self . _key_for_record ( record ) ] . append ( record ) <EOL> return self . buckets <EOL> def receive ( self , message , ** kwargs ) : <EOL> self . records . append ( message ) <EOL> class TimeSplitter ( BaseSplitter ) : <EOL> def __init__ ( self , unit ) : <EOL>", "answer": "super ( TimeSplitter , self ) . __init__ ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import warnings <EOL> from django import template <EOL> from django . conf import settings <EOL> from django . utils . encoding import smart_str , force_unicode <EOL> from django . utils . safestring import mark_safe <EOL> register = template . Library ( ) <EOL>", "answer": "@ register . filter ( is_safe = True )"}, {"prompt": "<s> from modules . model import Model <EOL> from modules . validations import is_required , is_string , is_number <EOL> from modules . content import get as c <EOL> import rethinkdb as r <EOL> def is_score ( val ) : <EOL> if val > <NUM_LIT:1> or val < <NUM_LIT:0> : <EOL> return c ( '<STR_LIT>' ) <EOL> class Response ( Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> tablename = '<STR_LIT>' <EOL> schema = dict ( Model . schema . copy ( ) , ** { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : ( is_required , is_string , ) , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : ( is_required , is_string , ) , <EOL> } , <EOL>", "answer": "'<STR_LIT>' : {"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> import collections <EOL> from django . utils import six <EOL> from django . views . decorators import vary <EOL> from . . import core <EOL> __all__ = ( \"<STR_LIT>\" , \"<STR_LIT>\" , ) <EOL> class VaryOnHeaders ( core . http . HttpMethodAllow ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vary_on_headers = None <EOL> def get_vary_on_headers ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . vary_on_headers <EOL> def get_allow_handler ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vary_on_headers = self . get_vary_on_headers ( ) <EOL> if isinstance ( vary_on_headers , six . string_types ) : <EOL>", "answer": "vary_on_headers = ( vary_on_headers , )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "from saunter . SaunterWebDriver import SaunterWebDriver"}, {"prompt": "<s> import sys , os <EOL> extensions = [ ] <EOL> templates_path = [ '<STR_LIT>' ] <EOL> source_suffix = '<STR_LIT>' <EOL> master_doc = '<STR_LIT:index>' <EOL> project = u'<STR_LIT>' <EOL> copyright = u'<STR_LIT>' <EOL> version = '<STR_LIT>' <EOL> release = '<STR_LIT>' <EOL> exclude_patterns = [ ] <EOL> pygments_style = '<STR_LIT>' <EOL> html_theme = '<STR_LIT:default>' <EOL> html_static_path = [ '<STR_LIT>' ] <EOL> htmlhelp_basename = '<STR_LIT>' <EOL> latex_elements = { <EOL> } <EOL> latex_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> man_pages = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> [ u'<STR_LIT>' ] , <NUM_LIT:1> ) <EOL> ] <EOL> texinfo_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ) , <EOL>", "answer": "] "}, {"prompt": "<s> from sqlalchemy import Boolean <EOL>", "answer": "from sqlalchemy import Column"}, {"prompt": "<s> import sys <EOL> if \"<STR_LIT:..>\" not in sys . path : sys . path . insert ( <NUM_LIT:0> , \"<STR_LIT:..>\" ) <EOL>", "answer": "import ply . lex as lex"}, {"prompt": "<s> import datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> depends_on = ( <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ) <EOL>", "answer": "def forwards ( self , orm ) :"}, {"prompt": "<s> from . . core . exceptions import ProjectorException <EOL> from . . utils . projector import ProjectorElement , ProjectorRequirement <EOL> from . models import User <EOL> from . views import GroupViewSet , UserViewSet <EOL> class UserSlide ( ProjectorElement ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = '<STR_LIT>' <EOL> def check_data ( self ) : <EOL>", "answer": "if not User . objects . filter ( pk = self . config_entry . get ( '<STR_LIT:id>' ) ) . exists ( ) :"}, {"prompt": "<s> from . settings import * <EOL> SECRET_KEY = '<STR_LIT>' <EOL> DEFAULT_CURRENCY = '<STR_LIT>' <EOL> DATABASES [ '<STR_LIT:default>' ] [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' : None } "}, {"prompt": "<s> import os <EOL> import sys <EOL> from string import join <EOL> sys . path . extend ( [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] ) <EOL> os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> from django . db . models . loading import cache <EOL> cache . get_apps ( ) <EOL> from freenasUI . common . system import ( <EOL> activedirectory_enabled , <EOL> ldap_enabled , <EOL> nis_enabled , <EOL> nt4_enabled <EOL> ) <EOL> from freenasUI . common . freenascache import ( <EOL> FreeNAS_UserCache , <EOL> FreeNAS_GroupCache , <EOL> FreeNAS_Directory_UserCache , <EOL> FreeNAS_Directory_GroupCache , <EOL> FREENAS_CACHEDIR <EOL> ) <EOL> from freenasUI . common . freenasldap import ( <EOL> FreeNAS_ActiveDirectory , <EOL> FLAGS_DBINIT , <EOL> FLAGS_CACHE_READ_USER , <EOL> FLAGS_CACHE_WRITE_USER , <EOL> FLAGS_CACHE_READ_GROUP , <EOL> FLAGS_CACHE_WRITE_GROUP <EOL> ) <EOL> from freenasUI . common . freenasnis import FreeNAS_NIS <EOL> from freenasUI . common . freenasnt4 import FreeNAS_NT4 <EOL> from freenasUI . common . freenasusers import ( <EOL> FreeNAS_Users , <EOL> FreeNAS_Groups <EOL> ) <EOL> def usage ( keys ) : <EOL> print >> sys . stderr , \"<STR_LIT>\" % ( sys . argv [ <NUM_LIT:0> ] , join ( keys , '<STR_LIT:|>' ) ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL>", "answer": "def _cachelen ( cache ) :"}, {"prompt": "<s> import sys <EOL> from lib . db import * <EOL> class sample ( object ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def define_sample ( self , md5 , sha1 , sha256 , ruleset_name , rule_name , notificaiton_date , first_seen , detection_ratio , size ) : <EOL>", "answer": "self . md5 = md5"}, {"prompt": "<s> import mock <EOL> import cloudservers <EOL> import httplib2 <EOL> from nose . tools import assert_raises , assert_equal <EOL> def test_authenticate_success ( ) : <EOL> cs = cloudservers . CloudServers ( \"<STR_LIT:username>\" , \"<STR_LIT>\" ) <EOL> auth_response = httplib2 . Response ( { <EOL> '<STR_LIT:status>' : <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } ) <EOL> mock_request = mock . Mock ( return_value = ( auth_response , None ) ) <EOL> @ mock . patch . object ( httplib2 . Http , \"<STR_LIT>\" , mock_request ) <EOL> def test_auth_call ( ) : <EOL> cs . client . authenticate ( ) <EOL> mock_request . assert_called_with ( cs . client . AUTH_URL , '<STR_LIT:GET>' , <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT:username>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : cs . client . USER_AGENT <EOL> } ) <EOL> assert_equal ( cs . client . management_url , auth_response [ '<STR_LIT>' ] ) <EOL> assert_equal ( cs . client . auth_token , auth_response [ '<STR_LIT>' ] ) <EOL> test_auth_call ( ) <EOL> def test_authenticate_failure ( ) : <EOL> cs = cloudservers . CloudServers ( \"<STR_LIT:username>\" , \"<STR_LIT>\" ) <EOL> auth_response = httplib2 . Response ( { '<STR_LIT:status>' : <NUM_LIT> } ) <EOL> mock_request = mock . Mock ( return_value = ( auth_response , None ) ) <EOL> @ mock . patch . object ( httplib2 . Http , \"<STR_LIT>\" , mock_request ) <EOL> def test_auth_call ( ) : <EOL> assert_raises ( cloudservers . Unauthorized , cs . client . authenticate ) <EOL>", "answer": "test_auth_call ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from collections import OrderedDict , Iterable <EOL> from copy import deepcopy <EOL> import logging <EOL> from skspec . logger import logclass <EOL> from skspec . plotting . multiplots import slice_plot <EOL> import skspec . core . utilities as put <EOL> logger = logging . getLogger ( __name__ ) <EOL> class MultiError ( Exception ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> def mem_address ( obj ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> out = obj . __repr__ ( ) . split ( ) [ - <NUM_LIT:1> ] <EOL> except Exception as E : <EOL> raise Exception ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % E . message ) <EOL> else : <EOL> return out . strip ( \"<STR_LIT:'>\" ) . strip ( '<STR_LIT:>>' ) <EOL> @ logclass ( log_name = __name__ , public_lvl = '<STR_LIT>' ) <EOL> class Stack ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> itemlabel = '<STR_LIT>' <EOL> _magic = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> def __init__ ( self , data , keys = None , name = '<STR_LIT>' , sort_items = False ) : <EOL> self . name = name <EOL> if isinstance ( data , dict ) : <EOL> logger . debug ( '<STR_LIT>' % self . full_name ) <EOL> if sort_items : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . _data = OrderedDict ( sorted ( data . keys ( ) , key = lambda t : t [ <NUM_LIT:0> ] ) ) <EOL> else : <EOL> self . _data = OrderedDict ( data ) <EOL> else : <EOL> if not isinstance ( data , Iterable ) : <EOL> logger . info ( '<STR_LIT>' <EOL> '<STR_LIT>' % self . full_name ) <EOL> data = [ data ] <EOL> if keys : <EOL> if not isinstance ( keys , Iterable ) : <EOL> logger . info ( '<STR_LIT>' <EOL> '<STR_LIT>' % self . full_name ) <EOL> keys = [ keys ] <EOL> if len ( keys ) != len ( data ) : <EOL> raise ValueError ( '<STR_LIT>' % ( len ( keys ) , len ( data ) ) ) <EOL> else : <EOL> try : <EOL> keys , data = zip ( * data ) <EOL> except Exception : <EOL> keys = self . _gen_keys ( len ( data ) ) <EOL> if len ( keys ) > <NUM_LIT:1> : <EOL> logger . warn ( \"<STR_LIT>\" % ( keys [ <NUM_LIT:0> ] , keys [ - <NUM_LIT:1> ] ) ) <EOL> else : <EOL> logger . warn ( \"<STR_LIT>\" % keys [ <NUM_LIT:0> ] ) <EOL> self . _data = OrderedDict ( [ ( key , data [ i ] ) for ( i , key ) <EOL> in enumerate ( keys ) ] ) <EOL> @ property <EOL> def _address ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return mem_address ( super ( Stack , self ) . __repr__ ( ) ) <EOL> def _gen_keys ( self , length ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> logger . debug ( '<STR_LIT>' % self . full_name ) <EOL> return [ self . itemlabel + str ( i ) for i in range ( length ) ] <EOL> def __getitem__ ( self , keyslice ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if hasattr ( keyslice , '<STR_LIT>' ) : <EOL> tuples_out = [ ] <EOL> for item in keyslice : <EOL> if isinstance ( item , str ) : <EOL> item = self . _data . keys ( ) . index ( item ) <EOL> tuples_out . append ( self . _data . items ( ) [ item ] ) <EOL> else : <EOL> if isinstance ( keyslice , int ) or isinstance ( keyslice , slice ) : <EOL> tuples_out = self . _data . items ( ) [ keyslice ] <EOL> else : <EOL> tuples_out = [ ( keyslice , self . _data [ keyslice ] ) ] <EOL> if sum ( <NUM_LIT:1> for x in tuples_out ) == <NUM_LIT:2> : <EOL> return tuples_out [ <NUM_LIT:1> ] <EOL> else : <EOL> return self . __class__ ( tuples_out ) <EOL> def __delitem__ ( self , keyslice ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( keyslice , str ) : <EOL> idx = self . names . index ( keyslice ) <EOL> self . pop ( idx ) <EOL> else : <EOL> raise NotImplementedError ( \"<STR_LIT>\" ) <EOL> def __setitem__ ( self , name , canvas ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> if name in self . names : <EOL> idx = self . names . index ( name ) <EOL> self . pop ( idx ) <EOL> self . insert ( idx , name , canvas ) <EOL> else : <EOL> self . names . append ( name ) <EOL> def __getattr__ ( self , attr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if attr in self . _data . keys ( ) : <EOL> if hasattr ( self . _data , attr ) : <EOL> raise AttributeError ( '<STR_LIT>' % ( attr ) ) <EOL> else : <EOL> return self [ attr ] <EOL> return getattr ( self . _data , attr ) <EOL> def __len__ ( self ) : <EOL> return self . _data . __len__ ( ) <EOL> def __iter__ ( self ) : <EOL> return self . _data . __iter__ ( ) <EOL> def __reversed__ ( self ) : <EOL> return self . _data . __reversed__ ( ) <EOL> def __contains__ ( self ) : <EOL> return self . _data . __contains__ ( ) <EOL> def as_3d ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise Panel ( data = self . _data ) <EOL> def get_all ( self , attr , astype = tuple ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return put . _parse_generator ( <EOL> ( ( item [ <NUM_LIT:0> ] , getattr ( item [ <NUM_LIT:1> ] , attr ) ) for item in self . items ( ) ) , astype ) <EOL> def _get_unique ( self , attr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> unique = set ( self . get_all ( attr , astype = dict ) . values ( ) ) <EOL> if len ( unique ) > <NUM_LIT:1> : <EOL> return '<STR_LIT>' <EOL> else : <EOL> return tuple ( unique ) [ <NUM_LIT:0> ] <EOL> def set_all ( self , attr , val , inplace = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if inplace : <EOL> for ( key , item ) in self . items ( ) : <EOL> try : <EOL> setattr ( item , attr , val ) <EOL> except Exception as E : <EOL> raise Exception ( '<STR_LIT>' % ( attr , key , E ) ) <EOL> else : <EOL> out = deepcopy ( self . _data ) <EOL> for item in out : <EOL> setattr ( out [ item ] , attr , val ) <EOL> return self . __class__ ( out ) <EOL> def apply ( self , func , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> inplace = kwargs . pop ( '<STR_LIT>' , False ) <EOL> if isinstance ( func , basestring ) : <EOL> if inplace : <EOL> for item in self : <EOL> self [ item ] = getattr ( self [ item ] , func ) ( * args , ** kwargs ) <EOL> else : <EOL> return self . __class__ ( OrderedDict ( [ ( k , getattr ( v , func ) ( * args , ** kwargs ) ) for k , v in self . items ( ) ] ) ) <EOL> else : <EOL> if inplace : <EOL> for item in self : <EOL> self [ item ] = self [ item ] . apply ( func ) ( * args , ** kwargs ) <EOL> else : <EOL> return self . __class__ ( OrderedDict ( [ ( k , v . apply ( func , * args , ** kwargs ) ) for k , v in self . items ( ) ] ) ) <EOL> @ property <EOL> def full_name ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> outname = getattr ( self , '<STR_LIT:name>' , '<STR_LIT>' ) <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ , self . name ) <EOL> @ logclass ( log_name = __name__ ) <EOL> class SpecStack ( Stack ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> itemlabel = '<STR_LIT>' <EOL>", "answer": "def as_3d ( self , ** kwargs ) :"}, {"prompt": "<s> from django . http import Http404 <EOL> from django . shortcuts import render_to_response <EOL> from django . core . paginator import Paginator , EmptyPage , PageNotAnInteger <EOL> def choice_list ( request , app_label , module_name , field_name , models ) : <EOL>", "answer": "m , f = lookup_field ( app_label , module_name , field_name , models )"}, {"prompt": "<s> import mock <EOL> from oslotest import base as test_base <EOL>", "answer": "import webob . dec"}, {"prompt": "<s> import testtools <EOL> from barbicanclient import formatter <EOL> class EntityFormatter ( formatter . EntityFormatter ) : <EOL> columns = ( \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ) <EOL> def _get_formatted_data ( self ) : <EOL> data = ( self . _attr_a , <EOL> self . _attr_b , <EOL> self . _attr_c ) <EOL> return data <EOL> class Entity ( EntityFormatter ) : <EOL> def __init__ ( self , attr_a , attr_b , attr_c ) : <EOL>", "answer": "self . _attr_a = attr_a"}, {"prompt": "<s> import os . path <EOL> import cherrypy <EOL> from ws4py . server . cherrypyserver import WebSocketPlugin , WebSocketTool <EOL> from ws4py . websocket import WebSocket <EOL> class BroadcastWebSocketHandler ( WebSocket ) : <EOL> def received_message ( self , m ) : <EOL> cherrypy . engine . publish ( '<STR_LIT>' , str ( m ) ) <EOL> class Root ( object ) : <EOL> @ cherrypy . expose <EOL> def display ( self ) : <EOL> return \"\"\"<STR_LIT>\"\"\" <EOL> @ cherrypy . expose <EOL> def ws ( self ) : <EOL> cherrypy . log ( \"<STR_LIT>\" % repr ( cherrypy . request . ws_handler ) ) <EOL> @ cherrypy . expose <EOL> def index ( self ) : <EOL> return \"\"\"<STR_LIT>\"\"\" <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> cherrypy . config . update ( { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT>' ) ) <EOL> } <EOL> ) <EOL> print os . path . abspath ( os . path . join ( __file__ , '<STR_LIT>' ) ) <EOL> WebSocketPlugin ( cherrypy . engine ) . subscribe ( ) <EOL> cherrypy . tools . websocket = WebSocketTool ( ) <EOL> cherrypy . quickstart ( Root ( ) , '<STR_LIT>' , config = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL>", "answer": "'<STR_LIT>' : {"}, {"prompt": "<s> import sys <EOL> import hashlib <EOL> import string <EOL> import struct <EOL> import logging <EOL> class lazy_property ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , fget ) : <EOL> self . func_name = fget . __name__ <EOL> self . fget = fget <EOL> def __get__ ( self , obj , cls ) : <EOL> if obj is None : <EOL> return <EOL> value = self . fget ( obj ) <EOL> setattr ( obj , self . func_name , value ) <EOL> return value <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def random_string ( length ) : <EOL> import M2Crypto . Rand <EOL> return M2Crypto . Rand . rand_bytes ( length ) <EOL> def get_table ( key ) : <EOL> m = hashlib . md5 ( ) <EOL> m . update ( key ) <EOL> s = m . digest ( ) <EOL> ( a , b ) = struct . unpack ( '<STR_LIT>' , s ) <EOL> table = [ c for c in string . maketrans ( '<STR_LIT>' , '<STR_LIT>' ) ] <EOL> for i in xrange ( <NUM_LIT:1> , <NUM_LIT> ) : <EOL> table . sort ( lambda x , y : int ( a % ( ord ( x ) + i ) - a % ( ord ( y ) + i ) ) ) <EOL> encrypt_table = '<STR_LIT>' . join ( table ) <EOL> decrypt_table = string . maketrans ( encrypt_table , string . maketrans ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> return encrypt_table , decrypt_table <EOL> def EVP_BytesToKey ( password , key_len , iv_len ) : <EOL> m = [ ] <EOL> i = <NUM_LIT:0> <EOL> while len ( '<STR_LIT>' . join ( m ) ) < ( key_len + iv_len ) : <EOL> md5 = hashlib . md5 ( ) <EOL> data = password <EOL> if i > <NUM_LIT:0> : <EOL> data = m [ i - <NUM_LIT:1> ] + password <EOL> md5 . update ( data ) <EOL> m . append ( md5 . digest ( ) ) <EOL> i += <NUM_LIT:1> <EOL> ms = '<STR_LIT>' . join ( m ) <EOL> key = ms [ : key_len ] <EOL> iv = ms [ key_len : key_len + iv_len ] <EOL> return ( key , iv ) <EOL> class Crypto ( object ) : <EOL>", "answer": "METHOD_SUPPORTED = {"}, {"prompt": "<s> from lino . api import dd , rt <EOL> from django . conf import settings <EOL> from lino . utils import Cycler <EOL> Entry = dd . resolve_model ( '<STR_LIT>' ) <EOL> EntryType = dd . resolve_model ( '<STR_LIT>' ) <EOL> Company = dd . resolve_model ( '<STR_LIT>' ) <EOL> LOREM_IPSUM = \"<STR_LIT>\" <EOL> def objects ( ) : <EOL> yield EntryType ( name = \"<STR_LIT>\" ) <EOL> yield EntryType ( name = \"<STR_LIT>\" ) <EOL> yield EntryType ( name = \"<STR_LIT>\" ) <EOL> yield EntryType ( name = \"<STR_LIT>\" ) <EOL> yield EntryType ( name = \"<STR_LIT>\" ) <EOL>", "answer": "TYPES = Cycler ( EntryType . objects . all ( ) )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> import sys <EOL> from modularodm import Q <EOL> from nose . tools import * <EOL> from website import models <EOL> from website . app import init_app <EOL> from scripts import utils as scripts_utils <EOL> logger = logging . getLogger ( __name__ ) <EOL>", "answer": "def main ( ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import division , absolute_import , print_function <EOL> from test . _common import unittest , DummyIO <EOL> from test import test_importer <EOL> from beets . ui . commands import TerminalImportSession <EOL> from beets import importer <EOL> from beets import config <EOL> class TestTerminalImportSession ( TerminalImportSession ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . io = kwargs . pop ( '<STR_LIT>' ) <EOL> super ( TestTerminalImportSession , self ) . __init__ ( * args , ** kwargs ) <EOL> self . _choices = [ ] <EOL> default_choice = importer . action . APPLY <EOL> def add_choice ( self , choice ) : <EOL> self . _choices . append ( choice ) <EOL> def clear_choices ( self ) : <EOL> self . _choices = [ ] <EOL> def choose_match ( self , task ) : <EOL> self . _add_choice_input ( ) <EOL> return super ( TestTerminalImportSession , self ) . choose_match ( task ) <EOL> def choose_item ( self , task ) : <EOL> self . _add_choice_input ( ) <EOL> return super ( TestTerminalImportSession , self ) . choose_item ( task ) <EOL> def _add_choice_input ( self ) : <EOL> try : <EOL> choice = self . _choices . pop ( <NUM_LIT:0> ) <EOL> except IndexError : <EOL> choice = self . default_choice <EOL> if choice == importer . action . APPLY : <EOL> self . io . addinput ( u'<STR_LIT:A>' ) <EOL> elif choice == importer . action . ASIS : <EOL> self . io . addinput ( u'<STR_LIT>' ) <EOL> elif choice == importer . action . ALBUMS : <EOL> self . io . addinput ( u'<STR_LIT>' ) <EOL> elif choice == importer . action . TRACKS : <EOL> self . io . addinput ( u'<STR_LIT:T>' ) <EOL> elif choice == importer . action . SKIP : <EOL> self . io . addinput ( u'<STR_LIT:S>' ) <EOL> elif isinstance ( choice , int ) : <EOL> self . io . addinput ( u'<STR_LIT:M>' ) <EOL> self . io . addinput ( unicode ( choice ) ) <EOL> self . _add_choice_input ( ) <EOL> else : <EOL> raise Exception ( u'<STR_LIT>' % choice ) <EOL> class TerminalImportSessionSetup ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _setup_import_session ( self , import_dir = None , delete = False , <EOL> threaded = False , copy = True , singletons = False , <EOL> move = False , autotag = True ) : <EOL> config [ '<STR_LIT>' ] [ '<STR_LIT>' ] = copy <EOL> config [ '<STR_LIT>' ] [ '<STR_LIT>' ] = delete <EOL> config [ '<STR_LIT>' ] [ '<STR_LIT>' ] = True <EOL> config [ '<STR_LIT>' ] = False <EOL> config [ '<STR_LIT>' ] [ '<STR_LIT>' ] = singletons <EOL> config [ '<STR_LIT>' ] [ '<STR_LIT>' ] = move <EOL> config [ '<STR_LIT>' ] [ '<STR_LIT>' ] = autotag <EOL> config [ '<STR_LIT>' ] [ '<STR_LIT>' ] = False <EOL> if not hasattr ( self , '<STR_LIT>' ) : <EOL> self . io = DummyIO ( ) <EOL> self . io . install ( ) <EOL> self . importer = TestTerminalImportSession ( <EOL> self . lib , loghandler = None , query = None , io = self . io , <EOL> paths = [ import_dir or self . import_dir ] , <EOL> ) <EOL> class NonAutotaggedImportTest ( TerminalImportSessionSetup , <EOL> test_importer . NonAutotaggedImportTest ) : <EOL> pass <EOL> class ImportTest ( TerminalImportSessionSetup , <EOL> test_importer . ImportTest ) : <EOL> pass <EOL> class ImportSingletonTest ( TerminalImportSessionSetup , <EOL> test_importer . ImportSingletonTest ) : <EOL> pass <EOL> class ImportTracksTest ( TerminalImportSessionSetup , <EOL> test_importer . ImportTracksTest ) : <EOL> pass <EOL> class ImportCompilationTest ( TerminalImportSessionSetup , <EOL> test_importer . ImportCompilationTest ) : <EOL> pass <EOL> class ImportExistingTest ( TerminalImportSessionSetup , <EOL> test_importer . ImportExistingTest ) : <EOL> pass <EOL> class ChooseCandidateTest ( TerminalImportSessionSetup , <EOL> test_importer . ChooseCandidateTest ) : <EOL> pass <EOL> class GroupAlbumsImportTest ( TerminalImportSessionSetup , <EOL> test_importer . GroupAlbumsImportTest ) : <EOL>", "answer": "pass"}, {"prompt": "<s> from . helper import UnitHelper <EOL> from github3 . null import NullObject <EOL> import pytest <EOL> class TestNullObject ( UnitHelper ) : <EOL> described_class = NullObject <EOL> def create_instance_of_described_class ( self ) : <EOL> return self . described_class ( ) <EOL> def test_returns_empty_list ( self ) : <EOL> assert list ( self . instance ) == [ ] <EOL> def test_contains_nothing ( self ) : <EOL> assert '<STR_LIT:foo>' not in self . instance <EOL> def test_returns_itself_when_called ( self ) : <EOL> assert self . instance ( '<STR_LIT:foo>' , '<STR_LIT:bar>' , '<STR_LIT>' ) is self . instance <EOL> def test_returns_empty_string ( self ) : <EOL> assert str ( self . instance ) == '<STR_LIT>' <EOL> def test_allows_arbitrary_attributes ( self ) : <EOL> assert self . instance . attr is self . instance <EOL> def test_allows_arbitrary_attributes_to_be_set ( self ) : <EOL> self . instance . attr = '<STR_LIT>' <EOL> assert self . instance . attr is self . instance <EOL>", "answer": "def test_provides_an_api_to_check_if_it_is_null ( self ) :"}, {"prompt": "<s> import core . modules <EOL> import core . modules . module_registry <EOL> from core . modules . vistrails_module import Module , ModuleError <EOL> from PDB import * <EOL> identifier = '<STR_LIT>' <EOL> version = '<STR_LIT>' <EOL> name = '<STR_LIT>' <EOL> def initialize ( * args , ** keywords ) : <EOL> reg = core . modules . module_registry <EOL> basic = core . modules . basic_modules <EOL> reg . add_module ( ProteinDataBank , abstract = True ) <EOL>", "answer": "reg . add_module ( Protein , abstract = True )"}, {"prompt": "<s> from time import sleep <EOL> from onvif import ONVIFCamera <EOL> XMAX = <NUM_LIT:1> <EOL> XMIN = - <NUM_LIT:1> <EOL> YMAX = <NUM_LIT:1> <EOL> YMIN = - <NUM_LIT:1> <EOL> def perform_move ( ptz , request , timeout ) : <EOL> ptz . ContinuousMove ( request ) <EOL> sleep ( timeout ) <EOL> ptz . Stop ( { '<STR_LIT>' : request . ProfileToken } ) <EOL> def move_up ( ptz , request , timeout = <NUM_LIT:1> ) : <EOL> print '<STR_LIT>' <EOL> request . Velocity . PanTilt . _x = <NUM_LIT:0> <EOL> request . Velocity . PanTilt . _y = YMAX <EOL> perform_move ( ptz , request , timeout ) <EOL> def move_down ( ptz , request , timeout = <NUM_LIT:1> ) : <EOL> print '<STR_LIT>' <EOL> request . Velocity . PanTilt . _x = <NUM_LIT:0> <EOL> request . Velocity . PanTilt . _y = YMIN <EOL> perform_move ( ptz , request , timeout ) <EOL> def move_right ( ptz , request , timeout = <NUM_LIT:1> ) : <EOL> print '<STR_LIT>' <EOL> request . Velocity . PanTilt . _x = XMAX <EOL> request . Velocity . PanTilt . _y = <NUM_LIT:0> <EOL> perform_move ( ptz , request , timeout ) <EOL> def move_left ( ptz , request , timeout = <NUM_LIT:1> ) : <EOL> print '<STR_LIT>' <EOL> request . Velocity . PanTilt . _x = XMIN <EOL> request . Velocity . PanTilt . _y = <NUM_LIT:0> <EOL> perform_move ( ptz , request , timeout ) <EOL> def continuous_move ( ) : <EOL> mycam = ONVIFCamera ( '<STR_LIT>' , <NUM_LIT> , '<STR_LIT>' , '<STR_LIT>' ) <EOL> media = mycam . create_media_service ( ) <EOL> ptz = mycam . create_ptz_service ( ) <EOL> media_profile = media . GetProfiles ( ) [ <NUM_LIT:0> ] ; <EOL>", "answer": "request = ptz . create_type ( '<STR_LIT>' )"}, {"prompt": "<s> from django . contrib . auth . models import User <EOL> from django . contrib . contenttypes . models import ContentType <EOL> from django . core . cache import cache <EOL> from django . core . urlresolvers import reverse <EOL> from django . http import HttpRequest <EOL> from django . template . context import Context <EOL> from django . template import Template <EOL> from django . test import override_settings <EOL> from . base import TreeNavTestCase as TestCase <EOL> from treenav . context_processors import treenav_active <EOL> from treenav . models import MenuItem , Item <EOL> from treenav . forms import MenuItemForm <EOL> from treenav . tests import Team <EOL> @ override_settings ( ROOT_URLCONF = '<STR_LIT>' ) <EOL> class TreeNavTestCase ( TestCase ) : <EOL> def setUp ( self ) : <EOL> self . root = self . create_menu_item ( ** { <EOL> '<STR_LIT:label>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> } ) <EOL> self . create_menu_item ( ** { <EOL> '<STR_LIT>' : self . root , <EOL> '<STR_LIT:label>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:4> , <EOL> } ) <EOL> self . create_menu_item ( ** { <EOL> '<STR_LIT>' : self . root , <EOL> '<STR_LIT:label>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> } ) <EOL> self . child = self . create_menu_item ( ** { <EOL> '<STR_LIT>' : self . root , <EOL> '<STR_LIT:label>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:9> , <EOL> } ) <EOL> self . second_level = self . create_menu_item ( ** { <EOL> '<STR_LIT>' : self . child , <EOL> '<STR_LIT:label>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> } ) <EOL> self . third_level = self . create_menu_item ( ** { <EOL> '<STR_LIT>' : self . second_level , <EOL> '<STR_LIT:label>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> } ) <EOL> def test_treenav_active ( self ) : <EOL> request = HttpRequest ( ) <EOL> request . META [ '<STR_LIT>' ] = '<STR_LIT:/>' <EOL> treenav_active ( request ) <EOL> def test_to_tree ( self ) : <EOL> self . root . to_tree ( ) <EOL> def compile_string ( self , url , template_str ) : <EOL> return Template ( template_str ) . render ( Context ( ) ) <EOL> def test_non_unique_form_save ( self ) : <EOL> dup = MenuItemForm ( { <EOL> '<STR_LIT:label>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> } ) <EOL> self . assertFalse ( dup . is_valid ( ) , '<STR_LIT>' ) <EOL> def test_single_level_menu_root ( self ) : <EOL> template_str = \"\"\"<STR_LIT>\"\"\" <EOL> result = self . compile_string ( \"<STR_LIT:/>\" , template_str ) <EOL> self . assertNotIn ( self . second_level . label , result ) <EOL> def test_single_level_menu_about_us ( self ) : <EOL> template_str = \"\"\"<STR_LIT>\"\"\" <EOL> result = self . compile_string ( \"<STR_LIT:/>\" , template_str ) <EOL> self . assertIn ( self . second_level . label , result ) <EOL> def test_show_treenav ( self ) : <EOL> template_str = \"\"\"<STR_LIT>\"\"\" <EOL> result = self . compile_string ( \"<STR_LIT:/>\" , template_str ) <EOL> self . assertNotIn ( self . second_level . label , result ) <EOL> def test_single_level_menu_show_treenav_equality ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> template_str = \"\"\"<STR_LIT>\"\"\" <EOL> single_level_menu_result = self . compile_string ( \"<STR_LIT:/>\" , template_str ) <EOL>", "answer": "template_str = \"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from django . contrib import admin <EOL> from guardian . admin import GuardedModelAdmin <EOL> from . import models <EOL>", "answer": "class StackAdmin ( GuardedModelAdmin ) :"}, {"prompt": "<s> import unittest <EOL> from stix . core import STIXPackage <EOL> from stix . test import EntityTestCase , TypedListTestCase , assert_warnings <EOL> from stix . test import data_marking_test <EOL> from stix . test . common import ( <EOL> confidence_test , information_source_test , related_test , identity_test <EOL> ) <EOL> import stix . threat_actor as ta <EOL> class TypesTests ( TypedListTestCase , unittest . TestCase ) : <EOL> klass = ta . _Types <EOL> _full_dict = [ <EOL> { <EOL> '<STR_LIT:value>' : { <EOL> \"<STR_LIT:value>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> } , <EOL> ] <EOL> class MotivationsTests ( TypedListTestCase , unittest . TestCase ) : <EOL> klass = ta . _Motivations <EOL> _full_dict = [ <EOL> { <EOL> '<STR_LIT:value>' : { <EOL> \"<STR_LIT:value>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> } , <EOL> ] <EOL> class SophisticationTests ( TypedListTestCase , unittest . TestCase ) : <EOL> klass = ta . _Sophistications <EOL> _full_dict = [ <EOL> { <EOL> '<STR_LIT:value>' : { <EOL> \"<STR_LIT:value>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> } , <EOL> ] <EOL> class IntendedEffectsTests ( TypedListTestCase , unittest . TestCase ) : <EOL> klass = ta . _IntendedEffects <EOL> _full_dict = [ <EOL> { <EOL> '<STR_LIT:value>' : { <EOL>", "answer": "\"<STR_LIT:value>\" : \"<STR_LIT>\" ,"}, {"prompt": "<s> from google . appengine . _internal . django . core . management import execute_manager <EOL> try : <EOL> import settings <EOL> except ImportError : <EOL> import sys <EOL> sys . stderr . write ( \"<STR_LIT>\" % __file__ ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL>", "answer": "execute_manager ( settings ) "}, {"prompt": "<s> import collections <EOL> import time <EOL> import importlib <EOL> import cProfile <EOL> class Benchmark ( object ) : <EOL> def __init__ ( self , name ) : <EOL> self . name = name <EOL> def __enter__ ( self ) : <EOL> self . start = time . time ( ) <EOL> def __exit__ ( self , ty , val , tb ) : <EOL> end = time . time ( ) <EOL> print ( \"<STR_LIT>\" <EOL> . format ( self . name , time_format ( end - self . start ) ) ) <EOL> return False <EOL> def profileit ( func ) : <EOL> def wrapper ( * args , ** kwargs ) : <EOL> datafn = func . __name__ + \"<STR_LIT>\" <EOL> prof = cProfile . Profile ( ) <EOL> retval = prof . runcall ( func , * args , ** kwargs ) <EOL> prof . dump_stats ( datafn ) <EOL> return retval <EOL> return wrapper <EOL> def time_format ( seconds ) : <EOL> if seconds <= <NUM_LIT> : <EOL> return \"<STR_LIT>\" . format ( seconds * <NUM_LIT> ) <EOL>", "answer": "if seconds <= <NUM_LIT:1.0> :"}, {"prompt": "<s> import os , socket <EOL> from ccmlib import common <EOL> from cassandra . cluster import Cluster , NoHostAvailable <EOL> from cassandra . io . asyncorereactor import AsyncoreConnection <EOL> from tests import is_monkey_patched <EOL> from tests . integration import use_cluster , remove_cluster , PROTOCOL_VERSION <EOL> if is_monkey_patched ( ) : <EOL> LibevConnection = - <NUM_LIT:1> <EOL> AsyncoreConnection = - <NUM_LIT:1> <EOL> else : <EOL> try : <EOL> from cassandra . io . libevreactor import LibevConnection <EOL> except ImportError : <EOL> LibevConnection = None <EOL> try : <EOL> import unittest2 as unittest <EOL> except ImportError : <EOL> import unittest <EOL> IPV6_CLUSTER_NAME = '<STR_LIT>' <EOL> def setup_module ( module ) : <EOL> if os . name != \"<STR_LIT>\" : <EOL> validate_host_viable ( ) <EOL> use_cluster ( IPV6_CLUSTER_NAME , [ <NUM_LIT:1> ] , ipformat = '<STR_LIT>' ) <EOL> def teardown_module ( ) : <EOL> remove_cluster ( ) <EOL> def validate_ccm_viable ( ) : <EOL> try : <EOL> common . normalize_interface ( ( '<STR_LIT>' , <NUM_LIT:0> ) ) <EOL> except : <EOL> raise unittest . SkipTest ( '<STR_LIT>' ) <EOL> def validate_host_viable ( ) : <EOL> try : <EOL> common . check_socket_available ( ( '<STR_LIT>' , <NUM_LIT> ) ) <EOL>", "answer": "except :"}, {"prompt": "<s> try : <EOL> import xml . etree . cElementTree as ET <EOL> except ImportError : <EOL> import xml . etree . ElementTree as ET <EOL> from rwb . lib . decorators import cached_property <EOL> import urllib2 <EOL> class RobotLog ( object ) : <EOL> def __init__ ( self ) : <EOL> self . path = None <EOL> self . suites = [ ] <EOL> self . statistics = None <EOL> def parse ( self , path ) : <EOL> self . path = path <EOL> self . suites = [ ] <EOL> try : <EOL> if \"<STR_LIT>\" in path : <EOL> f = urllib2 . urlopen ( path ) <EOL> else : <EOL> f = open ( path ) <EOL> except Exception , e : <EOL> raise Exception ( \"<STR_LIT>\" % str ( e ) ) <EOL> xml = ET . parse ( f ) <EOL> root = xml . getroot ( ) <EOL> if root . tag != \"<STR_LIT>\" : <EOL> raise Exception ( \"<STR_LIT>\" % root . tag ) <EOL> self . statistics = RobotStatistics ( root . find ( \"<STR_LIT>\" ) ) <EOL> for suite in root . findall ( \"<STR_LIT>\" ) : <EOL> s = RobotSuite ( suite ) <EOL> self . suites . append ( s ) <EOL> class RobotStatistics ( object ) : <EOL> def __init__ ( self , xml_object ) : <EOL> self . xml_object = xml_object <EOL> @ cached_property <EOL> def totals ( self ) : <EOL> total = self . xml_object . find ( \"<STR_LIT>\" ) <EOL> result = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : total . findall ( \"<STR_LIT>\" ) [ <NUM_LIT:0> ] . get ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : total . findall ( \"<STR_LIT>\" ) [ <NUM_LIT:0> ] . get ( \"<STR_LIT>\" ) , <EOL> } , <EOL> \"<STR_LIT:all>\" : { <EOL> \"<STR_LIT>\" : total . findall ( \"<STR_LIT>\" ) [ <NUM_LIT:1> ] . get ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : total . findall ( \"<STR_LIT>\" ) [ <NUM_LIT:1> ] . get ( \"<STR_LIT>\" ) , <EOL> } <EOL> } <EOL> return result <EOL> @ cached_property <EOL> def stats_by_suite ( self ) : <EOL> result = { } <EOL> for suite in self . xml_object . findall ( \"<STR_LIT>\" ) : <EOL> longname = tag . text . strip ( ) <EOL> result [ longname ] = { <EOL> \"<STR_LIT>\" : suite . get ( \"<STR_LIT>\" ) , <EOL>", "answer": "\"<STR_LIT>\" : suite . get ( \"<STR_LIT>\" )"}, {"prompt": "<s> from construct import * <EOL> from macho_cs import Blob <EOL> UInt32 = ULInt32 <EOL> CodeSigRef = Struct ( \"<STR_LIT>\" , <EOL> UInt32 ( '<STR_LIT>' ) , <EOL> UInt32 ( '<STR_LIT>' ) , <EOL> ) <EOL> LoadCommand = Struct ( \"<STR_LIT>\" , <EOL> Enum ( UInt32 ( \"<STR_LIT>\" ) , <EOL> LC_SEGMENT = <NUM_LIT> , <EOL> LC_SYMTAB = <NUM_LIT> , <EOL> LC_SYMSEG = <NUM_LIT> , <EOL> LC_THREAD = <NUM_LIT> , <EOL> LC_UNIXTHREAD = <NUM_LIT> , <EOL> LC_LOADFVMLIB = <NUM_LIT> , <EOL> LC_IDFVMLIB = <NUM_LIT> , <EOL> LC_IDENT = <NUM_LIT> , <EOL> LC_FVMFILE = <NUM_LIT> , <EOL> LC_PREPAGE = <NUM_LIT> , <EOL> LC_DYSYMTAB = <NUM_LIT> , <EOL> LC_LOAD_DYLIB = <NUM_LIT> , <EOL> LC_ID_DYLIB = <NUM_LIT> , <EOL> LC_LOAD_DYLINKER = <NUM_LIT> , <EOL> LC_ID_DYLINKER = <NUM_LIT> , <EOL> LC_PREBOUND_DYLIB = <NUM_LIT> , <EOL> LC_ROUTINES = <NUM_LIT> , <EOL> LC_SUB_FRAMEWORK = <NUM_LIT> , <EOL> LC_SUB_UMBRELLA = <NUM_LIT> , <EOL> LC_SUB_CLIENT = <NUM_LIT> , <EOL> LC_SUB_LIBRARY = <NUM_LIT> , <EOL> LC_TWOLEVEL_HINTS = <NUM_LIT> , <EOL> LC_PREBIND_CKSUM = <NUM_LIT> , <EOL> LC_LOAD_WEAK_DYLIB = <NUM_LIT> , <EOL> LC_SEGMENT_64 = <NUM_LIT> , <EOL> LC_ROUTINES_64 = <NUM_LIT> , <EOL> LC_UUID = <NUM_LIT> , <EOL> LC_RPATH = <NUM_LIT> , <EOL> LC_CODE_SIGNATURE = <NUM_LIT> , <EOL> LC_SEGMENT_SPLIT_INFO = <NUM_LIT> , <EOL> LC_REEXPORT_DYLIB = <NUM_LIT> , <EOL> LC_LAZY_LOAD_DYLIB = <NUM_LIT> , <EOL> LC_ENCRYPTION_INFO = <NUM_LIT> , <EOL> LC_DYLD_INFO = <NUM_LIT> , <EOL> LC_DYLD_INFO_ONLY = <NUM_LIT> , <EOL>", "answer": "LC_LOAD_UPWARD_DYLIB = <NUM_LIT> ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import unittest <EOL> from mbed_host_tests import is_host_test <EOL> from mbed_host_tests import get_host_test <EOL> from mbed_host_tests import get_plugin_caps <EOL> from mbed_host_tests import get_host_test_list <EOL> class BasicHostTestsTestCase ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> pass <EOL>", "answer": "def tearDown ( self ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from wtforms . fields import ( BooleanField , DecimalField , DateField , <EOL> DateTimeField , Field , FieldList , FloatField , FormField , HiddenField , <EOL> IntegerField , PasswordField , RadioField , SelectField , SelectMultipleField , <EOL> SubmitField , TextField , TextAreaField ) <EOL> from tipfyext . wtforms import widgets <EOL> from tipfyext . wtforms import validators <EOL> class CsrfTokenField ( HiddenField ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( CsrfTokenField , self ) . __init__ ( * args , ** kwargs ) <EOL> self . csrf_token = None <EOL> self . type = '<STR_LIT>' <EOL> def process_formdata ( self , valuelist ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if valuelist : <EOL> self . csrf_token = valuelist [ <NUM_LIT:0> ] <EOL> class FileField ( TextField ) : <EOL> widget = widgets . FileInput ( ) <EOL>", "answer": "def process_formdata ( self , valuelist ) :"}, {"prompt": "<s> from . transformer import TransformerObj <EOL> from . mean_centering import MeanCenterer <EOL>", "answer": "from . shuffle import shuffle_arrays_unison"}, {"prompt": "<s> import Tkinter as tk <EOL> def foo ( * args ) : <EOL> print \"<STR_LIT>\" , args <EOL> import sys ; sys . stdout . flush ( ) <EOL> def __extend__ ( app ) : <EOL>", "answer": "extension = KeywordExtension ( app )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __version__ = '<STR_LIT>' <EOL> __author__ = '<STR_LIT>' <EOL> __copyright__ = '<STR_LIT>' <EOL> __licence__ = '<STR_LIT>' <EOL>", "answer": "default_app_config = '<STR_LIT>' "}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import numpy <EOL> class TaggedList ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , initlist = [ ] ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . values = [ ] <EOL> self . keys = [ ] <EOL> for idx , item in enumerate ( initlist ) : <EOL> try : <EOL> key , value = item <EOL> key = None if key == '<STR_LIT>' else key <EOL> except ( TypeError , ValueError ) : <EOL> value = item <EOL> key = None <EOL> finally : <EOL> self . values . append ( value ) <EOL> self . keys . append ( key ) <EOL> def astuples ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return list ( zip ( self . keys , self . values ) ) <EOL> def __repr__ ( self ) : <EOL> data = [ \"<STR_LIT>\" % ( key , repr ( value ) ) if key else \"<STR_LIT>\" % value <EOL> for key , value in self . astuples ( ) ] <EOL> return '<STR_LIT>' % '<STR_LIT:U+002CU+0020>' . join ( data ) <EOL> __hash__ = None <EOL> def __eq__ ( self , other ) : <EOL> if not isinstance ( other , self . __class__ ) : <EOL> return False <EOL> return self . __dict__ == other . __dict__ <EOL> def __ne__ ( self , other ) : <EOL> return not self . __eq__ ( other ) <EOL> def __contains__ ( self , item ) : <EOL> return item in self . values <EOL> def __len__ ( self ) : <EOL> return len ( self . values ) <EOL> def __getitem__ ( self , i ) : <EOL> if type ( i ) == str : <EOL> i = self . keys . index ( i ) <EOL> return self . values [ i ] <EOL> def __setitem__ ( self , i , item ) : <EOL> if type ( i ) == str : <EOL> i = self . keys . index [ i ] <EOL> self . values [ i ] = item <EOL> def __delitem__ ( self , i ) : <EOL> if type ( i ) == str : <EOL> i = self . keys . index [ i ] <EOL> del self . keys [ i ] <EOL> del self . values [ i ] <EOL> def __getslice__ ( self , i , j ) : <EOL> i = max ( i , <NUM_LIT:0> ) <EOL> j = max ( j , <NUM_LIT:0> ) <EOL> return self . __class__ ( self . astuples ( ) [ i : j ] ) <EOL> def __delslice__ ( self , i , j ) : <EOL> raise NotImplementedError ( ) <EOL> def __add__ ( self , other ) : <EOL> raise NotImplementedError ( ) <EOL> def __radd__ ( self , other ) : <EOL> raise NotImplementedError ( ) <EOL> def __iadd__ ( self , other ) : <EOL> raise NotImplementedError ( ) <EOL> def __mul__ ( self , n ) : <EOL> raise NotImplementedError ( ) <EOL> __rmul__ = __mul__ <EOL> def __imul__ ( self , n ) : <EOL> raise NotImplementedError ( ) <EOL> def append ( self , * value , ** key_and_value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( value ) == <NUM_LIT:1> and not key_and_value : <EOL> key = None <EOL> value = value [ <NUM_LIT:0> ] <EOL>", "answer": "elif len ( key_and_value ) == <NUM_LIT:1> and not value :"}, {"prompt": "<s> import re <EOL> def add_role ( var , role ) : <EOL> r\"\"\"<STR_LIT>\"\"\" <EOL> roles = getattr ( var . tag , '<STR_LIT>' , [ ] ) <EOL> roles = [ old_role for old_role in roles <EOL> if not isinstance ( role , old_role . __class__ ) ] <EOL> if not any ( isinstance ( old_role , role . __class__ ) for old_role in roles ) : <EOL> roles += [ role ] <EOL> var . tag . roles = roles <EOL> def has_roles ( var , roles , match_all = False ) : <EOL> r\"\"\"<STR_LIT>\"\"\" <EOL> var_roles = getattr ( var . tag , '<STR_LIT>' , [ ] ) <EOL> matches = ( any ( isinstance ( var_role , role . __class__ ) for <EOL> var_role in var_roles ) for role in roles ) <EOL> return all ( matches ) if match_all else any ( matches ) <EOL> class VariableRole ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __eq__ ( self , other ) : <EOL> return self . __class__ == other . __class__ <EOL> def __repr__ ( self ) : <EOL> return re . sub ( r'<STR_LIT>' , r'<STR_LIT>' , <EOL> self . __class__ . __name__ [ : - <NUM_LIT:4> ] ) . upper ( ) <EOL> class InputRole ( VariableRole ) : <EOL> pass <EOL> INPUT = InputRole ( ) <EOL> class OutputRole ( VariableRole ) : <EOL> pass <EOL> OUTPUT = OutputRole ( ) <EOL> class CostRole ( VariableRole ) : <EOL> pass <EOL> COST = CostRole ( ) <EOL> class PersistentRole ( VariableRole ) : <EOL> pass <EOL> PERSISTENT = PersistentRole ( ) <EOL> class ParameterRole ( PersistentRole ) : <EOL> pass <EOL> PARAMETER = ParameterRole ( ) <EOL> class AuxiliaryRole ( VariableRole ) : <EOL> pass <EOL> AUXILIARY = AuxiliaryRole ( ) <EOL> class WeightRole ( ParameterRole ) : <EOL> pass <EOL> WEIGHT = WeightRole ( ) <EOL> class BiasRole ( ParameterRole ) : <EOL> pass <EOL> BIAS = BiasRole ( ) <EOL> class InitialStateRole ( ParameterRole ) : <EOL> pass <EOL> INITIAL_STATE = InitialStateRole ( ) <EOL> class FilterRole ( WeightRole ) : <EOL> pass <EOL> FILTER = FilterRole ( ) <EOL> class DropoutRole ( VariableRole ) : <EOL> pass <EOL> DROPOUT = DropoutRole ( ) <EOL> class CollectedRole ( VariableRole ) : <EOL> pass <EOL> COLLECTED = CollectedRole ( ) <EOL> class CollectorRole ( ParameterRole ) : <EOL>", "answer": "pass"}, {"prompt": "<s> from assertpy import assert_that , fail <EOL> class TestType ( object ) : <EOL> def test_is_type_of ( self ) : <EOL> assert_that ( '<STR_LIT:foo>' ) . is_type_of ( str ) <EOL> assert_that ( <NUM_LIT> ) . is_type_of ( int ) <EOL> assert_that ( <NUM_LIT> ) . is_type_of ( float ) <EOL> assert_that ( [ '<STR_LIT:a>' , '<STR_LIT:b>' ] ) . is_type_of ( list ) <EOL> assert_that ( ( '<STR_LIT:a>' , '<STR_LIT:b>' ) ) . is_type_of ( tuple ) <EOL> assert_that ( { '<STR_LIT:a>' : <NUM_LIT:1> , '<STR_LIT:b>' : <NUM_LIT:2> } ) . is_type_of ( dict ) <EOL> assert_that ( set ( [ '<STR_LIT:a>' , '<STR_LIT:b>' ] ) ) . is_type_of ( set ) <EOL> assert_that ( None ) . is_type_of ( type ( None ) ) <EOL> assert_that ( Foo ( ) ) . is_type_of ( Foo ) <EOL> assert_that ( Bar ( ) ) . is_type_of ( Bar ) <EOL> def test_is_type_of_failure ( self ) : <EOL> try : <EOL> assert_that ( '<STR_LIT:foo>' ) . is_type_of ( int ) <EOL> fail ( '<STR_LIT>' ) <EOL> except AssertionError as ex : <EOL> assert_that ( str ( ex ) ) . is_equal_to ( '<STR_LIT>' ) <EOL> def test_is_type_of_bad_arg_failure ( self ) : <EOL> try : <EOL> assert_that ( '<STR_LIT:foo>' ) . is_type_of ( '<STR_LIT>' ) <EOL> fail ( '<STR_LIT>' ) <EOL> except TypeError as ex : <EOL> assert_that ( str ( ex ) ) . is_equal_to ( '<STR_LIT>' ) <EOL> def test_is_type_of_subclass_failure ( self ) : <EOL> try : <EOL> assert_that ( Bar ( ) ) . is_type_of ( Foo ) <EOL> fail ( '<STR_LIT>' ) <EOL>", "answer": "except AssertionError as ex :"}, {"prompt": "<s> __all__ = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' <EOL> ] <EOL> import threading <EOL> import sys <EOL> import weakref <EOL> from multiprocessing . dummy . connection import Pipe <EOL> from threading import Lock , RLock , Semaphore , BoundedSemaphore <EOL> from threading import Event , Condition , Barrier <EOL> from queue import Queue <EOL> class DummyProcess ( threading . Thread ) : <EOL> def __init__ ( self , group = None , target = None , name = None , args = ( ) , kwargs = { } ) : <EOL> threading . Thread . __init__ ( self , group , target , name , args , kwargs ) <EOL> self . _pid = None <EOL> self . _children = weakref . WeakKeyDictionary ( ) <EOL> self . _start_called = False <EOL> self . _parent = current_process ( ) <EOL> def start ( self ) : <EOL> assert self . _parent is current_process ( ) <EOL> self . _start_called = True <EOL> if hasattr ( self . _parent , '<STR_LIT>' ) : <EOL> self . _parent . _children [ self ] = None <EOL> threading . Thread . start ( self ) <EOL> @ property <EOL> def exitcode ( self ) : <EOL> if self . _start_called and not self . is_alive ( ) : <EOL> return <NUM_LIT:0> <EOL> else : <EOL>", "answer": "return None"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> import datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . alter_column ( '<STR_LIT>' , '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT> ) ) <EOL> def backwards ( self , orm ) : <EOL> db . alter_column ( '<STR_LIT>' , '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT> ) ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:password>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:username>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:user>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:None>' , '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:description>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:None>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:None>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:None>' , '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:None>' , '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:4>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:filename>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:size>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT:title>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:filename>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:size>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT:title>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:message>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:None>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:type>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:url>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:None>' , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:filename>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:size>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT:title>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:None>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:user>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:None>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:None>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:user>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:end>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL>", "answer": "'<STR_LIT:message>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import unittest <EOL> from kameleon_mcmc . tools . ConvergenceStats import ConvergenceStats <EOL> import numpy as np <EOL> class ConvergenceStatsUnitTest ( unittest . TestCase ) : <EOL>", "answer": "def test_wrong_input_type_x ( self ) :"}, {"prompt": "<s> from . driver import Driver <EOL> from . query import Query <EOL>", "answer": "from . utils import Config"}, {"prompt": "<s> import hashlib <EOL> import datetime <EOL> from random import random <EOL> from django . conf import settings <EOL> from django . core . urlresolvers import reverse <EOL> from django . db import models <EOL> from django . db . models import signals <EOL> from django . template . loader import render_to_string <EOL> from django . contrib . sites . models import Site <EOL> from django . contrib . auth . models import User <EOL> if \"<STR_LIT>\" in settings . INSTALLED_APPS : <EOL> from mailer import send_mail <EOL> else : <EOL> from django . core . mail import send_mail <EOL> if \"<STR_LIT>\" in settings . INSTALLED_APPS : <EOL> from notification import models as notification <EOL> else : <EOL> notification = None <EOL> if \"<STR_LIT>\" in settings . INSTALLED_APPS : <EOL> from emailconfirmation . models import EmailAddress <EOL> else : <EOL> EmailAddress = None <EOL> class Contact ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> user = models . ForeignKey ( User , related_name = \"<STR_LIT>\" ) <EOL>", "answer": "name = models . CharField ( max_length = <NUM_LIT:100> , null = True , blank = True )"}, {"prompt": "<s> import sys <EOL> from pubnub import PubnubTwisted as Pubnub <EOL> publish_key = len ( sys . argv ) > <NUM_LIT:1> and sys . argv [ <NUM_LIT:1> ] or '<STR_LIT>' <EOL> subscribe_key = len ( sys . argv ) > <NUM_LIT:2> and sys . argv [ <NUM_LIT:2> ] or '<STR_LIT>' <EOL> secret_key = len ( sys . argv ) > <NUM_LIT:3> and sys . argv [ <NUM_LIT:3> ] or '<STR_LIT>' <EOL> cipher_key = len ( sys . argv ) > <NUM_LIT:4> and sys . argv [ <NUM_LIT:4> ] or '<STR_LIT>' <EOL> ssl_on = len ( sys . argv ) > <NUM_LIT:5> and bool ( sys . argv [ <NUM_LIT:5> ] ) or False <EOL> pubnub = Pubnub ( publish_key = publish_key , subscribe_key = subscribe_key , <EOL> secret_key = secret_key , cipher_key = cipher_key , ssl_on = ssl_on ) <EOL>", "answer": "channel = '<STR_LIT>'"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . conf import settings <EOL> from django . core . exceptions import ImproperlyConfigured <EOL> from django . utils . importlib import import_module <EOL> from django . core . mail . utils import CachedDnsName , DNS_NAME <EOL> from django . core . mail . message import ( <EOL> EmailMessage , EmailMultiAlternatives , <EOL> SafeMIMEText , SafeMIMEMultipart , <EOL> DEFAULT_ATTACHMENT_MIME_TYPE , make_msgid , <EOL> BadHeaderError , forbid_multi_line_headers ) <EOL> def get_connection ( backend = None , fail_silently = False , ** kwds ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "path = backend or settings . EMAIL_BACKEND"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from sqlalchemy import Table <EOL> from elixir import * <EOL> import elixir <EOL> def setup ( ) : <EOL> metadata . bind = '<STR_LIT>' <EOL> def teardown ( ) : <EOL> cleanup_all ( ) <EOL> class TestCollections ( object ) : <EOL> def teardown ( self ) : <EOL> cleanup_all ( ) <EOL> def test_no_collection ( self ) : <EOL> class Person ( Entity ) : <EOL> name = Field ( String ( <NUM_LIT:30> ) ) <EOL> using_options ( tablename = '<STR_LIT>' , collection = None ) <EOL> assert not elixir . entities <EOL> setup_entities ( [ Person ] ) <EOL> assert isinstance ( metadata . tables [ '<STR_LIT>' ] , Table ) <EOL> def test_several_collections ( self ) : <EOL> collection1 = EntityCollection ( ) <EOL> collection2 = EntityCollection ( ) <EOL> class A ( Entity ) : <EOL> name = Field ( String ( <NUM_LIT:30> ) ) <EOL> using_options ( collection = collection1 , tablename = '<STR_LIT:a>' ) <EOL> class B ( Entity ) : <EOL> name = Field ( String ( <NUM_LIT:30> ) ) <EOL> using_options ( collection = collection2 , tablename = '<STR_LIT:b>' ) <EOL> assert A not in elixir . entities <EOL> assert B not in elixir . entities <EOL> assert A in collection1 <EOL> assert B in collection2 <EOL> setup_entities ( collection1 ) <EOL> setup_entities ( collection2 ) <EOL> assert isinstance ( metadata . tables [ '<STR_LIT:a>' ] , Table ) <EOL> assert isinstance ( metadata . tables [ '<STR_LIT:b>' ] , Table ) <EOL> def test_getattr ( self ) : <EOL> collection = EntityCollection ( ) <EOL> class A ( Entity ) : <EOL> name = Field ( String ( <NUM_LIT:30> ) ) <EOL> using_options ( collection = collection ) <EOL> assert collection . A == A <EOL> def test_setup_after_cleanup ( self ) : <EOL> class A ( Entity ) : <EOL>", "answer": "name = Field ( String ( <NUM_LIT:30> ) )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> VERSION = ( <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:0> , '<STR_LIT:f>' , <NUM_LIT:0> ) <EOL> def get_version ( ) : <EOL> version = '<STR_LIT>' % ( VERSION [ <NUM_LIT:0> ] , VERSION [ <NUM_LIT:1> ] ) <EOL> if VERSION [ <NUM_LIT:2> ] : <EOL> version = '<STR_LIT>' % ( version , VERSION [ <NUM_LIT:2> ] ) <EOL> if VERSION [ <NUM_LIT:3> ] != '<STR_LIT:f>' : <EOL>", "answer": "version = '<STR_LIT>' % ( version , VERSION [ <NUM_LIT:3> ] , VERSION [ <NUM_LIT:4> ] )"}, {"prompt": "<s> from __future__ import print_function <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> from datasets import ParityDataSet <EOL> from pybrain . supervised . trainers . backprop import BackpropTrainer <EOL> from pybrain . structure import RecurrentNetwork , LinearLayer , TanhLayer , BiasUnit , FullConnection <EOL> def buildParityNet ( ) : <EOL> net = RecurrentNetwork ( ) <EOL> net . addInputModule ( LinearLayer ( <NUM_LIT:1> , name = '<STR_LIT:i>' ) ) <EOL> net . addModule ( TanhLayer ( <NUM_LIT:2> , name = '<STR_LIT:h>' ) ) <EOL> net . addModule ( BiasUnit ( '<STR_LIT>' ) ) <EOL> net . addOutputModule ( TanhLayer ( <NUM_LIT:1> , name = '<STR_LIT:o>' ) ) <EOL> net . addConnection ( FullConnection ( net [ '<STR_LIT:i>' ] , net [ '<STR_LIT:h>' ] ) ) <EOL>", "answer": "net . addConnection ( FullConnection ( net [ '<STR_LIT>' ] , net [ '<STR_LIT:h>' ] ) )"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import grovepi <EOL>", "answer": "try :"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from __future__ import absolute_import <EOL> import logging <EOL> log = logging . getLogger ( __name__ ) <EOL> __virtualname__ = '<STR_LIT>' <EOL> def __virtual__ ( ) : <EOL> '''<STR_LIT>''' <EOL> if '<STR_LIT>' in __salt__ : <EOL> return __virtualname__ <EOL> else : <EOL> return False <EOL> def validate ( config ) : <EOL> '''<STR_LIT>''' <EOL> if not isinstance ( config , dict ) : <EOL> return False , ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' not in config : <EOL> return False , ( '<STR_LIT>' ) <EOL> return True , '<STR_LIT>' <EOL> def beacon ( config ) : <EOL> '''<STR_LIT>''' <EOL> log . debug ( '<STR_LIT>' ) <EOL>", "answer": "ret = [ ]"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = <NUM_LIT:8> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> from . . surveyor import Surveyor <EOL> from . import Explorer <EOL> import logging <EOL> l = logging . getLogger ( \"<STR_LIT>\" ) <EOL> class Escaper ( Surveyor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , project , loop_addresses , start = None , max_concurrency = None , max_active = None , pickle_paths = None , <EOL> loop_iterations = <NUM_LIT:0> , iteration_depth = <NUM_LIT:100> , unconstrain_memory = True , unconstrain_registers = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Surveyor . __init__ ( self , project , start = start , max_concurrency = max_concurrency , max_active = max_active , <EOL> pickle_paths = pickle_paths ) <EOL> self . _loop_addresses = loop_addresses <EOL> self . _loop_iterations = loop_iterations <EOL> self . _iteration_depth = iteration_depth <EOL> self . _current_iteration = <NUM_LIT:0> <EOL> self . _done = False <EOL> self . _unconstrain_memory = unconstrain_memory <EOL> self . _unconstrain_registers = unconstrain_registers <EOL> self . normal = [ ] <EOL> self . forced = [ ] <EOL> def _tick_loop ( self , start = None ) : <EOL> results = Explorer ( self . _project , start = start , find = self . _loop_addresses [ <NUM_LIT:0> ] , restrict = self . _loop_addresses , <EOL> min_depth = <NUM_LIT:2> , max_depth = self . _iteration_depth , max_repeats = <NUM_LIT:1> , <EOL> max_concurrency = self . _max_concurrency , num_find = self . _num_find ) . run ( ) <EOL> self . deadended += results . deadended <EOL> return results <EOL> def unconstrain_loop ( self , constrained_entry ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> constrained_state = constrained_entry . state . copy ( ) <EOL> constrained_results = self . _tick_loop ( start = constrained_entry ) <EOL> l . debug ( \"<STR_LIT>\" , len ( constrained_results . found ) ) <EOL> unconstrained_states = [ ] <EOL> for p in constrained_results . found : <EOL> new_state = p . state . copy ( ) <EOL> if self . _unconstrain_registers : <EOL> new_state . registers . unconstrain_differences ( constrained_state . registers ) <EOL> if self . _unconstrain_memory : <EOL> new_state . memory . unconstrain_differences ( constrained_state . memory ) <EOL> unconstrained_states . append ( new_state ) <EOL> l . debug ( \"<STR_LIT>\" , len ( unconstrained_states ) ) <EOL> unconstrained_exits = [ ] <EOL> unconstrained_entry = constrained_entry <EOL> for s in unconstrained_states : <EOL> unconstrained_entry . state = s <EOL> unconstrained_results = self . _tick_loop ( start = unconstrained_entry ) <EOL>", "answer": "unconstrained_exits += unconstrained_results . deviating"}, {"prompt": "<s> _cvsid = '<STR_LIT>' <EOL> import re <EOL> import sys <EOL> import copy <EOL> import random <EOL> import struct <EOL> if sys . version_info [ <NUM_LIT:0> ] >= <NUM_LIT:3> : <EOL> import pickle <EOL> else : <EOL> if sys . version_info < ( <NUM_LIT:2> , <NUM_LIT:6> ) : <EOL> import cPickle as pickle <EOL> else : <EOL> import warnings <EOL> w = warnings . catch_warnings ( ) <EOL> w . __enter__ ( ) <EOL> try : <EOL> warnings . filterwarnings ( '<STR_LIT:ignore>' , <EOL> message = '<STR_LIT>' , <EOL> category = DeprecationWarning ) <EOL> import cPickle as pickle <EOL> finally : <EOL> w . __exit__ ( ) <EOL> del w <EOL> try : <EOL> from bsddb3 import db <EOL> except ImportError : <EOL> from bsddb import db <EOL> class TableDBError ( StandardError ) : <EOL> pass <EOL> class TableAlreadyExists ( TableDBError ) : <EOL> pass <EOL> class Cond : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __call__ ( self , s ) : <EOL> return <NUM_LIT:1> <EOL> class ExactCond ( Cond ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , strtomatch ) : <EOL> self . strtomatch = strtomatch <EOL> def __call__ ( self , s ) : <EOL> return s == self . strtomatch <EOL> class PrefixCond ( Cond ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , prefix ) : <EOL> self . prefix = prefix <EOL> def __call__ ( self , s ) : <EOL> return s [ : len ( self . prefix ) ] == self . prefix <EOL> class PostfixCond ( Cond ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , postfix ) : <EOL> self . postfix = postfix <EOL> def __call__ ( self , s ) : <EOL> return s [ - len ( self . postfix ) : ] == self . postfix <EOL> class LikeCond ( Cond ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , likestr , re_flags = re . IGNORECASE ) : <EOL> chars_to_escape = '<STR_LIT>' <EOL> for char in chars_to_escape : <EOL> likestr = likestr . replace ( char , '<STR_LIT:\\\\>' + char ) <EOL> self . likestr = likestr . replace ( '<STR_LIT:%>' , '<STR_LIT>' ) <EOL> self . re = re . compile ( '<STR_LIT>' + self . likestr + '<STR_LIT:$>' , re_flags ) <EOL> def __call__ ( self , s ) : <EOL> return self . re . match ( s ) <EOL> _table_names_key = '<STR_LIT>' <EOL> _columns = '<STR_LIT>' <EOL> def _columns_key ( table ) : <EOL> return table + _columns <EOL> _data = '<STR_LIT>' <EOL> _rowid = '<STR_LIT>' <EOL> _rowid_str_len = <NUM_LIT:8> <EOL> def _data_key ( table , col , rowid ) : <EOL> return table + _data + col + _data + rowid <EOL> def _search_col_data_key ( table , col ) : <EOL> return table + _data + col + _data <EOL> def _search_all_data_key ( table ) : <EOL> return table + _data <EOL> def _rowid_key ( table , rowid ) : <EOL> return table + _rowid + rowid + _rowid <EOL> def _search_rowid_key ( table ) : <EOL> return table + _rowid <EOL> def contains_metastrings ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ( s . find ( _table_names_key ) >= <NUM_LIT:0> or <EOL> s . find ( _columns ) >= <NUM_LIT:0> or <EOL> s . find ( _data ) >= <NUM_LIT:0> or <EOL> s . find ( _rowid ) >= <NUM_LIT:0> ) : <EOL> return <NUM_LIT:1> <EOL> else : <EOL> return <NUM_LIT:0> <EOL> class bsdTableDB : <EOL> def __init__ ( self , filename , dbhome , create = <NUM_LIT:0> , truncate = <NUM_LIT:0> , mode = <NUM_LIT:0> <NUM_LIT> , <EOL> recover = <NUM_LIT:0> , dbflags = <NUM_LIT:0> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . db = None <EOL> myflags = db . DB_THREAD <EOL> if create : <EOL> myflags |= db . DB_CREATE <EOL> flagsforenv = ( db . DB_INIT_MPOOL | db . DB_INIT_LOCK | db . DB_INIT_LOG | <EOL> db . DB_INIT_TXN | dbflags ) <EOL> try : <EOL> dbflags |= db . DB_AUTO_COMMIT <EOL> except AttributeError : <EOL> pass <EOL> if recover : <EOL> flagsforenv = flagsforenv | db . DB_RECOVER <EOL> self . env = db . DBEnv ( ) <EOL> self . env . set_lk_detect ( db . DB_LOCK_DEFAULT ) <EOL> self . env . open ( dbhome , myflags | flagsforenv ) <EOL> if truncate : <EOL> myflags |= db . DB_TRUNCATE <EOL> self . db = db . DB ( self . env ) <EOL> self . db . set_get_returns_none ( <NUM_LIT:1> ) <EOL> self . db . set_flags ( db . DB_DUP ) <EOL> self . db . open ( filename , db . DB_BTREE , dbflags | myflags , mode ) <EOL> self . dbfilename = filename <EOL> if sys . version_info [ <NUM_LIT:0> ] >= <NUM_LIT:3> : <EOL> class cursor_py3k ( object ) : <EOL> def __init__ ( self , dbcursor ) : <EOL> self . _dbcursor = dbcursor <EOL> def close ( self ) : <EOL> return self . _dbcursor . close ( ) <EOL> def set_range ( self , search ) : <EOL> v = self . _dbcursor . set_range ( bytes ( search , \"<STR_LIT>\" ) ) <EOL> if v is not None : <EOL> v = ( v [ <NUM_LIT:0> ] . decode ( \"<STR_LIT>\" ) , <EOL> v [ <NUM_LIT:1> ] . decode ( \"<STR_LIT>\" ) ) <EOL> return v <EOL> def __next__ ( self ) : <EOL> v = getattr ( self . _dbcursor , \"<STR_LIT>\" ) ( ) <EOL> if v is not None : <EOL> v = ( v [ <NUM_LIT:0> ] . decode ( \"<STR_LIT>\" ) , <EOL> v [ <NUM_LIT:1> ] . decode ( \"<STR_LIT>\" ) ) <EOL> return v <EOL> class db_py3k ( object ) : <EOL> def __init__ ( self , db ) : <EOL> self . _db = db <EOL> def cursor ( self , txn = None ) : <EOL> return cursor_py3k ( self . _db . cursor ( txn = txn ) ) <EOL> def has_key ( self , key , txn = None ) : <EOL> return getattr ( self . _db , \"<STR_LIT>\" ) ( bytes ( key , \"<STR_LIT>\" ) , <EOL> txn = txn ) <EOL> def put ( self , key , value , flags = <NUM_LIT:0> , txn = None ) : <EOL> key = bytes ( key , \"<STR_LIT>\" ) <EOL> if value is not None : <EOL> value = bytes ( value , \"<STR_LIT>\" ) <EOL> return self . _db . put ( key , value , flags = flags , txn = txn ) <EOL> def put_bytes ( self , key , value , txn = None ) : <EOL> key = bytes ( key , \"<STR_LIT>\" ) <EOL> return self . _db . put ( key , value , txn = txn ) <EOL> def get ( self , key , txn = None , flags = <NUM_LIT:0> ) : <EOL> key = bytes ( key , \"<STR_LIT>\" ) <EOL> v = self . _db . get ( key , txn = txn , flags = flags ) <EOL> if v is not None : <EOL> v = v . decode ( \"<STR_LIT>\" ) <EOL> return v <EOL> def get_bytes ( self , key , txn = None , flags = <NUM_LIT:0> ) : <EOL> key = bytes ( key , \"<STR_LIT>\" ) <EOL> return self . _db . get ( key , txn = txn , flags = flags ) <EOL>", "answer": "def delete ( self , key , txn = None ) :"}, {"prompt": "<s> from __future__ import with_statement <EOL> from codecs import open <EOL> from os import path <EOL> here = path . abspath ( path . dirname ( __file__ ) ) <EOL> with open ( path . join ( here , '<STR_LIT>' ) , encoding = '<STR_LIT:utf-8>' ) as f : <EOL>", "answer": "__version__ = f . read ( ) "}, {"prompt": "<s> import constants <EOL> Latin5_BulgarianCharToOrderMap = ( <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT> , <NUM_LIT:255> , <NUM_LIT:255> , <EOL> <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:100> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:200> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:200> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT:32> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:30> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:50> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:20> , <NUM_LIT:11> , <NUM_LIT:3> , <NUM_LIT> , <NUM_LIT:15> , <NUM_LIT:2> , <NUM_LIT> , <NUM_LIT:12> , <NUM_LIT:10> , <NUM_LIT> , <NUM_LIT:6> , <NUM_LIT:4> , <NUM_LIT> , <EOL> <NUM_LIT:7> , <NUM_LIT:8> , <NUM_LIT:5> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:16> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> ) <EOL> win1251BulgarianCharToOrderMap = ( <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT> , <NUM_LIT:255> , <NUM_LIT:255> , <EOL> <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <NUM_LIT:255> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:100> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:200> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT:64> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT:32> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:30> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:50> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT:9> , <NUM_LIT:20> , <NUM_LIT:11> , <NUM_LIT:3> , <NUM_LIT> , <NUM_LIT:15> , <NUM_LIT:2> , <NUM_LIT> , <NUM_LIT:12> , <NUM_LIT:10> , <NUM_LIT> , <NUM_LIT:6> , <NUM_LIT:4> , <NUM_LIT> , <EOL> <NUM_LIT:7> , <NUM_LIT:8> , <NUM_LIT:5> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:16> , <EOL> ) <EOL> BulgarianLangModel = ( <NUM_LIT:0> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <EOL> <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:2> , <EOL> <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:1> , <EOL> <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <EOL> <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:0> , <EOL> <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <EOL> <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:0> , <EOL> <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <EOL> <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:0> , <EOL> <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <EOL> <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <EOL> <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <EOL> <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:0> , <EOL> <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <EOL> <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> , <EOL> <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <EOL> <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> , <EOL> <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <EOL> <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <EOL> <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <EOL> <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> , <EOL> <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <EOL>", "answer": "<NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> ,"}, {"prompt": "<s> import os . path as op <EOL> import mne <EOL> from mne . datasets import testing <EOL> from mne import read_forward_solution <EOL> from mne . minimum_norm import ( read_inverse_operator , <EOL> point_spread_function , cross_talk_function ) <EOL> from mne . utils import slow_test , run_tests_if_main <EOL> from nose . tools import assert_true <EOL> data_path = op . join ( testing . data_path ( download = False ) , '<STR_LIT>' , '<STR_LIT>' ) <EOL> fname_inv_meg = op . join ( data_path , <EOL> '<STR_LIT>' ) <EOL> fname_inv_meeg = op . join ( data_path , '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> fname_fwd = op . join ( data_path , '<STR_LIT>' ) <EOL> fname_label = [ op . join ( data_path , '<STR_LIT>' , '<STR_LIT>' ) , <EOL> op . join ( data_path , '<STR_LIT>' , '<STR_LIT>' ) ] <EOL> snr = <NUM_LIT> <EOL> lambda2 = <NUM_LIT:1.0> / snr ** <NUM_LIT:2> <EOL> @ slow_test <EOL> @ testing . requires_testing_data <EOL> def test_psf_ctf ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> forward = read_forward_solution ( fname_fwd ) <EOL> labels = [ mne . read_label ( ss ) for ss in fname_label ] <EOL> method = '<STR_LIT>' <EOL> n_svd_comp = <NUM_LIT:2> <EOL> for fname_inv in ( fname_inv_meg , fname_inv_meeg ) : <EOL> inverse_operator = read_inverse_operator ( fname_inv ) <EOL> for mode in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL>", "answer": "stc_psf , psf_ev = point_spread_function ("}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import datetime <EOL> import base64 <EOL> import hmac <EOL> import hashlib <EOL> import warnings <EOL> from werkzeug . utils import secure_filename <EOL> from werkzeug . datastructures import FileStorage <EOL> from importlib import import_module <EOL> from flask import send_file , abort , url_for , request <EOL> import shortuuid <EOL> from libcloud . storage . types import Provider , ObjectDoesNotExistError <EOL> from libcloud . storage . providers import DRIVERS , get_driver <EOL> from libcloud . storage . base import Object as BaseObject , StorageDriver <EOL> from libcloud . storage . drivers import local <EOL> from six . moves . urllib . parse import urlparse , urlunparse , urljoin , urlencode <EOL> import slugify <EOL> SERVER_ENDPOINT = \"<STR_LIT>\" <EOL> EXTENSIONS = { <EOL> \"<STR_LIT>\" : [ \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:rb>\" , \"<STR_LIT>\" ] , <EOL> \"<STR_LIT>\" : [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> } <EOL> ALL_EXTENSIONS = EXTENSIONS [ \"<STR_LIT>\" ] + EXTENSIONS [ \"<STR_LIT>\" ] + EXTENSIONS [ \"<STR_LIT>\" ] + EXTENSIONS [ \"<STR_LIT>\" ] + EXTENSIONS [ \"<STR_LIT>\" ] + EXTENSIONS [ \"<STR_LIT>\" ] <EOL> class InvalidExtensionError ( Exception ) : <EOL> pass <EOL> def get_file_name ( filename ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return os . path . basename ( filename ) <EOL> def get_file_extension ( filename ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return os . path . splitext ( filename ) [ <NUM_LIT:1> ] [ <NUM_LIT:1> : ] . lower ( ) <EOL> def get_file_extension_type ( filename ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ext = get_file_extension ( filename ) <EOL> if ext : <EOL> for name , group in EXTENSIONS . items ( ) : <EOL> if ext in group : <EOL> return name <EOL> return \"<STR_LIT>\" <EOL> def get_driver_class ( provider ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if \"<STR_LIT:.>\" in provider : <EOL> parts = provider . split ( '<STR_LIT:.>' ) <EOL> kls = parts . pop ( ) <EOL> path = '<STR_LIT:.>' . join ( parts ) <EOL> module = import_module ( path ) <EOL> if not hasattr ( module , kls ) : <EOL> raise ImportError ( '<STR_LIT>' . format ( <EOL> kls , <EOL> path ) ) <EOL> driver = getattr ( module , kls ) <EOL> else : <EOL> driver = getattr ( Provider , provider . upper ( ) ) <EOL> return get_driver ( driver ) <EOL> def get_provider_name ( driver ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> kls = driver . __class__ . __name__ <EOL> for d , prop in DRIVERS . items ( ) : <EOL> if prop [ <NUM_LIT:1> ] == kls : <EOL> return d <EOL> return None <EOL> class Storage ( object ) : <EOL> container = None <EOL> driver = None <EOL> config = { } <EOL> allowed_extensions = EXTENSIONS [ \"<STR_LIT>\" ] + EXTENSIONS [ \"<STR_LIT>\" ] + EXTENSIONS [ \"<STR_LIT>\" ] + EXTENSIONS [ \"<STR_LIT>\" ] + EXTENSIONS [ \"<STR_LIT>\" ] <EOL> def __init__ ( self , <EOL> provider = None , <EOL> key = None , <EOL> secret = None , <EOL> container = None , <EOL> allowed_extensions = None , <EOL> app = None , <EOL>", "answer": "** kwargs ) :"}, {"prompt": "<s> from . widget . userlogin . models import UserLoginWidget <EOL>", "answer": "from . widget . registration . models import UserRegistrationWidget "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import argparse <EOL> import sys <EOL> import wx <EOL> from mdf . viewer import MDFViewerFrame <EOL> from datetime import datetime <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL>", "answer": "arg_parser = argparse . ArgumentParser ( )"}, {"prompt": "<s> import urlparse <EOL> from django . conf import settings <EOL> from django . core . urlresolvers import reverse <EOL> from django . http import HttpResponseRedirect , QueryDict <EOL> from django . template . response import TemplateResponse <EOL> from django . utils . http import base36_to_int <EOL> from django . utils . translation import ugettext as _ <EOL> from django . views . decorators . debug import sensitive_post_parameters <EOL> from django . views . decorators . cache import never_cache <EOL> from django . views . decorators . csrf import csrf_protect <EOL> from django . contrib . auth import REDIRECT_FIELD_NAME , login as auth_login , logout as auth_logout <EOL> from django . contrib . auth . decorators import login_required <EOL> from django . contrib . auth . forms import AuthenticationForm , PasswordResetForm , SetPasswordForm , PasswordChangeForm <EOL> from django . contrib . auth . models import User <EOL> from django . contrib . auth . tokens import default_token_generator <EOL> from django . contrib . auth . decorators import login_required <EOL> from django . http import HttpResponse <EOL> from django . shortcuts import render_to_response <EOL> from django . template import RequestContext <EOL> from backends import logout_user <EOL> from encryption import SimplerAES <EOL> aes = SimplerAES ( settings . SECRET_KEY ) <EOL> ORIGINAL_REDIRECT_FIELD_NAME = REDIRECT_FIELD_NAME <EOL> REDIRECT_FIELD_NAME = \"<STR_LIT>\" <EOL> @ sensitive_post_parameters ( ) <EOL> @ csrf_protect <EOL> def login ( request , template_name = settings . LOGIN_TEMPLATE , <EOL> redirect_field_name = REDIRECT_FIELD_NAME , <EOL> authentication_form = AuthenticationForm , <EOL> current_app = None , extra_context = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> redirect_to = request . REQUEST . get ( redirect_field_name , '<STR_LIT>' ) <EOL> if settings . SPLUNK_WEB_INTEGRATED : <EOL> return HttpResponseRedirect ( settings . LOGIN_URL + \"<STR_LIT>\" % ( redirect_field_name , redirect_to ) ) <EOL> if not redirect_to : <EOL> redirect_to = request . REQUEST . get ( ORIGINAL_REDIRECT_FIELD_NAME , '<STR_LIT>' ) <EOL> if request . method == \"<STR_LIT:POST>\" : <EOL>", "answer": "form = authentication_form ( data = request . POST , request = request )"}, {"prompt": "<s> import ast <EOL> import datetime <EOL> import xmlrpclib <EOL> import feedparser <EOL> import calendar <EOL> import requests <EOL> from django . conf import settings <EOL> from django . contrib . contenttypes . generic import GenericForeignKey , GenericRelation <EOL> from django . contrib . contenttypes . models import ContentType <EOL> from django . db import models , connections <EOL> METRIC_PERIOD_INSTANT = '<STR_LIT>' <EOL> METRIC_PERIOD_DAILY = '<STR_LIT>' <EOL> METRIC_PERIOD_WEEKLY = '<STR_LIT>' <EOL> METRIC_PERIOD_CHOICES = ( <EOL> ( METRIC_PERIOD_INSTANT , '<STR_LIT>' ) , <EOL> ( METRIC_PERIOD_DAILY , '<STR_LIT>' ) , <EOL> ( METRIC_PERIOD_WEEKLY , '<STR_LIT>' ) , <EOL> ) <EOL> class Category ( models . Model ) : <EOL> name = models . CharField ( max_length = <NUM_LIT> ) <EOL> position = models . PositiveSmallIntegerField ( default = <NUM_LIT:1> ) <EOL> class Meta : <EOL> verbose_name_plural = '<STR_LIT>' <EOL> def __unicode__ ( self ) : <EOL> return self . name <EOL> class Metric ( models . Model ) : <EOL> name = models . CharField ( max_length = <NUM_LIT> ) <EOL> slug = models . SlugField ( ) <EOL> category = models . ForeignKey ( Category , blank = True , null = True , <EOL> on_delete = models . SET_NULL ) <EOL> position = models . PositiveSmallIntegerField ( default = <NUM_LIT:1> ) <EOL> data = GenericRelation ( '<STR_LIT>' ) <EOL> show_on_dashboard = models . BooleanField ( default = True ) <EOL> show_sparkline = models . BooleanField ( default = True ) <EOL> period = models . CharField ( max_length = <NUM_LIT:15> , choices = METRIC_PERIOD_CHOICES , <EOL> default = METRIC_PERIOD_INSTANT ) <EOL> unit = models . CharField ( max_length = <NUM_LIT:100> ) <EOL> unit_plural = models . CharField ( max_length = <NUM_LIT:100> ) <EOL> class Meta : <EOL> abstract = True <EOL> def __unicode__ ( self ) : <EOL> return self . name <EOL> @ models . permalink <EOL> def get_absolute_url ( self ) : <EOL> return ( \"<STR_LIT>\" , [ self . slug ] ) <EOL> @ property <EOL> def display_position ( self ) : <EOL> cat_position = - <NUM_LIT:1> if self . category is None else self . category . position <EOL>", "answer": "return cat_position , self . position"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> import simplejson as json <EOL> except ImportError : <EOL> import json <EOL> from bigml . resourcehandler import ResourceHandler <EOL> from bigml . resourcehandler import ( check_resource_type , resource_is_ready , <EOL> get_logistic_regression_id ) <EOL> from bigml . constants import LOGISTIC_REGRESSION_PATH <EOL> class LogisticRegressionHandler ( ResourceHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . logistic_regression_url = self . url + LOGISTIC_REGRESSION_PATH <EOL> def create_logistic_regression ( self , datasets , <EOL> args = None , wait_time = <NUM_LIT:3> , retries = <NUM_LIT:10> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> create_args = self . _set_create_from_datasets_args ( <EOL> datasets , args = args , wait_time = wait_time , retries = retries ) <EOL> body = json . dumps ( create_args ) <EOL> return self . _create ( self . logistic_regression_url , body ) <EOL> def get_logistic_regression ( self , logistic_regression , query_string = '<STR_LIT>' , <EOL> shared_username = None , shared_api_key = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> check_resource_type ( logistic_regression , LOGISTIC_REGRESSION_PATH , <EOL> message = \"<STR_LIT>\" ) <EOL> logistic_regression_id = get_logistic_regression_id ( <EOL> logistic_regression ) <EOL> if logistic_regression_id : <EOL> return self . _get ( \"<STR_LIT>\" % ( self . url , logistic_regression_id ) , <EOL> query_string = query_string , <EOL> shared_username = shared_username , <EOL> shared_api_key = shared_api_key ) <EOL> def logistic_regression_is_ready ( self , logistic_regression , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> check_resource_type ( logistic_regression , LOGISTIC_REGRESSION_PATH , <EOL> message = \"<STR_LIT>\" ) <EOL> resource = self . get_logistic_regression ( logistic_regression , ** kwargs ) <EOL>", "answer": "return resource_is_ready ( resource )"}, {"prompt": "<s> def Initialize ( ) : pass <EOL> def ReadInt ( ) : pass <EOL> def Login ( ) : pass <EOL> def Logout ( ) : pass <EOL> def UpdateInt ( ) : pass <EOL> states = { <EOL> <NUM_LIT:0> : { '<STR_LIT>' : ( <NUM_LIT:0> , <NUM_LIT:0> ) } , <EOL> <NUM_LIT:1> : { '<STR_LIT>' : ( <NUM_LIT:0> , <NUM_LIT:1> ) } , <EOL> <NUM_LIT:2> : { '<STR_LIT>' : ( <NUM_LIT:0> , <NUM_LIT:2> ) } , <EOL> <NUM_LIT:3> : { '<STR_LIT>' : ( <NUM_LIT:0> , <NUM_LIT:3> ) } , <EOL> <NUM_LIT:4> : { '<STR_LIT>' : ( <NUM_LIT:0> , <NUM_LIT:4> ) } , <EOL> <NUM_LIT:5> : { '<STR_LIT>' : ( <NUM_LIT:0> , <NUM_LIT:5> ) } , <EOL> } <EOL> initial = <NUM_LIT:0> <EOL> accepting = [ <NUM_LIT:5> ] <EOL>", "answer": "unsafe = [ ]"}, {"prompt": "<s> import os , sys , string , math <EOL> import commands <EOL> from gm_custom import * <EOL> sys . path . append ( os . path . abspath ( os . getenv ( '<STR_LIT>' ) + \"<STR_LIT>\" ) ) <EOL> if len ( sys . argv ) != <NUM_LIT:2> : <EOL> print '<STR_LIT>' + sys . argv [ <NUM_LIT:0> ] + '<STR_LIT>' <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> remote_name = sys . argv [ <NUM_LIT:1> ] <EOL> repos = get_repositories ( ) <EOL> smsg = \"<STR_LIT>\" <EOL> for repo in repos : <EOL> if repo == \"<STR_LIT>\" : <EOL> continue <EOL> rfolder = get_repository_path ( repo ) <EOL> g = generate_git_report ( repo ) <EOL> if g . isrepo == - <NUM_LIT:1> : <EOL>", "answer": "smsg += '<STR_LIT>' + repo + '<STR_LIT>'"}, {"prompt": "<s> import urlparse <EOL> from django . conf . urls import patterns , url <EOL> from django . contrib import admin <EOL> from django . contrib . admin . options import ModelAdmin <EOL> from django . core . urlresolvers import reverse <EOL> from django . http import ( HttpResponseForbidden , HttpResponseBadRequest , HttpResponseRedirect , QueryDict ) <EOL> from django . utils import timezone <EOL> from django . views . generic . base import View <EOL> from itsdangerous import URLSafeTimedSerializer <EOL> from simple_sso . sso_server . models import Token , Consumer <EOL> import datetime <EOL> import urllib <EOL> from webservices . models import Provider <EOL> from webservices . sync import provider_for_django <EOL> class BaseProvider ( Provider ) : <EOL> max_age = <NUM_LIT:5> <EOL> def __init__ ( self , server ) : <EOL> self . server = server <EOL> def get_private_key ( self , public_key ) : <EOL> try : <EOL> self . consumer = Consumer . objects . get ( public_key = public_key ) <EOL> except Consumer . DoesNotExist : <EOL> return None <EOL> return self . consumer . private_key <EOL> class RequestTokenProvider ( BaseProvider ) : <EOL> def provide ( self , data ) : <EOL> redirect_to = data [ '<STR_LIT>' ] <EOL> token = Token . objects . create ( consumer = self . consumer , redirect_to = redirect_to ) <EOL> return { '<STR_LIT>' : token . request_token } <EOL> class AuthorizeView ( View ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> server = None <EOL> def get ( self , request ) : <EOL> request_token = request . GET . get ( '<STR_LIT>' , None ) <EOL> if not request_token : <EOL> return self . missing_token_argument ( ) <EOL> try : <EOL> self . token = Token . objects . select_related ( '<STR_LIT>' ) . get ( request_token = request_token ) <EOL> except Token . DoesNotExist : <EOL> return self . token_not_found ( ) <EOL> if not self . check_token_timeout ( ) : <EOL> return self . token_timeout ( ) <EOL> self . token . refresh ( ) <EOL> if request . user . is_authenticated ( ) : <EOL> return self . handle_authenticated_user ( ) <EOL> else : <EOL> return self . handle_unauthenticated_user ( ) <EOL> def missing_token_argument ( self ) : <EOL> return HttpResponseBadRequest ( '<STR_LIT>' ) <EOL> def token_not_found ( self ) : <EOL> return HttpResponseForbidden ( '<STR_LIT>' ) <EOL> def token_timeout ( self ) : <EOL> return HttpResponseForbidden ( '<STR_LIT>' ) <EOL> def check_token_timeout ( self ) : <EOL> delta = timezone . now ( ) - self . token . timestamp <EOL> if delta > self . server . token_timeout : <EOL> self . token . delete ( ) <EOL> return False <EOL> else : <EOL> return True <EOL> def handle_authenticated_user ( self ) : <EOL> if self . server . has_access ( self . request . user , self . token . consumer ) : <EOL> return self . success ( ) <EOL> else : <EOL> return self . access_denied ( ) <EOL> def handle_unauthenticated_user ( self ) : <EOL> next = '<STR_LIT>' % ( self . request . path , urllib . urlencode ( [ ( '<STR_LIT>' , self . token . request_token ) ] ) ) <EOL> url = '<STR_LIT>' % ( reverse ( self . server . auth_view_name ) , urllib . urlencode ( [ ( '<STR_LIT>' , next ) ] ) ) <EOL> return HttpResponseRedirect ( url ) <EOL> def access_denied ( self ) : <EOL> return HttpResponseForbidden ( \"<STR_LIT>\" ) <EOL> def success ( self ) : <EOL> self . token . user = self . request . user <EOL> self . token . save ( ) <EOL> serializer = URLSafeTimedSerializer ( self . token . consumer . private_key ) <EOL> parse_result = urlparse . urlparse ( self . token . redirect_to ) <EOL> query_dict = QueryDict ( parse_result . query , mutable = True ) <EOL> query_dict [ '<STR_LIT>' ] = serializer . dumps ( self . token . access_token ) <EOL> url = urlparse . urlunparse ( ( parse_result . scheme , parse_result . netloc , parse_result . path , '<STR_LIT>' , query_dict . urlencode ( ) , '<STR_LIT>' ) ) <EOL> return HttpResponseRedirect ( url ) <EOL> class VerificationProvider ( BaseProvider , AuthorizeView ) : <EOL> def provide ( self , data ) : <EOL> token = data [ '<STR_LIT>' ] <EOL> try : <EOL> self . token = Token . objects . select_related ( '<STR_LIT:user>' ) . get ( access_token = token , consumer = self . consumer ) <EOL> except Token . DoesNotExist : <EOL> return self . token_not_found ( ) <EOL> if not self . check_token_timeout ( ) : <EOL> return self . token_timeout ( ) <EOL> if not self . token . user : <EOL> return self . token_not_bound ( ) <EOL> extra_data = data . get ( '<STR_LIT>' , None ) <EOL>", "answer": "return self . server . get_user_data ("}, {"prompt": "<s> from aws import Action , BaseARN <EOL> service_name = '<STR_LIT>' <EOL> prefix = '<STR_LIT>' <EOL> class ARN ( BaseARN ) : <EOL> def __init__ ( self , resource , region = '<STR_LIT>' , account = '<STR_LIT>' ) : <EOL> sup = super ( ARN , self ) <EOL> sup . __init__ ( service = prefix , resource = resource , region = region , <EOL> account = account ) <EOL> CancelKeyDeletion = Action ( prefix , '<STR_LIT>' ) <EOL> CreateAlias = Action ( prefix , '<STR_LIT>' ) <EOL> CreateGrant = Action ( prefix , '<STR_LIT>' ) <EOL> CreateKey = Action ( prefix , '<STR_LIT>' ) <EOL> Decrypt = Action ( prefix , '<STR_LIT>' ) <EOL> DeleteAlias = Action ( prefix , '<STR_LIT>' ) <EOL> DescribeKey = Action ( prefix , '<STR_LIT>' ) <EOL> DisableKey = Action ( prefix , '<STR_LIT>' ) <EOL> DisableKeyRotation = Action ( prefix , '<STR_LIT>' ) <EOL> EnableKey = Action ( prefix , '<STR_LIT>' ) <EOL> EnableKeyRotation = Action ( prefix , '<STR_LIT>' ) <EOL> Encrypt = Action ( prefix , '<STR_LIT>' ) <EOL> GenerateDataKey = Action ( prefix , '<STR_LIT>' ) <EOL> GenerateDataKeyWithoutPlaintext = Action ( prefix , '<STR_LIT>' ) <EOL> GenerateRandom = Action ( prefix , '<STR_LIT>' ) <EOL> GetKeyPolicy = Action ( prefix , '<STR_LIT>' ) <EOL> GetKeyRotationStatus = Action ( prefix , '<STR_LIT>' ) <EOL> ListAliases = Action ( prefix , '<STR_LIT>' ) <EOL> ListGrants = Action ( prefix , '<STR_LIT>' ) <EOL> ListKeyPolicies = Action ( prefix , '<STR_LIT>' ) <EOL> ListKeys = Action ( prefix , '<STR_LIT>' ) <EOL> ListRetirableGrants = Action ( prefix , '<STR_LIT>' ) <EOL> PutKeyPolicy = Action ( prefix , '<STR_LIT>' ) <EOL>", "answer": "ReEncrypt = Action ( prefix , '<STR_LIT>' )"}, {"prompt": "<s> from rest_framework import serializers <EOL> from ralph . api import RalphAPISerializer <EOL> from ralph . assets . api . serializers import AssetSerializer , BaseObjectSerializer <EOL> from ralph . data_center . models import ( <EOL> Accessory , <EOL> Cluster , <EOL> ClusterType , <EOL> Database , <EOL> DataCenter , <EOL> DataCenterAsset , <EOL> Rack , <EOL>", "answer": "RackAccessory ,"}, {"prompt": "<s> from __future__ import print_function , division , absolute_import , unicode_literals <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> from past . builtins import basestring <EOL> from builtins import * <EOL> import os <EOL> from socket import gethostname <EOL> import time <EOL> import urllib . request <EOL> import urllib . parse <EOL> import urllib . error <EOL> from uuid import getnode as getmac <EOL> import webbrowser <EOL> import httplib2 <EOL> from oauth2client . client import OAuth2WebServerFlow , TokenRevokeError <EOL> import oauth2client . file <EOL> import gmusicapi <EOL> from gmusicapi . clients . shared import _Base <EOL> from gmusicapi . appdirs import my_appdirs <EOL> from gmusicapi . exceptions import CallFailure , NotLoggedIn <EOL> from gmusicapi . protocol import musicmanager , upload_pb2 , locker_pb2 <EOL> from gmusicapi . utils import utils <EOL> from gmusicapi import session <EOL> OAUTH_FILEPATH = os . path . join ( my_appdirs . user_data_dir , '<STR_LIT>' ) <EOL> class Musicmanager ( _Base ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _session_class = session . Musicmanager <EOL> @ staticmethod <EOL> def perform_oauth ( storage_filepath = OAUTH_FILEPATH , open_browser = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> flow = OAuth2WebServerFlow ( * musicmanager . oauth ) <EOL> auth_uri = flow . step1_get_authorize_url ( ) <EOL> print ( ) <EOL> print ( \"<STR_LIT>\" % auth_uri ) <EOL> if open_browser : <EOL> print ( ) <EOL> print ( '<STR_LIT>' , end = '<STR_LIT:U+0020>' ) <EOL> webbrowser . open ( auth_uri ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( ) <EOL> code = input ( \"<STR_LIT>\" ) <EOL> credentials = flow . step2_exchange ( code ) <EOL> if storage_filepath is not None : <EOL> if storage_filepath == OAUTH_FILEPATH : <EOL> utils . make_sure_path_exists ( os . path . dirname ( OAUTH_FILEPATH ) , <NUM_LIT> ) <EOL> storage = oauth2client . file . Storage ( storage_filepath ) <EOL> storage . put ( credentials ) <EOL> return credentials <EOL> def __init__ ( self , debug_logging = True , validate = True , verify_ssl = True ) : <EOL> super ( Musicmanager , self ) . __init__ ( self . __class__ . __name__ , <EOL> debug_logging , <EOL> validate , <EOL> verify_ssl ) <EOL> def login ( self , oauth_credentials = OAUTH_FILEPATH , <EOL> uploader_id = None , uploader_name = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return ( self . _oauth_login ( oauth_credentials ) and <EOL> self . _perform_upauth ( uploader_id , uploader_name ) ) <EOL> def _oauth_login ( self , oauth_credentials ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( oauth_credentials , basestring ) : <EOL> oauth_file = oauth_credentials <EOL> if oauth_file == OAUTH_FILEPATH : <EOL> utils . make_sure_path_exists ( os . path . dirname ( OAUTH_FILEPATH ) , <NUM_LIT> ) <EOL> storage = oauth2client . file . Storage ( oauth_file ) <EOL> oauth_credentials = storage . get ( ) <EOL> if oauth_credentials is None : <EOL> self . logger . warning ( \"<STR_LIT>\" , oauth_file ) <EOL> return False <EOL> if not self . session . login ( oauth_credentials ) : <EOL> self . logger . warning ( \"<STR_LIT>\" ) <EOL> return False <EOL> self . logger . info ( \"<STR_LIT>\" ) <EOL> return True <EOL> def _perform_upauth ( self , uploader_id , uploader_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if uploader_id is None : <EOL> mac_int = getmac ( ) <EOL> if ( mac_int >> <NUM_LIT> ) % <NUM_LIT:2> : <EOL> raise OSError ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> else : <EOL> mac_int = ( mac_int + <NUM_LIT:1> ) % ( <NUM_LIT:1> << <NUM_LIT> ) <EOL> uploader_id = utils . create_mac_string ( mac_int ) <EOL> if not utils . is_valid_mac ( uploader_id ) : <EOL> raise ValueError ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> if uploader_name is None : <EOL> uploader_name = gethostname ( ) + u\"<STR_LIT>\" % gmusicapi . __version__ <EOL> try : <EOL> self . _make_call ( musicmanager . AuthenticateUploader , <EOL> uploader_id , <EOL> uploader_name ) <EOL> self . logger . info ( \"<STR_LIT>\" ) <EOL> self . uploader_id = uploader_id <EOL> self . uploader_name = uploader_name <EOL> except CallFailure : <EOL> self . logger . exception ( \"<STR_LIT>\" ) <EOL> self . session . logout ( ) <EOL> return False <EOL> return True <EOL> def logout ( self , revoke_oauth = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> success = True <EOL> if revoke_oauth : <EOL> try : <EOL> self . session . _oauth_creds . revoke ( httplib2 . Http ( ) ) <EOL> except TokenRevokeError : <EOL> self . logger . exception ( \"<STR_LIT>\" ) <EOL> success = False <EOL> self . uploader_id = None <EOL> self . uploader_name = None <EOL> return success and super ( Musicmanager , self ) . logout ( ) <EOL> def get_uploaded_songs ( self , incremental = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> to_return = self . _get_all_songs ( ) <EOL> if not incremental : <EOL> to_return = [ song for chunk in to_return for song in chunk ] <EOL> return to_return <EOL> def get_purchased_songs ( self , incremental = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> to_return = self . _get_all_songs ( export_type = <NUM_LIT:2> ) <EOL> if not incremental : <EOL> to_return = [ song for chunk in to_return for song in chunk ] <EOL> return to_return <EOL> @ staticmethod <EOL> def _track_info_to_dict ( track_info ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return dict ( ( field , getattr ( track_info , field ) ) for field in <EOL> ( '<STR_LIT:id>' , '<STR_LIT:title>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ) ) <EOL> def _get_all_songs ( self , export_type = <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> get_next_chunk = True <EOL> lib_chunk = lambda : <NUM_LIT:0> <EOL> lib_chunk . continuation_token = None <EOL> while get_next_chunk : <EOL> lib_chunk = self . _make_call ( musicmanager . ListTracks , <EOL> self . uploader_id , <EOL> lib_chunk . continuation_token , <EOL> export_type ) <EOL> yield [ self . _track_info_to_dict ( info ) <EOL> for info in lib_chunk . download_track_info ] <EOL> get_next_chunk = lib_chunk . HasField ( '<STR_LIT>' ) <EOL> @ utils . enforce_id_param <EOL> def download_song ( self , song_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url = self . _make_call ( musicmanager . GetDownloadLink , <EOL> song_id , <EOL> self . uploader_id ) [ '<STR_LIT:url>' ] <EOL> response = self . _make_call ( musicmanager . DownloadTrack , url ) <EOL> cd_header = response . headers [ '<STR_LIT>' ] <EOL> filename = urllib . parse . unquote ( cd_header . split ( \"<STR_LIT>\" ) [ - <NUM_LIT:1> ] ) <EOL> return ( filename , response . content ) <EOL> @ utils . accept_singleton ( basestring ) <EOL> @ utils . empty_arg_shortcircuit ( return_code = '<STR_LIT:{}>' ) <EOL> def upload ( self , filepaths , transcode_quality = '<STR_LIT>' , enable_matching = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . uploader_id is None or self . uploader_name is None : <EOL> raise NotLoggedIn ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> uploaded = { } <EOL> matched = { } <EOL> not_uploaded = { } <EOL>", "answer": "local_info = { }"}, {"prompt": "<s> import requests <EOL> import json <EOL> controller_url = \"<STR_LIT>\" <EOL> payload = { \"<STR_LIT:username>\" : \"<STR_LIT>\" , \"<STR_LIT:password>\" : \"<STR_LIT>\" } <EOL> ticket_url = controller_url + \"<STR_LIT>\" <EOL> header = { \"<STR_LIT>\" : \"<STR_LIT:application/json>\" } <EOL> response = requests . post ( ticket_url , data = json . dumps ( payload ) , headers = header , verify = False ) <EOL> r_json = response . json ( ) <EOL>", "answer": "ticket = r_json [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ]"}, {"prompt": "<s> from time import time <EOL> from datetime import datetime <EOL> from mock import patch , Mock , sentinel <EOL> from nose import tools <EOL> from eventtracker . tasks import track , collect_events <EOL> from eventtracker . models import save_event <EOL> @ patch ( '<STR_LIT>' ) <EOL> def test_track_sends_event ( get_carrot_object ) : <EOL> get_carrot_object . return_value = get_carrot_object <EOL> args = ( '<STR_LIT>' , { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> track ( * args ) <EOL> tools . assert_true ( get_carrot_object . send . called ) <EOL> cargs , ckwargs = get_carrot_object . send . call_args <EOL> tools . assert_equals ( <NUM_LIT:1> , len ( cargs ) ) <EOL> cargs = cargs [ <NUM_LIT:0> ] <EOL> tools . assert_equals ( { } , ckwargs ) <EOL> tools . assert_equals ( args [ <NUM_LIT:0> ] , cargs [ <NUM_LIT:0> ] ) <EOL> tools . assert_true ( time ( ) > cargs [ <NUM_LIT:1> ] > time ( ) - <NUM_LIT:1> ) <EOL> tools . assert_equals ( args [ <NUM_LIT:1> ] , cargs [ <NUM_LIT:2> ] ) <EOL> @ patch ( '<STR_LIT>' ) <EOL> @ patch ( '<STR_LIT>' ) <EOL> @ patch ( '<STR_LIT>' ) <EOL> def test_collect_events_calls_save_event_for_every_event_in_queue ( save_event , get_mongo_collection , get_carrot_object ) : <EOL> collection = Mock ( ) <EOL> get_mongo_collection . return_value = collection <EOL> t1 , t2 = time ( ) - <NUM_LIT:1> , time ( ) <EOL> m1 , m2 = Mock ( ) , Mock ( ) <EOL> m1 . decode . return_value , m2 . decode . return_value = ( '<STR_LIT>' , t1 , { '<STR_LIT>' : '<STR_LIT>' } ) , ( '<STR_LIT>' , t2 , { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> consumer = Mock ( ) <EOL> get_carrot_object . return_value = consumer <EOL> consumer . iterqueue . return_value = [ m1 , m2 ] <EOL> collect_events ( ) <EOL> tools . assert_equals ( [ ( '<STR_LIT>' , ( ) , { } ) , ( '<STR_LIT>' , ( ) , { } ) ] , m1 . method_calls ) <EOL> tools . assert_equals ( [ ( '<STR_LIT>' , ( ) , { } ) , ( '<STR_LIT>' , ( ) , { } ) ] , m2 . method_calls ) <EOL> tools . assert_equals ( <NUM_LIT:1> , consumer . iterqueue . call_count ) <EOL> tools . assert_equals ( <NUM_LIT:2> , save_event . call_count ) <EOL>", "answer": "tools . assert_equals ( ["}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> import os <EOL> import sys <EOL> import heapq <EOL> from collections import defaultdict <EOL> def readNMerge ( fileLst , outFile ) : <EOL> '''<STR_LIT>''' <EOL> candLst = [ ] <EOL> tgtDict = { } <EOL> total_rules = <NUM_LIT:0> <EOL> stop_iteration = False <EOL> fileTrackLst = [ <NUM_LIT:1> for file in fileLst ] <EOL> print \"<STR_LIT>\" <EOL> fHLst = [ open ( file , '<STR_LIT:r>' ) for file in fileLst ] <EOL> oF = open ( outFile , '<STR_LIT:w>' ) <EOL> while True : <EOL> if stop_iteration : <EOL> break <EOL> for indx , f_track in enumerate ( fileTrackLst ) : <EOL> if f_track == <NUM_LIT:0> or f_track == <NUM_LIT:9> : <EOL> continue <EOL> fileTrackLst [ indx ] = <NUM_LIT:0> <EOL> line = fHLst [ indx ] . readline ( ) <EOL> line = line . strip ( ) <EOL> if line == '<STR_LIT>' : <EOL> fileTrackLst [ indx ] = <NUM_LIT:9> <EOL> stop_iteration = True <EOL> continue <EOL> stop_iteration = False <EOL> ( tgt , r_count ) = line . split ( '<STR_LIT>' ) <EOL> r_count = float ( r_count ) <EOL> if tgtDict . has_key ( tgt ) : <EOL> valTup = ( tgtDict [ tgt ] [ <NUM_LIT:0> ] + r_count , tgtDict [ tgt ] [ <NUM_LIT:1> ] + [ indx ] ) <EOL> tgtDict [ tgt ] = valTup <EOL> else : <EOL> tgtDict [ tgt ] = ( r_count , [ indx ] ) <EOL> heapq . heappush ( candLst , tgt ) <EOL> if len ( candLst ) == <NUM_LIT:0> : continue <EOL> popped_tgt = heapq . heappop ( candLst ) <EOL> ( r_count , indxLst ) = tgtDict . pop ( popped_tgt ) <EOL> oF . write ( \"<STR_LIT>\" % ( popped_tgt , r_count ) ) <EOL> total_rules += <NUM_LIT:1> <EOL> for indx1 in indxLst : <EOL> fileTrackLst [ indx1 ] = <NUM_LIT:1> <EOL> stop_iteration = False <EOL> for fH in fHLst : <EOL> fH . close ( ) <EOL> oF . close ( ) <EOL> print ( \"<STR_LIT>\" % ( total_rules ) ) <EOL> def main ( ) : <EOL> tgtPath = sys . argv [ <NUM_LIT:1> ] <EOL> fileLst = [ ] <EOL>", "answer": "for f in os . listdir ( tgtPath ) :"}, {"prompt": "<s> AUTH_TYPE_SAS = \"<STR_LIT>\" <EOL> AUTH_TYPE_ACS = \"<STR_LIT>\" <EOL> SERVICEBUS_AUTH_TYPE = AUTH_TYPE_SAS <EOL> SERVICEBUS_NAME = \"<STR_LIT>\" <EOL> SERVICEBUS_ACS_KEY = \"<STR_LIT>\" <EOL> SERVICEBUS_SAS_KEY_NAME = \"<STR_LIT>\" <EOL> SERVICEBUS_SAS_KEY_VALUE = \"<STR_LIT>\" <EOL> EVENTHUB_NAME = \"<STR_LIT>\" <EOL> EVENTHUB_SAS_KEY_NAME = \"<STR_LIT>\" <EOL> EVENTHUB_SAS_KEY_VALUE = \"<STR_LIT>\" <EOL> USE_PROXY = False <EOL> PROXY_HOST = \"<STR_LIT>\" <EOL> PROXY_PORT = \"<STR_LIT>\" <EOL> PROXY_USER = \"<STR_LIT>\" <EOL>", "answer": "PROXY_PASSWORD = \"<STR_LIT>\" "}, {"prompt": "<s> from __future__ import absolute_import , division , print_function <EOL> import json <EOL> from cStringIO import StringIO <EOL> import urllib <EOL> import bottle <EOL>", "answer": "from dossier . fc import FeatureCollection"}, {"prompt": "<s> import six <EOL> from sqlalchemy . sql import not_ <EOL> from nailgun import consts <EOL> from nailgun . db import db <EOL> from nailgun . db . sqlalchemy import models <EOL> from nailgun . objects import NailgunCollection <EOL> from nailgun . objects import NailgunObject <EOL> from nailgun . objects . serializers . base import BasicSerializer <EOL> class DPDKMixin ( object ) : <EOL> @ classmethod <EOL> def dpdk_available ( cls , instance , dpdk_drivers ) : <EOL> raise NotImplementedError <EOL> @ classmethod <EOL> def dpdk_enabled ( cls , instance ) : <EOL> dpdk = instance . interface_properties . get ( '<STR_LIT>' ) <EOL> return bool ( dpdk and dpdk . get ( '<STR_LIT>' ) ) <EOL> @ classmethod <EOL> def refresh_interface_dpdk_properties ( cls , interface , dpdk_drivers ) : <EOL> interface_properties = interface . interface_properties <EOL> dpdk_properties = interface_properties . get ( '<STR_LIT>' , { } ) . copy ( ) <EOL> dpdk_properties [ '<STR_LIT>' ] = cls . dpdk_available ( interface , <EOL> dpdk_drivers ) <EOL> if ( not dpdk_properties [ '<STR_LIT>' ] and <EOL> dpdk_properties . get ( '<STR_LIT>' ) ) : <EOL> dpdk_properties [ '<STR_LIT>' ] = False <EOL> if interface_properties . get ( '<STR_LIT>' , { } ) != dpdk_properties : <EOL> interface_properties [ '<STR_LIT>' ] = dpdk_properties <EOL> class NIC ( DPDKMixin , NailgunObject ) : <EOL> model = models . NodeNICInterface <EOL> serializer = BasicSerializer <EOL> @ classmethod <EOL> def assign_networks ( cls , instance , networks ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> instance . assigned_networks_list = networks <EOL> db ( ) . flush ( ) <EOL> @ classmethod <EOL> def get_dpdk_driver ( cls , instance , dpdk_drivers ) : <EOL> pci_id = instance . interface_properties . get ( '<STR_LIT>' , '<STR_LIT>' ) . lower ( ) <EOL> for driver , device_ids in six . iteritems ( dpdk_drivers ) : <EOL> if pci_id in device_ids : <EOL> return driver <EOL> return None <EOL> @ classmethod <EOL> def dpdk_available ( cls , instance , dpdk_drivers ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return ( cls . get_dpdk_driver ( instance , dpdk_drivers ) is not None and <EOL> instance . node . cluster . network_config . segmentation_type == <EOL> consts . NEUTRON_SEGMENT_TYPES . vlan ) <EOL> @ classmethod <EOL> def is_sriov_enabled ( cls , instance ) : <EOL> sriov = instance . interface_properties . get ( '<STR_LIT>' ) <EOL> return sriov and sriov [ '<STR_LIT>' ] <EOL> @ classmethod <EOL> def update_offloading_modes ( cls , instance , new_modes , keep_states = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if keep_states : <EOL> old_modes_states = instance . offloading_modes_as_flat_dict ( <EOL> instance . offloading_modes ) <EOL> for mode in new_modes : <EOL> if mode [ \"<STR_LIT:name>\" ] in old_modes_states : <EOL> mode [ \"<STR_LIT:state>\" ] = old_modes_states [ mode [ \"<STR_LIT:name>\" ] ] <EOL> instance . offloading_modes = new_modes <EOL>", "answer": "class NICCollection ( NailgunCollection ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import unittest <EOL> from unittest . mock import patch <EOL> import homeassistant . core as ha <EOL>", "answer": "from homeassistant . const import ("}, {"prompt": "<s> from __future__ import absolute_import <EOL> import socket <EOL> import ctypes <EOL> import os <EOL> class sockaddr ( ctypes . Structure ) : <EOL> _fields_ = [ ( \"<STR_LIT>\" , ctypes . c_short ) , <EOL> ( \"<STR_LIT>\" , ctypes . c_ushort ) , <EOL> ( \"<STR_LIT>\" , ctypes . c_byte * <NUM_LIT:4> ) , <EOL> ( \"<STR_LIT>\" , ctypes . c_byte * <NUM_LIT:16> ) , <EOL> ( \"<STR_LIT>\" , ctypes . c_ulong ) ] <EOL> if hasattr ( ctypes , '<STR_LIT>' ) : <EOL> WSAStringToAddressA = ctypes . windll . ws2_32 . WSAStringToAddressA <EOL> WSAAddressToStringA = ctypes . windll . ws2_32 . WSAAddressToStringA <EOL> else : <EOL> def not_windows ( ) : <EOL> raise SystemError ( <EOL>", "answer": "\"<STR_LIT>\""}, {"prompt": "<s> import os <EOL> DATABASES = { <EOL> '<STR_LIT:default>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> } <EOL> SECRET_KEY = '<STR_LIT>' <EOL> CACHE_BACKEND = '<STR_LIT>' <EOL> LOCAL_ROOT = os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT:data>' ) ) <EOL> ADMINS = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL>", "answer": "]"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from future . standard_library import install_aliases <EOL> install_aliases ( ) <EOL> from urllib import parse <EOL> from configparser import ConfigParser , DuplicateSectionError <EOL> import sqlalchemy as sa <EOL> from ipydb import CONFIG_FILE <EOL> def getconfigparser ( ) : <EOL> cp = ConfigParser ( ) <EOL> cp . read ( CONFIG_FILE ) <EOL> return cp <EOL> def getconfigs ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cp = getconfigparser ( ) <EOL> configs = { } <EOL> default = None <EOL> for section in cp . sections ( ) : <EOL> conf = dict ( cp . defaults ( ) ) <EOL> conf . update ( dict ( cp . items ( section ) ) ) <EOL> if conf . get ( '<STR_LIT:default>' ) : <EOL> default = section <EOL> configs [ section ] = conf <EOL> return default , configs <EOL> def get_nicknames ( ) : <EOL> return sorted ( getconfigs ( ) . keys ( ) ) <EOL> def from_config ( configname = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> default , configs = getconfigs ( ) <EOL> if not configname : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> elif configname not in configs : <EOL> raise ValueError ( <EOL> '<STR_LIT>' % ( get_nicknames ( ) ) ) <EOL> else : <EOL> config = configs [ configname ] <EOL> connect_args = { } <EOL> engine = from_url ( make_connection_url ( config ) , <EOL> connect_args = connect_args ) <EOL> return engine <EOL> def from_url ( url , connect_args = { } ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url_string = url <EOL> url = sa . engine . url . make_url ( str ( url_string ) ) <EOL> if url . drivername == '<STR_LIT>' : <EOL> import cx_Oracle <EOL> if not getattr ( cx_Oracle , '<STR_LIT>' , None ) : <EOL> setattr ( cx_Oracle , '<STR_LIT>' , cx_Oracle . makedsn ) <EOL> def newmakedsn ( * args , ** kw ) : <EOL> return cx_Oracle . _cxmakedsn ( * args , ** kw ) . replace ( <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> cx_Oracle . makedsn = newmakedsn <EOL> elif url . drivername == '<STR_LIT>' : <EOL> import MySQLdb . cursors <EOL> connect_args = { '<STR_LIT>' : MySQLdb . cursors . SSCursor } <EOL> engine = sa . engine . create_engine ( url , connect_args = connect_args ) <EOL> return engine <EOL> def make_connection_url ( config ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "return sa . engine . url . URL ("}, {"prompt": "<s> from sneakers . modules import Channel <EOL> from twython import Twython , TwythonError <EOL> import time <EOL> class Twitter ( Channel ) : <EOL> description = \"\"\"<STR_LIT>\"\"\" <EOL> requiredParams = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:key>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:key>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' <EOL> } <EOL> } <EOL> max_length = <NUM_LIT> <EOL> max_hourly = <NUM_LIT:100> <EOL> def send ( self , data ) : <EOL> send_params = self . params [ '<STR_LIT>' ] <EOL> APP_KEY = send_params [ '<STR_LIT:key>' ] <EOL> APP_SECRET = send_params [ '<STR_LIT>' ] <EOL> OAUTH_TOKEN = send_params [ '<STR_LIT>' ] <EOL> OAUTH_TOKEN_SECRET = send_params [ '<STR_LIT>' ] <EOL> twitter = Twython ( APP_KEY , APP_SECRET , OAUTH_TOKEN , OAUTH_TOKEN_SECRET ) <EOL> twitter . update_status ( status = data ) <EOL> return <EOL> def receive ( self ) : <EOL> rec_params = self . params [ '<STR_LIT>' ] <EOL> APP_KEY = rec_params [ '<STR_LIT:key>' ] <EOL> APP_SECRET = rec_params [ '<STR_LIT>' ] <EOL> OAUTH_TOKEN = rec_params [ '<STR_LIT>' ] <EOL> OAUTH_TOKEN_SECRET = rec_params [ '<STR_LIT>' ] <EOL> SCREEN_NAME = rec_params [ '<STR_LIT:name>' ] <EOL> twitter = Twython ( APP_KEY , APP_SECRET , OAUTH_TOKEN , OAUTH_TOKEN_SECRET ) <EOL> user_timeline = twitter . get_user_timeline ( screen_name = SCREEN_NAME ) <EOL> tweets = [ ] <EOL> for x in user_timeline : <EOL> if '<STR_LIT:text>' in x : <EOL> tweets . append ( x [ '<STR_LIT:text>' ] ) <EOL>", "answer": "return tweets "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from cafe . drivers . unittest . decorators import tags <EOL> from cloudcafe . compute . common . exceptions import ItemNotFound <EOL> from cloudcafe . images . common . types import ImageMemberStatus <EOL> from cloudroast . images . fixtures import ImagesFixture <EOL> class UnsharePreviouslySharedImageTest ( ImagesFixture ) : <EOL> @ classmethod <EOL> def setUpClass ( cls ) : <EOL> super ( UnsharePreviouslySharedImageTest , cls ) . setUpClass ( ) <EOL> cls . image = cls . images_behavior . create_image_via_task ( ) <EOL> @ tags ( type = '<STR_LIT>' , regression = '<STR_LIT:true>' ) <EOL> def test_unshare_previously_shared_image ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with self . assertRaises ( ItemNotFound ) : <EOL> self . alt_images_client . get_image ( image_id = self . image . id_ ) <EOL> response = self . images_client . add_member ( image_id = self . image . id_ , <EOL> member_id = self . alt_tenant_id ) <EOL> self . assertEqual ( response . status_code , <NUM_LIT:200> ) <EOL> member = response . entity <EOL> self . assertEqual ( member . member_id , self . alt_tenant_id ) <EOL> self . assertEqual ( member . status , ImageMemberStatus . PENDING ) <EOL> response = self . alt_images_client . get_image ( image_id = self . image . id_ ) <EOL> self . assertEqual ( response . status_code , <NUM_LIT:200> ) <EOL> new_image = response . entity <EOL> self . assertEqual ( new_image , self . image ) <EOL> response = self . alt_images_client . update_member ( <EOL> image_id = self . image . id_ , member_id = self . alt_tenant_id , <EOL> status = ImageMemberStatus . ACCEPTED ) <EOL> self . assertEqual ( response . status_code , <NUM_LIT:200> ) <EOL> updated_member = response . entity <EOL>", "answer": "self . assertEqual ( updated_member . member_id , self . alt_tenant_id )"}, {"prompt": "<s> import datetime <EOL> from flask import Flask <EOL> from flask import Response <EOL> from flask import flash <EOL> from flask import g <EOL> from flask import redirect <EOL> from flask import render_template <EOL> from flask import request <EOL> from flask import url_for <EOL> from peewee import * <EOL> from flask_peewee . admin import Admin <EOL> from flask_peewee . admin import AdminPanel <EOL> from flask_peewee . admin import ModelAdmin <EOL> from flask_peewee . auth import Auth <EOL> from flask_peewee . auth import BaseUser <EOL> from flask_peewee . db import Database <EOL> from flask_peewee . filters import QueryFilter <EOL> from flask_peewee . rest import APIKeyAuthentication <EOL> from flask_peewee . rest import AdminAuthentication <EOL> from flask_peewee . rest import Authentication <EOL> from flask_peewee . rest import RestAPI <EOL> from flask_peewee . rest import RestResource <EOL> from flask_peewee . rest import RestrictOwnerResource <EOL> from flask_peewee . rest import UserAuthentication <EOL> from flask_peewee . utils import get_object_or_404 <EOL> from flask_peewee . utils import make_password <EOL> from flask_peewee . utils import object_list <EOL> class TestFlask ( Flask ) : <EOL> def update_template_context ( self , context ) : <EOL> ret = super ( TestFlask , self ) . update_template_context ( context ) <EOL> self . _template_context . update ( context ) <EOL> return ret <EOL> app = TestFlask ( __name__ ) <EOL> app . config . from_object ( '<STR_LIT>' ) <EOL> db = Database ( app ) <EOL> @ app . before_request <EOL> def clear_context ( ) : <EOL> app . _template_context = { } <EOL> class User ( db . Model , BaseUser ) : <EOL> username = CharField ( ) <EOL> password = CharField ( ) <EOL> email = CharField ( ) <EOL> join_date = DateTimeField ( default = datetime . datetime . now ) <EOL> active = BooleanField ( default = True ) <EOL> admin = BooleanField ( default = False , verbose_name = '<STR_LIT>' ) <EOL> def __unicode__ ( self ) : <EOL> return self . username <EOL> def __hash__ ( self ) : <EOL> return hash ( self . username ) <EOL> def message_count ( self ) : <EOL> return self . message_set . count ( ) <EOL> class Message ( db . Model ) : <EOL>", "answer": "user = ForeignKeyField ( User )"}, {"prompt": "<s> from openmdao . main . api import Component <EOL> from openmdao . lib . datatypes . api import Float , Int <EOL> class PassengerCapsule ( Component ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> import os <EOL> import matplotlib . pyplot as plt <EOL> from framework . mongo import database <EOL> from website import settings <EOL> from . utils import plot_dates , mkdirp <EOL> log_collection = database [ '<STR_LIT>' ] <EOL> FIG_PATH = os . path . join ( settings . ANALYTICS_PATH , '<STR_LIT>' , '<STR_LIT>' ) <EOL> mkdirp ( FIG_PATH ) <EOL>", "answer": "def analyze_log_action ( action ) :"}, {"prompt": "<s> import sslip <EOL> import coro <EOL> import socket <EOL> import coro_ssl <EOL> import string <EOL> def http_client ( ) : <EOL> \"<STR_LIT>\" <EOL> client = coro_ssl . ssl_sock ( ) <EOL> client . create ( ) <EOL> client . connect ( ( '<STR_LIT>' , <NUM_LIT> ) ) <EOL> client . send ( '<STR_LIT>' ) <EOL> data = '<STR_LIT>' <EOL> while True : <EOL> block = client . recv ( <NUM_LIT> ) <EOL> if block : <EOL> data += block <EOL> else : <EOL> break <EOL> print data <EOL> client . close ( ) <EOL> def client ( ) : <EOL> \"<STR_LIT>\" <EOL> client = coro_ssl . ssl_sock ( ) <EOL> client . create ( ) <EOL> client . connect ( ( '<STR_LIT:127.0.0.1>' , <NUM_LIT> ) ) <EOL> print client . recv ( <NUM_LIT> ) <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> client . send ( '<STR_LIT>' % i ) <EOL> print client . recv ( <NUM_LIT> ) <EOL> client . close ( ) <EOL> def channel ( conn , addr ) : <EOL> \"<STR_LIT>\" <EOL>", "answer": "peer_cert = conn . ssl . get_peer_cert ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import supybot <EOL> import supybot . world as world <EOL> __version__ = \"<STR_LIT>\" <EOL> __author__ = supybot . authors . jemfinch <EOL> __contributors__ = { } <EOL> from . import config <EOL> from . import plugin <EOL> from imp import reload <EOL> reload ( plugin ) <EOL> if world . testing : <EOL>", "answer": "from . import test"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , print_function <EOL> import pytest <EOL> from pptx . opc . constants import RELATIONSHIP_TYPE as RT <EOL> from pptx . opc . package import Part , _Relationship <EOL> from pptx . opc . packuri import PackURI <EOL> from pptx . package import _ImageParts , Package <EOL> from pptx . parts . coreprops import CoreProperties <EOL> from pptx . parts . image import Image , ImagePart <EOL> from pptx . parts . presentation import PresentationPart <EOL> from . unitutil . file import absjoin <EOL> from . unitutil . mock import ( <EOL> class_mock , instance_mock , method_mock , property_mock <EOL> ) <EOL> class DescribePackage ( object ) : <EOL> def it_loads_default_template_when_opened_with_no_path ( self ) : <EOL> prs = Package . open ( ) . presentation <EOL> assert prs is not None <EOL> slide_masters = prs . slide_masters <EOL> assert slide_masters is not None <EOL> assert len ( slide_masters ) == <NUM_LIT:1> <EOL> slide_layouts = slide_masters [ <NUM_LIT:0> ] . slide_layouts <EOL> assert slide_layouts is not None <EOL> assert len ( slide_layouts ) == <NUM_LIT:11> <EOL> def it_provides_ref_to_package_presentation_part ( self ) : <EOL> pkg = Package . open ( ) <EOL> assert isinstance ( pkg . presentation , PresentationPart ) <EOL> def it_provides_access_to_its_core_properties_part ( self ) : <EOL> pkg = Package . open ( ) <EOL> assert isinstance ( pkg . core_properties , CoreProperties ) <EOL> def it_can_get_or_add_an_image_part ( self , image_part_fixture ) : <EOL> package , image_file , image_part_ = image_part_fixture <EOL> image_part = package . get_or_add_image_part ( image_file ) <EOL> package . _image_parts . get_or_add_image_part . assert_called_once_with ( <EOL> image_file <EOL> ) <EOL> assert image_part is image_part_ <EOL> def it_can_save_itself_to_a_pptx_file ( self , temp_pptx_path ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pkg = Package . open ( ) <EOL> pkg . save ( temp_pptx_path ) <EOL> pkg = Package . open ( temp_pptx_path ) <EOL> prs = pkg . presentation <EOL> assert prs is not None <EOL> slide_masters = prs . slide_masters <EOL> assert slide_masters is not None <EOL> assert len ( slide_masters ) == <NUM_LIT:1> <EOL> slide_layouts = slide_masters [ <NUM_LIT:0> ] . slide_layouts <EOL> assert slide_layouts is not None <EOL> assert len ( slide_layouts ) == <NUM_LIT:11> <EOL> def it_knows_the_next_available_image_partname ( self , next_fixture ) : <EOL> package , ext , expected_value = next_fixture <EOL> partname = package . next_image_partname ( ext ) <EOL> assert partname == expected_value <EOL> @ pytest . fixture <EOL> def image_part_fixture ( self , _image_parts_ , image_part_ ) : <EOL> package = Package ( ) <EOL> image_file = '<STR_LIT>' <EOL> package . _image_parts . get_or_add_image_part . return_value = image_part_ <EOL> return package , image_file , image_part_ <EOL> @ pytest . fixture ( params = [ <EOL> ( ( <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:2> ) , <NUM_LIT:1> ) , <EOL> ( ( <NUM_LIT:4> , <NUM_LIT:2> , <NUM_LIT:1> ) , <NUM_LIT:3> ) , <EOL> ( ( <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:1> ) , <NUM_LIT:4> ) , <EOL> ] ) <EOL> def next_fixture ( self , request , iter_parts_ ) : <EOL> idxs , idx = request . param <EOL> package = Package ( ) <EOL> package . iter_parts . return_value = self . i_image_parts ( request , idxs ) <EOL> ext = '<STR_LIT:foo>' <EOL> expected_value = '<STR_LIT>' % ( idx , ext ) <EOL> return package , ext , expected_value <EOL> @ pytest . fixture <EOL> def temp_pptx_path ( self , tmpdir ) : <EOL> return absjoin ( str ( tmpdir ) , '<STR_LIT>' ) <EOL> @ pytest . fixture <EOL> def image_part_ ( self , request ) : <EOL> return instance_mock ( request , ImagePart ) <EOL> @ pytest . fixture <EOL> def _image_parts_ ( self , request ) : <EOL> return property_mock ( request , Package , '<STR_LIT>' ) <EOL> def i_image_parts ( self , request , idxs ) : <EOL> def part ( idx ) : <EOL> partname = PackURI ( '<STR_LIT>' % idx ) <EOL> return instance_mock ( request , Part , partname = partname ) <EOL> return iter ( [ part ( idx ) for idx in idxs ] ) <EOL> @ pytest . fixture <EOL>", "answer": "def iter_parts_ ( self , request ) :"}, {"prompt": "<s> import os , sys , math , traceback <EOL> import arcpy <EOL> from arcpy import env <EOL> inFeature = arcpy . GetParameterAsText ( <NUM_LIT:0> ) <EOL> weaponTable = arcpy . GetParameterAsText ( <NUM_LIT:1> ) <EOL> weaponField = arcpy . GetParameterAsText ( <NUM_LIT:2> ) <EOL> weaponModel = arcpy . GetParameterAsText ( <NUM_LIT:3> ) <EOL> maxRangeField = arcpy . GetParameterAsText ( <NUM_LIT:4> ) <EOL> maxRange = float ( arcpy . GetParameterAsText ( <NUM_LIT:5> ) ) <EOL> geoBearing = float ( arcpy . GetParameterAsText ( <NUM_LIT:6> ) ) <EOL> traversal = float ( arcpy . GetParameterAsText ( <NUM_LIT:7> ) ) <EOL> outFeature = arcpy . GetParameterAsText ( <NUM_LIT:8> ) <EOL> commonSpatialReference = arcpy . GetParameter ( <NUM_LIT:9> ) <EOL> commonSpatialReferenceAsText = arcpy . GetParameterAsText ( <NUM_LIT:9> ) <EOL> deleteme = [ ] <EOL> debug = False <EOL> leftAngle = <NUM_LIT:0.0> <EOL> rightAngle = <NUM_LIT> <EOL> def Geo2Arithmetic ( inAngle ) : <EOL> outAngle = - <NUM_LIT:1.0> <EOL> if ( inAngle > <NUM_LIT> ) : <EOL> inAngle = math . fmod ( inAngle , <NUM_LIT> ) <EOL> if inAngle == <NUM_LIT> : inAngle = <NUM_LIT:0.0> <EOL> if ( inAngle >= <NUM_LIT:0.0> and inAngle <= <NUM_LIT> ) : <EOL> outAngle = math . fabs ( inAngle - <NUM_LIT> ) <EOL> if ( inAngle > <NUM_LIT> and inAngle < <NUM_LIT> ) : <EOL> outAngle = <NUM_LIT> - ( inAngle - <NUM_LIT> ) <EOL> if debug == True : arcpy . AddMessage ( \"<STR_LIT>\" + str ( inAngle ) + \"<STR_LIT>\" + str ( outAngle ) + \"<STR_LIT:)>\" ) <EOL> return outAngle <EOL> try : <EOL> currentOverwriteOutput = env . overwriteOutput <EOL> env . overwriteOutput = True <EOL> if commonSpatialReferenceAsText == '<STR_LIT>' : <EOL> commonSpatialReference = arcpy . Describe ( inFeature ) . spatialReference <EOL> arcpy . AddWarning ( \"<STR_LIT>\" + str ( commonSpatialReference . name ) ) <EOL> env . outputCoordinateSystem = commonSpatialReference <EOL> env . overwriteOutput = True <EOL> scratch = env . scratchWorkspace <EOL> copyInFeatures = os . path . join ( scratch , \"<STR_LIT>\" ) <EOL> arcpy . CopyFeatures_management ( inFeature , copyInFeatures ) <EOL> deleteme . append ( copyInFeatures ) <EOL> prjInFeature = os . path . join ( scratch , \"<STR_LIT>\" ) <EOL> srInputPoints = arcpy . Describe ( copyInFeatures ) . spatialReference <EOL> arcpy . AddMessage ( \"<STR_LIT>\" + str ( env . outputCoordinateSystem . name ) + \"<STR_LIT>\" ) <EOL> arcpy . Project_management ( copyInFeatures , prjInFeature , env . outputCoordinateSystem ) <EOL> deleteme . append ( prjInFeature ) <EOL> tempFans = os . path . join ( scratch , \"<STR_LIT>\" ) <EOL> geoBearing = math . fmod ( geoBearing , <NUM_LIT> ) <EOL> if debug == True : arcpy . AddMessage ( \"<STR_LIT>\" + str ( geoBearing ) ) <EOL> arithmeticBearing = Geo2Arithmetic ( geoBearing ) <EOL> if debug == True : arcpy . AddMessage ( \"<STR_LIT>\" + str ( arithmeticBearing ) ) <EOL> if traversal == <NUM_LIT:0.0> : <EOL> traversal = <NUM_LIT:1.0> <EOL> arcpy . AddWarning ( \"<STR_LIT>\" ) <EOL> leftAngle = arithmeticBearing + ( traversal / <NUM_LIT> ) <EOL> leftBearing = geoBearing - ( traversal / <NUM_LIT> ) <EOL> if leftBearing < <NUM_LIT:0.0> : leftBearing = <NUM_LIT> + leftBearing <EOL> rightAngle = arithmeticBearing - ( traversal / <NUM_LIT> ) <EOL> rightBearing = geoBearing + ( traversal / <NUM_LIT> ) <EOL> if rightBearing < <NUM_LIT:0.0> : rightBearing = <NUM_LIT> + rightBearing <EOL> if debug == True : arcpy . AddMessage ( \"<STR_LIT>\" + str ( leftAngle ) + \"<STR_LIT:/>\" + str ( rightAngle ) ) <EOL> if debug == True : arcpy . AddMessage ( \"<STR_LIT>\" + str ( leftBearing ) + \"<STR_LIT:/>\" + str ( rightBearing ) ) <EOL> centerPoints = [ ] <EOL> arcpy . AddMessage ( \"<STR_LIT>\" ) <EOL> shapefieldname = arcpy . Describe ( prjInFeature ) . ShapeFieldName <EOL> rows = arcpy . SearchCursor ( prjInFeature ) <EOL> for row in rows : <EOL> feat = row . getValue ( shapefieldname ) <EOL> pnt = feat . getPart ( ) <EOL> centerPointX = pnt . X <EOL> centerPointY = pnt . Y <EOL> centerPoints . append ( [ centerPointX , centerPointY ] ) <EOL> del row <EOL> del rows <EOL> paths = [ ] <EOL> arcpy . AddMessage ( \"<STR_LIT>\" ) <EOL> for centerPoint in centerPoints : <EOL> path = [ ] <EOL> centerPointX = centerPoint [ <NUM_LIT:0> ] <EOL> centerPointY = centerPoint [ <NUM_LIT:1> ] <EOL> path . append ( [ centerPointX , centerPointY ] ) <EOL> step = - <NUM_LIT:1.0> <EOL> rightAngleRelativeToLeft = leftAngle - traversal - <NUM_LIT:1> <EOL> for d in range ( int ( leftAngle ) , int ( rightAngleRelativeToLeft ) , int ( step ) ) : <EOL> x = centerPointX + ( maxRange * math . cos ( math . radians ( d ) ) ) <EOL> y = centerPointY + ( maxRange * math . sin ( math . radians ( d ) ) ) <EOL> path . append ( [ x , y ] ) <EOL> if debug == True : arcpy . AddMessage ( \"<STR_LIT>\" + str ( d ) + \"<STR_LIT:U+002C>\" + str ( x ) + \"<STR_LIT:U+002C>\" + str ( y ) ) <EOL> path . append ( [ centerPointX , centerPointY ] ) <EOL> paths . append ( path ) <EOL> if debug == True : arcpy . AddMessage ( \"<STR_LIT>\" + str ( len ( path ) ) ) <EOL> if debug == True : arcpy . AddMessage ( \"<STR_LIT>\" + str ( paths ) ) <EOL> arcpy . AddMessage ( \"<STR_LIT>\" ) <EOL> arcpy . CreateFeatureclass_management ( os . path . dirname ( tempFans ) , os . path . basename ( tempFans ) , \"<STR_LIT>\" , \"<STR_LIT:#>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , env . outputCoordinateSystem ) <EOL> arcpy . AddField_management ( tempFans , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:#>\" , \"<STR_LIT:#>\" , \"<STR_LIT:#>\" , \"<STR_LIT>\" ) <EOL> arcpy . AddField_management ( tempFans , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:#>\" , \"<STR_LIT:#>\" , \"<STR_LIT:#>\" , \"<STR_LIT>\" ) <EOL> arcpy . AddField_management ( tempFans , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:#>\" , \"<STR_LIT:#>\" , \"<STR_LIT:#>\" , \"<STR_LIT>\" ) <EOL> arcpy . AddField_management ( tempFans , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:#>\" , \"<STR_LIT:#>\" , \"<STR_LIT:#>\" , \"<STR_LIT>\" ) <EOL> arcpy . AddField_management ( tempFans , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:#>\" , \"<STR_LIT:#>\" , \"<STR_LIT:#>\" , \"<STR_LIT>\" ) <EOL> arcpy . AddField_management ( tempFans , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:#>\" , \"<STR_LIT:#>\" , \"<STR_LIT:#>\" , \"<STR_LIT>\" ) <EOL> deleteme . append ( tempFans ) <EOL> arcpy . AddMessage ( \"<STR_LIT>\" + str ( len ( paths ) ) + \"<STR_LIT>\" ) <EOL> cur = arcpy . InsertCursor ( tempFans ) <EOL> for outPath in paths : <EOL> lineArray = arcpy . Array ( ) <EOL> for vertex in outPath : <EOL> pnt = arcpy . Point ( ) <EOL> pnt . X = vertex [ <NUM_LIT:0> ] <EOL> pnt . Y = vertex [ <NUM_LIT:1> ] <EOL> lineArray . add ( pnt ) <EOL> del pnt <EOL> feat = cur . newRow ( ) <EOL> feat . shape = lineArray <EOL> feat . Range = maxRange <EOL> feat . Bearing = geoBearing <EOL> feat . Traversal = traversal <EOL> feat . LeftAz = leftBearing <EOL> feat . RightAz = rightBearing <EOL> feat . Model = str ( weaponModel ) <EOL> cur . insertRow ( feat ) <EOL> del lineArray <EOL> del feat <EOL> del cur <EOL> arcpy . AddMessage ( \"<STR_LIT>\" + str ( srInputPoints . name ) ) <EOL> arcpy . Project_management ( tempFans , outFeature , srInputPoints ) <EOL> arcpy . SetParameter ( <NUM_LIT:8> , outFeature ) <EOL> except arcpy . ExecuteError : <EOL> msgs = arcpy . GetMessages ( ) <EOL> arcpy . AddError ( msgs ) <EOL> print ( msgs ) <EOL> except : <EOL> tb = sys . exc_info ( ) [ <NUM_LIT:2> ] <EOL>", "answer": "tbinfo = traceback . format_tb ( tb ) [ <NUM_LIT:0> ]"}, {"prompt": "<s> filters = ( '<STR_LIT>' , ( r'<STR_LIT>' , ) ) <EOL>", "answer": "precedes = ( '<STR_LIT:data>' , ) "}, {"prompt": "<s> import unittest <EOL> import os <EOL> from pymongo import MongoClient , GEO2D , DESCENDING <EOL> from bson import json_util <EOL> from conversiontools . csv2geojson import * <EOL> from conversiontools . kml2geojson import * <EOL> from conversiontools . shp2geojson import * <EOL> from conversiontools . validategeojson import * <EOL> from conversiontools . geojson2mongo import * <EOL> from conversiontools . geojsonurl2mongo import * <EOL> class conversionTest ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . data_input_folder = \"<STR_LIT>\" <EOL> self . data_output_folder = \"<STR_LIT>\" <EOL> self . database = \"<STR_LIT>\" <EOL> self . client = MongoClient ( '<STR_LIT:localhost>' , <NUM_LIT> ) <EOL> self . db = self . client [ self . database ] <EOL> os . chdir ( \"<STR_LIT>\" ) <EOL> def validategeojson_test ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> valid_input_geojson = self . data_input_folder + \"<STR_LIT>\" <EOL> invalid_input_geojson = self . data_input_folder + \"<STR_LIT>\" <EOL> self . assertTrue ( validate_geojson_from_file ( valid_input_geojson ) ) <EOL> self . assertFalse ( validate_geojson_from_file ( invalid_input_geojson ) ) <EOL>", "answer": "def csv2geojson_test ( self ) :"}, {"prompt": "<s> from operator import attrgetter <EOL> from django . conf import settings <EOL> from django . core . exceptions import FieldError <EOL> from django . db import connection <EOL> from django . test import TestCase <EOL> from models import ( Chef , CommonInfo , ItalianRestaurant , ParkingLot , Place , <EOL> Post , Restaurant , Student , StudentWorker , Supplier , Worker , MixinModel ) <EOL> class ModelInheritanceTests ( TestCase ) : <EOL> def test_abstract ( self ) : <EOL> w1 = Worker . objects . create ( name = \"<STR_LIT>\" , age = <NUM_LIT> , job = \"<STR_LIT>\" ) <EOL> w2 = Worker . objects . create ( name = \"<STR_LIT>\" , age = <NUM_LIT> , job = \"<STR_LIT>\" ) <EOL> s = Student . objects . create ( name = \"<STR_LIT>\" , age = <NUM_LIT:5> , school_class = \"<STR_LIT>\" ) <EOL> self . assertEqual ( unicode ( w1 ) , \"<STR_LIT>\" ) <EOL> self . assertEqual ( unicode ( s ) , \"<STR_LIT>\" ) <EOL> self . assertQuerysetEqual ( <EOL> Worker . objects . values ( \"<STR_LIT:name>\" ) , [ <EOL> { \"<STR_LIT:name>\" : \"<STR_LIT>\" } , <EOL> { \"<STR_LIT:name>\" : \"<STR_LIT>\" } , <EOL> ] , <EOL> lambda o : o <EOL> ) <EOL> self . assertEqual ( Student . _meta . ordering , [ ] ) <EOL> self . assertRaises ( AttributeError , lambda : CommonInfo . objects . all ( ) ) <EOL> self . assertRaises ( Student . DoesNotExist , <EOL> StudentWorker . objects . get , pk = <NUM_LIT> <EOL> ) <EOL> self . assertRaises ( Worker . DoesNotExist , <EOL> StudentWorker . objects . get , pk = <NUM_LIT> <EOL> ) <EOL> sw1 = StudentWorker ( ) <EOL> sw1 . name = \"<STR_LIT>\" <EOL> sw1 . age = <NUM_LIT> <EOL> sw1 . save ( ) <EOL> sw2 = StudentWorker ( ) <EOL> sw2 . name = \"<STR_LIT>\" <EOL> sw2 . age = <NUM_LIT> <EOL> sw2 . save ( ) <EOL> self . assertRaises ( Student . MultipleObjectsReturned , <EOL> StudentWorker . objects . get , pk__lt = sw2 . pk + <NUM_LIT:100> <EOL> ) <EOL> self . assertRaises ( Worker . MultipleObjectsReturned , <EOL> StudentWorker . objects . get , pk__lt = sw2 . pk + <NUM_LIT:100> <EOL> ) <EOL> def test_multiple_table ( self ) : <EOL> post = Post . objects . create ( title = \"<STR_LIT>\" ) <EOL> post . attached_comment_set . create ( content = \"<STR_LIT>\" , is_spam = True ) <EOL> post . attached_link_set . create ( <EOL> content = \"<STR_LIT>\" , <EOL> url = \"<STR_LIT>\" <EOL> ) <EOL> self . assertRaises ( AttributeError , <EOL> getattr , post , \"<STR_LIT>\" <EOL> ) <EOL> p1 = Place . objects . create ( name = \"<STR_LIT>\" , address = \"<STR_LIT>\" ) <EOL> p2 = Place . objects . create ( name = \"<STR_LIT>\" , address = \"<STR_LIT>\" ) <EOL> r = Restaurant . objects . create ( <EOL> name = \"<STR_LIT>\" , <EOL> address = \"<STR_LIT>\" , <EOL> serves_hot_dogs = True , <EOL> serves_pizza = False , <EOL> rating = <NUM_LIT:2> <EOL> ) <EOL> c = Chef . objects . create ( name = \"<STR_LIT>\" ) <EOL> ir = ItalianRestaurant . objects . create ( <EOL> name = \"<STR_LIT>\" , <EOL> address = \"<STR_LIT>\" , <EOL> serves_hot_dogs = False , <EOL> serves_pizza = False , <EOL> serves_gnocchi = True , <EOL> rating = <NUM_LIT:4> , <EOL> chef = c <EOL> ) <EOL> self . assertQuerysetEqual ( <EOL> ItalianRestaurant . objects . filter ( address = \"<STR_LIT>\" ) , [ <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> attrgetter ( \"<STR_LIT:name>\" ) <EOL> ) <EOL> ir . address = \"<STR_LIT>\" <EOL> ir . save ( ) <EOL>", "answer": "self . assertQuerysetEqual ("}, {"prompt": "<s> import collections <EOL> from eventlet import queue <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> try : <EOL> from contextlib import contextmanager <EOL> exec ( '''<STR_LIT>''' ) <EOL> except ImportError : <EOL> item_impl = None <EOL> class Pool ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , min_size = <NUM_LIT:0> , max_size = <NUM_LIT:4> , order_as_stack = False , create = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "self . min_size = min_size"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import migrations , models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AlterUniqueTogether ( <EOL>", "answer": "name = '<STR_LIT>' ,"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> import django <EOL> from django . conf import settings <EOL> from django . utils . encoding import force_text <EOL> from unidecode import unidecode <EOL> def get_image_field_class ( ) : <EOL> try : <EOL> from sorl . thumbnail import ImageField <EOL> except ImportError : <EOL> from django . db . models import ImageField <EOL> return ImageField <EOL> def get_image_field_full_name ( ) : <EOL> try : <EOL> from sorl . thumbnail import ImageField <EOL> name = '<STR_LIT>' <EOL> except ImportError : <EOL> from django . db . models import ImageField <EOL> name = '<STR_LIT>' <EOL> return name <EOL> def get_user_model ( ) : <EOL> if django . VERSION [ : <NUM_LIT:2> ] >= ( <NUM_LIT:1> , <NUM_LIT:5> ) : <EOL> from django . contrib . auth import get_user_model <EOL> return get_user_model ( ) <EOL> else : <EOL> from django . contrib . auth . models import User <EOL> User . get_username = lambda u : u . username <EOL> return User <EOL> def get_user_model_path ( ) : <EOL> if django . VERSION [ : <NUM_LIT:2> ] >= ( <NUM_LIT:1> , <NUM_LIT:5> ) : <EOL> return getattr ( settings , '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> return '<STR_LIT>' <EOL> def get_username_field ( ) : <EOL> if django . VERSION [ : <NUM_LIT:2> ] >= ( <NUM_LIT:1> , <NUM_LIT:5> ) : <EOL> return get_user_model ( ) . USERNAME_FIELD <EOL> else : <EOL> return '<STR_LIT:username>' <EOL> def get_user_frozen_models ( user_model ) : <EOL> from south . creator . freezer import freeze_apps <EOL> user_app , user_class = user_model . split ( '<STR_LIT:.>' ) <EOL> if user_model != '<STR_LIT>' : <EOL> from south . migration . base import Migrations <EOL> from south . exceptions import NoMigrations <EOL> try : <EOL> user_migrations = Migrations ( user_app ) <EOL> except NoMigrations : <EOL> extra_model = freeze_apps ( user_app ) <EOL> else : <EOL> from pybb import defaults <EOL> migration_name = defaults . PYBB_INITIAL_CUSTOM_USER_MIGRATION or '<STR_LIT>' <EOL> initial_user_migration = user_migrations . migration ( migration_name ) <EOL> extra_model = initial_user_migration . migration_class ( ) . models <EOL> else : <EOL> extra_model = freeze_apps ( user_app ) <EOL> return extra_model <EOL> def get_atomic_func ( ) : <EOL> try : <EOL> from django . db . transaction import atomic as atomic_func <EOL> except ImportError : <EOL> from django . db . transaction import commit_on_success as atomic_func <EOL> return atomic_func <EOL> def get_paginator_class ( ) : <EOL> try : <EOL> from pure_pagination import Paginator <EOL> pure_pagination = True <EOL> except ImportError : <EOL> from django . core . paginator import Paginator , Page <EOL> class PageRepr ( int ) : <EOL> def querystring ( self ) : <EOL> return '<STR_LIT>' % self <EOL>", "answer": "Page . pages = lambda self : [ PageRepr ( i ) for i in range ( <NUM_LIT:1> , self . paginator . num_pages + <NUM_LIT:1> ) ]"}, {"prompt": "<s> import sys <EOL> import os <EOL> import subprocess <EOL> import tempfile <EOL> import shutil <EOL> import argparse <EOL> def Parser ( ) : <EOL> the_parser = argparse . ArgumentParser ( <EOL> description = \"<STR_LIT>\" ) <EOL> the_parser . add_argument ( <EOL> '<STR_LIT>' , action = \"<STR_LIT:store>\" , type = str , help = \"<STR_LIT>\" ) <EOL> the_parser . add_argument ( <EOL> '<STR_LIT>' , dest = \"<STR_LIT>\" , action = \"<STR_LIT:store>\" , type = str , help = \"<STR_LIT>\" ) <EOL> the_parser . add_argument ( '<STR_LIT>' , action = \"<STR_LIT:store>\" , type = str , <EOL> help = \"<STR_LIT>\" ) <EOL> the_parser . add_argument ( '<STR_LIT>' , dest = \"<STR_LIT>\" , action = \"<STR_LIT:store>\" , <EOL> type = str , help = \"<STR_LIT>\" ) <EOL> the_parser . add_argument ( <EOL> '<STR_LIT>' , dest = \"<STR_LIT>\" , action = \"<STR_LIT:store>\" , type = str , help = \"<STR_LIT>\" ) <EOL> the_parser . add_argument ( <EOL> '<STR_LIT>' , action = \"<STR_LIT:store>\" , type = str , help = \"<STR_LIT>\" ) <EOL> the_parser . add_argument ( <EOL> '<STR_LIT>' , dest = \"<STR_LIT>\" , action = \"<STR_LIT:store>\" , type = str , help = \"<STR_LIT>\" ) <EOL> the_parser . add_argument ( '<STR_LIT>' , dest = \"<STR_LIT>\" , <EOL> action = \"<STR_LIT:store>\" , type = str , help = \"<STR_LIT>\" ) <EOL> the_parser . add_argument ( <EOL> '<STR_LIT>' , action = \"<STR_LIT:store>\" , type = str , help = \"<STR_LIT>\" ) <EOL> the_parser . add_argument ( '<STR_LIT>' , action = \"<STR_LIT:store>\" , <EOL> type = str , help = \"<STR_LIT>\" ) <EOL> the_parser . add_argument ( '<STR_LIT>' , dest = \"<STR_LIT>\" , <EOL> action = \"<STR_LIT:store>\" , type = str , help = \"<STR_LIT>\" ) <EOL> args = the_parser . parse_args ( ) <EOL> return args <EOL> def stop_err ( msg ) : <EOL> sys . stderr . write ( '<STR_LIT>' % msg ) <EOL> sys . exit ( ) <EOL> def bowtieCommandLiner ( alignment_method = \"<STR_LIT>\" , v_mis = \"<STR_LIT:1>\" , out_type = \"<STR_LIT>\" , <EOL> aligned = \"<STR_LIT:None>\" , unaligned = \"<STR_LIT:None>\" , input_format = \"<STR_LIT>\" , input = \"<STR_LIT:path>\" , <EOL> index = \"<STR_LIT:path>\" , output = \"<STR_LIT:path>\" , pslots = \"<STR_LIT:4>\" ) : <EOL> if input_format == \"<STR_LIT>\" : <EOL> input_format = \"<STR_LIT>\" <EOL> elif ( input_format == \"<STR_LIT>\" ) or ( input_format == \"<STR_LIT>\" ) : <EOL> input_format = \"<STR_LIT>\" <EOL> else : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> if alignment_method == \"<STR_LIT>\" : <EOL> x = \"<STR_LIT>\" % ( <EOL> v_mis , pslots ) <EOL> elif alignment_method == \"<STR_LIT>\" : <EOL> x = \"<STR_LIT>\" % ( v_mis , pslots ) <EOL> elif alignment_method == \"<STR_LIT>\" : <EOL> x = \"<STR_LIT>\" % ( <EOL> v_mis , pslots ) <EOL> elif alignment_method == \"<STR_LIT>\" : <EOL> x = \"<STR_LIT>\" % ( v_mis , pslots ) <EOL> elif alignment_method == \"<STR_LIT>\" : <EOL> x = \"<STR_LIT>\" % ( v_mis , pslots ) <EOL> elif alignment_method == \"<STR_LIT>\" : <EOL> x = \"<STR_LIT>\" % ( v_mis , pslots ) <EOL> if aligned == \"<STR_LIT:None>\" and unaligned == \"<STR_LIT:None>\" : <EOL> fasta_command = \"<STR_LIT>\" <EOL> elif aligned != \"<STR_LIT:None>\" and unaligned == \"<STR_LIT:None>\" : <EOL> fasta_command = \"<STR_LIT>\" % aligned <EOL> elif aligned == \"<STR_LIT:None>\" and unaligned != \"<STR_LIT:None>\" : <EOL> fasta_command = \"<STR_LIT>\" % unaligned <EOL> else : <EOL> fasta_command = \"<STR_LIT>\" % ( aligned , unaligned ) <EOL> x = x + fasta_command <EOL> if out_type == \"<STR_LIT>\" : <EOL> return \"<STR_LIT>\" % ( x , index , input_format , input , output ) <EOL> elif out_type == \"<STR_LIT>\" : <EOL> return \"<STR_LIT>\" % ( x , index , input_format , input , output ) <EOL> elif out_type == \"<STR_LIT>\" : <EOL> return \"<STR_LIT>\" % ( <EOL> x , index , input_format , input , output ) <EOL> def bowtie_squash ( fasta ) : <EOL> tmp_index_dir = tempfile . mkdtemp ( ) <EOL> ref_file = tempfile . NamedTemporaryFile ( dir = tmp_index_dir ) <EOL> ref_file_name = ref_file . name <EOL> ref_file . close ( ) <EOL> os . symlink ( fasta , ref_file_name ) <EOL> cmd1 = '<STR_LIT>' % ( ref_file_name , ref_file_name ) <EOL> try : <EOL> FNULL = open ( os . devnull , '<STR_LIT:w>' ) <EOL> tmp = tempfile . NamedTemporaryFile ( dir = tmp_index_dir ) . name <EOL> tmp_stderr = open ( tmp , '<STR_LIT:wb>' ) <EOL> proc = subprocess . Popen ( <EOL> args = cmd1 , shell = True , cwd = tmp_index_dir , stderr = FNULL , stdout = FNULL ) <EOL> returncode = proc . wait ( ) <EOL> tmp_stderr . close ( ) <EOL> FNULL . close ( ) <EOL> sys . stdout . write ( cmd1 + \"<STR_LIT:\\n>\" ) <EOL> except Exception as e : <EOL> if os . path . exists ( tmp_index_dir ) : <EOL> shutil . rmtree ( tmp_index_dir ) <EOL> stop_err ( '<STR_LIT>' + str ( e ) ) <EOL> index_full_path = os . path . join ( tmp_index_dir , ref_file_name ) <EOL> return tmp_index_dir , index_full_path <EOL> def bowtie_alignment ( command_line , flyPreIndexed = '<STR_LIT>' ) : <EOL> tmp_index_dir = tempfile . mkdtemp ( ) <EOL> tmp = tempfile . NamedTemporaryFile ( dir = tmp_index_dir ) . name <EOL> tmp_stderr = open ( tmp , '<STR_LIT:wb>' ) <EOL> if \"<STR_LIT>\" in command_line : <EOL> target_file = command_line . split ( ) [ - <NUM_LIT:1> ] <EOL> path_to_unsortedBam = os . path . join ( tmp_index_dir , \"<STR_LIT>\" ) <EOL> path_to_sortedBam = os . path . join ( tmp_index_dir , \"<STR_LIT>\" ) <EOL> first_command_line = \"<STR_LIT:U+0020>\" . join ( <EOL> command_line . split ( ) [ : - <NUM_LIT:3> ] ) + \"<STR_LIT>\" + path_to_unsortedBam + \"<STR_LIT>\" <EOL> second_command_line = \"<STR_LIT>\" % ( <EOL> path_to_unsortedBam , path_to_sortedBam ) <EOL> p = subprocess . Popen ( <EOL> args = first_command_line , cwd = tmp_index_dir , shell = True , stderr = tmp_stderr . fileno ( ) ) <EOL>", "answer": "returncode = p . wait ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . constants import CONTENT_TYPE as CT <EOL> default_content_types = ( <EOL> ( '<STR_LIT>' , CT . PML_PRINTER_SETTINGS ) , <EOL> ( '<STR_LIT>' , CT . SML_PRINTER_SETTINGS ) , <EOL> ( '<STR_LIT>' , CT . WML_PRINTER_SETTINGS ) , <EOL> ( '<STR_LIT>' , CT . BMP ) , <EOL> ( '<STR_LIT>' , CT . X_EMF ) , <EOL> ( '<STR_LIT>' , CT . X_FONTDATA ) , <EOL> ( '<STR_LIT>' , CT . GIF ) , <EOL> ( '<STR_LIT>' , CT . JPEG ) , <EOL> ( '<STR_LIT>' , CT . JPEG ) , <EOL> ( '<STR_LIT>' , CT . JPEG ) , <EOL> ( '<STR_LIT>' , CT . PNG ) , <EOL>", "answer": "( '<STR_LIT>' , CT . OPC_RELATIONSHIPS ) ,"}, {"prompt": "<s> import caffe <EOL> import numpy as np <EOL> import cv2 <EOL> import sg_utils as utils <EOL> import cap_eval_utils <EOL> from IPython . core . debugger import Tracer <EOL> def load_model ( prototxt_file , model_file , base_image_size , mean , vocab ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> model = { } ; <EOL> model [ '<STR_LIT>' ] = caffe . Net ( prototxt_file , model_file , caffe . TEST ) ; <EOL> model [ '<STR_LIT>' ] = base_image_size ; <EOL> model [ '<STR_LIT>' ] = mean ; model [ '<STR_LIT>' ] = vocab ; <EOL> return model <EOL> def output_words_image ( threshold_metric , output_metric , min_words , threshold , vocab , is_functional ) : <EOL> ind_output = np . argsort ( threshold_metric ) <EOL> ind_output = ind_output [ : : - <NUM_LIT:1> ] <EOL> must_keep1 = threshold_metric [ ind_output ] >= threshold ; <EOL> must_keep2 = np . cumsum ( is_functional [ ind_output ] ) < <NUM_LIT:1> + min_words ; <EOL> ind_output = [ ind for j , ind in enumerate ( ind_output ) if must_keep1 [ j ] or must_keep2 [ j ] ] <EOL> out = [ ( vocab [ '<STR_LIT>' ] [ ind ] , output_metric [ ind ] , threshold_metric [ ind ] ) for ind in ind_output ] <EOL> return out <EOL> def output_words ( imdb , detection_file , eval_file , vocab , threshold_metric_name , output_metric_name , threshold , min_words , output_file = None , functional_words = [ '<STR_LIT:a>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:to>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dt = utils . load_variables ( detection_file ) ; <EOL> pt = utils . load_variables ( eval_file ) ; <EOL> is_functional = np . array ( [ x not in functional_words for x in vocab [ '<STR_LIT>' ] ] ) ; <EOL> prec = np . zeros ( dt [ '<STR_LIT>' ] . shape ) <EOL> for jj in xrange ( prec . shape [ <NUM_LIT:1> ] ) : <EOL> prec [ : , jj ] = cap_eval_utils . compute_precision_score_mapping ( pt [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ : , jj ] . copy ( ) , pt [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ : , jj ] . copy ( ) , dt [ '<STR_LIT>' ] [ : , jj ] ) ; <EOL> utils . tic_toc_print ( <NUM_LIT:1> , '<STR_LIT>' . format ( jj , prec . shape [ <NUM_LIT:1> ] ) ) <EOL> dt [ '<STR_LIT>' ] = prec ; <EOL> out_all = [ ] <EOL> for i in xrange ( imdb . num_images ) : <EOL> out = output_words_image ( dt [ threshold_metric_name ] [ i , : ] , dt [ output_metric_name ] [ i , : ] , min_words , threshold , vocab , is_functional ) <EOL> out_all . append ( out ) <EOL> utils . tic_toc_print ( <NUM_LIT:1> , '<STR_LIT>' . format ( i , imdb . num_images ) ) <EOL> if output_file is not None : <EOL> with open ( output_file , '<STR_LIT>' ) as f : <EOL> for i in xrange ( imdb . num_images ) : <EOL> f . write ( '<STR_LIT>' . format ( imdb . image_index [ i ] ) ) <EOL> out = out_all [ i ] <EOL> for j in xrange ( len ( out ) ) : <EOL> f . write ( '<STR_LIT>' . format ( out [ j ] [ <NUM_LIT:0> ] , out [ j ] [ <NUM_LIT:1> ] ) ) <EOL> f . write ( '<STR_LIT:\\n>' ) <EOL> def test_model ( imdb , model , detection_file = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> N_WORDS = len ( model [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> sc = np . zeros ( ( imdb . num_images , N_WORDS ) , dtype = np . float ) <EOL> mil_prob = np . zeros ( ( imdb . num_images , N_WORDS ) , dtype = np . float ) <EOL> for i in xrange ( len ( imdb . image_index ) ) : <EOL> im = cv2 . imread ( imdb . image_path_at ( i ) ) <EOL> sc [ i , : ] , mil_prob [ i , : ] = test_img ( im , model [ '<STR_LIT>' ] , model [ '<STR_LIT>' ] , model [ '<STR_LIT>' ] ) <EOL> utils . tic_toc_print ( <NUM_LIT> , '<STR_LIT>' . format ( i , len ( imdb . image_index ) ) ) <EOL> if detection_file is not None : <EOL> utils . save_variables ( detection_file , [ sc , mil_prob , model [ '<STR_LIT>' ] , imdb ] , <EOL> [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , overwrite = True ) <EOL> def benchmark ( imdb , vocab , gt_label , num_references , detection_file , eval_file = None ) : <EOL> dt = utils . load_variables ( detection_file ) <EOL> mil_prob = dt [ '<STR_LIT>' ] ; <EOL> n_words = len ( vocab [ '<STR_LIT>' ] ) <EOL> P = np . zeros ( mil_prob . shape , dtype = np . float ) <EOL> R = np . zeros ( mil_prob . shape , dtype = np . float ) <EOL> score = np . zeros ( mil_prob . shape , dtype = np . float ) <EOL> ap = np . zeros ( ( <NUM_LIT:1> , n_words ) , dtype = np . float ) <EOL> human_prec = np . zeros ( ( <NUM_LIT:1> , n_words ) , dtype = np . float ) <EOL> human_rec = np . zeros ( ( <NUM_LIT:1> , n_words ) , dtype = np . float ) <EOL> prec_at_human_rec = np . zeros ( ( <NUM_LIT:1> , n_words ) , dtype = np . float ) <EOL> rec_at_human_prec = np . zeros ( ( <NUM_LIT:1> , n_words ) , dtype = np . float ) <EOL> rec_at_half_prec = np . zeros ( ( <NUM_LIT:1> , n_words ) , dtype = np . float ) <EOL> prec_at_human_rec [ ... ] = np . nan <EOL> for i in range ( len ( vocab [ '<STR_LIT>' ] ) ) : <EOL> utils . tic_toc_print ( <NUM_LIT:1> , '<STR_LIT>' . format ( i , n_words ) ) <EOL> P [ : , i ] , R [ : , i ] , score [ : , i ] , ap [ <NUM_LIT:0> , i ] = cap_eval_utils . calc_pr_ovr ( gt_label [ : , i ] , mil_prob [ : , i ] , num_references ) <EOL> human_prec [ <NUM_LIT:0> , i ] , human_rec [ <NUM_LIT:0> , i ] = cap_eval_utils . human_agreement ( gt_label [ : , i ] , num_references ) <EOL> ind = np . where ( R [ : , i ] >= human_rec [ <NUM_LIT:0> , i ] ) [ <NUM_LIT:0> ] <EOL> if len ( ind ) > <NUM_LIT:0> : <EOL> ind = np . sort ( ind ) <EOL> prec_at_human_rec [ <NUM_LIT:0> , i ] = P [ ind [ <NUM_LIT:0> ] , i ] ; <EOL> ind = np . where ( P [ : , i ] >= human_prec [ <NUM_LIT:0> , i ] ) [ <NUM_LIT:0> ] <EOL> if len ( ind ) > <NUM_LIT:0> : <EOL> ind = np . sort ( ind ) <EOL> rec_at_human_prec [ <NUM_LIT:0> , i ] = R [ ind [ - <NUM_LIT:1> ] , i ] ; <EOL>", "answer": "ind = np . where ( P [ : , i ] >= <NUM_LIT:0.5> ) [ <NUM_LIT:0> ]"}, {"prompt": "<s> import os <EOL> import json <EOL> import itertools <EOL> from lxml import etree <EOL> from traverse import traverse , indent , LANGUAGES , COUNTRIES <EOL> BASE_XML = '<STR_LIT>' <EOL> def check_locale ( locale ) : <EOL> locale_parts = locale . split ( '<STR_LIT:->' ) <EOL> if len ( locale_parts ) > <NUM_LIT:0> and locale_parts [ <NUM_LIT:0> ] not in LANGUAGES : <EOL> print \"<STR_LIT>\" % locale . encode ( '<STR_LIT:utf8>' ) <EOL> return False <EOL> elif len ( locale_parts ) > <NUM_LIT:1> and locale_parts [ <NUM_LIT:1> ] [ <NUM_LIT:1> : ] not in COUNTRIES : <EOL> print \"<STR_LIT>\" % locale . encode ( '<STR_LIT:utf8>' ) <EOL> return False <EOL> return True <EOL> def process_pack ( root_dir , server_pack ) : <EOL> server_pack = dict ( ( x [ '<STR_LIT:name>' ] , x ) for x in server_pack ) <EOL> update_pack = { } <EOL> def remove_unused ( el , subel , kind , designator , locale , name , canonic_name , text , filename , priority , context ) : <EOL> if locale is None : <EOL> if canonic_name in server_pack : <EOL> update_pack [ canonic_name ] = server_pack [ canonic_name ] <EOL> return False <EOL> def check_rec ( el , subel , kind , designator , locale , name , canonic_name , text , filename , priority , context ) : <EOL> modified = False <EOL> if locale is not None : <EOL> localized = update_pack . get ( canonic_name , { } ) . get ( '<STR_LIT>' , { } ) <EOL> text = localized . get ( locale ) <EOL> if text is not None : <EOL> if check_locale ( locale ) and subel . text != text : <EOL> subel . text = text <EOL> print canonic_name , \"<STR_LIT>\" , locale , \"<STR_LIT>\" , text . encode ( '<STR_LIT:utf8>' ) <EOL> modified = True <EOL> del localized [ locale ] <EOL> if len ( localized ) == <NUM_LIT:0> : <EOL> del update_pack [ canonic_name ] <EOL> return modified <EOL> traverse ( root_dir , remove_unused ) <EOL> traverse ( root_dir , check_rec ) <EOL> to_write = sorted ( update_pack . values ( ) , key = lambda x : ( x [ '<STR_LIT:filename>' ] , x [ '<STR_LIT:name>' ] ) ) <EOL> to_write = itertools . groupby ( to_write , lambda x : x [ '<STR_LIT:filename>' ] ) <EOL> for filename , resources in to_write : <EOL> filename = filename . lstrip ( os . path . sep ) <EOL> filename = os . path . join ( root_dir , filename ) <EOL> for res in resources : <EOL> for locale , text in res . get ( '<STR_LIT>' ) . iteritems ( ) : <EOL> if not check_locale ( locale ) : <EOL> continue <EOL> localized_filename = filename . replace ( os . path . sep + '<STR_LIT>' + os . path . sep , os . path . sep + '<STR_LIT>' % locale + os . path . sep ) <EOL> if not os . path . isfile ( localized_filename ) : <EOL> if not os . path . exists ( os . path . dirname ( localized_filename ) ) : <EOL> os . makedirs ( os . path . dirname ( localized_filename ) ) <EOL> dummy = open ( localized_filename , '<STR_LIT:w>' ) <EOL> dummy . write ( BASE_XML ) <EOL> dummy . close ( ) <EOL> parser = etree . XMLParser ( remove_blank_text = True ) <EOL> tree = etree . parse ( localized_filename , parser ) <EOL>", "answer": "root = tree . getroot ( )"}, {"prompt": "<s> from django import template <EOL> register = template . Library ( ) <EOL>", "answer": "@ register . simple_tag"}, {"prompt": "<s> from south . db import db <EOL> from django . db import models <EOL> from cmsplugin_filer_image . models import * <EOL> class Migration : <EOL> depends_on = ( <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ) <EOL> def forwards ( self , orm ) : <EOL> db . create_table ( '<STR_LIT>' , ( <EOL> ( '<STR_LIT>' , orm [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT:image>' , orm [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , orm [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , orm [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , orm [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT:width>' , orm [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , orm [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT:float>' , orm [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , orm [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , orm [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT:description>' , orm [ '<STR_LIT>' ] ) , <EOL> ) ) <EOL> db . send_create_signal ( '<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> def backwards ( self , orm ) : <EOL> db . delete_table ( '<STR_LIT>' ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:password>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:username>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:5>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL>", "answer": "'<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' } ) ,"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from celery import shared_task <EOL> from pyiso import client_factory <EOL> import logging <EOL> from datetime import datetime <EOL> logger = logging . getLogger ( __name__ ) <EOL> @ shared_task <EOL> def get_generation ( ba_name , ** kwargs ) : <EOL> c = client_factory ( ba_name ) <EOL> data = c . get_generation ( ** kwargs ) <EOL> if len ( data ) == <NUM_LIT:0> : <EOL> msg = '<STR_LIT>' % ( ba_name , datetime . utcnow ( ) . isoformat ( ) , <EOL> kwargs ) <EOL> logger . warn ( msg ) <EOL> return data <EOL> @ shared_task <EOL> def get_load ( ba_name , ** kwargs ) : <EOL> c = client_factory ( ba_name ) <EOL> data = c . get_load ( ** kwargs ) <EOL> if len ( data ) == <NUM_LIT:0> : <EOL> msg = '<STR_LIT>' % ( ba_name , datetime . utcnow ( ) . isoformat ( ) , <EOL> kwargs ) <EOL> logger . warn ( msg ) <EOL> return data <EOL> @ shared_task <EOL> def get_trade ( ba_name , ** kwargs ) : <EOL> c = client_factory ( ba_name ) <EOL> data = c . get_trade ( ** kwargs ) <EOL> if len ( data ) == <NUM_LIT:0> : <EOL>", "answer": "msg = '<STR_LIT>' % ( ba_name , datetime . utcnow ( ) . isoformat ( ) ,"}, {"prompt": "<s> COUNTDOWNLATCH_AWAIT = <NUM_LIT> <EOL> COUNTDOWNLATCH_COUNTDOWN = <NUM_LIT> <EOL>", "answer": "COUNTDOWNLATCH_GETCOUNT = <NUM_LIT>"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> xmldata = \"\"\"<STR_LIT>\"\"\" <EOL> import android , random <EOL> from fullscreenwrapper2 import * <EOL> class DemoLayout ( Layout ) : <EOL> def __init__ ( self ) : <EOL> super ( DemoLayout , self ) . __init__ ( xmldata , \"<STR_LIT>\" ) <EOL> def on_show ( self ) : <EOL> self . add_event ( key_EventHandler ( handler_function = self . close_app ) ) <EOL> self . views . but_change . add_event ( click_EventHandler ( self . views . but_change , self . change_color ) ) <EOL> self . views . but_exit . add_event ( click_EventHandler ( self . views . but_exit , self . close_app ) ) <EOL> def on_close ( self ) : <EOL> pass <EOL> def close_app ( self , view , event ) : <EOL> FullScreenWrapper2App . exit_FullScreenWrapper2App ( ) <EOL> def change_color ( self , view , event ) : <EOL> colorvalue = \"<STR_LIT>\" + self . get_rand_hex_byte ( ) + self . get_rand_hex_byte ( ) + self . get_rand_hex_byte ( ) <EOL> self . views . txt_colorbox . background = colorvalue <EOL> def get_rand_hex_byte ( self ) : <EOL> j = random . randint ( <NUM_LIT:0> , <NUM_LIT:255> ) <EOL> hexrep = hex ( j ) [ <NUM_LIT:2> : ] <EOL> if ( len ( hexrep ) == <NUM_LIT:1> ) : <EOL> hexrep = '<STR_LIT:0>' + hexrep <EOL> return hexrep <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> droid = android . Android ( ) <EOL> random . seed ( ) <EOL> FullScreenWrapper2App . initialize ( droid ) <EOL>", "answer": "FullScreenWrapper2App . show_layout ( DemoLayout ( ) )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> from setuptools import setup <EOL> except ImportError : <EOL> from distutils . core import setup <EOL> setup ( name = '<STR_LIT>' , <EOL>", "answer": "version = '<STR_LIT>' ,"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import migrations <EOL> def remove_deleted_migrations ( apps , schema_editor ) : <EOL> Translation = apps . get_model ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> for t in Translation . objects . filter ( deleted__isnull = False ) : <EOL> t . delete ( ) <EOL> def noop ( apps , schema_editor ) : <EOL> pass <EOL> class Migration ( migrations . Migration ) : <EOL>", "answer": "dependencies = ["}, {"prompt": "<s> from pikos . monitors . line_memory_monitor import LineMemoryMonitor <EOL> from pikos . monitors . focused_line_mixin import FocusedLineMixin <EOL> class FocusedLineMemoryMonitor ( FocusedLineMixin , LineMemoryMonitor ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\" "}, {"prompt": "<s> import time <EOL> import sys <EOL> from dashvend . logger import info <EOL> from dashvend . addresses import Bip32Chain <EOL> from dashvend . dashrpc import DashRPC <EOL> from dashvend . dash_ix import InstantX <EOL> from dashvend . dash_p2p import DashP2P <EOL>", "answer": "from dashvend . vend import Vend"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import migrations , models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AlterField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL>", "answer": "field = models . GenericIPAddressField ( blank = True , null = True ) ,"}, {"prompt": "<s> import sys <EOL> from weakref import WeakKeyDictionary <EOL> from atom . api import Typed <EOL> from enaml . widgets . notebook import ProxyNotebook <EOL> from . QtCore import Qt , QEvent , Signal <EOL> from . QtGui import QTabWidget , QTabBar , QResizeEvent , QApplication <EOL> from . qt_constraints_widget import QtConstraintsWidget <EOL> from . qt_page import QtPage <EOL> TAB_POSITIONS = { <EOL> '<STR_LIT>' : QTabWidget . North , <EOL> '<STR_LIT>' : QTabWidget . South , <EOL> '<STR_LIT:left>' : QTabWidget . West , <EOL> '<STR_LIT:right>' : QTabWidget . East , <EOL> } <EOL> DOCUMENT_MODES = { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : False , <EOL> } <EOL> class QNotebook ( QTabWidget ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> layoutRequested = Signal ( ) <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( QNotebook , self ) . __init__ ( * args , ** kwargs ) <EOL> self . tabCloseRequested . connect ( self . onTabCloseRequested ) <EOL> self . _hidden_pages = WeakKeyDictionary ( ) <EOL> def _refreshTabBar ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> app = QApplication . instance ( ) <EOL> if app is not None : <EOL> bar = self . tabBar ( ) <EOL> size = bar . size ( ) <EOL> event = QResizeEvent ( size , size ) <EOL> app . sendEvent ( bar , event ) <EOL> size = self . size ( ) <EOL> event = QResizeEvent ( size , size ) <EOL> app . sendEvent ( self , event ) <EOL> def onTabCloseRequested ( self , index ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . widget ( index ) . requestClose ( ) <EOL> def event ( self , event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> res = super ( QNotebook , self ) . event ( event ) <EOL> if event . type ( ) == QEvent . LayoutRequest : <EOL> self . layoutRequested . emit ( ) <EOL> return res <EOL> def showPage ( self , page ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> index = self . indexOf ( page ) <EOL> if index == - <NUM_LIT:1> : <EOL> index = self . _hidden_pages . pop ( page , - <NUM_LIT:1> ) <EOL> if index != - <NUM_LIT:1> : <EOL> self . insertPage ( index , page ) <EOL> def hidePage ( self , page ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> index = self . indexOf ( page ) <EOL> if index != - <NUM_LIT:1> : <EOL> self . removeTab ( index ) <EOL> page . hide ( ) <EOL> self . _hidden_pages [ page ] = index <EOL> def addPage ( self , page ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . insertPage ( self . count ( ) , page ) <EOL> def insertPage ( self , index , page ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if page . isOpen ( ) : <EOL> index = min ( index , self . count ( ) ) <EOL> self . insertTab ( index , page , page . title ( ) ) <EOL> self . setTabIcon ( index , page . icon ( ) ) <EOL> self . setTabToolTip ( index , page . toolTip ( ) ) <EOL> self . setTabEnabled ( index , page . isTabEnabled ( ) ) <EOL> self . setTabCloseButtonVisible ( index , page . isClosable ( ) ) <EOL> else : <EOL> page . hide ( ) <EOL> self . _hidden_pages [ page ] = index <EOL> def removePage ( self , page ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> index = self . indexOf ( page ) <EOL>", "answer": "if index != - <NUM_LIT:1> :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys , os <EOL> from timeit import default_timer as clock <EOL> if \"<STR_LIT>\" in sys . argv : <EOL> sys . argv . remove ( '<STR_LIT>' ) <EOL> import psyco <EOL> psyco . full ( ) <EOL> if \"<STR_LIT>\" in sys . argv : <EOL> sys . argv . remove ( '<STR_LIT>' ) <EOL> os . environ [ '<STR_LIT>' ] = '<STR_LIT:Y>' <EOL> filt = '<STR_LIT>' <EOL> if not sys . argv [ - <NUM_LIT:1> ] . endswith ( \"<STR_LIT>\" ) : <EOL> filt = sys . argv [ - <NUM_LIT:1> ] <EOL> from mpmath import * <EOL> from mpmath . libmp . backend import exec_ <EOL> def test_asymp ( f , maxdps = <NUM_LIT> , verbose = False , huge_range = False ) : <EOL> dps = [ <NUM_LIT:5> , <NUM_LIT:15> , <NUM_LIT> , <NUM_LIT:50> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> dps = [ p for p in dps if p <= maxdps ] <EOL> def check ( x , y , p , inpt ) : <EOL> if abs ( x - y ) / abs ( y ) < workprec ( <NUM_LIT:20> ) ( power ) ( <NUM_LIT:10> , - p + <NUM_LIT:1> ) : <EOL> return <EOL> print ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( \"<STR_LIT>\" , inpt ) <EOL> print ( \"<STR_LIT>\" , p ) <EOL> print ( \"<STR_LIT>\" , x ) <EOL> print ( \"<STR_LIT>\" , y ) <EOL> print ( \"<STR_LIT>\" , abs ( x - y ) ) <EOL> print ( \"<STR_LIT>\" , abs ( x - y ) / abs ( y ) ) <EOL> raise AssertionError <EOL> exponents = range ( - <NUM_LIT:20> , <NUM_LIT:20> ) <EOL> if huge_range : <EOL> exponents += [ - <NUM_LIT:1000> , - <NUM_LIT:100> , - <NUM_LIT:50> , <NUM_LIT:50> , <NUM_LIT:100> , <NUM_LIT:1000> ] <EOL> for n in exponents : <EOL> if verbose : <EOL> sys . stdout . write ( \"<STR_LIT>\" ) <EOL> mp . dps = <NUM_LIT> <EOL> xpos = mpf ( <NUM_LIT:10> ) ** n / <NUM_LIT> <EOL> xneg = - xpos <EOL> ximag = xpos * j <EOL> xcomplex1 = xpos * ( <NUM_LIT:1> + j ) <EOL> xcomplex2 = xpos * ( - <NUM_LIT:1> + j ) <EOL> for i in range ( len ( dps ) ) : <EOL> if verbose : <EOL> print ( \"<STR_LIT>\" % dps [ i ] ) <EOL> mp . dps = dps [ i ] <EOL> new = f ( xpos ) , f ( xneg ) , f ( ximag ) , f ( xcomplex1 ) , f ( xcomplex2 ) <EOL> if i != <NUM_LIT:0> : <EOL> p = dps [ i - <NUM_LIT:1> ] <EOL> check ( prev [ <NUM_LIT:0> ] , new [ <NUM_LIT:0> ] , p , xpos ) <EOL> check ( prev [ <NUM_LIT:1> ] , new [ <NUM_LIT:1> ] , p , xneg ) <EOL> check ( prev [ <NUM_LIT:2> ] , new [ <NUM_LIT:2> ] , p , ximag ) <EOL> check ( prev [ <NUM_LIT:3> ] , new [ <NUM_LIT:3> ] , p , xcomplex1 ) <EOL>", "answer": "check ( prev [ <NUM_LIT:4> ] , new [ <NUM_LIT:4> ] , p , xcomplex2 )"}, {"prompt": "<s> from __future__ import absolute_import , unicode_literals <EOL> from django . conf import settings as django_settings <EOL> from django . contrib import admin <EOL> from django . core . exceptions import ImproperlyConfigured <EOL> from django . db import models <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from feincms import settings <EOL> from feincms . admin . item_editor import FeinCMSInline <EOL> from feincms . contrib . richtext import RichTextField <EOL> from feincms . module . medialibrary . fields import MediaFileForeignKey <EOL> from feincms . module . medialibrary . models import MediaFile <EOL> class SectionContentInline ( FeinCMSInline ) : <EOL> raw_id_fields = ( '<STR_LIT>' , ) <EOL> radio_fields = { '<STR_LIT:type>' : admin . VERTICAL } <EOL> class SectionContent ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> feincms_item_editor_inline = SectionContentInline <EOL> feincms_item_editor_context_processors = ( <EOL> lambda x : settings . FEINCMS_RICHTEXT_INIT_CONTEXT , <EOL> ) <EOL> feincms_item_editor_includes = { <EOL> '<STR_LIT>' : [ settings . FEINCMS_RICHTEXT_INIT_TEMPLATE ] , <EOL> } <EOL> title = models . CharField ( _ ( '<STR_LIT:title>' ) , max_length = <NUM_LIT:200> , blank = True ) <EOL> richtext = RichTextField ( _ ( '<STR_LIT:text>' ) , blank = True ) <EOL> mediafile = MediaFileForeignKey ( <EOL> MediaFile , verbose_name = _ ( '<STR_LIT>' ) , <EOL> related_name = '<STR_LIT:+>' , blank = True , null = True ) <EOL> class Meta : <EOL> abstract = True <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> verbose_name_plural = _ ( '<STR_LIT>' ) <EOL> @ classmethod <EOL> def initialize_type ( cls , TYPE_CHOICES = None , cleanse = None ) : <EOL> if '<STR_LIT>' not in django_settings . INSTALLED_APPS : <EOL> raise ImproperlyConfigured ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' % cls . __name__ ) <EOL> if TYPE_CHOICES is None : <EOL> raise ImproperlyConfigured ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' % cls . __name__ ) <EOL> cls . add_to_class ( '<STR_LIT:type>' , models . CharField ( <EOL> _ ( '<STR_LIT:type>' ) , <EOL> max_length = <NUM_LIT:10> , choices = TYPE_CHOICES , <EOL> default = TYPE_CHOICES [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] <EOL> ) ) <EOL> if cleanse : <EOL> cls . cleanse = cleanse <EOL> @ classmethod <EOL> def get_queryset ( cls , filter_args ) : <EOL>", "answer": "return cls . objects . select_related ( '<STR_LIT>' , '<STR_LIT>' ) . filter ("}, {"prompt": "<s> from django . db . models import Model <EOL>", "answer": "def get_object_list ( user , model_cls , pk_field = '<STR_LIT:id>' ) :"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from __future__ import unicode_literals <EOL> from scrapi . base import OAIHarvester <EOL> from scrapi . base import helpers <EOL> def oai_process_uris_addis_ababa ( * args ) : <EOL> identifiers = helpers . gather_identifiers ( args ) <EOL> provider_uris , object_uris = helpers . seperate_provider_object_uris ( <EOL> list ( map ( lambda x : x . replace ( '<STR_LIT>' , '<STR_LIT>' ) , identifiers ) ) <EOL> ) <EOL> potential_uris = ( provider_uris + object_uris ) <EOL> try : <EOL> canonical_uri = potential_uris [ <NUM_LIT:0> ] <EOL>", "answer": "except IndexError :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Static ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> from __future__ import unicode_literals , absolute_import <EOL> from mock import MagicMock , ANY <EOL> from ... . unittest import TestCase <EOL> from oauthlib . oauth1 . rfc5849 import Client <EOL> from oauthlib . oauth1 import RequestValidator <EOL> from oauthlib . oauth1 . rfc5849 . endpoints import ResourceEndpoint <EOL> class ResourceEndpointTest ( TestCase ) : <EOL> def setUp ( self ) : <EOL> self . validator = MagicMock ( wraps = RequestValidator ( ) ) <EOL> self . validator . check_client_key . return_value = True <EOL> self . validator . check_access_token . return_value = True <EOL> self . validator . allowed_signature_methods = [ '<STR_LIT>' ] <EOL> self . validator . get_client_secret . return_value = '<STR_LIT:bar>' <EOL> self . validator . get_access_token_secret . return_value = '<STR_LIT>' <EOL> self . validator . timestamp_lifetime = <NUM_LIT> <EOL> self . validator . validate_client_key . return_value = True <EOL> self . validator . validate_access_token . return_value = True <EOL> self . validator . validate_timestamp_and_nonce . return_value = True <EOL> self . validator . validate_realms . return_value = True <EOL> self . validator . dummy_client = '<STR_LIT>' <EOL> self . validator . dummy_secret = '<STR_LIT>' <EOL> self . validator . dummy_access_token = '<STR_LIT>' <EOL> self . endpoint = ResourceEndpoint ( self . validator ) <EOL> self . client = Client ( '<STR_LIT:foo>' , <EOL> client_secret = '<STR_LIT:bar>' , <EOL> resource_owner_key = '<STR_LIT>' , <EOL> resource_owner_secret = '<STR_LIT>' ) <EOL> self . uri , self . headers , self . body = self . client . sign ( <EOL> '<STR_LIT>' ) <EOL> def test_missing_parameters ( self ) : <EOL> self . validator . check_access_token . return_value = False <EOL> v , r = self . endpoint . validate_protected_resource_request ( <EOL> self . uri ) <EOL> self . assertFalse ( v ) <EOL> def test_check_access_token ( self ) : <EOL> self . validator . check_access_token . return_value = False <EOL> v , r = self . endpoint . validate_protected_resource_request ( <EOL> self . uri , headers = self . headers ) <EOL> self . assertFalse ( v ) <EOL> def test_validate_client_key ( self ) : <EOL> self . validator . validate_client_key . return_value = False <EOL> v , r = self . endpoint . validate_protected_resource_request ( <EOL> self . uri , headers = self . headers ) <EOL> self . assertFalse ( v ) <EOL> self . assertFalse ( r . validator_log [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( r . validator_log [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( r . validator_log [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( r . validator_log [ '<STR_LIT>' ] ) <EOL> def test_validate_access_token ( self ) : <EOL> self . validator . validate_access_token . return_value = False <EOL> v , r = self . endpoint . validate_protected_resource_request ( <EOL> self . uri , headers = self . headers ) <EOL> self . assertFalse ( v ) <EOL> self . assertTrue ( r . validator_log [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( r . validator_log [ '<STR_LIT>' ] ) <EOL> self . assertFalse ( r . validator_log [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( r . validator_log [ '<STR_LIT>' ] ) <EOL> def test_validate_realms ( self ) : <EOL> self . validator . validate_realms . return_value = False <EOL> v , r = self . endpoint . validate_protected_resource_request ( <EOL> self . uri , headers = self . headers ) <EOL> self . assertFalse ( v ) <EOL> self . assertTrue ( r . validator_log [ '<STR_LIT>' ] ) <EOL> self . assertFalse ( r . validator_log [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( r . validator_log [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( r . validator_log [ '<STR_LIT>' ] ) <EOL> def test_validate_signature ( self ) : <EOL> client = Client ( '<STR_LIT:foo>' , <EOL> resource_owner_key = '<STR_LIT>' , <EOL> resource_owner_secret = '<STR_LIT>' ) <EOL> _ , headers , _ = client . sign ( self . uri + '<STR_LIT>' ) <EOL>", "answer": "v , r = self . endpoint . validate_protected_resource_request ("}, {"prompt": "<s> from libtree . core . database import * <EOL> from libtree . core . node_data import * <EOL> from libtree . core . properties import * <EOL> from libtree . core . positioning import * <EOL> from libtree . core . query import * <EOL>", "answer": "from libtree . core . tree import * "}, {"prompt": "<s> from django . core . urlresolvers import reverse <EOL> from django . http import HttpResponseRedirect <EOL> from django . utils . decorators import method_decorator <EOL> from django . views . generic import * <EOL> from corehq . apps . style . decorators import use_bootstrap3 <EOL> from corehq . apps . styleguide . palette import ( <EOL> PaletteColor , <EOL> PaletteColorGroup , <EOL> Palette , <EOL> ) <EOL> from corehq . apps . styleguide . example_forms import BasicCrispyForm <EOL> def styleguide_default ( request ) : <EOL> return HttpResponseRedirect ( reverse ( MainStyleGuideView . urlname ) ) <EOL> class MainStyleGuideView ( TemplateView ) : <EOL> template_name = '<STR_LIT>' <EOL> urlname = '<STR_LIT>' <EOL> class BaseStyleGuideArticleView ( TemplateView ) : <EOL> template_name = '<STR_LIT>' <EOL> @ use_bootstrap3 <EOL> def dispatch ( self , request , * args , ** kwargs ) : <EOL> return super ( BaseStyleGuideArticleView , self ) . dispatch ( request , * args , ** kwargs ) <EOL> @ property <EOL> def sections ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( \"<STR_LIT>\" ) <EOL> @ property <EOL> def navigation_name ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( \"<STR_LIT>\" ) <EOL> @ property <EOL> def section_context ( self ) : <EOL> return { <EOL> '<STR_LIT>' : [ '<STR_LIT>' % s <EOL> for s in self . sections ] , <EOL> '<STR_LIT>' : ( '<STR_LIT>' <EOL> % self . navigation_name ) , <EOL> } <EOL> @ property <EOL> def page_context ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return { } <EOL> def render_to_response ( self , context , ** response_kwargs ) : <EOL> context . update ( self . section_context ) <EOL> context . update ( self . page_context ) <EOL> return super ( BaseStyleGuideArticleView , self ) . render_to_response ( <EOL> context , ** response_kwargs ) <EOL> class ClassBasedViewStyleGuideView ( BaseStyleGuideArticleView ) : <EOL> urlname = '<STR_LIT>' <EOL> navigation_name = '<STR_LIT>' <EOL> @ property <EOL> def sections ( self ) : <EOL> return [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> class FormsStyleGuideView ( BaseStyleGuideArticleView ) : <EOL> urlname = '<STR_LIT>' <EOL> navigation_name = '<STR_LIT>' <EOL> @ property <EOL> def sections ( self ) : <EOL> return [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> @ property <EOL> def page_context ( self ) : <EOL> return { <EOL> '<STR_LIT>' : BasicCrispyForm ( ) , <EOL> } <EOL> class IconsStyleGuideView ( BaseStyleGuideArticleView ) : <EOL> urlname = '<STR_LIT>' <EOL> navigation_name = '<STR_LIT>' <EOL> @ property <EOL> def sections ( self ) : <EOL> return [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> class ColorsStyleGuide ( BaseStyleGuideArticleView ) : <EOL> urlname = '<STR_LIT>' <EOL> navigation_name = '<STR_LIT>' <EOL> @ property <EOL> def sections ( self ) : <EOL> return [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> @ property <EOL> def page_context ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . palette , <EOL> } <EOL> @ property <EOL> def palette ( self ) : <EOL> text_color = PaletteColor ( '<STR_LIT>' , ) <EOL> bg_color = PaletteColor ( '<STR_LIT>' , ) <EOL> neutrals = PaletteColorGroup ( <EOL> \"<STR_LIT>\" , <EOL> '<STR_LIT>' , <EOL> PaletteColor ( '<STR_LIT>' , ) , <EOL> PaletteColor ( '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> PaletteColor ( '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> ) <EOL> brand = PaletteColorGroup ( <EOL> \"<STR_LIT>\" , <EOL> '<STR_LIT>' , <EOL> PaletteColor ( '<STR_LIT>' , ) , <EOL> PaletteColor ( '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> PaletteColor ( '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> ) <EOL> light_cool_accent = PaletteColorGroup ( <EOL> \"<STR_LIT>\" , <EOL> '<STR_LIT>' , <EOL> PaletteColor ( '<STR_LIT>' , ) , <EOL> PaletteColor ( '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> PaletteColor ( '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> ) <EOL> dark_warm_accent = PaletteColorGroup ( <EOL> \"<STR_LIT>\" , <EOL> '<STR_LIT>' , <EOL> PaletteColor ( '<STR_LIT>' , ) , <EOL> PaletteColor ( '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> PaletteColor ( '<STR_LIT>' , name = \"<STR_LIT>\" ) , <EOL> ) <EOL> light_warm_accent = PaletteColorGroup ( <EOL> \"<STR_LIT>\" , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> class BaseMatcher ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = None <EOL> def __init__ ( self ) : <EOL> if not self . name : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> self . on_init ( ) <EOL> def on_init ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return None <EOL>", "answer": "def match ( self , request , recorded_request ) :"}, {"prompt": "<s> from hanzo . warctools . record import ArchiveRecord , ArchiveParser <EOL> from hanzo . warctools . warc import WarcParser <EOL> from hanzo . warctools . arc import ArcParser <EOL> class MixedRecord ( ArchiveRecord ) : <EOL> @ classmethod <EOL> def make_parser ( self ) : <EOL> return MixedParser ( ) <EOL> class MixedParser ( ArchiveParser ) : <EOL> def __init__ ( self ) : <EOL> self . arc = ArcParser ( ) <EOL>", "answer": "self . warc = WarcParser ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> try : <EOL> from Queue import Full , Empty <EOL> except ImportError : <EOL> from queue import Full , Empty <EOL> from collections import deque <EOL> import heapq <EOL> from time import time as _time , sleep as _sleep <EOL> from gevent import monkey <EOL> from gevent . _compat import PY3 <EOL> __all__ = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> thread_name = '<STR_LIT>' if PY3 else '<STR_LIT>' <EOL> start_new_thread , Lock , get_ident , local , stack_size = monkey . get_original ( thread_name , [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> class RLock ( object ) : <EOL> def __init__ ( self ) : <EOL> self . __block = Lock ( ) <EOL> self . __owner = None <EOL> self . __count = <NUM_LIT:0> <EOL> def __repr__ ( self ) : <EOL> owner = self . __owner <EOL> return \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ , owner , self . __count ) <EOL> def acquire ( self , blocking = <NUM_LIT:1> ) : <EOL> me = get_ident ( ) <EOL> if self . __owner == me : <EOL> self . __count = self . __count + <NUM_LIT:1> <EOL> return <NUM_LIT:1> <EOL> rc = self . __block . acquire ( blocking ) <EOL> if rc : <EOL> self . __owner = me <EOL> self . __count = <NUM_LIT:1> <EOL> return rc <EOL> __enter__ = acquire <EOL> def release ( self ) : <EOL> if self . __owner != get_ident ( ) : <EOL> raise RuntimeError ( \"<STR_LIT>\" ) <EOL> self . __count = count = self . __count - <NUM_LIT:1> <EOL> if not count : <EOL> self . __owner = None <EOL> self . __block . release ( ) <EOL> def __exit__ ( self , t , v , tb ) : <EOL> self . release ( ) <EOL> def _acquire_restore ( self , count_owner ) : <EOL> count , owner = count_owner <EOL> self . __block . acquire ( ) <EOL> self . __count = count <EOL> self . __owner = owner <EOL> def _release_save ( self ) : <EOL> count = self . __count <EOL> self . __count = <NUM_LIT:0> <EOL> owner = self . __owner <EOL> self . __owner = None <EOL> self . __block . release ( ) <EOL> return ( count , owner ) <EOL> def _is_owned ( self ) : <EOL> return self . __owner == get_ident ( ) <EOL> class Condition ( object ) : <EOL> def __init__ ( self , lock = None ) : <EOL> if lock is None : <EOL> lock = RLock ( ) <EOL> self . __lock = lock <EOL> self . acquire = lock . acquire <EOL> self . release = lock . release <EOL> try : <EOL> self . _release_save = lock . _release_save <EOL> except AttributeError : <EOL> pass <EOL> try : <EOL> self . _acquire_restore = lock . _acquire_restore <EOL> except AttributeError : <EOL> pass <EOL> try : <EOL> self . _is_owned = lock . _is_owned <EOL> except AttributeError : <EOL> pass <EOL> self . __waiters = [ ] <EOL> def __enter__ ( self ) : <EOL> return self . __lock . __enter__ ( ) <EOL> def __exit__ ( self , * args ) : <EOL> return self . __lock . __exit__ ( * args ) <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . __lock , len ( self . __waiters ) ) <EOL> def _release_save ( self ) : <EOL> self . __lock . release ( ) <EOL> def _acquire_restore ( self , x ) : <EOL> self . __lock . acquire ( ) <EOL> def _is_owned ( self ) : <EOL> if self . __lock . acquire ( <NUM_LIT:0> ) : <EOL> self . __lock . release ( ) <EOL> return False <EOL> else : <EOL> return True <EOL> def wait ( self , timeout = None ) : <EOL> if not self . _is_owned ( ) : <EOL> raise RuntimeError ( \"<STR_LIT>\" ) <EOL> waiter = Lock ( ) <EOL> waiter . acquire ( ) <EOL> self . __waiters . append ( waiter ) <EOL> saved_state = self . _release_save ( ) <EOL> try : <EOL> if timeout is None : <EOL> waiter . acquire ( ) <EOL> else : <EOL> endtime = _time ( ) + timeout <EOL> delay = <NUM_LIT> <EOL> while True : <EOL> gotit = waiter . acquire ( <NUM_LIT:0> ) <EOL> if gotit : <EOL> break <EOL> remaining = endtime - _time ( ) <EOL> if remaining <= <NUM_LIT:0> : <EOL> break <EOL> delay = min ( delay * <NUM_LIT:2> , remaining , <NUM_LIT> ) <EOL> _sleep ( delay ) <EOL> if not gotit : <EOL> try : <EOL> self . __waiters . remove ( waiter ) <EOL> except ValueError : <EOL> pass <EOL> finally : <EOL> self . _acquire_restore ( saved_state ) <EOL> def notify ( self , n = <NUM_LIT:1> ) : <EOL> if not self . _is_owned ( ) : <EOL> raise RuntimeError ( \"<STR_LIT>\" ) <EOL> __waiters = self . __waiters <EOL> waiters = __waiters [ : n ] <EOL> if not waiters : <EOL> return <EOL> for waiter in waiters : <EOL> waiter . release ( ) <EOL> try : <EOL> __waiters . remove ( waiter ) <EOL> except ValueError : <EOL> pass <EOL> def notify_all ( self ) : <EOL> self . notify ( len ( self . __waiters ) ) <EOL> class Semaphore ( object ) : <EOL> def __init__ ( self , value = <NUM_LIT:1> ) : <EOL> if value < <NUM_LIT:0> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> self . __cond = Condition ( Lock ( ) ) <EOL> self . __value = value <EOL> def acquire ( self , blocking = <NUM_LIT:1> ) : <EOL> rc = False <EOL> self . __cond . acquire ( ) <EOL> while self . __value == <NUM_LIT:0> : <EOL> if not blocking : <EOL> break <EOL> self . __cond . wait ( ) <EOL> else : <EOL> self . __value = self . __value - <NUM_LIT:1> <EOL> rc = True <EOL> self . __cond . release ( ) <EOL> return rc <EOL> __enter__ = acquire <EOL> def release ( self ) : <EOL> self . __cond . acquire ( ) <EOL> self . __value = self . __value + <NUM_LIT:1> <EOL> self . __cond . notify ( ) <EOL> self . __cond . release ( ) <EOL> def __exit__ ( self , t , v , tb ) : <EOL> self . release ( ) <EOL> class BoundedSemaphore ( Semaphore ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , value = <NUM_LIT:1> ) : <EOL> Semaphore . __init__ ( self , value ) <EOL> self . _initial_value = value <EOL> def release ( self ) : <EOL> if self . Semaphore__value >= self . _initial_value : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return Semaphore . release ( self ) <EOL> class Event ( object ) : <EOL> def __init__ ( self ) : <EOL> self . __cond = Condition ( Lock ( ) ) <EOL> self . __flag = False <EOL> def _reset_internal_locks ( self ) : <EOL> self . __cond . __init__ ( ) <EOL> def is_set ( self ) : <EOL> return self . __flag <EOL> def set ( self ) : <EOL> self . __cond . acquire ( ) <EOL> try : <EOL> self . __flag = True <EOL> self . __cond . notify_all ( ) <EOL> finally : <EOL> self . __cond . release ( ) <EOL> def clear ( self ) : <EOL> self . __cond . acquire ( ) <EOL> try : <EOL> self . __flag = False <EOL> finally : <EOL> self . __cond . release ( ) <EOL> def wait ( self , timeout = None ) : <EOL> self . __cond . acquire ( ) <EOL> try : <EOL> if not self . __flag : <EOL> self . __cond . wait ( timeout ) <EOL> return self . __flag <EOL> finally : <EOL> self . __cond . release ( ) <EOL> class Queue : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , maxsize = <NUM_LIT:0> ) : <EOL> self . maxsize = maxsize <EOL> self . _init ( maxsize ) <EOL> self . mutex = Lock ( ) <EOL> self . not_empty = Condition ( self . mutex ) <EOL> self . not_full = Condition ( self . mutex ) <EOL> self . all_tasks_done = Condition ( self . mutex ) <EOL> self . unfinished_tasks = <NUM_LIT:0> <EOL> def task_done ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . all_tasks_done . acquire ( ) <EOL> try : <EOL> unfinished = self . unfinished_tasks - <NUM_LIT:1> <EOL> if unfinished <= <NUM_LIT:0> : <EOL> if unfinished < <NUM_LIT:0> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> self . all_tasks_done . notify_all ( ) <EOL> self . unfinished_tasks = unfinished <EOL> finally : <EOL> self . all_tasks_done . release ( ) <EOL> def join ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . all_tasks_done . acquire ( ) <EOL> try : <EOL> while self . unfinished_tasks : <EOL> self . all_tasks_done . wait ( ) <EOL> finally : <EOL> self . all_tasks_done . release ( ) <EOL> def qsize ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . mutex . acquire ( ) <EOL> try : <EOL> return self . _qsize ( ) <EOL> finally : <EOL> self . mutex . release ( ) <EOL> def empty ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . mutex . acquire ( ) <EOL> try : <EOL> return not self . _qsize ( ) <EOL> finally : <EOL> self . mutex . release ( ) <EOL> def full ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . mutex . acquire ( ) <EOL> try : <EOL> if self . maxsize <= <NUM_LIT:0> : <EOL> return False <EOL> if self . maxsize >= self . _qsize ( ) : <EOL> return True <EOL> finally : <EOL> self . mutex . release ( ) <EOL> def put ( self , item , block = True , timeout = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . not_full . acquire ( ) <EOL> try : <EOL> if self . maxsize > <NUM_LIT:0> : <EOL> if not block : <EOL> if self . _qsize ( ) >= self . maxsize : <EOL> raise Full <EOL> elif timeout is None : <EOL> while self . _qsize ( ) >= self . maxsize : <EOL> self . not_full . wait ( ) <EOL> elif timeout < <NUM_LIT:0> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> endtime = _time ( ) + timeout <EOL> while self . _qsize ( ) >= self . maxsize : <EOL> remaining = endtime - _time ( ) <EOL> if remaining <= <NUM_LIT:0.0> : <EOL> raise Full <EOL> self . not_full . wait ( remaining ) <EOL> self . _put ( item ) <EOL> self . unfinished_tasks += <NUM_LIT:1> <EOL> self . not_empty . notify ( ) <EOL> finally : <EOL> self . not_full . release ( ) <EOL> def put_nowait ( self , item ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . put ( item , False ) <EOL> def get ( self , block = True , timeout = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . not_empty . acquire ( ) <EOL> try : <EOL> if not block : <EOL> if not self . _qsize ( ) : <EOL> raise Empty <EOL> elif timeout is None : <EOL> while not self . _qsize ( ) : <EOL> self . not_empty . wait ( ) <EOL> elif timeout < <NUM_LIT:0> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> else : <EOL> endtime = _time ( ) + timeout <EOL> while not self . _qsize ( ) : <EOL> remaining = endtime - _time ( ) <EOL> if remaining <= <NUM_LIT:0.0> : <EOL> raise Empty <EOL> self . not_empty . wait ( remaining ) <EOL> item = self . _get ( ) <EOL> self . not_full . notify ( ) <EOL> return item <EOL> finally : <EOL> self . not_empty . release ( ) <EOL> def get_nowait ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . get ( False ) <EOL> def _init ( self , maxsize ) : <EOL> self . queue = deque ( ) <EOL> def _qsize ( self , len = len ) : <EOL> return len ( self . queue ) <EOL> def _put ( self , item ) : <EOL> self . queue . append ( item ) <EOL> def _get ( self ) : <EOL> return self . queue . popleft ( ) <EOL> class PriorityQueue ( Queue ) : <EOL> '''<STR_LIT>''' <EOL> def _init ( self , maxsize ) : <EOL> self . queue = [ ] <EOL> def _qsize ( self , len = len ) : <EOL> return len ( self . queue ) <EOL> def _put ( self , item , heappush = heapq . heappush ) : <EOL> heappush ( self . queue , item ) <EOL> def _get ( self , heappop = heapq . heappop ) : <EOL> return heappop ( self . queue ) <EOL> class LifoQueue ( Queue ) : <EOL> '''<STR_LIT>''' <EOL> def _init ( self , maxsize ) : <EOL> self . queue = [ ] <EOL> def _qsize ( self , len = len ) : <EOL> return len ( self . queue ) <EOL> def _put ( self , item ) : <EOL> self . queue . append ( item ) <EOL> def _get ( self ) : <EOL>", "answer": "return self . queue . pop ( ) "}, {"prompt": "<s> from jsonrpc import * <EOL> from djangoweb . webpages . models import Page <EOL> from django . template import loader <EOL> from django . shortcuts import render_to_response <EOL> from django . template import RequestContext , Template <EOL> from django . http import HttpResponseRedirect , HttpResponse <EOL> import urllib <EOL> service = JSONRPCService ( ) <EOL> def index ( request , path = None ) : <EOL> f = open ( \"<STR_LIT>\" , \"<STR_LIT:a>\" ) <EOL> f . write ( \"<STR_LIT>\" % str ( path ) ) <EOL> f . write ( \"<STR_LIT>\" % str ( request ) ) <EOL> path = request . GET . get ( '<STR_LIT>' , None ) <EOL> if path == '<STR_LIT>' : <EOL> path = '<STR_LIT:index>' <EOL> f . write ( \"<STR_LIT>\" % ( path ) ) <EOL> if path is None : <EOL> return HttpResponseRedirect ( \"<STR_LIT>\" ) <EOL> p = Page . objects . get ( name = path ) <EOL> f . write ( \"<STR_LIT>\" % ( str ( p ) ) ) <EOL> f . close ( ) <EOL> args = { '<STR_LIT:title>' : p . name , <EOL> '<STR_LIT>' : p . text <EOL> } <EOL> context_instance = RequestContext ( request ) <EOL> context_instance . autoescape = False <EOL> try : <EOL> template = Page . objects . get ( name = '<STR_LIT>' ) <EOL> except Page . DoesNotExist : <EOL> template = None <EOL> if not template : <EOL> return render_to_response ( '<STR_LIT>' , args , context_instance ) <EOL> tpl = loader . get_template_from_string ( template ) <EOL> context_instance . update ( args ) <EOL> tpl = tpl . render ( context_instance ) <EOL> return HttpResponse ( tpl ) <EOL> @ jsonremote ( service ) <EOL> def getPage ( request , num ) : <EOL> return json_convert ( [ Page . objects . get ( id = num ) ] ) <EOL> @ jsonremote ( service ) <EOL> def getPageByName ( request , name ) : <EOL> return json_convert ( [ Page . objects . get ( name = name ) ] ) <EOL> @ jsonremote ( service ) <EOL> def getPages ( request ) : <EOL> return json_convert ( Page . objects . all ( ) ) <EOL> @ jsonremote ( service ) <EOL> def updatePage ( request , item ) : <EOL> t = Page . objects . get ( id = item [ '<STR_LIT:id>' ] ) <EOL> t . name = item [ '<STR_LIT:name>' ] <EOL> t . text = item [ '<STR_LIT:text>' ] <EOL> t . save ( ) <EOL> return getPages ( request ) <EOL> @ jsonremote ( service ) <EOL> def addPage ( request , item ) : <EOL> t = Page ( ) <EOL> t . name = item [ '<STR_LIT:name>' ] <EOL> t . text = item [ '<STR_LIT:text>' ] <EOL> t . save ( ) <EOL> return getPages ( request ) <EOL>", "answer": "@ jsonremote ( service )"}, {"prompt": "<s> import requests <EOL> from httpretty import HTTPretty <EOL> from social . utils import parse_qs <EOL> from social . tests . backends . base import BaseBackendTest <EOL> class BaseLegacyTest ( BaseBackendTest ) : <EOL> form = '<STR_LIT>' <EOL> response_body = '<STR_LIT>' <EOL> def setUp ( self ) : <EOL> super ( BaseLegacyTest , self ) . setUp ( ) <EOL> self . strategy . set_settings ( { <EOL> '<STR_LIT>' . format ( self . name ) : <EOL> self . strategy . build_absolute_uri ( '<STR_LIT>' . format ( <EOL> self . backend . name ) ) <EOL> } ) <EOL> def extra_settings ( self ) : <EOL> return { '<STR_LIT>' . format ( self . name ) : <EOL> '<STR_LIT>' . format ( self . backend . name ) } <EOL> def do_start ( self ) : <EOL> start_url = self . strategy . build_absolute_uri ( self . backend . start ( ) . url ) <EOL> HTTPretty . register_uri ( <EOL> HTTPretty . GET , <EOL>", "answer": "start_url ,"}, {"prompt": "<s> import rasterio <EOL> from scipy . signal import medfilt <EOL> path = \"<STR_LIT>\" <EOL> output = \"<STR_LIT>\" <EOL> with rasterio . open ( path ) as src : <EOL> array = src . read ( ) <EOL> profile = src . profile <EOL> filtered = medfilt ( array , ( <NUM_LIT:1> , <NUM_LIT:5> , <NUM_LIT:5> ) ) . astype ( '<STR_LIT>' ) <EOL> with rasterio . open ( output , '<STR_LIT:w>' , ** profile ) as dst : <EOL>", "answer": "dst . write ( filtered ) "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> from cStringIO import StringIO <EOL> from types import ListType as NodeList <EOL> from types import StringTypes , UnicodeType <EOL> from twisted . web . sux import XMLParser , ParseError <EOL> from twisted . python . util import InsensitiveDict <EOL> def getElementsByTagName ( iNode , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> matches = [ ] <EOL> matches_append = matches . append <EOL> slice = [ iNode ] <EOL> while len ( slice ) > <NUM_LIT:0> : <EOL> c = slice . pop ( <NUM_LIT:0> ) <EOL> if c . nodeName == name : <EOL> matches_append ( c ) <EOL> slice [ : <NUM_LIT:0> ] = c . childNodes <EOL> return matches <EOL> def getElementsByTagNameNoCase ( iNode , name ) : <EOL> name = name . lower ( ) <EOL> matches = [ ] <EOL> matches_append = matches . append <EOL> slice = [ iNode ] <EOL> while len ( slice ) > <NUM_LIT:0> : <EOL> c = slice . pop ( <NUM_LIT:0> ) <EOL> if c . nodeName . lower ( ) == name : <EOL> matches_append ( c ) <EOL> slice [ : <NUM_LIT:0> ] = c . childNodes <EOL> return matches <EOL> HTML_ESCAPE_CHARS = ( ( '<STR_LIT:&>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT:<>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT:>>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT:\">' , '<STR_LIT>' ) ) <EOL> REV_HTML_ESCAPE_CHARS = list ( HTML_ESCAPE_CHARS ) <EOL> REV_HTML_ESCAPE_CHARS . reverse ( ) <EOL> XML_ESCAPE_CHARS = HTML_ESCAPE_CHARS + ( ( \"<STR_LIT:'>\" , '<STR_LIT>' ) , ) <EOL> REV_XML_ESCAPE_CHARS = list ( XML_ESCAPE_CHARS ) <EOL> REV_XML_ESCAPE_CHARS . reverse ( ) <EOL> def unescape ( text , chars = REV_HTML_ESCAPE_CHARS ) : <EOL> \"<STR_LIT>\" <EOL> for s , h in chars : <EOL> text = text . replace ( h , s ) <EOL> return text <EOL> def escape ( text , chars = HTML_ESCAPE_CHARS ) : <EOL> \"<STR_LIT>\" <EOL> for s , h in chars : <EOL> text = text . replace ( s , h ) <EOL> return text <EOL> class MismatchedTags ( Exception ) : <EOL> def __init__ ( self , filename , expect , got , endLine , endCol , begLine , begCol ) : <EOL> ( self . filename , self . expect , self . got , self . begLine , self . begCol , self . endLine , <EOL> self . endCol ) = filename , expect , got , begLine , begCol , endLine , endCol <EOL> def __str__ ( self ) : <EOL> return ( \"<STR_LIT>\" <EOL> % ( self . expect , self . got , self . endLine , self . endCol , self . begLine , <EOL> self . begCol ) ) <EOL> class Node ( object ) : <EOL> nodeName = \"<STR_LIT>\" <EOL> def __init__ ( self , parentNode = None ) : <EOL> self . parentNode = parentNode <EOL> self . childNodes = [ ] <EOL> def isEqualToNode ( self , other ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( self . childNodes ) != len ( other . childNodes ) : <EOL> return False <EOL> for a , b in zip ( self . childNodes , other . childNodes ) : <EOL> if not a . isEqualToNode ( b ) : <EOL> return False <EOL> return True <EOL> def writexml ( self , stream , indent = '<STR_LIT>' , addindent = '<STR_LIT>' , newl = '<STR_LIT>' , strip = <NUM_LIT:0> , <EOL> nsprefixes = { } , namespace = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def toxml ( self , indent = '<STR_LIT>' , addindent = '<STR_LIT>' , newl = '<STR_LIT>' , strip = <NUM_LIT:0> , nsprefixes = { } , <EOL> namespace = '<STR_LIT>' ) : <EOL> s = StringIO ( ) <EOL> self . writexml ( s , indent , addindent , newl , strip , nsprefixes , namespace ) <EOL> rv = s . getvalue ( ) <EOL> return rv <EOL> def writeprettyxml ( self , stream , indent = '<STR_LIT>' , addindent = '<STR_LIT:U+0020>' , newl = '<STR_LIT:\\n>' , strip = <NUM_LIT:0> ) : <EOL> return self . writexml ( stream , indent , addindent , newl , strip ) <EOL> def toprettyxml ( self , indent = '<STR_LIT>' , addindent = '<STR_LIT:U+0020>' , newl = '<STR_LIT:\\n>' , strip = <NUM_LIT:0> ) : <EOL> return self . toxml ( indent , addindent , newl , strip ) <EOL> def cloneNode ( self , deep = <NUM_LIT:0> , parent = None ) : <EOL> raise NotImplementedError ( ) <EOL> def hasChildNodes ( self ) : <EOL> if self . childNodes : <EOL> return <NUM_LIT:1> <EOL> else : <EOL> return <NUM_LIT:0> <EOL> def appendChild ( self , child ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( child , Node ) : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> self . childNodes . append ( child ) <EOL> child . parentNode = self <EOL> def insertBefore ( self , new , ref ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( new , Node ) or not isinstance ( ref , Node ) : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> i = self . childNodes . index ( ref ) <EOL> new . parentNode = self <EOL> self . childNodes . insert ( i , new ) <EOL> return new <EOL> def removeChild ( self , child ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( child , Node ) : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> if child in self . childNodes : <EOL> self . childNodes . remove ( child ) <EOL> child . parentNode = None <EOL> return child <EOL> def replaceChild ( self , newChild , oldChild ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( newChild , Node ) or not isinstance ( oldChild , Node ) : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> if oldChild . parentNode is not self : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> self . childNodes [ self . childNodes . index ( oldChild ) ] = newChild <EOL> oldChild . parentNode = None <EOL> newChild . parentNode = self <EOL> def lastChild ( self ) : <EOL> return self . childNodes [ - <NUM_LIT:1> ] <EOL> def firstChild ( self ) : <EOL> if len ( self . childNodes ) : <EOL> return self . childNodes [ <NUM_LIT:0> ] <EOL> return None <EOL> class Document ( Node ) : <EOL> def __init__ ( self , documentElement = None ) : <EOL> Node . __init__ ( self ) <EOL>", "answer": "if documentElement :"}, {"prompt": "<s> from time import time <EOL> import gevent <EOL> from gevent import pool <EOL> from gevent . event import Event <EOL> from gevent . queue import Queue <EOL> import greentest <EOL> import random <EOL> from greentest import ExpectedException <EOL> import six <EOL> import unittest <EOL> class TestCoroutinePool ( unittest . TestCase ) : <EOL> klass = pool . Pool <EOL> def test_apply_async ( self ) : <EOL> done = Event ( ) <EOL> def some_work ( x ) : <EOL> done . set ( ) <EOL> pool = self . klass ( <NUM_LIT:2> ) <EOL> pool . apply_async ( some_work , ( '<STR_LIT:x>' , ) ) <EOL> done . wait ( ) <EOL> def test_apply ( self ) : <EOL> value = '<STR_LIT>' <EOL> def some_work ( ) : <EOL> return value <EOL> pool = self . klass ( <NUM_LIT:2> ) <EOL> result = pool . apply ( some_work ) <EOL> self . assertEqual ( value , result ) <EOL> def test_apply_raises ( self ) : <EOL> pool = self . klass ( <NUM_LIT:1> ) <EOL> def raiser ( ) : <EOL> raise ExpectedException ( ) <EOL> try : <EOL> pool . apply ( raiser ) <EOL> except ExpectedException : <EOL> pass <EOL> else : <EOL> self . fail ( \"<STR_LIT>\" ) <EOL> test_apply_raises . error_fatal = False <EOL> def test_multiple_coros ( self ) : <EOL> evt = Event ( ) <EOL> results = [ ] <EOL> def producer ( ) : <EOL> gevent . sleep ( <NUM_LIT> ) <EOL> results . append ( '<STR_LIT>' ) <EOL> evt . set ( ) <EOL> def consumer ( ) : <EOL> results . append ( '<STR_LIT>' ) <EOL> evt . wait ( ) <EOL> results . append ( '<STR_LIT>' ) <EOL> pool = self . klass ( <NUM_LIT:2> ) <EOL> done = pool . spawn ( consumer ) <EOL> pool . apply_async ( producer ) <EOL> done . get ( ) <EOL> self . assertEqual ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , results ) <EOL> def dont_test_timer_cancel ( self ) : <EOL> timer_fired = [ ] <EOL> def fire_timer ( ) : <EOL> timer_fired . append ( True ) <EOL> def some_work ( ) : <EOL> gevent . timer ( <NUM_LIT:0> , fire_timer ) <EOL> pool = self . klass ( <NUM_LIT:2> ) <EOL> pool . apply ( some_work ) <EOL> gevent . sleep ( <NUM_LIT:0> ) <EOL> self . assertEqual ( timer_fired , [ ] ) <EOL> def test_reentrant ( self ) : <EOL> pool = self . klass ( <NUM_LIT:1> ) <EOL> result = pool . apply ( pool . apply , ( lambda a : a + <NUM_LIT:1> , ( <NUM_LIT:5> , ) ) ) <EOL> self . assertEqual ( result , <NUM_LIT:6> ) <EOL> evt = Event ( ) <EOL> pool . apply_async ( evt . set ) <EOL> evt . wait ( ) <EOL> def test_stderr_raising ( self ) : <EOL> if greentest . PYPY : <EOL> return <EOL> import sys <EOL> pool = self . klass ( size = <NUM_LIT:1> ) <EOL> normal_err = sys . stderr <EOL> try : <EOL> sys . stderr = FakeFile ( ) <EOL> waiter = pool . spawn ( crash ) <EOL> with gevent . Timeout ( <NUM_LIT:2> ) : <EOL> self . assertRaises ( RuntimeError , waiter . get ) <EOL> gevent . sleep ( <NUM_LIT:0> ) <EOL> self . assertEqual ( pool . free_count ( ) , <NUM_LIT:1> ) <EOL> t = gevent . Timeout . start_new ( <NUM_LIT:0.1> ) <EOL> try : <EOL> pool . apply ( gevent . sleep , ( <NUM_LIT:0> , ) ) <EOL> finally : <EOL> t . cancel ( ) <EOL> finally : <EOL> sys . stderr = normal_err <EOL> pool . join ( ) <EOL> def crash ( * args , ** kw ) : <EOL> raise RuntimeError ( \"<STR_LIT>\" ) <EOL> class FakeFile ( object ) : <EOL> def write ( * args ) : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> class PoolBasicTests ( greentest . TestCase ) : <EOL> klass = pool . Pool <EOL> def test_execute_async ( self ) : <EOL> p = self . klass ( size = <NUM_LIT:2> ) <EOL> self . assertEqual ( p . free_count ( ) , <NUM_LIT:2> ) <EOL> r = [ ] <EOL> first = p . spawn ( r . append , <NUM_LIT:1> ) <EOL> self . assertEqual ( p . free_count ( ) , <NUM_LIT:1> ) <EOL> first . get ( ) <EOL> self . assertEqual ( r , [ <NUM_LIT:1> ] ) <EOL> gevent . sleep ( <NUM_LIT:0> ) <EOL> self . assertEqual ( p . free_count ( ) , <NUM_LIT:2> ) <EOL> p . apply_async ( r . append , ( <NUM_LIT:2> , ) ) <EOL> self . assertEqual ( <NUM_LIT:1> , p . free_count ( ) ) <EOL> self . assertEqual ( r , [ <NUM_LIT:1> ] ) <EOL> p . apply_async ( r . append , ( <NUM_LIT:3> , ) ) <EOL> self . assertEqual ( <NUM_LIT:0> , p . free_count ( ) ) <EOL> self . assertEqual ( r , [ <NUM_LIT:1> ] ) <EOL> p . apply_async ( r . append , ( <NUM_LIT:4> , ) ) <EOL> self . assertEqual ( r , [ <NUM_LIT:1> ] ) <EOL> gevent . sleep ( <NUM_LIT> ) <EOL> self . assertEqual ( sorted ( r ) , [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ] ) <EOL> def test_discard ( self ) : <EOL> p = self . klass ( size = <NUM_LIT:1> ) <EOL> first = p . spawn ( gevent . sleep , <NUM_LIT:1000> ) <EOL> p . discard ( first ) <EOL> first . kill ( ) <EOL> assert not first , first <EOL> self . assertEqual ( len ( p ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( p . _semaphore . counter , <NUM_LIT:1> ) <EOL> def test_add_method ( self ) : <EOL> p = self . klass ( size = <NUM_LIT:1> ) <EOL> first = gevent . spawn ( gevent . sleep , <NUM_LIT:1000> ) <EOL> try : <EOL> second = gevent . spawn ( gevent . sleep , <NUM_LIT:1000> ) <EOL> try : <EOL> self . assertEqual ( p . free_count ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( p ) , <NUM_LIT:0> ) <EOL> p . add ( first ) <EOL> timeout = gevent . Timeout ( <NUM_LIT:0.1> ) <EOL> timeout . start ( ) <EOL> try : <EOL> p . add ( second ) <EOL> except gevent . Timeout : <EOL> pass <EOL> else : <EOL> raise AssertionError ( '<STR_LIT>' ) <EOL> finally : <EOL> timeout . cancel ( ) <EOL> self . assertEqual ( p . free_count ( ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( len ( p ) , <NUM_LIT:1> ) <EOL> finally : <EOL> second . kill ( ) <EOL> finally : <EOL> first . kill ( ) <EOL> def test_apply ( self ) : <EOL> p = self . klass ( ) <EOL> result = p . apply ( lambda a : ( '<STR_LIT:foo>' , a ) , ( <NUM_LIT:1> , ) ) <EOL> self . assertEqual ( result , ( '<STR_LIT:foo>' , <NUM_LIT:1> ) ) <EOL> def test_init_error ( self ) : <EOL> self . switch_expected = False <EOL> self . assertRaises ( ValueError , self . klass , - <NUM_LIT:1> ) <EOL> class TimingWrapper ( object ) : <EOL> def __init__ ( self , func ) : <EOL> self . func = func <EOL> self . elapsed = None <EOL> def __call__ ( self , * args , ** kwds ) : <EOL> t = time ( ) <EOL> try : <EOL> return self . func ( * args , ** kwds ) <EOL> finally : <EOL> self . elapsed = time ( ) - t <EOL> def sqr ( x , wait = <NUM_LIT:0.0> ) : <EOL> gevent . sleep ( wait ) <EOL> return x * x <EOL> def squared ( x ) : <EOL> return x * x <EOL> def sqr_random_sleep ( x ) : <EOL> gevent . sleep ( random . random ( ) * <NUM_LIT:0.1> ) <EOL> return x * x <EOL> def final_sleep ( ) : <EOL> for i in range ( <NUM_LIT:3> ) : <EOL> yield i <EOL> gevent . sleep ( <NUM_LIT> ) <EOL> TIMEOUT1 , TIMEOUT2 , TIMEOUT3 = <NUM_LIT> , <NUM_LIT> , <NUM_LIT> <EOL> class TestPool ( greentest . TestCase ) : <EOL> __timeout__ = <NUM_LIT:5> if not greentest . RUNNING_ON_APPVEYOR else <NUM_LIT:20> <EOL> size = <NUM_LIT:1> <EOL> def setUp ( self ) : <EOL> greentest . TestCase . setUp ( self ) <EOL> self . pool = pool . Pool ( self . size ) <EOL> def cleanup ( self ) : <EOL> self . pool . join ( ) <EOL> def test_apply ( self ) : <EOL> papply = self . pool . apply <EOL> self . assertEqual ( papply ( sqr , ( <NUM_LIT:5> , ) ) , <NUM_LIT> ) <EOL> self . assertEqual ( papply ( sqr , ( ) , { '<STR_LIT:x>' : <NUM_LIT:3> } ) , <NUM_LIT:9> ) <EOL> def test_map ( self ) : <EOL> pmap = self . pool . map <EOL> self . assertEqual ( pmap ( sqr , range ( <NUM_LIT:10> ) ) , list ( map ( squared , range ( <NUM_LIT:10> ) ) ) ) <EOL> self . assertEqual ( pmap ( sqr , range ( <NUM_LIT:100> ) ) , list ( map ( squared , range ( <NUM_LIT:100> ) ) ) ) <EOL> def test_async ( self ) : <EOL> res = self . pool . apply_async ( sqr , ( <NUM_LIT:7> , TIMEOUT1 , ) ) <EOL> get = TimingWrapper ( res . get ) <EOL> self . assertEqual ( get ( ) , <NUM_LIT> ) <EOL> self . assertTimeoutAlmostEqual ( get . elapsed , TIMEOUT1 , <NUM_LIT:1> ) <EOL> def test_async_callback ( self ) : <EOL> result = [ ] <EOL> res = self . pool . apply_async ( sqr , ( <NUM_LIT:7> , TIMEOUT1 , ) , callback = lambda x : result . append ( x ) ) <EOL> get = TimingWrapper ( res . get ) <EOL> self . assertEqual ( get ( ) , <NUM_LIT> ) <EOL> self . assertTimeoutAlmostEqual ( get . elapsed , TIMEOUT1 , <NUM_LIT:1> ) <EOL> gevent . sleep ( <NUM_LIT:0> ) <EOL> assert result == [ <NUM_LIT> ] , result <EOL> def test_async_timeout ( self ) : <EOL> res = self . pool . apply_async ( sqr , ( <NUM_LIT:6> , TIMEOUT2 + <NUM_LIT> ) ) <EOL> get = TimingWrapper ( res . get ) <EOL> self . assertRaises ( gevent . Timeout , get , timeout = TIMEOUT2 ) <EOL> self . assertTimeoutAlmostEqual ( get . elapsed , TIMEOUT2 , <NUM_LIT:1> ) <EOL> self . pool . join ( ) <EOL> def test_imap ( self ) : <EOL> it = self . pool . imap ( sqr , range ( <NUM_LIT:10> ) ) <EOL> self . assertEqual ( list ( it ) , list ( map ( squared , range ( <NUM_LIT:10> ) ) ) ) <EOL> it = self . pool . imap ( sqr , range ( <NUM_LIT:10> ) ) <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> self . assertEqual ( six . advance_iterator ( it ) , i * i ) <EOL> self . assertRaises ( StopIteration , lambda : six . advance_iterator ( it ) ) <EOL> it = self . pool . imap ( sqr , range ( <NUM_LIT:1000> ) ) <EOL> for i in range ( <NUM_LIT:1000> ) : <EOL> self . assertEqual ( six . advance_iterator ( it ) , i * i ) <EOL> self . assertRaises ( StopIteration , lambda : six . advance_iterator ( it ) ) <EOL> def test_imap_random ( self ) : <EOL> it = self . pool . imap ( sqr_random_sleep , range ( <NUM_LIT:10> ) ) <EOL> self . assertEqual ( list ( it ) , list ( map ( squared , range ( <NUM_LIT:10> ) ) ) ) <EOL> def test_imap_unordered ( self ) : <EOL> it = self . pool . imap_unordered ( sqr , range ( <NUM_LIT:1000> ) ) <EOL> self . assertEqual ( sorted ( it ) , list ( map ( squared , range ( <NUM_LIT:1000> ) ) ) ) <EOL> it = self . pool . imap_unordered ( sqr , range ( <NUM_LIT:1000> ) ) <EOL> self . assertEqual ( sorted ( it ) , list ( map ( squared , range ( <NUM_LIT:1000> ) ) ) ) <EOL> def test_imap_unordered_random ( self ) : <EOL> it = self . pool . imap_unordered ( sqr_random_sleep , range ( <NUM_LIT:10> ) ) <EOL> self . assertEqual ( sorted ( it ) , list ( map ( squared , range ( <NUM_LIT:10> ) ) ) ) <EOL> def test_empty ( self ) : <EOL> it = self . pool . imap_unordered ( sqr , [ ] ) <EOL> self . assertEqual ( list ( it ) , [ ] ) <EOL> it = self . pool . imap ( sqr , [ ] ) <EOL> self . assertEqual ( list ( it ) , [ ] ) <EOL> self . assertEqual ( self . pool . map ( sqr , [ ] ) , [ ] ) <EOL> def test_terminate ( self ) : <EOL> result = self . pool . map_async ( gevent . sleep , [ <NUM_LIT:0.1> ] * ( ( self . size or <NUM_LIT:10> ) * <NUM_LIT:2> ) ) <EOL> gevent . sleep ( <NUM_LIT:0.1> ) <EOL> kill = TimingWrapper ( self . pool . kill ) <EOL> kill ( ) <EOL> assert kill . elapsed < <NUM_LIT:0.5> , kill . elapsed <EOL> result . join ( ) <EOL> def sleep ( self , x ) : <EOL> gevent . sleep ( float ( x ) / <NUM_LIT> ) <EOL> return str ( x ) <EOL> def test_imap_unordered_sleep ( self ) : <EOL> result = list ( self . pool . imap_unordered ( self . sleep , [ <NUM_LIT:10> , <NUM_LIT:1> , <NUM_LIT:2> ] ) ) <EOL> if self . pool . size == <NUM_LIT:1> : <EOL> expected = [ '<STR_LIT>' , '<STR_LIT:1>' , '<STR_LIT:2>' ] <EOL> else : <EOL> expected = [ '<STR_LIT:1>' , '<STR_LIT:2>' , '<STR_LIT>' ] <EOL> self . assertEqual ( result , expected ) <EOL> def test_imap_no_stop ( self ) : <EOL> q = Queue ( ) <EOL> q . put ( <NUM_LIT> ) <EOL> gevent . spawn_later ( <NUM_LIT:0.1> , q . put , StopIteration ) <EOL> result = list ( self . pool . imap ( lambda _ : _ , q ) ) <EOL> self . assertEqual ( result , [ <NUM_LIT> ] ) <EOL> def test_imap_unordered_no_stop ( self ) : <EOL> q = Queue ( ) <EOL> q . put ( <NUM_LIT> ) <EOL> gevent . spawn_later ( <NUM_LIT:0.1> , q . put , StopIteration ) <EOL> result = list ( self . pool . imap_unordered ( lambda _ : _ , q ) ) <EOL> self . assertEqual ( result , [ <NUM_LIT> ] ) <EOL> def test_imap_final_sleep ( self ) : <EOL> result = list ( self . pool . imap ( sqr , final_sleep ( ) ) ) <EOL> self . assertEqual ( result , [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:4> ] ) <EOL> def test_imap_unordered_final_sleep ( self ) : <EOL> result = list ( self . pool . imap_unordered ( sqr , final_sleep ( ) ) ) <EOL> self . assertEqual ( result , [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:4> ] ) <EOL> def test_imap_unordered_bounded_queue ( self ) : <EOL> iterable = list ( range ( <NUM_LIT:100> ) ) <EOL> running = [ <NUM_LIT:0> ] <EOL> def short_running_func ( i , j ) : <EOL> running [ <NUM_LIT:0> ] += <NUM_LIT:1> <EOL> return i <EOL> for meth in self . pool . imap_unordered , self . pool . imap : <EOL> running [ <NUM_LIT:0> ] = <NUM_LIT:0> <EOL> mapping = meth ( short_running_func , iterable , iterable , <EOL> maxsize = <NUM_LIT:1> ) <EOL> def reader ( ) : <EOL> result = [ ] <EOL> for i , x in enumerate ( mapping ) : <EOL> self . assertTrue ( running [ <NUM_LIT:0> ] <= i + <NUM_LIT:2> , running [ <NUM_LIT:0> ] ) <EOL> result . append ( x ) <EOL> gevent . sleep ( <NUM_LIT> ) <EOL> self . assertTrue ( len ( mapping . queue ) <= <NUM_LIT:2> , len ( mapping . queue ) ) <EOL> return result <EOL> l = reader ( ) <EOL> self . assertEqual ( sorted ( l ) , iterable ) <EOL> class TestPool2 ( TestPool ) : <EOL> size = <NUM_LIT:2> <EOL> class TestPool3 ( TestPool ) : <EOL> size = <NUM_LIT:3> <EOL> class TestPool10 ( TestPool ) : <EOL> size = <NUM_LIT:10> <EOL> class TestPoolUnlimit ( TestPool ) : <EOL> size = None <EOL> class TestPool0 ( greentest . TestCase ) : <EOL> size = <NUM_LIT:0> <EOL> def test_wait_full ( self ) : <EOL> p = pool . Pool ( size = <NUM_LIT:0> ) <EOL> self . assertEqual ( <NUM_LIT:0> , p . free_count ( ) ) <EOL> self . assertTrue ( p . full ( ) ) <EOL> self . assertEqual ( <NUM_LIT:0> , p . wait_available ( timeout = <NUM_LIT> ) ) <EOL> class TestJoinSleep ( greentest . GenericWaitTestCase ) : <EOL> def wait ( self , timeout ) : <EOL> p = pool . Pool ( ) <EOL> g = p . spawn ( gevent . sleep , <NUM_LIT:10> ) <EOL> try : <EOL> p . join ( timeout = timeout ) <EOL> finally : <EOL> g . kill ( ) <EOL> class TestJoinSleep_raise_error ( greentest . GenericWaitTestCase ) : <EOL> def wait ( self , timeout ) : <EOL> p = pool . Pool ( ) <EOL> g = p . spawn ( gevent . sleep , <NUM_LIT:10> ) <EOL> try : <EOL> p . join ( timeout = timeout , raise_error = True ) <EOL> finally : <EOL> g . kill ( ) <EOL> class TestJoinEmpty ( greentest . TestCase ) : <EOL> switch_expected = False <EOL> def test ( self ) : <EOL> p = pool . Pool ( ) <EOL> res = p . join ( ) <EOL> self . assertTrue ( res , \"<STR_LIT>\" ) <EOL> class TestSpawn ( greentest . TestCase ) : <EOL> switch_expected = True <EOL> def test ( self ) : <EOL> p = pool . Pool ( <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( p ) , <NUM_LIT:0> ) <EOL> p . spawn ( gevent . sleep , <NUM_LIT:0.1> ) <EOL>", "answer": "self . assertEqual ( len ( p ) , <NUM_LIT:1> )"}, {"prompt": "<s> import sys <EOL> try : <EOL> import unittest2 as unittest <EOL> sys . modules [ '<STR_LIT>' ] = unittest <EOL> except ImportError : <EOL> import unittest <EOL> from goless . backends import current as be <EOL> class BaseTests ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL>", "answer": "be . yield_ ( )"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import copy <EOL> import logging <EOL> import mc_states . api <EOL> __name = '<STR_LIT>' <EOL> log = logging . getLogger ( __name__ ) <EOL> default_locs = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT:/>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' : '<STR_LIT>' ,"}, {"prompt": "<s> import sys <EOL> from functools import partial <EOL> from six . moves . urllib . request import urlopen <EOL> from awscli . customizations . commands import BasicCommand <EOL> class GetGameSessionLogCommand ( BasicCommand ) : <EOL> NAME = '<STR_LIT>' <EOL> DESCRIPTION = '<STR_LIT>' <EOL> ARG_TABLE = [ <EOL> { '<STR_LIT:name>' : '<STR_LIT>' , '<STR_LIT>' : True , <EOL> '<STR_LIT>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:name>' : '<STR_LIT>' , '<STR_LIT>' : True , <EOL> '<STR_LIT>' : '<STR_LIT>' } <EOL> ] <EOL> def _run_main ( self , args , parsed_globals ) : <EOL> client = self . _session . create_client ( <EOL> '<STR_LIT>' , region_name = parsed_globals . region , <EOL> endpoint_url = parsed_globals . endpoint_url , <EOL> verify = parsed_globals . verify_ssl <EOL> ) <EOL> response = client . get_game_session_log_url ( <EOL> GameSessionId = args . game_session_id ) <EOL> url = response [ '<STR_LIT>' ] <EOL> contents = urlopen ( url ) <EOL> sys . stdout . write ( <EOL> '<STR_LIT>' % <EOL> args . game_session_id <EOL>", "answer": ")"}, {"prompt": "<s> from datetime import date <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import User <EOL> from django . core . management . base import BaseCommand <EOL> from kitsune . customercare import badges as aoa_badges <EOL> from kitsune . customercare . models import Reply <EOL> from kitsune . customercare . tasks import ( <EOL> maybe_award_badge as maybe_award_aoa_badge ) <EOL> from kitsune . kbadge import badges <EOL> from kitsune . questions import badges as questions_badges <EOL> from kitsune . questions . models import Answer <EOL>", "answer": "from kitsune . questions . tasks import ("}, {"prompt": "<s> import sys <EOL> class Step ( object ) : <EOL> '''<STR_LIT>''' <EOL> name = '<STR_LIT>' <EOL> def __init__ ( self , message , * args ) : <EOL> self . _message = message <EOL> self . _args = args <EOL> self . _context = sys . _getframe ( <NUM_LIT:1> ) <EOL> self . _set_step_attrs ( self . _context . f_locals ) <EOL> self . _steps = self . _context . f_locals [ '<STR_LIT>' % self . __class__ . name ] <EOL> self . _steps . append ( ( None , self . _message , self . _args ) ) <EOL> def _set_step_attrs ( self , local_attrs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> attr_name = '<STR_LIT>' % self . name <EOL> if not attr_name in local_attrs : <EOL> local_attrs [ attr_name ] = [ ] <EOL> def __call__ ( self , method = None ) : <EOL> del self . _steps [ - <NUM_LIT:1> ] <EOL> self . _steps . append ( ( method , self . _message , self . _args ) ) <EOL> return method <EOL>", "answer": "class Given ( Step ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> class User ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> def current_user ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url = self . root_collection [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> return url <EOL> def current_user_person ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> url = self . collections [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ <NUM_LIT:0> ] [ <EOL> \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> except KeyError : <EOL> self . update_collection ( \"<STR_LIT>\" ) <EOL> url = self . collections [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ <NUM_LIT:0> ] [ <EOL> \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> return url <EOL>", "answer": "def agent ( self , uid ) :"}, {"prompt": "<s> def test_add_test_project ( build_worktree ) : <EOL>", "answer": "world = build_worktree . add_test_project ( \"<STR_LIT>\" )"}, {"prompt": "<s> import os <EOL> import shutil <EOL> import tempfile <EOL> from contextlib import contextmanager <EOL> from cactus . utils . helpers import map_apply <EOL> def mkdtemp ( ) : <EOL> return tempfile . mkdtemp ( dir = os . environ . get ( \"<STR_LIT>\" ) ) <EOL> def fileList ( paths , relative = False , folders = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( paths , list ) : <EOL> paths = [ paths ] <EOL> files = [ ] <EOL> def append ( directory , name ) : <EOL> if not name . startswith ( '<STR_LIT:.>' ) : <EOL> path = os . path . join ( directory , name ) <EOL> files . append ( path ) <EOL> for path in paths : <EOL> for directory , dirnames , filenames in os . walk ( path , followlinks = True ) : <EOL> if folders : <EOL> for dirname in dirnames : <EOL> append ( directory , dirname ) <EOL> for filename in filenames : <EOL> append ( directory , filename ) <EOL> if relative : <EOL> files = map_apply ( lambda x : x [ len ( path ) + <NUM_LIT:1> : ] , files ) <EOL> return files <EOL> @ contextmanager <EOL> def alt_file ( current_file ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _alt_file = current_file + '<STR_LIT>' <EOL> yield _alt_file <EOL> try : <EOL> shutil . move ( _alt_file , current_file ) <EOL>", "answer": "except IOError :"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> import os <EOL> from campfin . trainer import * <EOL> if not os . path . isfile ( \"<STR_LIT>\" ) : <EOL>", "answer": "os . system ( \"<STR_LIT>\" )"}, {"prompt": "<s> from __future__ import print_function <EOL> import sys <EOL> from copy import copy <EOL> import numpy <EOL> import theano <EOL> from theano import gof <EOL> from theano . compat import izip <EOL> from six import iteritems <EOL> from six . moves import xrange <EOL> from theano . gof import Apply , Op , OpenMPOp <EOL> from theano import scalar <EOL> from theano . scalar import get_scalar_type <EOL> from theano . printing import pprint <EOL> from theano . gradient import DisconnectedType <EOL> from theano . gof . null_type import NullType <EOL> from theano . gof . utils import hash_from_dict <EOL> from theano . tensor import elemwise_cgen as cgen <EOL> config = theano . config <EOL> discrete_dtypes = list ( map ( str , scalar . discrete_types ) ) <EOL> float_dtypes = list ( map ( str , scalar . float_types ) ) <EOL> int_dtypes = list ( map ( str , scalar . int_types ) ) <EOL> def as_tensor_variable ( data ) : <EOL> raise Exception ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def TensorType ( * inputs , ** kwargs ) : <EOL> raise Exception ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def TensorVariable ( * inputs , ** kwargs ) : <EOL> raise Exception ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def TensorConstant ( * inputs , ** kwargs ) : <EOL> raise Exception ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> class DimShuffle ( Op ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _f16_ok = True <EOL> check_input = False <EOL> def __init__ ( self , input_broadcastable , new_order , inplace = False ) : <EOL> input_broadcastable = tuple ( input_broadcastable ) <EOL> self . input_broadcastable = input_broadcastable <EOL> new_order = tuple ( new_order ) <EOL> self . new_order = new_order <EOL> self . inplace = inplace <EOL> for i , j in enumerate ( new_order ) : <EOL> if j != '<STR_LIT:x>' : <EOL> if not isinstance ( j , ( int , numpy . integer ) ) : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> if j >= len ( input_broadcastable ) : <EOL> raise ValueError ( ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) % <EOL> ( i , j , len ( input_broadcastable ) ) ) <EOL> if j in new_order [ ( i + <NUM_LIT:1> ) : ] : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> new_order ) <EOL> self . drop = [ ] <EOL> for i , b in enumerate ( input_broadcastable ) : <EOL> if i not in new_order : <EOL> if b == <NUM_LIT:1> : <EOL> self . drop . append ( i ) <EOL> else : <EOL> raise ValueError ( <EOL> \"<STR_LIT>\" , <EOL> ( input_broadcastable , new_order ) ) <EOL> self . shuffle = [ x for x in new_order if x != '<STR_LIT:x>' ] <EOL> self . augment = [ i for i , x in enumerate ( new_order ) if x == '<STR_LIT:x>' ] <EOL> if self . inplace : <EOL> self . view_map = { <NUM_LIT:0> : [ <NUM_LIT:0> ] } <EOL> self . _rehash ( ) <EOL> def __getstate__ ( self ) : <EOL> d = dict ( self . __dict__ ) <EOL> del d [ '<STR_LIT>' ] <EOL> return d <EOL> def __setstate__ ( self , d ) : <EOL> self . __dict__ . update ( d ) <EOL> self . _rehash ( ) <EOL> def make_node ( self , _input ) : <EOL> input = as_tensor_variable ( _input ) <EOL> ib = tuple ( input . type . broadcastable ) <EOL> if not ib == self . input_broadcastable : <EOL> if len ( ib ) != len ( self . input_broadcastable ) : <EOL> raise TypeError ( ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> % ( self . input_broadcastable , ib ) ) ) <EOL> for expected , b in zip ( self . input_broadcastable , ib ) : <EOL> if expected is True and b is False : <EOL> raise TypeError ( ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> % ( self . input_broadcastable , ib ) ) ) <EOL> ob = [ ] <EOL> for value in self . new_order : <EOL> if value == '<STR_LIT:x>' : <EOL> ob . append ( True ) <EOL> else : <EOL> ob . append ( ib [ value ] ) <EOL> output = TensorType ( dtype = input . type . dtype , <EOL> broadcastable = ob ) ( ) <EOL> return Apply ( self , [ input ] , [ output ] ) <EOL> def __eq__ ( self , other ) : <EOL> return type ( self ) == type ( other ) and self . inplace == other . inplace and self . new_order == other . new_order and self . input_broadcastable == other . input_broadcastable <EOL> def _rehash ( self ) : <EOL> self . _hashval = ( hash ( type ( self ) . __name__ ) ^ <EOL> hash ( type ( self ) . __module__ ) ^ <EOL> hash ( self . inplace ) ^ <EOL> hash ( self . new_order ) ^ <EOL> hash ( self . input_broadcastable ) ) <EOL> def __hash__ ( self ) : <EOL> return self . _hashval <EOL> def __str__ ( self ) : <EOL> if self . inplace : <EOL> return \"<STR_LIT>\" % \"<STR_LIT:U+002C>\" . join ( str ( x ) <EOL> for x in self . new_order ) <EOL> else : <EOL> return \"<STR_LIT>\" % \"<STR_LIT:U+002C>\" . join ( str ( x ) for x in self . new_order ) <EOL> def perform ( self , node , inp , out ) : <EOL> input , = inp <EOL> storage , = out <EOL> res = input <EOL> if type ( res ) != numpy . ndarray and type ( res ) != numpy . memmap : <EOL> raise TypeError ( res ) <EOL> res = res . transpose ( self . shuffle + self . drop ) <EOL> shape = list ( res . shape [ : len ( self . shuffle ) ] ) <EOL> for augm in self . augment : <EOL> shape . insert ( augm , <NUM_LIT:1> ) <EOL> res = res . reshape ( shape ) <EOL> if not self . inplace : <EOL> res = numpy . copy ( res ) <EOL> storage [ <NUM_LIT:0> ] = numpy . asarray ( res ) <EOL> def infer_shape ( self , node , shapes ) : <EOL> ishp , = shapes <EOL> rval = [ ishp [ i ] for i in self . shuffle ] <EOL> for augm in self . augment : <EOL> rval . insert ( augm , <NUM_LIT:1> ) <EOL> return [ rval ] <EOL> def R_op ( self , inputs , eval_points ) : <EOL> if None in eval_points : <EOL> return [ None ] <EOL> return self ( * eval_points , ** dict ( return_list = True ) ) <EOL> def c_code ( self , node , name , inp , out , sub ) : <EOL> input , = inp <EOL> res , = out <EOL> basename = input + '<STR_LIT>' <EOL> def statements ( lst ) : <EOL> return '<STR_LIT>' . join ( lst ) + '<STR_LIT:;>' <EOL> nd_in = len ( self . input_broadcastable ) <EOL> nd_out = len ( self . new_order ) <EOL> check_input_nd = [ ( '<STR_LIT>' + str ( nd_in ) + '<STR_LIT:)>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) ] <EOL> clear_output = [ '<STR_LIT>' ] <EOL> if self . inplace : <EOL> get_base = [ <EOL> '<STR_LIT>' , '<STR_LIT>' ] <EOL> else : <EOL> get_base = [ ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) ] <EOL> shape_statements = [ '<STR_LIT>' % nd_out ] <EOL> for i , o in enumerate ( self . new_order ) : <EOL> if o != '<STR_LIT:x>' : <EOL> shape_statements += [ ( '<STR_LIT>' + str ( <EOL> i ) + '<STR_LIT>' + str ( o ) + '<STR_LIT:]>' ) ] <EOL> else : <EOL> shape_statements += [ ( '<STR_LIT>' + str ( i ) + '<STR_LIT>' ) ] <EOL> strides_statements = [ '<STR_LIT>' % nd_out ] <EOL> for i , o in enumerate ( self . new_order ) : <EOL> if o != '<STR_LIT:x>' : <EOL> strides_statements += [ ( '<STR_LIT>' + str ( i ) + <EOL> '<STR_LIT>' + <EOL> str ( o ) + <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' + <EOL> str ( o ) + '<STR_LIT:]>' ) ] <EOL> else : <EOL> strides_statements += [ ( '<STR_LIT>' + str ( i ) + '<STR_LIT>' ) ] <EOL> if nd_out > <NUM_LIT:0> : <EOL> strides_statements . append ( <EOL> '<STR_LIT>' + <EOL> str ( nd_out ) + <EOL> '<STR_LIT>' + <EOL> str ( nd_out ) + <EOL> '<STR_LIT>' <EOL> ) <EOL> for i in xrange ( nd_out - <NUM_LIT:2> , - <NUM_LIT:1> , - <NUM_LIT:1> ) : <EOL> strides_statements . append ( <EOL> \"<STR_LIT>\" % dict ( i = str ( i ) ) ) <EOL> close_bracket = [ <EOL> ( '<STR_LIT>' <EOL> '<STR_LIT>' + str ( nd_out ) + '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> '<STR_LIT:}>' ] <EOL> full_code = statements ( check_input_nd + <EOL> clear_output + <EOL> get_base + <EOL> shape_statements + <EOL> strides_statements + <EOL> close_bracket ) <EOL> if <NUM_LIT:0> : <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( self ) <EOL> print ( \"<STR_LIT>\" , self . input_broadcastable ) <EOL> print ( \"<STR_LIT>\" , self . new_order ) <EOL> print ( \"<STR_LIT>\" , self . shuffle ) <EOL> print ( \"<STR_LIT>\" , self . augment ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( full_code ) <EOL> if <NUM_LIT:0> : <EOL> sys . exit ( ) <EOL> return full_code % dict ( locals ( ) , ** sub ) <EOL> def c_code_cache_version ( self ) : <EOL> return ( <NUM_LIT:3> , ) <EOL> def grad ( self , inp , grads ) : <EOL> x , = inp <EOL> gz , = grads <EOL> gz = as_tensor_variable ( gz ) <EOL> grad_order = [ '<STR_LIT:x>' ] * len ( x . type . broadcastable ) <EOL> for i , v in enumerate ( self . new_order ) : <EOL> if v != '<STR_LIT:x>' : <EOL> grad_order [ v ] = i <EOL> if '<STR_LIT:int>' in inp [ <NUM_LIT:0> ] . dtype : <EOL> return [ inp [ <NUM_LIT:0> ] . zeros_like ( dtype = theano . config . floatX ) ] <EOL> else : <EOL> return [ DimShuffle ( gz . type . broadcastable , grad_order ) ( <EOL> Elemwise ( scalar . identity ) ( gz ) ) ] <EOL> class DimShufflePrinter : <EOL> def __p ( self , new_order , pstate , r ) : <EOL> if new_order != ( ) and new_order [ <NUM_LIT:0> ] == '<STR_LIT:x>' : <EOL> return \"<STR_LIT:%s>\" % self . __p ( new_order [ <NUM_LIT:1> : ] , pstate , r ) <EOL> if list ( new_order ) == list ( range ( r . type . ndim ) ) : <EOL> return pstate . pprinter . process ( r ) <EOL> if list ( new_order ) == list ( reversed ( range ( r . type . ndim ) ) ) : <EOL> return \"<STR_LIT>\" % pstate . pprinter . process ( r ) <EOL> return \"<STR_LIT>\" % ( \"<STR_LIT:U+002CU+0020>\" . join ( map ( str , new_order ) ) , <EOL> pstate . pprinter . process ( r ) ) <EOL> def process ( self , r , pstate ) : <EOL> if r . owner is None : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> elif isinstance ( r . owner . op , DimShuffle ) : <EOL> ord = r . owner . op . new_order <EOL> return self . __p ( ord , pstate , r . owner . inputs [ <NUM_LIT:0> ] ) <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> pprint . assign ( lambda pstate , r : r . owner and isinstance ( r . owner . op , DimShuffle ) , <EOL> DimShufflePrinter ( ) ) <EOL> class Elemwise ( OpenMPOp ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , scalar_op , inplace_pattern = None , name = None , <EOL> nfunc_spec = None , openmp = None ) : <EOL> if inplace_pattern is None : <EOL> inplace_pattern = { } <EOL> self . name = name <EOL> self . scalar_op = scalar_op <EOL> self . inplace_pattern = inplace_pattern <EOL> self . destroy_map = dict ( ( o , [ i ] ) for o , i in inplace_pattern . items ( ) ) <EOL> self . ufunc = None <EOL> self . nfunc = None <EOL> if nfunc_spec is None : <EOL> nfunc_spec = getattr ( scalar_op , '<STR_LIT>' , None ) <EOL> self . nfunc_spec = nfunc_spec <EOL> if nfunc_spec : <EOL> self . nfunc = getattr ( numpy , nfunc_spec [ <NUM_LIT:0> ] ) <EOL> self . _rehash ( ) <EOL> super ( Elemwise , self ) . __init__ ( openmp = openmp ) <EOL> def __getstate__ ( self ) : <EOL> d = copy ( self . __dict__ ) <EOL> d . pop ( '<STR_LIT>' ) <EOL> d . pop ( '<STR_LIT>' ) <EOL> d . pop ( '<STR_LIT>' , None ) <EOL> d . pop ( '<STR_LIT>' ) <EOL> return d <EOL> def __setstate__ ( self , d ) : <EOL> super ( Elemwise , self ) . __setstate__ ( d ) <EOL> self . ufunc = None <EOL> self . nfunc = None <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> self . nfunc = getattr ( numpy , self . nfunc_spec [ <NUM_LIT:0> ] ) <EOL> elif <NUM_LIT:0> < self . scalar_op . nin < <NUM_LIT:32> : <EOL> self . ufunc = numpy . frompyfunc ( self . scalar_op . impl , <EOL> self . scalar_op . nin , <EOL> self . scalar_op . nout ) <EOL> self . _rehash ( ) <EOL> def make_node ( self , * inputs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> inputs = list ( map ( as_tensor_variable , inputs ) ) <EOL> shadow = self . scalar_op . make_node ( <EOL> * [ get_scalar_type ( dtype = i . type . dtype ) . make_variable ( ) <EOL> for i in inputs ] ) <EOL> target_length = max ( [ input . type . ndim for input in inputs ] ) <EOL> args = [ ] <EOL> for input in inputs : <EOL> length = input . type . ndim <EOL> difference = target_length - length <EOL> if not difference : <EOL> args . append ( input ) <EOL> else : <EOL> args . append ( DimShuffle ( <EOL> input . type . broadcastable , <EOL> [ '<STR_LIT:x>' ] * difference + list ( range ( length ) ) , <EOL> inplace = False ) ( input ) ) <EOL> inputs = args <EOL> out_broadcastables = [ [ all ( bcast ) <EOL> for bcast in <EOL> izip ( * [ input . type . broadcastable <EOL> for input in inputs ] ) ] ] * shadow . nout <EOL> inplace_pattern = self . inplace_pattern <EOL> if inplace_pattern : <EOL> for overwriter , overwritten in iteritems ( inplace_pattern ) : <EOL> for ob , ib in izip ( out_broadcastables [ overwriter ] , <EOL> inputs [ overwritten ] . type . broadcastable ) : <EOL> if ib and not ob : <EOL> raise ValueError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> out_dtypes = [ o . type . dtype for o in shadow . outputs ] <EOL> if any ( inputs [ i ] . type . dtype != out_dtypes [ o ] <EOL> for o , i in inplace_pattern . items ( ) ) : <EOL> raise TypeError ( ( <EOL> \"<STR_LIT>\" , <EOL> ( [ i . type . dtype for i in inputs ] , out_dtypes , inplace_pattern ) ) ) <EOL> outputs = [ TensorType ( dtype = dtype , broadcastable = broadcastable ) ( ) <EOL> for dtype , broadcastable in izip ( out_dtypes , <EOL> out_broadcastables ) ] <EOL> return Apply ( self , inputs , outputs ) <EOL> def __eq__ ( self , other ) : <EOL> if type ( self ) == type ( other ) : <EOL> items = list ( self . inplace_pattern . items ( ) ) <EOL> other_items = list ( other . inplace_pattern . items ( ) ) <EOL> items . sort ( ) <EOL> other_items . sort ( ) <EOL> rval = ( ( self . scalar_op == other . scalar_op ) and <EOL> ( items == other_items ) ) <EOL> return rval <EOL> return False <EOL> def _rehash ( self ) : <EOL> inplace_pattern_hash = hash_from_dict ( self . inplace_pattern ) <EOL> h = hash ( '<STR_LIT>' ) ^ hash ( self . scalar_op ) ^ inplace_pattern_hash <EOL> assert h == getattr ( self , '<STR_LIT>' , h ) <EOL> self . _hashval = h <EOL> def __hash__ ( self ) : <EOL> return self . _hashval <EOL> def __str__ ( self ) : <EOL> if self . name is None : <EOL> if self . inplace_pattern : <EOL> items = list ( self . inplace_pattern . items ( ) ) <EOL> items . sort ( ) <EOL> return \"<STR_LIT>\" % ( self . scalar_op , str ( items ) ) <EOL> else : <EOL> return \"<STR_LIT>\" % ( self . scalar_op ) <EOL> else : <EOL> return self . name <EOL> def R_op ( self , inputs , eval_points ) : <EOL> outs = self ( * inputs , ** dict ( return_list = True ) ) <EOL> rval = [ None for x in outs ] <EOL> for idx , out in enumerate ( outs ) : <EOL> ograds = [ x . zeros_like ( ) for x in outs ] <EOL> ograds [ idx ] = theano . tensor . ones_like ( out ) <EOL> bgrads = self . _bgrad ( inputs , ograds ) <EOL> rop_out = None <EOL> for jdx , ( inp , eval_point ) in enumerate ( izip ( inputs , <EOL> eval_points ) ) : <EOL> if bgrads [ jdx ] is None or isinstance ( bgrads [ jdx ] . type , DisconnectedType ) : <EOL> pass <EOL> elif eval_point is not None : <EOL> if rop_out is None : <EOL> rop_out = bgrads [ jdx ] * eval_point <EOL> else : <EOL> rop_out = rop_out + bgrads [ jdx ] * eval_point <EOL> rval [ idx ] = rop_out <EOL> return rval <EOL> def connection_pattern ( self , node ) : <EOL> if hasattr ( self . scalar_op , '<STR_LIT>' ) : <EOL> return self . scalar_op . connection_pattern ( node ) <EOL> return [ [ True for output in node . outputs ] for ipt in node . inputs ] <EOL> def grad ( self , inputs , ograds ) : <EOL> outs = self ( * inputs ) <EOL> if not isinstance ( outs , ( list , tuple ) ) : <EOL> outs = [ outs ] <EOL> rval = self . _bgrad ( inputs , ograds ) <EOL> if False in [ str ( out . type . dtype ) . find ( '<STR_LIT:int>' ) == - <NUM_LIT:1> <EOL> for out in outs ] : <EOL> new_rval = [ ] <EOL> for elem , ipt in izip ( rval , inputs ) : <EOL> if isinstance ( elem . type , ( NullType , DisconnectedType ) ) : <EOL> new_rval . append ( elem ) <EOL> else : <EOL> elem = ipt . zeros_like ( ) <EOL> if str ( elem . type . dtype ) . find ( '<STR_LIT:int>' ) != - <NUM_LIT:1> : <EOL> elem = elem . astype ( theano . config . floatX ) <EOL> assert str ( elem . type . dtype ) . find ( '<STR_LIT:int>' ) == - <NUM_LIT:1> <EOL> new_rval . append ( elem ) <EOL> return new_rval <EOL> for i , ipt in enumerate ( inputs ) : <EOL> if isinstance ( rval [ i ] . type , ( NullType , DisconnectedType ) ) : <EOL> continue <EOL> to_sum = [ j for j , bcast in enumerate ( ipt . type . broadcastable ) <EOL> if bcast ] <EOL> if to_sum : <EOL> shuffle = [ ] <EOL> j = <NUM_LIT:0> <EOL> for bcast in ipt . type . broadcastable : <EOL> if bcast == <NUM_LIT:1> : <EOL> shuffle . append ( '<STR_LIT:x>' ) <EOL> else : <EOL> shuffle . append ( j ) <EOL> j += <NUM_LIT:1> <EOL> sr = Sum ( axis = to_sum ) ( rval [ i ] ) <EOL> sr = sr . dimshuffle ( shuffle ) <EOL> rval [ i ] = sr <EOL> return rval <EOL> def _bgrad ( self , inputs , ograds ) : <EOL> prev_setting = theano . config . compute_test_value <EOL> try : <EOL> theano . config . compute_test_value = '<STR_LIT>' <EOL> def as_scalar ( t ) : <EOL> if isinstance ( t . type , ( NullType , DisconnectedType ) ) : <EOL> return t <EOL> return get_scalar_type ( t . type . dtype ) ( ) <EOL> scalar_inputs = list ( map ( as_scalar , inputs ) ) <EOL> scalar_ograds = list ( map ( as_scalar , ograds ) ) <EOL> scalar_igrads = self . scalar_op . grad ( scalar_inputs , scalar_ograds ) <EOL> for igrad in scalar_igrads : <EOL> assert igrad is not None , self . scalar_op <EOL> finally : <EOL> theano . config . compute_test_value = prev_setting <EOL> if not isinstance ( scalar_igrads , ( list , tuple ) ) : <EOL> raise TypeError ( '<STR_LIT>' % <EOL> ( str ( self . scalar_op ) , str ( type ( scalar_igrads ) ) ) ) <EOL> nd = len ( inputs [ <NUM_LIT:0> ] . type . broadcastable ) <EOL> def transform ( r ) : <EOL> if isinstance ( r . type , ( NullType , DisconnectedType ) ) : <EOL> return r <EOL> if r in scalar_inputs : <EOL> return inputs [ scalar_inputs . index ( r ) ] <EOL> if r in scalar_ograds : <EOL> return ograds [ scalar_ograds . index ( r ) ] <EOL> node = r . owner <EOL> if node is None : <EOL> res = theano . tensor . constant ( numpy . asarray ( r . data ) , dtype = r . type . dtype ) <EOL> return DimShuffle ( ( ) , [ '<STR_LIT:x>' ] * nd , inplace = False ) ( res ) <EOL> new_r = Elemwise ( node . op , { } ) ( <EOL> * [ transform ( ipt ) for ipt in node . inputs ] ) <EOL> return new_r <EOL> ret = [ ] <EOL> for scalar_igrad , ipt in izip ( scalar_igrads , inputs ) : <EOL> if scalar_igrad is None : <EOL> ret . append ( None ) <EOL> continue <EOL> ret . append ( transform ( scalar_igrad ) ) <EOL> return ret <EOL> def prepare_node ( self , node , storage_map , compute_map ) : <EOL> if ( len ( node . inputs ) < <NUM_LIT:32> and <EOL> ( self . nfunc is None or <EOL> self . scalar_op . nin != len ( node . inputs ) ) and <EOL> self . ufunc is None ) : <EOL> ufunc = numpy . frompyfunc ( self . scalar_op . impl , <EOL> len ( node . inputs ) , <EOL> self . scalar_op . nout ) <EOL> if self . scalar_op . nin > <NUM_LIT:0> : <EOL> self . ufunc = ufunc <EOL> else : <EOL> node . tag . ufunc = ufunc <EOL> out_dtype = node . outputs [ <NUM_LIT:0> ] . dtype <EOL> if ( out_dtype in float_dtypes and <EOL> isinstance ( self . nfunc , numpy . ufunc ) and <EOL> node . inputs [ <NUM_LIT:0> ] . dtype in discrete_dtypes ) : <EOL> char = numpy . sctype2char ( out_dtype ) <EOL> sig = char * node . nin + '<STR_LIT>' + char * node . nout <EOL> node . tag . sig = sig <EOL> def perform ( self , node , inputs , output_storage ) : <EOL> if len ( node . inputs ) >= <NUM_LIT:32> : <EOL> super ( Elemwise , self ) . perform ( node , inputs , output_storage ) <EOL> for dims in izip ( * [ list ( zip ( input . shape , sinput . type . broadcastable ) ) <EOL> for input , sinput in zip ( inputs , node . inputs ) ] ) : <EOL> if max ( d for d , b in dims ) != <NUM_LIT:1> and ( <NUM_LIT:1> , False ) in dims : <EOL> msg = [ ] <EOL> assert len ( inputs ) == len ( node . inputs ) <EOL> for input , sinput in zip ( inputs , node . inputs ) : <EOL> assert len ( input . shape ) == len ( sinput . type . broadcastable ) <EOL> msg2 = [ ] <EOL> for d , b in zip ( input . shape , sinput . type . broadcastable ) : <EOL> if b : <EOL> msg2 += [ '<STR_LIT:*>' ] <EOL> else : <EOL> msg2 += [ str ( d ) ] <EOL> msg . append ( '<STR_LIT>' % \"<STR_LIT:U+002CU+0020>\" . join ( msg2 ) ) <EOL> base_exc_str = '<STR_LIT>' % ( <EOL> '<STR_LIT:U+002CU+0020>' . join ( msg ) ) <EOL> raise ValueError ( base_exc_str ) <EOL> out_shape = [ ] <EOL> for values in izip ( * [ input . shape for input in inputs ] ) : <EOL> if any ( v == <NUM_LIT:0> for v in values ) : <EOL> assert max ( values ) <= <NUM_LIT:1> <EOL> out_shape . append ( <NUM_LIT:0> ) <EOL> else : <EOL> out_shape . append ( max ( values ) ) <EOL> out_shape = tuple ( out_shape ) <EOL> ufunc_args = inputs <EOL> ufunc_kwargs = { } <EOL> if self . nfunc and len ( inputs ) == self . nfunc_spec [ <NUM_LIT:1> ] : <EOL> ufunc = self . nfunc <EOL> nout = self . nfunc_spec [ <NUM_LIT:2> ] <EOL> if hasattr ( node . tag , '<STR_LIT>' ) : <EOL> ufunc_kwargs [ '<STR_LIT>' ] = node . tag . sig <EOL> else : <EOL> if self . ufunc : <EOL> ufunc = self . ufunc <EOL> else : <EOL> if not hasattr ( node . tag , '<STR_LIT>' ) : <EOL> node . tag . ufunc = numpy . frompyfunc ( self . scalar_op . impl , <EOL> len ( node . inputs ) , <EOL> self . scalar_op . nout ) <EOL> ufunc = node . tag . ufunc <EOL> nout = ufunc . nout <EOL> variables = ufunc ( * ufunc_args , ** ufunc_kwargs ) <EOL> if nout == <NUM_LIT:1> : <EOL> variables = [ variables ] <EOL> i = <NUM_LIT:0> <EOL> for variable , storage , nout in izip ( variables , output_storage , <EOL> node . outputs ) : <EOL> if getattr ( variable , \"<STR_LIT>\" , \"<STR_LIT>\" ) == '<STR_LIT:object>' : <EOL> variable = numpy . asarray ( variable , dtype = nout . dtype ) <EOL> if i in self . inplace_pattern : <EOL> odat = inputs [ self . inplace_pattern [ i ] ] <EOL> odat [ ... ] = variable <EOL> storage [ <NUM_LIT:0> ] = odat <EOL> elif ( not isinstance ( variable , numpy . ndarray ) or <EOL> variable . dtype != nout . dtype ) : <EOL> variable = numpy . asarray ( variable , nout . dtype ) <EOL> if numpy . dtype ( nout . dtype ) . num != variable . dtype . num : <EOL> variable = variable . view ( dtype = nout . dtype ) <EOL> storage [ <NUM_LIT:0> ] = variable <EOL> elif not variable . flags . owndata : <EOL> storage [ <NUM_LIT:0> ] = variable . copy ( ) <EOL> else : <EOL> storage [ <NUM_LIT:0> ] = variable <EOL> i += <NUM_LIT:1> <EOL> def infer_shape ( self , node , i_shapes ) : <EOL> rval = [ ] <EOL> for o in node . outputs : <EOL> oshp = [ ] <EOL> for dim , b in enumerate ( o . type . broadcastable ) : <EOL> b_dim = None <EOL> if b : <EOL> b_dim = <NUM_LIT:1> <EOL> else : <EOL> for ishp , i in izip ( i_shapes , node . inputs ) : <EOL> if isinstance ( i . type , theano . scalar . Scalar ) : <EOL> continue <EOL> if not i . type . broadcastable [ dim ] : <EOL> if ishp [ dim ] : <EOL> b_dim = ishp [ dim ] <EOL> break <EOL> oshp . append ( b_dim ) <EOL> rval . append ( tuple ( oshp ) ) <EOL> return rval <EOL> def _c_all ( self , node , nodename , inames , onames , sub ) : <EOL> _inames = inames <EOL> _onames = onames <EOL> inames = gof . utils . uniq ( inames ) <EOL> inputs = gof . utils . uniq ( node . inputs ) <EOL> assert len ( inames ) == len ( inputs ) <EOL> ii , iii = list ( zip ( * gof . utils . uniq ( list ( zip ( _inames , node . inputs ) ) ) ) ) <EOL> assert all ( [ x == y for x , y in zip ( ii , inames ) ] ) <EOL> assert all ( [ x == y for x , y in zip ( iii , inputs ) ] ) <EOL> defines = \"<STR_LIT>\" <EOL> undefs = \"<STR_LIT>\" <EOL> dmap = dict ( [ ( node . outputs [ o ] , [ node . inputs [ i ] ] ) <EOL> for o , i in iteritems ( self . inplace_pattern ) ] ) <EOL> idtypes = [ input . type . dtype_specs ( ) [ <NUM_LIT:1> ] for input in inputs ] <EOL> real = list ( zip ( * [ ( r , s , r . type . dtype_specs ( ) [ <NUM_LIT:1> ] ) <EOL> for r , s in izip ( node . outputs , onames ) <EOL> if r not in dmap ] ) ) <EOL> if real : <EOL> real_outputs , real_onames , real_odtypes = real <EOL> else : <EOL> real_outputs , real_onames , real_odtypes = [ ] , [ ] , [ ] <EOL> aliased = list ( zip ( * [ ( r , s ) <EOL> for ( r , s ) in izip ( node . outputs , onames ) <EOL> if r in dmap ] ) ) <EOL> if aliased : <EOL> aliased_outputs , aliased_onames = aliased <EOL> else : <EOL> aliased_outputs , aliased_onames = [ ] , [ ] <EOL> orders = [ [ x and '<STR_LIT:x>' or i <EOL> for i , x in enumerate ( input . type . broadcastable ) ] <EOL> for input in inputs ] <EOL> nnested = len ( orders [ <NUM_LIT:0> ] ) <EOL> sub = dict ( sub ) <EOL> for i , ( input , iname ) in enumerate ( izip ( inputs , inames ) ) : <EOL> sub [ '<STR_LIT>' % i ] = iname <EOL> decl = cgen . make_declare ( orders , idtypes , sub ) <EOL> checks = cgen . make_checks ( orders , idtypes , sub ) <EOL> z = list ( zip ( inames , inputs ) ) <EOL> alloc_fortran = '<STR_LIT>' . join ( [ \"<STR_LIT>\" % arr <EOL> for arr , var in z <EOL> if not all ( var . broadcastable ) ] ) <EOL> if len ( alloc_fortran ) == <NUM_LIT:0> : <EOL> alloc_fortran = '<STR_LIT:0>' <EOL> alloc = \"<STR_LIT>\" <EOL> for output , oname , odtype in izip ( <EOL> real_outputs , real_onames , real_odtypes ) : <EOL> i += <NUM_LIT:1> <EOL> sub [ '<STR_LIT>' % i ] = oname <EOL> sub [ '<STR_LIT>' ] = oname <EOL> alloc += cgen . make_declare ( [ list ( range ( nnested ) ) ] , [ odtype ] , <EOL> dict ( sub , lv0 = oname ) ) <EOL> alloc += cgen . make_alloc ( orders , odtype , sub , <EOL> fortran = alloc_fortran ) <EOL> alloc += cgen . make_checks ( [ list ( range ( nnested ) ) ] , [ odtype ] , <EOL> dict ( sub , lv0 = oname ) ) <EOL> olv_index = i <EOL> for output , oname in izip ( aliased_outputs , aliased_onames ) : <EOL> olv_index = inputs . index ( dmap [ output ] [ <NUM_LIT:0> ] ) <EOL> iname = inames [ olv_index ] <EOL> alloc += \"\"\"<STR_LIT>\"\"\" % locals ( ) <EOL> defines += \"<STR_LIT>\" % locals ( ) <EOL> undefs += \"<STR_LIT>\" % locals ( ) <EOL> task_code = self . scalar_op . c_code ( <EOL> Apply ( self . scalar_op , <EOL> [ get_scalar_type ( dtype = input . type . dtype ) . make_variable ( ) <EOL> for input in node . inputs ] , <EOL> [ get_scalar_type ( dtype = output . type . dtype ) . make_variable ( ) <EOL> for output in node . outputs ] ) , <EOL> nodename + '<STR_LIT>' , <EOL> [ \"<STR_LIT>\" % s for s in _inames ] , <EOL> [ \"<STR_LIT>\" % s for s in onames ] , <EOL> sub ) <EOL> code = \"\"\"<STR_LIT>\"\"\" % locals ( ) <EOL> loop_orders = orders + [ list ( range ( nnested ) ) ] * len ( real_onames ) <EOL> dtypes = ( idtypes + list ( real_odtypes ) ) <EOL> if all ( [ o . ndim <= <NUM_LIT:1> for o in node . outputs ] or <EOL> all ( node . outputs [ <NUM_LIT:0> ] . broadcastable ) ) : <EOL> if nnested : <EOL> all_code = [ ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ] * ( nnested - <NUM_LIT:1> ) + [ ( \"<STR_LIT>\" , code ) ] + [ \"<STR_LIT>\" ] <EOL> else : <EOL> all_code = [ code ] <EOL> if len ( all_code ) == <NUM_LIT:1> : <EOL> task_decl = \"<STR_LIT>\" . join ( [ <EOL> \"<STR_LIT>\" % ( dtype , name , name ) <EOL> for name , dtype in izip ( inames + list ( real_onames ) , <EOL> idtypes + list ( real_odtypes ) ) ] ) <EOL> preloops = { } <EOL> for i , ( loop_order , dtype ) in enumerate ( zip ( loop_orders , dtypes ) ) : <EOL> for j , index in enumerate ( loop_order ) : <EOL> if index != '<STR_LIT:x>' : <EOL> preloops . setdefault ( j , \"<STR_LIT>\" ) <EOL> preloops [ j ] += ( \"<STR_LIT>\" % locals ( ) ) % sub <EOL> break <EOL> else : <EOL> preloops . setdefault ( <NUM_LIT:0> , \"<STR_LIT>\" ) <EOL> preloops [ <NUM_LIT:0> ] += ( \"<STR_LIT>\" % locals ( ) ) % sub <EOL> init_array = preloops . get ( <NUM_LIT:0> , \"<STR_LIT:U+0020>\" ) <EOL> loop = \"\"\"<STR_LIT>\"\"\" % locals ( ) <EOL> else : <EOL> loop = cgen . make_loop ( <EOL> loop_orders = loop_orders , <EOL> dtypes = dtypes , <EOL> loop_tasks = all_code , <EOL> sub = sub , openmp = self . openmp ) <EOL> else : <EOL> loop = cgen . make_reordered_loop ( <EOL> init_loop_orders = loop_orders , <EOL> olv_index = olv_index , <EOL> dtypes = dtypes , <EOL> inner_task = code , <EOL> sub = sub , openmp = self . openmp ) <EOL> if ( all ( [ o . ndim >= <NUM_LIT:1> for o in node . outputs ] ) and <EOL> not all ( node . outputs [ <NUM_LIT:0> ] . broadcastable ) ) : <EOL> contig = None <EOL> try : <EOL> contig = self . scalar_op . c_code_contiguous ( <EOL> node , <EOL> nodename + '<STR_LIT>' , <EOL> _inames , <EOL> onames , <EOL> sub ) <EOL> except theano . gof . utils . MethodNotDefined : <EOL> if all ( [ io . broadcastable == node . outputs [ <NUM_LIT:0> ] . broadcastable or <EOL> all ( io . broadcastable ) <EOL> for io in node . inputs + node . outputs ] ) : <EOL> z = onames [ <NUM_LIT:0> ] <EOL> contig = \"\"\"<STR_LIT>\"\"\" % locals ( ) <EOL> index = \"<STR_LIT>\" <EOL> for x , var in zip ( inames + onames , <EOL> inputs + node . outputs ) : <EOL> if not all ( var . broadcastable ) : <EOL> contig += \"\"\"<STR_LIT>\"\"\" % locals ( ) <EOL> index += \"\"\"<STR_LIT>\"\"\" % locals ( ) <EOL> else : <EOL> contig += \"\"\"<STR_LIT>\"\"\" % locals ( ) <EOL> if self . openmp : <EOL> contig += \"\"\"<STR_LIT>\"\"\" % ( config . openmp_elemwise_minsize ) <EOL> contig += \"\"\"<STR_LIT>\"\"\" % locals ( ) <EOL> if contig is not None : <EOL> z = list ( zip ( inames + onames , inputs + node . outputs ) ) <EOL> cond1 = '<STR_LIT>' . join ( [ \"<STR_LIT>\" % arr <EOL> for arr , var in z <EOL> if not all ( var . broadcastable ) ] ) <EOL> cond2 = '<STR_LIT>' . join ( [ \"<STR_LIT>\" % arr <EOL> for arr , var in z <EOL> if not all ( var . broadcastable ) ] ) <EOL> loop = \"\"\"<STR_LIT>\"\"\" % locals ( ) <EOL> return decl , checks , alloc , loop <EOL> def c_code ( self , node , nodename , inames , onames , sub ) : <EOL> if ( any ( i . dtype == '<STR_LIT>' for i in node . inputs ) or <EOL> any ( o . dtype == '<STR_LIT>' for o in node . outputs ) or <EOL> getattr ( self . scalar_op , '<STR_LIT>' , False ) ) : <EOL> super ( Elemwise , self ) . c_code ( node , nodename , inames , onames , sub ) <EOL> code = \"<STR_LIT:\\n>\" . join ( self . _c_all ( node , nodename , inames , onames , sub ) ) <EOL> return code <EOL> def c_headers ( self ) : <EOL> return [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def c_support_code ( self ) : <EOL> return self . scalar_op . c_support_code ( ) <EOL> def c_support_code_apply ( self , node , nodename ) : <EOL> support_code = self . scalar_op . c_support_code_apply ( node , nodename + <EOL> '<STR_LIT>' ) <EOL> return support_code <EOL> def c_code_cache_version_apply ( self , node ) : <EOL> version = [ <NUM_LIT:12> ] <EOL> scalar_node = Apply ( <EOL> self . scalar_op , <EOL> [ get_scalar_type ( dtype = input . type . dtype ) . make_variable ( ) <EOL> for input in node . inputs ] , <EOL> [ get_scalar_type ( dtype = output . type . dtype ) . make_variable ( ) <EOL> for output in node . outputs ] ) <EOL> version . append ( self . scalar_op . c_code_cache_version_apply ( scalar_node ) ) <EOL> for i in node . inputs + node . outputs : <EOL> version . append ( get_scalar_type ( dtype = i . type . dtype ) . c_code_cache_version ( ) ) <EOL> version . append ( ( '<STR_LIT>' , self . openmp ) ) <EOL> if all ( version ) : <EOL> return tuple ( version ) <EOL> else : <EOL> return ( ) <EOL> def python_constant_folding ( self , node ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return node . outputs [ <NUM_LIT:0> ] . ndim == <NUM_LIT:0> <EOL> class CAReduce ( Op ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , scalar_op , axis = None ) : <EOL> if scalar_op . nin not in [ - <NUM_LIT:1> , <NUM_LIT:2> ] or scalar_op . nout != <NUM_LIT:1> : <EOL> raise NotImplementedError ( ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) ) <EOL> self . scalar_op = scalar_op <EOL> if axis is None : <EOL> self . axis = axis <EOL> elif isinstance ( axis , ( int , numpy . integer ) ) : <EOL> self . axis = ( axis , ) <EOL> elif isinstance ( axis , numpy . ndarray ) and axis . ndim == <NUM_LIT:0> : <EOL> self . axis = ( int ( axis ) , ) <EOL> else : <EOL> self . axis = list ( set ( int ( a ) for a in axis ) ) <EOL> self . axis . sort ( ) <EOL> self . axis = tuple ( self . axis ) <EOL> self . set_ufunc ( scalar_op ) <EOL> def set_ufunc ( self , scalar_op ) : <EOL> if isinstance ( scalar_op , theano . scalar . basic . Add ) : <EOL> self . ufunc = numpy . add <EOL> elif isinstance ( scalar_op , theano . scalar . basic . Mul ) : <EOL> self . ufunc = numpy . multiply <EOL> elif isinstance ( scalar_op , theano . scalar . basic . Maximum ) : <EOL> self . ufunc = numpy . maximum <EOL> elif isinstance ( scalar_op , theano . scalar . basic . Minimum ) : <EOL> self . ufunc = numpy . minimum <EOL> elif isinstance ( scalar_op , theano . scalar . basic . AND ) : <EOL> self . ufunc = numpy . bitwise_and <EOL> elif isinstance ( scalar_op , theano . scalar . basic . OR ) : <EOL> self . ufunc = numpy . bitwise_or <EOL> elif isinstance ( scalar_op , theano . scalar . basic . XOR ) : <EOL> self . ufunc = numpy . bitwise_xor <EOL> else : <EOL> self . ufunc = numpy . frompyfunc ( scalar_op . impl , <NUM_LIT:2> , <NUM_LIT:1> ) <EOL> def _output_dtype ( self , input_dtype ) : <EOL> return input_dtype <EOL> def make_node ( self , input ) : <EOL> input = as_tensor_variable ( input ) <EOL> if self . axis is not None : <EOL> for axis in self . axis : <EOL> if ( axis >= input . type . ndim or <EOL> ( axis < <NUM_LIT:0> and abs ( axis ) > input . type . ndim ) ) : <EOL> raise ValueError ( ( <EOL> '<STR_LIT>' <EOL> % ( input , axis ) ) ) <EOL> input = as_tensor_variable ( input ) <EOL> axis = self . axis <EOL> if axis is None : <EOL> axis = list ( range ( len ( input . type . broadcastable ) ) ) <EOL> if any ( a < <NUM_LIT:0> for a in axis ) : <EOL> axis2 = [ ] <EOL> for a in self . axis : <EOL> if a < <NUM_LIT:0> : <EOL> axis2 . append ( a + input . type . ndim ) <EOL> else : <EOL> axis2 . append ( a ) <EOL> assert len ( axis ) == len ( axis2 ) <EOL> axis = tuple ( axis2 ) <EOL> op = copy ( self ) <EOL> op . set_ufunc ( op . scalar_op ) <EOL> op . axis = axis <EOL> else : <EOL> op = self <EOL> broadcastable = [ x for i , x in enumerate ( input . type . broadcastable ) <EOL> if i not in axis ] <EOL> output = TensorType ( dtype = self . _output_dtype ( input . type . dtype ) , <EOL> broadcastable = broadcastable ) ( ) <EOL> return Apply ( op , [ input ] , [ output ] ) <EOL> def __getstate__ ( self ) : <EOL> d = copy ( self . __dict__ ) <EOL> d . pop ( '<STR_LIT>' , None ) <EOL> return d <EOL> def __setstate__ ( self , d ) : <EOL> self . __dict__ . update ( d ) <EOL> self . set_ufunc ( self . scalar_op ) <EOL> def __eq__ ( self , other ) : <EOL> return ( type ( self ) == type ( other ) and <EOL> self . scalar_op == other . scalar_op and <EOL> self . axis == other . axis ) <EOL> def __hash__ ( self ) : <EOL> if self . axis is None : <EOL> return hash ( self . scalar_op ) <EOL> else : <EOL> return hash ( self . scalar_op ) ^ hash ( tuple ( self . axis ) ) <EOL> def __str__ ( self ) : <EOL> if self . axis is not None : <EOL> return \"<STR_LIT>\" % ( <EOL> self . scalar_op , \"<STR_LIT:U+002CU+0020>\" . join ( str ( x ) for x in self . axis ) ) <EOL> else : <EOL> return \"<STR_LIT>\" % self . scalar_op <EOL> def perform ( self , node , inp , out ) : <EOL> input , = inp <EOL> output , = out <EOL> axis = self . axis <EOL> if axis is None : <EOL> axis = list ( range ( input . ndim ) ) <EOL> variable = input <EOL> to_reduce = reversed ( sorted ( axis ) ) <EOL> if hasattr ( self , '<STR_LIT>' ) and self . acc_dtype is not None : <EOL> acc_dtype = self . acc_dtype <EOL> else : <EOL> acc_dtype = node . outputs [ <NUM_LIT:0> ] . type . dtype <EOL> if to_reduce : <EOL> for dimension in to_reduce : <EOL> if variable . shape [ dimension ] == <NUM_LIT:0> : <EOL> if hasattr ( self . scalar_op , '<STR_LIT>' ) : <EOL> v_shape = list ( variable . shape ) <EOL> del v_shape [ dimension ] <EOL> variable = numpy . empty ( tuple ( v_shape ) , <EOL> dtype = acc_dtype ) <EOL> variable . fill ( self . scalar_op . identity ) <EOL> else : <EOL> raise ValueError ( ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> % ( variable , dimension , self . scalar_op ) ) ) <EOL> else : <EOL> if ( ( self . ufunc . ntypes == <NUM_LIT:1> ) and <EOL> ( self . ufunc . types [ <NUM_LIT:0> ] [ - <NUM_LIT:1> ] == '<STR_LIT:O>' ) ) : <EOL> variable = self . ufunc . reduce ( variable , dimension , <EOL> dtype = '<STR_LIT:object>' ) <EOL> else : <EOL> variable = self . ufunc . reduce ( variable , dimension , <EOL> dtype = acc_dtype ) <EOL> variable = numpy . asarray ( variable ) <EOL> if numpy . may_share_memory ( variable , input ) : <EOL> variable = variable . copy ( ) <EOL> output [ <NUM_LIT:0> ] = theano . _asarray ( variable , <EOL> dtype = node . outputs [ <NUM_LIT:0> ] . type . dtype ) <EOL> else : <EOL> output [ <NUM_LIT:0> ] = numpy . array ( variable , copy = True , <EOL> dtype = node . outputs [ <NUM_LIT:0> ] . type . dtype ) <EOL> def infer_shape ( self , node , shapes ) : <EOL> ishape , = shapes <EOL> axis = self . axis <EOL> if axis is None : <EOL> return ( ) , <EOL> return [ ishape [ i ] <EOL> for ( i , b ) in enumerate ( node . inputs [ <NUM_LIT:0> ] . type . broadcastable ) <EOL> if i not in axis ] , <EOL> def _c_all ( self , node , name , inames , onames , sub ) : <EOL> input = node . inputs [ <NUM_LIT:0> ] <EOL> output = node . outputs [ <NUM_LIT:0> ] <EOL> iname = inames [ <NUM_LIT:0> ] <EOL> oname = onames [ <NUM_LIT:0> ] <EOL> idtype = input . type . dtype_specs ( ) [ <NUM_LIT:1> ] <EOL> odtype = output . type . dtype_specs ( ) [ <NUM_LIT:1> ] <EOL> if hasattr ( self , '<STR_LIT>' ) and self . acc_dtype is not None : <EOL> if self . acc_dtype == '<STR_LIT>' : <EOL> raise theano . gof . utils . MethodNotDefined ( \"<STR_LIT>\" ) <EOL> acc_type = TensorType ( <EOL> broadcastable = node . outputs [ <NUM_LIT:0> ] . broadcastable , <EOL> dtype = self . acc_dtype ) <EOL> adtype = acc_type . dtype_specs ( ) [ <NUM_LIT:1> ] <EOL> else : <EOL> adtype = odtype <EOL> axis = self . axis <EOL> if axis is None : <EOL> axis = list ( range ( len ( input . type . broadcastable ) ) ) <EOL> if len ( axis ) == <NUM_LIT:0> : <EOL> var = theano . tensor . cast ( input , node . outputs [ <NUM_LIT:0> ] . dtype ) <EOL> if var is input : <EOL> var = Elemwise ( scalar . identity ) ( input ) <EOL> assert var . dtype == node . outputs [ <NUM_LIT:0> ] . dtype <EOL> return var . owner . op . _c_all ( var . owner , name , inames , onames , sub ) <EOL> order1 = [ i for i in xrange ( input . type . ndim ) if i not in axis ] <EOL> order = order1 + list ( axis ) <EOL> nnested = len ( order1 ) <EOL> sub = dict ( sub ) <EOL> for i , ( input , iname ) in enumerate ( izip ( node . inputs , inames ) ) : <EOL> sub [ '<STR_LIT>' % i ] = iname <EOL> decl = \"<STR_LIT>\" <EOL> if adtype != odtype : <EOL> aname = \"<STR_LIT>\" <EOL> decl = acc_type . c_declare ( aname , sub ) <EOL> decl += acc_type . c_init ( aname , sub ) <EOL> else : <EOL> aname = oname <EOL> decl += cgen . make_declare ( [ order ] , [ idtype ] , sub ) <EOL> checks = cgen . make_checks ( [ order ] , [ idtype ] , sub ) <EOL> alloc = \"<STR_LIT>\" <EOL> i += <NUM_LIT:1> <EOL> sub [ '<STR_LIT>' % i ] = oname <EOL> sub [ '<STR_LIT>' ] = oname <EOL> alloc += cgen . make_declare ( <EOL> [ list ( range ( nnested ) ) + [ '<STR_LIT:x>' ] * len ( axis ) ] , <EOL> [ odtype ] , dict ( sub , lv0 = oname ) ) <EOL> alloc += cgen . make_alloc ( [ order1 ] , odtype , sub ) <EOL> alloc += cgen . make_checks ( <EOL> [ list ( range ( nnested ) ) + [ '<STR_LIT:x>' ] * len ( axis ) ] , <EOL> [ odtype ] , dict ( sub , lv0 = oname ) ) <EOL> if adtype != odtype : <EOL> sub [ '<STR_LIT>' % i ] = aname <EOL> sub [ '<STR_LIT>' ] = aname <EOL> alloc += cgen . make_declare ( <EOL> [ list ( range ( nnested ) ) + [ '<STR_LIT:x>' ] * len ( axis ) ] , <EOL> [ adtype ] , dict ( sub , lv0 = aname ) ) <EOL> alloc += cgen . make_alloc ( [ order1 ] , adtype , sub ) <EOL> alloc += cgen . make_checks ( <EOL> [ list ( range ( nnested ) ) + [ '<STR_LIT:x>' ] * len ( axis ) ] , <EOL> [ adtype ] , dict ( sub , lv0 = aname ) ) <EOL> if hasattr ( self . scalar_op , '<STR_LIT>' ) : <EOL> identity = self . scalar_op . identity <EOL> elif self . scalar_op in [ scalar . maximum , scalar . minimum ] : <EOL> if self . scalar_op == scalar . maximum : <EOL> scal_name = '<STR_LIT>' <EOL> if input . type . dtype in [ \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> identity = \"<STR_LIT>\" <EOL> elif input . type . dtype . startswith ( \"<STR_LIT>\" ) : <EOL> identity = \"<STR_LIT:0>\" <EOL> else : <EOL> identity = \"<STR_LIT>\" + str ( input . type . dtype ) . upper ( ) <EOL> if self . scalar_op == scalar . minimum : <EOL> scal_name = '<STR_LIT>' <EOL> if input . type . dtype in [ \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> identity = \"<STR_LIT>\" <EOL> else : <EOL> identity = \"<STR_LIT>\" + str ( input . type . dtype ) . upper ( ) <EOL> fail = sub [ \"<STR_LIT>\" ] <EOL> pattern = [ <NUM_LIT:0> ] * len ( node . inputs [ <NUM_LIT:0> ] . broadcastable ) <EOL> axis = self . axis <EOL> if axis is None : <EOL> axis = list ( range ( len ( pattern ) ) ) <EOL> for i in axis : <EOL> pattern [ i ] = <NUM_LIT:1> <EOL> pattern_ = str ( pattern ) [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> decl += \"\"\"<STR_LIT>\"\"\" % locals ( ) <EOL> alloc += \"\"\"<STR_LIT>\"\"\" % locals ( ) <EOL> else : <EOL> raise TypeError ( <EOL> \"<STR_LIT>\" ) <EOL> task0_decl = ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> % dict ( dtype = adtype , name = aname , identity = identity ) ) <EOL> task1_decl = ( \"<STR_LIT>\" <EOL> % dict ( dtype = idtype , name = inames [ <NUM_LIT:0> ] ) ) <EOL> task1_code = self . scalar_op . c_code ( <EOL> Apply ( self . scalar_op , <EOL> [ get_scalar_type ( dtype = input . type . dtype ) . make_variable ( ) <EOL> for input in ( node . inputs * <NUM_LIT:2> ) ] , <EOL> [ get_scalar_type ( dtype = output . type . dtype ) . make_variable ( ) <EOL> for input in node . outputs ] ) , <EOL> None , <EOL> [ \"<STR_LIT>\" % aname , \"<STR_LIT>\" % inames [ <NUM_LIT:0> ] ] , <EOL> [ \"<STR_LIT>\" % aname ] , <EOL> sub ) <EOL> code1 = \"\"\"<STR_LIT>\"\"\" % locals ( ) <EOL> if node . inputs [ <NUM_LIT:0> ] . type . ndim : <EOL> if len ( axis ) == <NUM_LIT:1> : <EOL> all_code = [ ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ] * nnested + [ ( task0_decl , code1 ) , \"<STR_LIT>\" ] <EOL> else : <EOL> all_code = ( [ ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ] * nnested + <EOL> [ ( task0_decl , \"<STR_LIT>\" ) ] + <EOL> [ ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ] * ( len ( axis ) - <NUM_LIT:2> ) + <EOL> [ ( \"<STR_LIT>\" , code1 ) , \"<STR_LIT>\" ] ) <EOL> else : <EOL> all_code = [ task0_decl + code1 ] <EOL> loop = cgen . make_loop_careduce ( <EOL> [ order , list ( range ( nnested ) ) + [ '<STR_LIT:x>' ] * len ( axis ) ] , <EOL> [ idtype , adtype ] , all_code , sub ) <EOL> end = \"<STR_LIT>\" <EOL> if adtype != odtype : <EOL> end = \"\"\"<STR_LIT>\"\"\" % dict ( oname = oname , aname = aname ) <EOL> end += acc_type . c_cleanup ( aname , sub ) <EOL> return decl , checks , alloc , loop , end <EOL> def c_code ( self , node , name , inames , onames , sub ) : <EOL> code = \"<STR_LIT:\\n>\" . join ( self . _c_all ( node , name , inames , onames , sub ) ) <EOL> return code <EOL> def c_headers ( self ) : <EOL> return [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def c_code_cache_version_apply ( self , node ) : <EOL> version = ( <NUM_LIT:6> , ) <EOL> scalar_node = Apply ( <EOL> self . scalar_op , <EOL> [ get_scalar_type ( dtype = input . type . dtype ) . make_variable ( ) <EOL> for input in node . inputs ] , <EOL> [ get_scalar_type ( dtype = output . type . dtype ) . make_variable ( ) <EOL> for output in node . outputs ] ) <EOL>", "answer": "version . append ( self . scalar_op . c_code_cache_version_apply ( scalar_node ) )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import errno <EOL> import json <EOL> import logging <EOL> import os <EOL> import threading <EOL> from oauth2client . client import Credentials <EOL> from oauth2client . client import Storage as BaseStorage <EOL> from oauth2client import util <EOL> from oauth2client . contrib . locked_file import LockedFile <EOL> __author__ = '<STR_LIT>' <EOL> logger = logging . getLogger ( __name__ ) <EOL> _multistores = { } <EOL> _multistores_lock = threading . Lock ( ) <EOL> class Error ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class NewerCredentialStoreError ( Error ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _dict_to_tuple_key ( dictionary ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return tuple ( sorted ( dictionary . items ( ) ) ) <EOL> @ util . positional ( <NUM_LIT:4> ) <EOL> def get_credential_storage ( filename , client_id , user_agent , scope , <EOL> warn_on_readonly = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> key = { '<STR_LIT>' : client_id , '<STR_LIT>' : user_agent , <EOL> '<STR_LIT>' : util . scopes_to_string ( scope ) } <EOL> return get_credential_storage_custom_key ( <EOL> filename , key , warn_on_readonly = warn_on_readonly ) <EOL> @ util . positional ( <NUM_LIT:2> ) <EOL> def get_credential_storage_custom_string_key ( filename , key_string , <EOL> warn_on_readonly = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> key_dict = { '<STR_LIT:key>' : key_string } <EOL> return get_credential_storage_custom_key ( <EOL> filename , key_dict , warn_on_readonly = warn_on_readonly ) <EOL> @ util . positional ( <NUM_LIT:2> ) <EOL> def get_credential_storage_custom_key ( filename , key_dict , <EOL> warn_on_readonly = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> multistore = _get_multistore ( filename , warn_on_readonly = warn_on_readonly ) <EOL> key = _dict_to_tuple_key ( key_dict ) <EOL> return multistore . _get_storage ( key ) <EOL> @ util . positional ( <NUM_LIT:1> ) <EOL> def get_all_credential_keys ( filename , warn_on_readonly = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> multistore = _get_multistore ( filename , warn_on_readonly = warn_on_readonly ) <EOL> multistore . _lock ( ) <EOL> try : <EOL> return multistore . _get_all_credential_keys ( ) <EOL> finally : <EOL> multistore . _unlock ( ) <EOL> @ util . positional ( <NUM_LIT:1> ) <EOL> def _get_multistore ( filename , warn_on_readonly = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> filename = os . path . expanduser ( filename ) <EOL> _multistores_lock . acquire ( ) <EOL> try : <EOL> multistore = _multistores . setdefault ( <EOL> filename , _MultiStore ( filename , warn_on_readonly = warn_on_readonly ) ) <EOL> finally : <EOL> _multistores_lock . release ( ) <EOL> return multistore <EOL> class _MultiStore ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ util . positional ( <NUM_LIT:2> ) <EOL> def __init__ ( self , filename , warn_on_readonly = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _file = LockedFile ( filename , '<STR_LIT>' , '<STR_LIT:r>' ) <EOL> self . _thread_lock = threading . Lock ( ) <EOL> self . _read_only = False <EOL> self . _warn_on_readonly = warn_on_readonly <EOL> self . _create_file_if_needed ( ) <EOL> self . _data = None <EOL> class _Storage ( BaseStorage ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , multistore , key ) : <EOL> self . _multistore = multistore <EOL> self . _key = key <EOL> def acquire_lock ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _multistore . _lock ( ) <EOL> def release_lock ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _multistore . _unlock ( ) <EOL> def locked_get ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> credential = self . _multistore . _get_credential ( self . _key ) <EOL> if credential : <EOL> credential . set_store ( self ) <EOL> return credential <EOL> def locked_put ( self , credentials ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _multistore . _update_credential ( self . _key , credentials ) <EOL> def locked_delete ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _multistore . _delete_credential ( self . _key ) <EOL> def _create_file_if_needed ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not os . path . exists ( self . _file . filename ( ) ) : <EOL> old_umask = os . umask ( <NUM_LIT> ) <EOL> try : <EOL> open ( self . _file . filename ( ) , '<STR_LIT>' ) . close ( ) <EOL> finally : <EOL> os . umask ( old_umask ) <EOL> def _lock ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _thread_lock . acquire ( ) <EOL> try : <EOL> self . _file . open_and_lock ( ) <EOL> except IOError as e : <EOL> if e . errno == errno . ENOSYS : <EOL> logger . warn ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> elif e . errno == errno . ENOLCK : <EOL> logger . warn ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> elif e . errno == errno . EDEADLK : <EOL> logger . warn ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> elif e . errno == errno . EACCES : <EOL> logger . warn ( '<STR_LIT>' ) <EOL> else : <EOL> raise <EOL> if not self . _file . is_locked ( ) : <EOL> self . _read_only = True <EOL> if self . _warn_on_readonly : <EOL> logger . warn ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' , self . _file . filename ( ) ) <EOL> if os . path . getsize ( self . _file . filename ( ) ) == <NUM_LIT:0> : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . _data = { } <EOL> self . _write ( ) <EOL> elif not self . _read_only or self . _data is None : <EOL> self . _refresh_data_cache ( ) <EOL> def _unlock ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _file . unlock_and_close ( ) <EOL> self . _thread_lock . release ( ) <EOL> def _locked_json_read ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert self . _thread_lock . locked ( ) <EOL> self . _file . file_handle ( ) . seek ( <NUM_LIT:0> ) <EOL> return json . load ( self . _file . file_handle ( ) ) <EOL> def _locked_json_write ( self , data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert self . _thread_lock . locked ( ) <EOL> if self . _read_only : <EOL> return <EOL> self . _file . file_handle ( ) . seek ( <NUM_LIT:0> ) <EOL> json . dump ( data , self . _file . file_handle ( ) , <EOL> sort_keys = True , indent = <NUM_LIT:2> , separators = ( '<STR_LIT:U+002C>' , '<STR_LIT>' ) ) <EOL> self . _file . file_handle ( ) . truncate ( ) <EOL> def _refresh_data_cache ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _data = { } <EOL> try : <EOL> raw_data = self . _locked_json_read ( ) <EOL> except Exception : <EOL> logger . warn ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> return <EOL> version = <NUM_LIT:0> <EOL> try : <EOL> version = raw_data [ '<STR_LIT>' ] <EOL> except Exception : <EOL> logger . warn ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> if version > <NUM_LIT:1> : <EOL> raise NewerCredentialStoreError ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' % version ) <EOL> credentials = [ ] <EOL> try : <EOL> credentials = raw_data [ '<STR_LIT:data>' ] <EOL> except ( TypeError , KeyError ) : <EOL> pass <EOL> for cred_entry in credentials : <EOL> try : <EOL> key , credential = self . _decode_credential_from_json ( cred_entry ) <EOL> self . _data [ key ] = credential <EOL> except : <EOL> logger . info ( '<STR_LIT>' , <EOL> exc_info = True ) <EOL> def _decode_credential_from_json ( self , cred_entry ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raw_key = cred_entry [ '<STR_LIT:key>' ] <EOL> key = _dict_to_tuple_key ( raw_key ) <EOL> credential = None <EOL> credential = Credentials . new_from_json ( <EOL> json . dumps ( cred_entry [ '<STR_LIT>' ] ) ) <EOL> return ( key , credential ) <EOL> def _write ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raw_data = { '<STR_LIT>' : <NUM_LIT:1> } <EOL> raw_creds = [ ] <EOL> raw_data [ '<STR_LIT:data>' ] = raw_creds <EOL> for ( cred_key , cred ) in self . _data . items ( ) : <EOL> raw_key = dict ( cred_key ) <EOL> raw_cred = json . loads ( cred . to_json ( ) ) <EOL> raw_creds . append ( { '<STR_LIT:key>' : raw_key , '<STR_LIT>' : raw_cred } ) <EOL> self . _locked_json_write ( raw_data ) <EOL> def _get_all_credential_keys ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return [ dict ( key ) for key in self . _data . keys ( ) ] <EOL> def _get_credential ( self , key ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _data . get ( key , None ) <EOL> def _update_credential ( self , key , cred ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _data [ key ] = cred <EOL> self . _write ( ) <EOL> def _delete_credential ( self , key ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "try :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL>", "answer": "class Migration ( migrations . Migration ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> template_write_local_unclear_ref0 = \"\"\"<STR_LIT>\"\"\" <EOL> template_write_local_unclear_ref1 = \"\"\"<STR_LIT>\"\"\" <EOL> template_write_local_empty_ref0 = \"\"\"<STR_LIT>\"\"\" <EOL> template_write_local_empty_ref1 = \"\"\"<STR_LIT>\"\"\" <EOL> template_write_local_clear_ref0 = \"\"\"<STR_LIT>\"\"\" <EOL> template_write_local_inplace = \"\"\"<STR_LIT>\"\"\" <EOL> template_write_shared_inplace = \"\"\"<STR_LIT>\"\"\" <EOL> template_write_local_clear_ref1 = \"\"\"<STR_LIT>\"\"\" <EOL> template_write_shared_unclear_ref0 = \"\"\"<STR_LIT>\"\"\" <EOL> template_write_shared_unclear_ref1 = \"\"\"<STR_LIT>\"\"\" <EOL> template_write_shared_clear_ref0 = \"\"\"<STR_LIT>\"\"\" <EOL> template_write_shared_clear_ref1 = \"\"\"<STR_LIT>\"\"\" <EOL> template_read_local = \"\"\"<STR_LIT>\"\"\" <EOL> template_del_local_tolerant = \"\"\"<STR_LIT>\"\"\" <EOL> template_del_shared_tolerant = \"\"\"<STR_LIT>\"\"\" <EOL> template_del_local_intolerant = \"\"\"<STR_LIT>\"\"\" <EOL> template_del_shared_intolerant = \"\"\"<STR_LIT>\"\"\" <EOL> template_del_local_known = \"\"\"<STR_LIT>\"\"\" <EOL> template_del_shared_known = \"\"\"<STR_LIT>\"\"\" <EOL> template_release_unclear = \"\"\"<STR_LIT>\"\"\" <EOL> template_release_clear = \"\"\"<STR_LIT>\"\"\" <EOL> template_read_shared_unclear = \"\"\"<STR_LIT>\"\"\" <EOL> template_read_shared_known = \"\"\"<STR_LIT>\"\"\" <EOL> template_read_mvar_unclear = \"\"\"<STR_LIT>\"\"\" <EOL> template_read_maybe_local_unclear = \"\"\"<STR_LIT>\"\"\" <EOL> template_del_global_unclear = \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "template_update_locals_dict_value = \"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from djangocms_blog . models import thumbnail_model <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . alter_column ( u'<STR_LIT>' , '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( blank = True , default = '<STR_LIT>' ) ) <EOL> def backwards ( self , orm ) : <EOL> db . alter_column ( u'<STR_LIT>' , '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( ) ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:related_name>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:password>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:related_name>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:username>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:0>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:path>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:null>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> thumbnail_model : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:width>' : ( '<STR_LIT>' , [ ] , { } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:5>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:to>' : \"<STR_LIT>\" } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL>", "answer": "'<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" } ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> import inspect <EOL> try : <EOL> from email . utils import parsedate_tz <EOL> except ImportError : <EOL> from email . Utils import parsedate_tz <EOL> from urllib2 import parse_http_list as _parse_list_header <EOL> from datetime import datetime , timedelta <EOL> try : <EOL> from hashlib import md5 <EOL> except ImportError : <EOL> from md5 import new as md5 <EOL> from werkzeug . _internal import HTTP_STATUS_CODES <EOL> _accept_re = re . compile ( r'<STR_LIT>' ) <EOL> _token_chars = frozenset ( \"<STR_LIT>\" <EOL> '<STR_LIT>' ) <EOL> _etag_re = re . compile ( r'<STR_LIT>' ) <EOL> _unsafe_header_chars = set ( '<STR_LIT>' ) <EOL> _quoted_string_re = r'<STR_LIT>' <EOL> _option_header_piece_re = re . compile ( r'<STR_LIT>' % <EOL> ( _quoted_string_re , _quoted_string_re ) ) <EOL> _entity_headers = frozenset ( [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' <EOL> ] ) <EOL> _hop_by_pop_headers = frozenset ( [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] ) <EOL> def quote_header_value ( value , extra_chars = '<STR_LIT>' , allow_token = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> value = str ( value ) <EOL> if allow_token : <EOL> token_chars = _token_chars | set ( extra_chars ) <EOL> if set ( value ) . issubset ( token_chars ) : <EOL> return value <EOL> return '<STR_LIT>' % value . replace ( '<STR_LIT:\\\\>' , '<STR_LIT>' ) . replace ( '<STR_LIT:\">' , '<STR_LIT>' ) <EOL> def unquote_header_value ( value , is_filename = False ) : <EOL> r\"\"\"<STR_LIT>\"\"\" <EOL> if value and value [ <NUM_LIT:0> ] == value [ - <NUM_LIT:1> ] == '<STR_LIT:\">' : <EOL> value = value [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> if not is_filename or value [ : <NUM_LIT:2> ] != '<STR_LIT>' : <EOL> return value . replace ( '<STR_LIT>' , '<STR_LIT:\\\\>' ) . replace ( '<STR_LIT>' , '<STR_LIT:\">' ) <EOL> return value <EOL> def dump_options_header ( header , options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> segments = [ ] <EOL> if header is not None : <EOL> segments . append ( header ) <EOL> for key , value in options . iteritems ( ) : <EOL> if value is None : <EOL> segments . append ( key ) <EOL> else : <EOL> segments . append ( '<STR_LIT>' % ( key , quote_header_value ( value ) ) ) <EOL> return '<STR_LIT>' . join ( segments ) <EOL> def dump_header ( iterable , allow_token = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( iterable , dict ) : <EOL> items = [ ] <EOL> for key , value in iterable . iteritems ( ) : <EOL> if value is None : <EOL> items . append ( key ) <EOL> else : <EOL> items . append ( '<STR_LIT>' % ( <EOL> key , <EOL> quote_header_value ( value , allow_token = allow_token ) <EOL> ) ) <EOL> else : <EOL> items = [ quote_header_value ( x , allow_token = allow_token ) <EOL> for x in iterable ] <EOL> return '<STR_LIT:U+002CU+0020>' . join ( items ) <EOL> def parse_list_header ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = [ ] <EOL> for item in _parse_list_header ( value ) : <EOL> if item [ : <NUM_LIT:1> ] == item [ - <NUM_LIT:1> : ] == '<STR_LIT:\">' : <EOL> item = unquote_header_value ( item [ <NUM_LIT:1> : - <NUM_LIT:1> ] ) <EOL> result . append ( item ) <EOL> return result <EOL> def parse_dict_header ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> result = { } <EOL> for item in _parse_list_header ( value ) : <EOL> if '<STR_LIT:=>' not in item : <EOL> result [ item ] = None <EOL> continue <EOL> name , value = item . split ( '<STR_LIT:=>' , <NUM_LIT:1> ) <EOL> if value [ : <NUM_LIT:1> ] == value [ - <NUM_LIT:1> : ] == '<STR_LIT:\">' : <EOL> value = unquote_header_value ( value [ <NUM_LIT:1> : - <NUM_LIT:1> ] ) <EOL> result [ name ] = value <EOL> return result <EOL> def parse_options_header ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _tokenize ( string ) : <EOL> for match in _option_header_piece_re . finditer ( string ) : <EOL> key , value = match . groups ( ) <EOL> key = unquote_header_value ( key ) <EOL> if value is not None : <EOL> value = unquote_header_value ( value , key == '<STR_LIT:filename>' ) <EOL> yield key , value <EOL> if not value : <EOL> return '<STR_LIT>' , { } <EOL> parts = _tokenize ( '<STR_LIT:;>' + value ) <EOL> name = parts . next ( ) [ <NUM_LIT:0> ] <EOL> extra = dict ( parts ) <EOL> return name , extra <EOL> def parse_accept_header ( value , cls = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if cls is None : <EOL> cls = Accept <EOL> if not value : <EOL> return cls ( None ) <EOL> result = [ ] <EOL> for match in _accept_re . finditer ( value ) : <EOL> quality = match . group ( <NUM_LIT:2> ) <EOL> if not quality : <EOL> quality = <NUM_LIT:1> <EOL> else : <EOL> quality = max ( min ( float ( quality ) , <NUM_LIT:1> ) , <NUM_LIT:0> ) <EOL> result . append ( ( match . group ( <NUM_LIT:1> ) , quality ) ) <EOL> return cls ( result ) <EOL> def parse_cache_control_header ( value , on_update = None , cls = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if cls is None : <EOL> cls = RequestCacheControl <EOL> if not value : <EOL> return cls ( None , on_update ) <EOL> return cls ( parse_dict_header ( value ) , on_update ) <EOL> def parse_set_header ( value , on_update = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not value : <EOL> return HeaderSet ( None , on_update ) <EOL> return HeaderSet ( parse_list_header ( value ) , on_update ) <EOL> def parse_authorization_header ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not value : <EOL> return <EOL> try : <EOL> auth_type , auth_info = value . split ( None , <NUM_LIT:1> ) <EOL> auth_type = auth_type . lower ( ) <EOL> except ValueError : <EOL> return <EOL>", "answer": "if auth_type == '<STR_LIT>' :"}, {"prompt": "<s> try : <EOL> from django . conf . urls import patterns , url <EOL> except ImportError : <EOL>", "answer": "from django . conf . urls . defaults import patterns , url"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> from fabric . api import * <EOL> from fabric . contrib . files import * <EOL> from cloudbio . custom import shared <EOL> from shared import ( _if_not_installed , _get_install , _configure_make , _java_install , <EOL> _make_tmp_dir ) <EOL> def install_anaconda ( env ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> version = \"<STR_LIT>\" <EOL> outdir = os . path . join ( env . system_install , \"<STR_LIT>\" ) <EOL> if env . distribution in [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> platform = \"<STR_LIT>\" <EOL> elif env . distribution in [ \"<STR_LIT>\" ] : <EOL> platform = \"<STR_LIT>\" <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" % env . distribution ) <EOL> url = \"<STR_LIT>\" \"<STR_LIT>\" % ( version , platform ) <EOL> if not env . safe_exists ( outdir ) : <EOL> with _make_tmp_dir ( ) as work_dir : <EOL> with cd ( work_dir ) : <EOL> installer = shared . _remote_fetch ( env , url ) <EOL> env . safe_sed ( os . path . basename ( url ) , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> env . safe_sudo ( \"<STR_LIT>\" % ( outdir , installer ) ) <EOL> env . safe_sudo ( \"<STR_LIT>\" % ( env . user , outdir ) ) <EOL> comment_line = \"<STR_LIT>\" % version <EOL> if not env . safe_contains ( env . shell_config , comment_line ) : <EOL> env . safe_append ( env . shell_config , comment_line ) <EOL> env . safe_append ( env . shell_config , \"<STR_LIT>\" % outdir ) <EOL> env . safe_run ( \"<STR_LIT>\" % outdir ) <EOL> env . safe_run ( \"<STR_LIT>\" % outdir ) <EOL> @ _if_not_installed ( \"<STR_LIT>\" ) <EOL> def install_emboss ( env ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> default_version = \"<STR_LIT>\" <EOL> version = env . get ( \"<STR_LIT>\" , default_version ) <EOL> url = \"<STR_LIT>\" % version <EOL> _get_install ( url , env , _configure_make ) <EOL> def install_pgdspider ( env ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if os . path . exists ( os . path . join ( shared . _get_bin_dir ( env ) , \"<STR_LIT>\" ) ) : <EOL> return <EOL> version = \"<STR_LIT>\" <EOL> url = \"<STR_LIT>\" . format ( <EOL> v = version ) <EOL> def _install_fn ( env , install_dir ) : <EOL> env . safe_sudo ( \"<STR_LIT>\" % install_dir ) <EOL> bin_dir = shared . _get_bin_dir ( env ) <EOL> exe_file = \"<STR_LIT>\" <EOL> jar = \"<STR_LIT>\" <EOL> env . safe_sed ( exe_file , jar , \"<STR_LIT>\" . format ( dir = install_dir , jar = jar ) ) <EOL> env . safe_run ( \"<STR_LIT>\" . format ( exe_file ) ) <EOL>", "answer": "env . safe_sudo ( \"<STR_LIT>\" . format ( exe = exe_file , bin = bin_dir ) )"}, {"prompt": "<s> from mock import patch , Mock <EOL> from pytest import raises <EOL> from pyramid . testing import DummyRequest <EOL> from webob . cookies import SignedSerializer <EOL>", "answer": "def configure ( config ) :"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL> import os <EOL> import sys <EOL> from pyverilog . dataflow . dataflow_analyzer import VerilogDataflowAnalyzer <EOL> from pyverilog . dataflow . optimizer import VerilogDataflowOptimizer <EOL> from pyverilog . controlflow . controlflow_analyzer import VerilogControlflowAnalyzer <EOL> codedir = os . path . dirname ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) ) + '<STR_LIT>' <EOL> expected = \"\"\"<STR_LIT>\"\"\" <EOL> def test ( ) : <EOL> filelist = [ codedir + '<STR_LIT>' ] <EOL> topmodule = '<STR_LIT>' <EOL> noreorder = False <EOL> nobind = False <EOL> include = None <EOL> define = None <EOL> analyzer = VerilogDataflowAnalyzer ( filelist , topmodule , <EOL> noreorder = noreorder , <EOL> nobind = nobind , <EOL> preprocess_include = include , <EOL> preprocess_define = define ) <EOL> analyzer . generate ( ) <EOL> directives = analyzer . get_directives ( ) <EOL> instances = analyzer . getInstances ( ) <EOL> terms = analyzer . getTerms ( ) <EOL> binddict = analyzer . getBinddict ( ) <EOL> optimizer = VerilogDataflowOptimizer ( terms , binddict ) <EOL> optimizer . resolveConstant ( ) <EOL> c_analyzer = VerilogControlflowAnalyzer ( topmodule , terms , <EOL> binddict , <EOL> resolved_terms = optimizer . getResolvedTerms ( ) , <EOL> resolved_binddict = optimizer . getResolvedBinddict ( ) , <EOL> constlist = optimizer . getConstlist ( ) <EOL> ) <EOL>", "answer": "output = [ ]"}, {"prompt": "<s> import argparse <EOL> import sys <EOL> import time <EOL> from . btc import encoder , decoder , error , list_to_dict , dict_to_list , client <EOL> _description = '<STR_LIT>' <EOL> def main ( ) : <EOL>", "answer": "parser = argparse . ArgumentParser ( )"}, {"prompt": "<s> from __future__ import division <EOL> from PyQt4 import QtCore , QtGui <EOL> from vistrails . core . utils import any , expression <EOL> from vistrails . core import system <EOL> from constant_configuration import StandardConstantWidget , ColorWidget <EOL> class QueryWidgetMixin ( object ) : <EOL> def __init__ ( self , contents = None , query_method = None ) : <EOL> self . _last_contents = contents <EOL> self . _last_query_method = query_method <EOL> def updateMethod ( self ) : <EOL> self . update_parent ( ) <EOL> def update_parent ( self ) : <EOL> new_contents = self . contents ( ) <EOL> new_query_method = self . query_method ( ) <EOL> if ( new_contents != self . _last_contents or <EOL> new_query_method != self . _last_query_method ) : <EOL> if self . parent ( ) and hasattr ( self . parent ( ) , '<STR_LIT>' ) : <EOL> self . parent ( ) . updateMethod ( ) <EOL> self . _last_contents = new_contents <EOL> self . _last_query_method = new_query_method <EOL> self . emit ( QtCore . SIGNAL ( '<STR_LIT>' ) , ( self , new_contents ) ) <EOL> class BaseQueryWidget ( QtGui . QWidget , QueryWidgetMixin ) : <EOL> def __init__ ( self , contents_klass , query_methods , param , parent = None ) : <EOL> QtGui . QWidget . __init__ ( self , parent ) <EOL> QueryWidgetMixin . __init__ ( self , param . strValue , param . queryMethod ) <EOL> contents = param . strValue <EOL> queryMethod = param . queryMethod <EOL> layout = QtGui . QHBoxLayout ( ) <EOL> self . op_button = QtGui . QToolButton ( ) <EOL> self . op_button . setPopupMode ( QtGui . QToolButton . InstantPopup ) <EOL> self . op_button . setArrowType ( QtCore . Qt . NoArrow ) <EOL> action_group = QtGui . QActionGroup ( self . op_button ) <EOL> actions = [ ] <EOL> checked_exists = False <EOL> for method in query_methods : <EOL> action = QtGui . QAction ( method , self ) <EOL> action . setCheckable ( True ) <EOL> action_group . addAction ( action ) <EOL> if method == queryMethod : <EOL> action . setChecked ( True ) <EOL> checked_exists = True <EOL> actions . append ( action ) <EOL> if not checked_exists : <EOL> actions [ <NUM_LIT:0> ] . setChecked ( True ) <EOL> self . _last_query_method = str ( actions [ <NUM_LIT:0> ] . text ( ) ) <EOL> menu = QtGui . QMenu ( self . op_button ) <EOL> menu . addActions ( actions ) <EOL> self . op_button . setMenu ( menu ) <EOL> self . op_button . setText ( action_group . checkedAction ( ) . text ( ) ) <EOL> self . contents_widget = contents_klass ( param ) <EOL> self . contents_widget . setContents ( contents ) <EOL> layout . setMargin ( <NUM_LIT:0> ) <EOL> layout . setSpacing ( <NUM_LIT:0> ) <EOL> layout . addWidget ( self . op_button ) <EOL> layout . addWidget ( self . contents_widget ) <EOL> self . setLayout ( layout ) <EOL> self . connect ( self . op_button , QtCore . SIGNAL ( '<STR_LIT>' ) , <EOL> self . update_action ) <EOL> def contents ( self ) : <EOL> return self . contents_widget . contents ( ) <EOL> def setContents ( self , strValue , silent = True ) : <EOL> self . contents_widget . setContents ( strValue ) <EOL> if not silent : <EOL>", "answer": "self . update_parent ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import py <EOL> from pypy . rpython . lltypesystem import lltype <EOL> from pypy . rpython . ootypesystem import ootype <EOL> from pypy . rpython . lltypesystem . lloperation import llop <EOL> from pypy . rlib . rarithmetic import ovfcheck , r_uint , intmask <EOL> from pypy . jit . metainterp . history import BoxInt , ConstInt , check_descr <EOL> from pypy . jit . metainterp . history import INT , REF , ConstFloat <EOL> from pypy . jit . metainterp import resoperation <EOL> from pypy . jit . metainterp . resoperation import rop <EOL> def do_int_add ( cpu , box1 , box2 ) : <EOL> return ConstInt ( intmask ( box1 . getint ( ) + box2 . getint ( ) ) ) <EOL> def do_int_sub ( cpu , box1 , box2 ) : <EOL> return ConstInt ( intmask ( box1 . getint ( ) - box2 . getint ( ) ) ) <EOL> def do_int_mul ( cpu , box1 , box2 ) : <EOL> return ConstInt ( intmask ( box1 . getint ( ) * box2 . getint ( ) ) ) <EOL> def do_int_floordiv ( cpu , box1 , box2 ) : <EOL> z = llop . int_floordiv ( lltype . Signed , box1 . getint ( ) , box2 . getint ( ) ) <EOL> return ConstInt ( z ) <EOL> def do_int_mod ( cpu , box1 , box2 ) : <EOL> z = llop . int_mod ( lltype . Signed , box1 . getint ( ) , box2 . getint ( ) ) <EOL> return ConstInt ( z ) <EOL> def do_int_and ( cpu , box1 , box2 ) : <EOL> return ConstInt ( box1 . getint ( ) & box2 . getint ( ) ) <EOL> def do_int_or ( cpu , box1 , box2 ) : <EOL> return ConstInt ( box1 . getint ( ) | box2 . getint ( ) ) <EOL> def do_int_xor ( cpu , box1 , box2 ) : <EOL> return ConstInt ( box1 . getint ( ) ^ box2 . getint ( ) ) <EOL> def do_int_rshift ( cpu , box1 , box2 ) : <EOL> return ConstInt ( box1 . getint ( ) >> box2 . getint ( ) ) <EOL> def do_int_lshift ( cpu , box1 , box2 ) : <EOL> return ConstInt ( intmask ( box1 . getint ( ) << box2 . getint ( ) ) ) <EOL> def do_uint_rshift ( cpu , box1 , box2 ) : <EOL> v = r_uint ( box1 . getint ( ) ) >> r_uint ( box2 . getint ( ) ) <EOL> return ConstInt ( intmask ( v ) ) <EOL> def do_int_lt ( cpu , box1 , box2 ) : <EOL> return ConstInt ( box1 . getint ( ) < box2 . getint ( ) ) <EOL> def do_int_le ( cpu , box1 , box2 ) : <EOL> return ConstInt ( box1 . getint ( ) <= box2 . getint ( ) ) <EOL> def do_int_eq ( cpu , box1 , box2 ) : <EOL> return ConstInt ( box1 . getint ( ) == box2 . getint ( ) ) <EOL> def do_int_ne ( cpu , box1 , box2 ) : <EOL> return ConstInt ( box1 . getint ( ) != box2 . getint ( ) ) <EOL> def do_int_gt ( cpu , box1 , box2 ) : <EOL> return ConstInt ( box1 . getint ( ) > box2 . getint ( ) ) <EOL> def do_int_ge ( cpu , box1 , box2 ) : <EOL> return ConstInt ( box1 . getint ( ) >= box2 . getint ( ) ) <EOL> def do_uint_lt ( cpu , box1 , box2 ) : <EOL> return ConstInt ( r_uint ( box1 . getint ( ) ) < r_uint ( box2 . getint ( ) ) ) <EOL> def do_uint_le ( cpu , box1 , box2 ) : <EOL> return ConstInt ( r_uint ( box1 . getint ( ) ) <= r_uint ( box2 . getint ( ) ) ) <EOL> def do_uint_gt ( cpu , box1 , box2 ) : <EOL> return ConstInt ( r_uint ( box1 . getint ( ) ) > r_uint ( box2 . getint ( ) ) ) <EOL> def do_uint_ge ( cpu , box1 , box2 ) : <EOL> return ConstInt ( r_uint ( box1 . getint ( ) ) >= r_uint ( box2 . getint ( ) ) ) <EOL> def do_int_is_true ( cpu , box1 ) : <EOL> return ConstInt ( bool ( box1 . getint ( ) ) ) <EOL> def do_int_neg ( cpu , box1 ) : <EOL> return ConstInt ( intmask ( - box1 . getint ( ) ) ) <EOL> def do_int_invert ( cpu , box1 ) : <EOL> return ConstInt ( ~ box1 . getint ( ) ) <EOL> def do_bool_not ( cpu , box1 ) : <EOL> return ConstInt ( not box1 . getint ( ) ) <EOL> def do_same_as ( cpu , box1 ) : <EOL> return box1 <EOL> def do_oononnull ( cpu , box1 ) : <EOL> tp = box1 . type <EOL> if tp == INT : <EOL> x = bool ( box1 . getint ( ) ) <EOL> elif tp == REF : <EOL> x = bool ( box1 . getref_base ( ) ) <EOL> else : <EOL> assert False <EOL> return ConstInt ( x ) <EOL> def do_ooisnull ( cpu , box1 ) : <EOL> tp = box1 . type <EOL> if tp == INT : <EOL> x = bool ( box1 . getint ( ) ) <EOL> elif tp == REF : <EOL> x = bool ( box1 . getref_base ( ) ) <EOL> else : <EOL> assert False <EOL> return ConstInt ( not x ) <EOL> def do_oois ( cpu , box1 , box2 ) : <EOL> tp = box1 . type <EOL> assert tp == box2 . type <EOL> if tp == INT : <EOL> x = box1 . getint ( ) == box2 . getint ( ) <EOL> elif tp == REF : <EOL> x = box1 . getref_base ( ) == box2 . getref_base ( ) <EOL> else : <EOL> assert False <EOL> return ConstInt ( x ) <EOL> def do_ooisnot ( cpu , box1 , box2 ) : <EOL> tp = box1 . type <EOL> assert tp == box2 . type <EOL> if tp == INT : <EOL> x = box1 . getint ( ) != box2 . getint ( ) <EOL> elif tp == REF : <EOL> x = box1 . getref_base ( ) != box2 . getref_base ( ) <EOL> else : <EOL> assert False <EOL> return ConstInt ( x ) <EOL> def do_subclassof ( cpu , box1 , box2 ) : <EOL> return ConstInt ( cpu . ts . subclassOf ( cpu , box1 , box2 ) ) <EOL> def do_int_add_ovf ( cpu , box1 , box2 ) : <EOL> x = box1 . getint ( ) <EOL> y = box2 . getint ( ) <EOL> try : <EOL> z = ovfcheck ( x + y ) <EOL> except OverflowError : <EOL> ovf = True <EOL> z = <NUM_LIT:0> <EOL> else : <EOL> ovf = False <EOL> cpu . _overflow_flag = ovf <EOL> return BoxInt ( z ) <EOL> def do_int_sub_ovf ( cpu , box1 , box2 ) : <EOL> x = box1 . getint ( ) <EOL> y = box2 . getint ( ) <EOL> try : <EOL> z = ovfcheck ( x - y ) <EOL> except OverflowError : <EOL> ovf = True <EOL> z = <NUM_LIT:0> <EOL> else : <EOL> ovf = False <EOL> cpu . _overflow_flag = ovf <EOL> return BoxInt ( z ) <EOL> def do_int_mul_ovf ( cpu , box1 , box2 ) : <EOL> x = box1 . getint ( ) <EOL> y = box2 . getint ( ) <EOL> try : <EOL> z = ovfcheck ( x * y ) <EOL> except OverflowError : <EOL> ovf = True <EOL> z = <NUM_LIT:0> <EOL> else : <EOL> ovf = False <EOL> cpu . _overflow_flag = ovf <EOL> return BoxInt ( z ) <EOL> def do_float_neg ( cpu , box1 ) : <EOL> return ConstFloat ( - box1 . getfloat ( ) ) <EOL>", "answer": "def do_float_abs ( cpu , box1 ) :"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import pyvision as pv <EOL> import optparse <EOL> import os . path <EOL> IMAGE_EXTENSIONS = set ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def parseBasename ( path ) : <EOL> '''<STR_LIT>''' <EOL> if path == None : <EOL> return None <EOL> _ , filename = os . path . split ( path ) <EOL> basename = filename . split ( '<STR_LIT:.>' ) [ <NUM_LIT:0> ] <EOL> return basename <EOL> def locateFiles ( sigset , imdir ) : <EOL> '''<STR_LIT>''' <EOL> image_map = { } <EOL> file_map = { } <EOL> rec_map = { } <EOL> for each in sigset : <EOL> rec_id = each [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] [ '<STR_LIT:name>' ] <EOL> basename = parseBasename ( each [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] ) <EOL> image_map [ rec_id ] = None <EOL> file_map [ basename ] = rec_id <EOL> rec_map [ rec_id ] = basename <EOL> n_images = <NUM_LIT:0> <EOL> for rootdir , _ , files in os . walk ( imdir ) : <EOL> for filename in files : <EOL> basename , ext = os . path . splitext ( filename ) <EOL> if ext . upper ( ) not in IMAGE_EXTENSIONS : <EOL> continue <EOL> print filename <EOL> if file_map . has_key ( basename ) and image_map [ file_map [ basename ] ] == None : <EOL> image_map [ file_map [ basename ] ] = os . path . join ( rootdir , filename ) <EOL> n_images += <NUM_LIT:1> <EOL> elif file_map . has_key ( basename ) and image_map [ file_map [ basename ] ] != None : <EOL> raise ValueError ( \"<STR_LIT>\" % ( file_map [ basename ] , image_map [ file_map [ basename ] ] , os . path . join ( rootdir , filename ) ) ) <EOL> if rec_map . has_key ( basename ) and rec_map [ file_map [ basename ] ] == None : <EOL> image_map [ file_map [ basename ] ] = os . path . join ( rootdir , filename ) <EOL> n_images += <NUM_LIT:1> <EOL> elif rec_map . has_key ( basename ) and image_map [ file_map [ basename ] ] != None : <EOL> raise ValueError ( \"<STR_LIT>\" % ( file_map [ basename ] , image_map [ file_map [ basename ] ] , os . path . join ( rootdir , filename ) ) ) <EOL> if True : print \"<STR_LIT>\" % ( n_images , len ( image_map ) ) <EOL> missing = [ ] <EOL> found = [ ] <EOL>", "answer": "for item in sigset :"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import sys <EOL> import math <EOL> import CGAT . Experiment as E <EOL> import CGAT . Genomics as Genomics <EOL> import CGAT . FastaIterator as FastaIterator <EOL> def FilterAlignedPairForPositions ( seq1 , seq2 , method ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> l1 = len ( seq1 ) <EOL> l2 = len ( seq2 ) <EOL> if method == \"<STR_LIT:all>\" : <EOL> return seq1 , seq2 <EOL> elif method == \"<STR_LIT>\" : <EOL> return ( \"<STR_LIT>\" . join ( [ seq1 [ x ] for x in range ( <NUM_LIT:0> , l1 , <NUM_LIT:3> ) ] ) , <EOL> \"<STR_LIT>\" . join ( [ seq2 [ x ] for x in range ( <NUM_LIT:0> , l2 , <NUM_LIT:3> ) ] ) ) <EOL> elif method == \"<STR_LIT>\" : <EOL> return ( \"<STR_LIT>\" . join ( [ seq1 [ x ] for x in range ( <NUM_LIT:1> , l1 , <NUM_LIT:3> ) ] ) , <EOL> \"<STR_LIT>\" . join ( [ seq2 [ x ] for x in range ( <NUM_LIT:1> , l2 , <NUM_LIT:3> ) ] ) ) <EOL> elif method == \"<STR_LIT>\" : <EOL> return ( \"<STR_LIT>\" . join ( [ seq1 [ x ] for x in range ( <NUM_LIT:2> , l1 , <NUM_LIT:3> ) ] ) , <EOL> \"<STR_LIT>\" . join ( [ seq2 [ x ] for x in range ( <NUM_LIT:2> , l2 , <NUM_LIT:3> ) ] ) ) <EOL> elif method == \"<STR_LIT>\" : <EOL> s1 = [ ] <EOL> s2 = [ ] <EOL> for x in range ( <NUM_LIT:0> , l1 , <NUM_LIT:3> ) : <EOL> codon1 = seq1 [ x : x + <NUM_LIT:3> ] <EOL> codon2 = seq2 [ x : x + <NUM_LIT:3> ] <EOL> try : <EOL> aa1 , deg11 , deg12 , deg13 = Genomics . GetDegeneracy ( codon1 ) <EOL> aa2 , deg11 , deg22 , deg23 = Genomics . GetDegeneracy ( codon2 ) <EOL> except KeyError : <EOL> continue <EOL> if aa1 == aa2 and deg13 == <NUM_LIT:4> and deg23 == <NUM_LIT:4> : <EOL> s1 . append ( codon1 [ <NUM_LIT:2> ] ) <EOL> s2 . append ( codon2 [ <NUM_LIT:2> ] ) <EOL> return \"<STR_LIT>\" . join ( s1 ) , \"<STR_LIT>\" . join ( s2 ) <EOL> def CalculateDistanceJC69 ( info , do_gamma = False , alpha = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> p = float ( info . mNDifferent ) / info . mNAligned <EOL> if do_gamma : <EOL> distance = <NUM_LIT> * alpha * ( pow ( <NUM_LIT:1> - <NUM_LIT:4> * p / <NUM_LIT:3> , - <NUM_LIT:1> / alpha ) - <NUM_LIT:1> ) <EOL> variance = p * ( <NUM_LIT:1> - p ) / ( pow ( <NUM_LIT:1> - <NUM_LIT:4> * p / <NUM_LIT:3> , - <NUM_LIT:2> / ( alpha + <NUM_LIT:1> ) ) * L ) <EOL> else : <EOL> distance = - <NUM_LIT> * math . log ( <NUM_LIT:1.0> - <NUM_LIT> * p / <NUM_LIT> ) <EOL> variance = p * ( <NUM_LIT:1.0> - p ) / ( math . pow ( <NUM_LIT:1.0> - <NUM_LIT> * p / <NUM_LIT:3> , <NUM_LIT> ) * info . mNAligned ) <EOL> except : <EOL> raise ValueError <EOL> return distance , variance <EOL> def CalculateDistanceT92 ( info ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> gc = info . getGCContent ( ) <EOL> if gc == <NUM_LIT:0> or gc == <NUM_LIT:1> : <EOL> raise ValueError <EOL> wg = <NUM_LIT> * gc * ( <NUM_LIT:1.0> - gc ) <EOL> P = float ( info . mNTransitions ) / info . mNAligned <EOL> Q = float ( info . mNTransversions ) / info . mNAligned <EOL> a1 = <NUM_LIT:1.0> - P / wg - Q <EOL> if a1 <= <NUM_LIT:0> : <EOL> raise ValueError <EOL> a2 = <NUM_LIT:1.0> - <NUM_LIT> * Q <EOL> if a2 <= <NUM_LIT:0> : <EOL> raise ValueError <EOL> distance = - wg * math . log ( a1 ) - <NUM_LIT:0.5> * ( <NUM_LIT:1.0> - wg ) * math . log ( a2 ) <EOL> c1 = <NUM_LIT:1> / a1 <EOL>", "answer": "c2 = <NUM_LIT:1> / a2"}, {"prompt": "<s> PLUGINS = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL>", "answer": "PLUGIN_BLACKLIST = ["}, {"prompt": "<s> import importlib <EOL> import unittest <EOL> try : <EOL> import unittest . mock as mock <EOL> except ImportError : <EOL> import mock <EOL> from cloudbaseinit import exception <EOL> class TestWSMStorageManager ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . mock_wmi = mock . MagicMock ( ) <EOL> patcher = mock . patch . dict ( <EOL> \"<STR_LIT>\" , <EOL> { <EOL> \"<STR_LIT>\" : self . mock_wmi <EOL> } <EOL> ) <EOL> patcher . start ( ) <EOL> self . addCleanup ( patcher . stop ) <EOL> wsm_store = importlib . import_module ( <EOL> \"<STR_LIT>\" ) <EOL> self . wsm = wsm_store . WSMStorageManager ( ) <EOL> def test_init ( self ) : <EOL> self . mock_wmi . WMI . assert_called_once_with ( <EOL> moniker = '<STR_LIT>' ) <EOL> def _test_extend_volumes ( self , extend = True , fail = False , <EOL> size_ret = <NUM_LIT:0> , resize_ret = <NUM_LIT:0> ) : <EOL> volume_indexes = [ <NUM_LIT:1> , <NUM_LIT:3> ] <EOL> volumes = [ mock . Mock ( ) , mock . Mock ( ) , mock . Mock ( ) ] <EOL> partitions = [ mock . Mock ( ) ] <EOL> for volume in volumes : <EOL> volume . associators . return_value = partitions <EOL> for partition in partitions : <EOL> size_max = partition . Size = <NUM_LIT:100> <EOL> if extend : <EOL> size_max = partition . Size + <NUM_LIT:10> <EOL> partition . GetSupportedSize . return_value = [ <EOL> size_ret , <EOL> mock . Mock ( ) , <EOL> size_max , <EOL> mock . Mock ( ) ] <EOL> partition . Resize . return_value = [ <EOL> resize_ret , <EOL> mock . Mock ( ) ] <EOL> conn = self . mock_wmi . WMI . return_value <EOL> conn . MSFT_Volume . return_value = volumes <EOL> if fail : <EOL> if size_ret or extend : <EOL> with self . assertRaises ( exception . CloudbaseInitException ) : <EOL> self . wsm . extend_volumes ( volume_indexes = volume_indexes ) <EOL> return <EOL> self . wsm . extend_volumes ( volume_indexes = volume_indexes ) <EOL> conn . MSFT_Volume . assert_called_once_with ( ) <EOL> for idx in volume_indexes : <EOL> volumes [ idx - <NUM_LIT:1> ] . associators . assert_called_once_with ( <EOL> wmi_result_class = '<STR_LIT>' ) <EOL> volumes [ <NUM_LIT:1> ] . associators . assert_not_called ( ) <EOL> for partition in partitions : <EOL> calls = [ mock . call ( ) ] * len ( volume_indexes ) <EOL>", "answer": "partition . GetSupportedSize . assert_has_calls ( calls )"}, {"prompt": "<s> import json <EOL> from functionaltests . api import base <EOL> class TestSensorController ( base . TestCase ) : <EOL> def test_sensors_get_all ( self ) : <EOL> resp , body = self . client . get ( '<STR_LIT>' ) <EOL> data = json . loads ( body ) <EOL> self . assertEqual ( resp . status , <NUM_LIT:200> ) <EOL>", "answer": "self . assertEqual ( data , [ ] ) "}, {"prompt": "<s> import datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL>", "answer": "class Migration ( SchemaMigration ) :"}, {"prompt": "<s> import re <EOL> from bisect import bisect <EOL> try : <EOL> set <EOL> except NameError : <EOL> from sets import Set as set <EOL> from django . conf import settings <EOL> from django . db . models . related import RelatedObject <EOL> from django . db . models . fields . related import ManyToManyRel <EOL> from django . db . models . fields import AutoField , FieldDoesNotExist <EOL> from django . db . models . fields . proxy import OrderWrt <EOL> from django . db . models . loading import get_models , app_cache_ready <EOL> from django . utils . translation import activate , deactivate_all , get_language , string_concat <EOL> from django . utils . encoding import force_unicode , smart_str <EOL> from django . utils . datastructures import SortedDict <EOL> get_verbose_name = lambda class_name : re . sub ( '<STR_LIT>' , '<STR_LIT>' , class_name ) . lower ( ) . strip ( ) <EOL> DEFAULT_NAMES = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> class CompositePrimaryKey ( list ) : <EOL> def __eq__ ( self , field_name ) : <EOL> return field_name in self . names <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ , list . __repr__ ( self ) ) <EOL> def __str__ ( self ) : <EOL> return self . name <EOL> def __getattr__ ( self , key , value = None ) : <EOL> _reserved = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if key not in _reserved : <EOL> if len ( self ) == <NUM_LIT:1> : <EOL> return getattr ( self [ <NUM_LIT:0> ] , key , value ) <EOL> raise AttributeError , \"<STR_LIT>\" % ( key , self . __class__ . __name__ , ) <EOL> return list . __getattr__ ( self , key , value ) <EOL> def names ( self ) : <EOL> return [ f . name for f in self ] <EOL> names = property ( names ) <EOL> def attnames ( self ) : <EOL> return [ f . attname for f in self ] <EOL> attnames = property ( attnames ) <EOL> def append ( self , field ) : <EOL> field . primary_key = True <EOL> if field not in self : <EOL>", "answer": "list . append ( self , field )"}, {"prompt": "<s> from mock import patch <EOL> from oslo_serialization import jsonutils <EOL> from nailgun import consts <EOL> from nailgun . extensions . volume_manager . extension import VolumeManagerExtension <EOL> from nailgun . extensions . volume_manager import manager <EOL> from nailgun . test import base <EOL> from nailgun . utils import reverse <EOL> class TestVolumeManagerHelpers ( base . BaseIntegrationTest ) : <EOL> def setUp ( self ) : <EOL> super ( TestVolumeManagerHelpers , self ) . setUp ( ) <EOL> self . env . create ( <EOL> nodes_kwargs = [ <EOL> { '<STR_LIT>' : [ '<STR_LIT>' ] } , <EOL> ] <EOL> ) <EOL> self . node = self . env . nodes [ <NUM_LIT:0> ] <EOL> self . volumes = VolumeManagerExtension . get_node_volumes ( self . node ) <EOL> def test_get_volumes_by_name ( self ) : <EOL>", "answer": "result = manager . get_logical_volumes_by_name ("}, {"prompt": "<s> from hedwig . stats import scorefunctions <EOL> from hedwig . stats import adjustment <EOL> from hedwig . stats import significance <EOL>", "answer": "from hedwig . stats . validate import Validate"}, {"prompt": "<s> from bson . objectid import ObjectId <EOL> from time import * <EOL> import jsonpickle <EOL> import json <EOL> import sys <EOL> import requests <EOL> import getpass <EOL> import traceback <EOL> import uuid <EOL> import stat <EOL> import socket <EOL> import rest_client <EOL> from version import __version__ <EOL> from model import * <EOL> from bashhub_globals import * <EOL> import requests <EOL> from requests import ConnectionError <EOL> from requests import HTTPError <EOL> import ConfigParser <EOL> import collections <EOL> def query_yes_no ( question , default = \"<STR_LIT:yes>\" ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> valid = { \"<STR_LIT:yes>\" : True , \"<STR_LIT:y>\" : True , \"<STR_LIT>\" : True , \"<STR_LIT>\" : False , \"<STR_LIT:n>\" : False } <EOL> if default == None : <EOL> prompt = \"<STR_LIT>\" <EOL> elif default == \"<STR_LIT:yes>\" : <EOL> prompt = \"<STR_LIT>\" <EOL> elif default == \"<STR_LIT>\" : <EOL> prompt = \"<STR_LIT>\" <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" % default ) <EOL> while True : <EOL> sys . stdout . write ( question + prompt ) <EOL> choice = raw_input ( ) . lower ( ) <EOL> if default is not None and choice == '<STR_LIT>' : <EOL> return valid [ default ] <EOL> elif choice in valid : <EOL> return valid [ choice ] <EOL> else : <EOL> sys . stdout . write ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def get_new_user_information ( ) : <EOL> email = raw_input ( \"<STR_LIT>\" ) <EOL> username = raw_input ( \"<STR_LIT>\" ) <EOL> password = getpass . getpass ( \"<STR_LIT>\" ) <EOL> print ( \"<STR_LIT>\" + email + \"<STR_LIT>\" + username ) <EOL> all_good = query_yes_no ( \"<STR_LIT>\" ) <EOL> if all_good : <EOL> return RegisterUser ( email , username , password ) <EOL> else : <EOL> return get_new_user_information ( ) <EOL> def get_user_information_and_login ( username = None , password = None , attempts = <NUM_LIT:0> ) : <EOL> if attempts == <NUM_LIT:4> : <EOL> print ( \"<STR_LIT>\" ) <EOL> return None <EOL> if username == None and password == None : <EOL> print ( \"<STR_LIT>\" ) <EOL> username = raw_input ( \"<STR_LIT>\" ) <EOL> password = getpass . getpass ( \"<STR_LIT>\" ) <EOL> access_token = rest_client . login_user ( LoginForm ( username , password ) ) <EOL> if access_token : <EOL> result = ( username , password , access_token ) <EOL> else : <EOL> result = get_user_information_and_login ( attempts = attempts + <NUM_LIT:1> ) or ( <EOL> None , None , None ) <EOL> return result <EOL> def update_system_info ( ) : <EOL> mac = uuid . getnode ( ) . __str__ ( ) <EOL> hostname = socket . gethostname ( ) <EOL> patch = SystemPatch ( hostname = hostname , client_version = __version__ ) <EOL> return rest_client . patch_system ( patch , mac ) <EOL> def handle_system_information ( username , password ) : <EOL> mac = uuid . getnode ( ) . __str__ ( ) <EOL> system = rest_client . get_system_information ( mac ) <EOL> system_name = None <EOL> if system is None : <EOL> hostname = socket . gethostname ( ) <EOL> name_input = raw_input ( \"<STR_LIT>\" + <EOL> \"<STR_LIT>\" % hostname ) <EOL> name = name_input or hostname <EOL> system_name = rest_client . register_system ( RegisterSystem ( <EOL> name , mac , hostname , __version__ ) ) <EOL> if system_name : <EOL> print ( \"<STR_LIT>\" + name ) <EOL> else : <EOL> return ( None , None ) <EOL> access_token = rest_client . login_user ( LoginForm ( username , password , mac ) ) <EOL> if access_token is None : <EOL> print ( \"<STR_LIT>\" ) <EOL> return ( None , None ) <EOL> if system is not None : <EOL> system_name = system . name <EOL> print ( \"<STR_LIT>\" + <EOL> system . name + \"<STR_LIT:.>\" ) <EOL> return ( access_token , system_name ) <EOL> def write_to_config_file ( section , value ) : <EOL> exists = os . path . exists ( BH_HOME ) <EOL> file_path = BH_HOME + '<STR_LIT>' <EOL> permissions = stat . S_IRUSR | stat . S_IWUSR <EOL> if exists : <EOL> config = ConfigParser . ConfigParser ( ) <EOL> config . read ( BH_HOME + '<STR_LIT>' ) <EOL> if not config . has_section ( \"<STR_LIT>\" ) : <EOL> config . add_section ( \"<STR_LIT>\" ) <EOL> config . set ( \"<STR_LIT>\" , section , value ) <EOL> with open ( file_path , '<STR_LIT:w>' ) as config_file : <EOL> config . write ( config_file ) <EOL> os . chmod ( file_path , permissions ) <EOL> return True <EOL> else : <EOL> print ( \"<STR_LIT>\" ) <EOL> return False <EOL> def main ( ) : <EOL>", "answer": "try :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Intangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function <EOL> def setup ( app ) : <EOL> app . connect ( '<STR_LIT>' , add_html_link ) <EOL> app . connect ( '<STR_LIT>' , create_sitemap ) <EOL> app . sitemap_links = [ ] <EOL> def add_html_link ( app , pagename , templatename , context , doctree ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> site = context [ '<STR_LIT>' ] <EOL> version = context [ '<STR_LIT:version>' ] <EOL> app . sitemap_links . append ( site + version + '<STR_LIT:/>' + pagename + \"<STR_LIT>\" ) <EOL> def create_sitemap ( app , exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> filename = app . outdir + \"<STR_LIT>\" <EOL>", "answer": "print ( \"<STR_LIT>\" % filename )"}, {"prompt": "<s> from django . db import models <EOL> import datetime <EOL> from common . models import Project <EOL> class Stage ( models . Model ) : <EOL> name = models . CharField ( max_length = <NUM_LIT> ) <EOL> project = models . ForeignKey ( Project ) <EOL> text = models . TextField ( default = '<STR_LIT>' , blank = True ) <EOL> link = models . URLField ( default = None , blank = True , null = True ) <EOL> state = models . CharField ( max_length = <NUM_LIT> , default = '<STR_LIT:info>' , blank = True ) <EOL> weight = models . IntegerField ( default = <NUM_LIT:0> ) <EOL> updated = models . DateTimeField ( default = datetime . datetime . now ( ) ) <EOL> def save ( self , * args , ** kwargs ) : <EOL> self . updated = datetime . datetime . now ( ) <EOL> return super ( Stage , self ) . save ( * args , ** kwargs ) <EOL>", "answer": "def __str__ ( self ) :"}, {"prompt": "<s> from greenlet import greenlet <EOL>", "answer": "class GreenletWrapper :"}, {"prompt": "<s> from gwt . ui . SimplePanel import ( <EOL> DOM , <EOL> Factory , <EOL>", "answer": "Panel ,"}, {"prompt": "<s> import os <EOL> from urllib2 import urlopen <EOL> from boto . s3 . connection import S3Connection , S3ResponseError <EOL> from boto . s3 . connection import Location <EOL> from archivekit . store . common import Store , StoreObject , MANIFEST <EOL> DELIM = os . path . join ( '<STR_LIT:U+0020>' , '<STR_LIT:U+0020>' ) . strip ( ) <EOL> ALL_USERS = '<STR_LIT>' <EOL> class S3Store ( Store ) : <EOL> def __init__ ( self , aws_key_id = None , aws_secret = None , bucket_name = None , <EOL> prefix = None , location = Location . EU , ** kwargs ) : <EOL> if aws_key_id is None : <EOL> aws_key_id = os . environ . get ( '<STR_LIT>' ) <EOL> aws_secret = os . environ . get ( '<STR_LIT>' ) <EOL> self . aws_key_id = aws_key_id <EOL> self . aws_secret = aws_secret <EOL> if bucket_name is None : <EOL> bucket_name = os . environ . get ( '<STR_LIT>' ) <EOL> self . bucket_name = bucket_name <EOL> self . prefix = prefix <EOL> self . location = location <EOL> self . _bucket = None <EOL> @ property <EOL> def bucket ( self ) : <EOL> if self . _bucket is None : <EOL> self . conn = S3Connection ( self . aws_key_id , self . aws_secret ) <EOL> try : <EOL> self . _bucket = self . conn . get_bucket ( self . bucket_name ) <EOL> except S3ResponseError , se : <EOL> if se . status != <NUM_LIT> : <EOL> raise <EOL> self . _bucket = self . conn . create_bucket ( self . bucket_name , <EOL> location = self . location ) <EOL> return self . _bucket <EOL> def get_object ( self , collection , package_id , path ) : <EOL> return S3StoreObject ( self , collection , package_id , path ) <EOL> def _get_prefix ( self , collection ) : <EOL>", "answer": "prefix = collection"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> print ( __doc__ ) <EOL> import numpy as np <EOL> import matplotlib . pyplot as plt <EOL> from sklearn import linear_model <EOL> np . random . seed ( <NUM_LIT:0> ) <EOL> X = np . r_ [ np . random . randn ( <NUM_LIT:10> , <NUM_LIT:2> ) + [ <NUM_LIT:1> , <NUM_LIT:1> ] , np . random . randn ( <NUM_LIT:10> , <NUM_LIT:2> ) ] <EOL> y = [ <NUM_LIT:1> ] * <NUM_LIT:10> + [ - <NUM_LIT:1> ] * <NUM_LIT:10> <EOL> sample_weight = <NUM_LIT:100> * np . abs ( np . random . randn ( <NUM_LIT:20> ) ) <EOL>", "answer": "sample_weight [ : <NUM_LIT:10> ] *= <NUM_LIT:10>"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> from keystoneauth1 import loading as ks_loading <EOL> from neutron_lib . api import validators <EOL> from oslo_config import cfg <EOL> from oslo_db import options as db_options <EOL> from oslo_log import log as logging <EOL> import oslo_messaging <EOL> from oslo_middleware import cors <EOL> from oslo_service import wsgi <EOL> from neutron . _i18n import _ , _LI <EOL> from neutron . common import constants <EOL> from neutron . common import utils <EOL> from neutron import policy <EOL> from neutron import version <EOL> LOG = logging . getLogger ( __name__ ) <EOL> core_opts = [ <EOL> cfg . StrOpt ( '<STR_LIT>' , default = '<STR_LIT>' , <EOL> help = _ ( \"<STR_LIT>\" ) ) , <EOL> cfg . PortOpt ( '<STR_LIT>' , default = <NUM_LIT> , <EOL> help = _ ( \"<STR_LIT>\" ) ) , <EOL> cfg . StrOpt ( '<STR_LIT>' , default = \"<STR_LIT>\" , <EOL> help = _ ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) ) , <EOL> cfg . StrOpt ( '<STR_LIT>' , default = '<STR_LIT>' , <EOL> help = _ ( \"<STR_LIT>\" ) ) , <EOL> cfg . StrOpt ( '<STR_LIT>' , <EOL> help = _ ( \"<STR_LIT>\" ) ) , <EOL> cfg . ListOpt ( '<STR_LIT>' , default = [ ] , <EOL> help = _ ( \"<STR_LIT>\" ) ) , <EOL> cfg . StrOpt ( '<STR_LIT>' , default = \"<STR_LIT>\" , <EOL> help = _ ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) ) , <EOL> cfg . IntOpt ( '<STR_LIT>' , default = <NUM_LIT:16> , <EOL> help = _ ( \"<STR_LIT>\" ) ) , <EOL> cfg . BoolOpt ( '<STR_LIT>' , default = True , <EOL> help = _ ( \"<STR_LIT>\" ) ) , <EOL> cfg . BoolOpt ( '<STR_LIT>' , default = False , <EOL> help = _ ( \"<STR_LIT>\" ) ) , <EOL> cfg . BoolOpt ( '<STR_LIT>' , default = False , <EOL> help = _ ( \"<STR_LIT>\" ) ) , <EOL> cfg . StrOpt ( '<STR_LIT>' , default = \"<STR_LIT>\" , <EOL> help = _ ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) ) , <EOL> cfg . ListOpt ( '<STR_LIT>' , default = [ ] , <EOL> help = _ ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) ) , <EOL> cfg . IntOpt ( '<STR_LIT>' , default = <NUM_LIT:5> , <EOL> help = _ ( \"<STR_LIT>\" ) ) , <EOL> cfg . IntOpt ( '<STR_LIT>' , default = <NUM_LIT:20> , <EOL> help = _ ( \"<STR_LIT>\" ) ) , <EOL> cfg . IntOpt ( '<STR_LIT>' , default = <NUM_LIT:5> , <EOL> deprecated_for_removal = True , <EOL> help = _ ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) ) , <EOL> cfg . StrOpt ( '<STR_LIT>' , deprecated_for_removal = True , <EOL> help = _ ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) ) , <EOL>", "answer": "cfg . StrOpt ( '<STR_LIT>' , deprecated_for_removal = True ,"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL> from django . conf import settings <EOL> import django . db . models . deletion <EOL> import djangobmf . fields <EOL> class Migration ( migrations . Migration ) : <EOL> replaces = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> dependencies = [ <EOL> migrations . swappable_dependency ( settings . AUTH_USER_MODEL ) , <EOL> migrations . swappable_dependency ( settings . BMF_CONTRIB_PROJECT ) , <EOL> migrations . swappable_dependency ( settings . BMF_CONTRIB_PRODUCT ) , <EOL> migrations . swappable_dependency ( settings . BMF_CONTRIB_EMPLOYEE ) , <EOL> migrations . swappable_dependency ( settings . BMF_CONTRIB_ADDRESS ) , <EOL> migrations . swappable_dependency ( settings . BMF_CONTRIB_TRANSACTION ) , <EOL> migrations . swappable_dependency ( settings . BMF_CONTRIB_CUSTOMER ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( primary_key = True , auto_created = True , serialize = False , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . DateTimeField ( auto_now = True , null = True , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . DateTimeField ( auto_now_add = True , null = True , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( blank = True , db_index = True , editable = False , null = True , max_length = <NUM_LIT:100> , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT:state>' , djangobmf . fields . OLDWorkflowField ( editable = False , null = True , blank = True , max_length = <NUM_LIT:32> , db_index = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( null = True , max_length = <NUM_LIT:255> , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . FloatField ( editable = False , blank = True , null = True ) ) , <EOL> ( '<STR_LIT:date>' , models . DateField ( null = True , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . DateField ( blank = True , null = True , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . TextField ( blank = True , null = True , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . TextField ( blank = True , null = True , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( related_name = '<STR_LIT:+>' , blank = True , editable = False , to = settings . AUTH_USER_MODEL , null = True , on_delete = django . db . models . deletion . SET_NULL ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( null = True , to = settings . BMF_CONTRIB_CUSTOMER , on_delete = django . db . models . deletion . SET_NULL ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( null = True , to = settings . BMF_CONTRIB_EMPLOYEE , on_delete = django . db . models . deletion . SET_NULL ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( related_name = '<STR_LIT>' , null = True , to = settings . BMF_CONTRIB_ADDRESS , on_delete = django . db . models . deletion . SET_NULL ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( related_name = '<STR_LIT:+>' , blank = True , editable = False , to = settings . AUTH_USER_MODEL , null = True , on_delete = django . db . models . deletion . SET_NULL ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' : [ '<STR_LIT>' ] ,"}, {"prompt": "<s> from unittest import TestCase as BaseTest <EOL> import doze <EOL> class TestCase ( BaseTest ) : <EOL> pass <EOL> class TestDoze ( TestCase ) : <EOL> def test ( self ) : <EOL> twitter = doze . url ( \"<STR_LIT>\" ) <EOL> home_timeline = twitter . statuses ( \"<STR_LIT>\" ) <EOL> user_lookup = twitter . users ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( \"<STR_LIT>\" , <EOL> str ( home_timeline ) ) <EOL> self . assertEqual ( \"<STR_LIT>\" , <EOL> str ( user_lookup ( screen_name = \"<STR_LIT>\" ) ) ) <EOL> def test_simple ( self ) : <EOL> user_lookup = doze . url ( \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> screen_name = \"<STR_LIT>\" ) <EOL> self . assertEqual ( \"<STR_LIT>\" , <EOL> str ( user_lookup ) ) <EOL> def test_hardcoded_queries ( self ) : <EOL> google = doze . url ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( \"<STR_LIT>\" , <EOL> str ( google ( q = \"<STR_LIT>\" ) ) ) <EOL> def test_dupe_queries ( self ) : <EOL> google = doze . url ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( \"<STR_LIT>\" , <EOL> str ( google ( q = \"<STR_LIT>\" ) ) ) <EOL> def test_query_merge ( self ) : <EOL> google = doze . url ( \"<STR_LIT>\" ) <EOL> google = google ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( \"<STR_LIT>\" , <EOL> str ( google ) ) <EOL> google = doze . url ( \"<STR_LIT>\" ) <EOL> google = google ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( \"<STR_LIT>\" , <EOL> str ( google ) ) <EOL> def test_nonstring_bits ( self ) : <EOL> google = doze . url ( \"<STR_LIT>\" ) <EOL> google = google ( \"<STR_LIT>\" , <NUM_LIT:10> ) <EOL> self . assertEqual ( \"<STR_LIT>\" , <EOL> str ( google ( page = <NUM_LIT:1> ) ) ) <EOL> def test_list_params ( self ) : <EOL> google = doze . url ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( \"<STR_LIT>\" , <EOL> str ( google ( x = [ <NUM_LIT:1> , <NUM_LIT:2> ] ) ) ) <EOL> class TestMergeQueryList ( TestCase ) : <EOL> def test ( self ) : <EOL> self . assertEqual ( [ ( \"<STR_LIT:a>\" , \"<STR_LIT:2>\" ) ] , <EOL> doze . merge_querylist ( [ ( \"<STR_LIT:a>\" , \"<STR_LIT:1>\" ) ] , <EOL> [ ( \"<STR_LIT:a>\" , \"<STR_LIT:2>\" ) ] ) ) <EOL> self . assertEqual ( [ ( \"<STR_LIT:a>\" , \"<STR_LIT:1>\" ) , ( \"<STR_LIT:b>\" , \"<STR_LIT:2>\" ) ] , <EOL> doze . merge_querylist ( [ ( \"<STR_LIT:a>\" , \"<STR_LIT:1>\" ) ] , <EOL>", "answer": "[ ( \"<STR_LIT:b>\" , \"<STR_LIT:2>\" ) ] ) )"}, {"prompt": "<s> from pig_util import outputSchema <EOL> from datetime import datetime <EOL> import re <EOL> @ outputSchema ( '<STR_LIT>' ) <EOL> def parse_title ( title ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return re . sub ( r'<STR_LIT>' , '<STR_LIT>' , title ) <EOL> @ outputSchema ( '<STR_LIT>' ) <EOL>", "answer": "def days_since_release ( date ) :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Static ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from redis import StrictRedis <EOL> def get_default_connection ( request , <EOL> url = None , <EOL> redis_client = StrictRedis , <EOL> ** redis_options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> redis = getattr ( request . registry , '<STR_LIT>' , None ) <EOL> if redis is not None : <EOL> return redis <EOL> if url is not None : <EOL> redis_options . pop ( '<STR_LIT:password>' , None ) <EOL> redis_options . pop ( '<STR_LIT:host>' , None ) <EOL> redis_options . pop ( '<STR_LIT:port>' , None ) <EOL> redis_options . pop ( '<STR_LIT>' , None ) <EOL> redis_options . pop ( '<STR_LIT>' , None ) <EOL> redis_options . pop ( '<STR_LIT>' , None ) <EOL>", "answer": "redis = redis_client . from_url ( url , ** redis_options )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> __version__ = '<STR_LIT>' <EOL> class CertificateError ( ValueError ) : <EOL> pass <EOL> def _dnsname_match ( dn , hostname , max_wildcards = <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pats = [ ] <EOL> if not dn : <EOL>", "answer": "return False"}, {"prompt": "<s> import sys , argparse , os <EOL> from routes import RouteException <EOL> from commands import Command , CommandException <EOL> from util import find_subclasses <EOL> def main ( ) : <EOL> '''<STR_LIT>''' <EOL> os . environ [ '<STR_LIT>' ] = '<STR_LIT:100>' <EOL> parser = argparse . ArgumentParser ( prog = sys . argv [ <NUM_LIT:0> ] ) <EOL> subparsers = parser . add_subparsers ( ) <EOL> commands_dir = os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT>' ) <EOL> for module in os . listdir ( commands_dir ) : <EOL> if module == '<STR_LIT>' or module [ - <NUM_LIT:3> : ] != '<STR_LIT>' : <EOL> continue <EOL> command_mod = __import__ ( '<STR_LIT>' % module [ : - <NUM_LIT:3> ] , locals ( ) , globals ( ) , [ '<STR_LIT:object>' ] , - <NUM_LIT:1> ) <EOL> '''<STR_LIT>''' <EOL> for command_name , command_class in find_subclasses ( command_mod , Command ) : <EOL> command_parser = subparsers . add_parser ( command_name , help = command_class . help ) <EOL> command = command_class ( command_parser ) <EOL> command_parser . set_defaults ( func = command . run ) <EOL> args = parser . parse_args ( sys . argv [ <NUM_LIT:1> : ] ) <EOL>", "answer": "try :"}, {"prompt": "<s> import os <EOL> import sys <EOL> from core . models import User , Image <EOL> class XOSImageSelector ( object ) : <EOL> def __init__ ( self , user , distribution = None , type = None , architecture = None , version = None ) : <EOL> self . user = user <EOL> def get_allowed_images ( self ) : <EOL> nodes = Image . objects . all ( ) <EOL> return nodes <EOL>", "answer": "def get_image ( self ) :"}, {"prompt": "<s> import pymongo <EOL> from bson . objectid import ObjectId <EOL> from flask import Flask <EOL> from flask . ext import admin <EOL> from wtforms import form , fields <EOL> from flask . ext . admin . form import Select2Widget <EOL> from flask . ext . admin . contrib . pymongo import ModelView , filters <EOL> from flask . ext . admin . model . fields import InlineFormField , InlineFieldList <EOL> app = Flask ( __name__ ) <EOL> app . config [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> conn = pymongo . Connection ( ) <EOL> db = conn . test <EOL> class InnerForm ( form . Form ) : <EOL> name = fields . TextField ( '<STR_LIT:Name>' ) <EOL> test = fields . TextField ( '<STR_LIT>' ) <EOL> class UserForm ( form . Form ) : <EOL> name = fields . TextField ( '<STR_LIT:Name>' ) <EOL> email = fields . TextField ( '<STR_LIT>' ) <EOL> password = fields . TextField ( '<STR_LIT>' ) <EOL> inner = InlineFormField ( InnerForm ) <EOL> form_list = InlineFieldList ( InlineFormField ( InnerForm ) ) <EOL> class UserView ( ModelView ) : <EOL> column_list = ( '<STR_LIT:name>' , '<STR_LIT:email>' , '<STR_LIT:password>' ) <EOL> column_sortable_list = ( '<STR_LIT:name>' , '<STR_LIT:email>' , '<STR_LIT:password>' ) <EOL> form = UserForm <EOL> class TweetForm ( form . Form ) : <EOL> name = fields . TextField ( '<STR_LIT:Name>' ) <EOL> user_id = fields . SelectField ( '<STR_LIT>' , widget = Select2Widget ( ) ) <EOL> text = fields . TextField ( '<STR_LIT>' ) <EOL> testie = fields . BooleanField ( '<STR_LIT>' ) <EOL> class TweetView ( ModelView ) : <EOL> column_list = ( '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT:text>' ) <EOL> column_sortable_list = ( '<STR_LIT:name>' , '<STR_LIT:text>' ) <EOL> column_filters = ( filters . FilterEqual ( '<STR_LIT:name>' , '<STR_LIT:Name>' ) , <EOL> filters . FilterNotEqual ( '<STR_LIT:name>' , '<STR_LIT:Name>' ) , <EOL> filters . FilterLike ( '<STR_LIT:name>' , '<STR_LIT:Name>' ) , <EOL> filters . FilterNotLike ( '<STR_LIT:name>' , '<STR_LIT:Name>' ) , <EOL> filters . BooleanEqualFilter ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> column_searchable_list = ( '<STR_LIT:name>' , '<STR_LIT:text>' ) <EOL> form = TweetForm <EOL> def get_list ( self , * args , ** kwargs ) : <EOL> count , data = super ( TweetView , self ) . get_list ( * args , ** kwargs ) <EOL> query = { '<STR_LIT>' : { '<STR_LIT>' : [ x [ '<STR_LIT>' ] for x in data ] } } <EOL> users = db . user . find ( query , fields = ( '<STR_LIT:name>' , ) ) <EOL> users_map = dict ( ( x [ '<STR_LIT>' ] , x [ '<STR_LIT:name>' ] ) for x in users ) <EOL> for item in data : <EOL> item [ '<STR_LIT>' ] = users_map . get ( item [ '<STR_LIT>' ] ) <EOL> return count , data <EOL>", "answer": "def _feed_user_choices ( self , form ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> class Node ( object ) : <EOL> __slots__ = '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:index>' , <EOL> def __init__ ( self , tag , children , index ) : <EOL> self . tag = tag <EOL> self . children = children <EOL> self . index = index <EOL> def as_sexpr ( self ) : <EOL> return ( self . tag , ) + tuple ( [ c . as_sexpr ( ) for c in self . children ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> self . tag , <EOL> self . children , <EOL> self . index ) <EOL> class _GLUECLAMP_ : <EOL> _imports_ = ( <EOL> '<STR_LIT>' , <EOL> ) <EOL> _chgable_ = '<STR_LIT>' , '<STR_LIT>' <EOL> dotchar = '<STR_LIT:.>' <EOL>", "answer": "quotechar = '<STR_LIT:\\\\>'"}, {"prompt": "<s> PANEL = '<STR_LIT>' <EOL> PANEL_DASHBOARD = '<STR_LIT>' <EOL> PANEL_GROUP = '<STR_LIT>' <EOL>", "answer": "ADD_PANEL = '<STR_LIT>' "}, {"prompt": "<s> def startup_installed ( sender ) : <EOL>", "answer": "from uliweb . utils . date import set_timezone , set_local_timezone"}, {"prompt": "<s> import copy <EOL> import struct <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> def _compact_word ( word ) : <EOL> return ( word [ <NUM_LIT:0> ] << <NUM_LIT> ) | ( word [ <NUM_LIT:1> ] << <NUM_LIT:16> ) | ( word [ <NUM_LIT:2> ] << <NUM_LIT:8> ) | word [ <NUM_LIT:3> ] <EOL> def _string_to_bytes ( text ) : <EOL> return list ( ord ( c ) for c in text ) <EOL> def _bytes_to_string ( binary ) : <EOL> return \"<STR_LIT>\" . join ( chr ( b ) for b in binary ) <EOL> def _concat_list ( a , b ) : <EOL> return a + b <EOL> try : <EOL> xrange <EOL> except Exception : <EOL> xrange = range <EOL> def _string_to_bytes ( text ) : <EOL> if isinstance ( text , bytes ) : <EOL> return text <EOL> return [ ord ( c ) for c in text ] <EOL> def _bytes_to_string ( binary ) : <EOL> return bytes ( binary ) <EOL> def _concat_list ( a , b ) : <EOL> return a + bytes ( b ) <EOL> class AES ( object ) : <EOL> '''<STR_LIT>''' <EOL> number_of_rounds = { <NUM_LIT:16> : <NUM_LIT:10> , <NUM_LIT> : <NUM_LIT:12> , <NUM_LIT:32> : <NUM_LIT> } <EOL> rcon = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> S = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> Si = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> T1 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> T2 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> T3 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> T4 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> T5 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> T6 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> T7 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> T8 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> U1 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> U2 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> U3 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> U4 = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> def __init__ ( self , key ) : <EOL> if len ( key ) not in ( <NUM_LIT:16> , <NUM_LIT> , <NUM_LIT:32> ) : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> rounds = self . number_of_rounds [ len ( key ) ] <EOL> self . _Ke = [ [ <NUM_LIT:0> ] * <NUM_LIT:4> for i in xrange ( rounds + <NUM_LIT:1> ) ] <EOL> self . _Kd = [ [ <NUM_LIT:0> ] * <NUM_LIT:4> for i in xrange ( rounds + <NUM_LIT:1> ) ] <EOL> round_key_count = ( rounds + <NUM_LIT:1> ) * <NUM_LIT:4> <EOL> KC = len ( key ) // <NUM_LIT:4> <EOL> tk = [ struct . unpack ( '<STR_LIT>' , key [ i : i + <NUM_LIT:4> ] ) [ <NUM_LIT:0> ] for i in xrange ( <NUM_LIT:0> , len ( key ) , <NUM_LIT:4> ) ] <EOL> for i in xrange ( <NUM_LIT:0> , KC ) : <EOL> self . _Ke [ i // <NUM_LIT:4> ] [ i % <NUM_LIT:4> ] = tk [ i ] <EOL> self . _Kd [ rounds - ( i // <NUM_LIT:4> ) ] [ i % <NUM_LIT:4> ] = tk [ i ] <EOL> rconpointer = <NUM_LIT:0> <EOL> t = KC <EOL> while t < round_key_count : <EOL> tt = tk [ KC - <NUM_LIT:1> ] <EOL> tk [ <NUM_LIT:0> ] ^= ( ( self . S [ ( tt >> <NUM_LIT:16> ) & <NUM_LIT> ] << <NUM_LIT> ) ^ <EOL> ( self . S [ ( tt >> <NUM_LIT:8> ) & <NUM_LIT> ] << <NUM_LIT:16> ) ^ <EOL> ( self . S [ tt & <NUM_LIT> ] << <NUM_LIT:8> ) ^ <EOL> self . S [ ( tt >> <NUM_LIT> ) & <NUM_LIT> ] ^ <EOL> ( self . rcon [ rconpointer ] << <NUM_LIT> ) ) <EOL> rconpointer += <NUM_LIT:1> <EOL> if KC != <NUM_LIT:8> : <EOL> for i in xrange ( <NUM_LIT:1> , KC ) : <EOL> tk [ i ] ^= tk [ i - <NUM_LIT:1> ] <EOL> else : <EOL> for i in xrange ( <NUM_LIT:1> , KC // <NUM_LIT:2> ) : <EOL> tk [ i ] ^= tk [ i - <NUM_LIT:1> ] <EOL> tt = tk [ KC // <NUM_LIT:2> - <NUM_LIT:1> ] <EOL> tk [ KC // <NUM_LIT:2> ] ^= ( self . S [ tt & <NUM_LIT> ] ^ <EOL> ( self . S [ ( tt >> <NUM_LIT:8> ) & <NUM_LIT> ] << <NUM_LIT:8> ) ^ <EOL> ( self . S [ ( tt >> <NUM_LIT:16> ) & <NUM_LIT> ] << <NUM_LIT:16> ) ^ <EOL> ( self . S [ ( tt >> <NUM_LIT> ) & <NUM_LIT> ] << <NUM_LIT> ) ) <EOL> for i in xrange ( KC // <NUM_LIT:2> + <NUM_LIT:1> , KC ) : <EOL> tk [ i ] ^= tk [ i - <NUM_LIT:1> ] <EOL> j = <NUM_LIT:0> <EOL> while j < KC and t < round_key_count : <EOL> self . _Ke [ t // <NUM_LIT:4> ] [ t % <NUM_LIT:4> ] = tk [ j ] <EOL> self . _Kd [ rounds - ( t // <NUM_LIT:4> ) ] [ t % <NUM_LIT:4> ] = tk [ j ] <EOL> j += <NUM_LIT:1> <EOL> t += <NUM_LIT:1> <EOL> for r in xrange ( <NUM_LIT:1> , rounds ) : <EOL> for j in xrange ( <NUM_LIT:0> , <NUM_LIT:4> ) : <EOL> tt = self . _Kd [ r ] [ j ] <EOL> self . _Kd [ r ] [ j ] = ( self . U1 [ ( tt >> <NUM_LIT> ) & <NUM_LIT> ] ^ <EOL> self . U2 [ ( tt >> <NUM_LIT:16> ) & <NUM_LIT> ] ^ <EOL> self . U3 [ ( tt >> <NUM_LIT:8> ) & <NUM_LIT> ] ^ <EOL> self . U4 [ tt & <NUM_LIT> ] ) <EOL> def encrypt ( self , plaintext ) : <EOL> '<STR_LIT>' <EOL> if len ( plaintext ) != <NUM_LIT:16> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> rounds = len ( self . _Ke ) - <NUM_LIT:1> <EOL> ( s1 , s2 , s3 ) = [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] <EOL> a = [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] <EOL> t = [ ( _compact_word ( plaintext [ <NUM_LIT:4> * i : <NUM_LIT:4> * i + <NUM_LIT:4> ] ) ^ self . _Ke [ <NUM_LIT:0> ] [ i ] ) for i in xrange ( <NUM_LIT:0> , <NUM_LIT:4> ) ] <EOL> for r in xrange ( <NUM_LIT:1> , rounds ) : <EOL> for i in xrange ( <NUM_LIT:0> , <NUM_LIT:4> ) : <EOL> a [ i ] = ( self . T1 [ ( t [ i ] >> <NUM_LIT> ) & <NUM_LIT> ] ^ <EOL> self . T2 [ ( t [ ( i + s1 ) % <NUM_LIT:4> ] >> <NUM_LIT:16> ) & <NUM_LIT> ] ^ <EOL> self . T3 [ ( t [ ( i + s2 ) % <NUM_LIT:4> ] >> <NUM_LIT:8> ) & <NUM_LIT> ] ^ <EOL> self . T4 [ t [ ( i + s3 ) % <NUM_LIT:4> ] & <NUM_LIT> ] ^ <EOL> self . _Ke [ r ] [ i ] ) <EOL> t = copy . copy ( a ) <EOL> result = [ ] <EOL> for i in xrange ( <NUM_LIT:0> , <NUM_LIT:4> ) : <EOL> tt = self . _Ke [ rounds ] [ i ] <EOL> result . append ( ( self . S [ ( t [ i ] >> <NUM_LIT> ) & <NUM_LIT> ] ^ ( tt >> <NUM_LIT> ) ) & <NUM_LIT> ) <EOL> result . append ( ( self . S [ ( t [ ( i + s1 ) % <NUM_LIT:4> ] >> <NUM_LIT:16> ) & <NUM_LIT> ] ^ ( tt >> <NUM_LIT:16> ) ) & <NUM_LIT> ) <EOL> result . append ( ( self . S [ ( t [ ( i + s2 ) % <NUM_LIT:4> ] >> <NUM_LIT:8> ) & <NUM_LIT> ] ^ ( tt >> <NUM_LIT:8> ) ) & <NUM_LIT> ) <EOL> result . append ( ( self . S [ t [ ( i + s3 ) % <NUM_LIT:4> ] & <NUM_LIT> ] ^ tt ) & <NUM_LIT> ) <EOL> return result <EOL> def decrypt ( self , ciphertext ) : <EOL> '<STR_LIT>' <EOL> if len ( ciphertext ) != <NUM_LIT:16> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> rounds = len ( self . _Kd ) - <NUM_LIT:1> <EOL> ( s1 , s2 , s3 ) = [ <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:1> ] <EOL> a = [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] <EOL> t = [ ( _compact_word ( ciphertext [ <NUM_LIT:4> * i : <NUM_LIT:4> * i + <NUM_LIT:4> ] ) ^ self . _Kd [ <NUM_LIT:0> ] [ i ] ) for i in xrange ( <NUM_LIT:0> , <NUM_LIT:4> ) ] <EOL> for r in xrange ( <NUM_LIT:1> , rounds ) : <EOL> for i in xrange ( <NUM_LIT:0> , <NUM_LIT:4> ) : <EOL> a [ i ] = ( self . T5 [ ( t [ i ] >> <NUM_LIT> ) & <NUM_LIT> ] ^ <EOL> self . T6 [ ( t [ ( i + s1 ) % <NUM_LIT:4> ] >> <NUM_LIT:16> ) & <NUM_LIT> ] ^ <EOL> self . T7 [ ( t [ ( i + s2 ) % <NUM_LIT:4> ] >> <NUM_LIT:8> ) & <NUM_LIT> ] ^ <EOL> self . T8 [ t [ ( i + s3 ) % <NUM_LIT:4> ] & <NUM_LIT> ] ^ <EOL> self . _Kd [ r ] [ i ] ) <EOL> t = copy . copy ( a ) <EOL> result = [ ] <EOL> for i in xrange ( <NUM_LIT:0> , <NUM_LIT:4> ) : <EOL> tt = self . _Kd [ rounds ] [ i ] <EOL> result . append ( ( self . Si [ ( t [ i ] >> <NUM_LIT> ) & <NUM_LIT> ] ^ ( tt >> <NUM_LIT> ) ) & <NUM_LIT> ) <EOL> result . append ( ( self . Si [ ( t [ ( i + s1 ) % <NUM_LIT:4> ] >> <NUM_LIT:16> ) & <NUM_LIT> ] ^ ( tt >> <NUM_LIT:16> ) ) & <NUM_LIT> ) <EOL> result . append ( ( self . Si [ ( t [ ( i + s2 ) % <NUM_LIT:4> ] >> <NUM_LIT:8> ) & <NUM_LIT> ] ^ ( tt >> <NUM_LIT:8> ) ) & <NUM_LIT> ) <EOL> result . append ( ( self . Si [ t [ ( i + s3 ) % <NUM_LIT:4> ] & <NUM_LIT> ] ^ tt ) & <NUM_LIT> ) <EOL> return result <EOL> class Counter ( object ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , initial_value = <NUM_LIT:1> ) : <EOL> self . _counter = [ ( ( initial_value >> i ) % <NUM_LIT> ) for i in xrange ( <NUM_LIT> - <NUM_LIT:8> , - <NUM_LIT:1> , - <NUM_LIT:8> ) ] <EOL> value = property ( lambda s : s . _counter ) <EOL> def increment ( self ) : <EOL> '''<STR_LIT>''' <EOL> for i in xrange ( len ( self . _counter ) - <NUM_LIT:1> , - <NUM_LIT:1> , - <NUM_LIT:1> ) : <EOL> self . _counter [ i ] += <NUM_LIT:1> <EOL> if self . _counter [ i ] < <NUM_LIT> : break <EOL> self . _counter [ i ] = <NUM_LIT:0> <EOL> else : <EOL> self . _counter = [ <NUM_LIT:0> ] * len ( self . _counter ) <EOL> class AESBlockModeOfOperation ( object ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , key ) : <EOL> self . _aes = AES ( key ) <EOL> def decrypt ( self , ciphertext ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> def encrypt ( self , plaintext ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> class AESStreamModeOfOperation ( AESBlockModeOfOperation ) : <EOL> '''<STR_LIT>''' <EOL> class AESSegmentModeOfOperation ( AESStreamModeOfOperation ) : <EOL> '''<STR_LIT>''' <EOL> segment_bytes = <NUM_LIT:16> <EOL> class AESModeOfOperationECB ( AESBlockModeOfOperation ) : <EOL> '''<STR_LIT>''' <EOL> name = \"<STR_LIT>\" <EOL> def encrypt ( self , plaintext ) : <EOL> if len ( plaintext ) != <NUM_LIT:16> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> plaintext = _string_to_bytes ( plaintext ) <EOL> return _bytes_to_string ( self . _aes . encrypt ( plaintext ) ) <EOL> def decrypt ( self , ciphertext ) : <EOL> if len ( ciphertext ) != <NUM_LIT:16> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> ciphertext = _string_to_bytes ( ciphertext ) <EOL> return _bytes_to_string ( self . _aes . decrypt ( ciphertext ) ) <EOL> class AESModeOfOperationCBC ( AESBlockModeOfOperation ) : <EOL> '''<STR_LIT>''' <EOL> name = \"<STR_LIT>\" <EOL> def __init__ ( self , key , iv = None ) : <EOL> if iv is None : <EOL> self . _last_cipherblock = [ <NUM_LIT:0> ] * <NUM_LIT:16> <EOL> elif len ( iv ) != <NUM_LIT:16> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> else : <EOL> self . _last_cipherblock = _string_to_bytes ( iv ) <EOL> AESBlockModeOfOperation . __init__ ( self , key ) <EOL> def encrypt ( self , plaintext ) : <EOL> if len ( plaintext ) != <NUM_LIT:16> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> plaintext = _string_to_bytes ( plaintext ) <EOL> precipherblock = [ ( p ^ l ) for ( p , l ) in zip ( plaintext , self . _last_cipherblock ) ] <EOL> self . _last_cipherblock = self . _aes . encrypt ( precipherblock ) <EOL> return _bytes_to_string ( self . _last_cipherblock ) <EOL> def decrypt ( self , ciphertext ) : <EOL> if len ( ciphertext ) != <NUM_LIT:16> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> cipherblock = _string_to_bytes ( ciphertext ) <EOL> plaintext = [ ( p ^ l ) for ( p , l ) in zip ( self . _aes . decrypt ( cipherblock ) , self . _last_cipherblock ) ] <EOL> self . _last_cipherblock = cipherblock <EOL> return _bytes_to_string ( plaintext ) <EOL> class AESModeOfOperationCFB ( AESSegmentModeOfOperation ) : <EOL> '''<STR_LIT>''' <EOL> name = \"<STR_LIT>\" <EOL> def __init__ ( self , key , iv , segment_size = <NUM_LIT:1> ) : <EOL> if segment_size == <NUM_LIT:0> : segment_size = <NUM_LIT:1> <EOL> if iv is None : <EOL> self . _shift_register = [ <NUM_LIT:0> ] * <NUM_LIT:16> <EOL> elif len ( iv ) != <NUM_LIT:16> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> else : <EOL> self . _shift_register = _string_to_bytes ( iv ) <EOL> self . _segment_bytes = segment_size <EOL> AESBlockModeOfOperation . __init__ ( self , key ) <EOL> segment_bytes = property ( lambda s : s . _segment_bytes ) <EOL> def encrypt ( self , plaintext ) : <EOL> if len ( plaintext ) % self . _segment_bytes != <NUM_LIT:0> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> plaintext = _string_to_bytes ( plaintext ) <EOL> encrypted = [ ] <EOL> for i in xrange ( <NUM_LIT:0> , len ( plaintext ) , self . _segment_bytes ) : <EOL> plaintext_segment = plaintext [ i : i + self . _segment_bytes ] <EOL> xor_segment = self . _aes . encrypt ( self . _shift_register ) [ : len ( plaintext_segment ) ] <EOL> cipher_segment = [ ( p ^ x ) for ( p , x ) in zip ( plaintext_segment , xor_segment ) ] <EOL> self . _shift_register = _concat_list ( self . _shift_register [ len ( cipher_segment ) : ] , cipher_segment ) <EOL> encrypted . extend ( cipher_segment ) <EOL> return _bytes_to_string ( encrypted ) <EOL> def decrypt ( self , ciphertext ) : <EOL> if len ( ciphertext ) % self . _segment_bytes != <NUM_LIT:0> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> ciphertext = _string_to_bytes ( ciphertext ) <EOL> decrypted = [ ] <EOL> for i in xrange ( <NUM_LIT:0> , len ( ciphertext ) , self . _segment_bytes ) : <EOL> cipher_segment = ciphertext [ i : i + self . _segment_bytes ] <EOL> xor_segment = self . _aes . encrypt ( self . _shift_register ) [ : len ( cipher_segment ) ] <EOL> plaintext_segment = [ ( p ^ x ) for ( p , x ) in zip ( cipher_segment , xor_segment ) ] <EOL> self . _shift_register = _concat_list ( self . _shift_register [ len ( cipher_segment ) : ] , cipher_segment ) <EOL> decrypted . extend ( plaintext_segment ) <EOL> return _bytes_to_string ( decrypted ) <EOL> class AESModeOfOperationOFB ( AESStreamModeOfOperation ) : <EOL> '''<STR_LIT>''' <EOL> name = \"<STR_LIT>\" <EOL> def __init__ ( self , key , iv = None ) : <EOL> if iv is None : <EOL> self . _last_precipherblock = [ <NUM_LIT:0> ] * <NUM_LIT:16> <EOL> elif len ( iv ) != <NUM_LIT:16> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> else : <EOL> self . _last_precipherblock = _string_to_bytes ( iv ) <EOL> self . _remaining_block = [ ] <EOL> AESBlockModeOfOperation . __init__ ( self , key ) <EOL> def encrypt ( self , plaintext ) : <EOL> encrypted = [ ] <EOL> for p in _string_to_bytes ( plaintext ) : <EOL> if len ( self . _remaining_block ) == <NUM_LIT:0> : <EOL> self . _remaining_block = self . _aes . encrypt ( self . _last_precipherblock ) <EOL> self . _last_precipherblock = [ ] <EOL> precipherbyte = self . _remaining_block . pop ( <NUM_LIT:0> ) <EOL> self . _last_precipherblock . append ( precipherbyte ) <EOL> cipherbyte = p ^ precipherbyte <EOL> encrypted . append ( cipherbyte ) <EOL> return _bytes_to_string ( encrypted ) <EOL> def decrypt ( self , ciphertext ) : <EOL> return self . encrypt ( ciphertext ) <EOL> class AESModeOfOperationCTR ( AESStreamModeOfOperation ) : <EOL> '''<STR_LIT>''' <EOL> name = \"<STR_LIT>\" <EOL> def __init__ ( self , key , counter = None ) : <EOL> AESBlockModeOfOperation . __init__ ( self , key ) <EOL> if counter is None : <EOL> counter = Counter ( ) <EOL> self . _counter = counter <EOL> self . _remaining_counter = [ ] <EOL> def encrypt ( self , plaintext ) : <EOL> while len ( self . _remaining_counter ) < len ( plaintext ) : <EOL> self . _remaining_counter += self . _aes . encrypt ( self . _counter . value ) <EOL> self . _counter . increment ( ) <EOL> plaintext = _string_to_bytes ( plaintext ) <EOL> encrypted = [ ( p ^ c ) for ( p , c ) in zip ( plaintext , self . _remaining_counter ) ] <EOL> self . _remaining_counter = self . _remaining_counter [ len ( encrypted ) : ] <EOL> return _bytes_to_string ( encrypted ) <EOL>", "answer": "def decrypt ( self , crypttext ) :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from . . requests import UserListResponse <EOL> class UsersFollowers : <EOL> def __init__ ( self , client ) : <EOL> self . client = client <EOL> def list_followers ( self , user = None ) : <EOL> url = '<STR_LIT>' % user if ( <EOL> user is not None and user != self . client . _username ) else '<STR_LIT>' <EOL> return self . client . get ( url , msg_type = UserListResponse ) <EOL> def list_following ( self , user = None ) : <EOL> url = '<STR_LIT>' % user if ( <EOL> user is not None and user != self . client . _username ) else '<STR_LIT>' <EOL> return self . client . get ( url , msg_type = UserListResponse ) <EOL> def is_following ( self , user ) : <EOL> return self . client . get ( <EOL>", "answer": "'<STR_LIT>' % user )"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL> from owslib . wps import WebProcessingService , WPSExecution , WFSFeatureCollection , WFSQuery , GMLMultiPolygonFeatureCollection , monitorExecution , ComplexData , printInputOutput <EOL> from owslib . util import dump <EOL> verbose = True <EOL> wps = WebProcessingService ( '<STR_LIT>' , verbose = verbose ) <EOL> wps . getcapabilities ( ) <EOL> print ( '<STR_LIT>' % wps . identification . type ) <EOL>", "answer": "print ( '<STR_LIT>' % wps . identification . title )"}, {"prompt": "<s> from collections import defaultdict <EOL> import logging <EOL> import networkx <EOL> import simuvex <EOL> from . pathprioritizer import PathPrioritizer <EOL> from . errors import AngrAnnotatedCFGError , AngrExitError <EOL> from . analyses . cfg_node import CFGNode <EOL> l = logging . getLogger ( \"<STR_LIT>\" ) <EOL> class AnnotatedCFG ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , project , cfg = None , detect_loops = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _project = project <EOL> self . _cfg = None <EOL> self . _target = None <EOL> self . _run_statement_whitelist = defaultdict ( list ) <EOL> self . _exit_taken = defaultdict ( list ) <EOL> self . _addr_to_run = { } <EOL> self . _addr_to_last_stmt_id = { } <EOL> self . _loops = [ ] <EOL> self . _path_merge_points = [ ] <EOL> self . _path_prioritizer = None <EOL> if cfg is not None : <EOL> self . _cfg = cfg <EOL> if self . _cfg is not None : <EOL> for run in self . _cfg . nodes ( ) : <EOL> self . _addr_to_run [ self . get_addr ( run ) ] = run <EOL> def from_digraph ( self , digraph ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for n1 , n2 in digraph . edges ( ) : <EOL> addr1 , stmt_idx1 = n1 <EOL> addr2 , stmt_idx2 = n2 <EOL> if addr1 != addr2 : <EOL> self . add_exit_to_whitelist ( addr1 , addr2 ) <EOL> self . add_statements_to_whitelist ( addr1 , ( stmt_idx1 , ) ) <EOL> self . add_statements_to_whitelist ( addr2 , ( stmt_idx2 , ) ) <EOL> def get_addr ( self , run ) : <EOL> if isinstance ( run , simuvex . SimIRSB ) : <EOL> return run . first_imark . addr <EOL> elif isinstance ( run , simuvex . SimProcedure ) : <EOL> pseudo_addr = run . addr <EOL> return pseudo_addr <EOL> elif isinstance ( run , CFGNode ) : <EOL> return run . addr <EOL> elif type ( run ) in ( int , long ) : <EOL> return run <EOL> else : <EOL> raise AngrAnnotatedCFGError ( \"<STR_LIT>\" % type ( run ) ) <EOL> def add_simrun_to_whitelist ( self , simrun ) : <EOL> addr = self . get_addr ( simrun ) <EOL> self . _run_statement_whitelist [ addr ] = True <EOL> def add_statements_to_whitelist ( self , simrun , stmt_ids ) : <EOL> addr = self . get_addr ( simrun ) <EOL> if type ( stmt_ids ) is bool : <EOL> if type ( self . _run_statement_whitelist [ addr ] ) is list and self . _run_statement_whitelist [ addr ] : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> self . _run_statement_whitelist [ addr ] = stmt_ids <EOL> elif - <NUM_LIT:1> in stmt_ids : <EOL> self . _run_statement_whitelist [ addr ] = True <EOL> else : <EOL> self . _run_statement_whitelist [ addr ] . extend ( stmt_ids ) <EOL> self . _run_statement_whitelist [ addr ] = sorted ( list ( set ( self . _run_statement_whitelist [ addr ] ) ) ) <EOL> def add_exit_to_whitelist ( self , run_from , run_to ) : <EOL> addr_from = self . get_addr ( run_from ) <EOL> addr_to = self . get_addr ( run_to ) <EOL> self . _exit_taken [ addr_from ] . append ( addr_to ) <EOL> def set_last_statement ( self , simrun_addr , stmt_id ) : <EOL> self . _addr_to_last_stmt_id [ simrun_addr ] = stmt_id <EOL> def add_loop ( self , loop_tuple ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _loops . append ( loop_tuple ) <EOL> def set_path_merge_points ( self , points ) : <EOL> self . _path_merge_points = points . copy ( ) <EOL> def should_take_exit ( self , addr_from , addr_to ) : <EOL> if addr_from in self . _exit_taken : <EOL> return addr_to in self . _exit_taken [ addr_from ] <EOL> return False <EOL> def should_execute_statement ( self , addr , stmt_id ) : <EOL> if self . _run_statement_whitelist is None : <EOL> return True <EOL> elif addr in self . _run_statement_whitelist : <EOL> r = self . _run_statement_whitelist [ addr ] <EOL> if isinstance ( r , bool ) : <EOL> return r <EOL> else : <EOL> return stmt_id in self . _run_statement_whitelist [ addr ] <EOL> return False <EOL> def get_run ( self , addr ) : <EOL> if addr in self . _addr_to_run : <EOL> return self . _addr_to_run [ addr ] <EOL> return None <EOL> def get_whitelisted_statements ( self , addr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if addr in self . _run_statement_whitelist : <EOL> if self . _run_statement_whitelist [ addr ] is True : <EOL> return None <EOL> else : <EOL> return self . _run_statement_whitelist [ addr ] <EOL> else : <EOL> return [ ] <EOL> def get_last_statement_index ( self , addr ) : <EOL> if addr in self . _addr_to_last_stmt_id : <EOL> return self . _addr_to_last_stmt_id [ addr ] <EOL> return None <EOL> def get_loops ( self ) : <EOL> return self . _loops <EOL> def dbg_repr ( self ) : <EOL> ret_str = \"<STR_LIT>\" <EOL> ret_str += \"<STR_LIT>\" <EOL> for addr , run in self . _addr_to_run . items ( ) : <EOL> if addr is None : <EOL> continue <EOL> ret_str += \"<STR_LIT>\" % ( addr , run ) <EOL> l . debug ( \"<STR_LIT>\" ) <EOL> for addr , stmts in self . _run_statement_whitelist . items ( ) : <EOL> if addr is None : <EOL> continue <EOL> ret_str += \"<STR_LIT>\" % addr <EOL> l . debug ( stmts ) <EOL> l . debug ( \"<STR_LIT>\" ) <EOL> for loop in self . _loops : <EOL> s = \"<STR_LIT>\" <EOL> for addr in loop : <EOL> s += \"<STR_LIT>\" % addr <EOL> ret_str += s + \"<STR_LIT:\\n>\" <EOL> return ret_str <EOL> def dbg_print_irsb ( self , irsb_addr , project = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if project is None : <EOL> project = self . _project <EOL> if project is None : <EOL> raise Exception ( \"<STR_LIT>\" + \"<STR_LIT>\" ) <EOL> else : <EOL> vex_block = project . factory . block ( irsb_addr ) . vex <EOL> statements = vex_block . statements <EOL> whitelist = self . get_whitelisted_statements ( irsb_addr ) <EOL> for i in range ( <NUM_LIT:0> , len ( statements ) ) : <EOL> if whitelist is True or i in whitelist : <EOL> line = \"<STR_LIT:+>\" <EOL> else : <EOL> line = \"<STR_LIT:->\" <EOL> line += \"<STR_LIT>\" % i <EOL> print line , <EOL> statements [ i ] . pp ( ) <EOL> def keep_path ( self , path ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( path . addr_trace ) < <NUM_LIT:2> : <EOL> return True <EOL> return self . should_take_exit ( path . addr_trace [ - <NUM_LIT:2> ] , path . addr_trace [ - <NUM_LIT:1> ] ) <EOL> def filter_path ( self , path ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return True <EOL> def merge_points ( self , path ) : <EOL> addr = path . addr <EOL> if addr in self . _path_merge_points : <EOL> return { self . _path_merge_points [ addr ] } <EOL> else : <EOL> return set ( ) <EOL> def path_priority ( self , path ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _path_prioritizer . get_priority ( path ) <EOL> def successor_func ( self , path ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> whitelist = self . get_whitelisted_statements ( path . addr ) <EOL> last_stmt = self . get_last_statement_index ( path . addr ) <EOL>", "answer": "successors = path . step ("}, {"prompt": "<s> from foam . sfa . rspecs . elements . element import Element <EOL> class VM ( Element ) : <EOL> fields = [ <EOL> '<STR_LIT:name>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> import StringIO , os , sys <EOL> from zope . interface import implements <EOL> from zope . interface . verify import verifyObject <EOL> from twisted . trial . itrial import IReporter , ITestCase <EOL> from twisted . trial import unittest , runner , reporter , util <EOL> from twisted . python import failure , log , reflect , filepath <EOL> from twisted . python . filepath import FilePath <EOL> from twisted . scripts import trial <EOL> from twisted . plugins import twisted_trial <EOL> from twisted import plugin <EOL> from twisted . internet import defer <EOL> pyunit = __import__ ( '<STR_LIT>' ) <EOL> class CapturingDebugger ( object ) : <EOL> def __init__ ( self ) : <EOL> self . _calls = [ ] <EOL> def runcall ( self , * args , ** kwargs ) : <EOL> self . _calls . append ( '<STR_LIT>' ) <EOL> args [ <NUM_LIT:0> ] ( * args [ <NUM_LIT:1> : ] , ** kwargs ) <EOL> class CapturingReporter ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> implements ( IReporter ) <EOL> stream = None <EOL> tbformat = None <EOL> args = None <EOL> separator = None <EOL> testsRun = None <EOL> def __init__ ( self , stream = None , tbformat = None , rterrors = None , <EOL> publisher = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _calls = [ ] <EOL> self . shouldStop = False <EOL> self . _stream = stream <EOL> self . _tbformat = tbformat <EOL> self . _rterrors = rterrors <EOL> self . _publisher = publisher <EOL> def startTest ( self , method ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _calls . append ( '<STR_LIT>' ) <EOL> def stopTest ( self , method ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _calls . append ( '<STR_LIT>' ) <EOL> def cleanupErrors ( self , errs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _calls . append ( '<STR_LIT>' ) <EOL> def addSuccess ( self , test ) : <EOL> self . _calls . append ( '<STR_LIT>' ) <EOL> def done ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class TrialRunnerTestsMixin : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def tearDown ( self ) : <EOL> self . runner . _tearDownLogFile ( ) <EOL> def test_empty ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _getObservers ( self ) : <EOL> return log . theLogPublisher . observers <EOL> def test_addObservers ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> originalCount = len ( self . _getObservers ( ) ) <EOL> self . runner . run ( self . test ) <EOL> newCount = len ( self . _getObservers ( ) ) <EOL> self . assertEqual ( newCount , originalCount ) <EOL> def test_logFileAlwaysActive ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> oldSetUpLogFile = self . runner . _setUpLogFile <EOL>", "answer": "l = [ ]"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from __future__ import absolute_import <EOL> from salttesting import skipIf , TestCase <EOL> from salttesting . mock import ( <EOL> NO_MOCK , <EOL> NO_MOCK_REASON , <EOL> MagicMock , <EOL> patch ) <EOL> from salttesting . helpers import ensure_in_syspath <EOL> ensure_in_syspath ( '<STR_LIT>' ) <EOL> from salt . states import mysql_grants <EOL> mysql_grants . __salt__ = { } <EOL> mysql_grants . __opts__ = { } <EOL> @ skipIf ( NO_MOCK , NO_MOCK_REASON ) <EOL> class MysqlGrantsTestCase ( TestCase ) : <EOL> '''<STR_LIT>''' <EOL> def test_present ( self ) : <EOL> '''<STR_LIT>''' <EOL> name = '<STR_LIT>' <EOL> ret = { '<STR_LIT:name>' : name , <EOL> '<STR_LIT:result>' : True , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { } } <EOL> mock = MagicMock ( side_effect = [ True , False , False , False ] ) <EOL> mock_t = MagicMock ( return_value = True ) <EOL> mock_str = MagicMock ( return_value = '<STR_LIT>' ) <EOL> mock_none = MagicMock ( return_value = None ) <EOL> with patch . dict ( mysql_grants . __salt__ , { '<STR_LIT>' : mock , <EOL> '<STR_LIT>' : mock_t } ) : <EOL> comt = ( '<STR_LIT>' ) <EOL>", "answer": "ret . update ( { '<STR_LIT>' : comt } )"}, {"prompt": "<s> from django . test import TestCase <EOL> from django . test . client import Client , MULTIPART_CONTENT <EOL> from django . core . urlresolvers import reverse <EOL> from django . contrib . auth . models import User <EOL> import json <EOL> from decimal import Decimal <EOL> import base64 <EOL> import warnings <EOL> import six <EOL> from . models import * <EOL> from restless . models import serialize , flatten <EOL> try : <EOL> from urllib . parse import urlencode <EOL> except ImportError : <EOL> from urllib import urlencode <EOL> class TestClient ( Client ) : <EOL> @ staticmethod <EOL> def process ( response ) : <EOL> try : <EOL> raw_data = response . content . decode ( '<STR_LIT:utf-8>' ) <EOL> response . json = json . loads ( response . content . decode ( '<STR_LIT:utf-8>' ) ) <EOL> except : <EOL> response . json = None <EOL> finally : <EOL> return response <EOL> def get ( self , url_name , data = { } , follow = False , extra = { } , * args , ** kwargs ) : <EOL> return self . process ( <EOL> super ( TestClient , self ) . get ( <EOL> reverse ( url_name , args = args , kwargs = kwargs ) , <EOL> data = data , <EOL> follow = follow , <EOL> ** extra ) ) <EOL> def post ( self , url_name , data = { } , content_type = MULTIPART_CONTENT , <EOL> follow = False , extra = { } , * args , ** kwargs ) : <EOL> return self . process ( <EOL> super ( TestClient , self ) . post ( <EOL> reverse ( url_name , args = args , kwargs = kwargs ) , <EOL> content_type = content_type , <EOL> data = data , <EOL> follow = follow , <EOL> ** extra ) ) <EOL> def put ( self , url_name , data = { } , content_type = MULTIPART_CONTENT , <EOL> follow = False , * args , ** kwargs ) : <EOL> return self . process ( <EOL> super ( TestClient , self ) . put ( <EOL> reverse ( url_name , args = args , kwargs = kwargs ) , <EOL> content_type = content_type , data = data , follow = follow ) ) <EOL> def delete ( self , url_name , data = { } , content_type = MULTIPART_CONTENT , <EOL> follow = False , * args , ** kwargs ) : <EOL> return self . process ( <EOL> super ( TestClient , self ) . delete ( <EOL> reverse ( url_name , args = args , kwargs = kwargs ) , <EOL> content_type = content_type , data = data , follow = follow ) ) <EOL> class TestSerialization ( TestCase ) : <EOL> def setUp ( self ) : <EOL> self . author = Author . objects . create ( name = '<STR_LIT>' ) <EOL> self . publisher = Publisher . objects . create ( name = '<STR_LIT>' ) <EOL> self . books = [ ] <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> b = self . author . books . create ( author = self . author , <EOL> title = '<STR_LIT>' % i , <EOL> isbn = '<STR_LIT>' % i , <EOL> price = Decimal ( \"<STR_LIT>\" ) , <EOL> publisher = self . publisher ) <EOL> self . books . append ( b ) <EOL> def test_full_shallow ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> s = serialize ( self . author ) <EOL> self . assertEqual ( s , { '<STR_LIT:name>' : '<STR_LIT>' , '<STR_LIT:id>' : self . author . id } ) <EOL> def test_partial_shallow ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> s = serialize ( self . author , [ '<STR_LIT:name>' ] ) <EOL> self . assertEqual ( s , { '<STR_LIT:name>' : '<STR_LIT>' } ) <EOL> def test_shallow_foreign_key_serialization ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> s = serialize ( self . books [ <NUM_LIT:0> ] ) <EOL> self . assertEqual ( s [ '<STR_LIT>' ] , self . author . id ) <EOL> def test_serialize_related_deprecated ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with warnings . catch_warnings ( record = True ) : <EOL> s = serialize ( self . author , related = { '<STR_LIT>' : None } ) <EOL> self . assertEqual ( s [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( len ( s [ '<STR_LIT>' ] ) , len ( self . books ) ) <EOL> for b in s [ '<STR_LIT>' ] : <EOL> self . assertTrue ( b [ '<STR_LIT:title>' ] . startswith ( '<STR_LIT>' ) ) <EOL> self . assertTrue ( b [ '<STR_LIT>' ] . startswith ( '<STR_LIT>' ) ) <EOL> def test_serialize_related ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> s = serialize ( self . author , include = [ ( '<STR_LIT>' , dict ( ) ) ] ) <EOL> self . assertEqual ( s [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( len ( s [ '<STR_LIT>' ] ) , len ( self . books ) ) <EOL> for b in s [ '<STR_LIT>' ] : <EOL> self . assertTrue ( b [ '<STR_LIT:title>' ] . startswith ( '<STR_LIT>' ) ) <EOL> self . assertTrue ( b [ '<STR_LIT>' ] . startswith ( '<STR_LIT>' ) ) <EOL> def test_serialize_related_partial_deprecated ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with warnings . catch_warnings ( record = True ) : <EOL> s = serialize ( self . author , related = { <EOL> '<STR_LIT>' : ( '<STR_LIT:title>' , None , False ) <EOL> } ) <EOL> self . assertEqual ( s [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( len ( s [ '<STR_LIT>' ] ) , len ( self . books ) ) <EOL> for b in s [ '<STR_LIT>' ] : <EOL> self . assertTrue ( b [ '<STR_LIT:title>' ] . startswith ( '<STR_LIT>' ) ) <EOL> self . assertTrue ( '<STR_LIT>' not in b ) <EOL> def test_serialize_related_partial ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> s = serialize ( self . author , include = [ <EOL> ( '<STR_LIT>' , dict ( <EOL> fields = [ '<STR_LIT:title>' ] <EOL> ) ) <EOL> ] ) <EOL> self . assertEqual ( s [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( len ( s [ '<STR_LIT>' ] ) , len ( self . books ) ) <EOL> for b in s [ '<STR_LIT>' ] : <EOL> self . assertTrue ( b [ '<STR_LIT:title>' ] . startswith ( '<STR_LIT>' ) ) <EOL> self . assertTrue ( '<STR_LIT>' not in b ) <EOL> def test_serialize_related_deep_deprecated ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with warnings . catch_warnings ( record = True ) : <EOL> s = serialize ( self . author , related = { <EOL> '<STR_LIT>' : ( None , { <EOL> '<STR_LIT>' : None , <EOL> } , None ) } ) <EOL> self . assertEqual ( s [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( len ( s [ '<STR_LIT>' ] ) , len ( self . books ) ) <EOL> for b in s [ '<STR_LIT>' ] : <EOL> self . assertTrue ( b [ '<STR_LIT:title>' ] . startswith ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( b [ '<STR_LIT>' ] [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> def test_serialize_related_deep ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> s = serialize ( self . author , include = [ <EOL> ( '<STR_LIT>' , dict ( <EOL> include = [ ( '<STR_LIT>' , dict ( ) ) ] <EOL> ) ) <EOL> ] ) <EOL> self . assertEqual ( s [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( len ( s [ '<STR_LIT>' ] ) , len ( self . books ) ) <EOL> for b in s [ '<STR_LIT>' ] : <EOL> self . assertTrue ( b [ '<STR_LIT:title>' ] . startswith ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( b [ '<STR_LIT>' ] [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> def test_serialize_related_flatten_deprecated ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> b = self . books [ <NUM_LIT:0> ] <EOL> s = serialize ( b , related = { <EOL> '<STR_LIT>' : ( None , None , True ) <EOL> } ) <EOL> self . assertEqual ( s [ '<STR_LIT:name>' ] , b . author . name ) <EOL> def test_serialize_related_flatten ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> b = self . books [ <NUM_LIT:0> ] <EOL> s = serialize ( b , fields = [ <EOL> ( '<STR_LIT>' , dict ( ) ) <EOL> ] , fixup = flatten ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( s [ '<STR_LIT:name>' ] , b . author . name ) <EOL> def test_serialize_queryset ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Author . objects . all ( ) . delete ( ) <EOL> a1 = Author . objects . create ( name = \"<STR_LIT:foo>\" ) <EOL> a2 = Author . objects . create ( name = \"<STR_LIT:bar>\" ) <EOL> qs = Author . objects . all ( ) <EOL> _ = list ( qs ) <EOL> with self . assertNumQueries ( <NUM_LIT:0> ) : <EOL> s = serialize ( qs ) <EOL> self . assertEqual ( s , <EOL> [ <EOL> { '<STR_LIT:name>' : a1 . name , '<STR_LIT:id>' : a1 . id } , <EOL> { '<STR_LIT:name>' : a2 . name , '<STR_LIT:id>' : a2 . id } , <EOL> ] <EOL> ) <EOL> def test_serialize_list ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Author . objects . all ( ) . delete ( ) <EOL> a1 = Author . objects . create ( name = \"<STR_LIT:foo>\" ) <EOL> a2 = Author . objects . create ( name = \"<STR_LIT:bar>\" ) <EOL> s = serialize ( list ( Author . objects . all ( ) ) ) <EOL> self . assertEqual ( s , <EOL> [ <EOL> { '<STR_LIT:name>' : a1 . name , '<STR_LIT:id>' : a1 . id } , <EOL> { '<STR_LIT:name>' : a2 . name , '<STR_LIT:id>' : a2 . id } , <EOL> ] <EOL> ) <EOL> def test_serialize_dict ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Author . objects . all ( ) . delete ( ) <EOL> a1 = Author . objects . create ( name = \"<STR_LIT:foo>\" ) <EOL> a2 = Author . objects . create ( name = \"<STR_LIT:bar>\" ) <EOL> s = serialize ( { '<STR_LIT>' : a1 , '<STR_LIT>' : a2 } ) <EOL> self . assertEqual ( s [ '<STR_LIT>' ] [ '<STR_LIT:name>' ] , a1 . name ) <EOL> self . assertEqual ( s [ '<STR_LIT>' ] [ '<STR_LIT:name>' ] , a2 . name ) <EOL> def test_serialize_set ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Author . objects . all ( ) . delete ( ) <EOL> a1 = Author . objects . create ( name = \"<STR_LIT:bar>\" ) <EOL> a2 = Author . objects . create ( name = \"<STR_LIT:foo>\" ) <EOL> s = serialize ( set ( Author . objects . all ( ) ) ) <EOL> self . assertTrue ( isinstance ( s , list ) ) <EOL> self . assertEqual ( sorted ( s , key = lambda el : el [ '<STR_LIT:name>' ] ) , <EOL> [ <EOL> { '<STR_LIT:name>' : a1 . name , '<STR_LIT:id>' : a1 . id } , <EOL> { '<STR_LIT:name>' : a2 . name , '<STR_LIT:id>' : a2 . id } , <EOL> ] <EOL> ) <EOL> def test_passthrough ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> data = { '<STR_LIT:a>' : [ '<STR_LIT:b>' , '<STR_LIT:c>' ] , '<STR_LIT:d>' : <NUM_LIT:1> , '<STR_LIT:e>' : \"<STR_LIT:foo>\" } <EOL> self . assertEqual ( data , serialize ( data ) ) <EOL> def test_serialize_takes_fields_tuple ( self ) : <EOL> s = serialize ( self . author , fields = ( '<STR_LIT:id>' , ) , include = ( '<STR_LIT:name>' , ) ) <EOL> self . assertEqual ( s , { <EOL> '<STR_LIT:id>' : self . author . id , <EOL> '<STR_LIT:name>' : self . author . name <EOL> } ) <EOL> def test_serialize_doesnt_mutate_fields ( self ) : <EOL> runs = [ <NUM_LIT:0> ] <EOL> def accessor ( obj ) : <EOL> runs [ <NUM_LIT:0> ] += <NUM_LIT:1> <EOL> return '<STR_LIT:foo>' <EOL> serialize ( [ self . author , self . author ] , fields = [ '<STR_LIT:id>' ] , <EOL> include = [ ( '<STR_LIT>' , accessor ) ] ) <EOL> self . assertEqual ( runs [ <NUM_LIT:0> ] , <NUM_LIT:2> ) <EOL> class TestEndpoint ( TestCase ) : <EOL> def setUp ( self ) : <EOL> self . client = TestClient ( ) <EOL> self . author = Author . objects . create ( name = '<STR_LIT>' ) <EOL> def test_author_list ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . client . get ( '<STR_LIT>' ) <EOL> self . assertEqual ( r . status_code , <NUM_LIT:200> ) <EOL> self . assertEqual ( len ( r . json ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( r . json [ <NUM_LIT:0> ] [ '<STR_LIT:id>' ] , self . author . id ) <EOL> def test_author_details ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . client . get ( '<STR_LIT>' , author_id = self . author . id ) <EOL> self . assertEqual ( r . status_code , <NUM_LIT:200> ) <EOL> self . assertEqual ( r . json [ '<STR_LIT:id>' ] , self . author . id ) <EOL> self . assertEqual ( r . json [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> def test_author_details_not_found ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . client . get ( '<STR_LIT>' , author_id = self . author . id + <NUM_LIT> ) <EOL> self . assertEqual ( r . status_code , <NUM_LIT> ) <EOL> def test_author_details_invalid_method ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . client . post ( '<STR_LIT>' , author_id = self . author . id ) <EOL> self . assertEqual ( r . status_code , <NUM_LIT> ) <EOL> def test_create_author_form_encoded ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . client . post ( '<STR_LIT>' , data = urlencode ( { <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> } ) , content_type = '<STR_LIT>' ) <EOL> self . assertEqual ( r . status_code , <NUM_LIT> ) <EOL> self . assertEqual ( r . json [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( r . json [ '<STR_LIT:name>' ] , <EOL> Author . objects . get ( id = r . json [ '<STR_LIT:id>' ] ) . name ) <EOL> def test_create_author_multipart ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . client . post ( '<STR_LIT>' , data = { <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> } ) <EOL> self . assertEqual ( r . status_code , <NUM_LIT> ) <EOL> self . assertEqual ( r . json [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( r . json [ '<STR_LIT:name>' ] , <EOL> Author . objects . get ( id = r . json [ '<STR_LIT:id>' ] ) . name ) <EOL> def test_create_author_json ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . client . post ( '<STR_LIT>' , data = json . dumps ( { <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> } ) , content_type = '<STR_LIT>' ) <EOL> self . assertEqual ( r . status_code , <NUM_LIT> ) <EOL> self . assertEqual ( r . json [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( r . json [ '<STR_LIT:name>' ] , <EOL> Author . objects . get ( id = r . json [ '<STR_LIT:id>' ] ) . name ) <EOL> def test_invalid_json_payload ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . client . post ( '<STR_LIT>' , data = '<STR_LIT>' , <EOL> content_type = '<STR_LIT:application/json>' ) <EOL> self . assertEqual ( r . status_code , <NUM_LIT> ) <EOL> def test_delete_author ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . client . delete ( '<STR_LIT>' , author_id = self . author . id ) <EOL> self . assertEqual ( r . status_code , <NUM_LIT:200> ) <EOL> self . assertEqual ( Author . objects . count ( ) , <NUM_LIT:0> ) <EOL> def test_change_author ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . client . put ( '<STR_LIT>' , data = json . dumps ( { <EOL> '<STR_LIT:name>' : '<STR_LIT>' <EOL> } ) , author_id = self . author . id , content_type = '<STR_LIT:application/json>' ) <EOL> self . assertEqual ( r . status_code , <NUM_LIT:200> ) <EOL> self . assertEqual ( r . json [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( r . json [ '<STR_LIT:name>' ] , <EOL> Author . objects . get ( id = r . json [ '<STR_LIT:id>' ] ) . name ) <EOL> def test_view_failure ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with self . settings ( DEBUG = True ) : <EOL> r = self . client . get ( '<STR_LIT>' ) <EOL> self . assertEqual ( r . status_code , <NUM_LIT> ) <EOL> self . assertEqual ( r . json [ '<STR_LIT:error>' ] , \"<STR_LIT>\" ) <EOL> self . assertTrue ( '<STR_LIT>' in r . json ) <EOL> def test_raw_request_body ( self ) : <EOL> raw = b'<STR_LIT>' <EOL> r = self . client . post ( '<STR_LIT>' , data = raw , <EOL> content_type = '<STR_LIT>' ) <EOL> self . assertEqual ( base64 . b64decode ( r . json [ '<STR_LIT>' ] . encode ( '<STR_LIT:ascii>' ) ) , <EOL> raw ) <EOL> def test_get_payload_is_ignored ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = self . client . get ( '<STR_LIT>' , extra = { <EOL> '<STR_LIT>' : '<STR_LIT:application/json>' } ) <EOL> self . assertEqual ( r . status_code , <NUM_LIT:200> ) <EOL> def test_raising_http_error_returns_it ( self ) : <EOL> r = self . client . get ( '<STR_LIT>' ) <EOL> self . assertEqual ( r . status_code , <NUM_LIT> ) <EOL> class TestAuth ( TestCase ) : <EOL>", "answer": "def setUp ( self ) :"}, {"prompt": "<s> from django import template <EOL> from data_exports . compat import text_type <EOL> register = template . Library ( ) <EOL> @ register . filter ( ) <EOL> def getattribute ( model , item ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> elements = item . split ( '<STR_LIT:.>' ) <EOL> element = elements . pop ( <NUM_LIT:0> ) <EOL> try : <EOL> attr = getattr ( model , element , None ) <EOL> except : <EOL> return <EOL> if attr is None : <EOL> return <EOL>", "answer": "if callable ( attr ) :"}, {"prompt": "<s> def load ( ) : <EOL> '''<STR_LIT>''' <EOL> import numpy as np <EOL> from scipy import sparse <EOL> from os import path <EOL> if not path . exists ( '<STR_LIT>' ) : <EOL> raise IOError ( \"<STR_LIT>\" ) <EOL> data = np . loadtxt ( '<STR_LIT>' ) <EOL> ij = data [ : , : <NUM_LIT:2> ] <EOL> ij -= <NUM_LIT:1> <EOL> values = data [ : , <NUM_LIT:2> ] <EOL> reviews = sparse . csc_matrix ( ( values , ij . T ) ) . astype ( float ) <EOL> return reviews . toarray ( ) <EOL> def get_train_test ( reviews = None , random_state = None ) : <EOL> '''<STR_LIT>''' <EOL> import numpy as np <EOL> import random <EOL> r = random . Random ( random_state ) <EOL> if reviews is None : <EOL>", "answer": "reviews = load ( )"}, {"prompt": "<s> from . version import version as _version <EOL>", "answer": "__version__ = _version "}, {"prompt": "<s> import os <EOL> from distutils . command . install import INSTALL_SCHEMES <EOL> for scheme in INSTALL_SCHEMES . values ( ) : <EOL> scheme [ '<STR_LIT:data>' ] = scheme [ '<STR_LIT>' ] <EOL> from distutils . core import setup , Extension <EOL> setsc = Extension ( \"<STR_LIT>\" , <EOL> [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ] <EOL> ) <EOL> heapyc = Extension ( \"<STR_LIT>\" , <EOL> [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> ) <EOL> def doit ( ) : <EOL> setup ( name = \"<STR_LIT>\" , <EOL> version = \"<STR_LIT>\" , <EOL>", "answer": "description = \"<STR_LIT>\" ,"}, {"prompt": "<s> import copy <EOL> from cloudferry . lib . base . action import action <EOL> from cloudferry . lib . copy_engines import ssh_ceph_to_ceph <EOL> from cloudferry . lib . os . actions import snap_transfer <EOL> from cloudferry . lib . os . actions import task_transfer <EOL> from cloudferry . lib . utils import rbd_util <EOL> from cloudferry . lib . utils import utils as utl <EOL> OLD_ID = '<STR_LIT>' <EOL> class DeployVolSnapshots ( action . Action ) : <EOL> def run ( self , storage_info = None , identity_info = None , ** kwargs ) : <EOL> storage_info = copy . deepcopy ( storage_info ) <EOL> deploy_info = copy . deepcopy ( storage_info ) <EOL> deploy_info . update ( identity_info ) <EOL> storage_info . update ( identity_info ) <EOL> volume_resource = self . cloud . resources [ utl . STORAGE_RESOURCE ] <EOL> for vol_id , vol in deploy_info [ utl . VOLUMES_TYPE ] . iteritems ( ) : <EOL> if vol [ '<STR_LIT>' ] : <EOL> vol_info = vol [ utl . VOLUME_BODY ] <EOL> snapshots_list = [ snap_info for snap_info in vol [ '<STR_LIT>' ] . values ( ) ] <EOL> snapshots_list . sort ( key = lambda x : x [ '<STR_LIT>' ] ) <EOL> for snap in snapshots_list : <EOL> if snapshots_list . index ( snap ) == <NUM_LIT:0> : <EOL> act_snap_transfer = snap_transfer . SnapTransfer ( <EOL> self . init , <EOL> ssh_ceph_to_ceph . SSHCephToCeph , <EOL> <NUM_LIT:1> ) <EOL> else : <EOL> snap_num = snapshots_list . index ( snap ) <EOL> snap [ '<STR_LIT>' ] = snapshots_list [ snap_num - <NUM_LIT:1> ] [ '<STR_LIT:name>' ] <EOL> act_snap_transfer = snap_transfer . SnapTransfer ( <EOL> self . init , <EOL> ssh_ceph_to_ceph . SSHCephToCeph , <EOL> <NUM_LIT:2> ) <EOL> act_snap_transfer . run ( volume = vol_info , snapshot_info = snap ) <EOL> volume_resource . create_snapshot ( <EOL> volume_id = vol_id , <EOL> display_name = snap [ '<STR_LIT>' ] , <EOL> display_description = snap [ '<STR_LIT>' ] ) <EOL> act_snap_transfer = snap_transfer . SnapTransfer ( <EOL> self . init , <EOL> ssh_ceph_to_ceph . SSHCephToCeph , <EOL> <NUM_LIT:3> ) <EOL> act_snap_transfer . run ( volume = vol_info , <EOL> snapshot_info = snapshots_list [ - <NUM_LIT:1> ] ) <EOL> for snap in snapshots_list : <EOL> if volume_resource . config . storage . host : <EOL> act_delete_redundant_snap = rbd_util . RbdUtil ( cloud = self . cloud , <EOL>", "answer": "config_migrate = self . cfg . migrate ,"}, {"prompt": "<s> from thrift . Thrift import TProcessor , TMessageType , TException <EOL> from thrift . protocol import TProtocolDecorator , TMultiplexedProtocol <EOL> class TMultiplexedProcessor ( TProcessor ) : <EOL> def __init__ ( self ) : <EOL> self . services = { } <EOL> def registerProcessor ( self , serviceName , processor ) : <EOL> self . services [ serviceName ] = processor <EOL> def process ( self , iprot , oprot ) : <EOL> ( name , type , seqid ) = iprot . readMessageBegin ( ) ; <EOL> if type != TMessageType . CALL & type != TMessageType . ONEWAY : <EOL> raise TException ( \"<STR_LIT>\" ) <EOL> index = name . find ( TMultiplexedProtocol . SEPARATOR ) <EOL> if index < <NUM_LIT:0> : <EOL> raise TException ( \"<STR_LIT>\" + name + \"<STR_LIT>\" ) <EOL> serviceName = name [ <NUM_LIT:0> : index ] <EOL> call = name [ index + len ( TMultiplexedProtocol . SEPARATOR ) : ] <EOL> if not serviceName in self . services : <EOL> raise TException ( \"<STR_LIT>\" + serviceName + \"<STR_LIT>\" ) <EOL> standardMessage = ( <EOL> call , <EOL> type , <EOL> seqid <EOL> ) <EOL> return self . services [ serviceName ] . process ( StoredMessageProtocol ( iprot , standardMessage ) , oprot ) <EOL> class StoredMessageProtocol ( TProtocolDecorator . TProtocolDecorator ) : <EOL>", "answer": "def __init__ ( self , protocol , messageBegin ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re , codecs <EOL> from mako import parsetree , exceptions , util <EOL> from mako . pygen import adjust_whitespace <EOL> _regexp_cache = { } <EOL> class Lexer ( object ) : <EOL> def __init__ ( self , text , filename = None , <EOL> disable_unicode = False , <EOL> input_encoding = None , preprocessor = None ) : <EOL> self . text = text <EOL> self . filename = filename <EOL> self . template = parsetree . TemplateNode ( self . filename ) <EOL> self . matched_lineno = <NUM_LIT:1> <EOL> self . matched_charpos = <NUM_LIT:0> <EOL> self . lineno = <NUM_LIT:1> <EOL> self . match_position = <NUM_LIT:0> <EOL> self . tag = [ ] <EOL> self . control_line = [ ] <EOL> self . disable_unicode = disable_unicode <EOL> self . encoding = input_encoding <EOL> if util . py3k and disable_unicode : <EOL> raise exceptions . UnsupportedError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> if preprocessor is None : <EOL> self . preprocessor = [ ] <EOL> elif not hasattr ( preprocessor , '<STR_LIT>' ) : <EOL> self . preprocessor = [ preprocessor ] <EOL> else : <EOL> self . preprocessor = preprocessor <EOL> @ property <EOL> def exception_kwargs ( self ) : <EOL> return { '<STR_LIT:source>' : self . text , <EOL> '<STR_LIT>' : self . matched_lineno , <EOL> '<STR_LIT>' : self . matched_charpos , <EOL> '<STR_LIT:filename>' : self . filename } <EOL> def match ( self , regexp , flags = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> reg = _regexp_cache [ ( regexp , flags ) ] <EOL> except KeyError : <EOL> if flags : <EOL> reg = re . compile ( regexp , flags ) <EOL> else : <EOL> reg = re . compile ( regexp ) <EOL> _regexp_cache [ ( regexp , flags ) ] = reg <EOL> return self . match_reg ( reg ) <EOL> def match_reg ( self , reg ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> mp = self . match_position <EOL> match = reg . match ( self . text , self . match_position ) <EOL> if match : <EOL> ( start , end ) = match . span ( ) <EOL> if end == start : <EOL> self . match_position = end + <NUM_LIT:1> <EOL> else : <EOL> self . match_position = end <EOL> self . matched_lineno = self . lineno <EOL> lines = re . findall ( r\"<STR_LIT:\\n>\" , self . text [ mp : self . match_position ] ) <EOL> cp = mp - <NUM_LIT:1> <EOL> while ( cp >= <NUM_LIT:0> and cp < self . textlength and self . text [ cp ] != '<STR_LIT:\\n>' ) : <EOL> cp -= <NUM_LIT:1> <EOL> self . matched_charpos = mp - cp <EOL> self . lineno += len ( lines ) <EOL> return match <EOL> def parse_until_text ( self , * text ) : <EOL> startpos = self . match_position <EOL>", "answer": "while True :"}, {"prompt": "<s> from UserDict import DictMixin <EOL> class OrderedDict ( dict , DictMixin ) : <EOL> def __init__ ( self , * args , ** kwds ) : <EOL> if len ( args ) > <NUM_LIT:1> : <EOL> raise TypeError ( '<STR_LIT>' % len ( args ) ) <EOL> try : <EOL> self . __end <EOL> except AttributeError : <EOL> self . clear ( ) <EOL> self . update ( * args , ** kwds ) <EOL> def clear ( self ) : <EOL> self . __end = end = [ ] <EOL> end += [ None , end , end ] <EOL> self . __map = { } <EOL> dict . clear ( self ) <EOL> def __setitem__ ( self , key , value ) : <EOL> if key not in self : <EOL> end = self . __end <EOL> curr = end [ <NUM_LIT:1> ] <EOL> curr [ <NUM_LIT:2> ] = end [ <NUM_LIT:1> ] = self . __map [ key ] = [ key , curr , end ] <EOL> dict . __setitem__ ( self , key , value ) <EOL> def __delitem__ ( self , key ) : <EOL> dict . __delitem__ ( self , key ) <EOL> key , prev , next = self . __map . pop ( key ) <EOL> prev [ <NUM_LIT:2> ] = next <EOL> next [ <NUM_LIT:1> ] = prev <EOL> def __iter__ ( self ) : <EOL> end = self . __end <EOL> curr = end [ <NUM_LIT:2> ] <EOL> while curr is not end : <EOL> yield curr [ <NUM_LIT:0> ] <EOL> curr = curr [ <NUM_LIT:2> ] <EOL> def __reversed__ ( self ) : <EOL> end = self . __end <EOL> curr = end [ <NUM_LIT:1> ] <EOL> while curr is not end : <EOL> yield curr [ <NUM_LIT:0> ] <EOL> curr = curr [ <NUM_LIT:1> ] <EOL> def popitem ( self , last = True ) : <EOL> if not self : <EOL> raise KeyError ( '<STR_LIT>' ) <EOL> if last : <EOL> key = next ( reversed ( self ) ) <EOL> else : <EOL>", "answer": "key = next ( iter ( self ) )"}, {"prompt": "<s> from thespian . actors import ActorSystemMessage <EOL> class EndpointConnected ( ActorSystemMessage ) : <EOL> def __init__ ( self , childInstance ) : <EOL>", "answer": "self . childInstance = childInstance"}, {"prompt": "<s> from . import applicationcfc <EOL> from . import basecompletions <EOL> from . import cfdocs <EOL>", "answer": "from . import fw1"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import re <EOL> import json <EOL> import base64 <EOL> import logging <EOL> from sqlalchemy import desc , asc <EOL> from collections import defaultdict <EOL> from framework . dependency_management . dependency_resolver import BaseComponent <EOL> from framework . dependency_management . interfaces import TransactionInterface <EOL> from framework . db . target_manager import target_required <EOL> from framework . lib . exceptions import InvalidTransactionReference , InvalidParameterType <EOL> from framework . http import transaction <EOL> from framework . db import models <EOL> REGEX_TYPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> class TransactionManager ( BaseComponent , TransactionInterface ) : <EOL> COMPONENT_NAME = \"<STR_LIT>\" <EOL> def __init__ ( self ) : <EOL> self . register_in_service_locator ( ) <EOL> self . config = self . get_component ( \"<STR_LIT>\" ) <EOL> self . db = self . get_component ( \"<STR_LIT>\" ) <EOL> self . target = self . get_component ( \"<STR_LIT:target>\" ) <EOL> self . url_manager = self . get_component ( \"<STR_LIT>\" ) <EOL> self . zest = self . get_component ( \"<STR_LIT>\" ) <EOL> self . regexs = defaultdict ( list ) <EOL> for regex_type in REGEX_TYPES : <EOL> self . regexs [ regex_type ] = { } <EOL> self . CompileRegexs ( ) <EOL> @ target_required <EOL> def NumTransactions ( self , scope = True , target_id = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> count = self . db . session . query ( models . Transaction ) . filter_by ( <EOL> scope = scope , <EOL> target_id = target_id ) . count ( ) <EOL> return ( count ) <EOL> def IsTransactionAlreadyAdded ( self , criteria , target_id = None ) : <EOL> return ( len ( self . GetAll ( criteria , target_id = target_id ) ) > <NUM_LIT:0> ) <EOL> def GenerateQueryUsingSession ( self , criteria , target_id , for_stats = False ) : <EOL> query = self . db . session . query ( models . Transaction ) . filter_by ( <EOL> target_id = target_id ) <EOL> if criteria . get ( '<STR_LIT>' , None ) : <EOL> if criteria . get ( '<STR_LIT:url>' , None ) : <EOL> if isinstance ( criteria . get ( '<STR_LIT:url>' ) , list ) : <EOL> criteria [ '<STR_LIT:url>' ] = criteria [ '<STR_LIT:url>' ] [ <NUM_LIT:0> ] <EOL> query = query . filter ( models . Transaction . url . like ( <EOL> '<STR_LIT:%>' + criteria [ '<STR_LIT:url>' ] + '<STR_LIT:%>' ) ) <EOL> if criteria . get ( '<STR_LIT>' , None ) : <EOL> if isinstance ( criteria . get ( '<STR_LIT>' ) , list ) : <EOL> criteria [ '<STR_LIT>' ] = criteria [ '<STR_LIT>' ] [ <NUM_LIT:0> ] <EOL> query = query . filter ( models . Transaction . method . like ( <EOL> '<STR_LIT:%>' + criteria . get ( '<STR_LIT>' ) + '<STR_LIT:%>' ) ) <EOL> if criteria . get ( '<STR_LIT:data>' , None ) : <EOL> if isinstance ( criteria . get ( '<STR_LIT:data>' ) , list ) : <EOL> criteria [ '<STR_LIT:data>' ] = criteria [ '<STR_LIT:data>' ] [ <NUM_LIT:0> ] <EOL> query = query . filter ( models . Transaction . data . like ( <EOL> '<STR_LIT:%>' + criteria . get ( '<STR_LIT:data>' ) + '<STR_LIT:%>' ) ) <EOL> if criteria . get ( '<STR_LIT>' , None ) : <EOL> if isinstance ( criteria . get ( '<STR_LIT>' ) , list ) : <EOL> criteria [ '<STR_LIT>' ] = criteria [ '<STR_LIT>' ] [ <NUM_LIT:0> ] <EOL> query = query . filter ( models . Transaction . raw_request . like ( <EOL> '<STR_LIT:%>' + criteria . get ( '<STR_LIT>' ) + '<STR_LIT:%>' ) ) <EOL> if criteria . get ( '<STR_LIT>' , None ) : <EOL> if isinstance ( criteria . get ( '<STR_LIT>' ) , list ) : <EOL> criteria [ '<STR_LIT>' ] = criteria [ '<STR_LIT>' ] [ <NUM_LIT:0> ] <EOL> query = query . filter ( models . Transaction . response_status . like ( <EOL> '<STR_LIT:%>' + criteria . get ( '<STR_LIT>' ) + '<STR_LIT:%>' ) ) <EOL> if criteria . get ( '<STR_LIT>' , None ) : <EOL> if isinstance ( criteria . get ( '<STR_LIT>' ) , list ) : <EOL> criteria [ '<STR_LIT>' ] = criteria [ '<STR_LIT>' ] [ <NUM_LIT:0> ] <EOL>", "answer": "query = query . filter ( models . Transaction . response_headers . like ("}, {"prompt": "<s> from django . core . urlresolvers import reverse <EOL> from raspberryio . project . tests . base import RaspberryIOBaseTestCase <EOL> class UserProfileFormTestCase ( RaspberryIOBaseTestCase ) : <EOL> url_name = \"<STR_LIT>\" <EOL> def setUp ( self ) : <EOL>", "answer": "self . user = self . create_user ( data = { '<STR_LIT:username>' : '<STR_LIT:test>' , '<STR_LIT:password>' : '<STR_LIT>' } )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import wx <EOL> from wx . grid import PyGridCellEditor <EOL> from wx import SIZE_ALLOW_MINUS_ONE <EOL> from traitsui . api import UI , default_handler <EOL> from combobox_focus_handler import ComboboxFocusHandler <EOL> wx_28 = ( float ( wx . __version__ [ : <NUM_LIT:3> ] ) >= <NUM_LIT> ) <EOL> def get_control ( control ) : <EOL> if isinstance ( control , wx . Control ) : <EOL> return control <EOL> for control in control . GetChildren ( ) : <EOL> result = get_control ( control ) <EOL> if result is not None : <EOL> return result <EOL> return None <EOL> def push_control ( control , grid ) : <EOL> control . PushEventHandler ( ComboboxFocusHandler ( grid ) ) <EOL> for child_control in control . GetChildren ( ) : <EOL> push_control ( child_control , grid ) <EOL> class TraitGridCellAdapter ( PyGridCellEditor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , trait_editor_factory , obj , name , description , <EOL> handler = None , context = None , style = '<STR_LIT>' , <EOL> width = - <NUM_LIT:1.0> , height = - <NUM_LIT:1.0> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> PyGridCellEditor . __init__ ( self ) <EOL> self . _factory = trait_editor_factory <EOL> self . _style = style <EOL> self . _width = width <EOL> self . _height = height <EOL> self . _editor = None <EOL> self . _obj = obj <EOL> self . _name = name <EOL> self . _description = description <EOL> self . _handler = handler <EOL> self . _context = context <EOL> def Create ( self , parent , id , evtHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if hasattr ( self , '<STR_LIT>' ) : <EOL> return <EOL> handler = self . _handler <EOL> if handler is None : <EOL> handler = default_handler ( ) <EOL> if self . _context is None : <EOL> ui = UI ( handler = handler ) <EOL> else : <EOL> context = self . _context . copy ( ) <EOL> context [ '<STR_LIT>' ] = context [ '<STR_LIT:object>' ] <EOL> context [ '<STR_LIT:object>' ] = self . _obj <EOL> ui = UI ( handler = handler , context = context ) <EOL> factory = self . _factory <EOL> if factory . _ui is not None : <EOL> ui . history = factory . _ui . history <EOL> factory . is_grid_cell = True <EOL> factory_method = getattr ( factory , self . _style + '<STR_LIT>' ) <EOL> self . _editor = factory_method ( ui , <EOL> self . _obj , <EOL> self . _name , <EOL> self . _description , <EOL> parent ) <EOL> self . _editor . prepare ( parent ) <EOL> self . _control = control = self . _editor . control <EOL> grid , row , col = getattr ( self , '<STR_LIT>' , ( None , None , None ) ) <EOL> width , height = control . GetBestSize ( ) <EOL> self_height = self . _height <EOL> if self_height > <NUM_LIT:1.0> : <EOL> height = int ( self_height ) <EOL> elif ( self_height >= <NUM_LIT:0.0> ) and ( grid is not None ) : <EOL> height = int ( self_height * grid . GetSize ( ) [ <NUM_LIT:1> ] ) <EOL> self_width = self . _width <EOL> if self_width > <NUM_LIT:1.0> : <EOL> width = int ( self_width ) <EOL> elif ( self_width >= <NUM_LIT:0.0> ) and ( grid is not None ) : <EOL> width = int ( self_width * grid . GetSize ( ) [ <NUM_LIT:0> ] ) <EOL> self . _edit_width , self . _edit_height = width , height <EOL> push_control ( control , grid ) <EOL> control = get_control ( control ) <EOL> if control is not None : <EOL> self . SetControl ( control ) <EOL> def SetSize ( self , rect ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> changed = False <EOL> edit_width , edit_height = rect . width , rect . height <EOL> grid , row , col = getattr ( self , '<STR_LIT>' , ( None , None , None ) ) <EOL> if ( grid is not None ) and self . _editor . scrollable : <EOL> edit_width , cur_width = self . _edit_width , grid . GetColSize ( col ) <EOL> restore_width = getattr ( grid , '<STR_LIT>' , None ) <EOL> if restore_width is not None : <EOL> cur_width = restore_width <EOL> if ( edit_width > cur_width ) or ( restore_width is not None ) : <EOL> edit_width = max ( edit_width , cur_width ) <EOL> grid . _restore_width = cur_width <EOL> grid . SetColSize ( col , edit_width + <NUM_LIT:1> + ( col == <NUM_LIT:0> ) ) <EOL> changed = True <EOL> else : <EOL> edit_width = cur_width <EOL> edit_height , cur_height = self . _edit_height , grid . GetRowSize ( row ) <EOL> restore_height = getattr ( grid , '<STR_LIT>' , None ) <EOL> if restore_height is not None : <EOL> cur_height = restore_height <EOL> if ( edit_height > cur_height ) or ( restore_height is not None ) : <EOL> edit_height = max ( edit_height , cur_height ) <EOL> grid . _restore_height = cur_height <EOL> grid . SetRowSize ( row , edit_height + <NUM_LIT:1> + ( row == <NUM_LIT:0> ) ) <EOL> changed = True <EOL> else : <EOL> edit_height = cur_height <EOL> if changed : <EOL> grid . ForceRefresh ( ) <EOL> self . _control . SetDimensions ( rect . x + <NUM_LIT:1> , rect . y + <NUM_LIT:1> , <EOL> edit_width , edit_height , <EOL> SIZE_ALLOW_MINUS_ONE ) <EOL> if changed : <EOL> grid . MakeCellVisible ( grid . GetGridCursorRow ( ) , <EOL> grid . GetGridCursorCol ( ) ) <EOL> def Show ( self , show , attr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . IsCreated ( ) : <EOL> if wx_28 : <EOL> super ( TraitGridCellAdapter , self ) . Show ( show , attr ) <EOL> else : <EOL> self . base_Show ( show , attr ) <EOL> return <EOL> def PaintBackground ( self , rect , attr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return <EOL> def BeginEdit ( self , row , col , grid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _editor . update_editor ( ) <EOL> control = self . _control <EOL> control . Show ( True ) <EOL> control . SetFocus ( ) <EOL> if isinstance ( control , wx . TextCtrl ) : <EOL> control . SetSelection ( - <NUM_LIT:1> , - <NUM_LIT:1> ) <EOL> def EndEdit ( self , row , col , grid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _control . Show ( False ) <EOL> changed = False <EOL> grid , row , col = self . _grid_info <EOL> if grid . _no_reset_col : <EOL> grid . _no_reset_col = False <EOL> else : <EOL> width = getattr ( grid , '<STR_LIT>' , None ) <EOL> if width is not None : <EOL> del grid . _restore_width <EOL> grid . SetColSize ( col , width ) <EOL> changed = True <EOL> if grid . _no_reset_row : <EOL> grid . _no_reset_row = False <EOL> else : <EOL> height = getattr ( grid , '<STR_LIT>' , None ) <EOL> if height is not None : <EOL> del grid . _restore_height <EOL> grid . SetRowSize ( row , height ) <EOL> changed = True <EOL> if changed : <EOL> grid . ForceRefresh ( ) <EOL> def Reset ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return <EOL> def StartingKey ( self , evt ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return <EOL> def StartingClick ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return <EOL> def Destroy ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _editor . dispose ( ) <EOL> return <EOL> def Clone ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return TraitGridCellAdapter ( self . _factory , self . _obj , self . _name , <EOL> self . _description , style = self . _style ) <EOL> def dispose ( self ) : <EOL> if self . _editor is not None : <EOL>", "answer": "self . _editor . dispose ( ) "}, {"prompt": "<s> from msrest . paging import Paged <EOL>", "answer": "class TagDetailsPaged ( Paged ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from nltk . corpus import wordnet as wn <EOL> from nltk . corpus import wordnet_ic as wnic <EOL> from nltk . tokenize import word_tokenize <EOL> from utils import lemmatize <EOL> def similarity_by_path ( sense1 , sense2 , option = \"<STR_LIT:path>\" ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if option . lower ( ) in [ \"<STR_LIT:path>\" , \"<STR_LIT>\" ] : <EOL> return max ( wn . path_similarity ( sense1 , sense2 ) , <EOL> wn . path_similarity ( sense1 , sense2 ) ) <EOL> elif option . lower ( ) in [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> return wn . wup_similarity ( sense1 , sense2 ) <EOL> elif option . lower ( ) in [ '<STR_LIT>' , \"<STR_LIT>\" ] : <EOL> if sense1 . pos != sense2 . pos : <EOL> return <NUM_LIT:0> <EOL> return wn . lch_similarity ( sense1 , sense2 ) <EOL> def similarity_by_infocontent ( sense1 , sense2 , option ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if sense1 . pos != sense2 . pos : <EOL> return <NUM_LIT:0> <EOL> info_contents = [ '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] <EOL> if option in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return wn . res_similarity ( sense1 , sense2 , wnic . ic ( '<STR_LIT>' ) ) <EOL> elif option in [ '<STR_LIT>' , \"<STR_LIT>\" ] : <EOL> return wn . jcn_similarity ( sense1 , sense2 , wnic . ic ( '<STR_LIT>' ) ) <EOL> elif option in [ '<STR_LIT>' ] : <EOL> return wn . lin_similarity ( sense1 , sense2 , wnic . ic ( '<STR_LIT>' ) ) <EOL> def sim ( sense1 , sense2 , option = \"<STR_LIT:path>\" ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> option = option . lower ( ) <EOL> if option . lower ( ) in [ \"<STR_LIT:path>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> '<STR_LIT>' , \"<STR_LIT>\" ] : <EOL> return similarity_by_path ( sense1 , sense2 , option ) <EOL> elif option . lower ( ) in [ \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] : <EOL> return similarity_by_infocontent ( sense1 , sense2 , option ) <EOL> def max_similarity ( context_sentence , ambiguous_word , option = \"<STR_LIT:path>\" , <EOL> lemma = True , context_is_lemmatized = False , pos = None , best = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ambiguous_word = lemmatize ( ambiguous_word ) <EOL> if not wn . synsets ( ambiguous_word ) : <EOL> return None <EOL> if context_is_lemmatized : <EOL> context_sentence = word_tokenize ( context_sentence ) <EOL> else : <EOL> context_sentence = [ lemmatize ( w ) for w in word_tokenize ( context_sentence ) ] <EOL> result = { } <EOL> for i in wn . synsets ( ambiguous_word ) : <EOL> try : <EOL> if pos and pos != str ( i . pos ( ) ) : <EOL> continue <EOL> except : <EOL> if pos and pos != str ( i . pos ) : <EOL>", "answer": "continue"}, {"prompt": "<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> from abc import abstractmethod <EOL> from pants . util . meta import AbstractClass <EOL> from pants . util . objects import datatype <EOL> class Spec ( AbstractClass ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ abstractmethod <EOL> def to_spec_string ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class SingleAddress ( datatype ( '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT:name>' ] ) , Spec ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def to_spec_string ( self ) :"}, {"prompt": "<s> import numpy as np <EOL> import unittest <EOL> from SimPEG import * <EOL> from scipy . sparse . linalg import dsolve <EOL> TOL = <NUM_LIT> <EOL> MAPS_TO_TEST_2D = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> MAPS_TO_TEST_3D = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> class MapTests ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> a = np . array ( [ <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:1> ] ) <EOL> b = np . array ( [ <NUM_LIT:1> , <NUM_LIT:2> ] ) <EOL> self . mesh2 = Mesh . TensorMesh ( [ a , b ] , x0 = np . array ( [ <NUM_LIT:3> , <NUM_LIT:5> ] ) ) <EOL> self . mesh3 = Mesh . TensorMesh ( [ a , b , [ <NUM_LIT:3> , <NUM_LIT:4> ] ] , x0 = np . array ( [ <NUM_LIT:3> , <NUM_LIT:5> , <NUM_LIT:2> ] ) ) <EOL> self . mesh22 = Mesh . TensorMesh ( [ b , a ] , x0 = np . array ( [ <NUM_LIT:3> , <NUM_LIT:5> ] ) ) <EOL> def test_transforms2D ( self ) : <EOL> for M in MAPS_TO_TEST_2D : <EOL> maps = getattr ( Maps , M ) ( self . mesh2 ) <EOL> self . assertTrue ( maps . test ( ) ) <EOL> def test_transforms3D ( self ) : <EOL> for M in MAPS_TO_TEST_3D : <EOL> maps = getattr ( Maps , M ) ( self . mesh3 ) <EOL> self . assertTrue ( maps . test ( ) ) <EOL> def test_transforms_logMap_reciprocalMap ( self ) : <EOL> v2 = np . r_ [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> dv2 = np . r_ [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL>", "answer": "v3 = np . r_ [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ]"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from buildservice . models import OAuthToken , Webhook <EOL> def create_user_token ( user , repo = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> token = OAuthToken . objects . create ( user = user , value = '<STR_LIT>' ) <EOL> if repo : <EOL> Webhook . objects . create ( repository = repo ) <EOL>", "answer": "return token "}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import os , sys , time , optparse , datetime , math <EOL> try : <EOL> from core import pycore <EOL> except ImportError : <EOL> if \"<STR_LIT>\" in sys . path : <EOL> sys . path . append ( \"<STR_LIT>\" ) <EOL> if \"<STR_LIT>\" in sys . path : <EOL> sys . path . append ( \"<STR_LIT>\" ) <EOL> if \"<STR_LIT>\" in sys . path : <EOL> sys . path . append ( \"<STR_LIT>\" ) <EOL> if \"<STR_LIT>\" in sys . path : <EOL> sys . path . append ( \"<STR_LIT>\" ) <EOL> from core import pycore <EOL> from core . misc import ipaddr <EOL> from corens3 . obj import Ns3Session , Ns3LteNet <EOL> import ns . core <EOL> import ns . mobility <EOL> def ltesession ( opt ) : <EOL> '''<STR_LIT>''' <EOL> session = Ns3Session ( persistent = True , duration = opt . duration ) <EOL> lte = session . addobj ( cls = Ns3LteNet , name = \"<STR_LIT>\" ) <EOL> lte . setsubchannels ( range ( <NUM_LIT> ) , range ( <NUM_LIT:50> , <NUM_LIT:100> ) ) <EOL> if opt . verbose : <EOL> ascii = ns . network . AsciiTraceHelper ( ) <EOL> stream = ascii . CreateFileStream ( '<STR_LIT>' ) <EOL> lte . lte . EnableAsciiAll ( stream ) <EOL> prefix = ipaddr . IPv4Prefix ( \"<STR_LIT>\" ) <EOL> mobb = None <EOL> nodes = [ ] <EOL> for i in xrange ( <NUM_LIT:1> , opt . numnodes + <NUM_LIT:1> ) : <EOL>", "answer": "node = session . addnode ( name = \"<STR_LIT>\" % i )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __version__ = '<STR_LIT>' <EOL> from ircbot import SingleServerIRCBot <EOL> from irclib import nm_to_n , nm_to_h , irc_lower , ip_numstr_to_quad , ip_quad_to_numstr <EOL> import wikipedia <EOL> import re <EOL> class ArtNoDisp ( SingleServerIRCBot ) : <EOL> def __init__ ( self , site , channel , nickname , server , port = <NUM_LIT> ) : <EOL> SingleServerIRCBot . __init__ ( self , [ ( server , port ) ] , nickname , nickname ) <EOL> self . channel = channel <EOL> self . site = site <EOL> self . other_ns = re . compile ( u'<STR_LIT>' + u'<STR_LIT:|>' . join ( site . namespaces ( ) ) + u'<STR_LIT:)>' ) <EOL> self . api_url = self . site . api_address ( ) <EOL> self . api_url += '<STR_LIT>' <EOL> self . api_found = re . compile ( r'<STR_LIT>' ) <EOL> self . re_edit = re . compile ( r'<STR_LIT>' . replace ( '<STR_LIT>' , '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> def on_nicknameinuse ( self , c , e ) : <EOL> c . nick ( c . get_nickname ( ) + \"<STR_LIT:_>\" ) <EOL> def on_welcome ( self , c , e ) : <EOL> c . join ( self . channel ) <EOL> def on_privmsg ( self , c , e ) : <EOL> pass <EOL> def on_pubmsg ( self , c , e ) : <EOL> match = self . re_edit . match ( e . arguments ( ) [ <NUM_LIT:0> ] ) <EOL>", "answer": "if not match :"}, {"prompt": "<s> import Utils , Survey , Problem , numpy as np , scipy . sparse as sp , gc <EOL> from Utils . SolverUtils import * <EOL> import DataMisfit <EOL> import Regularization <EOL> class BaseInvProblem ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __metaclass__ = Utils . SimPEGMetaClass <EOL> beta = <NUM_LIT:1.0> <EOL> debug = False <EOL> counter = None <EOL> dmisfit = None <EOL> reg = None <EOL> opt = None <EOL> deleteTheseOnModelUpdate = [ ] <EOL> @ property <EOL> def curModel ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return getattr ( self , '<STR_LIT>' , None ) <EOL> @ curModel . setter <EOL> def curModel ( self , value ) : <EOL> if value is self . curModel : <EOL> return <EOL> self . _curModel = value <EOL> for prop in self . deleteTheseOnModelUpdate : <EOL> if hasattr ( self , prop ) : <EOL> delattr ( self , prop ) <EOL> def __init__ ( self , dmisfit , reg , opt , ** kwargs ) : <EOL> Utils . setKwargs ( self , ** kwargs ) <EOL> assert isinstance ( dmisfit , DataMisfit . BaseDataMisfit ) , '<STR_LIT>' <EOL> assert isinstance ( reg , Regularization . BaseRegularization ) , '<STR_LIT>' <EOL> self . dmisfit = dmisfit <EOL> self . reg = reg <EOL> self . opt = opt <EOL> self . prob , self . survey = dmisfit . prob , dmisfit . survey <EOL> self . opt . parent = self <EOL> self . reg . parent = self <EOL> self . dmisfit . parent = self <EOL> @ Utils . callHooks ( '<STR_LIT>' ) <EOL> def startup ( self , m0 ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . debug : print '<STR_LIT>' <EOL> if self . reg . mref is None : <EOL> print '<STR_LIT>' <EOL> self . reg . mref = m0 <EOL> self . phi_d = np . nan <EOL> self . phi_m = np . nan <EOL> self . curModel = m0 <EOL> print \"\"\"<STR_LIT>\"\"\" <EOL> self . opt . bfgsH0 = self . prob . Solver ( self . reg . eval2Deriv ( self . curModel ) , ** self . prob . solverOpts ) <EOL> @ property <EOL> def warmstart ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , [ ] ) <EOL> @ warmstart . setter <EOL> def warmstart ( self , value ) : <EOL> assert type ( value ) is list , '<STR_LIT>' <EOL> for v in value : <EOL> assert type ( v ) is tuple , '<STR_LIT>' <EOL> assert len ( v ) == <NUM_LIT:2> , '<STR_LIT>' <EOL> assert isinstance ( v [ <NUM_LIT:0> ] , np . ndarray ) , '<STR_LIT>' <EOL> self . _warmstart = value <EOL> def getFields ( self , m , store = False , deleteWarmstart = True ) : <EOL> u = None <EOL> for mtest , u_ofmtest in self . warmstart : <EOL> if m is mtest : <EOL> u = u_ofmtest <EOL> if self . debug : print '<STR_LIT>' <EOL> break <EOL> if u is None : <EOL>", "answer": "u = self . prob . fields ( m )"}, {"prompt": "<s> import os <EOL> import sys <EOL> def setup_django_settings ( ) : <EOL> sys . path . insert ( <NUM_LIT:0> , os . getcwd ( ) ) <EOL> os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> def run_tests ( ) : <EOL> if not os . environ . get ( \"<STR_LIT>\" , False ) : <EOL> setup_django_settings ( ) <EOL> import django <EOL> from django . conf import settings <EOL> from django . test . utils import get_runner <EOL> from inline_media . tests import delete_tmp_dirs <EOL> if django . VERSION [ <NUM_LIT:1> ] >= <NUM_LIT:7> : <EOL> django . setup ( ) <EOL>", "answer": "runner = get_runner ( settings , \"<STR_LIT>\" )"}, {"prompt": "<s> import os <EOL> from django . contrib import admin <EOL> from file_store . models import FileStoreItem , FileType , FileExtension <EOL> class FileStoreItemAdmin ( admin . ModelAdmin ) : <EOL> readonly_fields = ( '<STR_LIT>' , ) <EOL> list_display = [ '<STR_LIT>' , '<STR_LIT:id>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:source>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> def save_model ( self , request , obj , form , change ) : <EOL> '''<STR_LIT>''' <EOL> if os . path . isabs ( obj . source ) and not obj . is_local ( ) : <EOL> obj . symlink_datafile ( ) <EOL>", "answer": "class FileTypeAdmin ( admin . ModelAdmin ) :"}, {"prompt": "<s> from __future__ import absolute_import , print_function , division <EOL> from theano . tensor . xlogx import xlogx , xlogy0 <EOL> import unittest <EOL> import theano <EOL> from theano . tensor import as_tensor_variable <EOL> from . import test_basic as TT <EOL> import random <EOL> import numpy . random <EOL> from theano . tests import unittest_tools as utt <EOL> class T_XlogX ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> utt . seed_rng ( ) <EOL>", "answer": "def test0 ( self ) :"}, {"prompt": "<s> from south . utils import datetime_utils as datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . delete_column ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> db . delete_column ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> db . rename_column ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def backwards ( self , orm ) : <EOL> db . add_column ( '<STR_LIT>' , '<STR_LIT>' , <EOL> self . gf ( '<STR_LIT>' ) ( default = <NUM_LIT:0> , related_name = '<STR_LIT>' , to = orm [ '<STR_LIT>' ] ) , <EOL> keep_default = False ) <EOL> db . add_column ( '<STR_LIT>' , '<STR_LIT>' , <EOL> self . gf ( '<STR_LIT>' ) ( default = False ) , <EOL> keep_default = False ) <EOL> db . rename_column ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:url>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:user>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:date>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:message>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:url>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:src>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT:title>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT:url>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:user>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:message>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:src>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT:title>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL>", "answer": "'<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) ,"}, {"prompt": "<s> import os <EOL> from django . conf import settings <EOL> from django . core . files import File <EOL> from django . core . files . images import ImageFile <EOL> import mock <EOL> from nose . tools import eq_ <EOL> import kitsune . upload . tasks <EOL> from kitsune . questions . tests import QuestionFactory <EOL> from kitsune . sumo . tests import TestCase <EOL> from kitsune . upload . models import ImageAttachment <EOL> from kitsune . upload . tasks import ( <EOL> _scale_dimensions , _create_image_thumbnail , compress_image , <EOL> generate_thumbnail ) <EOL> from kitsune . users . tests import UserFactory <EOL> class ScaleDimensionsTestCase ( TestCase ) : <EOL> def test_scale_dimensions_default ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ts = settings . THUMBNAIL_SIZE <EOL> ( width , height ) = _scale_dimensions ( ts , ts , ts ) <EOL> eq_ ( ts , width ) <EOL> eq_ ( ts , height ) <EOL> def test_small ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ts = settings . THUMBNAIL_SIZE / <NUM_LIT:2> <EOL> ( width , height ) = _scale_dimensions ( ts , ts ) <EOL> eq_ ( ts , width ) <EOL> eq_ ( ts , height ) <EOL> def test_width_large ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ts = <NUM_LIT> <EOL> ( width , height ) = _scale_dimensions ( ts * <NUM_LIT:3> + <NUM_LIT:10> , ts - <NUM_LIT:1> , ts ) <EOL> eq_ ( ts , width ) <EOL> eq_ ( <NUM_LIT> , height ) <EOL> def test_large_height ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ts = <NUM_LIT> <EOL> ( width , height ) = _scale_dimensions ( ts - <NUM_LIT:2> , ts * <NUM_LIT:2> + <NUM_LIT:9> , ts ) <EOL> eq_ ( <NUM_LIT> , width ) <EOL> eq_ ( ts , height ) <EOL> def test_large_both_height ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ts = <NUM_LIT> <EOL> ( width , height ) = _scale_dimensions ( ts * <NUM_LIT:2> + <NUM_LIT> , ts * <NUM_LIT:5> + <NUM_LIT:30> , ts ) <EOL> eq_ ( <NUM_LIT> , width ) <EOL> eq_ ( ts , height ) <EOL> def test_large_both_width ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ts = <NUM_LIT> <EOL> ( width , height ) = _scale_dimensions ( ts * <NUM_LIT:20> + <NUM_LIT:8> , ts * <NUM_LIT:4> + <NUM_LIT> , ts ) <EOL> eq_ ( ts , width ) <EOL> eq_ ( <NUM_LIT> , height ) <EOL> class CreateThumbnailTestCase ( TestCase ) : <EOL> def test_create_image_thumbnail_default ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> thumb_content = _create_image_thumbnail ( <EOL> '<STR_LIT>' ) <EOL> actual_thumb = ImageFile ( thumb_content ) <EOL> with open ( '<STR_LIT>' ) as f : <EOL> expected_thumb = ImageFile ( f ) <EOL> eq_ ( expected_thumb . width , actual_thumb . width ) <EOL> eq_ ( expected_thumb . height , actual_thumb . height ) <EOL> def test_create_image_thumbnail_avatar ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> thumb_content = _create_image_thumbnail ( <EOL> '<STR_LIT>' , <EOL> settings . AVATAR_SIZE , pad = True ) <EOL> actual_thumb = ImageFile ( thumb_content ) <EOL> eq_ ( settings . AVATAR_SIZE , actual_thumb . width ) <EOL> eq_ ( settings . AVATAR_SIZE , actual_thumb . height ) <EOL> class GenerateThumbnail ( TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( GenerateThumbnail , self ) . setUp ( ) <EOL> self . user = UserFactory ( ) <EOL> self . obj = QuestionFactory ( ) <EOL> def tearDown ( self ) : <EOL> ImageAttachment . objects . all ( ) . delete ( ) <EOL> def _image_with_thumbnail ( self ) : <EOL> image = ImageAttachment ( content_object = self . obj , creator = self . user ) <EOL> with open ( '<STR_LIT>' ) as f : <EOL> up_file = File ( f ) <EOL> image . file . save ( up_file . name , up_file , save = True ) <EOL> generate_thumbnail ( image , '<STR_LIT:file>' , '<STR_LIT>' ) <EOL> return image <EOL> def test_generate_thumbnail_default ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> image = self . _image_with_thumbnail ( ) <EOL> eq_ ( <NUM_LIT> , image . thumbnail . width ) <EOL> eq_ ( <NUM_LIT> , image . thumbnail . height ) <EOL> def test_generate_no_file ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> image = ImageAttachment ( content_object = self . obj , creator = self . user ) <EOL> generate_thumbnail ( image , '<STR_LIT:file>' , '<STR_LIT>' ) <EOL> def test_generate_deleted_file ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> image = ImageAttachment ( content_object = self . obj , creator = self . user ) <EOL> with open ( '<STR_LIT>' ) as f : <EOL> up_file = File ( f ) <EOL> image . file . save ( up_file . name , up_file , save = True ) <EOL> os . remove ( image . file . path ) <EOL> generate_thumbnail ( image , '<STR_LIT:file>' , '<STR_LIT>' ) <EOL> def test_generate_thumbnail_twice ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> image = self . _image_with_thumbnail ( ) <EOL> old_path = image . thumbnail . path <EOL> assert os . path . isfile ( old_path ) <EOL> generate_thumbnail ( image , '<STR_LIT:file>' , '<STR_LIT>' ) <EOL> new_path = image . thumbnail . path <EOL> assert os . path . isfile ( new_path ) <EOL> if old_path != new_path : <EOL> assert not os . path . exists ( old_path ) <EOL> class CompressImageTestCase ( TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( CompressImageTestCase , self ) . setUp ( ) <EOL> self . user = UserFactory ( ) <EOL> self . obj = QuestionFactory ( ) <EOL> def tearDown ( self ) : <EOL> ImageAttachment . objects . all ( ) . delete ( ) <EOL> def _uploaded_image ( self , testfile = \"<STR_LIT>\" ) : <EOL>", "answer": "image = ImageAttachment ( content_object = self . obj , creator = self . user )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import requests , logging , json , sys <EOL> from http_calls import EdgeGridHttpCaller <EOL> from random import randint <EOL> from akamai . edgegrid import EdgeGridAuth <EOL> from config import EdgeGridConfig <EOL> import urllib <EOL> session = requests . Session ( ) <EOL> debug = False <EOL> verbose = False <EOL> section_name = \"<STR_LIT:default>\" <EOL> config = EdgeGridConfig ( { } , section_name ) <EOL> if hasattr ( config , \"<STR_LIT>\" ) and config . debug : <EOL> debug = True <EOL> if hasattr ( config , \"<STR_LIT>\" ) and config . verbose : <EOL> verbose = True <EOL> session . auth = EdgeGridAuth ( <EOL> client_token = config . client_token , <EOL> client_secret = config . client_secret , <EOL>", "answer": "access_token = config . access_token"}, {"prompt": "<s> class Solution : <EOL>", "answer": "def computeArea ( self , A , B , C , D , E , F , G , H ) :"}, {"prompt": "<s> import os <EOL> import io <EOL> import unittest <EOL> import json <EOL> from . import devicecomponent <EOL> from . fhirdate import FHIRDate <EOL> class DeviceComponentTests ( unittest . TestCase ) : <EOL> def instantiate_from ( self , filename ) : <EOL> datadir = os . environ . get ( '<STR_LIT>' ) or '<STR_LIT>' <EOL> with io . open ( os . path . join ( datadir , filename ) , '<STR_LIT:r>' , encoding = '<STR_LIT:utf-8>' ) as handle : <EOL> js = json . load ( handle ) <EOL> self . assertEqual ( \"<STR_LIT>\" , js [ \"<STR_LIT>\" ] ) <EOL> return devicecomponent . DeviceComponent ( js ) <EOL> def testDeviceComponent1 ( self ) : <EOL> inst = self . instantiate_from ( \"<STR_LIT>\" ) <EOL> self . assertIsNotNone ( inst , \"<STR_LIT>\" ) <EOL>", "answer": "self . implDeviceComponent1 ( inst )"}, {"prompt": "<s> from terminal import Command , Option <EOL> from nose . tools import raises <EOL> class TestOption ( object ) : <EOL> def test_attr ( self ) : <EOL> o = Option ( '<STR_LIT>' ) <EOL> assert repr ( o ) == '<STR_LIT>' <EOL> @ raises ( ValueError ) <EOL> def test_raise ( self ) : <EOL> Option ( '<STR_LIT>' ) <EOL> def test_shortname ( self ) : <EOL> o = Option ( '<STR_LIT>' ) <EOL> assert o . key == '<STR_LIT>' <EOL> assert o . boolean <EOL> assert o . default is False <EOL> assert o . required is False <EOL> def test_longname ( self ) : <EOL> o = Option ( '<STR_LIT>' ) <EOL> assert o . key == '<STR_LIT>' <EOL> assert o . boolean <EOL> assert o . default is False <EOL> assert o . required is False <EOL> o = Option ( '<STR_LIT>' ) <EOL> assert o . key == '<STR_LIT>' <EOL> assert o . boolean <EOL> assert o . default is True <EOL> assert o . required is False <EOL> def test_both_name ( self ) : <EOL> o = Option ( '<STR_LIT>' ) <EOL> assert o . key == '<STR_LIT>' <EOL> assert o . boolean <EOL> assert o . default is False <EOL> assert o . required is False <EOL> def test_non_boolean ( self ) : <EOL> o = Option ( '<STR_LIT>' ) <EOL> assert o . key == '<STR_LIT>' <EOL> assert o . boolean is False <EOL> assert o . default is None <EOL> assert o . required is False <EOL> o = Option ( '<STR_LIT>' ) <EOL> assert o . required is True <EOL> def test_default ( self ) : <EOL> o = Option ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> assert o . default == '<STR_LIT:src>' <EOL> o = Option ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> assert o . default == '<STR_LIT:src>' <EOL> o = Option ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> assert o . default == '<STR_LIT:src>' <EOL> o = Option ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> assert o . default is None <EOL> def test_to_python ( self ) : <EOL> o = Option ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> assert o . to_python ( ) == '<STR_LIT:src>' <EOL> assert o . to_python ( '<STR_LIT:foo>' ) == '<STR_LIT:foo>' <EOL> o = Option ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> resolve = int , <EOL> ) <EOL> assert o . to_python ( '<STR_LIT>' ) == <NUM_LIT:12> <EOL> class TestCommand ( object ) : <EOL> def test_parse ( self ) : <EOL> program = Command ( '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> program . option ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> program . option ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> program . option ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> program . option ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> program . option ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> program . option ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> program . print_version ( ) <EOL> program . print_help ( ) <EOL> program . parse ( <EOL> '<STR_LIT>' <EOL> ) <EOL> assert program . get ( '<STR_LIT>' ) <EOL> assert program . verbose <EOL> assert program . tag == '<STR_LIT>' <EOL> assert program . color is False <EOL> assert program . key == '<STR_LIT>' <EOL> def test_print ( self ) : <EOL> program = Command ( '<STR_LIT>' , title = '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> program . print_version ( ) <EOL> program . print_help ( ) <EOL> program . _usage = '<STR_LIT>' <EOL> program . print_help ( ) <EOL> def test_help_footer ( self ) : <EOL> footers = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> program = Command ( '<STR_LIT>' , help_footer = '<STR_LIT:\\n>' . join ( footers ) ) <EOL> program . print_help ( ) <EOL> def test_add_action ( self ) : <EOL> program = Command ( '<STR_LIT>' ) <EOL> @ program . action <EOL> def hello ( bar ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert bar == '<STR_LIT>' <EOL> program . parse ( '<STR_LIT>' ) <EOL> program . print_help ( ) <EOL> def test_action ( self ) : <EOL> program = Command ( '<STR_LIT:action>' ) <EOL> @ program . action <EOL> def lepture ( bar , color = True , force = False , msg = '<STR_LIT:hello>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert bar == '<STR_LIT>' <EOL> program . print_version ( ) <EOL> program . print_help ( ) <EOL> program . parse ( '<STR_LIT>' ) <EOL> program . parse ( '<STR_LIT>' ) <EOL> assert '<STR_LIT>' in program . args <EOL> program . action ( program ) <EOL> program . parse ( '<STR_LIT>' ) <EOL> def test_call ( self ) : <EOL> program = Command ( '<STR_LIT>' ) <EOL> @ program <EOL> def bar ( ) : <EOL> return '<STR_LIT:bar>' <EOL> program . print_help ( ) <EOL> def test_subcommand ( self ) : <EOL> program = Command ( '<STR_LIT>' ) <EOL> @ program . subcommand <EOL> def bar ( ) : <EOL> return '<STR_LIT:bar>' <EOL> program . print_help ( ) <EOL> def test_func ( self ) : <EOL> def bar ( ) : <EOL> return '<STR_LIT:bar>' <EOL> program = Command ( '<STR_LIT>' , func = bar ) <EOL> program . parse ( '<STR_LIT>' ) <EOL> @ raises ( RuntimeError ) <EOL> def test_missing_option ( self ) : <EOL>", "answer": "program = Command ( '<STR_LIT>' )"}, {"prompt": "<s> import boto <EOL> import logging <EOL> from django . conf import settings <EOL> from django . core . management . base import BaseCommand <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Command ( BaseCommand ) : <EOL> help = \"<STR_LIT>\" <EOL> def handle ( self , * args , ** options ) : <EOL> conn = boto . connect_s3 ( <EOL> settings . AWS_ACCESS_KEY_ID , <EOL> settings . AWS_SECRET_ACCESS_KEY <EOL>", "answer": ")"}, {"prompt": "<s> from python_toolbox import cute_testing <EOL> from python_toolbox import math_tools <EOL> from python_toolbox import combi <EOL> def test ( ) : <EOL> assert combi . misc . get_short_factorial_string ( <NUM_LIT:7> ) == str ( math_tools . factorial ( <NUM_LIT:7> ) ) <EOL> assert combi . misc . get_short_factorial_string ( <NUM_LIT:7> , minus_one = True ) == str ( math_tools . factorial ( <NUM_LIT:7> ) - <NUM_LIT:1> ) <EOL> assert combi . misc . get_short_factorial_string ( <NUM_LIT> ) == '<STR_LIT>' <EOL> assert combi . misc . get_short_factorial_string ( <NUM_LIT> , minus_one = True ) == '<STR_LIT>' <EOL> assert combi . misc . get_short_factorial_string ( float ( '<STR_LIT>' ) ) == '''<STR_LIT>''' <EOL> assert combi . misc . get_short_factorial_string ( float ( '<STR_LIT>' ) , <EOL> minus_one = True ) == '''<STR_LIT>''' <EOL> def test_things_in_root_namespace ( ) : <EOL> combi . binomial <EOL> combi . Bag <EOL>", "answer": "combi . OrderedBag"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import cv2 <EOL> import numpy as np <EOL> from cam import MyCam <EOL> from fmatch import draw_match <EOL> print __doc__ <EOL> MIN_MATCH_COUNT = <NUM_LIT:10> <EOL>", "answer": "sift = cv2 . SIFT ( )"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import re <EOL> from flanker . addresslib . drivers . redis_driver import RedisCache <EOL> from flanker . addresslib . drivers . dns_lookup import DNSLookup <EOL> from flanker . addresslib . plugins import yahoo <EOL> from flanker . addresslib . plugins import aol <EOL> from flanker . addresslib . plugins import gmail <EOL> from flanker . addresslib . plugins import icloud <EOL>", "answer": "from flanker . addresslib . plugins import hotmail"}, {"prompt": "<s> __author__ = '<STR_LIT>' <EOL> from restapi . modules . base import BaseModel , db <EOL> from marshmallow import Serializer , fields <EOL> class Cake ( BaseModel ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> id = db . Column ( db . Integer , primary_key = True ) <EOL> cakename = db . Column ( db . String ( <NUM_LIT> ) , unique = True ) <EOL> bakername = db . Column ( db . String ( <NUM_LIT> ) , unique = False ) <EOL>", "answer": "price = db . Column ( db . Float )"}, {"prompt": "<s> from smart_server . smart . utils . startup import check_environment <EOL>", "answer": "import os "}, {"prompt": "<s> import sys <EOL> import os <EOL> import difflib <EOL> from PySide import QtGui , QtCore <EOL> from kraken . core . maths import Vec2 <EOL> from kraken . core . kraken_system import KrakenSystem <EOL> class ComponentTreeWidget ( QtGui . QTreeWidget ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , parent ) : <EOL> super ( ComponentTreeWidget , self ) . __init__ ( parent ) <EOL> self . setObjectName ( '<STR_LIT>' ) <EOL> self . header ( ) . close ( ) <EOL> self . setColumnCount ( <NUM_LIT:1> ) <EOL> self . setDragEnabled ( True ) <EOL> self . setDragDropMode ( QtGui . QTreeWidget . DragOnly ) <EOL> krakenUIWidget = self . parent ( ) . parent ( ) <EOL> graphViewWidget = krakenUIWidget . graphViewWidget <EOL> krakenUIWidget . error_loading_startup = False <EOL> if not self . generateData ( ) : <EOL> krakenUIWidget . error_loading_startup = True <EOL> self . buildWidgets ( ) <EOL> def buildWidgets ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . clear ( ) <EOL> self . __iterateOnData ( self . _data , parentWidget = self ) <EOL> def __iterateOnData ( self , data , parentWidget = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for item in data [ '<STR_LIT>' ] : <EOL> if data [ '<STR_LIT>' ] [ item ] not in self . ks . registeredComponents . keys ( ) : <EOL> print ( \"<STR_LIT>\" + data [ '<STR_LIT>' ] [ item ] + \"<STR_LIT>\" ) <EOL> for component in self . ks . registeredComponents : <EOL> print \"<STR_LIT:U+0020>\" + component <EOL> continue <EOL> treeItem = QtGui . QTreeWidgetItem ( parentWidget ) <EOL> treeItem . setData ( <NUM_LIT:0> , QtCore . Qt . UserRole , data [ '<STR_LIT>' ] [ item ] ) <EOL> treeItem . setText ( <NUM_LIT:0> , item ) <EOL> component = self . ks . registeredComponents [ data [ '<STR_LIT>' ] [ item ] ] <EOL> module = sys . modules [ component . __module__ ] <EOL> treeItem . setToolTip ( <NUM_LIT:0> , module . __file__ ) <EOL> if parentWidget is not None : <EOL> parentWidget . setToolTip ( <NUM_LIT:0> , os . path . dirname ( module . __file__ ) ) <EOL> for item in data [ '<STR_LIT>' ] . keys ( ) : <EOL> treeItem = QtGui . QTreeWidgetItem ( parentWidget ) <EOL> treeItem . setData ( <NUM_LIT:0> , QtCore . Qt . UserRole , '<STR_LIT>' ) <EOL> treeItem . setText ( <NUM_LIT:0> , item ) <EOL> self . __iterateOnData ( data [ '<STR_LIT>' ] [ item ] , parentWidget = treeItem ) <EOL> def generateData ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . ks = KrakenSystem . getInstance ( ) <EOL> isSuccessful = self . ks . loadComponentModules ( ) <EOL> componentClassNames = [ ] <EOL>", "answer": "for componentClassName in sorted ( self . ks . getComponentClassNames ( ) ) :"}, {"prompt": "<s> from sys import argv <EOL> from builtins import input <EOL> from pyroute2 import IPRoute , NetNS , IPDB , NSPopen <EOL> from simulation import Simulation <EOL> from subprocess import PIPE , call , Popen <EOL>", "answer": "import re"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL> import smart_selects . db_fields <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL>", "answer": "name = '<STR_LIT>' ,"}, {"prompt": "<s> from . data_calc import DataCalc <EOL> from datetime import datetime <EOL> import math <EOL> class LatCalc ( DataCalc ) : <EOL> def __init__ ( self ) : <EOL> self . initialize_data ( ) <EOL> def initialize_data ( self ) : <EOL> self . data = <NUM_LIT> <EOL> self . last_calc = datetime . now ( ) <EOL> self . earth_circumference_km = <NUM_LIT> <EOL> self . km_per_deg = self . earth_circumference_km / <NUM_LIT> <EOL> self . name = '<STR_LIT>' <EOL> def iterate ( self , snapshot ) : <EOL> vehicle_speed = snapshot [ '<STR_LIT>' ] <EOL> heading = snapshot [ '<STR_LIT>' ] <EOL> current_time = datetime . now ( ) <EOL>", "answer": "time_delta = current_time - self . last_calc"}, {"prompt": "<s> from __future__ import absolute_import <EOL> class EventTypeManager ( object ) : <EOL> def __init__ ( self ) : <EOL> self . __values = [ ] <EOL> self . __lookup = { } <EOL>", "answer": "def __iter__ ( self ) :"}, {"prompt": "<s> appname = \"<STR_LIT>\" <EOL>", "answer": "client_id = \"<STR_LIT>\""}, {"prompt": "<s> from . import domainresource <EOL> class Immunization ( domainresource . DomainResource ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> resource_name = \"<STR_LIT>\" <EOL> def __init__ ( self , jsondict = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . date = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . doseQuantity = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . encounter = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . expirationDate = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . explanation = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . identifier = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . location = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . lotNumber = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . manufacturer = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . note = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "self . patient = None"}, {"prompt": "<s> import os <EOL> import sys <EOL> import threading <EOL> import traceback <EOL> from . import common , compat , configs , utils <EOL> def _get_appsock_from_handshake ( config , handshake_endpoint ) : <EOL> app_info = utils . create_rep_socket_bound_to_random ( ) <EOL> handshake_sock = compat . MQ . socket ( compat . MQ . REQ ) <EOL> handshake_sock . connect ( handshake_endpoint ) <EOL> handshake_sock . send ( config . dumps ( app_info . endpoint ) ) <EOL> handshake_sock . recv ( ) <EOL> handshake_sock . close ( ) <EOL> return app_info . socket , app_info . endpoint <EOL> _execstate = { } <EOL> def eval_ ( source ) : <EOL> return eval ( source , _execstate , _execstate ) <EOL> def exec_ ( source ) : <EOL> return compat . exec_ ( source , _execstate , _execstate ) <EOL> def start_server ( env = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if env is None : <EOL> env = os . environ <EOL> configname = env . get ( common . ENV_CONFIGNAME ) <EOL> if not configname : <EOL> sys . exit ( '<STR_LIT>' % common . ENV_CONFIGNAME ) <EOL> config = configs . config_by_name ( configname ) <EOL> handshake_endpoint = env . get ( common . ENV_HANDSHAKE_ENDPOINT ) <EOL> if handshake_endpoint : <EOL> sock , app_endpoint = _get_appsock_from_handshake ( <EOL> config , handshake_endpoint ) <EOL> else : <EOL> app_endpoint = env . get ( common . ENV_APP_ENDPOINT ) <EOL> if not app_endpoint : <EOL> sys . exit ( '<STR_LIT>' <EOL> % common . ENV_APP_ENDPOINT ) <EOL> sock = compat . MQ . socket ( compat . MQ . REP ) <EOL>", "answer": "sock . bind ( app_endpoint )"}, {"prompt": "<s> import unittest <EOL> from imgfac . NotificationCenter import NotificationCenter <EOL> class testNotificationCenter ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . notification_center = NotificationCenter ( ) <EOL> def tearDown ( self ) : <EOL> del self . notification_center <EOL> def testAddRemoveObservers ( self ) : <EOL> o1 = MockObserver ( ) <EOL> o2 = MockObserver ( ) <EOL> nc = self . notification_center <EOL> self . assertEqual ( len ( nc . observers ) , <NUM_LIT:0> ) <EOL> nc . add_observer ( o1 , '<STR_LIT>' ) <EOL> self . assertEqual ( len ( nc . observers ) , <NUM_LIT:1> ) <EOL> nc . add_observer ( o1 , '<STR_LIT>' , '<STR_LIT:test>' ) <EOL> self . assertEqual ( len ( nc . observers ) , <NUM_LIT:2> ) <EOL> nc . add_observer ( o2 , '<STR_LIT>' , '<STR_LIT>' , self ) <EOL> self . assertEqual ( len ( nc . observers ) , <NUM_LIT:3> ) <EOL> nc . remove_observer ( o1 , '<STR_LIT>' ) <EOL> self . assertEqual ( len ( nc . observers ) , <NUM_LIT:2> ) <EOL> nc . remove_observer ( o1 , '<STR_LIT>' , '<STR_LIT:test>' ) <EOL> self . assertEqual ( len ( nc . observers ) , <NUM_LIT:1> ) <EOL> nc . remove_observer ( o2 , '<STR_LIT>' , '<STR_LIT>' , self ) <EOL> self . assertEqual ( len ( nc . observers ) , <NUM_LIT:0> ) <EOL> def testPostNotification ( self ) : <EOL> o1 = MockObserver ( ) <EOL> o2 = MockObserver ( ) <EOL> o3 = MockObserver ( ) <EOL> mock_sender = object ( ) <EOL> mock_usr_info = dict ( test_key = '<STR_LIT>' ) <EOL> self . assertIsNone ( o1 . notification ) <EOL> nc = self . notification_center <EOL> nc . add_observer ( o1 , '<STR_LIT>' ) <EOL> nc . add_observer ( o2 , '<STR_LIT>' , '<STR_LIT:test>' ) <EOL> nc . add_observer ( o3 , '<STR_LIT>' , sender = mock_sender ) <EOL> nc . post_notification_with_info ( '<STR_LIT>' , self ) <EOL> self . assertEqual ( o1 . notification . message , '<STR_LIT>' ) <EOL> self . assertIsNone ( o2 . notification ) <EOL> self . assertIsNone ( o3 . notification ) <EOL> nc . post_notification_with_info ( '<STR_LIT:test>' , self ) <EOL> self . assertEqual ( o1 . notification . message , '<STR_LIT:test>' ) <EOL> self . assertEqual ( o2 . notification . message , '<STR_LIT:test>' ) <EOL> self . assertIsNone ( o3 . notification ) <EOL> nc . post_notification_with_info ( '<STR_LIT>' , mock_sender ) <EOL> self . assertEqual ( o1 . notification . message , '<STR_LIT>' ) <EOL> self . assertNotEqual ( o2 . notification . message , '<STR_LIT>' ) <EOL> self . assertEqual ( o3 . notification . message , '<STR_LIT>' ) <EOL>", "answer": "self . assertIsNone ( o1 . notification . user_info )"}, {"prompt": "<s> from django . shortcuts import get_object_or_404 , render_to_response <EOL> from django . template . context import RequestContext <EOL> from dnd . menu import menu_item , submenu_item , MenuItem <EOL> from dnd . dnd_paginator import DndPaginator <EOL> from dnd . filters import MonsterFilter <EOL> from dnd . models import Rulebook , Monster <EOL> from dnd . views import is_3e_edition , permanent_redirect_view , permanent_redirect_object <EOL> @ menu_item ( MenuItem . BESTIARY ) <EOL>", "answer": "@ submenu_item ( MenuItem . Bestiary . MONSTERS )"}, {"prompt": "<s> import sys , os , os . path , re <EOL> import itertools <EOL> import datetime <EOL> YEAR = datetime . date . today ( ) . strftime ( '<STR_LIT>' ) <EOL> sys . path . append ( os . path . abspath ( '<STR_LIT>' ) ) <EOL> import ipython_console_highlighting <EOL> highlight_language = '<STR_LIT>' <EOL> extensions = [ <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import threading <EOL> from sendsms . backends . base import BaseSmsBackend <EOL> class SmsBackend ( BaseSmsBackend ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . stream = kwargs . pop ( '<STR_LIT>' , sys . stdout ) <EOL> self . _lock = threading . RLock ( ) <EOL> super ( SmsBackend , self ) . __init__ ( * args , ** kwargs ) <EOL> def send_messages ( self , messages ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not messages : <EOL> return <EOL> self . _lock . acquire ( ) <EOL> try : <EOL> try : <EOL> stream_created = self . open ( ) <EOL> for message in messages : <EOL> self . stream . write ( render_message ( message ) ) <EOL> self . stream . write ( '<STR_LIT:\\n>' ) <EOL> self . stream . write ( '<STR_LIT:->' * <NUM_LIT> ) <EOL> self . stream . write ( '<STR_LIT:\\n>' ) <EOL> self . stream . flush ( ) <EOL> if stream_created : <EOL> self . close ( ) <EOL> except : <EOL> if not self . fail_silently : <EOL> raise <EOL> finally : <EOL>", "answer": "self . _lock . release ( )"}, {"prompt": "<s> from . construct_nodes import EnamlDefConstruct <EOL> from . exceptions import DeclarativeException <EOL>", "answer": "from . resolver import Resolver"}, {"prompt": "<s> import os <EOL> import re <EOL> import subprocess <EOL> import lldb <EOL> import fblldbbase as fb <EOL> import fblldbviewcontrollerhelpers as vcHelpers <EOL> import fblldbviewhelpers as viewHelpers <EOL> import fblldbobjcruntimehelpers as runtimeHelpers <EOL> def lldbcommands ( ) : <EOL> return [ <EOL> FBPrintViewHierarchyCommand ( ) , <EOL> FBPrintCoreAnimationTree ( ) , <EOL> FBPrintViewControllerHierarchyCommand ( ) , <EOL> FBPrintIsExecutingInAnimationBlockCommand ( ) , <EOL> FBPrintInheritanceHierarchy ( ) , <EOL> FBPrintUpwardResponderChain ( ) , <EOL> FBPrintOnscreenTableView ( ) , <EOL> FBPrintOnscreenTableViewCells ( ) , <EOL> FBPrintInternals ( ) , <EOL> FBPrintInstanceVariable ( ) , <EOL> FBPrintKeyPath ( ) , <EOL> FBPrintApplicationDocumentsPath ( ) , <EOL> FBPrintData ( ) , <EOL> FBPrintTargetActions ( ) , <EOL> FBPrintJSON ( ) , <EOL> FBPrintAsCurl ( ) , <EOL> FBPrintToClipboard ( ) , <EOL> FBPrintInObjc ( ) , <EOL>", "answer": "FBPrintInSwift ( ) ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import click <EOL> import SoftLayer <EOL> from SoftLayer . CLI import environment <EOL> @ click . command ( ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> @ click . argument ( '<STR_LIT>' ) <EOL> @ environment . pass_env <EOL> def cli ( env , account_id , origin_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> manager = SoftLayer . CDNManager ( env . client ) <EOL>", "answer": "manager . remove_origin ( account_id , origin_id ) "}, {"prompt": "<s> import time , config <EOL> from optparse import OptionParser <EOL> from comodit_client . api import Client <EOL> from comodit_client . api . exceptions import PythonApiException <EOL> from comodit_client . api . host import Host <EOL> from helper import get_latest_id , get_short_hostname , create_host <EOL> def downscale_osds ( count ) : <EOL> print \"<STR_LIT>\" <EOL> start_time = time . time ( ) <EOL> client = Client ( config . endpoint , config . username , config . password ) <EOL> env = client . get_environment ( config . organization , '<STR_LIT>' ) <EOL> latest_id = get_latest_id ( '<STR_LIT>' , env ) <EOL> if latest_id < <NUM_LIT:0> : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> if latest_id - count + <NUM_LIT:1> <= <NUM_LIT:2> : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> mon_hosts = [ ] <EOL> for i in xrange ( latest_id - count + <NUM_LIT:1> , latest_id + <NUM_LIT:1> ) : <EOL> mon = env . get_host ( '<STR_LIT>' + str ( i ) ) <EOL> print \"<STR_LIT>\" % i <EOL> mon . settings ( ) . create ( \"<STR_LIT:status>\" , \"<STR_LIT>\" ) <EOL> mon_hosts . append ( mon ) <EOL> for h in mon_hosts : <EOL> h . wait_for_pending_changes ( ) <EOL> print \"<STR_LIT>\" <EOL> next_id = latest_id + <NUM_LIT:1> <EOL> monitors = env . get_setting ( \"<STR_LIT>\" ) . value <EOL> for i in xrange ( <NUM_LIT:0> , len ( monitors ) ) : <EOL> mon = monitors [ i ] <EOL> id = int ( mon [ \"<STR_LIT:id>\" ] ) <EOL> if id >= latest_id - count + <NUM_LIT:1> and id < latest_id + <NUM_LIT:1> : <EOL> del monitors [ i ] <EOL> env . settings ( ) . update ( \"<STR_LIT>\" , monitors ) <EOL>", "answer": "time . sleep ( <NUM_LIT:3> )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> lutkepohl_dfm = { <EOL> '<STR_LIT>' : [ <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <EOL> ] , <EOL> '<STR_LIT>' : [ <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <EOL> ] , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> } <EOL> lutkepohl_dfm2 = { <EOL> '<STR_LIT>' : [ <EOL> <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> <EOL> ] , <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> } <EOL> lutkepohl_dfm_exog1 = { <EOL> '<STR_LIT>' : [ <EOL> - <NUM_LIT> , - <NUM_LIT> , - <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <EOL> ] , <EOL> '<STR_LIT>' : [ <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> <EOL> ] , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> } <EOL> lutkepohl_dfm_exog2 = { <EOL> '<STR_LIT>' : [ <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , - <NUM_LIT> , <EOL> <NUM_LIT> , - <NUM_LIT> , <EOL> <NUM_LIT> , - <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <EOL> ] , <EOL> '<STR_LIT>' : [ <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <EOL> ] , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> } <EOL> lutkepohl_dfm_gen = { <EOL> '<STR_LIT>' : [ <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <EOL> - <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , - <NUM_LIT> , <NUM_LIT> , <EOL> - <NUM_LIT> , <NUM_LIT> , - <NUM_LIT> <EOL> ] , <EOL> '<STR_LIT>' : [ <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> None , <EOL> None , None , <EOL> None , None , None , <EOL> <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> <EOL> ] , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> } <EOL> lutkepohl_dfm_ar2 = { <EOL> '<STR_LIT>' : [ <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <EOL> - <NUM_LIT> , - <NUM_LIT> , <EOL> - <NUM_LIT> , - <NUM_LIT> , <EOL> - <NUM_LIT> , - <NUM_LIT> , <EOL> ] , <EOL> '<STR_LIT>' : [ <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <EOL>", "answer": "<NUM_LIT> , <NUM_LIT> , <NUM_LIT> ,"}, {"prompt": "<s> import os <EOL> import subprocess <EOL> import time <EOL> from django . conf import settings <EOL> import jinja2 <EOL> from jingo import register <EOL> from . utils import get_media_url , get_path <EOL> try : <EOL> from build import BUILD_ID_CSS , BUILD_ID_JS , BUILD_ID_IMG , BUNDLE_HASHES <EOL> except ImportError : <EOL> BUILD_ID_CSS = BUILD_ID_JS = BUILD_ID_IMG = '<STR_LIT>' <EOL> BUNDLE_HASHES = { } <EOL> def is_external ( url ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return url . startswith ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> def _get_item_path ( item ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if is_external ( item ) : <EOL> return item <EOL> return get_media_url ( ) + item <EOL> def _get_mtime ( item ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if item . startswith ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) : <EOL> return int ( time . time ( ) ) <EOL> return int ( os . path . getmtime ( get_path ( item ) ) ) <EOL> def _build_html ( items , wrapping ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return jinja2 . Markup ( '<STR_LIT:\\n>' . join ( ( wrapping % item for item in items ) ) ) <EOL> def get_js_urls ( bundle , debug = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if debug is None : <EOL> debug = settings . TEMPLATE_DEBUG <EOL> if debug : <EOL> return [ _get_item_path ( '<STR_LIT>' % ( item , _get_mtime ( item ) ) ) for <EOL> item in settings . MINIFY_BUNDLES [ '<STR_LIT>' ] [ bundle ] ] <EOL> else : <EOL> build_id = BUILD_ID_JS <EOL> bundle_full = '<STR_LIT>' % bundle <EOL> if bundle_full in BUNDLE_HASHES : <EOL> build_id = BUNDLE_HASHES [ bundle_full ] <EOL> return ( _get_item_path ( '<STR_LIT>' % ( bundle , build_id , ) ) , ) <EOL> def _get_compiled_css_url ( item ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ( ( item . endswith ( '<STR_LIT>' ) and <EOL> getattr ( settings , '<STR_LIT>' , False ) ) or <EOL> item . endswith ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) ) : <EOL> compile_css ( item ) <EOL> return item + '<STR_LIT>' <EOL> return item <EOL> def get_css_urls ( bundle , debug = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if debug is None : <EOL> debug = settings . TEMPLATE_DEBUG <EOL> if debug : <EOL> items = [ ] <EOL> for item in settings . MINIFY_BUNDLES [ '<STR_LIT>' ] [ bundle ] : <EOL> if ( ( item . endswith ( '<STR_LIT>' ) and <EOL> getattr ( settings , '<STR_LIT>' , False ) ) or <EOL> item . endswith ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) ) : <EOL> compile_css ( item ) <EOL> items . append ( '<STR_LIT>' % item ) <EOL> else : <EOL> items . append ( item ) <EOL> return [ _get_item_path ( '<STR_LIT>' % ( item , _get_mtime ( item ) ) ) for <EOL> item in items ] <EOL> else : <EOL> build_id = BUILD_ID_CSS <EOL> bundle_full = '<STR_LIT>' % bundle <EOL> if bundle_full in BUNDLE_HASHES : <EOL> build_id = BUNDLE_HASHES [ bundle_full ] <EOL> return ( _get_item_path ( '<STR_LIT>' % <EOL> ( bundle , build_id ) ) , ) <EOL> @ register . function <EOL> def js ( bundle , debug = None , defer = False , async = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> attrs = [ ] <EOL> urls = get_js_urls ( bundle , debug ) <EOL> attrs . append ( '<STR_LIT>' ) <EOL> if defer : <EOL> attrs . append ( '<STR_LIT>' ) <EOL> if async : <EOL> attrs . append ( '<STR_LIT>' ) <EOL> return _build_html ( urls , '<STR_LIT>' % '<STR_LIT:U+0020>' . join ( attrs ) ) <EOL> @ register . function <EOL> def css ( bundle , media = False , debug = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> urls = get_css_urls ( bundle , debug ) <EOL> if not media : <EOL> media = getattr ( settings , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return _build_html ( urls , '<STR_LIT>' <EOL> % media ) <EOL> @ register . function <EOL> def inline_css ( bundle , media = False , debug = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if debug is None : <EOL> debug = getattr ( settings , '<STR_LIT>' , False ) <EOL> if debug : <EOL> items = [ _get_compiled_css_url ( i ) <EOL> for i in settings . MINIFY_BUNDLES [ '<STR_LIT>' ] [ bundle ] ] <EOL> else : <EOL> items = [ '<STR_LIT>' % bundle ] <EOL> if not media : <EOL> media = getattr ( settings , '<STR_LIT>' , '<STR_LIT>' ) <EOL> contents = [ ] <EOL> for css in items : <EOL> if is_external ( css ) : <EOL> return _build_html ( [ css ] , '<STR_LIT>' <EOL> '<STR_LIT>' % media ) <EOL> with open ( get_path ( css ) , '<STR_LIT:r>' ) as f : <EOL> contents . append ( f . read ( ) ) <EOL>", "answer": "return _build_html ( contents , '<STR_LIT>'"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from __future__ import unicode_literals <EOL> from . import Extension <EOL> from . . treeprocessors import Treeprocessor <EOL> from . . util import etree <EOL> from . headerid import slugify , unique , itertext <EOL> import re <EOL> def order_toc_list ( toc_list ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def build_correct ( remaining_list , prev_elements = [ { '<STR_LIT>' : <NUM_LIT:1000> } ] ) : <EOL> if not remaining_list : <EOL> return [ ] , [ ] <EOL> current = remaining_list . pop ( <NUM_LIT:0> ) <EOL> if not '<STR_LIT>' in current . keys ( ) : <EOL> current [ '<STR_LIT>' ] = [ ] <EOL> if not prev_elements : <EOL> next_elements , children = build_correct ( remaining_list , [ current ] ) <EOL> current [ '<STR_LIT>' ] . append ( children ) <EOL> return [ current ] + next_elements , [ ] <EOL> prev_element = prev_elements . pop ( ) <EOL> children = [ ] <EOL> next_elements = [ ] <EOL> if current [ '<STR_LIT>' ] > prev_element [ '<STR_LIT>' ] : <EOL> prev_elements . append ( prev_element ) <EOL> prev_elements . append ( current ) <EOL> prev_element [ '<STR_LIT>' ] . append ( current ) <EOL> next_elements2 , children2 = build_correct ( remaining_list , prev_elements ) <EOL> children += children2 <EOL> next_elements += next_elements2 <EOL> else : <EOL> if not prev_elements : <EOL> next_elements . append ( current ) <EOL> prev_elements = [ current ] <EOL> next_elements2 , children2 = build_correct ( remaining_list , prev_elements ) <EOL> current [ '<STR_LIT>' ] . extend ( children2 ) <EOL> else : <EOL> remaining_list . insert ( <NUM_LIT:0> , current ) <EOL> next_elements2 , children2 = build_correct ( remaining_list , prev_elements ) <EOL> children . extend ( children2 ) <EOL> next_elements += next_elements2 <EOL> return next_elements , children <EOL> ordered_list , __ = build_correct ( toc_list ) <EOL> return ordered_list <EOL> class TocTreeprocessor ( Treeprocessor ) : <EOL> def iterparent ( self , root ) : <EOL> for parent in root . getiterator ( ) : <EOL> for child in parent : <EOL> yield parent , child <EOL> def add_anchor ( self , c , elem_id ) : <EOL> if self . use_anchors : <EOL> anchor = etree . Element ( \"<STR_LIT:a>\" ) <EOL> anchor . text = c . text <EOL> anchor . attrib [ \"<STR_LIT>\" ] = \"<STR_LIT:#>\" + elem_id <EOL> anchor . attrib [ \"<STR_LIT:class>\" ] = \"<STR_LIT>\" <EOL> c . text = \"<STR_LIT>\" <EOL> for elem in c . getchildren ( ) : <EOL> anchor . append ( elem ) <EOL> c . remove ( elem ) <EOL> c . append ( anchor ) <EOL> def build_toc_etree ( self , div , toc_list ) : <EOL> if self . config [ \"<STR_LIT:title>\" ] : <EOL> header = etree . SubElement ( div , \"<STR_LIT>\" ) <EOL> header . attrib [ \"<STR_LIT:class>\" ] = \"<STR_LIT>\" <EOL> header . text = self . config [ \"<STR_LIT:title>\" ] <EOL> def build_etree_ul ( toc_list , parent ) : <EOL> ul = etree . SubElement ( parent , \"<STR_LIT>\" ) <EOL> for item in toc_list : <EOL> li = etree . SubElement ( ul , \"<STR_LIT>\" ) <EOL> link = etree . SubElement ( li , \"<STR_LIT:a>\" ) <EOL> link . text = item . get ( '<STR_LIT:name>' , '<STR_LIT>' ) <EOL> link . attrib [ \"<STR_LIT>\" ] = '<STR_LIT:#>' + item . get ( '<STR_LIT:id>' , '<STR_LIT>' ) <EOL> if item [ '<STR_LIT>' ] : <EOL> build_etree_ul ( item [ '<STR_LIT>' ] , li ) <EOL> return ul <EOL> return build_etree_ul ( toc_list , div ) <EOL> def run ( self , doc ) : <EOL> div = etree . Element ( \"<STR_LIT>\" ) <EOL> div . attrib [ \"<STR_LIT:class>\" ] = \"<STR_LIT>\" <EOL> header_rgx = re . compile ( \"<STR_LIT>\" ) <EOL> self . use_anchors = self . config [ \"<STR_LIT>\" ] in [ <NUM_LIT:1> , '<STR_LIT:1>' , True , '<STR_LIT:True>' , '<STR_LIT:true>' ] <EOL> used_ids = set ( ) <EOL> for c in doc . getiterator ( ) : <EOL> if \"<STR_LIT:id>\" in c . attrib : <EOL> used_ids . add ( c . attrib [ \"<STR_LIT:id>\" ] ) <EOL> toc_list = [ ] <EOL> marker_found = False <EOL> for ( p , c ) in self . iterparent ( doc ) : <EOL> text = '<STR_LIT>' . join ( itertext ( c ) ) . strip ( ) <EOL> if not text : <EOL> continue <EOL> if c . text and c . text . strip ( ) == self . config [ \"<STR_LIT>\" ] and not header_rgx . match ( c . tag ) and c . tag not in [ '<STR_LIT>' , '<STR_LIT:code>' ] : <EOL> for i in range ( len ( p ) ) : <EOL> if p [ i ] == c : <EOL> p [ i ] = div <EOL> break <EOL> marker_found = True <EOL> if header_rgx . match ( c . tag ) : <EOL>", "answer": "if not \"<STR_LIT:id>\" in c . attrib :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> import json <EOL> except ImportError : <EOL> import simplejson as json <EOL> import urllib2 <EOL> import diamond . collector <EOL> class SidekiqWebCollector ( diamond . collector . Collector ) : <EOL> def get_default_config_help ( self ) : <EOL> config_help = super ( SidekiqWebCollector , self ) . get_default_config_help ( ) <EOL> config_help . update ( { <EOL> } ) <EOL> return config_help <EOL> def get_default_config ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> config = super ( SidekiqWebCollector , self ) . get_default_config ( ) <EOL> config . update ( { <EOL> '<STR_LIT:host>' : '<STR_LIT:localhost>' , <EOL> '<STR_LIT:port>' : <NUM_LIT> , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> } ) <EOL> return config <EOL> def collect ( self ) : <EOL> try : <EOL> response = urllib2 . urlopen ( \"<STR_LIT>\" % ( <EOL> self . config [ '<STR_LIT:host>' ] , int ( self . config [ '<STR_LIT:port>' ] ) ) ) <EOL> except Exception , e : <EOL> self . log . error ( '<STR_LIT>' , e ) <EOL> return { } <EOL> try : <EOL> j = json . loads ( response . read ( ) ) <EOL> except Exception , e : <EOL> self . log . error ( '<STR_LIT>' , e ) <EOL> return { } <EOL> for k in j : <EOL> for item , value in j [ k ] . items ( ) : <EOL> if isinstance ( value , ( str , unicode ) ) and '<STR_LIT:M>' in value : <EOL>", "answer": "value = float ( value . replace ( '<STR_LIT:M>' , '<STR_LIT>' ) )"}, {"prompt": "<s> from django . dispatch import Signal <EOL> post_schema_sync = Signal ( providing_args = [ '<STR_LIT>' ] ) <EOL>", "answer": "post_schema_sync . __doc__ = \"\"\"<STR_LIT>\"\"\" "}, {"prompt": "<s> import os <EOL> import copy <EOL> import operator <EOL> import functools <EOL> from . import date <EOL> from . functional import memoize , immutable , identity , soak , vectorize <EOL> from . server import single_serve <EOL> from . string import format , affix , paste , cut <EOL> try : <EOL> basestring = basestring <EOL> unicode = unicode <EOL> input = raw_input <EOL> except NameError : <EOL>", "answer": "basestring = str"}, {"prompt": "<s> import warnings <EOL> warnings . warn ( \"<STR_LIT>\" , <EOL> category = PendingDeprecationWarning ) <EOL> import win32con <EOL> import regutil <EOL>", "answer": "import win32api"}, {"prompt": "<s> from director import transformUtils <EOL> from director import affordanceitems <EOL> from urdf_parser_py import urdf <EOL> def geometryFromAffordance ( aff ) : <EOL> if isinstance ( aff , affordanceitems . SphereAffordanceItem ) : <EOL> radius = aff . getProperty ( '<STR_LIT>' ) <EOL> return urdf . Sphere ( radius = radius ) <EOL> if isinstance ( aff , affordanceitems . BoxAffordanceItem ) : <EOL> dimensions = aff . getProperty ( '<STR_LIT>' ) <EOL> return urdf . Box ( size = dimensions ) <EOL> if isinstance ( aff , affordanceitems . CylinderAffordanceItem ) : <EOL> return urdf . Cylinder ( length = aff . getProperty ( '<STR_LIT>' ) , radius = aff . getProperty ( '<STR_LIT>' ) ) <EOL> if isinstance ( aff , affordanceitems . CapsuleAffordanceItem ) : <EOL> return urdf . Cylinder ( length = aff . getProperty ( '<STR_LIT>' ) , radius = aff . getProperty ( '<STR_LIT>' ) ) <EOL> if isinstance ( aff , affordanceitems . CapsuleRingAffordanceItem ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> if isinstance ( aff , affordanceitems . MeshAffordanceItem ) : <EOL> filename = aff . getProperty ( '<STR_LIT>' ) <EOL> filename = affordanceitems . MeshAffordanceItem . getMeshManager ( ) . getFilesystemFilename ( filename ) <EOL> return urdf . Mesh ( filename = filename , scale = [ <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> ] ) <EOL> def stringWithAffordanceId ( inputStr , aff ) : <EOL> return inputStr % aff . getProperty ( '<STR_LIT>' ) <EOL> def stringWithAffordanceName ( inputStr , aff ) : <EOL> return inputStr % aff . getProperty ( '<STR_LIT:Name>' ) <EOL> def colorFromAffordance ( aff ) : <EOL> color = aff . getProperty ( '<STR_LIT>' ) <EOL> return urdf . Color ( color [ <NUM_LIT:0> ] , color [ <NUM_LIT:1> ] , color [ <NUM_LIT:2> ] , <NUM_LIT:1> ) <EOL> def materialFromAffordance ( aff ) : <EOL> color = colorFromAffordance ( aff ) <EOL> return urdf . Material ( name = stringWithAffordanceId ( '<STR_LIT>' , aff ) , color = color , texture = None ) <EOL> def poseFromAffordance ( aff ) : <EOL> t = aff . getChildFrame ( ) . transform <EOL> position , quat = transformUtils . poseFromTransform ( t ) <EOL> rpy = transformUtils . rollPitchYawFromTransform ( t ) <EOL> return urdf . Pose ( position , rpy ) <EOL> def linkFromAffordance ( aff ) : <EOL> geometry = geometryFromAffordance ( aff ) <EOL> material = materialFromAffordance ( aff ) <EOL> pose = poseFromAffordance ( aff ) <EOL>", "answer": "visual = urdf . Visual ( geometry = geometry , material = material , origin = pose )"}, {"prompt": "<s> from django . conf import settings <EOL> from django . contrib . sites . models import Site , RequestSite , get_current_site <EOL> from django . core . exceptions import ObjectDoesNotExist <EOL> from django . http import HttpRequest <EOL> from django . test import TestCase <EOL> class SitesFrameworkTests ( TestCase ) : <EOL> def setUp ( self ) : <EOL> Site ( id = settings . SITE_ID , domain = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) . save ( ) <EOL> self . old_Site_meta_installed = Site . _meta . installed <EOL>", "answer": "Site . _meta . installed = True"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from cafe . drivers . unittest . decorators import tags <EOL> from cloudcafe . compute . common . exceptions import BadRequest , ItemNotFound <EOL> from cloudcafe . common . tools . datagen import rand_name <EOL> from cloudroast . compute . fixtures import ComputeFixture <EOL> class ServersNegativeTest ( ComputeFixture ) : <EOL> @ tags ( type = '<STR_LIT>' , net = '<STR_LIT>' ) <EOL> def test_server_name_blank ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with self . assertRaises ( BadRequest ) : <EOL> self . servers_client . create_server ( '<STR_LIT>' , self . image_ref , <EOL> self . flavor_ref ) <EOL> @ tags ( type = '<STR_LIT>' , net = '<STR_LIT>' ) <EOL> def test_personality_file_contents_not_encoded ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> file_contents = '<STR_LIT>' <EOL> personality = [ { '<STR_LIT:path>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : file_contents } ] <EOL> with self . assertRaises ( BadRequest ) : <EOL> self . servers_client . create_server ( <EOL> '<STR_LIT>' , self . image_ref , self . flavor_ref , <EOL> personality = personality ) <EOL> @ tags ( type = '<STR_LIT>' , net = '<STR_LIT>' ) <EOL> def test_invalid_ip_v4_access_address ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> accessIPv4 = '<STR_LIT>' <EOL> name = rand_name ( \"<STR_LIT>\" ) <EOL> with self . assertRaises ( BadRequest ) : <EOL> self . servers_client . create_server ( <EOL> name , self . image_ref , self . flavor_ref , accessIPv4 = accessIPv4 ) <EOL>", "answer": "@ tags ( type = '<STR_LIT>' , net = '<STR_LIT>' )"}, {"prompt": "<s> from time import sleep <EOL> from tornado import ioloop <EOL> from tornado . httpclient import AsyncHTTPClient , HTTPClient , HTTPError <EOL> from framework . http . wafbypasser . core . http_helper import HTTPHelper <EOL> class Fuzzer : <EOL> def __init__ ( self , http_helper ) : <EOL> self . req_num = <NUM_LIT:0> <EOL> self . resp_num = <NUM_LIT:0> <EOL> self . responses = [ ] <EOL> self . http_helper = http_helper <EOL> def reset ( self ) : <EOL> self . req_num = <NUM_LIT:0> <EOL> self . resp_num = <NUM_LIT:0> <EOL> self . responses = [ ] <EOL> def async_fuzz ( self , requests ) : <EOL> '''<STR_LIT>''' <EOL> self . reset ( ) <EOL> http_client = AsyncHTTPClient ( ) <EOL> self . req_num = len ( requests ) <EOL> self . resp_num = <NUM_LIT:0> <EOL> for request in requests : <EOL> http_client . fetch ( request , self . handle_response ) <EOL> ioloop . IOLoop . instance ( ) . start ( ) <EOL> return self . responses <EOL> def handle_response ( self , response ) : <EOL> '''<STR_LIT>''' <EOL> self . resp_num += <NUM_LIT:1> <EOL> self . responses . append ( response ) <EOL> if self . resp_num == self . req_num : <EOL> ioloop . IOLoop . instance ( ) . stop ( ) <EOL> def sync_fuzz ( self , requests , delay = <NUM_LIT:0> , follow_cookies = True ) : <EOL> '''<STR_LIT>''' <EOL> self . reset ( ) <EOL> http_client = HTTPClient ( ) <EOL> cookie = None <EOL> for request in requests : <EOL> try : <EOL> if follow_cookies and cookie : <EOL> request . headers = HTTPHelper . add_header_param ( <EOL> request . header , <EOL> \"<STR_LIT>\" , <EOL> cookie ) <EOL> response = http_client . fetch ( request ) <EOL> except HTTPError as e : <EOL> if e . response : <EOL> response = e . response <EOL> self . responses . append ( response ) <EOL> if follow_cookies : <EOL>", "answer": "if \"<STR_LIT>\" in response . headers :"}, {"prompt": "<s> import uuid <EOL> from django . test import TestCase , SimpleTestCase <EOL> from fakecouch import FakeCouchDb <EOL> from corehq . apps . domain . shortcuts import create_domain <EOL> from corehq . apps . locations . models import SQLLocation , LocationType , Location <EOL> from corehq . apps . userreports . expressions . factory import ExpressionFactory <EOL> from corehq . apps . userreports . specs import EvaluationContext <EOL> class TestLocationTypeExpression ( TestCase ) : <EOL> @ classmethod <EOL> def setUpClass ( cls ) : <EOL> cls . domain_name = \"<STR_LIT>\" <EOL> cls . domain_obj = create_domain ( cls . domain_name ) <EOL> cls . location_type = LocationType ( <EOL> domain = cls . domain_name , <EOL> name = \"<STR_LIT:state>\" , <EOL> code = \"<STR_LIT:state>\" , <EOL> ) <EOL> cls . location_type . save ( ) <EOL> cls . location = SQLLocation ( <EOL> domain = \"<STR_LIT>\" , <EOL> name = \"<STR_LIT>\" , <EOL> location_type = cls . location_type <EOL> ) <EOL> cls . location . save ( ) <EOL> cls . unique_id = cls . location . location_id <EOL> cls . spec = { <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> } <EOL> cls . expression = ExpressionFactory . from_spec ( cls . spec ) <EOL> @ classmethod <EOL> def tearDownClass ( cls ) : <EOL> cls . domain_obj . delete ( ) <EOL> def _check_expression ( self , doc , expected , domain = None ) : <EOL> domain = domain or self . domain_name <EOL> self . assertEqual ( <EOL> expected , <EOL> self . expression ( <EOL> doc , <EOL> context = EvaluationContext ( { \"<STR_LIT>\" : domain } , <NUM_LIT:0> ) <EOL> ) <EOL> ) <EOL> def test_location_type_expression ( self ) : <EOL> doc = { \"<STR_LIT>\" : self . unique_id } <EOL> self . _check_expression ( doc , \"<STR_LIT:state>\" ) <EOL> def test_bad_domain ( self ) : <EOL> doc = { \"<STR_LIT>\" : self . unique_id } <EOL> self . _check_expression ( doc , None , domain = \"<STR_LIT>\" ) <EOL> def test_bad_doc ( self ) : <EOL> doc = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> self . _check_expression ( doc , None ) <EOL> def test_location_not_found ( self ) : <EOL> doc = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> self . _check_expression ( doc , None ) <EOL> class TestLocationParentIdExpression ( SimpleTestCase ) : <EOL> def setUp ( self ) : <EOL> self . domain = '<STR_LIT>' <EOL> self . evaluation_context = EvaluationContext ( { \"<STR_LIT>\" : self . domain } ) <EOL> self . orig_db = Location . get_db ( ) <EOL> self . database = FakeCouchDb ( ) <EOL> Location . set_db ( self . database ) <EOL> self . parent = self . _make_location ( _id = uuid . uuid4 ( ) . hex ) <EOL> self . child = self . _make_location ( <EOL> _id = uuid . uuid4 ( ) . hex , <EOL> lineage = [ self . parent . _id ] <EOL> ) <EOL> self . grandchild = self . _make_location ( <EOL> _id = uuid . uuid4 ( ) . hex , <EOL> lineage = [ self . child . _id , self . parent . _id ] <EOL> ) <EOL> self . expression_spec = { <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL>", "answer": "}"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import migrations , models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL>", "answer": "( '<STR_LIT>' , '<STR_LIT>' ) ,"}, {"prompt": "<s> from django_openid_auth . views import login_begin as django_login_begin , login_complete <EOL> from desktop . lib . django_util import render <EOL> from django . core import urlresolvers <EOL> import libopenid . conf <EOL> from libopenid . backend import OpenIDBackend <EOL> from libopenid . forms import OpenIDLoginFormExt <EOL> from django . conf import settings <EOL> import logging <EOL> from django . shortcuts import render_to_response <EOL> from django . template import RequestContext <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def login_begin ( request ) : <EOL> redirect_to = request . REQUEST . get ( '<STR_LIT>' , '<STR_LIT:/>' ) <EOL> is_first_login_ever = OpenIDBackend . is_first_login_ever ( ) <EOL> request . session . set_test_cookie ( ) <EOL> openid_url = getattr ( settings , '<STR_LIT>' , None ) <EOL> identity_url_prefix = getattr ( settings , '<STR_LIT>' , None ) <EOL> if openid_url is not None : <EOL> if request . method == '<STR_LIT:GET>' : <EOL> return render_to_response ( '<STR_LIT>' , { <EOL> '<STR_LIT:action>' : urlresolvers . reverse ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : redirect_to , <EOL> '<STR_LIT>' : is_first_login_ever , <EOL> '<STR_LIT>' : True <EOL> } , context_instance = RequestContext ( request ) ) <EOL> return django_login_begin ( request , template_name = '<STR_LIT>' , form_class = OpenIDLoginFormExt ) <EOL> setattr ( login_begin , '<STR_LIT>' , True ) <EOL>", "answer": "setattr ( login_complete , '<STR_LIT>' , True ) "}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . core . cache import cache <EOL> from django . test import TestCase , RequestFactory <EOL> from django . core . urlresolvers import reverse <EOL> from ... core . tests import utils <EOL> from . models import TopicUnread <EOL> from ... comment . bookmark . models import CommentBookmark <EOL> class TopicUnreadViewTest ( TestCase ) : <EOL> def setUp ( self ) : <EOL> cache . clear ( ) <EOL> self . user = utils . create_user ( ) <EOL> self . user2 = utils . create_user ( ) <EOL> self . category = utils . create_category ( ) <EOL> self . topic = utils . create_topic ( self . category ) <EOL> self . topic2 = utils . create_topic ( self . category , user = self . user ) <EOL> self . topic3 = utils . create_topic ( self . category , user = self . user ) <EOL> self . topic4 = utils . create_topic ( self . category , user = self . user ) <EOL> self . topic_unread = TopicUnread . objects . create ( user = self . user , topic = self . topic ) <EOL> self . topic_unread2 = TopicUnread . objects . create ( user = self . user , topic = self . topic2 ) <EOL> self . topic_unread4 = TopicUnread . objects . create ( user = self . user , topic = self . topic4 ) <EOL> self . topic_unread5 = TopicUnread . objects . create ( user = self . user2 , topic = self . topic ) <EOL> def test_topic_unread_list ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> TopicUnread . objects . filter ( pk__in = [ self . topic_unread . pk , self . topic_unread2 . pk ] ) . update ( is_read = False ) <EOL> utils . login ( self ) <EOL> response = self . client . get ( reverse ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( list ( response . context [ '<STR_LIT>' ] ) , [ self . topic2 , self . topic ] ) <EOL> response = self . client . get ( reverse ( '<STR_LIT>' ) + \"<STR_LIT>\" + str ( self . topic2 . pk ) ) <EOL> self . assertEqual ( list ( response . context [ '<STR_LIT>' ] ) , [ self . topic , ] ) <EOL> def test_topic_unread_list_show_private_topic ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> TopicUnread . objects . all ( ) . delete ( ) <EOL> topic_a = utils . create_private_topic ( user = self . user ) <EOL> TopicUnread . objects . create ( user = self . user , topic = topic_a . topic , is_read = False ) <EOL> utils . login ( self ) <EOL> response = self . client . get ( reverse ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( list ( response . context [ '<STR_LIT>' ] ) , [ topic_a . topic , ] ) <EOL> def test_topic_unread_list_dont_show_removed_or_no_access ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> TopicUnread . objects . all ( ) . delete ( ) <EOL> category = utils . create_category ( ) <EOL> category_removed = utils . create_category ( is_removed = True ) <EOL> subcategory = utils . create_category ( parent = category_removed ) <EOL> subcategory_removed = utils . create_category ( parent = category , is_removed = True ) <EOL> topic_a = utils . create_private_topic ( ) <EOL> topic_b = utils . create_topic ( category = category , is_removed = True ) <EOL> topic_c = utils . create_topic ( category = category_removed ) <EOL> topic_d = utils . create_topic ( category = subcategory ) <EOL> topic_e = utils . create_topic ( category = subcategory_removed ) <EOL> TopicUnread . objects . create ( user = self . user , topic = topic_a . topic , is_read = False ) <EOL> TopicUnread . objects . create ( user = self . user , topic = topic_b , is_read = False ) <EOL> TopicUnread . objects . create ( user = self . user , topic = topic_c , is_read = False ) <EOL> TopicUnread . objects . create ( user = self . user , topic = topic_d , is_read = False ) <EOL> TopicUnread . objects . create ( user = self . user , topic = topic_e , is_read = False ) <EOL> utils . login ( self ) <EOL> response = self . client . get ( reverse ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( list ( response . context [ '<STR_LIT>' ] ) , [ ] ) <EOL> def test_topic_unread_list_invalid_topic_id ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> utils . login ( self ) <EOL> last_pk = TopicUnread . objects . order_by ( \"<STR_LIT>\" ) . last ( ) . pk <EOL> response = self . client . get ( reverse ( '<STR_LIT>' ) + \"<STR_LIT>\" + str ( last_pk + <NUM_LIT:1> ) ) <EOL> self . assertEqual ( response . status_code , <NUM_LIT> ) <EOL> def test_topic_unread_list_empty_first_page ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> utils . login ( self ) <EOL> response = self . client . get ( reverse ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( response . status_code , <NUM_LIT:200> ) <EOL> self . assertEqual ( list ( response . context [ '<STR_LIT>' ] ) , [ ] ) <EOL> def test_topic_unread_list_empty_page ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> utils . login ( self ) <EOL> response = self . client . get ( reverse ( '<STR_LIT>' ) + \"<STR_LIT>\" + str ( self . topic . pk ) ) <EOL> self . assertEqual ( response . status_code , <NUM_LIT> ) <EOL> def test_topic_unread_list_bookmarks ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> TopicUnread . objects . filter ( pk__in = [ self . topic_unread . pk , self . topic_unread2 . pk ] ) . update ( is_read = False ) <EOL> bookmark = CommentBookmark . objects . create ( topic = self . topic2 , user = self . user ) <EOL> utils . login ( self ) <EOL> response = self . client . get ( reverse ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( list ( response . context [ '<STR_LIT>' ] ) , [ self . topic2 , self . topic ] ) <EOL> self . assertEqual ( response . context [ '<STR_LIT>' ] [ <NUM_LIT:0> ] . bookmark , bookmark ) <EOL> class TopicUnreadModelsTest ( TestCase ) : <EOL> def setUp ( self ) : <EOL> cache . clear ( ) <EOL> self . user = utils . create_user ( ) <EOL> self . user2 = utils . create_user ( ) <EOL> self . category = utils . create_category ( ) <EOL> self . topic = utils . create_topic ( self . category ) <EOL>", "answer": "self . topic2 = utils . create_topic ( self . category , user = self . user )"}, {"prompt": "<s> class CORSRule ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , allowed_method = None , allowed_origin = None , <EOL> id = None , allowed_header = None , max_age_seconds = None , <EOL> expose_header = None ) : <EOL> if allowed_method is None : <EOL> allowed_method = [ ] <EOL> self . allowed_method = allowed_method <EOL> if allowed_origin is None : <EOL> allowed_origin = [ ] <EOL> self . allowed_origin = allowed_origin <EOL> self . id = id <EOL> if allowed_header is None : <EOL> allowed_header = [ ] <EOL> self . allowed_header = allowed_header <EOL> self . max_age_seconds = max_age_seconds <EOL> if expose_header is None : <EOL> expose_header = [ ] <EOL> self . expose_header = expose_header <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % self . id <EOL> def startElement ( self , name , attrs , connection ) : <EOL> return None <EOL> def endElement ( self , name , value , connection ) : <EOL> if name == '<STR_LIT>' : <EOL> self . id = value <EOL> elif name == '<STR_LIT>' : <EOL> self . allowed_method . append ( value ) <EOL> elif name == '<STR_LIT>' : <EOL> self . allowed_origin . append ( value ) <EOL> elif name == '<STR_LIT>' : <EOL> self . allowed_header . append ( value ) <EOL> elif name == '<STR_LIT>' : <EOL> self . max_age_seconds = int ( value ) <EOL> elif name == '<STR_LIT>' : <EOL> self . expose_header . append ( value ) <EOL> else : <EOL> setattr ( self , name , value ) <EOL> def to_xml ( self ) : <EOL> s = '<STR_LIT>' <EOL> for allowed_method in self . allowed_method : <EOL> s += '<STR_LIT>' % allowed_method <EOL> for allowed_origin in self . allowed_origin : <EOL> s += '<STR_LIT>' % allowed_origin <EOL> for allowed_header in self . allowed_header : <EOL> s += '<STR_LIT>' % allowed_header <EOL> for expose_header in self . expose_header : <EOL> s += '<STR_LIT>' % expose_header <EOL> if self . max_age_seconds : <EOL> s += '<STR_LIT>' % self . max_age_seconds <EOL> if self . id : <EOL> s += '<STR_LIT>' % self . id <EOL> s += '<STR_LIT>' <EOL> return s <EOL> class CORSConfiguration ( list ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def startElement ( self , name , attrs , connection ) : <EOL> if name == '<STR_LIT>' : <EOL> rule = CORSRule ( ) <EOL> self . append ( rule ) <EOL> return rule <EOL> return None <EOL> def endElement ( self , name , value , connection ) : <EOL>", "answer": "setattr ( self , name , value )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import copy <EOL> import json <EOL> import os <EOL> import shutil <EOL> import tempfile <EOL> import xml . dom . minidom as minidom <EOL> import mox <EOL> import stubout <EOL> import webob <EOL> from glance import client as glance_client <EOL> from nova import context <EOL> from nova import exception <EOL> from nova import test <EOL> from nova import utils <EOL> import nova . api . openstack <EOL> from nova . api . openstack import images <EOL> from nova . tests . api . openstack import fakes <EOL> class _BaseImageServiceTests ( test . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( _BaseImageServiceTests , self ) . __init__ ( * args , ** kwargs ) <EOL> self . service = None <EOL> self . context = None <EOL> def test_create ( self ) : <EOL> fixture = self . _make_fixture ( '<STR_LIT>' ) <EOL> num_images = len ( self . service . index ( self . context ) ) <EOL> image_id = self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] <EOL> self . assertNotEquals ( None , image_id ) <EOL> self . assertEquals ( num_images + <NUM_LIT:1> , <EOL> len ( self . service . index ( self . context ) ) ) <EOL> def test_create_and_show_non_existing_image ( self ) : <EOL> fixture = self . _make_fixture ( '<STR_LIT>' ) <EOL> num_images = len ( self . service . index ( self . context ) ) <EOL> image_id = self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] <EOL> self . assertNotEquals ( None , image_id ) <EOL> self . assertRaises ( exception . NotFound , <EOL> self . service . show , <EOL> self . context , <EOL> '<STR_LIT>' ) <EOL> def test_create_and_show_non_existing_image_by_name ( self ) : <EOL> fixture = self . _make_fixture ( '<STR_LIT>' ) <EOL> num_images = len ( self . service . index ( self . context ) ) <EOL> image_id = self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] <EOL> self . assertNotEquals ( None , image_id ) <EOL> self . assertRaises ( exception . ImageNotFound , <EOL> self . service . show_by_name , <EOL> self . context , <EOL> '<STR_LIT>' ) <EOL> def test_update ( self ) : <EOL> fixture = self . _make_fixture ( '<STR_LIT>' ) <EOL> image_id = self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] <EOL> fixture [ '<STR_LIT:status>' ] = '<STR_LIT>' <EOL> self . service . update ( self . context , image_id , fixture ) <EOL> new_image_data = self . service . show ( self . context , image_id ) <EOL> self . assertEquals ( '<STR_LIT>' , new_image_data [ '<STR_LIT:status>' ] ) <EOL> def test_delete ( self ) : <EOL> fixture1 = self . _make_fixture ( '<STR_LIT>' ) <EOL> fixture2 = self . _make_fixture ( '<STR_LIT>' ) <EOL> fixtures = [ fixture1 , fixture2 ] <EOL> num_images = len ( self . service . index ( self . context ) ) <EOL> self . assertEquals ( <NUM_LIT:0> , num_images , str ( self . service . index ( self . context ) ) ) <EOL> ids = [ ] <EOL> for fixture in fixtures : <EOL> new_id = self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] <EOL> ids . append ( new_id ) <EOL> num_images = len ( self . service . index ( self . context ) ) <EOL> self . assertEquals ( <NUM_LIT:2> , num_images , str ( self . service . index ( self . context ) ) ) <EOL> self . service . delete ( self . context , ids [ <NUM_LIT:0> ] ) <EOL> num_images = len ( self . service . index ( self . context ) ) <EOL> self . assertEquals ( <NUM_LIT:1> , num_images ) <EOL> def test_index ( self ) : <EOL> fixture = self . _make_fixture ( '<STR_LIT>' ) <EOL> image_id = self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] <EOL> image_metas = self . service . index ( self . context ) <EOL> expected = [ { '<STR_LIT:id>' : '<STR_LIT>' , '<STR_LIT:name>' : '<STR_LIT>' } ] <EOL> self . assertDictListMatch ( image_metas , expected ) <EOL> @ staticmethod <EOL> def _make_fixture ( name ) : <EOL> fixture = { '<STR_LIT:name>' : name , <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT:status>' : None , <EOL> '<STR_LIT>' : True } <EOL> return fixture <EOL> class GlanceImageServiceTest ( _BaseImageServiceTests ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> super ( GlanceImageServiceTest , self ) . setUp ( ) <EOL> self . stubs = stubout . StubOutForTesting ( ) <EOL> fakes . stub_out_glance ( self . stubs ) <EOL> fakes . stub_out_compute_api_snapshot ( self . stubs ) <EOL> service_class = '<STR_LIT>' <EOL> self . service = utils . import_object ( service_class ) <EOL> self . context = context . RequestContext ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . service . delete_all ( ) <EOL> self . sent_to_glance = { } <EOL> fakes . stub_out_glance_add_image ( self . stubs , self . sent_to_glance ) <EOL> def tearDown ( self ) : <EOL> self . stubs . UnsetAll ( ) <EOL> super ( GlanceImageServiceTest , self ) . tearDown ( ) <EOL> def test_create_with_instance_id ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fixture = { '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } } <EOL> image_id = self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] <EOL> expected = fixture <EOL> self . assertDictMatch ( self . sent_to_glance [ '<STR_LIT>' ] , expected ) <EOL> image_meta = self . service . show ( self . context , image_id ) <EOL> expected = { '<STR_LIT:id>' : image_id , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } } <EOL> self . assertDictMatch ( image_meta , expected ) <EOL> image_metas = self . service . detail ( self . context ) <EOL> self . assertDictMatch ( image_metas [ <NUM_LIT:0> ] , expected ) <EOL> def test_create_without_instance_id ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fixture = { '<STR_LIT:name>' : '<STR_LIT>' } <EOL> image_id = self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] <EOL> expected = { '<STR_LIT:name>' : '<STR_LIT>' , '<STR_LIT>' : { } } <EOL> self . assertDictMatch ( self . sent_to_glance [ '<STR_LIT>' ] , expected ) <EOL> def test_index_default_limit ( self ) : <EOL> fixtures = [ ] <EOL> ids = [ ] <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> fixture = self . _make_fixture ( '<STR_LIT>' % ( i ) ) <EOL> fixtures . append ( fixture ) <EOL> ids . append ( self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] ) <EOL> image_metas = self . service . index ( self . context ) <EOL> i = <NUM_LIT:0> <EOL> for meta in image_metas : <EOL> expected = { '<STR_LIT:id>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' % ( i ) } <EOL> self . assertDictMatch ( meta , expected ) <EOL> i = i + <NUM_LIT:1> <EOL> def test_index_marker ( self ) : <EOL> fixtures = [ ] <EOL> ids = [ ] <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> fixture = self . _make_fixture ( '<STR_LIT>' % ( i ) ) <EOL> fixtures . append ( fixture ) <EOL> ids . append ( self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] ) <EOL> image_metas = self . service . index ( self . context , marker = ids [ <NUM_LIT:1> ] ) <EOL> self . assertEquals ( len ( image_metas ) , <NUM_LIT:8> ) <EOL> i = <NUM_LIT:2> <EOL> for meta in image_metas : <EOL> expected = { '<STR_LIT:id>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' % ( i ) } <EOL> self . assertDictMatch ( meta , expected ) <EOL> i = i + <NUM_LIT:1> <EOL> def test_index_limit ( self ) : <EOL> fixtures = [ ] <EOL> ids = [ ] <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> fixture = self . _make_fixture ( '<STR_LIT>' % ( i ) ) <EOL> fixtures . append ( fixture ) <EOL> ids . append ( self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] ) <EOL> image_metas = self . service . index ( self . context , limit = <NUM_LIT:3> ) <EOL> self . assertEquals ( len ( image_metas ) , <NUM_LIT:3> ) <EOL> def test_index_marker_and_limit ( self ) : <EOL> fixtures = [ ] <EOL> ids = [ ] <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> fixture = self . _make_fixture ( '<STR_LIT>' % ( i ) ) <EOL> fixtures . append ( fixture ) <EOL> ids . append ( self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] ) <EOL> image_metas = self . service . index ( self . context , marker = ids [ <NUM_LIT:3> ] , limit = <NUM_LIT:1> ) <EOL> self . assertEquals ( len ( image_metas ) , <NUM_LIT:1> ) <EOL> i = <NUM_LIT:4> <EOL> for meta in image_metas : <EOL> expected = { '<STR_LIT:id>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' % ( i ) } <EOL> self . assertDictMatch ( meta , expected ) <EOL> i = i + <NUM_LIT:1> <EOL> def test_detail_marker ( self ) : <EOL> fixtures = [ ] <EOL> ids = [ ] <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> fixture = self . _make_fixture ( '<STR_LIT>' % ( i ) ) <EOL> fixtures . append ( fixture ) <EOL> ids . append ( self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] ) <EOL> image_metas = self . service . detail ( self . context , marker = ids [ <NUM_LIT:1> ] ) <EOL> self . assertEquals ( len ( image_metas ) , <NUM_LIT:8> ) <EOL> i = <NUM_LIT:2> <EOL> for meta in image_metas : <EOL> expected = { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> '<STR_LIT:status>' : None , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT:name>' : '<STR_LIT>' % ( i ) , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> } , <EOL> } <EOL> self . assertDictMatch ( meta , expected ) <EOL> i = i + <NUM_LIT:1> <EOL> def test_detail_limit ( self ) : <EOL> fixtures = [ ] <EOL> ids = [ ] <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> fixture = self . _make_fixture ( '<STR_LIT>' % ( i ) ) <EOL> fixtures . append ( fixture ) <EOL> ids . append ( self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] ) <EOL> image_metas = self . service . detail ( self . context , limit = <NUM_LIT:3> ) <EOL> self . assertEquals ( len ( image_metas ) , <NUM_LIT:3> ) <EOL> def test_detail_marker_and_limit ( self ) : <EOL> fixtures = [ ] <EOL> ids = [ ] <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> fixture = self . _make_fixture ( '<STR_LIT>' % ( i ) ) <EOL> fixtures . append ( fixture ) <EOL> ids . append ( self . service . create ( self . context , fixture ) [ '<STR_LIT:id>' ] ) <EOL> image_metas = self . service . detail ( self . context , marker = ids [ <NUM_LIT:3> ] , limit = <NUM_LIT:3> ) <EOL> self . assertEquals ( len ( image_metas ) , <NUM_LIT:3> ) <EOL> i = <NUM_LIT:4> <EOL> for meta in image_metas : <EOL> expected = { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> '<STR_LIT:status>' : None , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT:name>' : '<STR_LIT>' % ( i ) , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : None , '<STR_LIT>' : None } , <EOL> } <EOL> self . assertDictMatch ( meta , expected ) <EOL> i = i + <NUM_LIT:1> <EOL> class ImageControllerWithGlanceServiceTest ( test . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> NOW_GLANCE_FORMAT = \"<STR_LIT>\" <EOL> NOW_API_FORMAT = \"<STR_LIT>\" <EOL> def setUp ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( ImageControllerWithGlanceServiceTest , self ) . setUp ( ) <EOL> self . flags ( image_service = '<STR_LIT>' ) <EOL> self . stubs = stubout . StubOutForTesting ( ) <EOL> fakes . stub_out_networking ( self . stubs ) <EOL> fakes . stub_out_rate_limiting ( self . stubs ) <EOL> fakes . stub_out_key_pair_funcs ( self . stubs ) <EOL> self . fixtures = self . _make_image_fixtures ( ) <EOL> fakes . stub_out_glance ( self . stubs , initial_fixtures = self . fixtures ) <EOL> fakes . stub_out_compute_api_snapshot ( self . stubs ) <EOL> fakes . stub_out_compute_api_backup ( self . stubs ) <EOL> def tearDown ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . stubs . UnsetAll ( ) <EOL> super ( ImageControllerWithGlanceServiceTest , self ) . tearDown ( ) <EOL> def _get_fake_context ( self ) : <EOL> class Context ( object ) : <EOL> project_id = '<STR_LIT>' <EOL> return Context ( ) <EOL> def _applicable_fixture ( self , fixture , user_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> is_public = fixture [ \"<STR_LIT>\" ] <EOL> try : <EOL> uid = fixture [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> except KeyError : <EOL> uid = None <EOL> return uid == user_id or is_public <EOL> def test_get_image_index ( self ) : <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> response = request . get_response ( fakes . wsgi_app ( ) ) <EOL> response_dict = json . loads ( response . body ) <EOL> response_list = response_dict [ \"<STR_LIT>\" ] <EOL> expected = [ { '<STR_LIT:id>' : <NUM_LIT> , '<STR_LIT:name>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:id>' : <NUM_LIT> , '<STR_LIT:name>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:id>' : <NUM_LIT> , '<STR_LIT:name>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:id>' : <NUM_LIT> , '<STR_LIT:name>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:id>' : <NUM_LIT> , '<STR_LIT:name>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:id>' : <NUM_LIT> , '<STR_LIT:name>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:id>' : <NUM_LIT> , '<STR_LIT:name>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:id>' : <NUM_LIT> , '<STR_LIT:name>' : None } ] <EOL> self . assertDictListMatch ( response_list , expected ) <EOL> def test_get_image ( self ) : <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> response = request . get_response ( fakes . wsgi_app ( ) ) <EOL> self . assertEqual ( <NUM_LIT:200> , response . status_int ) <EOL> actual_image = json . loads ( response . body ) <EOL> expected_image = { <EOL> \"<STR_LIT:image>\" : { <EOL> \"<STR_LIT:id>\" : <NUM_LIT> , <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : self . NOW_API_FORMAT , <EOL> \"<STR_LIT>\" : self . NOW_API_FORMAT , <EOL> \"<STR_LIT:status>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : <NUM_LIT:100> , <EOL> } , <EOL> } <EOL> self . assertEqual ( expected_image , actual_image ) <EOL> def test_get_image_v1_1 ( self ) : <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> response = request . get_response ( fakes . wsgi_app ( ) ) <EOL> actual_image = json . loads ( response . body ) <EOL> href = \"<STR_LIT>\" <EOL> bookmark = \"<STR_LIT>\" <EOL> server_href = \"<STR_LIT>\" <EOL> server_bookmark = \"<STR_LIT>\" <EOL> expected_image = { <EOL> \"<STR_LIT:image>\" : { <EOL> \"<STR_LIT:id>\" : '<STR_LIT>' , <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : self . NOW_API_FORMAT , <EOL> \"<STR_LIT>\" : self . NOW_API_FORMAT , <EOL> \"<STR_LIT:status>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : <NUM_LIT:0> , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : server_href , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : server_bookmark , <EOL> } ] , <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : href , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : bookmark , <EOL> } ] , <EOL> } , <EOL> } <EOL> self . assertEqual ( expected_image , actual_image ) <EOL> def test_get_image_xml ( self ) : <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> request . accept = \"<STR_LIT>\" <EOL> response = request . get_response ( fakes . wsgi_app ( ) ) <EOL> actual_image = minidom . parseString ( response . body . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT>\" ) ) <EOL> expected_now = self . NOW_API_FORMAT <EOL> expected_image = minidom . parseString ( \"\"\"<STR_LIT>\"\"\" % ( locals ( ) ) ) <EOL> self . assertEqual ( expected_image . toxml ( ) , actual_image . toxml ( ) ) <EOL> def test_get_image_xml_no_name ( self ) : <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> request . accept = \"<STR_LIT>\" <EOL> response = request . get_response ( fakes . wsgi_app ( ) ) <EOL> actual_image = minidom . parseString ( response . body . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT>\" ) ) <EOL> expected_now = self . NOW_API_FORMAT <EOL> expected_image = minidom . parseString ( \"\"\"<STR_LIT>\"\"\" % ( locals ( ) ) ) <EOL> self . assertEqual ( expected_image . toxml ( ) , actual_image . toxml ( ) ) <EOL> def test_get_image_404_json ( self ) : <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> response = request . get_response ( fakes . wsgi_app ( ) ) <EOL> self . assertEqual ( <NUM_LIT> , response . status_int ) <EOL> expected = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT:message>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:code>\" : <NUM_LIT> , <EOL> } , <EOL> } <EOL> actual = json . loads ( response . body ) <EOL> self . assertEqual ( expected , actual ) <EOL> def test_get_image_404_xml ( self ) : <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> request . accept = \"<STR_LIT>\" <EOL> response = request . get_response ( fakes . wsgi_app ( ) ) <EOL> self . assertEqual ( <NUM_LIT> , response . status_int ) <EOL> expected = minidom . parseString ( \"\"\"<STR_LIT>\"\"\" . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT>\" ) ) <EOL> actual = minidom . parseString ( response . body . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT>\" ) ) <EOL> self . assertEqual ( expected . toxml ( ) , actual . toxml ( ) ) <EOL> def test_get_image_404_v1_1_json ( self ) : <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> response = request . get_response ( fakes . wsgi_app ( ) ) <EOL> self . assertEqual ( <NUM_LIT> , response . status_int ) <EOL> expected = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT:message>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:code>\" : <NUM_LIT> , <EOL> } , <EOL> } <EOL> actual = json . loads ( response . body ) <EOL> self . assertEqual ( expected , actual ) <EOL> def test_get_image_404_v1_1_xml ( self ) : <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> request . accept = \"<STR_LIT>\" <EOL> response = request . get_response ( fakes . wsgi_app ( ) ) <EOL> self . assertEqual ( <NUM_LIT> , response . status_int ) <EOL> expected = minidom . parseString ( \"\"\"<STR_LIT>\"\"\" . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT>\" ) ) <EOL> actual = minidom . parseString ( response . body . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT>\" ) ) <EOL> self . assertEqual ( expected . toxml ( ) , actual . toxml ( ) ) <EOL> def test_get_image_index_v1_1 ( self ) : <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> response = request . get_response ( fakes . wsgi_app ( ) ) <EOL> response_dict = json . loads ( response . body ) <EOL> response_list = response_dict [ \"<STR_LIT>\" ] <EOL> fixtures = copy . copy ( self . fixtures ) <EOL> for image in fixtures : <EOL> if not self . _applicable_fixture ( image , \"<STR_LIT>\" ) : <EOL> fixtures . remove ( image ) <EOL> continue <EOL> href = \"<STR_LIT>\" % image [ \"<STR_LIT:id>\" ] <EOL> bookmark = \"<STR_LIT>\" % image [ \"<STR_LIT:id>\" ] <EOL> test_image = { <EOL> \"<STR_LIT:id>\" : str ( image [ \"<STR_LIT:id>\" ] ) , <EOL> \"<STR_LIT:name>\" : image [ \"<STR_LIT:name>\" ] , <EOL> \"<STR_LIT>\" : [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : href , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : bookmark , <EOL> } , <EOL> ] , <EOL> } <EOL> self . assertTrue ( test_image in response_list ) <EOL> self . assertEqual ( len ( response_list ) , len ( fixtures ) ) <EOL> def test_get_image_details ( self ) : <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> response = request . get_response ( fakes . wsgi_app ( ) ) <EOL> response_dict = json . loads ( response . body ) <EOL> response_list = response_dict [ \"<STR_LIT>\" ] <EOL> expected = [ { <EOL> '<STR_LIT:id>' : <NUM_LIT> , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:100> , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : <NUM_LIT> , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : <NUM_LIT> , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : <NUM_LIT> , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:100> , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : <NUM_LIT> , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : <NUM_LIT> , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : <NUM_LIT> , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : <NUM_LIT> , <EOL> '<STR_LIT:name>' : None , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:100> , <EOL> } ] <EOL> self . assertDictListMatch ( expected , response_list ) <EOL> def test_get_image_details_v1_1 ( self ) : <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> response = request . get_response ( fakes . wsgi_app ( ) ) <EOL> response_dict = json . loads ( response . body ) <EOL> response_list = response_dict [ \"<STR_LIT>\" ] <EOL> server_href = \"<STR_LIT>\" <EOL> server_bookmark = \"<STR_LIT>\" <EOL> expected = [ { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { } , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:100> , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } ] , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> u'<STR_LIT>' : u'<STR_LIT>' , <EOL> u'<STR_LIT>' : u'<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : server_href , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : server_bookmark , <EOL> } ] , <EOL> } , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } ] , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> u'<STR_LIT>' : u'<STR_LIT>' , <EOL> u'<STR_LIT>' : u'<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : server_href , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : server_bookmark , <EOL> } ] , <EOL> } , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } ] , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> u'<STR_LIT>' : u'<STR_LIT>' , <EOL> u'<STR_LIT>' : u'<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:100> , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : server_href , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : server_bookmark , <EOL> } ] , <EOL> } , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } ] , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> u'<STR_LIT>' : u'<STR_LIT>' , <EOL> u'<STR_LIT>' : u'<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : server_href , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : server_bookmark , <EOL> } ] , <EOL> } , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } ] , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> u'<STR_LIT>' : u'<STR_LIT>' , <EOL> u'<STR_LIT>' : u'<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : server_href , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : server_bookmark , <EOL> } ] , <EOL> } , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } ] , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> u'<STR_LIT>' : u'<STR_LIT>' , <EOL> u'<STR_LIT>' : u'<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:0> , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : server_href , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : server_bookmark , <EOL> } ] , <EOL> } , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } ] , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : None , <EOL> '<STR_LIT>' : { } , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:100> , <EOL> \"<STR_LIT>\" : [ { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } ] , <EOL> } , <EOL> ] <EOL> self . assertDictListMatch ( expected , response_list ) <EOL> def test_image_filter_with_name ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { '<STR_LIT:name>' : '<STR_LIT>' } <EOL> image_service . index ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . index ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_filter_with_status ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { '<STR_LIT:status>' : '<STR_LIT>' } <EOL> image_service . index ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . index ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_filter_with_property ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { '<STR_LIT>' : '<STR_LIT:3>' } <EOL> image_service . index ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . index ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_filter_server ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { '<STR_LIT>' : '<STR_LIT>' } <EOL> image_service . index ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . index ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_filter_changes_since ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { '<STR_LIT>' : '<STR_LIT>' } <EOL> image_service . index ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . index ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_filter_with_type ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { '<STR_LIT>' : '<STR_LIT>' } <EOL> image_service . index ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . index ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_filter_not_supported ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { '<STR_LIT:status>' : '<STR_LIT>' } <EOL> image_service . detail ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . detail ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_no_filters ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { } <EOL> image_service . index ( <EOL> context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( <EOL> '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . index ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_detail_filter_with_name ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { '<STR_LIT:name>' : '<STR_LIT>' } <EOL> image_service . detail ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . detail ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_detail_filter_with_status ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { '<STR_LIT:status>' : '<STR_LIT>' } <EOL> image_service . detail ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . detail ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_detail_filter_with_property ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { '<STR_LIT>' : '<STR_LIT:3>' } <EOL> image_service . detail ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( <EOL> '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . detail ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_detail_filter_server ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { '<STR_LIT>' : '<STR_LIT>' } <EOL> image_service . index ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . index ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_detail_filter_changes_since ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { '<STR_LIT>' : '<STR_LIT>' } <EOL> image_service . index ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . index ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_detail_filter_with_type ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { '<STR_LIT>' : '<STR_LIT>' } <EOL> image_service . index ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . index ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_detail_filter_not_supported ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { '<STR_LIT:status>' : '<STR_LIT>' } <EOL> image_service . detail ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . detail ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_image_detail_no_filters ( self ) : <EOL> image_service = self . mox . CreateMockAnything ( ) <EOL> context = self . _get_fake_context ( ) <EOL> filters = { } <EOL> image_service . detail ( context , filters = filters ) . AndReturn ( [ ] ) <EOL> self . mox . ReplayAll ( ) <EOL> request = webob . Request . blank ( '<STR_LIT>' ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> controller = images . ControllerV11 ( image_service = image_service ) <EOL> controller . detail ( request ) <EOL> self . mox . VerifyAll ( ) <EOL> def test_get_image_found ( self ) : <EOL> req = webob . Request . blank ( '<STR_LIT>' ) <EOL> res = req . get_response ( fakes . wsgi_app ( ) ) <EOL> image_meta = json . loads ( res . body ) [ '<STR_LIT:image>' ] <EOL> expected = { '<STR_LIT:id>' : <NUM_LIT> , '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , <EOL> '<STR_LIT>' : self . NOW_API_FORMAT , '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT:100> } <EOL> self . assertDictMatch ( image_meta , expected ) <EOL> def test_get_image_non_existent ( self ) : <EOL> req = webob . Request . blank ( '<STR_LIT>' ) <EOL> res = req . get_response ( fakes . wsgi_app ( ) ) <EOL> self . assertEqual ( res . status_int , <NUM_LIT> ) <EOL> def test_get_image_not_owned ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> req = webob . Request . blank ( '<STR_LIT>' ) <EOL> res = req . get_response ( fakes . wsgi_app ( ) ) <EOL> self . assertEqual ( res . status_int , <NUM_LIT> ) <EOL> def test_create_image ( self ) : <EOL> body = dict ( image = dict ( serverId = '<STR_LIT>' , name = '<STR_LIT>' ) ) <EOL> req = webob . Request . blank ( '<STR_LIT>' ) <EOL> req . method = '<STR_LIT:POST>' <EOL> req . body = json . dumps ( body ) <EOL> req . headers [ \"<STR_LIT>\" ] = \"<STR_LIT:application/json>\" <EOL> response = req . get_response ( fakes . wsgi_app ( ) ) <EOL> self . assertEqual ( <NUM_LIT:200> , response . status_int ) <EOL> image_meta = json . loads ( response . body ) [ '<STR_LIT:image>' ] <EOL> self . assertEqual ( <NUM_LIT> , image_meta [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( '<STR_LIT>' , image_meta [ '<STR_LIT:name>' ] ) <EOL> def test_create_snapshot_no_name ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> body = dict ( image = dict ( serverId = '<STR_LIT>' ) ) <EOL> req = webob . Request . blank ( '<STR_LIT>' ) <EOL> req . method = '<STR_LIT:POST>' <EOL> req . body = json . dumps ( body ) <EOL> req . headers [ \"<STR_LIT>\" ] = \"<STR_LIT:application/json>\" <EOL> response = req . get_response ( fakes . wsgi_app ( ) ) <EOL> self . assertEqual ( <NUM_LIT> , response . status_int ) <EOL> def test_create_image_no_server_id ( self ) : <EOL> body = dict ( image = dict ( name = '<STR_LIT>' ) ) <EOL> req = webob . Request . blank ( '<STR_LIT>' ) <EOL> req . method = '<STR_LIT:POST>' <EOL> req . body = json . dumps ( body ) <EOL> req . headers [ \"<STR_LIT>\" ] = \"<STR_LIT:application/json>\" <EOL> response = req . get_response ( fakes . wsgi_app ( ) ) <EOL> self . assertEqual ( <NUM_LIT> , response . status_int ) <EOL> def test_create_image_snapshots_disabled ( self ) : <EOL> self . flags ( allow_instance_snapshots = False ) <EOL> body = dict ( image = dict ( serverId = '<STR_LIT>' , name = '<STR_LIT>' ) ) <EOL> req = webob . Request . blank ( '<STR_LIT>' ) <EOL> req . method = '<STR_LIT:POST>' <EOL> req . body = json . dumps ( body ) <EOL> req . headers [ \"<STR_LIT>\" ] = \"<STR_LIT:application/json>\" <EOL> response = req . get_response ( fakes . wsgi_app ( ) ) <EOL> self . assertEqual ( <NUM_LIT> , response . status_int ) <EOL> @ classmethod <EOL> def _make_image_fixtures ( cls ) : <EOL> image_id = <NUM_LIT> <EOL> base_attrs = { '<STR_LIT>' : cls . NOW_GLANCE_FORMAT , <EOL> '<STR_LIT>' : cls . NOW_GLANCE_FORMAT , <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : False } <EOL> fixtures = [ ] <EOL> def add_fixture ( ** kwargs ) : <EOL> kwargs . update ( base_attrs ) <EOL> fixtures . append ( kwargs ) <EOL> add_fixture ( id = image_id , name = '<STR_LIT>' , is_public = True , <EOL> status = '<STR_LIT>' , properties = { } ) <EOL> image_id += <NUM_LIT:1> <EOL> server_ref = '<STR_LIT>' <EOL> snapshot_properties = { '<STR_LIT>' : server_ref , '<STR_LIT>' : '<STR_LIT>' } <EOL> statuses = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> for status in statuses : <EOL> add_fixture ( id = image_id , name = '<STR_LIT>' % status , <EOL> is_public = False , status = status , <EOL> properties = snapshot_properties ) <EOL> image_id += <NUM_LIT:1> <EOL> other_snapshot_properties = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } <EOL> add_fixture ( id = image_id , name = '<STR_LIT>' , <EOL> is_public = False , status = '<STR_LIT>' , <EOL> properties = other_snapshot_properties ) <EOL> image_id += <NUM_LIT:1> <EOL> add_fixture ( id = image_id , is_public = True , status = '<STR_LIT>' , <EOL> properties = { } ) <EOL> image_id += <NUM_LIT:1> <EOL> return fixtures <EOL> class ImageXMLSerializationTest ( test . TestCase ) : <EOL> TIMESTAMP = \"<STR_LIT>\" <EOL> SERVER_HREF = '<STR_LIT>' <EOL> SERVER_BOOKMARK = '<STR_LIT>' <EOL> IMAGE_HREF = '<STR_LIT>' <EOL> IMAGE_BOOKMARK = '<STR_LIT>' <EOL> def test_show ( self ) : <EOL> serializer = images . ImageXMLSerializer ( ) <EOL> fixture = { <EOL> '<STR_LIT:image>' : { <EOL> '<STR_LIT:id>' : <NUM_LIT:1> , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . TIMESTAMP , <EOL> '<STR_LIT>' : self . TIMESTAMP , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:id>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : self . SERVER_HREF , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : self . SERVER_BOOKMARK , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : self . IMAGE_HREF % <NUM_LIT:1> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : self . IMAGE_BOOKMARK % <NUM_LIT:1> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] , <EOL> } , <EOL> } <EOL> output = serializer . serialize ( fixture , '<STR_LIT>' ) <EOL> actual = minidom . parseString ( output . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT>\" ) ) <EOL> expected_server_href = self . SERVER_HREF <EOL> expected_server_bookmark = self . SERVER_BOOKMARK <EOL> expected_href = self . IMAGE_HREF % <NUM_LIT:1> <EOL> expected_bookmark = self . IMAGE_BOOKMARK % <NUM_LIT:1> <EOL> expected_now = self . TIMESTAMP <EOL> expected = minidom . parseString ( \"\"\"<STR_LIT>\"\"\" . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT>\" ) % ( locals ( ) ) ) <EOL> self . assertEqual ( expected . toxml ( ) , actual . toxml ( ) ) <EOL> def test_show_zero_metadata ( self ) : <EOL> serializer = images . ImageXMLSerializer ( ) <EOL> fixture = { <EOL> '<STR_LIT:image>' : { <EOL> '<STR_LIT:id>' : <NUM_LIT:1> , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . TIMESTAMP , <EOL> '<STR_LIT>' : self . TIMESTAMP , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:id>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : self . SERVER_HREF , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : self . SERVER_BOOKMARK , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] , <EOL> } , <EOL> '<STR_LIT>' : { } , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : self . IMAGE_HREF % <NUM_LIT:1> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : self . IMAGE_BOOKMARK % <NUM_LIT:1> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] , <EOL> } , <EOL> } <EOL> output = serializer . serialize ( fixture , '<STR_LIT>' ) <EOL> actual = minidom . parseString ( output . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT>\" ) ) <EOL> expected_server_href = self . SERVER_HREF <EOL> expected_server_bookmark = self . SERVER_BOOKMARK <EOL> expected_href = self . IMAGE_HREF % <NUM_LIT:1> <EOL> expected_bookmark = self . IMAGE_BOOKMARK % <NUM_LIT:1> <EOL> expected_now = self . TIMESTAMP <EOL> expected = minidom . parseString ( \"\"\"<STR_LIT>\"\"\" . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT>\" ) % ( locals ( ) ) ) <EOL> self . assertEqual ( expected . toxml ( ) , actual . toxml ( ) ) <EOL> def test_show_image_no_metadata_key ( self ) : <EOL> serializer = images . ImageXMLSerializer ( ) <EOL> fixture = { <EOL> '<STR_LIT:image>' : { <EOL> '<STR_LIT:id>' : <NUM_LIT:1> , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . TIMESTAMP , <EOL> '<STR_LIT>' : self . TIMESTAMP , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:id>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : self . SERVER_HREF , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : self . SERVER_BOOKMARK , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] , <EOL> } , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : self . IMAGE_HREF % <NUM_LIT:1> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : self . IMAGE_BOOKMARK % <NUM_LIT:1> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] , <EOL> } , <EOL> } <EOL> output = serializer . serialize ( fixture , '<STR_LIT>' ) <EOL> actual = minidom . parseString ( output . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT>\" ) ) <EOL> expected_server_href = self . SERVER_HREF <EOL> expected_server_bookmark = self . SERVER_BOOKMARK <EOL> expected_href = self . IMAGE_HREF % <NUM_LIT:1> <EOL> expected_bookmark = self . IMAGE_BOOKMARK % <NUM_LIT:1> <EOL> expected_now = self . TIMESTAMP <EOL> expected = minidom . parseString ( \"\"\"<STR_LIT>\"\"\" . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT>\" ) % ( locals ( ) ) ) <EOL> self . assertEqual ( expected . toxml ( ) , actual . toxml ( ) ) <EOL> def test_show_no_server ( self ) : <EOL> serializer = images . ImageXMLSerializer ( ) <EOL> fixture = { <EOL> '<STR_LIT:image>' : { <EOL> '<STR_LIT:id>' : <NUM_LIT:1> , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . TIMESTAMP , <EOL> '<STR_LIT>' : self . TIMESTAMP , <EOL> '<STR_LIT:status>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : self . IMAGE_HREF % <NUM_LIT:1> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> { <EOL> '<STR_LIT>' : self . IMAGE_BOOKMARK % <NUM_LIT:1> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] , <EOL> } , <EOL> } <EOL> output = serializer . serialize ( fixture , '<STR_LIT>' ) <EOL> actual = minidom . parseString ( output . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT>\" ) ) <EOL> expected_href = self . IMAGE_HREF % <NUM_LIT:1> <EOL> expected_bookmark = self . IMAGE_BOOKMARK % <NUM_LIT:1> <EOL> expected_now = self . TIMESTAMP <EOL> expected = minidom . parseString ( \"\"\"<STR_LIT>\"\"\" . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT>\" ) % ( locals ( ) ) ) <EOL> self . assertEqual ( expected . toxml ( ) , actual . toxml ( ) ) <EOL> def test_index ( self ) : <EOL> serializer = images . ImageXMLSerializer ( ) <EOL> fixture = { <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT:id>' : <NUM_LIT:1> , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : self . IMAGE_HREF % <NUM_LIT:1> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> ] , <EOL> } , <EOL> { <EOL> '<STR_LIT:id>' : <NUM_LIT:2> , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : self . IMAGE_HREF % <NUM_LIT:2> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL>", "answer": "} ,"}, {"prompt": "<s> from django . db . models . fields import TextField <EOL> from bs4 import BeautifulSoup <EOL> class HtmlField ( TextField ) : <EOL> def cleanup_html ( self , value ) : <EOL> try : <EOL> soup = BeautifulSoup ( value , '<STR_LIT>' ) <EOL> soup . body . hidden = True <EOL> value = soup . body . prettify ( ) . encode ( '<STR_LIT:ascii>' , '<STR_LIT:ignore>' ) <EOL> except Exception as ex : <EOL>", "answer": "value = value"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from . models import Workflow <EOL> def launch_workflow ( sender , instance , created , ** kwargs ) : <EOL> if created : <EOL>", "answer": "Workflow . objects . launch_for ( instance ) "}, {"prompt": "<s> import sys <EOL> import os <EOL> sys . path . insert ( <NUM_LIT:0> , os . path . abspath ( '<STR_LIT>' ) ) <EOL> class MockX ( object ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MockX , self ) . __init__ ( ) <EOL> def __call__ ( self , * args , ** kwargs ) : <EOL> return MockX ( ) <EOL> @ classmethod <EOL> def __getattr__ ( cls , name ) : <EOL> if name in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> return [ ] <EOL> elif name [ <NUM_LIT:0> ] == name [ <NUM_LIT:0> ] . upper ( ) : <EOL> mockType = MockX ( ) <EOL> mockType . __module__ = name <EOL> return mockType <EOL> else : <EOL> m = MockX ( ) <EOL> return m <EOL> MOCK_MODULES = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> for mod_name in MOCK_MODULES : <EOL> sys . modules [ mod_name ] = MockX ( ) <EOL> extensions = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> templates_path = [ '<STR_LIT>' ] <EOL> source_suffix = '<STR_LIT>' <EOL> master_doc = '<STR_LIT:index>' <EOL> project = u'<STR_LIT>' <EOL> copyright = u'<STR_LIT>' <EOL> sys . path . insert ( <NUM_LIT:0> , os . path . abspath ( '<STR_LIT:..>' ) ) <EOL> import package <EOL> version = package . version <EOL> release = package . version <EOL> exclude_patterns = [ '<STR_LIT>' ] <EOL> pygments_style = '<STR_LIT>' <EOL> html_theme = '<STR_LIT:default>' <EOL> html_static_path = [ '<STR_LIT>' ] <EOL> html_show_sourcelink = False <EOL> htmlhelp_basename = '<STR_LIT>' <EOL> latex_elements = { <EOL> } <EOL> latex_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL>", "answer": "man_pages = ["}, {"prompt": "<s> from __future__ import absolute_import <EOL> from nose . tools import raises <EOL> from plotly . graph_objs import ( Annotation , Annotations , Data , Figure , Font , <EOL> Layout , Scene , XAxis , YAxis ) <EOL> import plotly . tools as tls <EOL> @ raises ( Exception ) <EOL> def test_non_integer_rows ( ) : <EOL> tls . make_subplots ( rows = <NUM_LIT> ) <EOL> @ raises ( Exception ) <EOL> def test_less_than_zero_rows ( ) : <EOL> tls . make_subplots ( rows = - <NUM_LIT:2> ) <EOL> @ raises ( Exception ) <EOL> def test_non_integer_cols ( ) : <EOL> tls . make_subplots ( cols = <NUM_LIT:2> / <NUM_LIT:3> ) <EOL> @ raises ( Exception ) <EOL> def test_less_than_zero_cols ( ) : <EOL> tls . make_subplots ( cols = - <NUM_LIT:10> ) <EOL> @ raises ( Exception ) <EOL> def test_wrong_kwarg ( ) : <EOL> tls . make_subplots ( stuff = '<STR_LIT>' ) <EOL> @ raises ( Exception ) <EOL> def test_non_integer_rows ( ) : <EOL> tls . make_subplots ( rows = <NUM_LIT> ) <EOL> @ raises ( Exception ) <EOL> def test_non_integer_cols ( ) : <EOL> tls . make_subplots ( cols = <NUM_LIT:2> / <NUM_LIT:3> ) <EOL> @ raises ( Exception ) <EOL> def test_wrong_kwarg ( ) : <EOL> tls . make_subplots ( stuff = '<STR_LIT>' ) <EOL> @ raises ( Exception ) <EOL> def test_start_cell_wrong_values ( ) : <EOL> tls . make_subplots ( rows = <NUM_LIT:2> , cols = <NUM_LIT:2> , start_cell = '<STR_LIT>' ) <EOL> @ raises ( Exception ) <EOL> def test_specs_wrong_type ( ) : <EOL> tls . make_subplots ( specs = \"<STR_LIT>\" ) <EOL> @ raises ( Exception ) <EOL> def test_specs_wrong_inner_type ( ) : <EOL> tls . make_subplots ( specs = [ { } ] ) <EOL> @ raises ( Exception ) <EOL> def test_specs_wrong_item_type ( ) : <EOL> tls . make_subplots ( specs = [ [ ( '<STR_LIT>' , '<STR_LIT>' ) ] ] ) <EOL> @ raises ( Exception ) <EOL> def test_specs_wrong_item_key ( ) : <EOL> tls . make_subplots ( specs = [ { '<STR_LIT>' : \"<STR_LIT>\" } ] ) <EOL> @ raises ( Exception ) <EOL> def test_specs_underspecified ( ) : <EOL> tls . make_subplots ( rows = <NUM_LIT:2> , specs = [ { } ] ) <EOL> tls . make_subplots ( rows = <NUM_LIT:2> , cols = <NUM_LIT:2> , specs = [ [ { } , { } ] , [ { } ] ] ) <EOL> @ raises ( Exception ) <EOL> def test_specs_overspecified ( ) : <EOL> tls . make_subplots ( rows = <NUM_LIT:2> , specs = [ [ { } ] , [ { } ] , [ { } ] ] ) <EOL> tls . make_subplots ( cols = <NUM_LIT:2> , specs = [ { } , { } , { } ] ) <EOL> @ raises ( Exception ) <EOL> def test_specs_colspan_too_big ( ) : <EOL> tls . make_subplots ( cols = <NUM_LIT:3> , specs = [ [ { } , None , { '<STR_LIT>' : <NUM_LIT:2> } ] ] ) <EOL> @ raises ( Exception ) <EOL> def test_specs_rowspan_too_big ( ) : <EOL> tls . make_subplots ( rows = <NUM_LIT:3> , specs = [ [ { } ] , [ None ] , [ { '<STR_LIT>' : <NUM_LIT:2> } ] ] ) <EOL> @ raises ( Exception ) <EOL> def test_insets_wrong_type ( ) : <EOL> tls . make_subplots ( insets = \"<STR_LIT>\" ) <EOL> @ raises ( Exception ) <EOL> def test_insets_wrong_item ( ) : <EOL> tls . make_subplots ( insets = [ { '<STR_LIT>' : \"<STR_LIT>\" } ] ) <EOL> @ raises ( Exception ) <EOL> def test_insets_wrong_cell_row ( ) : <EOL> tls . make_subplots ( insets = ( [ { '<STR_LIT>' : ( <NUM_LIT:0> , <NUM_LIT:1> ) } ] ) ) <EOL> @ raises ( Exception ) <EOL> def test_insets_wrong_cell_col ( ) : <EOL> tls . make_subplots ( insets = ( [ { '<STR_LIT>' : ( <NUM_LIT:1> , <NUM_LIT:0> ) } ] ) ) <EOL> def test_single_plot ( ) : <EOL> expected = Figure ( <EOL> data = Data ( ) , <EOL> layout = Layout ( <EOL> xaxis1 = XAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT:1.0> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis1 = YAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT:1.0> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) <EOL> ) <EOL> ) <EOL> assert tls . make_subplots ( ) == expected <EOL> def test_two_row ( ) : <EOL> expected = Figure ( <EOL> data = Data ( ) , <EOL> layout = Layout ( <EOL> xaxis1 = XAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT:1.0> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis2 = XAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT:1.0> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis1 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT:1.0> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis2 = YAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) <EOL> ) <EOL> ) <EOL> assert tls . make_subplots ( rows = <NUM_LIT:2> ) == expected <EOL> def test_two_row_bottom_left ( ) : <EOL> expected = Figure ( <EOL> data = Data ( ) , <EOL> layout = Layout ( <EOL> xaxis1 = XAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT:1.0> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis2 = XAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT:1.0> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis1 = YAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis2 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT:1.0> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) <EOL> ) <EOL> ) <EOL> fig = tls . make_subplots ( rows = <NUM_LIT:2> , start_cell = '<STR_LIT>' ) <EOL> assert fig == expected <EOL> def test_two_column ( ) : <EOL> expected = Figure ( <EOL> data = Data ( ) , <EOL> layout = Layout ( <EOL> xaxis1 = XAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis2 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT:1.0> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis1 = YAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT:1.0> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis2 = YAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT:1.0> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) <EOL> ) <EOL> ) <EOL> assert tls . make_subplots ( cols = <NUM_LIT:2> ) == expected <EOL> def test_a_lot ( ) : <EOL> expected = Figure ( <EOL> data = Data ( ) , <EOL> layout = Layout ( <EOL> xaxis1 = XAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis10 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis11 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis12 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis13 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis14 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis15 = XAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis16 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis17 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis18 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis19 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis2 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis20 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis21 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis22 = XAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis23 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis24 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis25 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis26 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis27 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis28 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis3 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis4 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis5 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis6 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis7 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis8 = XAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> xaxis9 = XAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis1 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis10 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis11 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis12 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis13 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis14 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis15 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis16 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis17 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis18 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis19 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis2 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis20 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis21 = YAxis ( <EOL> domain = [ <NUM_LIT> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis22 = YAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis23 = YAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis24 = YAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis25 = YAxis ( <EOL> domain = [ <NUM_LIT:0.0> , <NUM_LIT> ] , <EOL> anchor = '<STR_LIT>' <EOL> ) , <EOL> yaxis26 = YAxis ( <EOL>", "answer": "domain = [ <NUM_LIT:0.0> , <NUM_LIT> ] ,"}, {"prompt": "<s> import sublime <EOL> import sublime_plugin <EOL> class PasteAsReferenceCommand ( sublime_plugin . TextCommand ) : <EOL> def run ( self , edit ) : <EOL> view = self . view <EOL> sel = view . sel ( ) [ <NUM_LIT:0> ] <EOL> text = view . substr ( sel ) <EOL> contents = sublime . get_clipboard ( ) <EOL> self . view . replace ( edit , sel , \"<STR_LIT:[>\" + text + \"<STR_LIT>\" + contents ) <EOL> def is_enabled ( self ) : <EOL>", "answer": "return bool ( self . view . score_selector ( self . view . sel ( ) [ <NUM_LIT:0> ] . a , \"<STR_LIT>\" ) ) "}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import re <EOL> import sys <EOL> import os <EOL> from com . dtmilano . android . viewclient import ViewClient <EOL> if len ( sys . argv ) < <NUM_LIT:2> : <EOL> sys . exit ( \"<STR_LIT>\" % sys . argv [ <NUM_LIT:0> ] ) <EOL> filename = sys . argv . pop ( <NUM_LIT:1> ) <EOL> kwargs1 = { '<STR_LIT>' : False , '<STR_LIT>' : False } <EOL> device , serialno = ViewClient . connectToDeviceOrExit ( ** kwargs1 ) <EOL> kwargs2 = { '<STR_LIT>' : True , '<STR_LIT>' : False , '<STR_LIT>' : False , '<STR_LIT>' : True } <EOL> vc = ViewClient ( device , serialno , ** kwargs2 ) <EOL> vc . dump ( window = '<STR_LIT>' ) <EOL>", "answer": "vc . findViewWithContentDescriptionOrRaise ( '''<STR_LIT>''' ) . writeImageToFile ( filename , '<STR_LIT>' ) "}, {"prompt": "<s> import optparse as op <EOL> import os <EOL> import sys <EOL> import shutil <EOL> class NoDirectoriesError ( Exception ) : <EOL> \"<STR_LIT>\" <EOL> class DirHelper ( object ) : <EOL> def __init__ ( self , is_dir , list_dir , walk , rmtree ) : <EOL> self . is_dir = is_dir <EOL> self . list_dir = list_dir <EOL> self . walk = walk <EOL> self . rmtree = rmtree <EOL> class FileSystemHelper ( object ) : <EOL> def __init__ ( self , open_ , path_join , move , exists ) : <EOL> self . open_ = open_ <EOL> self . path_join = path_join <EOL> self . move = move <EOL> self . exists = exists <EOL> class Replacer ( object ) : <EOL> \"<STR_LIT>\" <EOL> def __init__ ( self , from_ , to ) : <EOL> self . from_ = from_ <EOL> self . to = to <EOL> def process ( self , text ) : <EOL> return text . replace ( self . from_ , self . to ) <EOL> class FileHandler ( object ) : <EOL> \"<STR_LIT>\" <EOL> def __init__ ( self , name , replacers , opener ) : <EOL> self . name = name <EOL> self . replacers = replacers <EOL> self . opener = opener <EOL> def process ( self ) : <EOL> text = self . opener ( self . name ) . read ( ) <EOL> for replacer in self . replacers : <EOL> text = replacer . process ( text ) <EOL> self . opener ( self . name , \"<STR_LIT:w>\" ) . write ( text ) <EOL> class Remover ( object ) : <EOL> def __init__ ( self , exists , remove ) : <EOL> self . exists = exists <EOL> self . remove = remove <EOL> def __call__ ( self , name ) : <EOL> if self . exists ( name ) : <EOL> self . remove ( name ) <EOL> class ForceRename ( object ) : <EOL> def __init__ ( self , renamer , remove ) : <EOL> self . renamer = renamer <EOL> self . remove = remove <EOL> def __call__ ( self , from_ , to ) : <EOL> self . remove ( to ) <EOL> self . renamer ( from_ , to ) <EOL> class VerboseRename ( object ) : <EOL> def __init__ ( self , renamer , stream ) : <EOL> self . renamer = renamer <EOL> self . stream = stream <EOL> def __call__ ( self , from_ , to ) : <EOL> self . stream . write ( <EOL> \"<STR_LIT>\" <EOL> % ( os . path . basename ( from_ ) , os . path . basename ( to ) ) <EOL> ) <EOL> self . renamer ( from_ , to ) <EOL> class DirectoryHandler ( object ) : <EOL> \"<STR_LIT>\" <EOL> def __init__ ( self , name , root , renamer ) : <EOL> self . name = name <EOL> self . new_name = name [ <NUM_LIT:1> : ] <EOL> self . root = root + os . sep <EOL> self . renamer = renamer <EOL> def path ( self ) : <EOL> return os . path . join ( self . root , self . name ) <EOL> def relative_path ( self , directory , filename ) : <EOL> path = directory . replace ( self . root , \"<STR_LIT>\" , <NUM_LIT:1> ) <EOL> return os . path . join ( path , filename ) <EOL> def new_relative_path ( self , directory , filename ) : <EOL> path = self . relative_path ( directory , filename ) <EOL> return path . replace ( self . name , self . new_name , <NUM_LIT:1> ) <EOL> def process ( self ) : <EOL> from_ = os . path . join ( self . root , self . name ) <EOL> to = os . path . join ( self . root , self . new_name ) <EOL> self . renamer ( from_ , to ) <EOL> class HandlerFactory ( object ) : <EOL> def create_file_handler ( self , name , replacers , opener ) : <EOL> return FileHandler ( name , replacers , opener ) <EOL> def create_dir_handler ( self , name , root , renamer ) : <EOL> return DirectoryHandler ( name , root , renamer ) <EOL> class OperationsFactory ( object ) : <EOL> def create_force_rename ( self , renamer , remover ) : <EOL> return ForceRename ( renamer , remover ) <EOL> def create_verbose_rename ( self , renamer , stream ) : <EOL> return VerboseRename ( renamer , stream ) <EOL> def create_replacer ( self , from_ , to ) : <EOL> return Replacer ( from_ , to ) <EOL> def create_remover ( self , exists , remove ) : <EOL> return Remover ( exists , remove ) <EOL> class Layout ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , directory_handlers , file_handlers ) : <EOL> self . directory_handlers = directory_handlers <EOL> self . file_handlers = file_handlers <EOL> def process ( self ) : <EOL> for handler in self . file_handlers : <EOL> handler . process ( ) <EOL> for handler in self . directory_handlers : <EOL> handler . process ( ) <EOL> class LayoutFactory ( object ) : <EOL> \"<STR_LIT>\" <EOL> def __init__ ( self , operations_factory , handler_factory , file_helper , <EOL> dir_helper , verbose , stream , force ) : <EOL> self . operations_factory = operations_factory <EOL> self . handler_factory = handler_factory <EOL> self . file_helper = file_helper <EOL> self . dir_helper = dir_helper <EOL> self . verbose = verbose <EOL> self . output_stream = stream <EOL> self . force = force <EOL> def create_layout ( self , path ) : <EOL> contents = self . dir_helper . list_dir ( path ) <EOL> renamer = self . file_helper . move <EOL> if self . force : <EOL> remove = self . operations_factory . create_remover ( self . file_helper . exists , self . dir_helper . rmtree ) <EOL> renamer = self . operations_factory . create_force_rename ( renamer , remove ) <EOL> if self . verbose : <EOL> renamer = self . operations_factory . create_verbose_rename ( renamer , self . output_stream ) <EOL> directories = [ d for d in contents if self . is_underscore_dir ( path , d ) ] <EOL> underscore_directories = [ <EOL> self . handler_factory . create_dir_handler ( d , path , renamer ) <EOL> for d in directories <EOL> ] <EOL> if not underscore_directories : <EOL> raise NoDirectoriesError ( ) <EOL> replacers = [ ] <EOL> for handler in underscore_directories : <EOL> for directory , dirs , files in self . dir_helper . walk ( handler . path ( ) ) : <EOL> for f in files : <EOL> replacers . append ( <EOL> self . operations_factory . create_replacer ( <EOL> handler . relative_path ( directory , f ) , <EOL> handler . new_relative_path ( directory , f ) <EOL> ) <EOL> ) <EOL> filelist = [ ] <EOL> for root , dirs , files in self . dir_helper . walk ( path ) : <EOL> for f in files : <EOL> if f . endswith ( \"<STR_LIT>\" ) : <EOL> filelist . append ( <EOL> self . handler_factory . create_file_handler ( <EOL> self . file_helper . path_join ( root , f ) , <EOL> replacers , <EOL> self . file_helper . open_ ) <EOL> ) <EOL> if f . endswith ( \"<STR_LIT>\" ) : <EOL> filelist . append ( <EOL> self . handler_factory . create_file_handler ( <EOL> self . file_helper . path_join ( root , f ) , <EOL> [ self . operations_factory . create_replacer ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ] , <EOL> self . file_helper . open_ <EOL> ) <EOL> ) <EOL> return Layout ( underscore_directories , filelist ) <EOL> def is_underscore_dir ( self , path , directory ) : <EOL>", "answer": "return ( self . dir_helper . is_dir ( self . file_helper . path_join ( path , directory ) )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import division <EOL> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL>", "answer": "import datetime"}, {"prompt": "<s> from pypy . interpreter . mixedmodule import MixedModule <EOL> import sys <EOL> class Module ( MixedModule ) : <EOL> appleveldefs = { <EOL> '<STR_LIT:error>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> interpleveldefs = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL>", "answer": "}"}, {"prompt": "<s> import plivohelper <EOL> import sys <EOL> try : <EOL> room = sys . argv [ <NUM_LIT:1> ] <EOL> memberid = sys . argv [ <NUM_LIT:2> ] <EOL> except IndexError : <EOL> print \"<STR_LIT>\" <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> REST_API_URL = '<STR_LIT>' <EOL> API_VERSION = '<STR_LIT>' <EOL>", "answer": "SID = '<STR_LIT>'"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL>", "answer": "result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "<s> import threading <EOL> from pickle import loads , dumps <EOL> import sys <EOL> from amqplib import client_0_8 as amqp <EOL> from . import config <EOL> from . url import URL <EOL> from . threaded import daemon <EOL> def connect ( url , insist = False ) : <EOL> url = URL ( url , host = \"<STR_LIT:localhost>\" , port = <NUM_LIT> , <EOL> user = \"<STR_LIT>\" , password = \"<STR_LIT>\" , path = \"<STR_LIT:/>\" ) <EOL> host = \"<STR_LIT::>\" . join ( ( url . host , str ( url . port ) ) ) <EOL> userid , password = url . user , url . password <EOL> virtual_host = \"<STR_LIT:/>\" + url . path <EOL> server = amqp . Connection ( host = host , userid = userid , password = password , <EOL> virtual_host = virtual_host , insist = insist ) <EOL> return server <EOL> def start_worker ( server , mapid , work ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> channel = server . channel ( ) <EOL> exchange = \"<STR_LIT>\" <EOL> map_queue = \"<STR_LIT:.>\" . join ( ( \"<STR_LIT>\" , mapid ) ) <EOL> channel . exchange_declare ( exchange = exchange , type = \"<STR_LIT>\" , <EOL> durable = False , auto_delete = True ) <EOL> channel . queue_declare ( queue = map_queue , durable = False , <EOL> exclusive = False , auto_delete = True ) <EOL> def _process_work ( msg ) : <EOL> if msg . reply_to == \"<STR_LIT>\" : <EOL> channel . basic_cancel ( consumer ) <EOL> body = loads ( msg . body ) <EOL> try : <EOL> result = work ( body [ '<STR_LIT:value>' ] ) <EOL> except Exception as _exc : <EOL> result = None <EOL> channel . basic_ack ( msg . delivery_tag ) <EOL> reply = amqp . Message ( dumps ( dict ( index = body [ '<STR_LIT:index>' ] , result = result ) ) ) <EOL> channel . basic_publish ( reply , exchange = exchange , <EOL> routing_key = msg . reply_to ) <EOL> consumer = channel . basic_consume ( queue = map_queue , callback = _process_work , <EOL> no_ack = False ) <EOL> while True : <EOL> channel . wait ( ) <EOL> class Mapper ( object ) : <EOL> def __init__ ( self , server , mapid ) : <EOL> channel = server . channel ( ) <EOL> exchange = \"<STR_LIT>\" <EOL> channel . exchange_declare ( exchange = exchange , type = \"<STR_LIT>\" , <EOL> durable = False , auto_delete = True ) <EOL> map_channel = channel <EOL> map_queue = \"<STR_LIT:.>\" . join ( ( \"<STR_LIT>\" , mapid ) ) <EOL> map_channel . queue_declare ( queue = map_queue , durable = False , <EOL> exclusive = False , auto_delete = True ) <EOL> map_channel . queue_bind ( queue = map_queue , exchange = \"<STR_LIT>\" , <EOL> routing_key = map_queue ) <EOL> reply_channel = server . channel ( ) <EOL> reply_queue = \"<STR_LIT>\" <EOL> reply_queue , _ , _ = reply_channel . queue_declare ( queue = reply_queue , <EOL> durable = False , <EOL> exclusive = True , <EOL> auto_delete = True ) <EOL> reply_channel . queue_bind ( queue = reply_queue , exchange = \"<STR_LIT>\" , <EOL> routing_key = reply_queue ) <EOL> reply_channel . basic_consume ( queue = reply_queue , <EOL> callback = self . _process_result , <EOL> no_ack = True ) <EOL> self . exchange = exchange <EOL> self . map_queue = map_queue <EOL> self . map_channel = map_channel <EOL> self . reply_queue = reply_queue <EOL> self . reply_channel = reply_channel <EOL> self . _throttle = threading . Condition ( ) <EOL> def close ( self ) : <EOL> self . channel . close ( ) <EOL> def _process_result ( self , msg ) : <EOL> self . _reply = loads ( msg . body ) <EOL> @ daemon <EOL> def _send_map ( self , items ) : <EOL> for i , v in enumerate ( items ) : <EOL> self . num_queued = i <EOL> if self . num_queued - self . num_processed > config . MAX_QUEUE : <EOL> self . _throttle . acquire ( ) <EOL> self . _throttle . wait ( ) <EOL> self . _throttle . release ( ) <EOL> body = dumps ( dict ( index = i , value = v ) ) <EOL> msg = amqp . Message ( body , reply_to = self . reply_queue , delivery_mode = <NUM_LIT:1> ) <EOL> self . map_channel . basic_publish ( msg , exchange = self . exchange , <EOL> routing_key = self . map_queue ) <EOL> def cancel ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL> msg = amqp . Message ( \"<STR_LIT>\" , reply_to = \"<STR_LIT>\" , delivery_mode = <NUM_LIT:1> ) <EOL> self . map_channel . basic_publish ( msg , exchange = self . exchange , <EOL> routing_key = self . map_queue ) <EOL> def async ( self , items ) : <EOL> items = list ( items ) <EOL> self . num_items = len ( items ) <EOL> self . num_processed = <NUM_LIT:0> <EOL> publisher = self . _send_map ( items ) <EOL> recvd = set ( ) <EOL> while self . num_processed < self . num_items : <EOL> try : del self . _reply <EOL> except : pass <EOL> self . reply_channel . wait ( ) <EOL> try : <EOL> idx = self . _reply [ '<STR_LIT:index>' ] <EOL> except : <EOL> sys . stdout . flush ( ) <EOL> raise RuntimeError ( \"<STR_LIT>\" ) <EOL>", "answer": "if idx in recvd : continue"}, {"prompt": "<s> import gzip <EOL> import io <EOL> import random <EOL> import re <EOL> import string <EOL> import time <EOL> try : <EOL> import socks <EOL> NO_SOCKS = False <EOL> except ImportError : <EOL> NO_SOCKS = True <EOL> import socket <EOL> try : <EOL> import urllib2 <EOL> except ImportError : <EOL> import urllib . request as urllib2 <EOL> UA = \"\"\"<STR_LIT>\"\"\" <EOL> urlReqHeaders = { '<STR_LIT>' : UA , '<STR_LIT>' : '<STR_LIT>' } <EOL> class FatalError ( Exception ) : <EOL> pass <EOL> def fixFormatting ( s , spaceToken ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for i in string . punctuation : <EOL> if ( i != '<STR_LIT:->' and i != spaceToken ) : <EOL> s = s . replace ( i , '<STR_LIT>' ) <EOL> return s . lower ( ) . lstrip ( spaceToken ) . strip ( ) . replace ( '<STR_LIT:U+0020>' , spaceToken ) <EOL> def getSourceCode ( url , proxy , returnRedirctUrl = False , maxRetries = <NUM_LIT:1> , waitRetryTime = <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ( proxy is not None ) : <EOL> if ( NO_SOCKS ) : <EOL> raise FatalError ( '<STR_LIT>' ) <EOL> proxySettings = proxy . split ( '<STR_LIT::>' ) <EOL> socks . setdefaultproxy ( socks . PROXY_TYPE_SOCKS4 , proxySettings [ <NUM_LIT:0> ] , int ( proxySettings [ <NUM_LIT:1> ] ) , True ) <EOL> socket . socket = socks . socksocket <EOL> global urlReqHeaders <EOL> ret = None <EOL> request = urllib2 . Request ( url , headers = urlReqHeaders ) <EOL> while ( ret == None ) : <EOL> try : <EOL> f = urllib2 . urlopen ( request ) <EOL> encoding = f . headers . get ( '<STR_LIT>' ) <EOL> if encoding == None : <EOL> ret = f . read ( ) <EOL> else : <EOL> if encoding . upper ( ) == '<STR_LIT>' : <EOL> compressedstream = io . BytesIO ( f . read ( ) ) <EOL> gzipper = gzip . GzipFile ( fileobj = compressedstream ) <EOL> ret = gzipper . read ( ) <EOL> else : <EOL> raise FatalError ( '<STR_LIT>' ) <EOL> except urllib2 . URLError : <EOL> if ( maxRetries == <NUM_LIT:0> ) : <EOL> break <EOL> else : <EOL> time . sleep ( random . uniform ( <NUM_LIT:0.5> * waitRetryTime , <NUM_LIT> * waitRetryTime ) ) <EOL> maxRetries -= <NUM_LIT:1> <EOL> if returnRedirctUrl : <EOL> return ret , f . geturl ( ) <EOL> else : <EOL> return ret <EOL> def isImageLibAvailable ( ) : <EOL> try : <EOL> from ConvertPackage . ConvertFile import convertFile <EOL> return True <EOL> except ImportError : <EOL> return False <EOL> def zeroFillStr ( inputString , numOfZeros ) : <EOL> return re . sub ( '<STR_LIT>' , <EOL> lambda matchObj : <EOL> ( '<STR_LIT>' + str ( numOfZeros ) + '<STR_LIT:i>' ) % int ( matchObj . group ( <NUM_LIT:0> ) ) , <EOL> inputString ) <EOL> def getText ( node ) : <EOL> rc = [ ] <EOL> for node in node . childNodes : <EOL> if node . nodeType == node . TEXT_NODE : <EOL> rc . append ( node . data ) <EOL> return '<STR_LIT>' . join ( rc ) <EOL> def setText ( dom , node , text ) : <EOL> for currNode in node . childNodes : <EOL> if currNode . nodeType == currNode . TEXT_NODE : <EOL> currNode . data = text <EOL> return <EOL> textNode = dom . createTextNode ( text ) <EOL> node . appendChild ( textNode ) <EOL>", "answer": "def updateNode ( dom , node , tagName , text ) :"}, {"prompt": "<s> from __future__ import print_function <EOL> import sys <EOL> sys . path . insert ( <NUM_LIT:0> , \"<STR_LIT:.>\" ) <EOL> import unittest <EOL> import neuroml <EOL> import neuroml . writers as writers <EOL> import PyOpenWorm <EOL> from PyOpenWorm import * <EOL> import networkx <EOL> import rdflib <EOL> import rdflib as R <EOL> import logging <EOL> import pint as Q <EOL> import os <EOL> import subprocess as SP <EOL> import subprocess <EOL> import tempfile <EOL> import doctest <EOL> from glob import glob <EOL> from GraphDBInit import * <EOL> from ConfigureTest import ConfigureTest <EOL> from DataIntegrityTest import DataIntegrityTest <EOL> from DatabaseBackendTest import DatabaseBackendTest <EOL> from ExampleRunnerTest import ExampleRunnerTest <EOL> from QuantityTest import QuantityTest <EOL> from RDFLibTest import RDFLibTest <EOL> from DataTestTemplate import _DataTest <EOL> from WormTest import WormTest <EOL> from CellTest import CellTest <EOL> from DataObjectTest import DataObjectTest <EOL> from DataUserTest import DataUserTest <EOL> from ChannelTest import ChannelTest <EOL> from ExperimentTest import ExperimentTest <EOL> from NeuronTest import NeuronTest <EOL> from NetworkTest import NetworkTest <EOL> from EvidenceTest import EvidenceTest <EOL> from EvidenceCoverageTest import EvidenceCoverageTest <EOL> from ConnectionTest import ConnectionTest <EOL> from MuscleTest import MuscleTest <EOL> from PlotTest import PlotTest <EOL> from PropertyTest import PropertyTest <EOL> from SimplePropertyTest import SimplePropertyTest <EOL> from NeuroMLTest import NeuroMLTest <EOL> from InferenceTest import InferenceTest <EOL> from MiscTest import MiscTest <EOL> from DocumentationTest import DocumentationTest <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> from optparse import OptionParser <EOL> parser = OptionParser ( ) <EOL> parser . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT>\" , <EOL> action = \"<STR_LIT:store_true>\" , default = False , <EOL> help = \"<STR_LIT>\" ) <EOL>", "answer": "parser . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , dest = \"<STR_LIT>\" ,"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from goblin . _compat import integer_types , float_types , string_types , iteritems <EOL> from goblin . tools import LazyImportClass <EOL> from goblin . exceptions import GoblinException <EOL> element = LazyImportClass ( '<STR_LIT>' ) <EOL> numeric_types = ( integer_types + float_types ) <EOL> class Row ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __ready = False <EOL> __okay_setattr = '<STR_LIT>' <EOL> def __init__ ( self , data ) : <EOL> if isinstance ( data , element . klass ) : <EOL> data = data . as_dict ( ) <EOL> elif not isinstance ( data , dict ) : <EOL> raise GoblinException ( \"<STR_LIT>\" ) <EOL> self . __data = data <EOL> for k , v in data . items ( ) : <EOL> if isinstance ( k , string_types ) : <EOL> setattr ( self , k , v ) <EOL> self . __position = <NUM_LIT:0> <EOL> self . __ready = True <EOL> def __getslice__ ( self , i , j ) : <EOL> return list ( self . __data . values ( ) ) [ i : j ] <EOL> def __setslice__ ( self , i , j , sequence ) : <EOL> raise GoblinException ( \"<STR_LIT>\" ) <EOL> def __delslice__ ( self , i , j ) : <EOL> raise GoblinException ( \"<STR_LIT>\" ) <EOL> def __getitem__ ( self , item ) : <EOL> if isinstance ( item , numeric_types ) or isinstance ( item , slice ) : <EOL> return list ( self . __data . values ( ) ) [ item ] <EOL> return self . __data [ item ] <EOL> def __setitem__ ( self , key , value ) : <EOL> raise GoblinException ( \"<STR_LIT>\" ) <EOL> def __delitem__ ( self , key ) : <EOL> raise GoblinException ( \"<STR_LIT>\" ) <EOL> def __setattr__ ( self , key , value ) : <EOL> if not self . __ready or key . startswith ( self . __okay_setattr ) : <EOL> super ( Row , self ) . __setattr__ ( key , value ) <EOL> else : <EOL> raise GoblinException ( \"<STR_LIT>\" ) <EOL> def __delattr__ ( self , item ) : <EOL> raise GoblinException ( \"<STR_LIT>\" ) <EOL> def __iter__ ( self ) : <EOL> return self <EOL> def __next__ ( self ) : <EOL> return self . next ( ) <EOL> def keys ( self ) : <EOL> return self . __data . keys ( ) <EOL> def values ( self ) : <EOL> return self . __data . values ( ) <EOL> def items ( self ) : <EOL> return self . __data . items ( ) <EOL> def iteritems ( self ) : <EOL> for k , v in self . __data . items ( ) : <EOL> yield k , v <EOL> def next ( self ) : <EOL> if self . __position == len ( self . __data ) : <EOL> self . __position = <NUM_LIT:0> <EOL> raise StopIteration ( ) <EOL> tmp = list ( self . __data . values ( ) ) [ self . __position ] <EOL> self . __position += <NUM_LIT:1> <EOL> return tmp <EOL> def __len__ ( self ) : <EOL> return len ( self . __data ) <EOL> def __repr__ ( self ) : <EOL> result = \"<STR_LIT>\" . format ( self . __class__ . __name__ ) <EOL> for k , v in iteritems ( self . __data ) : <EOL> result += \"<STR_LIT>\" . format ( k , v ) <EOL> result = result . rstrip ( \"<STR_LIT:U+002CU+0020>\" ) <EOL> result += \"<STR_LIT:)>\" <EOL> return result <EOL> def __eq__ ( self , other ) : <EOL> if not isinstance ( other , self . __class__ ) : <EOL> return False <EOL> else : <EOL> return self . __data == other . _Row__data <EOL> class Table ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , gremlin_result ) : <EOL> if gremlin_result == [ [ ] ] : <EOL> gremlin_result = [ ] <EOL> self . __gremlin_result = gremlin_result <EOL> self . __position = <NUM_LIT:0> <EOL> def __getitem__ ( self , item ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return Row ( self . __gremlin_result [ item ] ) <EOL> def __setitem__ ( self , key , value ) : <EOL> raise GoblinException ( \"<STR_LIT>\" ) <EOL> def __delitem__ ( self , key ) : <EOL> raise GoblinException ( \"<STR_LIT>\" ) <EOL> def __getslice__ ( self , i , j ) : <EOL> return [ Row ( r ) for r in self . __gremlin_result [ i : j ] ] <EOL> def __setslice__ ( self , i , j , sequence ) : <EOL> raise GoblinException ( \"<STR_LIT>\" ) <EOL> def __delslice__ ( self , i , j ) : <EOL> raise GoblinException ( \"<STR_LIT>\" ) <EOL> def __iter__ ( self ) : <EOL> return self <EOL> def __next__ ( self ) : <EOL> return self . next ( ) <EOL> def next ( self ) : <EOL> if self . __position == len ( self . __gremlin_result ) : <EOL> self . __position = <NUM_LIT:0> <EOL> raise StopIteration ( ) <EOL> tmp = self . __gremlin_result [ self . __position ] <EOL> self . __position += <NUM_LIT:1> <EOL> return Row ( tmp ) <EOL> def __len__ ( self ) : <EOL> return len ( self . __gremlin_result ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' . format ( <EOL> self . __class__ . __name__ , len ( self . __gremlin_result ) ) <EOL>", "answer": "__all__ = [ '<STR_LIT>' , '<STR_LIT>' ] "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import abc <EOL> import logging <EOL> import socket <EOL> import time <EOL> import traceback <EOL> import weakref <EOL> import netaddr <EOL> from ryu . lib import hub <EOL> from ryu . lib import sockopt <EOL> from ryu . lib . hub import Timeout <EOL> from ryu . lib . packet . bgp import RF_IPv4_UC <EOL> from ryu . lib . packet . bgp import RF_IPv6_UC <EOL> from ryu . lib . packet . bgp import RF_IPv4_VPN <EOL> from ryu . lib . packet . bgp import RF_IPv6_VPN <EOL> from ryu . lib . packet . bgp import RF_RTC_UC <EOL> from ryu . services . protocols . bgp . utils . circlist import CircularListType <EOL> from ryu . services . protocols . bgp . utils . evtlet import LoopingCall <EOL> LOG = logging . getLogger ( '<STR_LIT>' ) <EOL> try : <EOL> from collections import OrderedDict <EOL> except ImportError : <EOL> from ordereddict import OrderedDict <EOL> OrderedDict = OrderedDict <EOL> SUPPORTED_GLOBAL_RF = set ( [ RF_IPv4_UC , <EOL> RF_IPv6_UC , <EOL> RF_IPv4_VPN , <EOL> RF_RTC_UC , <EOL> RF_IPv6_VPN <EOL> ] ) <EOL> ACTIVITY_ERROR_CODE = <NUM_LIT:100> <EOL> RUNTIME_CONF_ERROR_CODE = <NUM_LIT:200> <EOL> BIN_ERROR = <NUM_LIT> <EOL> NET_CTRL_ERROR_CODE = <NUM_LIT> <EOL> API_ERROR_CODE = <NUM_LIT> <EOL> PREFIX_ERROR_CODE = <NUM_LIT> <EOL> BGP_PROCESSOR_ERROR_CODE = <NUM_LIT> <EOL> CORE_ERROR_CODE = <NUM_LIT> <EOL> _EXCEPTION_REGISTRY = { } <EOL> class BGPSException ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> CODE = <NUM_LIT:1> <EOL> SUB_CODE = <NUM_LIT:1> <EOL> DEF_DESC = '<STR_LIT>' <EOL> def __init__ ( self , desc = None ) : <EOL> super ( BGPSException , self ) . __init__ ( ) <EOL> if not desc : <EOL> desc = self . __class__ . DEF_DESC <EOL> kls = self . __class__ <EOL> self . message = '<STR_LIT>' % ( kls . CODE , kls . SUB_CODE , desc ) <EOL>", "answer": "def __repr__ ( self ) :"}, {"prompt": "<s> try : <EOL>", "answer": "from django . template . engine import Engine"}, {"prompt": "<s> from social . strategies . utils import set_current_strategy_getter <EOL> from social . apps . flask_app . utils import load_strategy <EOL>", "answer": "set_current_strategy_getter ( load_strategy ) "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , unicode_literals <EOL> import errno <EOL> import socket <EOL> from amqp . exceptions import RecoverableConnectionError <EOL> from kombu . exceptions import ChannelError , ConnectionError <EOL> from kombu . message import Message <EOL> from kombu . utils import cached_property <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def _LeftBlank ( obj , method ) : <EOL> return NotImplementedError ( <EOL> '<STR_LIT>' . format ( <EOL> obj . __class__ , method ) ) <EOL> class StdChannel ( object ) : <EOL> no_ack_consumers = None <EOL> def Consumer ( self , * args , ** kwargs ) : <EOL> from kombu . messaging import Consumer <EOL> return Consumer ( self , * args , ** kwargs ) <EOL> def Producer ( self , * args , ** kwargs ) : <EOL> from kombu . messaging import Producer <EOL> return Producer ( self , * args , ** kwargs ) <EOL> def get_bindings ( self ) : <EOL> raise _LeftBlank ( self , '<STR_LIT>' ) <EOL> def after_reply_message_received ( self , queue ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> def __enter__ ( self ) : <EOL> return self <EOL> def __exit__ ( self , * exc_info ) : <EOL> self . close ( ) <EOL> class Management ( object ) : <EOL> def __init__ ( self , transport ) : <EOL> self . transport = transport <EOL> def get_bindings ( self ) : <EOL> raise _LeftBlank ( self , '<STR_LIT>' ) <EOL> class Implements ( dict ) : <EOL> def __getattr__ ( self , key ) : <EOL> try : <EOL> return self [ key ] <EOL> except KeyError : <EOL> raise AttributeError ( key ) <EOL> def __setattr__ ( self , key , value ) : <EOL> self [ key ] = value <EOL> def extend ( self , ** kwargs ) : <EOL> return self . __class__ ( self , ** kwargs ) <EOL> default_transport_capabilities = Implements ( <EOL> async = False , <EOL> exchange_type = frozenset ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) , <EOL> heartbeats = False , <EOL> ) <EOL> class Transport ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Management = Management <EOL> client = None <EOL> can_parse_url = False <EOL> default_port = None <EOL> connection_errors = ( ConnectionError , ) <EOL> channel_errors = ( ChannelError , ) <EOL> driver_type = '<STR_LIT>' <EOL> driver_name = '<STR_LIT>' <EOL> __reader = None <EOL> implements = default_transport_capabilities . extend ( ) <EOL> def __init__ ( self , client , ** kwargs ) : <EOL> self . client = client <EOL> def establish_connection ( self ) : <EOL> raise _LeftBlank ( self , '<STR_LIT>' ) <EOL> def close_connection ( self , connection ) : <EOL> raise _LeftBlank ( self , '<STR_LIT>' ) <EOL> def create_channel ( self , connection ) : <EOL> raise _LeftBlank ( self , '<STR_LIT>' ) <EOL> def close_channel ( self , connection ) : <EOL> raise _LeftBlank ( self , '<STR_LIT>' ) <EOL> def drain_events ( self , connection , ** kwargs ) : <EOL> raise _LeftBlank ( self , '<STR_LIT>' ) <EOL>", "answer": "def heartbeat_check ( self , connection , rate = <NUM_LIT:2> ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import collections <EOL> import logging <EOL> import os <EOL> import sys <EOL> import types <EOL> import weakref <EOL> from . google_imports import apiproxy_stub_map <EOL> from . google_imports import apiproxy_rpc <EOL> from . google_imports import datastore <EOL> from . google_imports import datastore_errors <EOL> from . google_imports import datastore_pbs <EOL> from . google_imports import datastore_rpc <EOL> from . google_imports import namespace_manager <EOL> from . google_imports import callback as _request_callback <EOL> from . import eventloop <EOL> from . import utils <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> _logging_debug = utils . logging_debug <EOL> _CALLBACK_KEY = '<STR_LIT>' <EOL> def _is_generator ( obj ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return isinstance ( obj , types . GeneratorType ) <EOL> class _State ( utils . threading_local ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> super ( _State , self ) . __init__ ( ) <EOL> self . current_context = None <EOL> self . all_generators = weakref . WeakSet ( ) <EOL> self . all_pending = set ( ) <EOL> def set_context ( self , ctx ) : <EOL> if _request_callback and _CALLBACK_KEY not in os . environ : <EOL> _request_callback . SetRequestEndCallback ( self . reset ) <EOL> os . environ [ _CALLBACK_KEY ] = '<STR_LIT:1>' <EOL> self . current_context = ctx <EOL> def add_generator ( self , gen ) : <EOL> _logging_debug ( '<STR_LIT>' , gen ) <EOL> self . all_generators . add ( gen ) <EOL> def add_pending ( self , fut ) : <EOL> _logging_debug ( '<STR_LIT>' , fut ) <EOL> self . all_pending . add ( fut ) <EOL> def remove_pending ( self , fut , status = '<STR_LIT:success>' ) : <EOL> if fut in self . all_pending : <EOL> _logging_debug ( '<STR_LIT>' , status , fut ) <EOL> self . all_pending . remove ( fut ) <EOL> else : <EOL> _logging_debug ( '<STR_LIT>' , status , fut ) <EOL> def clear_all_generators ( self ) : <EOL> if self . all_generators : <EOL> _logging_debug ( '<STR_LIT>' , self . all_generators ) <EOL> for gen in self . all_generators : <EOL> gen . close ( ) <EOL> self . all_generators . clear ( ) <EOL> else : <EOL> _logging_debug ( '<STR_LIT>' ) <EOL> def clear_all_pending ( self ) : <EOL> if self . all_pending : <EOL> _logging_debug ( '<STR_LIT>' , self . all_pending ) <EOL> self . all_pending . clear ( ) <EOL> else : <EOL> _logging_debug ( '<STR_LIT>' ) <EOL> def dump_all_pending ( self , verbose = False ) : <EOL> pending = [ ] <EOL> for fut in self . all_pending : <EOL> if verbose : <EOL> line = fut . dump ( ) + ( '<STR_LIT:\\n>' + '<STR_LIT:->' * <NUM_LIT> ) <EOL> else : <EOL> line = fut . dump_stack ( ) <EOL> pending . append ( line ) <EOL> return '<STR_LIT:\\n>' . join ( pending ) <EOL> def reset ( self ) : <EOL> self . current_context = None <EOL> ev = eventloop . get_event_loop ( ) <EOL> ev . clear ( ) <EOL> self . clear_all_pending ( ) <EOL> self . clear_all_generators ( ) <EOL> _state = _State ( ) <EOL> _flow_exceptions = ( ) <EOL> def add_flow_exception ( exc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> global _flow_exceptions <EOL> if not isinstance ( exc , type ) or not issubclass ( exc , Exception ) : <EOL> raise TypeError ( '<STR_LIT>' % ( exc , ) ) <EOL> as_set = set ( _flow_exceptions ) <EOL> as_set . add ( exc ) <EOL> _flow_exceptions = tuple ( as_set ) <EOL> def _init_flow_exceptions ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> global _flow_exceptions <EOL> _flow_exceptions = ( ) <EOL> add_flow_exception ( datastore_errors . Rollback ) <EOL> try : <EOL> from webob import exc <EOL> except ImportError : <EOL> pass <EOL> else : <EOL> add_flow_exception ( exc . HTTPException ) <EOL> _init_flow_exceptions ( ) <EOL> class Future ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> IDLE = apiproxy_rpc . RPC . IDLE <EOL> RUNNING = apiproxy_rpc . RPC . RUNNING <EOL> FINISHING = apiproxy_rpc . RPC . FINISHING <EOL> _geninfo = None <EOL> def __init__ ( self , info = None ) : <EOL> __ndb_debug__ = '<STR_LIT>' <EOL> self . _info = info <EOL> self . _where = utils . get_stack ( ) <EOL> self . _context = None <EOL> self . _reset ( ) <EOL> def _reset ( self ) : <EOL> self . _done = False <EOL> self . _result = None <EOL> self . _exception = None <EOL> self . _traceback = None <EOL> self . _callbacks = [ ] <EOL> self . _immediate_callbacks = [ ] <EOL> _state . add_pending ( self ) <EOL> self . _next = None <EOL> def __repr__ ( self ) : <EOL> if self . _done : <EOL> if self . _exception is not None : <EOL> state = '<STR_LIT>' % ( self . _exception . __class__ . __name__ , <EOL> self . _exception ) <EOL> else : <EOL> state = '<STR_LIT>' % ( self . _result , ) <EOL> else : <EOL> state = '<STR_LIT>' <EOL> line = '<STR_LIT:?>' <EOL> for line in self . _where : <EOL> if '<STR_LIT>' not in line : <EOL> break <EOL> if self . _info : <EOL> line += '<STR_LIT>' % self . _info <EOL> if self . _geninfo : <EOL> line += '<STR_LIT>' % self . _geninfo <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , id ( self ) , line , state ) <EOL> def dump ( self ) : <EOL> return '<STR_LIT>' % ( self . dump_stack ( ) , <EOL> '<STR_LIT>' . join ( self . _where ) ) <EOL> def dump_stack ( self ) : <EOL> lines = [ ] <EOL> fut = self <EOL> while fut is not None : <EOL> lines . append ( str ( fut ) ) <EOL> fut = fut . _next <EOL> return '<STR_LIT>' . join ( lines ) <EOL> def add_callback ( self , callback , * args , ** kwds ) : <EOL> if self . _done : <EOL> eventloop . queue_call ( None , callback , * args , ** kwds ) <EOL> else : <EOL> self . _callbacks . append ( ( callback , args , kwds ) ) <EOL> def add_immediate_callback ( self , callback , * args , ** kwds ) : <EOL> if self . _done : <EOL> callback ( * args , ** kwds ) <EOL> else : <EOL> self . _immediate_callbacks . append ( ( callback , args , kwds ) ) <EOL> def set_result ( self , result ) : <EOL> if self . _done : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> self . _result = result <EOL> self . _done = True <EOL> _state . remove_pending ( self ) <EOL> for callback , args , kwds in self . _immediate_callbacks : <EOL> callback ( * args , ** kwds ) <EOL> for callback , args , kwds in self . _callbacks : <EOL> eventloop . queue_call ( None , callback , * args , ** kwds ) <EOL> def set_exception ( self , exc , tb = None ) : <EOL> if not isinstance ( exc , BaseException ) : <EOL> raise TypeError ( '<STR_LIT>' % exc ) <EOL> if self . _done : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> self . _exception = exc <EOL> self . _traceback = tb <EOL> self . _done = True <EOL> _state . remove_pending ( self , status = '<STR_LIT>' ) <EOL> for callback , args , kwds in self . _immediate_callbacks : <EOL> callback ( * args , ** kwds ) <EOL> for callback , args , kwds in self . _callbacks : <EOL> eventloop . queue_call ( None , callback , * args , ** kwds ) <EOL> def done ( self ) : <EOL> return self . _done <EOL> @ property <EOL> def state ( self ) : <EOL> if self . _done : <EOL> return self . FINISHING <EOL> else : <EOL> return self . RUNNING <EOL> def wait ( self ) : <EOL> if self . _done : <EOL> return <EOL> ev = eventloop . get_event_loop ( ) <EOL> while not self . _done : <EOL> if not ev . run1 ( ) : <EOL> logging . info ( '<STR_LIT>' , self ) <EOL> logging . info ( '<STR_LIT>' , _state . dump_all_pending ( ) ) <EOL> _logging_debug ( '<STR_LIT>' , <EOL> _state . dump_all_pending ( verbose = True ) ) <EOL> self . set_exception ( RuntimeError ( '<STR_LIT>' % self ) ) <EOL> def get_exception ( self ) : <EOL> self . wait ( ) <EOL> return self . _exception <EOL> def get_traceback ( self ) : <EOL> self . wait ( ) <EOL> return self . _traceback <EOL> def check_success ( self ) : <EOL> self . wait ( ) <EOL> if self . _exception is not None : <EOL> raise self . _exception . __class__ , self . _exception , self . _traceback <EOL> def get_result ( self ) : <EOL> self . check_success ( ) <EOL> return self . _result <EOL> @ classmethod <EOL> def wait_any ( cls , futures ) : <EOL> waiting_on = set ( futures ) <EOL> ev = eventloop . get_event_loop ( ) <EOL> while waiting_on : <EOL> for f in waiting_on : <EOL> if f . state == cls . FINISHING : <EOL> return f <EOL> ev . run1 ( ) <EOL> return None <EOL> @ classmethod <EOL> def wait_all ( cls , futures ) : <EOL> waiting_on = set ( futures ) <EOL> ev = eventloop . get_event_loop ( ) <EOL> while waiting_on : <EOL> waiting_on = set ( f for f in waiting_on if f . state == cls . RUNNING ) <EOL> ev . run1 ( ) <EOL> def _help_tasklet_along ( self , ns , ds_conn , gen , val = None , exc = None , tb = None ) : <EOL> info = utils . gen_info ( gen ) <EOL> __ndb_debug__ = info <EOL> try : <EOL> save_context = get_context ( ) <EOL> save_namespace = namespace_manager . get_namespace ( ) <EOL> save_ds_connection = datastore . _GetConnection ( ) <EOL> try : <EOL> set_context ( self . _context ) <EOL> if ns != save_namespace : <EOL> namespace_manager . set_namespace ( ns ) <EOL> if ds_conn is not save_ds_connection : <EOL> datastore . _SetConnection ( ds_conn ) <EOL> if exc is not None : <EOL> _logging_debug ( '<STR_LIT>' , <EOL> exc . __class__ . __name__ , exc , info ) <EOL> value = gen . throw ( exc . __class__ , exc , tb ) <EOL> else : <EOL> _logging_debug ( '<STR_LIT>' , val , info ) <EOL> value = gen . send ( val ) <EOL> self . _context = get_context ( ) <EOL> finally : <EOL> ns = namespace_manager . get_namespace ( ) <EOL> ds_conn = datastore . _GetConnection ( ) <EOL> set_context ( save_context ) <EOL> if save_namespace != ns : <EOL> namespace_manager . set_namespace ( save_namespace ) <EOL> if save_ds_connection is not ds_conn : <EOL> datastore . _SetConnection ( save_ds_connection ) <EOL> except StopIteration , err : <EOL> result = get_return_value ( err ) <EOL> _logging_debug ( '<STR_LIT>' , info , result ) <EOL> self . set_result ( result ) <EOL> return <EOL> except GeneratorExit : <EOL> raise <EOL> except Exception , err : <EOL> _ , _ , tb = sys . exc_info ( ) <EOL> if isinstance ( err , _flow_exceptions ) : <EOL> _logging_debug ( '<STR_LIT>' , <EOL> info , err . __class__ . __name__ , err ) <EOL> elif utils . DEBUG and logging . getLogger ( ) . level < logging . DEBUG : <EOL> logging . warning ( '<STR_LIT>' , <EOL> info , err . __class__ . __name__ , err , exc_info = True ) <EOL> else : <EOL> logging . warning ( '<STR_LIT>' , info , err . __class__ . __name__ , err ) <EOL> self . set_exception ( err , tb ) <EOL> return <EOL> else : <EOL> _logging_debug ( '<STR_LIT>' , info , value ) <EOL> if isinstance ( value , ( apiproxy_stub_map . UserRPC , <EOL> datastore_rpc . MultiRpc ) ) : <EOL> eventloop . queue_rpc ( value , self . _on_rpc_completion , <EOL> value , ns , ds_conn , gen ) <EOL> return <EOL> if isinstance ( value , Future ) : <EOL> if self . _next : <EOL> raise RuntimeError ( '<STR_LIT>' % <EOL> self . _next ) <EOL> self . _next = value <EOL> self . _geninfo = utils . gen_info ( gen ) <EOL> _logging_debug ( '<STR_LIT>' , self , value ) <EOL> value . add_callback ( self . _on_future_completion , value , ns , ds_conn , gen ) <EOL> return <EOL> if isinstance ( value , ( tuple , list ) ) : <EOL> info = '<STR_LIT>' % utils . gen_info ( gen ) <EOL> mfut = MultiFuture ( info ) <EOL> try : <EOL> for subfuture in value : <EOL> mfut . add_dependent ( subfuture ) <EOL> mfut . complete ( ) <EOL> except GeneratorExit : <EOL> raise <EOL> except Exception , err : <EOL> _ , _ , tb = sys . exc_info ( ) <EOL> mfut . set_exception ( err , tb ) <EOL> mfut . add_callback ( self . _on_future_completion , mfut , ns , ds_conn , gen ) <EOL> return <EOL> if _is_generator ( value ) : <EOL> raise NotImplementedError ( '<STR_LIT>' ) <EOL> raise RuntimeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % ( info , value ) ) <EOL> def _on_rpc_completion ( self , rpc , ns , ds_conn , gen ) : <EOL> try : <EOL> result = rpc . get_result ( ) <EOL> except GeneratorExit : <EOL> raise <EOL> except Exception , err : <EOL> _ , _ , tb = sys . exc_info ( ) <EOL> self . _help_tasklet_along ( ns , ds_conn , gen , exc = err , tb = tb ) <EOL> else : <EOL> self . _help_tasklet_along ( ns , ds_conn , gen , result ) <EOL> def _on_future_completion ( self , future , ns , ds_conn , gen ) : <EOL> if self . _next is future : <EOL> self . _next = None <EOL> self . _geninfo = None <EOL> _logging_debug ( '<STR_LIT>' , self , future ) <EOL> exc = future . get_exception ( ) <EOL> if exc is not None : <EOL> self . _help_tasklet_along ( ns , ds_conn , gen , <EOL> exc = exc , tb = future . get_traceback ( ) ) <EOL> else : <EOL> val = future . get_result ( ) <EOL> self . _help_tasklet_along ( ns , ds_conn , gen , val ) <EOL> def sleep ( dt ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fut = Future ( '<STR_LIT>' % dt ) <EOL> eventloop . queue_call ( dt , fut . set_result , None ) <EOL> return fut <EOL> class MultiFuture ( Future ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , info = None ) : <EOL> __ndb_debug__ = '<STR_LIT>' <EOL> self . _full = False <EOL> self . _dependents = set ( ) <EOL> self . _results = [ ] <EOL> super ( MultiFuture , self ) . __init__ ( info = info ) <EOL> def __repr__ ( self ) : <EOL> line = super ( MultiFuture , self ) . __repr__ ( ) <EOL> lines = [ line ] <EOL> for fut in self . _results : <EOL> lines . append ( fut . dump_stack ( ) . replace ( '<STR_LIT:\\n>' , '<STR_LIT>' ) ) <EOL> return '<STR_LIT>' . join ( lines ) <EOL> def complete ( self ) : <EOL> if self . _full : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> self . _full = True <EOL> if not self . _dependents : <EOL> self . _finish ( ) <EOL> def set_exception ( self , exc , tb = None ) : <EOL> self . _full = True <EOL> super ( MultiFuture , self ) . set_exception ( exc , tb ) <EOL> def _finish ( self ) : <EOL> if not self . _full : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> if self . _dependents : <EOL> raise RuntimeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % self . _dependents ) <EOL> if self . _done : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> try : <EOL> result = [ r . get_result ( ) for r in self . _results ] <EOL> except GeneratorExit : <EOL> raise <EOL> except Exception , err : <EOL> _ , _ , tb = sys . exc_info ( ) <EOL> self . set_exception ( err , tb ) <EOL> else : <EOL> self . set_result ( result ) <EOL> def putq ( self , value ) : <EOL> if isinstance ( value , Future ) : <EOL> fut = value <EOL> else : <EOL> fut = Future ( ) <EOL> fut . set_result ( value ) <EOL> self . add_dependent ( fut ) <EOL> def add_dependent ( self , fut ) : <EOL> if isinstance ( fut , list ) : <EOL> mfut = MultiFuture ( ) <EOL> map ( mfut . add_dependent , fut ) <EOL> mfut . complete ( ) <EOL> fut = mfut <EOL> elif not isinstance ( fut , Future ) : <EOL> raise TypeError ( '<STR_LIT>' % ( type ( fut ) , fut ) ) <EOL> if self . _full : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> self . _results . append ( fut ) <EOL> if fut not in self . _dependents : <EOL> self . _dependents . add ( fut ) <EOL> fut . add_callback ( self . _signal_dependent_done , fut ) <EOL> def _signal_dependent_done ( self , fut ) : <EOL> self . _dependents . remove ( fut ) <EOL> if self . _full and not self . _dependents and not self . _done : <EOL> self . _finish ( ) <EOL> class QueueFuture ( Future ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , info = None ) : <EOL> self . _full = False <EOL> self . _dependents = set ( ) <EOL> self . _completed = collections . deque ( ) <EOL> self . _waiting = collections . deque ( ) <EOL> super ( QueueFuture , self ) . __init__ ( info = info ) <EOL> def complete ( self ) : <EOL> if self . _full : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> self . _full = True <EOL> if not self . _dependents : <EOL> self . set_result ( None ) <EOL> self . _mark_finished ( ) <EOL> def set_exception ( self , exc , tb = None ) : <EOL> self . _full = True <EOL> super ( QueueFuture , self ) . set_exception ( exc , tb ) <EOL> if not self . _dependents : <EOL> self . _mark_finished ( ) <EOL> def putq ( self , value ) : <EOL> if isinstance ( value , Future ) : <EOL> fut = value <EOL> else : <EOL> fut = Future ( ) <EOL> fut . set_result ( value ) <EOL> self . add_dependent ( fut ) <EOL> def add_dependent ( self , fut ) : <EOL> if not isinstance ( fut , Future ) : <EOL> raise TypeError ( '<STR_LIT>' % fut ) <EOL> if self . _full : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> if fut not in self . _dependents : <EOL> self . _dependents . add ( fut ) <EOL> fut . add_callback ( self . _signal_dependent_done , fut ) <EOL> def _signal_dependent_done ( self , fut ) : <EOL> if not fut . done ( ) : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> self . _dependents . remove ( fut ) <EOL> exc = fut . get_exception ( ) <EOL> tb = fut . get_traceback ( ) <EOL> val = None <EOL> if exc is None : <EOL> val = fut . get_result ( ) <EOL> if self . _waiting : <EOL> waiter = self . _waiting . popleft ( ) <EOL> self . _pass_result ( waiter , exc , tb , val ) <EOL> else : <EOL> self . _completed . append ( ( exc , tb , val ) ) <EOL> if self . _full and not self . _dependents and not self . _done : <EOL> self . set_result ( None ) <EOL> self . _mark_finished ( ) <EOL> def _mark_finished ( self ) : <EOL> if not self . done ( ) : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> while self . _waiting : <EOL> waiter = self . _waiting . popleft ( ) <EOL> self . _pass_eof ( waiter ) <EOL> def getq ( self ) : <EOL> fut = Future ( ) <EOL> if self . _completed : <EOL> exc , tb , val = self . _completed . popleft ( ) <EOL> self . _pass_result ( fut , exc , tb , val ) <EOL> elif self . _full and not self . _dependents : <EOL> self . _pass_eof ( fut ) <EOL> else : <EOL> self . _waiting . append ( fut ) <EOL> return fut <EOL> def _pass_eof ( self , fut ) : <EOL> if not self . _done : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> exc = self . get_exception ( ) <EOL> if exc is not None : <EOL> tb = self . get_traceback ( ) <EOL> else : <EOL> exc = EOFError ( '<STR_LIT>' ) <EOL> tb = None <EOL> self . _pass_result ( fut , exc , tb , None ) <EOL> def _pass_result ( self , fut , exc , tb , val ) : <EOL> if exc is not None : <EOL> fut . set_exception ( exc , tb ) <EOL> else : <EOL> fut . set_result ( val ) <EOL> class SerialQueueFuture ( Future ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , info = None ) : <EOL> self . _queue = collections . deque ( ) <EOL> self . _waiting = collections . deque ( ) <EOL> super ( SerialQueueFuture , self ) . __init__ ( info = info ) <EOL> def complete ( self ) : <EOL> while self . _waiting : <EOL> waiter = self . _waiting . popleft ( ) <EOL> waiter . set_exception ( EOFError ( '<STR_LIT>' ) ) <EOL> self . set_result ( None ) <EOL> def set_exception ( self , exc , tb = None ) : <EOL> super ( SerialQueueFuture , self ) . set_exception ( exc , tb ) <EOL> while self . _waiting : <EOL> waiter = self . _waiting . popleft ( ) <EOL> waiter . set_exception ( exc , tb ) <EOL> def putq ( self , value ) : <EOL> if isinstance ( value , Future ) : <EOL> fut = value <EOL> else : <EOL> if self . _waiting : <EOL> waiter = self . _waiting . popleft ( ) <EOL> waiter . set_result ( value ) <EOL> return <EOL> fut = Future ( ) <EOL> fut . set_result ( value ) <EOL> self . add_dependent ( fut ) <EOL> def add_dependent ( self , fut ) : <EOL> if not isinstance ( fut , Future ) : <EOL> raise TypeError ( '<STR_LIT>' % fut ) <EOL> if self . _done : <EOL> raise RuntimeError ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> if self . _waiting : <EOL> waiter = self . _waiting . popleft ( ) <EOL> fut . add_callback ( _transfer_result , fut , waiter ) <EOL> else : <EOL> self . _queue . append ( fut ) <EOL> def getq ( self ) : <EOL> if self . _queue : <EOL> fut = self . _queue . popleft ( ) <EOL> else : <EOL> fut = Future ( ) <EOL> if self . _done : <EOL> err = self . get_exception ( ) <EOL> if err is not None : <EOL> tb = self . get_traceback ( ) <EOL> else : <EOL> err = EOFError ( '<STR_LIT>' ) <EOL> tb = None <EOL> fut . set_exception ( err , tb ) <EOL> else : <EOL> self . _waiting . append ( fut ) <EOL> return fut <EOL> def _transfer_result ( fut1 , fut2 ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> exc = fut1 . get_exception ( ) <EOL> if exc is not None : <EOL> tb = fut1 . get_traceback ( ) <EOL> fut2 . set_exception ( exc , tb ) <EOL> else : <EOL> val = fut1 . get_result ( ) <EOL> fut2 . set_result ( val ) <EOL> class ReducingFuture ( Future ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , reducer , info = None , batch_size = <NUM_LIT:20> ) : <EOL> self . _reducer = reducer <EOL> self . _batch_size = batch_size <EOL> self . _full = False <EOL> self . _dependents = set ( ) <EOL> self . _completed = collections . deque ( ) <EOL> self . _queue = collections . deque ( ) <EOL> super ( ReducingFuture , self ) . __init__ ( info = info ) <EOL> def complete ( self ) : <EOL> if self . _full : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> self . _full = True <EOL> if not self . _dependents : <EOL> self . _mark_finished ( ) <EOL> def set_exception ( self , exc , tb = None ) : <EOL> self . _full = True <EOL> self . _queue . clear ( ) <EOL> super ( ReducingFuture , self ) . set_exception ( exc , tb ) <EOL> def putq ( self , value ) : <EOL> if isinstance ( value , Future ) : <EOL> fut = value <EOL> else : <EOL> fut = Future ( ) <EOL> fut . set_result ( value ) <EOL> self . add_dependent ( fut ) <EOL> def add_dependent ( self , fut ) : <EOL> if self . _full : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> self . _internal_add_dependent ( fut ) <EOL> def _internal_add_dependent ( self , fut ) : <EOL> if not isinstance ( fut , Future ) : <EOL> raise TypeError ( '<STR_LIT>' % fut ) <EOL> if fut not in self . _dependents : <EOL> self . _dependents . add ( fut ) <EOL> fut . add_callback ( self . _signal_dependent_done , fut ) <EOL> def _signal_dependent_done ( self , fut ) : <EOL> if not fut . done ( ) : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> self . _dependents . remove ( fut ) <EOL> if self . _done : <EOL> return <EOL> try : <EOL> val = fut . get_result ( ) <EOL> except GeneratorExit : <EOL> raise <EOL> except Exception , err : <EOL> _ , _ , tb = sys . exc_info ( ) <EOL> self . set_exception ( err , tb ) <EOL> return <EOL> self . _queue . append ( val ) <EOL> if len ( self . _queue ) >= self . _batch_size : <EOL> todo = list ( self . _queue ) <EOL> self . _queue . clear ( ) <EOL> try : <EOL> nval = self . _reducer ( todo ) <EOL> except GeneratorExit : <EOL> raise <EOL> except Exception , err : <EOL> _ , _ , tb = sys . exc_info ( ) <EOL> self . set_exception ( err , tb ) <EOL> return <EOL> if isinstance ( nval , Future ) : <EOL> self . _internal_add_dependent ( nval ) <EOL> else : <EOL> self . _queue . append ( nval ) <EOL> if self . _full and not self . _dependents : <EOL> self . _mark_finished ( ) <EOL> def _mark_finished ( self ) : <EOL> if not self . _queue : <EOL> self . set_result ( None ) <EOL> elif len ( self . _queue ) == <NUM_LIT:1> : <EOL> self . set_result ( self . _queue . pop ( ) ) <EOL> else : <EOL> todo = list ( self . _queue ) <EOL> self . _queue . clear ( ) <EOL> try : <EOL> nval = self . _reducer ( todo ) <EOL> except GeneratorExit : <EOL> raise <EOL> except Exception , err : <EOL> _ , _ , tb = sys . exc_info ( ) <EOL> self . set_exception ( err , tb ) <EOL> return <EOL> if isinstance ( nval , Future ) : <EOL> self . _internal_add_dependent ( nval ) <EOL> else : <EOL>", "answer": "self . set_result ( nval )"}, {"prompt": "<s> import datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> from django . contrib . auth import get_user_model <EOL> User = get_user_model ( ) <EOL> class Migration ( SchemaMigration ) : <EOL> depends_on = ( <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ) <EOL> def forwards ( self , orm ) : <EOL> db . create_table ( u'<STR_LIT>' , ( <EOL> ( u'<STR_LIT:id>' , self . gf ( '<STR_LIT>' ) ( primary_key = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( auto_now_add = True , blank = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( auto_now = True , blank = True ) ) , <EOL> ( '<STR_LIT:user>' , self . gf ( '<STR_LIT>' ) ( to = orm [ '<STR_LIT>' % ( User . _meta . app_label , User . _meta . object_name ) ] ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = <NUM_LIT:1> , to = orm [ '<STR_LIT>' ] ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( db_index = True , max_length = <NUM_LIT:4> , null = True , blank = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( db_index = True , max_length = <NUM_LIT:100> , null = True , blank = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = datetime . datetime . now , null = True , db_index = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = False , db_index = True ) ) , <EOL> ( '<STR_LIT:name>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT> ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( unique = True , max_length = <NUM_LIT> ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT> ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( default = <NUM_LIT:7> ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT:1> ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( to = orm [ '<STR_LIT>' ] , null = True , blank = True ) ) , <EOL> ( '<STR_LIT>' , self . gf ( '<STR_LIT>' ) ( null = True , blank = True ) ) , <EOL> ) ) <EOL> db . send_create_signal ( u'<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> def backwards ( self , orm ) : <EOL> db . delete_table ( u'<STR_LIT>' ) <EOL> models = { <EOL> u'<STR_LIT>' % ( User . _meta . app_label , User . _meta . module_name ) : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : User . __name__ } , <EOL>", "answer": "} ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from google . appengine . _internal . django . conf import settings <EOL> from google . appengine . _internal . django . core . serializers import base <EOL> from google . appengine . _internal . django . db import models , DEFAULT_DB_ALIAS <EOL> from google . appengine . _internal . django . utils . xmlutils import SimplerXMLGenerator <EOL> from google . appengine . _internal . django . utils . encoding import smart_unicode <EOL> from xml . dom import pulldom <EOL> class Serializer ( base . Serializer ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def indent ( self , level ) : <EOL> if self . options . get ( '<STR_LIT>' , None ) is not None : <EOL> self . xml . ignorableWhitespace ( '<STR_LIT:\\n>' + '<STR_LIT:U+0020>' * self . options . get ( '<STR_LIT>' , None ) * level ) <EOL> def start_serialization ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . xml = SimplerXMLGenerator ( self . stream , self . options . get ( \"<STR_LIT>\" , settings . DEFAULT_CHARSET ) ) <EOL> self . xml . startDocument ( ) <EOL> self . xml . startElement ( \"<STR_LIT>\" , { \"<STR_LIT:version>\" : \"<STR_LIT:1.0>\" } ) <EOL> def end_serialization ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . indent ( <NUM_LIT:0> ) <EOL> self . xml . endElement ( \"<STR_LIT>\" ) <EOL> self . xml . endDocument ( ) <EOL> def start_object ( self , obj ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not hasattr ( obj , \"<STR_LIT>\" ) : <EOL> raise base . SerializationError ( \"<STR_LIT>\" % type ( obj ) ) <EOL> self . indent ( <NUM_LIT:1> ) <EOL> obj_pk = obj . _get_pk_val ( ) <EOL> if obj_pk is None : <EOL> attrs = { \"<STR_LIT>\" : smart_unicode ( obj . _meta ) , } <EOL> else : <EOL> attrs = { <EOL> \"<STR_LIT>\" : smart_unicode ( obj . _get_pk_val ( ) ) , <EOL> \"<STR_LIT>\" : smart_unicode ( obj . _meta ) , <EOL> } <EOL> self . xml . startElement ( \"<STR_LIT:object>\" , attrs ) <EOL> def end_object ( self , obj ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . indent ( <NUM_LIT:1> ) <EOL> self . xml . endElement ( \"<STR_LIT:object>\" ) <EOL> def handle_field ( self , obj , field ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . indent ( <NUM_LIT:2> ) <EOL> self . xml . startElement ( \"<STR_LIT>\" , { <EOL> \"<STR_LIT:name>\" : field . name , <EOL> \"<STR_LIT:type>\" : field . get_internal_type ( ) <EOL> } ) <EOL> if getattr ( obj , field . name ) is not None : <EOL> self . xml . characters ( field . value_to_string ( obj ) ) <EOL> else : <EOL> self . xml . addQuickElement ( \"<STR_LIT:None>\" ) <EOL> self . xml . endElement ( \"<STR_LIT>\" ) <EOL> def handle_fk_field ( self , obj , field ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _start_relational_field ( field ) <EOL> related = getattr ( obj , field . name ) <EOL> if related is not None : <EOL> if self . use_natural_keys and hasattr ( related , '<STR_LIT>' ) : <EOL> related = related . natural_key ( ) <EOL> for key_value in related : <EOL> self . xml . startElement ( \"<STR_LIT>\" , { } ) <EOL> self . xml . characters ( smart_unicode ( key_value ) ) <EOL> self . xml . endElement ( \"<STR_LIT>\" ) <EOL> else : <EOL> if field . rel . field_name == related . _meta . pk . name : <EOL> related = related . _get_pk_val ( ) <EOL> else : <EOL> related = getattr ( related , field . rel . field_name ) <EOL> self . xml . characters ( smart_unicode ( related ) ) <EOL> else : <EOL> self . xml . addQuickElement ( \"<STR_LIT:None>\" ) <EOL> self . xml . endElement ( \"<STR_LIT>\" ) <EOL> def handle_m2m_field ( self , obj , field ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if field . rel . through . _meta . auto_created : <EOL> self . _start_relational_field ( field ) <EOL> if self . use_natural_keys and hasattr ( field . rel . to , '<STR_LIT>' ) : <EOL> def handle_m2m ( value ) : <EOL> natural = value . natural_key ( ) <EOL> self . xml . startElement ( \"<STR_LIT:object>\" , { } ) <EOL> for key_value in natural : <EOL> self . xml . startElement ( \"<STR_LIT>\" , { } ) <EOL> self . xml . characters ( smart_unicode ( key_value ) ) <EOL> self . xml . endElement ( \"<STR_LIT>\" ) <EOL> self . xml . endElement ( \"<STR_LIT:object>\" ) <EOL> else : <EOL> def handle_m2m ( value ) : <EOL> self . xml . addQuickElement ( \"<STR_LIT:object>\" , attrs = { <EOL> '<STR_LIT>' : smart_unicode ( value . _get_pk_val ( ) ) <EOL> } ) <EOL> for relobj in getattr ( obj , field . name ) . iterator ( ) : <EOL> handle_m2m ( relobj ) <EOL> self . xml . endElement ( \"<STR_LIT>\" ) <EOL> def _start_relational_field ( self , field ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . indent ( <NUM_LIT:2> ) <EOL> self . xml . startElement ( \"<STR_LIT>\" , { <EOL> \"<STR_LIT:name>\" : field . name , <EOL> \"<STR_LIT>\" : field . rel . __class__ . __name__ , <EOL> \"<STR_LIT:to>\" : smart_unicode ( field . rel . to . _meta ) , <EOL> } ) <EOL> class Deserializer ( base . Deserializer ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , stream_or_string , ** options ) : <EOL> super ( Deserializer , self ) . __init__ ( stream_or_string , ** options ) <EOL> self . event_stream = pulldom . parse ( self . stream ) <EOL> self . db = options . pop ( '<STR_LIT>' , DEFAULT_DB_ALIAS ) <EOL> def next ( self ) : <EOL> for event , node in self . event_stream : <EOL> if event == \"<STR_LIT>\" and node . nodeName == \"<STR_LIT:object>\" : <EOL> self . event_stream . expandNode ( node ) <EOL> return self . _handle_object ( node ) <EOL> raise StopIteration <EOL> def _handle_object ( self , node ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from django . apps import AppConfig <EOL> class RulesConfig ( AppConfig ) : <EOL> name = '<STR_LIT>' <EOL> class AutodiscoverRulesConfig ( RulesConfig ) : <EOL> def ready ( self ) : <EOL>", "answer": "from django . utils . module_loading import autodiscover_modules"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL>", "answer": "import oscar . models . fields . autoslugfield"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import sys <EOL> import os <EOL> _base = os . path . dirname ( __file__ ) <EOL> site_root = os . path . realpath ( os . path . join ( _base , '<STR_LIT>' ) ) <EOL> sys . path . append ( site_root ) <EOL> import manage <EOL> from django . test import TestCase <EOL> import models <EOL> from test_utils import setup_test_environment , TestCase <EOL> setup_test_environment ( ) <EOL> from django . contrib . auth . models import User <EOL> from django . test . client import Client <EOL> class OwnerTest ( TestCase ) : <EOL> fixtures = [ '<STR_LIT>' ] <EOL> def setUp ( self ) : <EOL>", "answer": "self . client = Client ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import time <EOL> from google . appengine . api import validation <EOL> from google . appengine . api import yaml_builder <EOL> from google . appengine . api import yaml_errors <EOL> from google . appengine . api import yaml_listener <EOL> from google . appengine . api import yaml_object <EOL> from google . appengine . ext import db <EOL> from google . appengine . ext . mapreduce import base_handler <EOL> from google . appengine . ext . mapreduce import errors <EOL> from google . appengine . ext . mapreduce import model <EOL> MR_YAML_NAMES = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> class BadStatusParameterError ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class UserParam ( validation . Validated ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ATTRIBUTES = { <EOL> \"<STR_LIT:name>\" : r\"<STR_LIT>\" , <EOL> \"<STR_LIT:default>\" : validation . Optional ( r\"<STR_LIT>\" ) , <EOL> \"<STR_LIT:value>\" : validation . Optional ( r\"<STR_LIT>\" ) , <EOL> } <EOL> class MapperInfo ( validation . Validated ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ATTRIBUTES = { <EOL> \"<STR_LIT>\" : r\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : r\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : validation . Optional ( r\"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : validation . Optional ( validation . Repeated ( UserParam ) ) , <EOL> \"<STR_LIT>\" : validation . Optional ( r\"<STR_LIT>\" ) , <EOL> } <EOL> class MapreduceInfo ( validation . Validated ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ATTRIBUTES = { <EOL> \"<STR_LIT:name>\" : r\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : MapperInfo , <EOL> \"<STR_LIT>\" : validation . Optional ( validation . Repeated ( UserParam ) ) , <EOL> \"<STR_LIT>\" : validation . Optional ( r\"<STR_LIT>\" ) , <EOL> } <EOL> class MapReduceYaml ( validation . Validated ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ATTRIBUTES = { <EOL> \"<STR_LIT>\" : validation . Optional ( validation . Repeated ( MapreduceInfo ) ) <EOL> } <EOL> @ staticmethod <EOL> def to_dict ( mapreduce_yaml ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> all_configs = [ ] <EOL> for config in mapreduce_yaml . mapreduce : <EOL> out = { <EOL> \"<STR_LIT:name>\" : config . name , <EOL> \"<STR_LIT>\" : config . mapper . input_reader , <EOL> \"<STR_LIT>\" : config . mapper . handler , <EOL> } <EOL> if config . mapper . params_validator : <EOL> out [ \"<STR_LIT>\" ] = config . mapper . params_validator <EOL> if config . mapper . params : <EOL> param_defaults = { } <EOL> for param in config . mapper . params : <EOL> param_defaults [ param . name ] = param . default or param . value <EOL> out [ \"<STR_LIT>\" ] = param_defaults <EOL> if config . params : <EOL> param_defaults = { } <EOL> for param in config . params : <EOL> param_defaults [ param . name ] = param . default or param . value <EOL> out [ \"<STR_LIT>\" ] = param_defaults <EOL> if config . mapper . output_writer : <EOL> out [ \"<STR_LIT>\" ] = config . mapper . output_writer <EOL> all_configs . append ( out ) <EOL> return all_configs <EOL> def find_mapreduce_yaml ( status_file = __file__ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> checked = set ( ) <EOL> yaml = _find_mapreduce_yaml ( os . path . dirname ( status_file ) , checked ) <EOL> if not yaml : <EOL> yaml = _find_mapreduce_yaml ( os . getcwd ( ) , checked ) <EOL> return yaml <EOL> def _find_mapreduce_yaml ( start , checked ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dir = start <EOL> while dir not in checked : <EOL> checked . add ( dir ) <EOL> for mr_yaml_name in MR_YAML_NAMES : <EOL> yaml_path = os . path . join ( dir , mr_yaml_name ) <EOL> if os . path . exists ( yaml_path ) : <EOL> return yaml_path <EOL> dir = os . path . dirname ( dir ) <EOL> return None <EOL> def parse_mapreduce_yaml ( contents ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> builder = yaml_object . ObjectBuilder ( MapReduceYaml ) <EOL> handler = yaml_builder . BuilderHandler ( builder ) <EOL> listener = yaml_listener . EventListener ( handler ) <EOL> listener . Parse ( contents ) <EOL> mr_info = handler . GetResults ( ) <EOL> except ( ValueError , yaml_errors . EventError ) , e : <EOL> raise errors . BadYamlError ( e ) <EOL> if len ( mr_info ) < <NUM_LIT:1> : <EOL> raise errors . BadYamlError ( \"<STR_LIT>\" ) <EOL> if len ( mr_info ) > <NUM_LIT:1> : <EOL> raise errors . MultipleDocumentsInMrYaml ( \"<STR_LIT>\" % <EOL> len ( mr_info ) ) <EOL> jobs = mr_info [ <NUM_LIT:0> ] <EOL> job_names = set ( j . name for j in jobs . mapreduce ) <EOL> if len ( jobs . mapreduce ) != len ( job_names ) : <EOL> raise errors . BadYamlError ( <EOL> \"<STR_LIT>\" ) <EOL> return jobs <EOL> def get_mapreduce_yaml ( parse = parse_mapreduce_yaml ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> mr_yaml_path = find_mapreduce_yaml ( ) <EOL> if not mr_yaml_path : <EOL> raise errors . MissingYamlError ( ) <EOL> mr_yaml_file = open ( mr_yaml_path ) <EOL> try : <EOL> return parse ( mr_yaml_file . read ( ) ) <EOL> finally : <EOL> mr_yaml_file . close ( ) <EOL> class ResourceHandler ( base_handler . BaseHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "_RESOURCE_MAP = {"}, {"prompt": "<s> __author__ = \"<STR_LIT>\" <EOL> a = [ <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> , <NUM_LIT:6> , <NUM_LIT:7> ] <EOL> b = [ ] <EOL> for i in a : <EOL> if i > <NUM_LIT:4> : <EOL> b . append ( i ) <EOL>", "answer": "print b"}, {"prompt": "<s> import unittest <EOL> import pdfparanoia <EOL> class AmericanInstituteOfPhysicsTestCase ( unittest . TestCase ) : <EOL> def test_aip ( self ) : <EOL>", "answer": "file_handler = open ( \"<STR_LIT>\" , \"<STR_LIT:rb>\" )"}, {"prompt": "<s> import psycopg2 <EOL> import argparse <EOL> import os <EOL> parser = argparse . ArgumentParser ( ) <EOL> parser . add_argument ( \"<STR_LIT>\" , type = int ) <EOL> parser . add_argument ( \"<STR_LIT>\" , type = int ) <EOL> arguments = parser . parse_args ( ) <EOL> os . setgid ( arguments . gid ) <EOL> os . setuid ( arguments . uid ) <EOL> import configuration <EOL> db = psycopg2 . connect ( ** configuration . database . PARAMETERS ) <EOL> cursor = db . cursor ( ) <EOL> try : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL>", "answer": "except psycopg2 . ProgrammingError :"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from bbio import * <EOL> class ADT7310 ( object ) : <EOL> CONFIG_COMPARATOR = ( <NUM_LIT:1> << <NUM_LIT:4> ) <EOL> CONFIG_CONTINUOUS = ( <NUM_LIT> << <NUM_LIT:6> ) <EOL> CONFIG_SHUTDOWN = ( <NUM_LIT> << <NUM_LIT:6> ) <EOL> CONFIG_13BIT = ( <NUM_LIT:0> << <NUM_LIT:7> ) <EOL> CMD_READ = <NUM_LIT> <EOL> CMD_WRITE = <NUM_LIT> <EOL> CMD_CONTINUOUS = ( <NUM_LIT:1> << <NUM_LIT:2> ) <EOL> R_CONFIGURATION = <NUM_LIT> << <NUM_LIT:3> <EOL> R_TEMP = ( <NUM_LIT> << <NUM_LIT:3> ) <EOL> R_ID = ( <NUM_LIT> << <NUM_LIT:3> ) <EOL> R_CRIT = ( <NUM_LIT> << <NUM_LIT:3> ) <EOL> R_HYST = ( <NUM_LIT> << <NUM_LIT:3> ) <EOL> R_HIGH = ( <NUM_LIT> << <NUM_LIT:3> ) <EOL> R_LOW = ( <NUM_LIT> << <NUM_LIT:3> ) <EOL> _continuous = False <EOL> def __init__ ( self , spi_no , cs ) : <EOL> assert <NUM_LIT:0> <= spi_no < <NUM_LIT:2> , \"<STR_LIT>\" <EOL> assert <NUM_LIT:0> <= cs < <NUM_LIT:2> , \"<STR_LIT>\" <EOL> if spi_no == <NUM_LIT:0> : <EOL> self . spidev = SPI0 <EOL> else : <EOL> self . spidev = SPI1 <EOL> self . cs = cs <EOL> self . alarm_pin = None <EOL> self . critical_pin = None <EOL> self . spidev . begin ( ) <EOL> self . spidev . setDataMode ( self . cs , <NUM_LIT:3> ) <EOL> self . reset ( ) <EOL> self . spidev . write ( self . cs , [ self . CMD_WRITE | self . R_CONFIGURATION ] + [ self . CONFIG_COMPARATOR ] ) <EOL> self . _continuous = False <EOL> addToCleanup ( self . close ) <EOL> def close ( self ) : <EOL>", "answer": "'''<STR_LIT>'''"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Intangible ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from sentry import app <EOL> from flaskext . babel import ngettext , gettext <EOL> from jinja2 import Markup , escape <EOL> import datetime <EOL> import simplejson <EOL> @ app . template_filter ( ) <EOL> def maybe_link ( value ) : <EOL> if value . startswith ( '<STR_LIT:http>' ) and '<STR_LIT>' in value : <EOL> value = escape ( value ) <EOL> return Markup ( u'<STR_LIT>' % ( value , value ) ) <EOL> return value <EOL> @ app . template_filter ( ) <EOL> def as_sorted ( value ) : <EOL> return sorted ( value ) <EOL> @ app . template_filter ( ) <EOL> def is_dict ( value ) : <EOL> return isinstance ( value , dict ) <EOL> @ app . template_filter ( ) <EOL> def with_priority ( result_list , key = '<STR_LIT>' ) : <EOL> if result_list : <EOL> if isinstance ( result_list [ <NUM_LIT:0> ] , dict ) : <EOL> _get = lambda x , k : x [ k ] <EOL> else : <EOL> _get = lambda x , k : getattr ( x , k , <NUM_LIT:0> ) <EOL> min_ , max_ = min ( [ _get ( r , key ) for r in result_list ] ) , max ( [ _get ( r , key ) for r in result_list ] ) <EOL>", "answer": "mid = ( max_ - min_ ) / <NUM_LIT:4>"}, {"prompt": "<s> from thriftpy . protocol import TCyBinaryProtocolFactory <EOL> from thriftpy . thrift import TClient <EOL> from thriftpy . transport import ( <EOL> TCyBufferedTransportFactory , <EOL> TSocket ) <EOL> PROTO_FACTORY = TCyBinaryProtocolFactory <EOL> TRANS_FACTORY = TCyBufferedTransportFactory <EOL> def make_client ( service , host , port , timeout = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if timeout is None : <EOL> timeout = <NUM_LIT> * <NUM_LIT:1000> <EOL> return ClientProxy ( service , host , port , timeout ) <EOL> def _wrapper_api ( api , transport ) : <EOL> def wrapper ( * args , ** kwargs ) : <EOL> try : <EOL> transport . open ( ) <EOL>", "answer": "return api ( * args , ** kwargs )"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field = models . TextField ( blank = True ) , <EOL> preserve_default = True , <EOL> ) , <EOL>", "answer": "] "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import re <EOL> import signal <EOL> import subprocess <EOL> import tempfile <EOL> import time <EOL> import unittest <EOL> from django . db . models import get_models <EOL> from google . appengine . ext import db <EOL> from appengine_django . models import BaseModel <EOL> from appengine_django . models import ModelManager <EOL> from appengine_django . models import ModelOptions <EOL> from appengine_django . models import RegistrationTestModel <EOL> class CommandsTest ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> COMMAND_TIMEOUT = <NUM_LIT:10> <EOL> def runCommand ( self , command , args = None , int_after = None , input = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not args : <EOL> args = [ ] <EOL> start = time . time ( ) <EOL> int_sent = False <EOL> fd = subprocess . PIPE <EOL> child = subprocess . Popen ( [ \"<STR_LIT>\" , command ] + args , stdin = fd , <EOL> stdout = fd , stderr = fd , cwd = os . getcwdu ( ) ) <EOL> if input : <EOL> child . stdin . write ( input ) <EOL> child . stdin . close ( ) <EOL> while <NUM_LIT:1> : <EOL> rc = child . poll ( ) <EOL> if rc is not None : <EOL> break <EOL> elapsed = time . time ( ) - start <EOL> if int_after and int_after > <NUM_LIT:0> and elapsed > int_after and not int_sent : <EOL> os . kill ( child . pid , signal . SIGINT ) <EOL> start = time . time ( ) <EOL> int_sent = True <EOL> continue <EOL> if elapsed < self . COMMAND_TIMEOUT : <EOL> continue <EOL> os . kill ( child . pid , signal . SIGKILL ) <EOL> time . sleep ( <NUM_LIT:2> ) <EOL> break <EOL> return rc , child . stdout . read ( ) , child . stderr . read ( ) <EOL> def assertCommandSucceeds ( self , command , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rc , stdout , stderr = self . runCommand ( command , * args , ** kwargs ) <EOL> fd , tempname = tempfile . mkstemp ( ) <EOL> os . write ( fd , stdout ) <EOL> os . close ( fd ) <EOL> self . assertEquals ( <NUM_LIT:0> , rc , <EOL> \"<STR_LIT>\" % <EOL> ( command , rc , tempname ) ) <EOL> os . unlink ( tempname ) <EOL> def getCommands ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rc , stdout , stderr = self . runCommand ( \"<STR_LIT>\" ) <EOL> parts = re . split ( \"<STR_LIT>\" , stderr ) <EOL> if len ( parts ) < <NUM_LIT:2> : <EOL> return [ ] <EOL> return [ t . strip ( ) for t in parts [ - <NUM_LIT:1> ] . split ( \"<STR_LIT:\\n>\" ) if t . strip ( ) ] <EOL>", "answer": "def testDiffSettings ( self ) :"}, {"prompt": "<s> import mock <EOL> from openstackclient . tests import fakes <EOL> from openstackclient . tests import utils <EOL>", "answer": "from openstackclient . tests . volume . v1 import fakes as volume_fakes"}, {"prompt": "<s> from PyQt4 . QtGui import ( QDialog , QLabel , QComboBox , QDialogButtonBox , <EOL> QGridLayout , QLineEdit , QMessageBox , QCheckBox ) <EOL> from PyQt4 . QtCore import Qt , SIGNAL <EOL> class FilterGroupDialog ( QDialog ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , type = None , name = None , exclusive = False , parent = None ) : <EOL> QDialog . __init__ ( self , parent ) <EOL> self . setupUi ( ) <EOL> if type : <EOL> index = self . filterTypeComboBox . findText ( type ) <EOL> if index >= <NUM_LIT:0> : <EOL> self . filterTypeComboBox . setCurrentIndex ( index ) <EOL> if name : <EOL> self . nameLineEdit . setText ( name ) <EOL> self . filterTypeComboBox . setEnabled ( False ) <EOL> self . exclusiveCheckBox . setChecked ( exclusive ) <EOL> def setupUi ( self ) : <EOL> self . setWindowTitle ( '<STR_LIT>' ) <EOL> self . filterTypeComboBox = QComboBox ( self ) <EOL> self . filterTypeComboBox . addItem ( '<STR_LIT>' ) <EOL> self . filterTypeComboBox . addItem ( '<STR_LIT>' ) <EOL> self . filterTypeComboBox . addItem ( '<STR_LIT>' ) <EOL> self . filterTypeComboBox . addItem ( '<STR_LIT>' ) <EOL> self . filterTypeComboBox . addItem ( '<STR_LIT>' ) <EOL> self . nameLineEdit = QLineEdit ( ) <EOL> self . dialogButtonBox = QDialogButtonBox ( self ) <EOL> self . dialogButtonBox . setAutoFillBackground ( False ) <EOL> self . dialogButtonBox . setOrientation ( Qt . Horizontal ) <EOL> self . dialogButtonBox . setStandardButtons ( QDialogButtonBox . Cancel | QDialogButtonBox . Ok ) <EOL> self . dialogButtonBox . setCenterButtons ( True ) <EOL> self . exclusiveCheckBox = QCheckBox ( self ) <EOL> self . exclusiveCheckBox . setText ( '<STR_LIT>' ) <EOL> self . exclusiveCheckBox . setToolTip ( '<STR_LIT>' ) <EOL> gridLayout = QGridLayout ( self ) <EOL> gridLayout . addWidget ( QLabel ( '<STR_LIT>' , self ) , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> gridLayout . addWidget ( self . filterTypeComboBox , <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> gridLayout . addWidget ( QLabel ( '<STR_LIT>' , self ) , <NUM_LIT:1> , <NUM_LIT:0> ) <EOL> gridLayout . addWidget ( self . nameLineEdit , <NUM_LIT:1> , <NUM_LIT:1> ) <EOL> gridLayout . addWidget ( self . exclusiveCheckBox , <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> gridLayout . addWidget ( self . dialogButtonBox , <NUM_LIT:3> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> self . connect ( self . dialogButtonBox , SIGNAL ( '<STR_LIT>' ) , self . accept ) <EOL> self . connect ( self . dialogButtonBox , SIGNAL ( '<STR_LIT>' ) , self . reject ) <EOL> def name ( self ) : <EOL> return self . nameLineEdit . text ( ) <EOL> def type ( self ) : <EOL> return self . filterTypeComboBox . currentText ( ) <EOL>", "answer": "def exclusive ( self ) :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = <NUM_LIT:9> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import shutil <EOL> from behave import given , then , when <EOL> from helpers import ( <EOL> assertManifestsMatch , assertPackagesMatch , OpcCommand , ref_pkg_path , <EOL> scratch_path <EOL> ) <EOL> from step_data import Manifest , _Manifest <EOL> SUBCMD_BROWSE = '<STR_LIT>' <EOL> SUBCMD_DIFF = '<STR_LIT>' <EOL> SUBCMD_DIFF_ITEM = '<STR_LIT>' <EOL> SUBCMD_EXTRACT = '<STR_LIT>' <EOL> SUBCMD_REPACKAGE = '<STR_LIT>' <EOL>", "answer": "SUBCMD_SUBSTITUTE = '<STR_LIT>'"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Intangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> import sys <EOL> from remoteserver import RemoteServer <EOL> class DictResult ( object ) : <EOL> def return_dict ( self , ** kwargs ) : <EOL> return kwargs <EOL> def return_nested_dict ( self ) : <EOL>", "answer": "return dict ( key = '<STR_LIT:root>' , nested = dict ( key = <NUM_LIT> , nested = dict ( key = '<STR_LIT>' ) ) )"}, {"prompt": "<s> import logging <EOL> import sys <EOL> import pytest <EOL> from affine import Affine <EOL> import numpy <EOL> import rasterio <EOL> from rasterio . enums import Resampling <EOL> from rasterio . env import Env <EOL> from rasterio . warp import ( <EOL> reproject , transform_geom , transform , transform_bounds , <EOL> calculate_default_transform ) <EOL> logging . basicConfig ( stream = sys . stderr , level = logging . DEBUG ) <EOL> DST_TRANSFORM = Affine . from_gdal ( - <NUM_LIT> , <NUM_LIT> , <NUM_LIT:0.0> , <NUM_LIT> , <NUM_LIT:0.0> , - <NUM_LIT> ) <EOL> class ReprojectParams ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , left , bottom , right , top , width , height , src_crs , <EOL> dst_crs ) : <EOL> self . width = width <EOL> self . height = height <EOL> src_res = float ( right - left ) / float ( width ) <EOL> self . src_transform = Affine ( src_res , <NUM_LIT:0> , left , <NUM_LIT:0> , - src_res , top ) <EOL> self . src_crs = src_crs <EOL> self . dst_crs = dst_crs <EOL> with Env ( ) : <EOL> dt , dw , dh = calculate_default_transform ( <EOL> src_crs , dst_crs , width , height , left , bottom , right , top ) <EOL> self . dst_transform = dt <EOL> self . dst_width = dw <EOL> self . dst_height = dh <EOL> def default_reproject_params ( ) : <EOL> return ReprojectParams ( <EOL> left = - <NUM_LIT> , <EOL> bottom = <NUM_LIT:30> , <EOL> right = - <NUM_LIT> , <EOL> top = <NUM_LIT> , <EOL> width = <NUM_LIT> , <EOL> height = <NUM_LIT> , <EOL> src_crs = { '<STR_LIT>' : '<STR_LIT>' } , <EOL> dst_crs = { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> def test_transform ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> WGS84_crs = { '<STR_LIT>' : '<STR_LIT>' } <EOL> WGS84_points = ( [ <NUM_LIT> ] , [ <NUM_LIT> ] , [ <NUM_LIT> ] ) <EOL> ECEF_crs = { '<STR_LIT>' : '<STR_LIT>' } <EOL> ECEF_points = ( [ <NUM_LIT> ] , [ <NUM_LIT> ] , [ <NUM_LIT> ] ) <EOL> ECEF_result = transform ( WGS84_crs , ECEF_crs , * WGS84_points ) <EOL> assert numpy . allclose ( numpy . array ( ECEF_result ) , numpy . array ( ECEF_points ) ) <EOL> UTM33_crs = { '<STR_LIT>' : '<STR_LIT>' } <EOL> UTM33_points = ( [ <NUM_LIT> ] , [ <NUM_LIT> ] ) <EOL> UTM33_result = transform ( WGS84_crs , UTM33_crs , * WGS84_points [ : <NUM_LIT:2> ] ) <EOL> assert numpy . allclose ( numpy . array ( UTM33_result ) , numpy . array ( UTM33_points ) ) <EOL> def test_transform_bounds ( ) : <EOL> with Env ( ) : <EOL> with rasterio . open ( '<STR_LIT>' ) as src : <EOL> l , b , r , t = src . bounds <EOL> assert numpy . allclose ( <EOL> transform_bounds ( src . crs , { '<STR_LIT>' : '<STR_LIT>' } , l , b , r , t ) , <EOL> ( <EOL> - <NUM_LIT> , <NUM_LIT> , <EOL> - <NUM_LIT> , <NUM_LIT> <EOL> ) <EOL> ) <EOL> def test_transform_bounds_densify ( ) : <EOL> src_crs = { '<STR_LIT>' : '<STR_LIT>' } <EOL> dst_crs = { '<STR_LIT>' : '<STR_LIT>' } <EOL> assert numpy . allclose ( <EOL> transform_bounds ( <EOL> src_crs , <EOL> dst_crs , <EOL> - <NUM_LIT> , <NUM_LIT> , - <NUM_LIT> , <NUM_LIT:64> , <EOL> densify_pts = <NUM_LIT:0> <EOL> ) , <EOL> ( <EOL> <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> <EOL> ) <EOL> ) <EOL> assert numpy . allclose ( <EOL> transform_bounds ( <EOL> src_crs , <EOL> dst_crs , <EOL> - <NUM_LIT> , <NUM_LIT> , - <NUM_LIT> , <NUM_LIT:64> , <EOL> densify_pts = <NUM_LIT:100> <EOL> ) , <EOL> ( <EOL> <NUM_LIT> , <NUM_LIT> , <EOL> <NUM_LIT> , <NUM_LIT> <EOL> ) <EOL> ) <EOL> def test_transform_bounds_no_change ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with Env ( ) : <EOL> with rasterio . open ( '<STR_LIT>' ) as src : <EOL> l , b , r , t = src . bounds <EOL> assert numpy . allclose ( <EOL> transform_bounds ( src . crs , src . crs , l , b , r , t ) , <EOL> src . bounds <EOL> ) <EOL> def test_transform_bounds_densify_out_of_bounds ( ) : <EOL> with pytest . raises ( ValueError ) : <EOL> transform_bounds ( <EOL> { '<STR_LIT>' : '<STR_LIT>' } , <EOL> { '<STR_LIT>' : '<STR_LIT>' } , <EOL> - <NUM_LIT> , <NUM_LIT> , - <NUM_LIT> , <NUM_LIT:64> , <EOL> densify_pts = - <NUM_LIT:10> <EOL> ) <EOL> def test_calculate_default_transform ( ) : <EOL> target_transform = Affine ( <EOL> <NUM_LIT> , <NUM_LIT:0.0> , - <NUM_LIT> , <EOL> <NUM_LIT:0.0> , - <NUM_LIT> , <NUM_LIT> ) <EOL> with Env ( ) : <EOL> with rasterio . open ( '<STR_LIT>' ) as src : <EOL> wgs84_crs = { '<STR_LIT>' : '<STR_LIT>' } <EOL> dst_transform , width , height = calculate_default_transform ( <EOL> src . crs , wgs84_crs , src . width , src . height , * src . bounds ) <EOL> assert dst_transform . almost_equals ( target_transform ) <EOL> assert width == <NUM_LIT> <EOL> assert height == <NUM_LIT> <EOL> def test_calculate_default_transform_single_resolution ( ) : <EOL> with Env ( ) : <EOL> with rasterio . open ( '<STR_LIT>' ) as src : <EOL> target_resolution = <NUM_LIT:0.1> <EOL> target_transform = Affine ( <EOL> target_resolution , <NUM_LIT:0.0> , - <NUM_LIT> , <EOL> <NUM_LIT:0.0> , - target_resolution , <NUM_LIT> <EOL> ) <EOL> dst_transform , width , height = calculate_default_transform ( <EOL> src . crs , { '<STR_LIT>' : '<STR_LIT>' } , src . width , src . height , <EOL> * src . bounds , resolution = target_resolution <EOL> ) <EOL> assert dst_transform . almost_equals ( target_transform ) <EOL> assert width == <NUM_LIT> <EOL> assert height == <NUM_LIT:20> <EOL> def test_calculate_default_transform_multiple_resolutions ( ) : <EOL> with Env ( ) : <EOL> with rasterio . open ( '<STR_LIT>' ) as src : <EOL> target_resolution = ( <NUM_LIT> , <NUM_LIT:0.1> ) <EOL> target_transform = Affine ( <EOL> target_resolution [ <NUM_LIT:0> ] , <NUM_LIT:0.0> , - <NUM_LIT> , <EOL> <NUM_LIT:0.0> , - target_resolution [ <NUM_LIT:1> ] , <NUM_LIT> <EOL> ) <EOL> dst_transform , width , height = calculate_default_transform ( <EOL> src . crs , { '<STR_LIT>' : '<STR_LIT>' } , src . width , src . height , <EOL> * src . bounds , resolution = target_resolution <EOL> ) <EOL> assert dst_transform . almost_equals ( target_transform ) <EOL> assert width == <NUM_LIT:12> <EOL> assert height == <NUM_LIT:20> <EOL> def test_reproject_ndarray ( ) : <EOL> with Env ( ) : <EOL> with rasterio . open ( '<STR_LIT>' ) as src : <EOL> source = src . read ( <NUM_LIT:1> ) <EOL> dst_crs = dict ( <EOL> proj = '<STR_LIT>' , <EOL> a = <NUM_LIT> , <EOL> b = <NUM_LIT> , <EOL> lat_ts = <NUM_LIT:0.0> , <EOL> lon_0 = <NUM_LIT:0.0> , <EOL> x_0 = <NUM_LIT:0.0> , <EOL> y_0 = <NUM_LIT:0> , <EOL> k = <NUM_LIT:1.0> , <EOL> units = '<STR_LIT:m>' , <EOL> nadgrids = '<STR_LIT>' , <EOL> wktext = True , <EOL> no_defs = True ) <EOL> out = numpy . empty ( src . shape , dtype = numpy . uint8 ) <EOL> reproject ( <EOL> source , <EOL> out , <EOL> src_transform = src . transform , <EOL> src_crs = src . crs , <EOL> dst_transform = DST_TRANSFORM , <EOL> dst_crs = dst_crs , <EOL> resampling = Resampling . nearest ) <EOL> assert ( out > <NUM_LIT:0> ) . sum ( ) == <NUM_LIT> <EOL> def test_reproject_epsg ( ) : <EOL> with Env ( ) : <EOL> with rasterio . open ( '<STR_LIT>' ) as src : <EOL> source = src . read ( <NUM_LIT:1> ) <EOL> dst_crs = { '<STR_LIT>' : '<STR_LIT>' } <EOL> out = numpy . empty ( src . shape , dtype = numpy . uint8 ) <EOL> reproject ( <EOL> source , <EOL> out , <EOL> src_transform = src . transform , <EOL> src_crs = src . crs , <EOL> dst_transform = DST_TRANSFORM , <EOL> dst_crs = dst_crs , <EOL> resampling = Resampling . nearest ) <EOL> assert ( out > <NUM_LIT:0> ) . sum ( ) == <NUM_LIT> <EOL> def test_reproject_out_of_bounds ( ) : <EOL> with Env ( ) : <EOL> with rasterio . open ( '<STR_LIT>' ) as src : <EOL> source = src . read ( <NUM_LIT:1> ) <EOL> dst_crs = { '<STR_LIT>' : '<STR_LIT>' } <EOL> out = numpy . empty ( src . shape , dtype = numpy . uint8 ) <EOL> reproject ( <EOL> source , <EOL> out , <EOL> src_transform = src . transform , <EOL> src_crs = src . crs , <EOL> dst_transform = DST_TRANSFORM , <EOL> dst_crs = dst_crs , <EOL> resampling = Resampling . nearest ) <EOL> assert not out . any ( ) <EOL> def test_reproject_nodata ( ) : <EOL> params = default_reproject_params ( ) <EOL> nodata = <NUM_LIT> <EOL> with Env ( ) : <EOL> source = numpy . ones ( ( params . width , params . height ) , dtype = numpy . uint8 ) <EOL> out = numpy . zeros ( ( params . dst_width , params . dst_height ) , <EOL> dtype = source . dtype ) <EOL> out . fill ( <NUM_LIT> ) <EOL> reproject ( <EOL> source , <EOL> out , <EOL> src_transform = params . src_transform , <EOL> src_crs = params . src_crs , <EOL> src_nodata = nodata , <EOL> dst_transform = params . dst_transform , <EOL> dst_crs = params . dst_crs , <EOL> dst_nodata = nodata <EOL> ) <EOL> assert ( out == <NUM_LIT:1> ) . sum ( ) == <NUM_LIT> <EOL> assert ( out == nodata ) . sum ( ) == ( params . dst_width * <EOL> params . dst_height - <NUM_LIT> ) <EOL> def test_reproject_nodata_nan ( ) : <EOL> params = default_reproject_params ( ) <EOL> with Env ( ) : <EOL> source = numpy . ones ( ( params . width , params . height ) , dtype = numpy . float32 ) <EOL> out = numpy . zeros ( ( params . dst_width , params . dst_height ) , <EOL> dtype = source . dtype ) <EOL> out . fill ( <NUM_LIT> ) <EOL> reproject ( <EOL> source , <EOL> out , <EOL> src_transform = params . src_transform , <EOL> src_crs = params . src_crs , <EOL> src_nodata = numpy . nan , <EOL> dst_transform = params . dst_transform , <EOL> dst_crs = params . dst_crs , <EOL> dst_nodata = numpy . nan <EOL> ) <EOL> assert ( out == <NUM_LIT:1> ) . sum ( ) == <NUM_LIT> <EOL> assert numpy . isnan ( out ) . sum ( ) == ( params . dst_width * <EOL> params . dst_height - <NUM_LIT> ) <EOL> def test_reproject_dst_nodata_default ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> params = default_reproject_params ( ) <EOL> with Env ( ) : <EOL> source = numpy . ones ( ( params . width , params . height ) , dtype = numpy . uint8 ) <EOL> out = numpy . zeros ( ( params . dst_width , params . dst_height ) , <EOL> dtype = source . dtype ) <EOL> out . fill ( <NUM_LIT> ) <EOL> reproject ( <EOL> source , <EOL> out , <EOL> src_transform = params . src_transform , <EOL> src_crs = params . src_crs , <EOL> dst_transform = params . dst_transform , <EOL> dst_crs = params . dst_crs <EOL> ) <EOL> assert ( out == <NUM_LIT:1> ) . sum ( ) == <NUM_LIT> <EOL> assert ( out == <NUM_LIT:0> ) . sum ( ) == ( params . dst_width * <EOL> params . dst_height - <NUM_LIT> ) <EOL> def test_reproject_invalid_dst_nodata ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> params = default_reproject_params ( ) <EOL> with Env ( ) : <EOL> source = numpy . ones ( ( params . width , params . height ) , dtype = numpy . uint8 ) <EOL> out = source . copy ( ) <EOL> with pytest . raises ( ValueError ) : <EOL> reproject ( <EOL> source , <EOL> out , <EOL> src_transform = params . src_transform , <EOL> src_crs = params . src_crs , <EOL> src_nodata = <NUM_LIT:0> , <EOL> dst_transform = params . dst_transform , <EOL> dst_crs = params . dst_crs , <EOL> dst_nodata = <NUM_LIT> <EOL> ) <EOL> def test_reproject_missing_src_nodata ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> params = default_reproject_params ( ) <EOL> with Env ( ) : <EOL> source = numpy . ones ( ( params . width , params . height ) , dtype = numpy . uint8 ) <EOL> out = source . copy ( ) <EOL> with pytest . raises ( ValueError ) : <EOL> reproject ( <EOL> source , <EOL> out , <EOL> src_transform = params . src_transform , <EOL> src_crs = params . src_crs , <EOL> dst_transform = params . dst_transform , <EOL> dst_crs = params . dst_crs , <EOL> dst_nodata = <NUM_LIT> <EOL> ) <EOL> def test_reproject_invalid_src_nodata ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> params = default_reproject_params ( ) <EOL> with Env ( ) : <EOL> source = numpy . ones ( ( params . width , params . height ) , dtype = numpy . uint8 ) <EOL> out = source . copy ( ) <EOL> with pytest . raises ( ValueError ) : <EOL> reproject ( <EOL> source , <EOL> out , <EOL> src_transform = params . src_transform , <EOL> src_crs = params . src_crs , <EOL> src_nodata = <NUM_LIT> , <EOL> dst_transform = params . dst_transform , <EOL> dst_crs = params . dst_crs , <EOL> dst_nodata = <NUM_LIT> <EOL> ) <EOL> def test_reproject_multi ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with Env ( ) : <EOL> with rasterio . open ( '<STR_LIT>' ) as src : <EOL> source = src . read ( ) <EOL> dst_crs = dict ( <EOL> proj = '<STR_LIT>' , <EOL> a = <NUM_LIT> , <EOL> b = <NUM_LIT> , <EOL> lat_ts = <NUM_LIT:0.0> , <EOL> lon_0 = <NUM_LIT:0.0> , <EOL> x_0 = <NUM_LIT:0.0> , <EOL> y_0 = <NUM_LIT:0> , <EOL> k = <NUM_LIT:1.0> , <EOL> units = '<STR_LIT:m>' , <EOL> nadgrids = '<STR_LIT>' , <EOL> wktext = True , <EOL> no_defs = True ) <EOL> destin = numpy . empty ( source . shape , dtype = numpy . uint8 ) <EOL> reproject ( <EOL> source , <EOL> destin , <EOL> src_transform = src . transform , <EOL> src_crs = src . crs , <EOL> dst_transform = DST_TRANSFORM , <EOL> dst_crs = dst_crs , <EOL> resampling = Resampling . nearest ) <EOL> assert destin . any ( ) <EOL> def test_warp_from_file ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with rasterio . open ( '<STR_LIT>' ) as src : <EOL> dst_crs = dict ( <EOL> proj = '<STR_LIT>' , <EOL> a = <NUM_LIT> , <EOL> b = <NUM_LIT> , <EOL> lat_ts = <NUM_LIT:0.0> , <EOL> lon_0 = <NUM_LIT:0.0> , <EOL> x_0 = <NUM_LIT:0.0> , <EOL> y_0 = <NUM_LIT:0> , <EOL> k = <NUM_LIT:1.0> , <EOL> units = '<STR_LIT:m>' , <EOL> nadgrids = '<STR_LIT>' , <EOL> wktext = True , <EOL> no_defs = True ) <EOL> destin = numpy . empty ( src . shape , dtype = numpy . uint8 ) <EOL> reproject ( <EOL> rasterio . band ( src , <NUM_LIT:1> ) , <EOL> destin , <EOL> dst_transform = DST_TRANSFORM , <EOL> dst_crs = dst_crs ) <EOL> assert destin . any ( ) <EOL> def test_warp_from_to_file ( tmpdir ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> tiffname = str ( tmpdir . join ( '<STR_LIT>' ) ) <EOL> with rasterio . open ( '<STR_LIT>' ) as src : <EOL> dst_crs = dict ( <EOL> proj = '<STR_LIT>' , <EOL> a = <NUM_LIT> , <EOL> b = <NUM_LIT> , <EOL> lat_ts = <NUM_LIT:0.0> , <EOL> lon_0 = <NUM_LIT:0.0> , <EOL> x_0 = <NUM_LIT:0.0> , <EOL> y_0 = <NUM_LIT:0> , <EOL> k = <NUM_LIT:1.0> , <EOL> units = '<STR_LIT:m>' , <EOL> nadgrids = '<STR_LIT>' , <EOL> wktext = True , <EOL> no_defs = True ) <EOL> kwargs = src . meta . copy ( ) <EOL> kwargs . update ( <EOL> transform = DST_TRANSFORM , <EOL> crs = dst_crs ) <EOL> with rasterio . open ( tiffname , '<STR_LIT:w>' , ** kwargs ) as dst : <EOL> for i in ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) : <EOL> reproject ( rasterio . band ( src , i ) , rasterio . band ( dst , i ) ) <EOL> def test_warp_from_to_file_multi ( tmpdir ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> tiffname = str ( tmpdir . join ( '<STR_LIT>' ) ) <EOL> with rasterio . open ( '<STR_LIT>' ) as src : <EOL> dst_crs = dict ( <EOL> proj = '<STR_LIT>' , <EOL> a = <NUM_LIT> , <EOL> b = <NUM_LIT> , <EOL> lat_ts = <NUM_LIT:0.0> , <EOL> lon_0 = <NUM_LIT:0.0> , <EOL> x_0 = <NUM_LIT:0.0> , <EOL> y_0 = <NUM_LIT:0> , <EOL> k = <NUM_LIT:1.0> , <EOL> units = '<STR_LIT:m>' , <EOL> nadgrids = '<STR_LIT>' , <EOL> wktext = True , <EOL> no_defs = True ) <EOL> kwargs = src . meta . copy ( ) <EOL> kwargs . update ( <EOL> transform = DST_TRANSFORM , <EOL> crs = dst_crs ) <EOL> with rasterio . open ( tiffname , '<STR_LIT:w>' , ** kwargs ) as dst : <EOL> for i in ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) : <EOL> reproject ( <EOL> rasterio . band ( src , i ) , <EOL> rasterio . band ( dst , i ) , <EOL> num_threads = <NUM_LIT:2> ) <EOL> def test_transform_geom ( ) : <EOL> geom = { <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : ( <EOL> ( ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) , <EOL> ( <NUM_LIT> , <NUM_LIT> ) ) , ) } <EOL> result = transform_geom ( '<STR_LIT>' , '<STR_LIT>' , geom ) <EOL> assert result [ '<STR_LIT:type>' ] == '<STR_LIT>' <EOL> assert len ( result [ '<STR_LIT>' ] ) == <NUM_LIT:1> <EOL> result = transform_geom ( <EOL> '<STR_LIT>' , '<STR_LIT>' , geom , antimeridian_cutting = True ) <EOL> assert result [ '<STR_LIT:type>' ] == '<STR_LIT>' <EOL> assert len ( result [ '<STR_LIT>' ] ) == <NUM_LIT:2> <EOL> result = transform_geom ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> geom , <EOL> antimeridian_cutting = True , <EOL> antimeridian_offset = <NUM_LIT:0> ) <EOL> assert result [ '<STR_LIT:type>' ] == '<STR_LIT>' <EOL> assert len ( result [ '<STR_LIT>' ] ) == <NUM_LIT:2> <EOL> result = transform_geom ( '<STR_LIT>' , '<STR_LIT>' , geom , precision = <NUM_LIT:1> ) <EOL> assert int ( result [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] * <NUM_LIT:10> ) == - <NUM_LIT> <EOL> def test_reproject_unsupported_resampling ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with Env ( ) : <EOL> with rasterio . open ( '<STR_LIT>' ) as src : <EOL> source = src . read ( <NUM_LIT:1> ) <EOL> dst_crs = { '<STR_LIT>' : '<STR_LIT>' } <EOL> out = numpy . empty ( src . shape , dtype = numpy . uint8 ) <EOL> with pytest . raises ( ValueError ) : <EOL> reproject ( <EOL> source , <EOL> out , <EOL> src_transform = src . transform , <EOL> src_crs = src . crs , <EOL> dst_transform = DST_TRANSFORM , <EOL> dst_crs = dst_crs , <EOL> resampling = <NUM_LIT> ) <EOL> def test_reproject_unsupported_resampling_guass ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with Env ( ) : <EOL> with rasterio . open ( '<STR_LIT>' ) as src : <EOL> source = src . read ( <NUM_LIT:1> ) <EOL> dst_crs = { '<STR_LIT>' : '<STR_LIT>' } <EOL> out = numpy . empty ( src . shape , dtype = numpy . uint8 ) <EOL> with pytest . raises ( ValueError ) : <EOL> reproject ( <EOL>", "answer": "source ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . common import * <EOL> from flask_json import JsonError <EOL> class TestJsonError ( CommonTest ) : <EOL> def test_simple ( self ) : <EOL> @ self . app . route ( '<STR_LIT>' ) <EOL> def endpoint ( ) : <EOL> raise JsonError <EOL> r = self . client . get ( '<STR_LIT>' ) <EOL> assert_equals ( r . status_code , <NUM_LIT> ) <EOL> assert_dict_equal ( r . json , { '<STR_LIT:status>' : <NUM_LIT> } ) <EOL> self . app . config [ '<STR_LIT>' ] = False <EOL> r = self . client . get ( '<STR_LIT>' ) <EOL>", "answer": "assert_equals ( r . status_code , <NUM_LIT> )"}, {"prompt": "<s> import curses <EOL> import datetime <EOL> import threading <EOL> import re <EOL> import sys <EOL> import os <EOL> STRIP_COLORS = re . compile ( r'<STR_LIT>' ) <EOL> DEFAULT_TERM_COLUMNS = <NUM_LIT> <EOL> def supports_color ( out = sys . stdout ) : <EOL> return out . isatty ( ) or '<STR_LIT>' in os . environ <EOL> def color ( n , s , bold = True ) : <EOL> return '<STR_LIT>' . format ( n , '<STR_LIT:1>' if bold else '<STR_LIT>' , s ) <EOL> def green ( s ) : <EOL> return color ( <NUM_LIT:32> , s ) <EOL> def blue ( s ) : <EOL> return color ( <NUM_LIT> , s , bold = False ) <EOL> def red ( s ) : <EOL> return color ( <NUM_LIT> , s ) <EOL> def columns ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in os . environ : <EOL> return int ( os . environ [ '<STR_LIT>' ] ) <EOL> if not sys . stdout . isatty ( ) : <EOL> return DEFAULT_TERM_COLUMNS <EOL> try : <EOL> win = curses . initscr ( ) <EOL> _ , cols = win . getmaxyx ( ) <EOL> curses . endwin ( ) <EOL> return cols <EOL> except : <EOL> return DEFAULT_TERM_COLUMNS <EOL> def _default_printer ( s ) : <EOL> sys . stdout . write ( s ) <EOL> sys . stdout . write ( '<STR_LIT>' ) <EOL> sys . stdout . flush ( ) <EOL> def time_ago ( t , base = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not t : <EOL> return '<STR_LIT>' <EOL> delta = ( base or datetime . datetime . utcnow ( ) ) - t <EOL> duration = int ( delta . total_seconds ( ) ) <EOL> days , seconds = delta . days , delta . seconds <EOL> hours = seconds // <NUM_LIT> <EOL> minutes = ( seconds % <NUM_LIT> ) // <NUM_LIT> <EOL> seconds = ( seconds % <NUM_LIT> ) <EOL> if duration < <NUM_LIT:0> : <EOL> return '<STR_LIT>' <EOL> if duration < <NUM_LIT> : <EOL> return '<STR_LIT>' . format ( duration ) <EOL> if duration < <NUM_LIT> : <EOL> return '<STR_LIT>' . format ( minutes , seconds ) <EOL> if duration < <NUM_LIT> : <EOL> return '<STR_LIT>' . format ( hours , minutes ) <EOL> return '<STR_LIT>' . format ( days , hours , minutes ) <EOL> class OutputManager : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , lines , out = sys . stdout ) : <EOL> self . _lines = lines <EOL> self . _out = out <EOL> self . _formatters = { } <EOL> self . _lock = threading . Lock ( ) <EOL> def get_formatter ( self , pos , prefix = None ) : <EOL> f = OutputFormatter ( lambda s : self . _print ( s , pos ) , prefix = prefix ) <EOL> self . _formatters [ pos ] = f <EOL> return f <EOL> def start ( self ) : <EOL> if not supports_color ( self . _out ) : <EOL> return <EOL> self . _print ( '<STR_LIT>' . format ( '<STR_LIT:\\n>' * self . _lines , self . _lines ) ) <EOL> def end ( self ) : <EOL> if not supports_color ( self . _out ) : <EOL> return <EOL> self . _print ( '<STR_LIT>' . format ( self . _lines ) ) <EOL> def _print ( self , s , pos = None ) : <EOL> if not supports_color ( self . _out ) : <EOL> s = STRIP_COLORS . sub ( '<STR_LIT>' , s ) <EOL> self . _out . write ( s + '<STR_LIT:\\n>' ) <EOL> self . _out . flush ( ) <EOL> return <EOL> with self . _lock : <EOL> if pos : <EOL> self . _out . write ( '<STR_LIT>' . format ( pos ) ) <EOL> self . _out . write ( '<STR_LIT>' . format ( s ) ) <EOL> if pos : <EOL> self . _out . write ( '<STR_LIT>' . format ( pos ) ) <EOL> self . _out . flush ( ) <EOL>", "answer": "class OutputFormatter :"}, {"prompt": "<s> import uuid <EOL> class ReportNode ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , name , count = <NUM_LIT:0> , parent = None , children = [ ] , <EOL> link = None , ** kwargs ) : <EOL> self . name = name <EOL> self . count = count <EOL> self . parent = parent <EOL> self . children = [ ] <EOL> self . link = link <EOL> self . uid = \"<STR_LIT>\" . format ( uuid . uuid1 ( ) ) <EOL> def add_child ( self , child ) : <EOL> self . children . append ( child ) <EOL> child . parent = self <EOL> def add_to_count ( self , count ) : <EOL> self . count += count <EOL> def update_count ( self ) : <EOL> for node in self . ancestors : <EOL> node . add_to_count ( self . count ) <EOL> @ property <EOL> def ancestors ( self ) : <EOL> parent = self . parent <EOL> while parent : <EOL> yield parent <EOL> parent = parent . parent <EOL> def to_dict ( self ) : <EOL> return { <EOL> '<STR_LIT:name>' : self . name , <EOL>", "answer": "'<STR_LIT:count>' : self . count ,"}, {"prompt": "<s> import re <EOL> import socket <EOL> from opennode . cli . actions . utils import execute <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def list_bridges ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> bridges = [ x . strip ( ) for x in execute ( '<STR_LIT>' ) . splitlines ( ) ] <EOL> return None if len ( bridges ) == <NUM_LIT:0> else bridges <EOL> def add_bridge ( bridge ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> execute ( '<STR_LIT>' % bridge ) <EOL> def delete_bridge ( bridge ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> execute ( '<STR_LIT>' % bridge ) <EOL> def configure_bridge ( bridge , hello = None , fd = None , stp = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if hello is not None : <EOL> execute ( '<STR_LIT>' % ( bridge , hello ) ) <EOL> if fd is not None : <EOL> execute ( '<STR_LIT>' % ( bridge , fd ) ) <EOL> if stp is not None : <EOL> execute ( '<STR_LIT>' % ( bridge , stp ) ) <EOL> def add_bridge_interface ( bridge , interface ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> execute ( '<STR_LIT>' % ( bridge , interface ) ) <EOL> def remove_bridge_interface ( bridge , interface ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> execute ( '<STR_LIT>' % ( bridge , interface ) ) <EOL> def list_bridge_interface ( bridge ) : <EOL> execute ( \"<STR_LIT>\" ) <EOL> def list_nameservers ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with open ( '<STR_LIT>' , '<STR_LIT:r>' ) as dnsservers : <EOL> entries = dnsservers . readlines ( ) <EOL> dns = [ ] <EOL> for entry in entries : <EOL> if re . match ( \"<STR_LIT>\" , entry ) is not None : <EOL> dns . append ( entry . split ( ) [ <NUM_LIT:1> ] ) <EOL> return dns <EOL> def add_nameserver ( ns ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' ) as dnsservers : <EOL> entries = dnsservers . readlines ( ) <EOL> for entry in entries : <EOL> if re . match ( \"<STR_LIT>\" % ns , entry ) is not None : <EOL> return <EOL> entries . append ( '<STR_LIT>' % ns ) <EOL> dnsservers . seek ( <NUM_LIT:0> ) <EOL> dnsservers . writelines ( entries ) <EOL> def remove_nameserver ( ns ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> filtered_entries = [ ] <EOL> with open ( '<STR_LIT>' , '<STR_LIT:r>' ) as dnsservers : <EOL> entries = dnsservers . readlines ( ) <EOL> for entry in entries : <EOL> if re . match ( \"<STR_LIT>\" % ns , entry ) is not None : <EOL> continue <EOL>", "answer": "filtered_entries . append ( entry )"}, {"prompt": "<s> from sqlalchemy import Boolean , Column , DateTime , ForeignKey , Integer <EOL> from sqlalchemy import MetaData , String , Table <EOL> from nova import log as logging <EOL> meta = MetaData ( ) <EOL> instances = Table ( '<STR_LIT>' , meta , <EOL> Column ( '<STR_LIT:id>' , Integer ( ) , primary_key = True , nullable = False ) , <EOL> ) <EOL> quotas = Table ( '<STR_LIT>' , meta , <EOL> Column ( '<STR_LIT:id>' , Integer ( ) , primary_key = True , nullable = False ) , <EOL> ) <EOL> instance_metadata_table = Table ( '<STR_LIT>' , meta , <EOL> Column ( '<STR_LIT>' , DateTime ( timezone = False ) ) , <EOL> Column ( '<STR_LIT>' , DateTime ( timezone = False ) ) , <EOL> Column ( '<STR_LIT>' , DateTime ( timezone = False ) ) , <EOL> Column ( '<STR_LIT>' , Boolean ( create_constraint = True , name = None ) ) , <EOL> Column ( '<STR_LIT:id>' , Integer ( ) , primary_key = True , nullable = False ) , <EOL> Column ( '<STR_LIT>' , <EOL> Integer ( ) , <EOL> ForeignKey ( '<STR_LIT>' ) , <EOL> nullable = False ) , <EOL> Column ( '<STR_LIT:key>' , <EOL> String ( length = <NUM_LIT:255> , convert_unicode = False , assert_unicode = None , <EOL> unicode_error = None , _warn_on_bytestring = False ) ) , <EOL> Column ( '<STR_LIT:value>' , <EOL> String ( length = <NUM_LIT:255> , convert_unicode = False , assert_unicode = None , <EOL> unicode_error = None , _warn_on_bytestring = False ) ) ) <EOL> quota_metadata_items = Column ( '<STR_LIT>' , Integer ( ) ) <EOL> def upgrade ( migrate_engine ) : <EOL> meta . bind = migrate_engine <EOL> for table in ( instance_metadata_table , ) : <EOL> try : <EOL> table . create ( ) <EOL> except Exception : <EOL> logging . info ( repr ( table ) ) <EOL> logging . exception ( '<STR_LIT>' ) <EOL>", "answer": "raise"}, {"prompt": "<s> from django . contrib import admin <EOL> from models import Feed , Item <EOL>", "answer": "class FeedAdmin ( admin . ModelAdmin ) :"}, {"prompt": "<s> import calendar <EOL> import datetime <EOL> import re <EOL> from dateutil . relativedelta import relativedelta <EOL> from corehq . apps . reports . datatables import DataTablesHeader , DataTablesColumn <EOL> from corehq . apps . reports . generic import GenericTabularReport <EOL> from corehq . apps . reports . standard import DatespanMixin , CustomProjectReport <EOL> from corehq . apps . reports . util import format_datatables_data <EOL> from custom . up_nrhm . sql_data import ASHAFacilitatorsData <EOL> from django . utils . translation import ugettext as _ , ugettext_noop <EOL> class BlockLevelMonthReport ( GenericTabularReport , DatespanMixin , CustomProjectReport ) : <EOL> name = ugettext_noop ( \"<STR_LIT>\" ) <EOL> slug = \"<STR_LIT>\" <EOL> no_value = '<STR_LIT>' <EOL> is_bootstrap3 = True <EOL> @ property <EOL> def headers ( self ) : <EOL> date = self . report_config [ '<STR_LIT>' ] <EOL> first = ( ( date + relativedelta ( months = <NUM_LIT:3> ) ) . month , ( date + relativedelta ( months = <NUM_LIT:3> ) ) . year ) <EOL> second = ( ( date + relativedelta ( months = <NUM_LIT:2> ) ) . month , ( date + relativedelta ( months = <NUM_LIT:2> ) ) . year ) <EOL> third = ( ( date + relativedelta ( months = <NUM_LIT:1> ) ) . month , ( date + relativedelta ( months = <NUM_LIT:1> ) ) . year ) <EOL> return DataTablesHeader ( * [ <EOL> DataTablesColumn ( _ ( '<STR_LIT>' ) , sortable = False ) , <EOL> DataTablesColumn ( '<STR_LIT>' % ( calendar . month_name [ first [ <NUM_LIT:0> ] ] , first [ <NUM_LIT:1> ] ) , sortable = False ) , <EOL> DataTablesColumn ( '<STR_LIT>' % ( calendar . month_name [ second [ <NUM_LIT:0> ] ] , second [ <NUM_LIT:1> ] ) , sortable = False ) , <EOL> DataTablesColumn ( '<STR_LIT>' % ( calendar . month_name [ third [ <NUM_LIT:0> ] ] , third [ <NUM_LIT:1> ] ) , sortable = False ) , <EOL> DataTablesColumn ( _ ( '<STR_LIT>' ) , sortable = False ) ] ) <EOL> @ property <EOL> def report_config ( self ) : <EOL> startdate = datetime . datetime . utcnow ( ) <EOL> if not self . needs_filters : <EOL> year = int ( self . request . GET . get ( '<STR_LIT>' ) ) <EOL> month = int ( self . request . GET . get ( '<STR_LIT>' ) ) <EOL> startdate = datetime . datetime ( year , month , <NUM_LIT> ) - relativedelta ( months = <NUM_LIT:3> ) <EOL> return { <EOL> '<STR_LIT>' : self . domain , <EOL> '<STR_LIT>' : startdate . replace ( hour = <NUM_LIT:0> , minute = <NUM_LIT:0> , second = <NUM_LIT:0> ) , <EOL> '<STR_LIT>' : self . request . GET . get ( '<STR_LIT>' ) , <EOL> } <EOL> @ property <EOL> def model ( self ) : <EOL> return ASHAFacilitatorsData ( config = self . report_config ) <EOL> @ property <EOL> def rows ( self ) : <EOL> def format_val ( val ) : <EOL> return self . no_value if val is None else val <EOL> def avg ( values , idx = None ) : <EOL> sum = <NUM_LIT:0> <EOL> denom = <NUM_LIT:0> <EOL> for v in values : <EOL> if idx == <NUM_LIT:10> : <EOL> numbers = re . split ( '<STR_LIT>' , v [ '<STR_LIT:html>' ] ) <EOL> sum += int ( numbers [ <NUM_LIT:0> ] ) <EOL> if int ( numbers [ <NUM_LIT:1> ] ) > denom : <EOL> denom = int ( numbers [ <NUM_LIT:1> ] ) <EOL> else : <EOL> sum += v [ '<STR_LIT>' ] if v is not None else <NUM_LIT:0> <EOL> mean = ( float ( sum ) / float ( len ( values ) ) ) <EOL> if idx == <NUM_LIT:10> : <EOL> try : <EOL> percent = mean * <NUM_LIT:100> / denom <EOL> except ZeroDivisionError : <EOL> percent = <NUM_LIT:0> <EOL> html = \"<STR_LIT>\" . format ( int ( mean ) , int ( denom ) , int ( percent ) ) <EOL> return format_datatables_data ( html , percent ) <EOL> mean = \"<STR_LIT>\" % mean <EOL>", "answer": "return format_datatables_data ( mean , mean )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __all__ = [ \"<STR_LIT>\" ] <EOL> from sys import float_info <EOL> from traits . api import Range <EOL> from traits . api import Complex as TraitComplex <EOL> from traits . api import Float as TraitFloat <EOL> from openmdao . main . uncertain_distributions import UncertainDistribution <EOL> from openmdao . main . variable import Variable <EOL> from openmdao . units import PhysicalQuantity <EOL> class Float ( Variable ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , default_value = None , iotype = None , desc = None , <EOL> low = None , high = None , exclude_low = False , exclude_high = False , <EOL> units = None , ** metadata ) : <EOL> _default_set = False <EOL> if default_value is None : <EOL> if low is None and high is None : <EOL> default_value = <NUM_LIT:0.0> <EOL> elif low is None : <EOL> default_value = high <EOL> else : <EOL> default_value = low <EOL> else : <EOL> _default_set = True <EOL> if not isinstance ( default_value , float ) : <EOL> if isinstance ( default_value , int ) : <EOL> default_value = float ( default_value ) <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> self . exclude_low = exclude_low <EOL> self . exclude_high = exclude_high <EOL> if iotype is not None : <EOL> metadata [ '<STR_LIT>' ] = iotype <EOL> if desc is not None : <EOL> metadata [ '<STR_LIT>' ] = desc <EOL> if units is not None : <EOL> metadata [ '<STR_LIT>' ] = units <EOL> if low is None and high is None : <EOL> self . _validator = TraitFloat ( default_value , ** metadata ) <EOL> else : <EOL> if low is None : <EOL> low = - float_info . max <EOL> else : <EOL> low = float ( low ) <EOL> if high is None : <EOL> high = float_info . max <EOL> else : <EOL> high = float ( high ) <EOL> if low > high : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if default_value > high or default_value < low : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> % ( str ( low ) , str ( high ) ) ) <EOL> default_value = float ( default_value ) <EOL> self . _validator = Range ( low = low , high = high , value = default_value , <EOL> exclude_low = exclude_low , <EOL> exclude_high = exclude_high , <EOL> ** metadata ) <EOL> if '<STR_LIT>' in metadata : <EOL> try : <EOL> pq = PhysicalQuantity ( <NUM_LIT:0.> , metadata [ '<STR_LIT>' ] ) <EOL> except : <EOL> raise ValueError ( \"<STR_LIT>\" % <EOL> metadata [ '<STR_LIT>' ] ) <EOL> metadata [ '<STR_LIT>' ] = low <EOL> metadata [ '<STR_LIT>' ] = high <EOL> if '<STR_LIT>' in metadata : <EOL> del metadata [ '<STR_LIT>' ] <EOL> if not _default_set and metadata . get ( '<STR_LIT>' ) is True : <EOL> super ( Float , self ) . __init__ ( ** metadata ) <EOL> if not _default_set : <EOL> super ( Float , self ) . __init__ ( default_value = default_value , <EOL> assumed_default = True , ** metadata ) <EOL> else : <EOL> super ( Float , self ) . __init__ ( default_value = default_value , <EOL> assumed_default = False , ** metadata ) <EOL> def validate ( self , obj , name , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( value , UncertainDistribution ) : <EOL> value = value . getvalue ( ) <EOL> is_complex_step = False <EOL> if isinstance ( value , complex ) : <EOL> value_imag = value . imag <EOL> value = value . real <EOL>", "answer": "if value_imag != <NUM_LIT:0> :"}, {"prompt": "<s> import sys <EOL> from setuptools import setup <EOL> if sys . argv [ - <NUM_LIT:1> ] == '<STR_LIT>' : <EOL> print ( '<STR_LIT>' ) <EOL> print ( ) <EOL> sys . path . insert ( <NUM_LIT:0> , '<STR_LIT>' ) <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> url = '<STR_LIT>' , <EOL> keywords = '<STR_LIT>' , <EOL> packages = [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> license = '<STR_LIT>' , <EOL> entry_points = { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> } , <EOL> install_requires = [ '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] <EOL>", "answer": ") "}, {"prompt": "<s> assert_has_feature ( <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , '<STR_LIT>' , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : <NUM_LIT> } ) <EOL> assert_has_feature ( <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , '<STR_LIT>' , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : <NUM_LIT> } ) <EOL> assert_has_feature ( <EOL> <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , '<STR_LIT>' , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : <NUM_LIT> } ) <EOL>", "answer": "assert_has_feature ("}, {"prompt": "<s> from copy import deepcopy <EOL> from django import template <EOL>", "answer": "from classytags . exceptions import ArgumentRequiredError"}, {"prompt": "<s> import logging <EOL>", "answer": "from optparse import OptionParser"}, {"prompt": "<s> import time <EOL>", "answer": "def start ( ) :"}, {"prompt": "<s> import _10gen <EOL>", "answer": "import types"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = <NUM_LIT:8> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from caniusepython3 import command <EOL> from caniusepython3 . test import unittest , skip_pypi_timeouts <EOL> from distutils import dist <EOL> def make_command ( requires ) : <EOL> return command . Command ( dist . Distribution ( requires ) ) <EOL> class RequiresTests ( unittest . TestCase ) : <EOL> def verify_cmd ( self , requirements ) : <EOL> requires = { requirements : [ '<STR_LIT>' ] } <EOL> cmd = make_command ( requires ) <EOL> got = cmd . _dependencies ( ) <EOL> self . assertEqual ( frozenset ( got ) , frozenset ( [ '<STR_LIT>' ] ) ) <EOL> return cmd <EOL> def test_install_requires ( self ) : <EOL> self . verify_cmd ( '<STR_LIT>' ) <EOL> def test_tests_require ( self ) : <EOL> self . verify_cmd ( '<STR_LIT>' ) <EOL> def test_extras_require ( self ) : <EOL> cmd = make_command ( { '<STR_LIT>' : { '<STR_LIT>' : [ '<STR_LIT>' ] } } ) <EOL> got = frozenset ( cmd . _dependencies ( ) ) <EOL>", "answer": "self . assertEqual ( got , frozenset ( [ '<STR_LIT>' ] ) )"}, {"prompt": "<s> import re <EOL> from django . conf import settings <EOL> from django import template <EOL> from django . utils . html import conditional_escape <EOL> from django . utils . safestring import mark_safe <EOL> from django . utils . encoding import force_unicode <EOL> try : <EOL> import smartypants <EOL> except ImportError : <EOL> raise template . TemplateSyntaxError , \"<STR_LIT>\" <EOL> register = template . Library ( ) <EOL> def amp_filter ( text ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> text = force_unicode ( text ) <EOL> tag_pattern = '<STR_LIT>' <EOL> amp_finder = re . compile ( r\"<STR_LIT>\" ) <EOL> intra_tag_finder = re . compile ( r'<STR_LIT>' % ( tag_pattern , tag_pattern ) ) <EOL> def _amp_process ( groups ) : <EOL> prefix = groups . group ( '<STR_LIT>' ) or '<STR_LIT>' <EOL> text = amp_finder . sub ( r\"\"\"<STR_LIT>\"\"\" , groups . group ( '<STR_LIT:text>' ) ) <EOL> suffix = groups . group ( '<STR_LIT>' ) or '<STR_LIT>' <EOL> return prefix + text + suffix <EOL> output = intra_tag_finder . sub ( _amp_process , text ) <EOL> return mark_safe ( output ) <EOL> amp_filter . is_safe = True <EOL> def caps_filter ( text ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> text = force_unicode ( text ) <EOL> tokens = smartypants . _tokenize ( text ) <EOL> result = [ ] <EOL> in_skipped_tag = False <EOL> cap_finder = re . compile ( r\"\"\"<STR_LIT>\"\"\" , re . VERBOSE ) <EOL> def _cap_wrapper ( matchobj ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if matchobj . group ( <NUM_LIT:2> ) : <EOL> return \"\"\"<STR_LIT>\"\"\" % matchobj . group ( <NUM_LIT:2> ) <EOL> else : <EOL> if matchobj . group ( <NUM_LIT:3> ) [ - <NUM_LIT:1> ] == \"<STR_LIT:U+0020>\" : <EOL> caps = matchobj . group ( <NUM_LIT:3> ) [ : - <NUM_LIT:1> ] <EOL> tail = '<STR_LIT:U+0020>' <EOL> else : <EOL> caps = matchobj . group ( <NUM_LIT:3> ) <EOL> tail = '<STR_LIT>' <EOL> return \"\"\"<STR_LIT>\"\"\" % ( caps , tail ) <EOL> tags_to_skip_regex = re . compile ( \"<STR_LIT>\" , re . IGNORECASE ) <EOL> for token in tokens : <EOL> if token [ <NUM_LIT:0> ] == \"<STR_LIT>\" : <EOL> result . append ( token [ <NUM_LIT:1> ] ) <EOL> close_match = tags_to_skip_regex . match ( token [ <NUM_LIT:1> ] ) <EOL> if close_match and close_match . group ( <NUM_LIT:1> ) == None : <EOL> in_skipped_tag = True <EOL> else : <EOL> in_skipped_tag = False <EOL> else : <EOL> if in_skipped_tag : <EOL> result . append ( token [ <NUM_LIT:1> ] ) <EOL> else : <EOL> result . append ( cap_finder . sub ( _cap_wrapper , token [ <NUM_LIT:1> ] ) ) <EOL> output = \"<STR_LIT>\" . join ( result ) <EOL> return mark_safe ( output ) <EOL> caps_filter . is_safe = True <EOL> def number_suffix_filter ( text ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> tokens = smartypants . _tokenize ( text ) <EOL> result = [ ] <EOL> in_skipped_tag = False <EOL> suffix_finder = re . compile ( r'<STR_LIT>' ) <EOL> def _suffix_process ( groups ) : <EOL> number = groups . group ( '<STR_LIT>' ) <EOL> suffix = groups . group ( '<STR_LIT>' ) <EOL>", "answer": "return \"<STR_LIT>\" % ( number , suffix )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from io import open <EOL> import imp <EOL> import os <EOL> from penelope . prefix_default import get_prefix as get_prefix_default <EOL> from penelope . utilities import get_uuid <EOL> from penelope . utilities import print_error <EOL> __author__ = \"<STR_LIT>\" <EOL> __copyright__ = \"<STR_LIT>\" <EOL> __license__ = \"<STR_LIT>\" <EOL> __version__ = \"<STR_LIT>\" <EOL> __email__ = \"<STR_LIT>\" <EOL> __status__ = \"<STR_LIT>\" <EOL> def read_dictionary ( args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> metadata = DictionaryMetadata ( <EOL> identifier_string = args . identifier , <EOL> author_string = args . author , <EOL> email_string = args . email , <EOL> website_string = args . website , <EOL> title_string = args . title , <EOL> copyright_string = args . copyright , <EOL> license_string = args . license , <EOL> year_string = args . year , <EOL> language_from = args . language_from , <EOL> language_to = args . language_to , <EOL> description_string = args . description <EOL> ) <EOL> dictionary = Dictionary ( metadata = metadata ) <EOL> input_format = args . input_format <EOL> if input_format == \"<STR_LIT>\" : <EOL> import penelope . format_bookeen <EOL> return penelope . format_bookeen . read ( dictionary , args , args . input_file ) <EOL> elif input_format == \"<STR_LIT>\" : <EOL> input_file_paths = prepare_file_paths ( args . input_file , \"<STR_LIT>\" ) <EOL> if input_file_paths is None : <EOL> return None <EOL> import penelope . format_csv <EOL> return penelope . format_csv . read ( dictionary , args , input_file_paths ) <EOL> elif input_format == \"<STR_LIT>\" : <EOL> input_file_paths = prepare_file_paths ( args . input_file , \"<STR_LIT>\" ) <EOL> if input_file_paths is None : <EOL> return None <EOL> import penelope . format_kobo <EOL> return penelope . format_kobo . read ( dictionary , args , input_file_paths ) <EOL> elif input_format == \"<STR_LIT>\" : <EOL> input_file_paths = prepare_file_paths ( args . input_file , \"<STR_LIT>\" ) <EOL> if input_file_paths is None : <EOL> return None <EOL> import penelope . format_stardict <EOL> return penelope . format_stardict . read ( dictionary , args , input_file_paths ) <EOL> elif input_format == \"<STR_LIT>\" : <EOL> input_file_paths = prepare_file_paths ( args . input_file , \"<STR_LIT>\" ) <EOL> if input_file_paths is None : <EOL> return None <EOL> import penelope . format_xml <EOL> return penelope . format_xml . read ( dictionary , args , input_file_paths ) <EOL> return dictionary <EOL> def write_dictionary ( dictionary , args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> output_format = args . output_format <EOL> if output_format == \"<STR_LIT>\" : <EOL> import penelope . format_bookeen <EOL> return penelope . format_bookeen . write ( dictionary , args , args . output_file ) <EOL> elif output_format == \"<STR_LIT>\" : <EOL> output_file_path = add_extension ( args . output_file , \"<STR_LIT>\" ) <EOL> import penelope . format_csv <EOL> return penelope . format_csv . write ( dictionary , args , output_file_path ) <EOL> elif output_format == \"<STR_LIT>\" : <EOL> output_file_path = add_extension ( args . output_file , \"<STR_LIT>\" ) <EOL> import penelope . format_epub <EOL> return penelope . format_epub . write ( dictionary , args , output_file_path ) <EOL> elif output_format == \"<STR_LIT>\" : <EOL> output_file_path = get_kobo_file_path ( args ) <EOL> import penelope . format_kobo <EOL> return penelope . format_kobo . write ( dictionary , args , output_file_path ) <EOL> elif output_format == \"<STR_LIT>\" : <EOL> output_file_path = add_extension ( args . output_file , \"<STR_LIT>\" ) <EOL> import penelope . format_mobi <EOL> return penelope . format_mobi . write ( dictionary , args , output_file_path ) <EOL> elif output_format == \"<STR_LIT>\" : <EOL> output_file_path = add_extension ( args . output_file , \"<STR_LIT>\" ) <EOL> import penelope . format_stardict <EOL> return penelope . format_stardict . write ( dictionary , args , output_file_path ) <EOL> elif output_format == \"<STR_LIT>\" : <EOL> output_file_path = add_extension ( args . output_file , \"<STR_LIT>\" ) <EOL> import penelope . format_xml <EOL> return penelope . format_xml . write ( dictionary , args , output_file_path ) <EOL> return False <EOL> def get_kobo_file_path ( args ) : <EOL> if ( args . language_from == args . language_to ) and ( args . language_from == \"<STR_LIT>\" ) : <EOL> output_file_name = \"<STR_LIT>\" <EOL> else : <EOL> output_file_name = \"<STR_LIT>\" % ( args . language_from ) <EOL> if args . language_from != args . language_to : <EOL> output_file_name += \"<STR_LIT>\" % ( args . language_to ) <EOL> output_file_name += \"<STR_LIT>\" <EOL> output_file_path = os . path . split ( args . output_file ) [ <NUM_LIT:0> ] <EOL> output_file_path = os . path . join ( output_file_path , output_file_name ) <EOL> return output_file_path <EOL> def add_extension ( file_path , extension ) : <EOL> if not file_path . endswith ( extension ) : <EOL> file_path += extension <EOL> return file_path <EOL> def prepare_file_paths ( string , extension ) : <EOL> file_paths = [ ] <EOL> for prefix in string . split ( \"<STR_LIT:U+002C>\" ) : <EOL> file_path = add_extension ( prefix , extension ) <EOL> if not os . path . exists ( file_path ) : <EOL> print_error ( \"<STR_LIT>\" % file_path ) <EOL> return None <EOL> file_paths . append ( file_path ) <EOL> return file_paths <EOL> class DictionaryEntry ( object ) : <EOL> def __init__ ( <EOL> self , <EOL> headword , <EOL> definition <EOL> ) : <EOL> self . headword = headword <EOL> self . definition = definition <EOL> self . clear_synonyms ( ) <EOL> def clear_synonyms ( self ) : <EOL> self . synonyms = [ ] <EOL> def add_synonym ( self , synonym ) : <EOL> self . synonyms . append ( synonym ) <EOL> def get_synonyms ( self ) : <EOL> return self . synonyms <EOL> def __len__ ( self ) : <EOL> if self . headword is None : <EOL> return <NUM_LIT:0> <EOL> return len ( self . headword ) <EOL> def __str__ ( self ) : <EOL> return u\"\"\"<STR_LIT>\"\"\" % ( self . headword , self . definition ) <EOL> def prefix ( self , prefix_length ) : <EOL> if len ( self ) < prefix_length : <EOL> return self . headword <EOL> return self . headword [ <NUM_LIT:0> : prefix_length ] <EOL> class DictionaryMetadata ( object ) : <EOL> def __init__ ( <EOL> self , <EOL> identifier_string = None , <EOL> author_string = None , <EOL> email_string = None , <EOL> website_string = None , <EOL> title_string = None , <EOL> copyright_string = None , <EOL> license_string = None , <EOL> year_string = None , <EOL> language_from = None , <EOL> language_to = None , <EOL> description_string = None <EOL> ) : <EOL> self . identifier_string = identifier_string <EOL> self . author_string = author_string <EOL> self . email_string = email_string <EOL> self . website_string = website_string <EOL> self . title_string = title_string <EOL> self . copyright_string = copyright_string <EOL> self . license_string = license_string <EOL> self . year_string = year_string <EOL> self . language_from = language_from <EOL> self . language_to = language_to <EOL> self . description_string = description_string <EOL> if self . identifier_string is None : <EOL> self . identifier_string = get_uuid ( ) <EOL> def __str__ ( self ) : <EOL> return u\"\"\"<STR_LIT>\"\"\" % ( <EOL> self . identifier_string , <EOL> self . language_from , <EOL> self . language_to , <EOL> self . title_string , <EOL> self . author_string , <EOL> self . copyright_string , <EOL> self . license_string , <EOL> self . year_string , <EOL> self . email_string , <EOL> self . website_string , <EOL> self . description_string <EOL> ) <EOL> @ property <EOL> def is_monolingual ( self ) : <EOL> if self . language_from is None : <EOL> return False <EOL> return self . language_from == self . language_to <EOL> @ property <EOL>", "answer": "def is_bilingual ( self ) :"}, {"prompt": "<s> from circus . commands . base import Command <EOL> from circus . exc import ArgumentError <EOL> class RmWatcher ( Command ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = \"<STR_LIT>\" <EOL> properties = [ '<STR_LIT:name>' ] <EOL> options = Command . waiting_options + [ ( '<STR_LIT>' , '<STR_LIT>' , False , '<STR_LIT>' ) ] <EOL> def message ( self , * args , ** opts ) : <EOL> if len ( args ) < <NUM_LIT:1> or len ( args ) > <NUM_LIT:1> : <EOL> raise ArgumentError ( \"<STR_LIT>\" ) <EOL> return self . make_message ( name = args [ <NUM_LIT:0> ] ) <EOL>", "answer": "def execute ( self , arbiter , props ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from alembic import op <EOL> revision = '<STR_LIT>' <EOL>", "answer": "down_revision = '<STR_LIT>'"}, {"prompt": "<s> import httplib , urllib2 , time , calendar <EOL> from datetime import datetime <EOL> from decimal import Decimal <EOL> from xml . etree . ElementTree import fromstring <EOL> from xml . etree import ElementTree as ET <EOL> from base64 import b64encode <EOL> API_VERSION = '<STR_LIT>' <EOL> def utc_to_local ( dt ) : <EOL>", "answer": "'''<STR_LIT>'''"}, {"prompt": "<s> from django . test import TestCase <EOL> from cms . api import add_plugin , create_page <EOL> from djangocms_picture . cms_plugins import PicturePlugin <EOL> from . . templatetags . cms_pages import placeholder_content <EOL> class PlaceholderContentTest ( TestCase ) : <EOL> def test_placeholder_content_concatenates_plugin_bodies ( self ) : <EOL> page = create_page ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> blurb = page . placeholders . get ( slot = '<STR_LIT>' ) <EOL>", "answer": "main = page . placeholders . get ( slot = '<STR_LIT>' )"}, {"prompt": "<s> class InstanceGroup ( object ) : <EOL> def __init__ ( self , num_instances , role , type , market , name , bidprice = None ) : <EOL> self . num_instances = num_instances <EOL> self . role = role <EOL>", "answer": "self . type = type"}, {"prompt": "<s> from lib import actions <EOL> class GetTemperatureAction ( actions . BaseAction ) : <EOL> def run ( self , scale = '<STR_LIT:c>' , structure = None , device = None ) : <EOL>", "answer": "if structure and device :"}, {"prompt": "<s> import os <EOL> import unittest <EOL> from robotide . robotapi import _Import <EOL> from resources import FakeSettings <EOL> from robotide . context import IS_WINDOWS <EOL> from robotide . namespace . resourcefactory import ResourceFactory <EOL> class _ResourceFactory ( ResourceFactory ) : <EOL> from_path = None <EOL> def _load_resource ( self , path , report_status ) : <EOL> return object ( ) <EOL> def _get_python_path ( self , name ) : <EOL> if not self . from_path : <EOL> return None <EOL> return os . path . join ( self . from_path , name ) <EOL> def _remove ( self ) : <EOL> p = self . _excludes . _exclude_file_path <EOL> if p : <EOL> os . remove ( p ) <EOL> class ResourceFactoryDirectoryIgnoreTestCase ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . _import = _Import ( None , __file__ ) <EOL> self . _context = self . _mock_context ( ) <EOL> def tearDown ( self ) : <EOL> if self . r : <EOL> self . r . _remove ( ) <EOL> def test_resourcefactory_finds_imported_resource ( self ) : <EOL> self . r = _ResourceFactory ( FakeSettings ( ) ) <EOL> self . _is_resolved ( self . r ) <EOL> def test_resourcefactory_ignores_imported_resource_from_ignore_directory ( self ) : <EOL> self . r = self . _create_factory ( os . path . dirname ( __file__ ) ) <EOL> self . assertEqual ( None , self . r . get_resource_from_import ( self . _import , self . _context ) ) <EOL> def test_resourcefactory_ignores_imported_resource_from_ignore_subdirectory ( self ) : <EOL> self . r = self . _create_factory ( os . path . split ( os . path . dirname ( __file__ ) ) [ <NUM_LIT:0> ] ) <EOL> self . assertEqual ( None , self . r . get_resource_from_import ( self . _import , self . _context ) ) <EOL> def test_resourcefactory_finds_imported_resource_when_subdirectory_ignored ( self ) : <EOL> self . r = self . _create_factory ( os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT>' ) ) <EOL> self . _is_resolved ( self . r ) <EOL> def test_resourcefactory_finds_imported_resource_when_similar_ignore_name ( self ) : <EOL> self . r = self . _create_factory ( os . path . dirname ( __file__ ) ) <EOL> imp = _Import ( None , os . path . join ( os . path . dirname ( __file__ ) + '<STR_LIT:2>' , '<STR_LIT:foo>' ) ) <EOL> self . _is_resolved ( self . r , imp ) <EOL> def test_resourcefactory_ignores_imported_resource_when_relative_import ( self ) : <EOL> self . r = self . _create_factory ( os . path . abspath ( '<STR_LIT:.>' ) ) <EOL> imp = _Import ( None , os . path . join ( '<STR_LIT:.>' , '<STR_LIT:foo>' ) ) <EOL> self . assertEqual ( None , self . r . get_resource_from_import ( imp , self . _context ) ) <EOL> def test_resourcefactory_finds_imported_resource_from_python_path ( self ) : <EOL> self . r = _ResourceFactory ( FakeSettings ( ) ) <EOL>", "answer": "self . r . from_path = os . path . dirname ( __file__ )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from abc import ABCMeta , abstractmethod <EOL> from . config import get_mapping <EOL> def _with_metaclass ( meta , * bases ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class metaclass ( meta ) : <EOL> __call__ = type . __call__ <EOL> __init__ = type . __init__ <EOL> def __new__ ( cls , name , this_bases , d ) : <EOL> if this_bases is None : <EOL> return type . __new__ ( cls , name , ( ) , d ) <EOL> return meta ( name , bases , d ) <EOL> return metaclass ( '<STR_LIT>' , None , { } ) <EOL> class Storable ( _with_metaclass ( ABCMeta ) ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ORIG_VER_FIELD_NAME = \"<STR_LIT>\" <EOL> @ classmethod <EOL> @ abstractmethod <EOL> def get_table_name ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> @ abstractmethod <EOL> def get_id ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> @ abstractmethod <EOL> def set_id ( self , new_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> @ abstractmethod <EOL> def to_data ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> @ classmethod <EOL> @ abstractmethod <EOL> def from_data ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> @ classmethod <EOL> def index_names ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return None <EOL> def indexes ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return None <EOL> def _ensure_table ( cls ) : <EOL> get_mapping ( cls ) . ensure_table ( cls ) <EOL> def _post_load ( obj ) : <EOL> if obj : <EOL> setattr ( obj , Storable . ORIG_VER_FIELD_NAME , obj . to_data ( ) ) <EOL> return obj <EOL> def _find_one ( cls , id ) : <EOL> return _post_load ( get_mapping ( cls ) . find_one ( cls , id ) ) <EOL> def _find_all ( cls ) : <EOL> return [ <EOL> _post_load ( obj ) <EOL> for obj in get_mapping ( cls ) . find_all ( cls ) <EOL> ] <EOL> def _find_by_index ( cls , index_name , value ) : <EOL> return [ <EOL> _post_load ( obj ) <EOL> for obj in get_mapping ( cls ) . find_by_index ( cls , index_name , value ) <EOL> ] <EOL> def _save ( self ) : <EOL> get_mapping ( self . __class__ ) . save ( self ) <EOL> setattr ( self , Storable . ORIG_VER_FIELD_NAME , self . to_data ( ) ) <EOL> def DatabaseEnabled ( cls ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not issubclass ( cls , Storable ) : <EOL> raise ValueError ( <EOL> \"<STR_LIT>\" % repr ( cls ) <EOL> ) <EOL> cls . ensure_table = classmethod ( _ensure_table ) <EOL>", "answer": "cls . find_one = classmethod ( _find_one )"}, {"prompt": "<s> import netifaces <EOL> from oslo_log import log as logging <EOL> from neutron . _i18n import _LE <EOL> LOG = logging . getLogger ( __name__ ) <EOL> OPTS = [ ] <EOL> class IPWrapper ( object ) : <EOL> def get_device_by_ip ( self , ip ) : <EOL> if not ip : <EOL> return <EOL> for device in self . get_devices ( ) : <EOL> if device . device_has_ip ( ip ) : <EOL> return device <EOL> def get_devices ( self ) : <EOL> try : <EOL> return [ IPDevice ( iface ) for iface in netifaces . interfaces ( ) ] <EOL> except ( OSError , MemoryError ) : <EOL> LOG . error ( _LE ( \"<STR_LIT>\" ) ) <EOL> return [ ] <EOL> class IPDevice ( object ) : <EOL> def __init__ ( self , name ) : <EOL> self . device_name = name <EOL> def device_has_ip ( self , ip ) : <EOL> try : <EOL> device_addresses = netifaces . ifaddresses ( self . device_name ) <EOL> except ValueError : <EOL> return False <EOL> try : <EOL> addresses = [ ip_addr [ '<STR_LIT>' ] for ip_addr in <EOL> device_addresses . get ( netifaces . AF_INET , [ ] ) ] <EOL> return ip in addresses <EOL> except OSError : <EOL>", "answer": "LOG . error ( _LE ( \"<STR_LIT>\" ) ,"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from __future__ import absolute_import <EOL> from distutils . version import LooseVersion <EOL> import re <EOL> import logging <EOL> import salt . utils <EOL> from salt . exceptions import CommandExecutionError <EOL> log = logging . getLogger ( __name__ ) <EOL> __virtualname__ = '<STR_LIT>' <EOL> def __virtual__ ( ) : <EOL> '''<STR_LIT>''' <EOL> if salt . utils . is_darwin ( ) and LooseVersion ( __grains__ [ '<STR_LIT>' ] ) >= LooseVersion ( '<STR_LIT>' ) : <EOL> return True <EOL> return False , '<STR_LIT>' <EOL>", "answer": "def install ( app_id , enable = True ) :"}, {"prompt": "<s> import pickle <EOL> from cStringIO import StringIO <EOL> from test import test_support <EOL> from test . pickletester import AbstractPickleTests <EOL> from test . pickletester import AbstractPickleModuleTests <EOL> from test . pickletester import AbstractPersistentPicklerTests <EOL> from test . pickletester import AbstractPicklerUnpicklerObjectTests <EOL> class PickleTests ( AbstractPickleTests , AbstractPickleModuleTests ) : <EOL> def dumps ( self , arg , proto = <NUM_LIT:0> , fast = <NUM_LIT:0> ) : <EOL> return pickle . dumps ( arg , proto ) <EOL> def loads ( self , buf ) : <EOL> return pickle . loads ( buf ) <EOL> module = pickle <EOL> error = KeyError <EOL> class PicklerTests ( AbstractPickleTests ) : <EOL>", "answer": "error = KeyError"}, {"prompt": "<s> import pytest <EOL> import django_assets . env <EOL> @ pytest . fixture ( autouse = True ) <EOL>", "answer": "def set_django_assets_env ( ) :"}, {"prompt": "<s> import hashlib <EOL> import logging <EOL> import random <EOL> import re <EOL> import time <EOL> from datetime import datetime , timedelta <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import User , Group <EOL> from django . contrib . sites . models import Site <EOL> from django . db import models <EOL> from django . utils . translation import ugettext as _ , ugettext_lazy as _lazy <EOL> from celery . task import task <EOL> from statsd import statsd <EOL> from timezones . fields import TimeZoneField <EOL> from kitsune . lib . countries import COUNTRIES <EOL> from kitsune . search . es_utils import UnindexMeBro <EOL> from kitsune . search . models import ( <EOL> SearchMappingType , SearchMixin , register_for_indexing , <EOL> register_mapping_type ) <EOL> from kitsune . sumo import email_utils <EOL> from kitsune . sumo . models import ModelBase , LocaleField <EOL> from kitsune . sumo . urlresolvers import reverse <EOL> from kitsune . sumo . utils import auto_delete_files , chunked <EOL> from kitsune . users . validators import TwitterValidator <EOL> log = logging . getLogger ( '<STR_LIT>' ) <EOL> SHA1_RE = re . compile ( '<STR_LIT>' ) <EOL> CONTRIBUTOR_GROUP = '<STR_LIT>' <EOL> @ auto_delete_files <EOL> class Profile ( ModelBase , SearchMixin ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> user = models . OneToOneField ( User , primary_key = True , <EOL> verbose_name = _lazy ( u'<STR_LIT>' ) ) <EOL> name = models . CharField ( max_length = <NUM_LIT:255> , null = True , blank = True , <EOL> verbose_name = _lazy ( u'<STR_LIT>' ) ) <EOL> public_email = models . BooleanField ( <EOL> default = False , verbose_name = _lazy ( u'<STR_LIT>' ) ) <EOL> avatar = models . ImageField ( upload_to = settings . USER_AVATAR_PATH , null = True , <EOL> blank = True , verbose_name = _lazy ( u'<STR_LIT>' ) , <EOL> max_length = settings . MAX_FILEPATH_LENGTH ) <EOL> bio = models . TextField ( null = True , blank = True , <EOL> verbose_name = _lazy ( u'<STR_LIT>' ) ) <EOL> website = models . URLField ( max_length = <NUM_LIT:255> , null = True , blank = True , <EOL> verbose_name = _lazy ( u'<STR_LIT>' ) ) <EOL> twitter = models . CharField ( max_length = <NUM_LIT:15> , null = True , blank = True , validators = [ TwitterValidator ] , <EOL> verbose_name = _lazy ( u'<STR_LIT>' ) ) <EOL> facebook = models . URLField ( max_length = <NUM_LIT:255> , null = True , blank = True , <EOL> verbose_name = _lazy ( u'<STR_LIT>' ) ) <EOL> mozillians = models . CharField ( max_length = <NUM_LIT:255> , null = True , blank = True , <EOL> verbose_name = _lazy ( u'<STR_LIT>' ) ) <EOL> irc_handle = models . CharField ( max_length = <NUM_LIT:255> , null = True , blank = True , <EOL> verbose_name = _lazy ( u'<STR_LIT>' ) ) <EOL> timezone = TimeZoneField ( null = True , blank = True , <EOL> verbose_name = _lazy ( u'<STR_LIT>' ) ) <EOL> country = models . CharField ( max_length = <NUM_LIT:2> , choices = COUNTRIES , null = True , <EOL> blank = True , verbose_name = _lazy ( u'<STR_LIT>' ) ) <EOL> city = models . CharField ( max_length = <NUM_LIT:255> , null = True , blank = True , <EOL> verbose_name = _lazy ( u'<STR_LIT>' ) ) <EOL> locale = LocaleField ( default = settings . LANGUAGE_CODE , <EOL> verbose_name = _lazy ( u'<STR_LIT>' ) ) <EOL> first_answer_email_sent = models . BooleanField ( <EOL> default = False , help_text = _lazy ( u'<STR_LIT>' ) ) <EOL> first_l10n_email_sent = models . BooleanField ( <EOL> default = False , help_text = _lazy ( u'<STR_LIT>' ) ) <EOL> involved_from = models . DateField ( null = True , blank = True , <EOL> verbose_name = _lazy ( u'<STR_LIT>' ) ) <EOL> csat_email_sent = models . DateField ( null = True , blank = True , <EOL> verbose_name = _lazy ( u'<STR_LIT>' <EOL> u'<STR_LIT>' ) ) <EOL> class Meta ( object ) : <EOL> permissions = ( ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , ) <EOL> def __unicode__ ( self ) : <EOL> try : <EOL> return unicode ( self . user ) <EOL> except Exception as exc : <EOL> return unicode ( '<STR_LIT>' % ( self . pk , exc ) ) <EOL> def get_absolute_url ( self ) : <EOL> return reverse ( '<STR_LIT>' , args = [ self . user_id ] ) <EOL> def clear ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . name = '<STR_LIT>' <EOL> self . public_email = False <EOL> self . avatar = None <EOL> self . bio = '<STR_LIT>' <EOL> self . website = '<STR_LIT>' <EOL> self . twitter = '<STR_LIT>' <EOL> self . facebook = '<STR_LIT>' <EOL> self . mozillians = '<STR_LIT>' <EOL> self . irc_handle = '<STR_LIT>' <EOL> self . city = '<STR_LIT>' <EOL> @ property <EOL> def display_name ( self ) : <EOL> return self . name if self . name else self . user . username <EOL> @ property <EOL> def twitter_usernames ( self ) : <EOL> from kitsune . customercare . models import Reply <EOL> return list ( <EOL> Reply . objects . filter ( user = self . user ) <EOL> . values_list ( '<STR_LIT>' , flat = True ) <EOL> . distinct ( ) ) <EOL> @ classmethod <EOL> def get_mapping_type ( cls ) : <EOL> return UserMappingType <EOL> @ classmethod <EOL> def get_serializer ( cls , serializer_type = '<STR_LIT>' ) : <EOL> from kitsune . users import api <EOL> if serializer_type == '<STR_LIT>' : <EOL> return api . ProfileSerializer <EOL> elif serializer_type == '<STR_LIT>' : <EOL> return api . ProfileFKSerializer <EOL> else : <EOL> raise ValueError ( '<STR_LIT>' . format ( serializer_type ) ) <EOL> @ property <EOL> def last_contribution_date ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from kitsune . customercare . models import Reply <EOL> from kitsune . questions . models import Answer <EOL> from kitsune . wiki . models import Revision <EOL> dates = [ ] <EOL> try : <EOL> aoa_reply = Reply . objects . filter ( <EOL> user = self . user ) . latest ( '<STR_LIT>' ) <EOL> dates . append ( aoa_reply . created ) <EOL> except Reply . DoesNotExist : <EOL> pass <EOL> try : <EOL> answer = Answer . objects . filter ( <EOL> creator = self . user ) . latest ( '<STR_LIT>' ) <EOL> dates . append ( answer . created ) <EOL> except Answer . DoesNotExist : <EOL> pass <EOL> try : <EOL> revision = Revision . objects . filter ( <EOL> creator = self . user ) . latest ( '<STR_LIT>' ) <EOL> dates . append ( revision . created ) <EOL> except Revision . DoesNotExist : <EOL> pass <EOL> try : <EOL> revision = Revision . objects . filter ( <EOL> reviewer = self . user ) . latest ( '<STR_LIT>' ) <EOL> dates . append ( revision . reviewed or revision . created ) <EOL> except Revision . DoesNotExist : <EOL> pass <EOL> if len ( dates ) == <NUM_LIT:0> : <EOL> return None <EOL> return max ( dates ) <EOL> @ property <EOL> def settings ( self ) : <EOL> return self . user . settings <EOL> @ property <EOL> def answer_helpfulness ( self ) : <EOL> from kitsune . questions . models import AnswerVote <EOL> return AnswerVote . objects . filter ( answer__creator = self . user , helpful = True ) . count ( ) <EOL> @ register_mapping_type <EOL> class UserMappingType ( SearchMappingType ) : <EOL> list_keys = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> @ classmethod <EOL> def get_model ( cls ) : <EOL> return Profile <EOL> @ classmethod <EOL> def get_index_group ( cls ) : <EOL> return '<STR_LIT>' <EOL> @ classmethod <EOL> def get_mapping ( cls ) : <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:id>' : { '<STR_LIT:type>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:type>' : '<STR_LIT:string>' , '<STR_LIT:index>' : '<STR_LIT>' } , <EOL> '<STR_LIT:url>' : { '<STR_LIT:type>' : '<STR_LIT:string>' , '<STR_LIT:index>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:type>' : '<STR_LIT>' } , <EOL> '<STR_LIT:username>' : { '<STR_LIT:type>' : '<STR_LIT:string>' , '<STR_LIT:index>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:type>' : '<STR_LIT:string>' , '<STR_LIT:index>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:type>' : '<STR_LIT:string>' , <EOL> '<STR_LIT:index>' : '<STR_LIT>' <EOL> } , <EOL> '<STR_LIT>' : { '<STR_LIT:type>' : '<STR_LIT:date>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:type>' : '<STR_LIT:string>' , '<STR_LIT:index>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:type>' : '<STR_LIT:string>' , '<STR_LIT>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:type>' : '<STR_LIT:string>' , <EOL> '<STR_LIT:index>' : '<STR_LIT>' <EOL> } , <EOL> '<STR_LIT>' : { '<STR_LIT:type>' : '<STR_LIT:string>' , '<STR_LIT:index>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : True , <EOL> } <EOL> } <EOL> } <EOL> @ classmethod <EOL> def extract_document ( cls , obj_id , obj = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if obj is None : <EOL> model = cls . get_model ( ) <EOL> obj = model . objects . select_related ( '<STR_LIT:user>' ) . get ( pk = obj_id ) <EOL> if not obj . user . is_active : <EOL> raise UnindexMeBro ( ) <EOL> d = { } <EOL>", "answer": "d [ '<STR_LIT:id>' ] = obj . pk"}, {"prompt": "<s> import angr <EOL> import logging <EOL> import os <EOL>", "answer": "l = logging . getLogger ( \"<STR_LIT>\" )"}, {"prompt": "<s> from sellmo . core . loading import load <EOL> from django . db import models <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> import sellmo . apps . product as _product <EOL> import sellmo . contrib . product . subtypes . configurable_product as _configurable_product <EOL> @ load ( after = '<STR_LIT>' ) <EOL> @ load ( action = '<STR_LIT>' ) <EOL> def finalize_model ( ) : <EOL> class ConfigurableProduct ( <EOL> _configurable_product . models . ConfigurableProduct , <EOL> _product . models . Product <EOL> ) : <EOL> objects = _product . models . ProductManager . from_queryset ( <EOL> _product . models . ProductQuerySet ) ( ) <EOL> class Meta ( <EOL> _configurable_product . models . ConfigurableProduct . Meta , <EOL> _product . models . Product . Meta <EOL> ) : <EOL> app_label = '<STR_LIT>' <EOL> _configurable_product . models . ConfigurableProduct = ConfigurableProduct <EOL> class ConfigurableProduct ( models . Model ) : <EOL> is_configurable = True <EOL> def get_options_tree ( self , variations = None ) : <EOL> if variations is None : <EOL> variations = self . get_variations ( ) <EOL> if variations is None or variations . count ( ) == <NUM_LIT:0> : <EOL> return <EOL> variations = variations . prefetch_related ( '<STR_LIT>' ) <EOL>", "answer": "attributes = variations . get_variating_attributes ( )"}, {"prompt": "<s> SCREEN_SIZE = ( <NUM_LIT> , <NUM_LIT> ) <EOL> from math import radians <EOL> from OpenGL . GL import * <EOL> from OpenGL . GLU import * <EOL> import pygame <EOL> from pygame . locals import * <EOL> def resize ( width , height ) : <EOL> glViewport ( <NUM_LIT:0> , <NUM_LIT:0> , width , height ) <EOL> glMatrixMode ( GL_PROJECTION ) <EOL> glLoadIdentity ( ) <EOL> gluPerspective ( <NUM_LIT> , float ( width ) / height , <NUM_LIT> , <NUM_LIT> ) <EOL> glMatrixMode ( GL_MODELVIEW ) <EOL> glLoadIdentity ( ) <EOL> def init ( ) : <EOL> glEnable ( GL_TEXTURE_2D ) <EOL> glClearColor ( <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:0.0> ) <EOL> def run ( ) : <EOL> pygame . init ( ) <EOL> screen = pygame . display . set_mode ( SCREEN_SIZE , HWSURFACE | OPENGL | DOUBLEBUF ) <EOL> resize ( * SCREEN_SIZE ) <EOL> init ( ) <EOL> texture_surface = pygame . image . load ( \"<STR_LIT>\" ) <EOL> texture_data = pygame . image . tostring ( texture_surface , '<STR_LIT>' , True ) <EOL> texture_id = glGenTextures ( <NUM_LIT:1> ) <EOL> glBindTexture ( GL_TEXTURE_2D , texture_id ) <EOL> glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_LINEAR ) <EOL> glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_LINEAR ) <EOL> glPixelStorei ( GL_UNPACK_ALIGNMENT , <NUM_LIT:1> ) <EOL> width , height = texture_surface . get_rect ( ) . size <EOL> glTexImage2D ( GL_TEXTURE_2D , <EOL>", "answer": "<NUM_LIT:0> ,"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from future . utils import PY3 <EOL> if PY3 : <EOL> from _dummy_thread import * <EOL> else : <EOL>", "answer": "__future_module__ = True"}, {"prompt": "<s> from logging import getLogger <EOL> from os import environ <EOL> from flask import Flask , send_from_directory <EOL> from sqlalchemy import event <EOL> from sqlalchemy . engine import Engine <EOL>", "answer": "from utils . flaskutils import install_request_logger"}, {"prompt": "<s> from coapthon import defines <EOL> from coapthon . messages . message import Message <EOL> from coapthon . messages . option import Option <EOL> class Request ( Message ) : <EOL> def __init__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( Request , self ) . __init__ ( ) <EOL> @ property <EOL> def uri_path ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> value = [ ] <EOL> for option in self . options : <EOL> if option . number == defines . OptionRegistry . URI_PATH . number : <EOL> value . append ( str ( option . value ) + '<STR_LIT:/>' ) <EOL> value = \"<STR_LIT>\" . join ( value ) <EOL> value = value [ : - <NUM_LIT:1> ] <EOL> return value <EOL> @ uri_path . setter <EOL> def uri_path ( self , path ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = path . strip ( \"<STR_LIT:/>\" ) <EOL> tmp = path . split ( \"<STR_LIT:?>\" ) <EOL> path = tmp [ <NUM_LIT:0> ] <EOL> paths = path . split ( \"<STR_LIT:/>\" ) <EOL> for p in paths : <EOL> option = Option ( ) <EOL> option . number = defines . OptionRegistry . URI_PATH . number <EOL> option . value = p <EOL> self . add_option ( option ) <EOL> if len ( tmp ) > <NUM_LIT:1> : <EOL> query = tmp [ <NUM_LIT:1> ] <EOL> self . uri_query = query <EOL> @ uri_path . deleter <EOL> def uri_path ( self ) : <EOL> self . del_option_by_number ( defines . OptionRegistry . URI_PATH . number ) <EOL> @ property <EOL> def uri_query ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> value = [ ] <EOL> for option in self . options : <EOL> if option . number == defines . OptionRegistry . URI_QUERY . number : <EOL> value . append ( str ( option . value ) ) <EOL> return \"<STR_LIT:&>\" . join ( value ) <EOL> @ uri_query . setter <EOL> def uri_query ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> del self . uri_query <EOL> queries = value . split ( \"<STR_LIT:&>\" ) <EOL> for q in queries : <EOL> option = Option ( ) <EOL> option . number = defines . OptionRegistry . URI_QUERY . number <EOL> option . value = str ( q ) <EOL> self . add_option ( option ) <EOL> @ uri_query . deleter <EOL> def uri_query ( self ) : <EOL> self . del_option_by_number ( defines . OptionRegistry . URI_QUERY . number ) <EOL> @ property <EOL> def accept ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for option in self . options : <EOL> if option . number == defines . OptionRegistry . ACCEPT . number : <EOL> return option . value <EOL> return None <EOL> @ accept . setter <EOL> def accept ( self , value ) : <EOL> if value in defines . Content_types . values ( ) : <EOL> option = Option ( ) <EOL> option . number = defines . OptionRegistry . ACCEPT . number <EOL> option . value = value <EOL> self . add_option ( option ) <EOL> @ accept . deleter <EOL> def accept ( self ) : <EOL> self . del_option_by_number ( defines . OptionRegistry . ACCEPT . number ) <EOL> @ property <EOL> def if_match ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> value = [ ] <EOL> for option in self . options : <EOL> if option . number == defines . OptionRegistry . IF_MATCH . number : <EOL> value . append ( option . value ) <EOL> return value <EOL> @ if_match . setter <EOL> def if_match ( self , values ) : <EOL> assert isinstance ( values , list ) <EOL> for v in values : <EOL> option = Option ( ) <EOL> option . number = defines . OptionRegistry . IF_MATCH . number <EOL> option . value = v <EOL> self . add_option ( option ) <EOL> @ if_match . deleter <EOL> def if_match ( self ) : <EOL> self . del_option_by_number ( defines . OptionRegistry . IF_MATCH . number ) <EOL> @ property <EOL> def if_none_match ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for option in self . options : <EOL> if option . number == defines . OptionRegistry . IF_NONE_MATCH . number : <EOL> return True <EOL> return False <EOL> def add_if_none_match ( self ) : <EOL> option = Option ( ) <EOL> option . number = defines . OptionRegistry . IF_NONE_MATCH . number <EOL>", "answer": "option . value = None"}, {"prompt": "<s> from . . _error import ( <EOL>", "answer": "_validate_not_none ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> import hashlib <EOL> import time <EOL> import json <EOL> import os <EOL> from . import cmdline <EOL> import requests <EOL> def get_token ( network ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> tm_value = int ( time . time ( ) ) <EOL> token = hashlib . sha256 ( '<STR_LIT>' . format ( network [ '<STR_LIT>' ] , tm_value ) ) <EOL> return '<STR_LIT>' . format ( network [ '<STR_LIT>' ] , <EOL> token . hexdigest ( ) , <EOL> tm_value ) <EOL> def prepare_message ( msg , network , parent ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from x84 . bbs . msgbase import format_origin_line , to_utctime <EOL> return { <EOL> '<STR_LIT>' : msg . author , <EOL> '<STR_LIT>' : msg . subject , <EOL> '<STR_LIT>' : msg . recipient , <EOL> '<STR_LIT>' : parent , <EOL> '<STR_LIT>' : [ tag for tag in msg . tags if tag != network [ '<STR_LIT:name>' ] ] , <EOL> '<STR_LIT:body>' : u'<STR_LIT>' . join ( ( msg . body , format_origin_line ( ) ) ) , <EOL> '<STR_LIT>' : to_utctime ( msg . ctime ) <EOL> } <EOL> def pull_rest ( net , last_msg_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url = '<STR_LIT>' % ( net [ '<STR_LIT>' ] , net [ '<STR_LIT:name>' ] , last_msg_id ) <EOL> log = logging . getLogger ( __name__ ) <EOL> try : <EOL> req = requests . get ( url , <EOL> headers = { '<STR_LIT>' : get_token ( net ) } , <EOL> verify = net [ '<STR_LIT>' ] ) <EOL> except requests . ConnectionError as err : <EOL> log . warn ( '<STR_LIT>' <EOL> . format ( net = net , err = err ) ) <EOL> return False <EOL> except Exception as err : <EOL> log . exception ( '<STR_LIT>' <EOL> . format ( net = net , err = err ) ) <EOL> return False <EOL> if req . status_code != <NUM_LIT:200> : <EOL> log . error ( '<STR_LIT>' <EOL> . format ( net = net , req = req ) ) <EOL> return False <EOL> try : <EOL> response = json . loads ( req . text ) <EOL> return response [ '<STR_LIT>' ] if response [ '<STR_LIT>' ] else [ ] <EOL> except Exception as err : <EOL> log . exception ( '<STR_LIT>' <EOL> . format ( net = net , err = err ) ) <EOL> return False <EOL> def push_rest ( net , msg , parent ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> msg_data = prepare_message ( msg , net , parent ) <EOL> url = '<STR_LIT>' . format ( net = net ) <EOL> data = { '<STR_LIT:message>' : json . dumps ( msg_data ) } <EOL> log = logging . getLogger ( __name__ ) <EOL> try : <EOL> req = requests . put ( url , <EOL> headers = { '<STR_LIT>' : get_token ( net ) } , <EOL> data = data , <EOL> verify = net [ '<STR_LIT>' ] ) <EOL> except Exception as err : <EOL> log . exception ( '<STR_LIT>' <EOL> . format ( net = net , err = err ) ) <EOL> return False <EOL> if req . status_code not in ( <NUM_LIT:200> , <NUM_LIT> ) : <EOL> log . error ( '<STR_LIT>' <EOL> . format ( net = net , req = req ) ) <EOL> return False <EOL> try : <EOL> response = json . loads ( req . text ) <EOL> except Exception as err : <EOL> log . exception ( '<STR_LIT>' <EOL> . format ( net = net , err = err ) ) <EOL>", "answer": "else :"}, {"prompt": "<s> import charcoal <EOL> from charcoal import Charcoal <EOL> import yaml <EOL> import os <EOL> import logging <EOL> import json <EOL> import socket <EOL> from nose . tools import raises <EOL> import requests <EOL> import httpretty <EOL> THIS_DIR = os . path . dirname ( os . path . realpath ( __file__ ) ) <EOL> LOG = logging . getLogger ( '<STR_LIT>' ) <EOL> LOG . setLevel ( logging . DEBUG ) <EOL> def test_github_status ( ) : <EOL> total_failed_tests = <NUM_LIT:0> <EOL> total_passed_tests = <NUM_LIT:0> <EOL> myfile = open ( THIS_DIR + '<STR_LIT>' ) <EOL> test_json = yaml . load ( myfile ) <EOL> for test in test_json [ '<STR_LIT>' ] : <EOL> test_obj = Charcoal ( test = test , host = '<STR_LIT>' ) <EOL>", "answer": "total_failed_tests += test_obj . failed"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from django . core . urlresolvers import reverse <EOL> from sentry . testutils import APITestCase <EOL> class ProjectMemberIndexTest ( APITestCase ) : <EOL> def test_simple ( self ) : <EOL> user_1 = self . create_user ( '<STR_LIT>' , username = '<STR_LIT:foo>' ) <EOL> user_2 = self . create_user ( '<STR_LIT>' , username = '<STR_LIT:bar>' ) <EOL> user_3 = self . create_user ( '<STR_LIT>' , username = '<STR_LIT>' ) <EOL> org = self . create_organization ( owner = user_1 ) <EOL> team = self . create_team ( organization = org , slug = '<STR_LIT>' ) <EOL> project_1 = self . create_project ( team = team , slug = '<STR_LIT:foo>' ) <EOL> self . create_project ( team = team , slug = '<STR_LIT:bar>' ) <EOL> self . create_member ( organization = org , user = user_2 , teams = [ project_1 . team ] ) <EOL> self . create_member ( organization = org , user = user_3 , teams = [ project_1 . team ] ) <EOL> self . login_as ( user = user_2 ) <EOL> url = reverse ( '<STR_LIT>' , kwargs = { <EOL> '<STR_LIT>' : project_1 . organization . slug , <EOL> '<STR_LIT>' : project_1 . slug , <EOL> } ) <EOL>", "answer": "response = self . client . get ( url )"}, {"prompt": "<s> try : <EOL> import unittest2 as unittest <EOL> except ImportError : <EOL> import unittest <EOL> import keypress_mock as kp <EOL> from colorama import Fore , Style <EOL> from term2048 . board import Board <EOL> from term2048 . game import Game <EOL> import sys <EOL> import os <EOL> from os import remove <EOL> from tempfile import NamedTemporaryFile <EOL> from uuid import uuid4 <EOL> from helpers import DevNull <EOL> _BSIZE = Board . SIZE <EOL> class TestGame ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> Board . SIZE = _BSIZE <EOL> Game . SCORES_FILE = None <EOL> self . g = Game ( scores_file = None , store_file = None ) <EOL> self . b = self . g . board <EOL> self . stdout = sys . stdout <EOL>", "answer": "sys . stdout = DevNull ( )"}, {"prompt": "<s> import numpy as np <EOL> def generate_anchors ( base_size = <NUM_LIT:16> , ratios = [ <NUM_LIT:0.5> , <NUM_LIT:1> , <NUM_LIT:2> ] , <EOL> scales = <NUM_LIT:2> ** np . arange ( <NUM_LIT:3> , <NUM_LIT:6> ) ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> base_anchor = np . array ( [ <NUM_LIT:1> , <NUM_LIT:1> , base_size , base_size ] ) - <NUM_LIT:1> <EOL> ratio_anchors = _ratio_enum ( base_anchor , ratios ) <EOL> anchors = np . vstack ( [ _scale_enum ( ratio_anchors [ i , : ] , scales ) <EOL> for i in xrange ( ratio_anchors . shape [ <NUM_LIT:0> ] ) ] ) <EOL> return anchors <EOL> def _whctrs ( anchor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> w = anchor [ <NUM_LIT:2> ] - anchor [ <NUM_LIT:0> ] + <NUM_LIT:1> <EOL>", "answer": "h = anchor [ <NUM_LIT:3> ] - anchor [ <NUM_LIT:1> ] + <NUM_LIT:1>"}, {"prompt": "<s> import unittest <EOL> from test . asserting . config_source import ConfigSourceAssertion <EOL> from vint . linting . config . config_cmdargs_source import ConfigCmdargsSource <EOL> from vint . linting . level import Level <EOL> class TestConfigFileSource ( ConfigSourceAssertion , unittest . TestCase ) : <EOL> def test_get_config_dict ( self ) : <EOL> env = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : <NUM_LIT:10> , <EOL> } , <EOL> } <EOL> expected_config_dict = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : Level . WARNING , <EOL>", "answer": "'<STR_LIT>' : <NUM_LIT:10> ,"}, {"prompt": "<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> import os <EOL> from pants . base . build_environment import get_buildroot , pants_version <EOL> from pants . build_graph . build_file_aliases import BuildFileAliases <EOL> from pants . build_graph . from_target import FromTarget <EOL>", "answer": "from pants . build_graph . intransitive_dependency import ( IntransitiveDependencyFactory ,"}, {"prompt": "<s> import sys <EOL> def empty_float ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> x = float ( ) <EOL> return x <EOL> def float_conjugate ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if sys . version_info >= ( <NUM_LIT:2> , <NUM_LIT:6> ) : <EOL> x = <NUM_LIT> . conjugate ( ) <EOL> else : <EOL> x = <NUM_LIT> <EOL> return x <EOL> def float_call_conjugate ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if sys . version_info >= ( <NUM_LIT:2> , <NUM_LIT:6> ) : <EOL> x = float ( <NUM_LIT> ) . conjugate ( ) <EOL> else : <EOL> x = <NUM_LIT> <EOL>", "answer": "return x "}, {"prompt": "<s> from django_bitcoin . models import bitcoinprice_eur , bitcoinprice_usd <EOL> def bitcoinprice ( request ) : <EOL> return { '<STR_LIT>' : bitcoinprice_eur ( ) , <EOL>", "answer": "'<STR_LIT>' : bitcoinprice_usd ( ) ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from kameleon_mcmc . distribution . Gaussian import Gaussian <EOL> from kameleon_mcmc . experiments . SingleChainExperiment import SingleChainExperiment <EOL> from kameleon_mcmc . gp . GPData import GPData <EOL> from kameleon_mcmc . gp . mcmc . PseudoMarginalHyperparameterDistribution import PseudoMarginalHyperparameterDistribution <EOL> from kameleon_mcmc . kernel . GaussianKernel import GaussianKernel <EOL> from kameleon_mcmc . mcmc . MCMCChain import MCMCChain <EOL> from kameleon_mcmc . mcmc . MCMCParams import MCMCParams <EOL> from kameleon_mcmc . mcmc . output . PlottingOutput import PlottingOutput <EOL> from kameleon_mcmc . mcmc . output . StatisticsOutput import StatisticsOutput <EOL> from kameleon_mcmc . mcmc . samplers . AdaptiveMetropolisLearnScale import AdaptiveMetropolisLearnScale <EOL> from kameleon_mcmc . mcmc . samplers . KameleonWindowLearnScale import KameleonWindowLearnScale <EOL> from kameleon_mcmc . mcmc . samplers . StandardMetropolis import StandardMetropolis <EOL> from numpy . lib . twodim_base import eye <EOL> from numpy . linalg . linalg import cholesky <EOL> from numpy . ma . core import mean , ones , shape , asarray <EOL>", "answer": "from numpy . ma . extras import cov"}, {"prompt": "<s> import sys , os <EOL> autodoc_docstring_signature = True <EOL> extensions = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> templates_path = [ '<STR_LIT>' ] <EOL> source_suffix = '<STR_LIT>' <EOL> master_doc = '<STR_LIT:index>' <EOL> project = u'<STR_LIT>' <EOL> copyright = u'<STR_LIT>' <EOL> version = '<STR_LIT>' <EOL> release = '<STR_LIT>' <EOL> exclude_patterns = [ '<STR_LIT>' ] <EOL> pygments_style = '<STR_LIT>' <EOL> import os <EOL> on_rtd = os . environ . get ( '<STR_LIT>' , None ) == '<STR_LIT:True>' <EOL> if on_rtd : <EOL> html_theme = '<STR_LIT:default>' <EOL> else : <EOL> try : <EOL> import sphinx_rtd_theme <EOL> html_theme = '<STR_LIT>' <EOL> html_theme_path = [ sphinx_rtd_theme . get_html_theme_path ( ) ] <EOL> except ImportError : <EOL> html_theme = '<STR_LIT>' <EOL> html_static_path = [ '<STR_LIT>' ] <EOL> htmlhelp_basename = '<STR_LIT>' <EOL> latex_elements = { <EOL> } <EOL> latex_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> man_pages = [ <EOL>", "answer": "( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' ,"}, {"prompt": "<s> import copy <EOL> import errno <EOL> import os <EOL> import signal <EOL> import time <EOL> import sys <EOL> from random import randint <EOL> try : <EOL> from itertools import zip_longest as izip_longest <EOL> except ImportError : <EOL> from itertools import izip_longest <EOL> import site <EOL> from tornado import gen <EOL> from psutil import NoSuchProcess , TimeoutExpired <EOL> import zmq . utils . jsonapi as json <EOL> from zmq . eventloop import ioloop <EOL> from circus . process import Process , DEAD_OR_ZOMBIE , UNEXISTING <EOL> from circus . papa_process_proxy import PapaProcessProxy <EOL> from circus import logger <EOL> from circus import util <EOL> from circus . stream import get_stream , Redirector <EOL> from circus . stream . papa_redirector import PapaRedirector <EOL> from circus . util import parse_env_dict , resolve_name , tornado_sleep , IS_WINDOWS <EOL> from circus . util import papa <EOL> from circus . py3compat import bytestring , is_callable , b , PY2 <EOL> class Watcher ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , name , cmd , args = None , numprocesses = <NUM_LIT:1> , warmup_delay = <NUM_LIT:0.> , <EOL> working_dir = None , shell = False , shell_args = None , uid = None , <EOL> max_retry = <NUM_LIT:5> , gid = None , send_hup = False , <EOL> stop_signal = signal . SIGTERM , stop_children = False , env = None , <EOL> graceful_timeout = <NUM_LIT> , prereload_fn = None , rlimits = None , <EOL> executable = None , stdout_stream = None , stderr_stream = None , <EOL> priority = <NUM_LIT:0> , loop = None , singleton = False , use_sockets = False , <EOL> copy_env = False , copy_path = False , max_age = <NUM_LIT:0> , <EOL> max_age_variance = <NUM_LIT:30> , hooks = None , respawn = True , <EOL> autostart = True , on_demand = False , virtualenv = None , <EOL> close_child_stdin = True , close_child_stdout = False , <EOL> close_child_stderr = False , virtualenv_py_ver = None , <EOL> use_papa = False , ** options ) : <EOL> self . name = name <EOL> self . use_sockets = use_sockets <EOL> self . on_demand = on_demand <EOL> self . res_name = name . lower ( ) . replace ( \"<STR_LIT:U+0020>\" , \"<STR_LIT:_>\" ) <EOL> self . numprocesses = int ( numprocesses ) <EOL> self . warmup_delay = warmup_delay <EOL> self . cmd = cmd <EOL> self . args = args <EOL> self . _status = \"<STR_LIT>\" <EOL> self . graceful_timeout = float ( graceful_timeout ) <EOL> self . prereload_fn = prereload_fn <EOL> self . executable = None <EOL> self . priority = priority <EOL> self . stdout_stream_conf = copy . copy ( stdout_stream ) <EOL> self . stderr_stream_conf = copy . copy ( stderr_stream ) <EOL> self . stdout_stream = get_stream ( self . stdout_stream_conf ) <EOL> self . stderr_stream = get_stream ( self . stderr_stream_conf ) <EOL> self . stream_redirector = None <EOL> self . max_retry = max_retry <EOL> self . _options = options <EOL> self . singleton = singleton <EOL> self . copy_env = copy_env <EOL> self . copy_path = copy_path <EOL> self . virtualenv = virtualenv <EOL> self . virtualenv_py_ver = virtualenv_py_ver <EOL> self . max_age = int ( max_age ) <EOL> self . max_age_variance = int ( max_age_variance ) <EOL> self . ignore_hook_failure = [ '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> self . respawn = respawn <EOL> self . autostart = autostart <EOL> self . close_child_stdin = close_child_stdin <EOL> self . close_child_stdout = close_child_stdout <EOL> self . close_child_stderr = close_child_stderr <EOL> self . use_papa = use_papa and papa is not None <EOL> self . loop = loop or ioloop . IOLoop . instance ( ) <EOL> if singleton and self . numprocesses not in ( <NUM_LIT:0> , <NUM_LIT:1> ) : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % self . numprocesses ) <EOL> if IS_WINDOWS : <EOL> if self . stdout_stream or self . stderr_stream : <EOL> raise NotImplementedError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> if not copy_env and not env : <EOL> self . copy_env = True <EOL> self . optnames = ( ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:args>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" ) + <EOL> tuple ( options . keys ( ) ) ) <EOL> if not working_dir : <EOL> working_dir = util . get_working_dir ( ) <EOL> self . working_dir = working_dir <EOL> self . processes = { } <EOL> self . shell = shell <EOL> self . shell_args = shell_args <EOL> self . uid = uid <EOL> self . gid = gid <EOL> if self . copy_env : <EOL> self . env = os . environ . copy ( ) <EOL> if self . copy_path : <EOL> path = os . pathsep . join ( sys . path ) <EOL> self . env [ '<STR_LIT>' ] = path <EOL> if env is not None : <EOL> self . env . update ( env ) <EOL> else : <EOL> if self . copy_path : <EOL> raise ValueError ( ( '<STR_LIT>' <EOL> '<STR_LIT>' ) ) <EOL> self . env = env <EOL> if self . virtualenv : <EOL> util . load_virtualenv ( self , py_ver = virtualenv_py_ver ) <EOL> if self . env is not None and '<STR_LIT>' in self . env : <EOL> for path in self . env [ '<STR_LIT>' ] . split ( os . pathsep ) : <EOL> if path in sys . path : <EOL> continue <EOL> site . addsitedir ( path ) <EOL> self . rlimits = rlimits <EOL> self . send_hup = send_hup <EOL> self . stop_signal = stop_signal <EOL> self . stop_children = stop_children <EOL> self . sockets = self . evpub_socket = None <EOL> self . arbiter = None <EOL> self . hooks = { } <EOL> self . _resolve_hooks ( hooks ) <EOL> self . _found_wids = [ ] <EOL> if self . use_papa : <EOL> with papa . Papa ( ) as p : <EOL> base_name = '<STR_LIT>' . format ( name . lower ( ) ) <EOL> running = p . list_processes ( base_name ) <EOL> self . _found_wids = [ int ( proc_name [ len ( base_name ) - <NUM_LIT:1> : ] ) <EOL> for proc_name in running ] <EOL> def _reload_hook ( self , key , hook , ignore_error ) : <EOL> hook_name = key . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] <EOL> self . _resolve_hook ( hook_name , hook , ignore_error , reload_module = True ) <EOL> @ property <EOL> def _redirector_class ( self ) : <EOL> return PapaRedirector if self . use_papa else Redirector <EOL> @ property <EOL> def _process_class ( self ) : <EOL> return PapaProcessProxy if self . use_papa else Process <EOL> def _reload_stream ( self , key , val ) : <EOL> parts = key . split ( '<STR_LIT:.>' , <NUM_LIT:1> ) <EOL> stream_type = '<STR_LIT>' if parts [ <NUM_LIT:0> ] == '<STR_LIT>' else '<STR_LIT>' <EOL> old_stream = self . stream_redirector . get_stream ( stream_type ) if self . stream_redirector else None <EOL> if stream_type == '<STR_LIT>' : <EOL> self . stdout_stream_conf [ parts [ <NUM_LIT:1> ] ] = val <EOL> new_stream = get_stream ( self . stdout_stream_conf , reload = True ) <EOL> self . stdout_stream = new_stream <EOL> else : <EOL> self . stderr_stream_conf [ parts [ <NUM_LIT:1> ] ] = val <EOL> new_stream = get_stream ( self . stderr_stream_conf , reload = True ) <EOL> self . stderr_stream = new_stream <EOL> if self . stream_redirector : <EOL> self . stream_redirector . change_stream ( stream_type , new_stream ) <EOL> else : <EOL> self . stream_redirector = self . _redirector_class ( <EOL> self . stdout_stream , self . stderr_stream , loop = self . loop ) <EOL> if old_stream : <EOL> if hasattr ( old_stream , '<STR_LIT>' ) : <EOL> old_stream . close ( ) <EOL> return <NUM_LIT:0> <EOL> self . stream_redirector . start ( ) <EOL> return <NUM_LIT:1> <EOL> def _create_redirectors ( self ) : <EOL> if self . stdout_stream or self . stderr_stream : <EOL> if self . stream_redirector : <EOL> self . stream_redirector . stop ( ) <EOL> self . stream_redirector = self . _redirector_class ( <EOL> self . stdout_stream , self . stderr_stream , loop = self . loop ) <EOL> else : <EOL> self . stream_redirector = None <EOL> def _resolve_hook ( self , name , callable_or_name , ignore_failure , <EOL> reload_module = False ) : <EOL> if is_callable ( callable_or_name ) : <EOL> self . hooks [ name ] = callable_or_name <EOL> else : <EOL> self . hooks [ name ] = resolve_name ( callable_or_name , <EOL> reload = reload_module ) <EOL> if ignore_failure : <EOL> self . ignore_hook_failure . append ( name ) <EOL> def _resolve_hooks ( self , hooks ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if hooks is None : <EOL> return <EOL> for name , ( callable_or_name , ignore_failure ) in hooks . items ( ) : <EOL> self . _resolve_hook ( name , callable_or_name , ignore_failure ) <EOL> @ property <EOL> def pending_socket_event ( self ) : <EOL> return self . on_demand and not self . arbiter . socket_event <EOL> @ classmethod <EOL> def load_from_config ( cls , config ) : <EOL> if '<STR_LIT>' in config : <EOL> config [ '<STR_LIT>' ] = parse_env_dict ( config [ '<STR_LIT>' ] ) <EOL> cfg = config . copy ( ) <EOL> w = cls ( name = config . pop ( '<STR_LIT:name>' ) , cmd = config . pop ( '<STR_LIT>' ) , ** config ) <EOL> w . _cfg = cfg <EOL> return w <EOL> @ util . debuglog <EOL> def initialize ( self , evpub_socket , sockets , arbiter ) : <EOL> self . evpub_socket = evpub_socket <EOL> self . sockets = sockets <EOL> self . arbiter = arbiter <EOL> def __len__ ( self ) : <EOL> return len ( self . processes ) <EOL> def notify_event ( self , topic , msg ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = bytestring ( self . res_name ) <EOL> multipart_msg = [ b ( \"<STR_LIT>\" % ( name , topic ) ) , json . dumps ( msg ) ] <EOL> if self . evpub_socket is not None and not self . evpub_socket . closed : <EOL> self . evpub_socket . send_multipart ( multipart_msg ) <EOL> @ util . debuglog <EOL> def reap_process ( self , pid , status = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if pid not in self . processes : <EOL> return <EOL> process = self . processes . pop ( pid ) <EOL> timeout = <NUM_LIT> <EOL> while status is None : <EOL> if IS_WINDOWS : <EOL> try : <EOL> status = process . wait ( timeout = timeout ) <EOL> except TimeoutExpired : <EOL> continue <EOL> else : <EOL> try : <EOL> _ , status = os . waitpid ( pid , os . WNOHANG ) <EOL> except OSError as e : <EOL> if e . errno == errno . EAGAIN : <EOL> time . sleep ( timeout ) <EOL> continue <EOL> elif e . errno == errno . ECHILD : <EOL> status = None <EOL> else : <EOL> raise <EOL> if status is None : <EOL> logger . debug ( '<STR_LIT>' , <EOL> pid , self . name ) <EOL> self . notify_event ( <EOL> \"<STR_LIT>\" , <EOL> { \"<STR_LIT>\" : pid , <EOL> \"<STR_LIT:time>\" : time . time ( ) , <EOL> \"<STR_LIT>\" : process . returncode ( ) } ) <EOL> process . stop ( ) <EOL> return <EOL> if hasattr ( os , '<STR_LIT>' ) : <EOL> exit_code = <NUM_LIT:0> <EOL> if os . WIFSIGNALED ( status ) : <EOL> exit_code = - os . WTERMSIG ( status ) <EOL> elif os . WIFEXITED ( status ) : <EOL> exit_code = os . WEXITSTATUS ( status ) <EOL> else : <EOL> raise RuntimeError ( \"<STR_LIT>\" ) <EOL> else : <EOL> exit_code = status <EOL> if process . status in ( DEAD_OR_ZOMBIE , UNEXISTING ) : <EOL> process . stop ( ) <EOL> logger . debug ( '<STR_LIT>' , pid , self . name ) <EOL> self . notify_event ( \"<STR_LIT>\" , <EOL> { \"<STR_LIT>\" : pid , <EOL> \"<STR_LIT:time>\" : time . time ( ) , <EOL> \"<STR_LIT>\" : exit_code } ) <EOL> @ util . debuglog <EOL> def reap_processes ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . is_stopped ( ) : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return <EOL> for pid in list ( self . processes . keys ( ) ) : <EOL> self . reap_process ( pid ) <EOL> @ gen . coroutine <EOL> @ util . debuglog <EOL> def manage_processes ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . is_stopped ( ) : <EOL> return <EOL> for process in list ( self . processes . values ( ) ) : <EOL> if process . status in ( DEAD_OR_ZOMBIE , UNEXISTING ) : <EOL> self . processes . pop ( process . pid ) <EOL> if self . max_age : <EOL> yield self . remove_expired_processes ( ) <EOL> if len ( self . processes ) < self . numprocesses and not self . is_stopping ( ) : <EOL> if self . respawn : <EOL> yield self . spawn_processes ( ) <EOL> elif not len ( self . processes ) and not self . on_demand : <EOL> yield self . _stop ( ) <EOL> if len ( self . processes ) > self . numprocesses : <EOL> processes_to_kill = [ ] <EOL> for process in sorted ( self . processes . values ( ) , <EOL> key = lambda process : process . started , <EOL> reverse = True ) [ self . numprocesses : ] : <EOL> if process . status in ( DEAD_OR_ZOMBIE , UNEXISTING ) : <EOL> self . processes . pop ( process . pid ) <EOL> else : <EOL> processes_to_kill . append ( process ) <EOL> removes = yield [ self . kill_process ( process ) <EOL> for process in processes_to_kill ] <EOL> for i , process in enumerate ( processes_to_kill ) : <EOL> if removes [ i ] : <EOL> self . processes . pop ( process . pid ) <EOL> @ gen . coroutine <EOL> @ util . debuglog <EOL> def remove_expired_processes ( self ) : <EOL> expired_processes = [ p for p in self . processes . values ( ) <EOL> if p . age ( ) > ( self . max_age + randint ( <NUM_LIT:0> , <EOL> self . max_age_variance ) ) ] <EOL> removes = yield [ self . kill_process ( x ) for x in expired_processes ] <EOL> for i , process in enumerate ( expired_processes ) : <EOL> if removes [ i ] : <EOL> self . processes . pop ( process . pid ) <EOL> @ gen . coroutine <EOL> @ util . debuglog <EOL> def reap_and_manage_processes ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . is_stopped ( ) : <EOL> return <EOL> self . reap_processes ( ) <EOL> yield self . manage_processes ( ) <EOL> @ gen . coroutine <EOL> @ util . debuglog <EOL> def spawn_processes ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . pending_socket_event : <EOL> self . _status = \"<STR_LIT>\" <EOL> return <EOL> for i in self . _found_wids : <EOL> self . spawn_process ( i ) <EOL> yield tornado_sleep ( <NUM_LIT:0> ) <EOL> self . _found_wids = { } <EOL> for i in range ( self . numprocesses - len ( self . processes ) ) : <EOL> res = self . spawn_process ( ) <EOL> if res is False : <EOL> yield self . _stop ( ) <EOL> break <EOL> delay = self . warmup_delay <EOL> if isinstance ( res , float ) : <EOL> delay -= ( time . time ( ) - res ) <EOL> if delay < <NUM_LIT:0> : <EOL> delay = <NUM_LIT:0> <EOL> yield tornado_sleep ( delay ) <EOL> def _get_sockets_fds ( self ) : <EOL> if self . sockets is None : <EOL> return { } <EOL> return dict ( ( name , sock . fileno ( ) ) <EOL> for name , sock in self . sockets . items ( ) <EOL> if sock . use_papa == self . use_papa ) <EOL> def spawn_process ( self , recovery_wid = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . is_stopped ( ) : <EOL> return True <EOL> if not recovery_wid and not self . call_hook ( '<STR_LIT>' ) : <EOL> return False <EOL> cmd = util . replace_gnu_args ( self . cmd , env = self . env ) <EOL> nb_tries = <NUM_LIT:0> <EOL> if self . stream_redirector : <EOL> self . stream_redirector . start ( ) <EOL> while nb_tries < self . max_retry or self . max_retry == - <NUM_LIT:1> : <EOL> process = None <EOL> pipe_stdout = self . stdout_stream is not None <EOL> pipe_stderr = self . stderr_stream is not None <EOL> ProcCls = self . _process_class <EOL> try : <EOL> process = ProcCls ( self . name , recovery_wid or self . _nextwid , <EOL> cmd , args = self . args , <EOL> working_dir = self . working_dir , <EOL> shell = self . shell , uid = self . uid , gid = self . gid , <EOL> env = self . env , rlimits = self . rlimits , <EOL> executable = self . executable , <EOL> use_fds = self . use_sockets , watcher = self , <EOL> pipe_stdout = pipe_stdout , <EOL> pipe_stderr = pipe_stderr , <EOL> close_child_stdin = self . close_child_stdin , <EOL> close_child_stdout = self . close_child_stdout , <EOL> close_child_stderr = self . close_child_stderr ) <EOL> if self . stream_redirector : <EOL> self . stream_redirector . add_redirections ( process ) <EOL> self . processes [ process . pid ] = process <EOL> logger . debug ( '<STR_LIT>' , self . name , <EOL> process . pid ) <EOL> if not self . call_hook ( '<STR_LIT>' , pid = process . pid ) : <EOL> self . kill_process ( process ) <EOL> del self . processes [ process . pid ] <EOL> return False <EOL> except ( OSError , ValueError ) as e : <EOL> logger . warning ( '<STR_LIT>' , self . name , str ( e ) ) <EOL> if process is None : <EOL> nb_tries += <NUM_LIT:1> <EOL> continue <EOL> else : <EOL> self . notify_event ( \"<STR_LIT>\" , { \"<STR_LIT>\" : process . pid , <EOL> \"<STR_LIT:time>\" : process . started } ) <EOL> return process . started <EOL> return False <EOL> @ util . debuglog <EOL> def send_signal_process ( self , process , signum ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> children = None <EOL> try : <EOL> children = process . children ( ) <EOL> self . send_signal ( process . pid , signum ) <EOL> self . notify_event ( \"<STR_LIT>\" , { \"<STR_LIT>\" : process . pid , <EOL> \"<STR_LIT:time>\" : time . time ( ) } ) <EOL> except NoSuchProcess : <EOL> if children is None : <EOL> return <EOL> for child_pid in children : <EOL> try : <EOL> process . send_signal_child ( child_pid , signum ) <EOL> self . notify_event ( \"<STR_LIT>\" , { \"<STR_LIT>\" : child_pid , <EOL> \"<STR_LIT:time>\" : time . time ( ) } ) <EOL> except NoSuchProcess : <EOL> pass <EOL> @ gen . coroutine <EOL> @ util . debuglog <EOL> def kill_process ( self , process , stop_signal = None , graceful_timeout = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if stop_signal is None : <EOL> stop_signal = self . stop_signal <EOL> if graceful_timeout is None : <EOL> graceful_timeout = self . graceful_timeout <EOL> if process . stopping : <EOL> raise gen . Return ( False ) <EOL> try : <EOL> logger . debug ( \"<STR_LIT>\" , self . name , process . pid ) <EOL> if self . stop_children : <EOL> self . send_signal_process ( process , stop_signal ) <EOL> else : <EOL> self . send_signal ( process . pid , stop_signal ) <EOL> self . notify_event ( \"<STR_LIT>\" , { \"<STR_LIT>\" : process . pid , <EOL> \"<STR_LIT:time>\" : time . time ( ) } ) <EOL> except NoSuchProcess : <EOL> raise gen . Return ( False ) <EOL> process . stopping = True <EOL> waited = <NUM_LIT:0> <EOL> while waited < graceful_timeout : <EOL> if not process . is_alive ( ) : <EOL> break <EOL> yield tornado_sleep ( <NUM_LIT:0.1> ) <EOL> waited += <NUM_LIT:0.1> <EOL> if waited >= graceful_timeout : <EOL> if hasattr ( signal , '<STR_LIT>' ) : <EOL> self . send_signal_process ( process , signal . SIGKILL ) <EOL> if self . stream_redirector : <EOL> self . stream_redirector . remove_redirections ( process ) <EOL> process . stopping = False <EOL> process . stop ( ) <EOL> raise gen . Return ( True ) <EOL> @ gen . coroutine <EOL> @ util . debuglog <EOL> def kill_processes ( self , stop_signal = None , graceful_timeout = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> active_processes = self . get_active_processes ( ) <EOL> try : <EOL> yield [ self . kill_process ( process , <EOL> stop_signal = stop_signal , <EOL> graceful_timeout = graceful_timeout ) <EOL> for process in active_processes ] <EOL> except OSError as e : <EOL> if e . errno != errno . ESRCH : <EOL> raise <EOL> @ util . debuglog <EOL> def send_signal ( self , pid , signum ) : <EOL> is_sigkill = hasattr ( signal , '<STR_LIT>' ) and signum == signal . SIGKILL <EOL> if pid in self . processes : <EOL> process = self . processes [ pid ] <EOL> hook_result = self . call_hook ( \"<STR_LIT>\" , <EOL> pid = pid , signum = signum ) <EOL> if not is_sigkill and not hook_result : <EOL> logger . debug ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % ( signum , pid ) ) <EOL> else : <EOL> process . send_signal ( signum ) <EOL> self . call_hook ( \"<STR_LIT>\" , pid = pid , signum = signum ) <EOL> else : <EOL> logger . debug ( '<STR_LIT>' % pid ) <EOL> @ util . debuglog <EOL> def send_signal_child ( self , pid , child_id , signum ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> process = self . processes [ pid ] <EOL> try : <EOL> process . send_signal_child ( int ( child_id ) , signum ) <EOL> except OSError as e : <EOL> if e . errno != errno . ESRCH : <EOL> raise <EOL> @ util . debuglog <EOL> def send_signal_children ( self , pid , signum , recursive = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> process = self . processes [ int ( pid ) ] <EOL> process . send_signal_children ( signum , recursive ) <EOL> @ util . debuglog <EOL> def status ( self ) : <EOL> return self . _status <EOL> @ util . debuglog <EOL> def process_info ( self , pid , extended = False ) : <EOL> process = self . processes [ int ( pid ) ] <EOL> result = process . info ( ) <EOL> if extended and '<STR_LIT>' in self . hooks : <EOL> self . hooks [ '<STR_LIT>' ] ( self , self . arbiter , <EOL> '<STR_LIT>' , <EOL> pid = pid , stats = result ) <EOL> return result <EOL> @ util . debuglog <EOL> def info ( self , extended = False ) : <EOL> result = dict ( [ ( proc . pid , proc . info ( ) ) <EOL> for proc in self . processes . values ( ) ] ) <EOL> if extended and '<STR_LIT>' in self . hooks : <EOL> for pid , stats in result . items ( ) : <EOL> self . hooks [ '<STR_LIT>' ] ( self , self . arbiter , <EOL> '<STR_LIT>' , <EOL> pid = pid , stats = stats ) <EOL> return result <EOL> @ util . synchronized ( \"<STR_LIT>\" ) <EOL> @ gen . coroutine <EOL> def stop ( self ) : <EOL> yield self . _stop ( True ) <EOL> @ util . debuglog <EOL> @ gen . coroutine <EOL> def _stop ( self , close_output_streams = False , for_shutdown = False ) : <EOL> if self . is_stopped ( ) : <EOL> return <EOL> self . _status = \"<STR_LIT>\" <EOL> skip = for_shutdown and self . use_papa <EOL> if not skip : <EOL> logger . debug ( '<STR_LIT>' % self . name ) <EOL> logger . debug ( '<STR_LIT>' % ( <EOL> self . name , self . graceful_timeout ) ) <EOL> self . call_hook ( '<STR_LIT>' ) <EOL> yield self . kill_processes ( ) <EOL> self . reap_processes ( ) <EOL> if self . stream_redirector : <EOL> self . stream_redirector . stop ( ) <EOL> self . stream_redirector = None <EOL> if close_output_streams : <EOL> if self . stdout_stream and hasattr ( self . stdout_stream , '<STR_LIT>' ) : <EOL> self . stdout_stream . close ( ) <EOL> if self . stderr_stream and hasattr ( self . stderr_stream , '<STR_LIT>' ) : <EOL> self . stderr_stream . close ( ) <EOL> if skip : <EOL> logger . info ( '<STR_LIT>' , self . name ) <EOL> else : <EOL> if self . evpub_socket is not None : <EOL> self . notify_event ( \"<STR_LIT>\" , { \"<STR_LIT:time>\" : time . time ( ) } ) <EOL> self . _status = \"<STR_LIT>\" <EOL> self . call_hook ( '<STR_LIT>' ) <EOL> logger . info ( '<STR_LIT>' , self . name ) <EOL> def get_active_processes ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return [ p for p in self . processes . values ( ) <EOL> if p . status not in ( DEAD_OR_ZOMBIE , UNEXISTING ) ] <EOL> def get_active_pids ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return [ p . pid for p in self . processes . values ( ) <EOL> if p . status not in ( DEAD_OR_ZOMBIE , UNEXISTING ) ] <EOL> @ property <EOL> def pids ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return [ process . pid for process in self . processes ] <EOL> @ property <EOL> def _nextwid ( self ) : <EOL> used_wids = set ( [ p . wid for p in self . processes . values ( ) ] ) <EOL> all_wids = set ( range ( <NUM_LIT:1> , self . numprocesses * <NUM_LIT:2> + <NUM_LIT:1> ) ) <EOL> available_wids = sorted ( all_wids - used_wids ) <EOL> try : <EOL> return available_wids [ <NUM_LIT:0> ] <EOL> except IndexError : <EOL> raise RuntimeError ( \"<STR_LIT>\" ) <EOL> def call_hook ( self , hook_name , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> hook_kwargs = { '<STR_LIT>' : self , '<STR_LIT>' : self . arbiter , <EOL> '<STR_LIT>' : hook_name } <EOL> hook_kwargs . update ( kwargs ) <EOL> if hook_name in self . hooks : <EOL> try : <EOL> result = self . hooks [ hook_name ] ( ** hook_kwargs ) <EOL> self . notify_event ( \"<STR_LIT>\" , <EOL> { \"<STR_LIT:name>\" : hook_name , \"<STR_LIT:time>\" : time . time ( ) } ) <EOL> except Exception as error : <EOL> logger . exception ( '<STR_LIT>' % hook_name ) <EOL> result = hook_name in self . ignore_hook_failure <EOL> self . notify_event ( \"<STR_LIT>\" , <EOL> { \"<STR_LIT:name>\" : hook_name , \"<STR_LIT:time>\" : time . time ( ) , <EOL> \"<STR_LIT:error>\" : str ( error ) } ) <EOL> return result <EOL> else : <EOL> return True <EOL> @ util . synchronized ( \"<STR_LIT>\" ) <EOL> @ gen . coroutine <EOL> def start ( self ) : <EOL> before_pids = set ( ) if self . is_stopped ( ) else set ( self . processes ) <EOL> yield self . _start ( ) <EOL> after_pids = set ( self . processes ) <EOL> raise gen . Return ( { '<STR_LIT>' : sorted ( after_pids - before_pids ) , <EOL> '<STR_LIT>' : sorted ( after_pids & before_pids ) } ) <EOL> @ gen . coroutine <EOL> @ util . debuglog <EOL> def _start ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . pending_socket_event : <EOL> return <EOL> if not self . is_stopped ( ) : <EOL> if len ( self . processes ) < self . numprocesses : <EOL> self . reap_processes ( ) <EOL> yield self . spawn_processes ( ) <EOL> return <EOL> found_wids = len ( self . _found_wids ) <EOL> if not self . _found_wids and not self . call_hook ( '<STR_LIT>' ) : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return <EOL> self . _status = \"<STR_LIT>\" <EOL> if self . stdout_stream and hasattr ( self . stdout_stream , '<STR_LIT>' ) : <EOL> self . stdout_stream . open ( ) <EOL> if self . stderr_stream and hasattr ( self . stderr_stream , '<STR_LIT>' ) : <EOL> self . stderr_stream . open ( ) <EOL> self . _create_redirectors ( ) <EOL> self . reap_processes ( ) <EOL> yield self . spawn_processes ( ) <EOL> if not self . processes or not self . call_hook ( '<STR_LIT>' ) : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> yield self . _stop ( True ) <EOL> return <EOL> self . _status = \"<STR_LIT>\" <EOL> if found_wids : <EOL> logger . info ( '<STR_LIT>' % self . name ) <EOL> else : <EOL> logger . info ( '<STR_LIT>' % self . name ) <EOL> self . notify_event ( \"<STR_LIT:start>\" , { \"<STR_LIT:time>\" : time . time ( ) } ) <EOL> @ util . synchronized ( \"<STR_LIT>\" ) <EOL> @ gen . coroutine <EOL> def restart ( self ) : <EOL> before_pids = set ( ) if self . is_stopped ( ) else set ( self . processes ) <EOL> yield self . _restart ( ) <EOL> after_pids = set ( self . processes ) <EOL> raise gen . Return ( { '<STR_LIT>' : sorted ( before_pids - after_pids ) , <EOL> '<STR_LIT>' : sorted ( after_pids - before_pids ) , <EOL> '<STR_LIT>' : sorted ( after_pids & before_pids ) } ) <EOL> @ gen . coroutine <EOL>", "answer": "@ util . debuglog"}, {"prompt": "<s> class socket_producer : <EOL> def __init__ ( self , conn , buffer_size = <NUM_LIT> ) : <EOL> self . conn = conn <EOL> self . buffer_size = buffer_size <EOL> def next ( self ) : <EOL> return self . conn . recv ( self . buffer_size ) <EOL> def sock_stream ( sock ) : <EOL> return buffered_stream ( socket_producer ( sock ) . next ) <EOL> class buffered_stream : <EOL> def __init__ ( self , producer ) : <EOL> self . producer = producer <EOL> self . buffer = '<STR_LIT>' <EOL> def gen_read_until ( self , delim ) : <EOL>", "answer": "\"<STR_LIT>\""}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> from django . core . management . base import LabelCommand , CommandError <EOL> from corehq . apps . userreports import tasks <EOL> class Command ( LabelCommand ) : <EOL> help = \"<STR_LIT>\" <EOL> args = '<STR_LIT>' <EOL> label = \"<STR_LIT>\" <EOL> def handle ( self , * args , ** options ) : <EOL> if len ( args ) < <NUM_LIT:1> : <EOL> raise CommandError ( '<STR_LIT>' % self . args ) <EOL>", "answer": "config_id = args [ <NUM_LIT:0> ]"}, {"prompt": "<s> import warnings <EOL> warnings . warn ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> DeprecationWarning , <EOL> stacklevel = <NUM_LIT:2> <EOL>", "answer": ")"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Intangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL>", "answer": "result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "<s> import logging <EOL> log = logging . getLogger ( __name__ ) <EOL> EXCLUDED_LOG_VARS = [ '<STR_LIT>' , '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:args>' , '<STR_LIT>' , '<STR_LIT:filename>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:message>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL>", "answer": "def register_logging ( logger , client_config , cls ) :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = - <NUM_LIT:1>"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from freight . testutils import TestCase <EOL> class CatchallTest ( TestCase ) : <EOL> def test_simple ( self ) : <EOL> path = '<STR_LIT>' <EOL> for method in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> resp = getattr ( self . client , method ) ( path ) <EOL>", "answer": "assert resp . status_code == <NUM_LIT>"}, {"prompt": "<s> import os <EOL> _base = os . path . dirname ( __file__ ) <EOL> TEMPLATE_DEBUG = DEBUG = True <EOL> DATABASE_ENGINE = '<STR_LIT>' <EOL> DATABASE_NAME = os . path . join ( _base , '<STR_LIT>' ) <EOL> DATABASE_USER = '<STR_LIT>' <EOL> DATABASE_PASSWORD = '<STR_LIT>' <EOL> DATABASE_HOST = '<STR_LIT>' <EOL> DATABASE_PORT = '<STR_LIT>' <EOL> TIME_ZONE = '<STR_LIT>' <EOL> LANGUAGE_CODE = '<STR_LIT>' <EOL> SITE_ID = <NUM_LIT:1> <EOL> USE_I18N = False <EOL> MEDIA_ROOT = os . path . join ( _base , \"<STR_LIT>\" ) <EOL> MEDIA_URL = '<STR_LIT>' <EOL> ADMIN_MEDIA_PREFIX = '<STR_LIT>' <EOL> SECRET_KEY = '<STR_LIT>' <EOL> TEMPLATE_LOADERS = ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) <EOL> MIDDLEWARE_CLASSES = ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) <EOL> ROOT_URLCONF = '<STR_LIT>' <EOL> TEMPLATE_DIRS = ( <EOL> os . path . join ( _base , \"<STR_LIT>\" ) , <EOL> ) <EOL> INSTALLED_APPS = ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> from django . db import models <EOL> from django . conf import settings <EOL> User = getattr ( settings , '<STR_LIT>' , '<STR_LIT>' ) <EOL> class PinCard ( models . Model ) : <EOL> token = models . CharField ( max_length = <NUM_LIT:32> , db_index = True , editable = False ) <EOL> display_number = models . CharField ( max_length = <NUM_LIT:20> , editable = False ) <EOL> expiry_month = models . PositiveSmallIntegerField ( ) <EOL> expiry_year = models . PositiveSmallIntegerField ( ) <EOL> scheme = models . CharField ( max_length = <NUM_LIT:20> , editable = False ) <EOL> first_name = models . CharField ( max_length = <NUM_LIT:255> ) <EOL> last_name = models . CharField ( max_length = <NUM_LIT:255> ) <EOL> address_line1 = models . CharField ( max_length = <NUM_LIT:255> ) <EOL> address_line2 = models . CharField ( max_length = <NUM_LIT:255> , blank = True ) <EOL> address_city = models . CharField ( max_length = <NUM_LIT:255> ) <EOL> address_postcode = models . CharField ( max_length = <NUM_LIT:20> ) <EOL> address_state = models . CharField ( max_length = <NUM_LIT:255> ) <EOL> address_country = models . CharField ( max_length = <NUM_LIT:255> ) <EOL> created_at = models . DateTimeField ( auto_now_add = True ) <EOL> user = models . ForeignKey ( User , related_name = '<STR_LIT>' , blank = True , null = True ) <EOL> def __unicode__ ( self ) : <EOL> return '<STR_LIT>' % self . display_number <EOL> class Meta : <EOL> app_label = __name__ . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:0> ] <EOL> class PinCustomer ( models . Model ) : <EOL> token = models . CharField ( unique = True , max_length = <NUM_LIT:32> ) <EOL> card = models . ForeignKey ( \"<STR_LIT>\" , related_name = '<STR_LIT>' ) <EOL> email = models . EmailField ( ) <EOL> created_at = models . DateTimeField ( ) <EOL>", "answer": "user = models . OneToOneField ( User , related_name = '<STR_LIT>' , blank = True , null = True )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> try : <EOL> from urlparse import urljoin , urlunparse <EOL> from urllib import quote <EOL> except ImportError : <EOL> from urllib . parse import urljoin , urlunparse , quote <EOL> is_py3 = sys . version_info [ <NUM_LIT:0> ] > <NUM_LIT:2> <EOL> if is_py3 : <EOL> binary_type = bytes <EOL> text_type = str <EOL> else : <EOL>", "answer": "binary_type = str"}, {"prompt": "<s> import commands , sys , os <EOL> status , path_sct = commands . getstatusoutput ( '<STR_LIT>' ) <EOL> sys . path . append ( path_sct + '<STR_LIT>' ) <EOL> sys . path . append ( path_sct + '<STR_LIT>' ) <EOL> import sct_utils as sct <EOL> import nibabel <EOL> from glob import glob <EOL> import time <EOL> path = '<STR_LIT>' <EOL> os . chdir ( path ) <EOL> list_dir = os . listdir ( path ) <EOL> for i in range ( - <NUM_LIT:2> , len ( list_dir ) ) : <EOL> if os . path . isdir ( list_dir [ i ] ) : <EOL> list_dir_2 = os . listdir ( path + '<STR_LIT:/>' + list_dir [ i ] ) <EOL> for j in range ( len ( list_dir_2 ) ) : <EOL> if list_dir_2 [ j ] == '<STR_LIT>' : <EOL> print '<STR_LIT>' + list_dir [ i ] + '<STR_LIT:/>' + list_dir_2 [ j ] + '<STR_LIT>' <EOL> os . chdir ( list_dir [ i ] + '<STR_LIT:/>' + list_dir_2 [ j ] ) <EOL> path_tmp = '<STR_LIT>' + time . strftime ( \"<STR_LIT>\" ) <EOL> sct . run ( '<STR_LIT>' + path_tmp ) <EOL> sct . printv ( '<STR_LIT>' ) <EOL> name_anatomy_file = glob ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL>", "answer": "path_anatomy_file = os . path . abspath ( name_anatomy_file )"}, {"prompt": "<s> from foam . sfa . rspecs . elements . element import Element <EOL> class PLTag ( Element ) : <EOL> fields = [ <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> __email__ = '<STR_LIT>' <EOL> __since__ = '<STR_LIT>' <EOL> from . import api <EOL> class CrashLog ( api . APIRequest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , api_key , app_id , crash_id , format = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> api . APIRequest . __init__ ( self , api_key ) <EOL> self . _key = '<STR_LIT>' <EOL> self . _app_id = app_id <EOL> self . _crash_id = crash_id <EOL>", "answer": "self . _format = format"}, {"prompt": "<s> import itertools as it , operator as op , functools as ft <EOL> from urlparse import urlparse <EOL> from hashlib import sha1 <EOL> import os <EOL> from django . core . urlresolvers import reverse <EOL> from django . http import HttpResponse , Http404 <EOL> from django import template <EOL> from django . conf import settings <EOL> from django . views . decorators . http import etag <EOL> from django_remotestorage import __version__ <EOL> from django_remotestorage . utils import cors_wrapper <EOL> from . xrd_gen import xrd_cache <EOL> xrd_mime = lambda fmt : '<STR_LIT>' . format ( fmt , settings . DEFAULT_CHARSET ) <EOL> etag_base = sha1 ( __version__ ) . hexdigest ( ) <EOL> def etag_func ( request , ext = None , fmt = None ) : <EOL> return sha1 ( '<STR_LIT>' . join ( it . imap ( bytes , [ <EOL> etag_base , ext , fmt , <EOL> request . build_absolute_uri ( '<STR_LIT:/>' ) , <EOL> reverse ( '<STR_LIT>' ) , <EOL> reverse ( '<STR_LIT>' , kwargs = dict ( acct = '<STR_LIT>' , path = '<STR_LIT>' ) ) , <EOL> request . GET . get ( '<STR_LIT>' , '<STR_LIT>' ) ] ) ) ) . hexdigest ( ) <EOL> @ etag ( etag_func ) <EOL> @ cors_wrapper <EOL> def host_meta ( request , ext = None , fmt = '<STR_LIT>' ) : <EOL> assert fmt in [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> try : tpl = template . loader . get_template ( '<STR_LIT>' . format ( fmt ) ) <EOL> except template . TemplateDoesNotExist : <EOL> page = xrd_cache . gen_host_meta ( fmt = fmt , <EOL> template = '<STR_LIT>' . format ( request . build_absolute_uri ( <EOL> reverse ( '<STR_LIT>' , kwargs = dict ( fmt = fmt ) ) ) ) ) , <EOL> else : <EOL> page = tpl . render ( template . RequestContext ( <EOL> request , dict ( q_fmt = fmt , url_base = request . build_absolute_uri ( '<STR_LIT:/>' ) . rstrip ( '<STR_LIT:/>' ) ) ) ) <EOL> return HttpResponse ( page , content_type = xrd_mime ( fmt ) ) <EOL> @ etag ( etag_func ) <EOL> @ cors_wrapper <EOL> def webfinger ( request , ext = None , fmt = '<STR_LIT>' ) : <EOL> assert fmt in [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> try : subject = request . GET [ '<STR_LIT>' ] <EOL> except KeyError : raise Http404 <EOL> subject_parsed = urlparse ( subject , '<STR_LIT>' ) <EOL> if subject_parsed . scheme != '<STR_LIT>' or '<STR_LIT:@>' not in subject_parsed . path : raise Http404 <EOL> acct = subject_parsed . path . split ( '<STR_LIT:@>' , <NUM_LIT:1> ) [ <NUM_LIT:0> ] <EOL> try : tpl = template . loader . get_template ( '<STR_LIT>' . format ( fmt ) ) <EOL> except template . TemplateDoesNotExist : <EOL> page = xrd_cache . gen_webfinger ( fmt = fmt , <EOL>", "answer": "auth = '<STR_LIT>' . format ("}, {"prompt": "<s> from __future__ import absolute_import , print_function <EOL> import os <EOL> import shutil <EOL> from toil . job import Job <EOL> from toil . leader import FailedJobsException <EOL> from toil . test import ToilTest <EOL> class CleanWorkDirTest ( ToilTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> super ( CleanWorkDirTest , self ) . setUp ( ) <EOL> self . testDir = self . _createTempDir ( ) <EOL> def tearDown ( self ) : <EOL> super ( CleanWorkDirTest , self ) . tearDown ( ) <EOL> shutil . rmtree ( self . testDir ) <EOL> def testNever ( self ) : <EOL> retainedTempData = self . _runAndReturnWorkDir ( \"<STR_LIT>\" , job = tempFileTestJob ) <EOL> self . assertNotEqual ( retainedTempData , [ ] , \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def testAlways ( self ) : <EOL> retainedTempData = self . _runAndReturnWorkDir ( \"<STR_LIT>\" , job = tempFileTestJob ) <EOL> self . assertEqual ( retainedTempData , [ ] , \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def testOnErrorWithError ( self ) : <EOL> retainedTempData = self . _runAndReturnWorkDir ( \"<STR_LIT>\" , job = tempFileTestErrorJob , expectError = True ) <EOL> self . assertEqual ( retainedTempData , [ ] , \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def testOnErrorWithNoError ( self ) : <EOL> retainedTempData = self . _runAndReturnWorkDir ( \"<STR_LIT>\" , job = tempFileTestJob ) <EOL> self . assertNotEqual ( retainedTempData , [ ] , \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def testOnSuccessWithError ( self ) : <EOL> retainedTempData = self . _runAndReturnWorkDir ( \"<STR_LIT>\" , job = tempFileTestErrorJob , expectError = True ) <EOL> self . assertNotEqual ( retainedTempData , [ ] , \"<STR_LIT>\" <EOL>", "answer": "\"<STR_LIT>\" )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import numpy as np <EOL> import matplotlib . pyplot as plt <EOL> import mne <EOL> from mne . datasets import sample <EOL> from mne . minimum_norm import apply_inverse_epochs , read_inverse_operator <EOL> from mne . connectivity import spectral_connectivity <EOL> from mne . viz import circular_layout , plot_connectivity_circle <EOL> print ( __doc__ ) <EOL> data_path = sample . data_path ( ) <EOL> subjects_dir = data_path + '<STR_LIT>' <EOL> fname_inv = data_path + '<STR_LIT>' <EOL> fname_raw = data_path + '<STR_LIT>' <EOL> fname_event = data_path + '<STR_LIT>' <EOL> inverse_operator = read_inverse_operator ( fname_inv ) <EOL> raw = mne . io . read_raw_fif ( fname_raw ) <EOL> events = mne . read_events ( fname_event ) <EOL> raw . info [ '<STR_LIT>' ] += [ '<STR_LIT>' ] <EOL> picks = mne . pick_types ( raw . info , meg = True , eeg = False , stim = False , eog = True , <EOL> exclude = '<STR_LIT>' ) <EOL> event_id , tmin , tmax = <NUM_LIT:1> , - <NUM_LIT> , <NUM_LIT:0.5> <EOL> epochs = mne . Epochs ( raw , events , event_id , tmin , tmax , picks = picks , <EOL> baseline = ( None , <NUM_LIT:0> ) , reject = dict ( mag = <NUM_LIT> , grad = <NUM_LIT> , <EOL> eog = <NUM_LIT> ) ) <EOL> snr = <NUM_LIT:1.0> <EOL> lambda2 = <NUM_LIT:1.0> / snr ** <NUM_LIT:2> <EOL> method = \"<STR_LIT>\" <EOL> stcs = apply_inverse_epochs ( epochs , inverse_operator , lambda2 , method , <EOL> pick_ori = \"<STR_LIT>\" , return_generator = True ) <EOL> labels = mne . read_labels_from_annot ( '<STR_LIT>' , parc = '<STR_LIT>' , <EOL> subjects_dir = subjects_dir ) <EOL> label_colors = [ label . color for label in labels ] <EOL> src = inverse_operator [ '<STR_LIT:src>' ] <EOL> label_ts = mne . extract_label_time_course ( stcs , labels , src , mode = '<STR_LIT>' , <EOL> return_generator = True ) <EOL> fmin = <NUM_LIT> <EOL> fmax = <NUM_LIT> <EOL> sfreq = raw . info [ '<STR_LIT>' ] <EOL> con_methods = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> con , freqs , times , n_epochs , n_tapers = spectral_connectivity ( <EOL> label_ts , method = con_methods , mode = '<STR_LIT>' , sfreq = sfreq , fmin = fmin , <EOL> fmax = fmax , faverage = True , mt_adaptive = True , n_jobs = <NUM_LIT:1> ) <EOL> con_res = dict ( ) <EOL> for method , c in zip ( con_methods , con ) : <EOL> con_res [ method ] = c [ : , : , <NUM_LIT:0> ] <EOL> label_names = [ label . name for label in labels ] <EOL> lh_labels = [ name for name in label_names if name . endswith ( '<STR_LIT>' ) ] <EOL> label_ypos = list ( ) <EOL> for name in lh_labels : <EOL> idx = label_names . index ( name ) <EOL> ypos = np . mean ( labels [ idx ] . pos [ : , <NUM_LIT:1> ] ) <EOL> label_ypos . append ( ypos ) <EOL> lh_labels = [ label for ( yp , label ) in sorted ( zip ( label_ypos , lh_labels ) ) ] <EOL> rh_labels = [ label [ : - <NUM_LIT:2> ] + '<STR_LIT>' for label in lh_labels ] <EOL> node_order = list ( ) <EOL>", "answer": "node_order . extend ( lh_labels [ : : - <NUM_LIT:1> ] )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import unittest <EOL>", "answer": "def test_TestSuite_iter ( ) :"}, {"prompt": "<s> from django . conf import settings <EOL> user_model_label = getattr ( settings , '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL>", "answer": "from django . contrib . auth . tests . utils import skipIfCustomUser"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from alembic import op <EOL>", "answer": "revision = \"<STR_LIT>\""}, {"prompt": "<s> from south . utils import datetime_utils as datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . add_column ( '<STR_LIT>' , '<STR_LIT>' , <EOL> self . gf ( '<STR_LIT>' ) ( default = None ) , <EOL> keep_default = False ) <EOL> def backwards ( self , orm ) : <EOL> db . delete_column ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:user>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:user>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL>", "answer": "'<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from service_document import ServiceDocument <EOL> from collection import SDCollection , Collection_Feed <EOL> from statement import Atom_Sword_Statement , Ore_Sword_Statement <EOL> from error_document import Error_Document <EOL> from connection import Connection <EOL> from transaction_history import Transaction_History <EOL> from exceptions import * <EOL>", "answer": "from server_errors import SWORD2ERRORSBYIRI , SWORD2ERRORSBYNAME"}, {"prompt": "<s> nexts = [ <NUM_LIT:0> ] * maximum_depth_of_tree <EOL> def minimum_ws ( tree , depth = <NUM_LIT:0> ) : <EOL> tree . x = nexts [ depth ] <EOL> tree . y = depth <EOL>", "answer": "nexts [ depth ] += <NUM_LIT:1>"}, {"prompt": "<s> from flask_plugins import Plugin <EOL> __plugin__ = \"<STR_LIT>\" <EOL> class TestThreePlugin ( Plugin ) : <EOL> name = \"<STR_LIT>\" <EOL> description = \"<STR_LIT>\" <EOL> author = \"<STR_LIT>\" <EOL> license = \"<STR_LIT>\" <EOL>", "answer": "version = \"<STR_LIT:1.0>\" "}, {"prompt": "<s> from django . views . generic import list_detail <EOL> from basic . music . models import * <EOL> def genre_detail ( request , slug ) : <EOL> return list_detail . object_detail ( <EOL> request , <EOL> queryset = Genre . objects . all ( ) , <EOL> slug = slug , <EOL> ) <EOL> genre_detail . __doc__ = list_detail . object_detail . __doc__ <EOL> def genre_list ( request ) : <EOL> return list_detail . object_list ( <EOL> request , <EOL> queryset = Genre . objects . all ( ) , <EOL> paginate_by = <NUM_LIT:20> , <EOL> ) <EOL> genre_list . __doc__ = list_detail . object_list . __doc__ <EOL> def label_detail ( request , slug ) : <EOL> return list_detail . object_detail ( <EOL> request , <EOL> queryset = Label . objects . all ( ) , <EOL> slug = slug , <EOL> ) <EOL> label_detail . __doc__ = list_detail . object_detail . __doc__ <EOL> def label_list ( request ) : <EOL> return list_detail . object_list ( <EOL> request , <EOL> queryset = Label . objects . all ( ) , <EOL> paginate_by = <NUM_LIT:20> , <EOL> ) <EOL>", "answer": "label_list . __doc__ = list_detail . object_list . __doc__"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models <EOL> from django . utils . encoding import python_2_unicode_compatible <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from django . contrib . sites . models import Site <EOL> from jsonfield . fields import JSONField <EOL> from . models_base import CascadeModelBase <EOL> @ python_2_unicode_compatible <EOL> class SharedGlossary ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> plugin_type = models . CharField ( _ ( \"<STR_LIT>\" ) , max_length = <NUM_LIT:50> , db_index = True , editable = False ) <EOL> identifier = models . CharField ( _ ( \"<STR_LIT>\" ) , max_length = <NUM_LIT:50> , unique = True ) <EOL> glossary = JSONField ( null = True , blank = True , default = { } ) <EOL> class Meta : <EOL> unique_together = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> verbose_name_plural = verbose_name = _ ( \"<STR_LIT>\" ) <EOL> def __str__ ( self ) : <EOL> return self . identifier <EOL> class CascadeElement ( CascadeModelBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class Meta : <EOL> db_table = '<STR_LIT>' <EOL> def copy_relations ( self , oldinstance ) : <EOL> def init_element ( inline_element ) : <EOL> inline_element . pk = None <EOL> inline_element . cascade_element = self <EOL> inline_element . save ( ) <EOL> for inline_element in oldinstance . inline_elements . all ( ) : <EOL>", "answer": "init_element ( inline_element )"}, {"prompt": "<s> import sys <EOL> class Node ( object ) : <EOL> __slots__ = ( ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def children ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> def show ( self , buf = sys . stdout , offset = <NUM_LIT:0> , attrnames = False , nodenames = False , showcoord = False , _my_node_name = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> lead = '<STR_LIT:U+0020>' * offset <EOL> if nodenames and _my_node_name is not None : <EOL> buf . write ( lead + self . __class__ . __name__ + '<STR_LIT>' + _my_node_name + '<STR_LIT>' ) <EOL> else : <EOL> buf . write ( lead + self . __class__ . __name__ + '<STR_LIT>' ) <EOL> if self . attr_names : <EOL> if attrnames : <EOL> nvlist = [ ( n , getattr ( self , n ) ) for n in self . attr_names ] <EOL> attrstr = '<STR_LIT:U+002CU+0020>' . join ( '<STR_LIT>' % nv for nv in nvlist ) <EOL> else : <EOL> vlist = [ getattr ( self , n ) for n in self . attr_names ] <EOL> attrstr = '<STR_LIT:U+002CU+0020>' . join ( '<STR_LIT:%s>' % v for v in vlist ) <EOL> buf . write ( attrstr ) <EOL> if showcoord : <EOL> buf . write ( '<STR_LIT>' % self . coord ) <EOL> buf . write ( '<STR_LIT:\\n>' ) <EOL> for ( child_name , child ) in self . children ( ) : <EOL> child . show ( <EOL> buf , <EOL> offset = offset + <NUM_LIT:2> , <EOL> attrnames = attrnames , <EOL> nodenames = nodenames , <EOL> showcoord = showcoord , <EOL> _my_node_name = child_name ) <EOL> class NodeVisitor ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def visit ( self , node ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> method = '<STR_LIT>' + node . __class__ . __name__ <EOL> visitor = getattr ( self , method , self . generic_visit ) <EOL> return visitor ( node ) <EOL> def generic_visit ( self , node ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for c_name , c in node . children ( ) : <EOL> self . visit ( c ) <EOL> class ArrayDecl ( Node ) : <EOL> __slots__ = ( '<STR_LIT:type>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , type , dim , dim_quals , coord = None ) : <EOL> self . type = type <EOL> self . dim = dim <EOL> self . dim_quals = dim_quals <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . type is not None : nodelist . append ( ( \"<STR_LIT:type>\" , self . type ) ) <EOL> if self . dim is not None : nodelist . append ( ( \"<STR_LIT>\" , self . dim ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( '<STR_LIT>' , ) <EOL> class ArrayRef ( Node ) : <EOL> __slots__ = ( '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , name , subscript , coord = None ) : <EOL> self . name = name <EOL> self . subscript = subscript <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . name is not None : nodelist . append ( ( \"<STR_LIT:name>\" , self . name ) ) <EOL> if self . subscript is not None : nodelist . append ( ( \"<STR_LIT>\" , self . subscript ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class Assignment ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , op , lvalue , rvalue , coord = None ) : <EOL> self . op = op <EOL> self . lvalue = lvalue <EOL> self . rvalue = rvalue <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . lvalue is not None : nodelist . append ( ( \"<STR_LIT>\" , self . lvalue ) ) <EOL> if self . rvalue is not None : nodelist . append ( ( \"<STR_LIT>\" , self . rvalue ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( '<STR_LIT>' , ) <EOL> class BinaryOp ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT:left>' , '<STR_LIT:right>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , op , left , right , coord = None ) : <EOL> self . op = op <EOL> self . left = left <EOL> self . right = right <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . left is not None : nodelist . append ( ( \"<STR_LIT:left>\" , self . left ) ) <EOL> if self . right is not None : nodelist . append ( ( \"<STR_LIT:right>\" , self . right ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( '<STR_LIT>' , ) <EOL> class Break ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , coord = None ) : <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> return ( ) <EOL> attr_names = ( ) <EOL> class Case ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , expr , stmts , coord = None ) : <EOL> self . expr = expr <EOL> self . stmts = stmts <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . expr is not None : nodelist . append ( ( \"<STR_LIT>\" , self . expr ) ) <EOL> for i , child in enumerate ( self . stmts or [ ] ) : <EOL> nodelist . append ( ( \"<STR_LIT>\" % i , child ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class Cast ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , to_type , expr , coord = None ) : <EOL> self . to_type = to_type <EOL> self . expr = expr <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . to_type is not None : nodelist . append ( ( \"<STR_LIT>\" , self . to_type ) ) <EOL> if self . expr is not None : nodelist . append ( ( \"<STR_LIT>\" , self . expr ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class Compound ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , block_items , coord = None ) : <EOL> self . block_items = block_items <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> for i , child in enumerate ( self . block_items or [ ] ) : <EOL> nodelist . append ( ( \"<STR_LIT>\" % i , child ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class CompoundLiteral ( Node ) : <EOL> __slots__ = ( '<STR_LIT:type>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , type , init , coord = None ) : <EOL> self . type = type <EOL> self . init = init <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . type is not None : nodelist . append ( ( \"<STR_LIT:type>\" , self . type ) ) <EOL> if self . init is not None : nodelist . append ( ( \"<STR_LIT>\" , self . init ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class Constant ( Node ) : <EOL> __slots__ = ( '<STR_LIT:type>' , '<STR_LIT:value>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , type , value , coord = None ) : <EOL> self . type = type <EOL> self . value = value <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> return tuple ( nodelist ) <EOL> attr_names = ( '<STR_LIT:type>' , '<STR_LIT:value>' , ) <EOL> class Continue ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , coord = None ) : <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> return ( ) <EOL> attr_names = ( ) <EOL> class Decl ( Node ) : <EOL> __slots__ = ( '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:type>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , name , quals , storage , funcspec , type , init , bitsize , coord = None ) : <EOL> self . name = name <EOL> self . quals = quals <EOL> self . storage = storage <EOL> self . funcspec = funcspec <EOL> self . type = type <EOL> self . init = init <EOL> self . bitsize = bitsize <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . type is not None : nodelist . append ( ( \"<STR_LIT:type>\" , self . type ) ) <EOL> if self . init is not None : nodelist . append ( ( \"<STR_LIT>\" , self . init ) ) <EOL> if self . bitsize is not None : nodelist . append ( ( \"<STR_LIT>\" , self . bitsize ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ) <EOL> class DeclList ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , decls , coord = None ) : <EOL> self . decls = decls <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> for i , child in enumerate ( self . decls or [ ] ) : <EOL> nodelist . append ( ( \"<STR_LIT>\" % i , child ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class Default ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , stmts , coord = None ) : <EOL> self . stmts = stmts <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> for i , child in enumerate ( self . stmts or [ ] ) : <EOL> nodelist . append ( ( \"<STR_LIT>\" % i , child ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class DoWhile ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , cond , stmt , coord = None ) : <EOL> self . cond = cond <EOL> self . stmt = stmt <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . cond is not None : nodelist . append ( ( \"<STR_LIT>\" , self . cond ) ) <EOL> if self . stmt is not None : nodelist . append ( ( \"<STR_LIT>\" , self . stmt ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class EllipsisParam ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , coord = None ) : <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> return ( ) <EOL> attr_names = ( ) <EOL> class EmptyStatement ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , coord = None ) : <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> return ( ) <EOL> attr_names = ( ) <EOL> class Enum ( Node ) : <EOL> __slots__ = ( '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , name , values , coord = None ) : <EOL> self . name = name <EOL> self . values = values <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . values is not None : nodelist . append ( ( \"<STR_LIT>\" , self . values ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( '<STR_LIT:name>' , ) <EOL> class Enumerator ( Node ) : <EOL> __slots__ = ( '<STR_LIT:name>' , '<STR_LIT:value>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , name , value , coord = None ) : <EOL> self . name = name <EOL> self . value = value <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . value is not None : nodelist . append ( ( \"<STR_LIT:value>\" , self . value ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( '<STR_LIT:name>' , ) <EOL> class EnumeratorList ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , enumerators , coord = None ) : <EOL> self . enumerators = enumerators <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> for i , child in enumerate ( self . enumerators or [ ] ) : <EOL> nodelist . append ( ( \"<STR_LIT>\" % i , child ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class ExprList ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , exprs , coord = None ) : <EOL> self . exprs = exprs <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> for i , child in enumerate ( self . exprs or [ ] ) : <EOL> nodelist . append ( ( \"<STR_LIT>\" % i , child ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class FileAST ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , ext , coord = None ) : <EOL> self . ext = ext <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> for i , child in enumerate ( self . ext or [ ] ) : <EOL> nodelist . append ( ( \"<STR_LIT>\" % i , child ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class For ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , init , cond , next , stmt , coord = None ) : <EOL> self . init = init <EOL> self . cond = cond <EOL> self . next = next <EOL> self . stmt = stmt <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . init is not None : nodelist . append ( ( \"<STR_LIT>\" , self . init ) ) <EOL> if self . cond is not None : nodelist . append ( ( \"<STR_LIT>\" , self . cond ) ) <EOL> if self . next is not None : nodelist . append ( ( \"<STR_LIT>\" , self . next ) ) <EOL> if self . stmt is not None : nodelist . append ( ( \"<STR_LIT>\" , self . stmt ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class FuncCall ( Node ) : <EOL> __slots__ = ( '<STR_LIT:name>' , '<STR_LIT:args>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , name , args , coord = None ) : <EOL> self . name = name <EOL> self . args = args <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . name is not None : nodelist . append ( ( \"<STR_LIT:name>\" , self . name ) ) <EOL> if self . args is not None : nodelist . append ( ( \"<STR_LIT:args>\" , self . args ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class FuncDecl ( Node ) : <EOL> __slots__ = ( '<STR_LIT:args>' , '<STR_LIT:type>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , args , type , coord = None ) : <EOL> self . args = args <EOL> self . type = type <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . args is not None : nodelist . append ( ( \"<STR_LIT:args>\" , self . args ) ) <EOL> if self . type is not None : nodelist . append ( ( \"<STR_LIT:type>\" , self . type ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class FuncDef ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:body>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , decl , param_decls , body , coord = None ) : <EOL> self . decl = decl <EOL> self . param_decls = param_decls <EOL> self . body = body <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . decl is not None : nodelist . append ( ( \"<STR_LIT>\" , self . decl ) ) <EOL> if self . body is not None : nodelist . append ( ( \"<STR_LIT:body>\" , self . body ) ) <EOL> for i , child in enumerate ( self . param_decls or [ ] ) : <EOL> nodelist . append ( ( \"<STR_LIT>\" % i , child ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class Goto ( Node ) : <EOL> __slots__ = ( '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , name , coord = None ) : <EOL> self . name = name <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> return tuple ( nodelist ) <EOL> attr_names = ( '<STR_LIT:name>' , ) <EOL> class ID ( Node ) : <EOL> __slots__ = ( '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , name , coord = None ) : <EOL> self . name = name <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> return tuple ( nodelist ) <EOL> attr_names = ( '<STR_LIT:name>' , ) <EOL> class IdentifierType ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , names , coord = None ) : <EOL> self . names = names <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> return tuple ( nodelist ) <EOL> attr_names = ( '<STR_LIT>' , ) <EOL> class If ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , cond , iftrue , iffalse , coord = None ) : <EOL> self . cond = cond <EOL> self . iftrue = iftrue <EOL> self . iffalse = iffalse <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . cond is not None : nodelist . append ( ( \"<STR_LIT>\" , self . cond ) ) <EOL> if self . iftrue is not None : nodelist . append ( ( \"<STR_LIT>\" , self . iftrue ) ) <EOL> if self . iffalse is not None : nodelist . append ( ( \"<STR_LIT>\" , self . iffalse ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class InitList ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , exprs , coord = None ) : <EOL> self . exprs = exprs <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> for i , child in enumerate ( self . exprs or [ ] ) : <EOL> nodelist . append ( ( \"<STR_LIT>\" % i , child ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class Label ( Node ) : <EOL> __slots__ = ( '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , name , stmt , coord = None ) : <EOL> self . name = name <EOL> self . stmt = stmt <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . stmt is not None : nodelist . append ( ( \"<STR_LIT>\" , self . stmt ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( '<STR_LIT:name>' , ) <EOL> class NamedInitializer ( Node ) : <EOL> __slots__ = ( '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , name , expr , coord = None ) : <EOL> self . name = name <EOL> self . expr = expr <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . expr is not None : nodelist . append ( ( \"<STR_LIT>\" , self . expr ) ) <EOL> for i , child in enumerate ( self . name or [ ] ) : <EOL> nodelist . append ( ( \"<STR_LIT>\" % i , child ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class ParamList ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , params , coord = None ) : <EOL> self . params = params <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> for i , child in enumerate ( self . params or [ ] ) : <EOL> nodelist . append ( ( \"<STR_LIT>\" % i , child ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class PtrDecl ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT:type>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , quals , type , coord = None ) : <EOL> self . quals = quals <EOL> self . type = type <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . type is not None : nodelist . append ( ( \"<STR_LIT:type>\" , self . type ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( '<STR_LIT>' , ) <EOL> class Return ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , expr , coord = None ) : <EOL> self . expr = expr <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . expr is not None : nodelist . append ( ( \"<STR_LIT>\" , self . expr ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( ) <EOL> class Struct ( Node ) : <EOL> __slots__ = ( '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , name , decls , coord = None ) : <EOL> self . name = name <EOL> self . decls = decls <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> for i , child in enumerate ( self . decls or [ ] ) : <EOL> nodelist . append ( ( \"<STR_LIT>\" % i , child ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( '<STR_LIT:name>' , ) <EOL> class StructRef ( Node ) : <EOL> __slots__ = ( '<STR_LIT:name>' , '<STR_LIT:type>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , name , type , field , coord = None ) : <EOL> self . name = name <EOL> self . type = type <EOL> self . field = field <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . name is not None : nodelist . append ( ( \"<STR_LIT:name>\" , self . name ) ) <EOL> if self . field is not None : nodelist . append ( ( \"<STR_LIT>\" , self . field ) ) <EOL> return tuple ( nodelist ) <EOL> attr_names = ( '<STR_LIT:type>' , ) <EOL> class Switch ( Node ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , cond , stmt , coord = None ) : <EOL> self . cond = cond <EOL> self . stmt = stmt <EOL> self . coord = coord <EOL> def children ( self ) : <EOL> nodelist = [ ] <EOL> if self . cond is not None : nodelist . append ( ( \"<STR_LIT>\" , self . cond ) ) <EOL> if self . stmt is not None : nodelist . append ( ( \"<STR_LIT>\" , self . stmt ) ) <EOL>", "answer": "return tuple ( nodelist )"}, {"prompt": "<s> import webob <EOL> import webob . dec <EOL> import webob . exc <EOL> from nova . api import ec2 <EOL> from nova import context <EOL> from nova import exception <EOL> from nova import flags <EOL> from nova import test <EOL> from nova import utils <EOL> from xml . etree . ElementTree import fromstring as xml_to_tree <EOL> FLAGS = flags . FLAGS <EOL> @ webob . dec . wsgify <EOL> def conditional_forbid ( req ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in req . params and req . params [ '<STR_LIT>' ] == '<STR_LIT:1>' : <EOL> raise webob . exc . HTTPForbidden ( ) <EOL> return '<STR_LIT:OK>' <EOL> class LockoutTestCase ( test . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> super ( LockoutTestCase , self ) . setUp ( ) <EOL> utils . set_time_override ( ) <EOL> self . lockout = ec2 . Lockout ( conditional_forbid ) <EOL> def tearDown ( self ) : <EOL> utils . clear_time_override ( ) <EOL> super ( LockoutTestCase , self ) . tearDown ( ) <EOL> def _send_bad_attempts ( self , access_key , num_attempts = <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for i in xrange ( num_attempts ) : <EOL> req = webob . Request . blank ( '<STR_LIT>' % access_key ) <EOL> self . assertEqual ( req . get_response ( self . lockout ) . status_int , <NUM_LIT> ) <EOL> def _is_locked_out ( self , access_key ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> req = webob . Request . blank ( '<STR_LIT>' % access_key ) <EOL> return ( req . get_response ( self . lockout ) . status_int == <NUM_LIT> ) <EOL> def test_lockout ( self ) : <EOL> self . _send_bad_attempts ( '<STR_LIT:test>' , FLAGS . lockout_attempts ) <EOL> self . assertTrue ( self . _is_locked_out ( '<STR_LIT:test>' ) ) <EOL> def test_timeout ( self ) : <EOL> self . _send_bad_attempts ( '<STR_LIT:test>' , FLAGS . lockout_attempts ) <EOL> self . assertTrue ( self . _is_locked_out ( '<STR_LIT:test>' ) ) <EOL> utils . advance_time_seconds ( FLAGS . lockout_minutes * <NUM_LIT> ) <EOL> self . assertFalse ( self . _is_locked_out ( '<STR_LIT:test>' ) ) <EOL> def test_multiple_keys ( self ) : <EOL> self . _send_bad_attempts ( '<STR_LIT>' , FLAGS . lockout_attempts ) <EOL> self . assertTrue ( self . _is_locked_out ( '<STR_LIT>' ) ) <EOL> self . assertFalse ( self . _is_locked_out ( '<STR_LIT>' ) ) <EOL> utils . advance_time_seconds ( FLAGS . lockout_minutes * <NUM_LIT> ) <EOL> self . assertFalse ( self . _is_locked_out ( '<STR_LIT>' ) ) <EOL> self . assertFalse ( self . _is_locked_out ( '<STR_LIT>' ) ) <EOL> def test_window_timeout ( self ) : <EOL> self . _send_bad_attempts ( '<STR_LIT:test>' , FLAGS . lockout_attempts - <NUM_LIT:1> ) <EOL> self . assertFalse ( self . _is_locked_out ( '<STR_LIT:test>' ) ) <EOL> utils . advance_time_seconds ( FLAGS . lockout_window * <NUM_LIT> ) <EOL> self . _send_bad_attempts ( '<STR_LIT:test>' , FLAGS . lockout_attempts - <NUM_LIT:1> ) <EOL> self . assertFalse ( self . _is_locked_out ( '<STR_LIT:test>' ) ) <EOL> class ExecutorTestCase ( test . TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( ExecutorTestCase , self ) . setUp ( ) <EOL> self . executor = ec2 . Executor ( ) <EOL> def _execute ( self , invoke ) : <EOL> class Fake ( object ) : <EOL> pass <EOL> fake_ec2_request = Fake ( ) <EOL> fake_ec2_request . invoke = invoke <EOL> fake_wsgi_request = Fake ( ) <EOL> fake_wsgi_request . environ = { <EOL> '<STR_LIT>' : context . get_admin_context ( ) , <EOL> '<STR_LIT>' : fake_ec2_request , <EOL> } <EOL> return self . executor ( fake_wsgi_request ) <EOL> def _extract_message ( self , result ) : <EOL>", "answer": "tree = xml_to_tree ( result . body )"}, {"prompt": "<s> from __future__ import absolute_import , unicode_literals <EOL> import datetime <EOL> import qsstats <EOL> from . models import Document , DocumentPage , DocumentVersion <EOL> def new_documents_per_month ( ) : <EOL> qss = qsstats . QuerySetStats ( Document . passthrough . all ( ) , '<STR_LIT>' ) <EOL> today = datetime . date . today ( ) <EOL> this_year = datetime . date ( year = today . year , month = <NUM_LIT:1> , day = <NUM_LIT:1> ) <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : map ( lambda x : { x [ <NUM_LIT:0> ] . month : x [ <NUM_LIT:1> ] } , qss . time_series ( start = this_year , end = today , interval = '<STR_LIT>' ) ) <EOL> } <EOL> } <EOL> def new_document_versions_per_month ( ) : <EOL> qss = qsstats . QuerySetStats ( DocumentVersion . objects . all ( ) , '<STR_LIT>' ) <EOL> today = datetime . date . today ( ) <EOL> this_year = datetime . date ( year = today . year , month = <NUM_LIT:1> , day = <NUM_LIT:1> ) <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : map ( lambda x : { x [ <NUM_LIT:0> ] . month : x [ <NUM_LIT:1> ] } , qss . time_series ( start = this_year , end = today , interval = '<STR_LIT>' ) ) <EOL> } <EOL> } <EOL> def new_document_pages_per_month ( ) : <EOL> qss = qsstats . QuerySetStats ( DocumentPage . objects . all ( ) , '<STR_LIT>' ) <EOL> today = datetime . date . today ( ) <EOL> this_year = datetime . date ( year = today . year , month = <NUM_LIT:1> , day = <NUM_LIT:1> ) <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : map ( lambda x : { x [ <NUM_LIT:0> ] . month : x [ <NUM_LIT:1> ] } , qss . time_series ( start = this_year , end = today , interval = '<STR_LIT>' ) ) <EOL> } <EOL> } <EOL> def total_document_per_month ( ) : <EOL> qss = qsstats . QuerySetStats ( Document . objects . all ( ) , '<STR_LIT>' ) <EOL> this_year = datetime . date . today ( ) . year <EOL> result = [ ] <EOL> for month in range ( <NUM_LIT:1> , datetime . date . today ( ) . month + <NUM_LIT:1> ) : <EOL> next_month = month + <NUM_LIT:1> <EOL> if next_month == <NUM_LIT:12> : <EOL> next_month = <NUM_LIT:1> <EOL> year = this_year + <NUM_LIT:1> <EOL> else : <EOL> next_month = month + <NUM_LIT:1> <EOL> year = this_year <EOL> result . append ( { month : qss . until ( datetime . date ( year , next_month , <NUM_LIT:1> ) ) } ) <EOL> return { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : result <EOL>", "answer": "}"}, {"prompt": "<s> class ProxyCharacter : <EOL> def __init__ ( self , character_ref ) : <EOL> if type ( character_ref ) is str : <EOL> if character_ref . find ( \"<STR_LIT::>\" ) > - <NUM_LIT:1> : <EOL> [ self . player_ref , self . minion_ref ] = character_ref . split ( '<STR_LIT::>' ) <EOL> self . minion_ref = int ( self . minion_ref ) <EOL> else : <EOL> self . player_ref = character_ref <EOL> self . minion_ref = None <EOL> elif character_ref . is_hero ( ) : <EOL> if character_ref == character_ref . player . game . players [ <NUM_LIT:0> ] . hero : <EOL> self . player_ref = \"<STR_LIT>\" <EOL> else : <EOL> self . player_ref = \"<STR_LIT>\" <EOL> self . minion_ref = None <EOL> elif character_ref . is_minion ( ) : <EOL> if character_ref . player == character_ref . game . players [ <NUM_LIT:0> ] : <EOL> self . player_ref = \"<STR_LIT>\" <EOL> else : <EOL> self . player_ref = \"<STR_LIT>\" <EOL> self . minion_ref = character_ref . index <EOL> def resolve ( self , game ) : <EOL> if self . player_ref == \"<STR_LIT>\" : <EOL> char = game . players [ <NUM_LIT:0> ] . hero <EOL> else : <EOL> char = game . players [ <NUM_LIT:1> ] . hero <EOL> if self . minion_ref is not None : <EOL> if self . minion_ref == - <NUM_LIT:1> : <EOL> return None <EOL> if self . player_ref == \"<STR_LIT>\" : <EOL> char = game . players [ <NUM_LIT:0> ] . minions [ self . minion_ref ] <EOL> else : <EOL> char = game . players [ <NUM_LIT:1> ] . minions [ self . minion_ref ] <EOL> return char <EOL> def __str__ ( self ) : <EOL> if self . minion_ref is not None : <EOL> return \"<STR_LIT>\" . format ( self . player_ref , self . minion_ref ) <EOL> return self . player_ref <EOL> def to_output ( self ) : <EOL> return str ( self ) <EOL> def __to_json__ ( self ) : <EOL> if self . minion_ref is not None : <EOL> return { <EOL> '<STR_LIT>' : self . player_ref , <EOL> '<STR_LIT>' : self . minion_ref <EOL> } <EOL> else : <EOL> return { <EOL> '<STR_LIT>' : self . player_ref <EOL> } <EOL> @ staticmethod <EOL> def from_json ( player , minion = None ) : <EOL> rval = ProxyCharacter . __new__ ( ProxyCharacter ) <EOL> rval . player_ref = player <EOL> rval . minion_ref = minion <EOL> return rval <EOL> class ProxyCard : <EOL> def __init__ ( self , card_reference ) : <EOL> self . option = None <EOL> if isinstance ( card_reference , str ) : <EOL> if str . find ( card_reference , \"<STR_LIT::>\" ) > - <NUM_LIT:1> : <EOL> card_arr = str . split ( card_reference , \"<STR_LIT::>\" ) <EOL> self . card_ref = int ( card_arr [ <NUM_LIT:0> ] ) <EOL> self . option = int ( card_arr [ <NUM_LIT:1> ] ) <EOL>", "answer": "else :"}, {"prompt": "<s> class GstreamerBasePackage ( GstreamerPackage ) : <EOL> def __init__ ( self ) : <EOL> GstreamerPackage . __init__ ( self , <EOL> project = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' ) <EOL> self . configure = '<STR_LIT>' <EOL> self . sources . append ( <EOL> '<STR_LIT>' ) <EOL> self . sources . append ( <EOL> '<STR_LIT>' ) <EOL> self . sources . append ( <EOL> '<STR_LIT>' ) <EOL> def prep ( self ) : <EOL> Package . prep ( self ) <EOL> self . sh ( '<STR_LIT>' ) <EOL> self . sh ( '<STR_LIT>' ) <EOL>", "answer": "self . sh ( '<STR_LIT>' )"}, {"prompt": "<s> l = [ ] <EOL>", "answer": "print len ( l )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> from django . core . files import File <EOL> from django . test import TestCase <EOL> from django . test . client import RequestFactory <EOL> from leads . models import Register , Newsletter <EOL> from leads . admin import RegisterAdmin , NewsletterAdmin <EOL> class InitialDataMixin ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . factory = RequestFactory ( ) <EOL> self . register_admin = RegisterAdmin ( Register , None ) <EOL> Register . objects . create ( name = '<STR_LIT>' , email = '<STR_LIT>' ) <EOL> Register . objects . create ( name = '<STR_LIT>' , email = '<STR_LIT>' ) <EOL> Register . objects . create ( name = '<STR_LIT>' , email = '<STR_LIT>' ) <EOL> class TestRegisterAdmin ( InitialDataMixin , TestCase ) : <EOL> def test_export_to_csv ( self ) : <EOL> expected_result = [ [ '<STR_LIT:email>' , '<STR_LIT:name>' ] , <EOL> [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> [ '<STR_LIT>' , '<STR_LIT>' ] ] <EOL>", "answer": "request = self . factory . get ( '<STR_LIT:/>' )"}, {"prompt": "<s> from django . db . models import sql <EOL> from django . db . models . loading import cache <EOL> from django . db . models . query import CollectedObjects <EOL> from django . db . models . query_utils import CyclicDependency <EOL> from django . test import TestCase <EOL> from models import A , B , C , D , E , F <EOL> class DeleteTests ( TestCase ) : <EOL> def clear_rel_obj_caches ( self , * models ) : <EOL> for m in models : <EOL> if hasattr ( m . _meta , '<STR_LIT>' ) : <EOL> del m . _meta . _related_objects_cache <EOL> def order_models ( self , * models ) : <EOL> cache . app_models [ \"<STR_LIT>\" ] . keyOrder = models <EOL> def setUp ( self ) : <EOL> self . order_models ( \"<STR_LIT:a>\" , \"<STR_LIT:b>\" , \"<STR_LIT:c>\" , \"<STR_LIT:d>\" , \"<STR_LIT:e>\" , \"<STR_LIT:f>\" ) <EOL> self . clear_rel_obj_caches ( A , B , C , D , E , F ) <EOL> def tearDown ( self ) : <EOL> self . order_models ( \"<STR_LIT:a>\" , \"<STR_LIT:b>\" , \"<STR_LIT:c>\" , \"<STR_LIT:d>\" , \"<STR_LIT:e>\" , \"<STR_LIT:f>\" ) <EOL> self . clear_rel_obj_caches ( A , B , C , D , E , F ) <EOL> def test_collected_objects ( self ) : <EOL> g = CollectedObjects ( ) <EOL> self . assertFalse ( g . add ( \"<STR_LIT>\" , <NUM_LIT:1> , \"<STR_LIT>\" , None ) ) <EOL> self . assertEqual ( g [ \"<STR_LIT>\" ] , { <NUM_LIT:1> : \"<STR_LIT>\" } ) <EOL> self . assertFalse ( g . add ( \"<STR_LIT>\" , <NUM_LIT:1> , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> self . assertFalse ( g . add ( \"<STR_LIT>\" , <NUM_LIT:2> , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> self . assertEqual ( g [ \"<STR_LIT>\" ] , { <NUM_LIT:1> : \"<STR_LIT>\" , <NUM_LIT:2> : \"<STR_LIT>\" } ) <EOL> self . assertFalse ( g . add ( \"<STR_LIT>\" , <NUM_LIT:1> , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> self . assertTrue ( g . add ( \"<STR_LIT>\" , <NUM_LIT:1> , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> self . assertEqual ( g . ordered_keys ( ) , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) <EOL> self . assertTrue ( g . add ( \"<STR_LIT>\" , <NUM_LIT:1> , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) <EOL> self . assertRaises ( CyclicDependency , g . ordered_keys ) <EOL>", "answer": "def test_delete ( self ) :"}, {"prompt": "<s> from setuptools import setup , find_packages <EOL> version = \"<STR_LIT>\" <EOL> setup ( name = \"<STR_LIT>\" , <EOL> version = version , <EOL> description = \"<STR_LIT>\" , <EOL>", "answer": "author = \"<STR_LIT>\" ,"}, {"prompt": "<s> import logging <EOL> from django . core . urlresolvers import reverse <EOL> from django . template import defaultfilters <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from django . utils . translation import ungettext_lazy <EOL> from horizon import tables <EOL> from openstack_dashboard import api <EOL> from openstack_dashboard . dashboards . identity . groups import constants <EOL> LOG = logging . getLogger ( __name__ ) <EOL> LOGOUT_URL = '<STR_LIT>' <EOL> STATUS_CHOICES = ( <EOL> ( \"<STR_LIT:true>\" , True ) , <EOL> ( \"<STR_LIT:false>\" , False ) <EOL> ) <EOL> class CreateGroupLink ( tables . LinkAction ) : <EOL> name = \"<STR_LIT>\" <EOL> verbose_name = _ ( \"<STR_LIT>\" ) <EOL> url = constants . GROUPS_CREATE_URL <EOL> classes = ( \"<STR_LIT>\" , ) <EOL> icon = \"<STR_LIT>\" <EOL> policy_rules = ( ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , ) <EOL> def allowed ( self , request , group ) : <EOL> return api . keystone . keystone_can_edit_group ( ) <EOL> class EditGroupLink ( tables . LinkAction ) : <EOL> name = \"<STR_LIT>\" <EOL> verbose_name = _ ( \"<STR_LIT>\" ) <EOL> url = constants . GROUPS_UPDATE_URL <EOL> classes = ( \"<STR_LIT>\" , ) <EOL> icon = \"<STR_LIT>\" <EOL> policy_rules = ( ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , ) <EOL> def allowed ( self , request , group ) : <EOL> return api . keystone . keystone_can_edit_group ( ) <EOL> class DeleteGroupsAction ( tables . DeleteAction ) : <EOL> @ staticmethod <EOL> def action_present ( count ) : <EOL> return ungettext_lazy ( <EOL> u\"<STR_LIT>\" , <EOL> u\"<STR_LIT>\" , <EOL> count <EOL> ) <EOL> @ staticmethod <EOL> def action_past ( count ) : <EOL> return ungettext_lazy ( <EOL> u\"<STR_LIT>\" , <EOL> u\"<STR_LIT>\" , <EOL> count <EOL> ) <EOL> name = \"<STR_LIT>\" <EOL> policy_rules = ( ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , ) <EOL> def allowed ( self , request , datum ) : <EOL> return api . keystone . keystone_can_edit_group ( ) <EOL> def delete ( self , request , obj_id ) : <EOL> LOG . info ( '<STR_LIT>' % obj_id ) <EOL> api . keystone . group_delete ( request , obj_id ) <EOL> class ManageUsersLink ( tables . LinkAction ) : <EOL> name = \"<STR_LIT>\" <EOL>", "answer": "verbose_name = _ ( \"<STR_LIT>\" )"}, {"prompt": "<s> from __future__ import print_function <EOL> import sys <EOL> def print_one_html_line ( ) : <EOL>", "answer": "print ( '<STR_LIT>' )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from rally . common . i18n import _ <EOL> from rally import consts <EOL> from rally . task import sla <EOL> @ sla . configure ( name = \"<STR_LIT>\" ) <EOL> class FailureRate ( sla . SLA ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "CONFIG_SCHEMA = {"}, {"prompt": "<s> from re_scan import Scanner <EOL> scanner = Scanner ( [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL>", "answer": "( '<STR_LIT>' , '<STR_LIT>' ) ,"}, {"prompt": "<s> from setuptools import setup , find_packages <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL>", "answer": "version = '<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from warnings import warnpy3k <EOL> warnpy3k ( \"<STR_LIT>\" , <EOL> stacklevel = <NUM_LIT:2> ) <EOL> del warnpy3k <EOL> import markupbase <EOL> import re <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> interesting = re . compile ( '<STR_LIT>' ) <EOL> incomplete = re . compile ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> entityref = re . compile ( '<STR_LIT>' ) <EOL> charref = re . compile ( '<STR_LIT>' ) <EOL> starttagopen = re . compile ( '<STR_LIT>' ) <EOL> shorttagopen = re . compile ( '<STR_LIT>' ) <EOL> shorttag = re . compile ( '<STR_LIT>' ) <EOL> piclose = re . compile ( '<STR_LIT:>>' ) <EOL> endbracket = re . compile ( '<STR_LIT>' ) <EOL> tagfind = re . compile ( '<STR_LIT>' ) <EOL> attrfind = re . compile ( <EOL> r'<STR_LIT>' <EOL> r'<STR_LIT>' ) <EOL> class SGMLParseError ( RuntimeError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class SGMLParser ( markupbase . ParserBase ) : <EOL> entity_or_charref = re . compile ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> def __init__ ( self , verbose = <NUM_LIT:0> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . verbose = verbose <EOL> self . reset ( ) <EOL> def reset ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . __starttag_text = None <EOL> self . rawdata = '<STR_LIT>' <EOL> self . stack = [ ] <EOL> self . lasttag = '<STR_LIT>' <EOL> self . nomoretags = <NUM_LIT:0> <EOL> self . literal = <NUM_LIT:0> <EOL> markupbase . ParserBase . reset ( self ) <EOL> def setnomoretags ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . nomoretags = self . literal = <NUM_LIT:1> <EOL> def setliteral ( self , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . literal = <NUM_LIT:1> <EOL> def feed ( self , data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . rawdata = self . rawdata + data <EOL> self . goahead ( <NUM_LIT:0> ) <EOL> def close ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . goahead ( <NUM_LIT:1> ) <EOL> def error ( self , message ) : <EOL> raise SGMLParseError ( message ) <EOL> def goahead ( self , end ) : <EOL> rawdata = self . rawdata <EOL> i = <NUM_LIT:0> <EOL> n = len ( rawdata ) <EOL> while i < n : <EOL> if self . nomoretags : <EOL> self . handle_data ( rawdata [ i : n ] ) <EOL> i = n <EOL> break <EOL> match = interesting . search ( rawdata , i ) <EOL> if match : j = match . start ( ) <EOL> else : j = n <EOL> if i < j : <EOL> self . handle_data ( rawdata [ i : j ] ) <EOL> i = j <EOL> if i == n : break <EOL> if rawdata [ i ] == '<STR_LIT:<>' : <EOL> if starttagopen . match ( rawdata , i ) : <EOL> if self . literal : <EOL> self . handle_data ( rawdata [ i ] ) <EOL> i = i + <NUM_LIT:1> <EOL> continue <EOL> k = self . parse_starttag ( i ) <EOL> if k < <NUM_LIT:0> : break <EOL> i = k <EOL> continue <EOL> if rawdata . startswith ( \"<STR_LIT>\" , i ) : <EOL> k = self . parse_endtag ( i ) <EOL> if k < <NUM_LIT:0> : break <EOL> i = k <EOL> self . literal = <NUM_LIT:0> <EOL> continue <EOL> if self . literal : <EOL> if n > ( i + <NUM_LIT:1> ) : <EOL> self . handle_data ( \"<STR_LIT:<>\" ) <EOL> i = i + <NUM_LIT:1> <EOL> else : <EOL> break <EOL> continue <EOL> if rawdata . startswith ( \"<STR_LIT>\" , i ) : <EOL> k = self . parse_comment ( i ) <EOL> if k < <NUM_LIT:0> : break <EOL> i = k <EOL> continue <EOL> if rawdata . startswith ( \"<STR_LIT>\" , i ) : <EOL> k = self . parse_pi ( i ) <EOL> if k < <NUM_LIT:0> : break <EOL> i = i + k <EOL> continue <EOL> if rawdata . startswith ( \"<STR_LIT>\" , i ) : <EOL> k = self . parse_declaration ( i ) <EOL> if k < <NUM_LIT:0> : break <EOL> i = k <EOL> continue <EOL> elif rawdata [ i ] == '<STR_LIT:&>' : <EOL> if self . literal : <EOL> self . handle_data ( rawdata [ i ] ) <EOL> i = i + <NUM_LIT:1> <EOL> continue <EOL> match = charref . match ( rawdata , i ) <EOL> if match : <EOL> name = match . group ( <NUM_LIT:1> ) <EOL> self . handle_charref ( name ) <EOL> i = match . end ( <NUM_LIT:0> ) <EOL> if rawdata [ i - <NUM_LIT:1> ] != '<STR_LIT:;>' : i = i - <NUM_LIT:1> <EOL> continue <EOL> match = entityref . match ( rawdata , i ) <EOL> if match : <EOL> name = match . group ( <NUM_LIT:1> ) <EOL> self . handle_entityref ( name ) <EOL> i = match . end ( <NUM_LIT:0> ) <EOL> if rawdata [ i - <NUM_LIT:1> ] != '<STR_LIT:;>' : i = i - <NUM_LIT:1> <EOL> continue <EOL> else : <EOL> self . error ( '<STR_LIT>' ) <EOL> match = incomplete . match ( rawdata , i ) <EOL> if not match : <EOL> self . handle_data ( rawdata [ i ] ) <EOL> i = i + <NUM_LIT:1> <EOL> continue <EOL> j = match . end ( <NUM_LIT:0> ) <EOL> if j == n : <EOL> break <EOL> self . handle_data ( rawdata [ i : j ] ) <EOL> i = j <EOL> if end and i < n : <EOL> self . handle_data ( rawdata [ i : n ] ) <EOL> i = n <EOL> self . rawdata = rawdata [ i : ] <EOL> _decl_otherchars = '<STR_LIT:=>' <EOL> def parse_pi ( self , i ) : <EOL> rawdata = self . rawdata <EOL> if rawdata [ i : i + <NUM_LIT:2> ] != '<STR_LIT>' : <EOL> self . error ( '<STR_LIT>' ) <EOL> match = piclose . search ( rawdata , i + <NUM_LIT:2> ) <EOL> if not match : <EOL> return - <NUM_LIT:1> <EOL> j = match . start ( <NUM_LIT:0> ) <EOL> self . handle_pi ( rawdata [ i + <NUM_LIT:2> : j ] ) <EOL> j = match . end ( <NUM_LIT:0> ) <EOL> return j - i <EOL> def get_starttag_text ( self ) : <EOL> return self . __starttag_text <EOL> def parse_starttag ( self , i ) : <EOL> self . __starttag_text = None <EOL> start_pos = i <EOL> rawdata = self . rawdata <EOL> if shorttagopen . match ( rawdata , i ) : <EOL> match = shorttag . match ( rawdata , i ) <EOL> if not match : <EOL> return - <NUM_LIT:1> <EOL> tag , data = match . group ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> self . __starttag_text = '<STR_LIT>' % tag <EOL> tag = tag . lower ( ) <EOL> k = match . end ( <NUM_LIT:0> ) <EOL> self . finish_shorttag ( tag , data ) <EOL> self . __starttag_text = rawdata [ start_pos : match . end ( <NUM_LIT:1> ) + <NUM_LIT:1> ] <EOL> return k <EOL> match = endbracket . search ( rawdata , i + <NUM_LIT:1> ) <EOL> if not match : <EOL> return - <NUM_LIT:1> <EOL> j = match . start ( <NUM_LIT:0> ) <EOL> attrs = [ ] <EOL> if rawdata [ i : i + <NUM_LIT:2> ] == '<STR_LIT>' : <EOL> k = j <EOL> tag = self . lasttag <EOL> else : <EOL> match = tagfind . match ( rawdata , i + <NUM_LIT:1> ) <EOL> if not match : <EOL> self . error ( '<STR_LIT>' ) <EOL> k = match . end ( <NUM_LIT:0> ) <EOL> tag = rawdata [ i + <NUM_LIT:1> : k ] . lower ( ) <EOL> self . lasttag = tag <EOL> while k < j : <EOL> match = attrfind . match ( rawdata , k ) <EOL> if not match : break <EOL> attrname , rest , attrvalue = match . group ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) <EOL> if not rest : <EOL> attrvalue = attrname <EOL> else : <EOL> if ( attrvalue [ : <NUM_LIT:1> ] == \"<STR_LIT:'>\" == attrvalue [ - <NUM_LIT:1> : ] or <EOL> attrvalue [ : <NUM_LIT:1> ] == '<STR_LIT:\">' == attrvalue [ - <NUM_LIT:1> : ] ) : <EOL> attrvalue = attrvalue [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> attrvalue = self . entity_or_charref . sub ( <EOL> self . _convert_ref , attrvalue ) <EOL> attrs . append ( ( attrname . lower ( ) , attrvalue ) ) <EOL> k = match . end ( <NUM_LIT:0> ) <EOL> if rawdata [ j ] == '<STR_LIT:>>' : <EOL> j = j + <NUM_LIT:1> <EOL> self . __starttag_text = rawdata [ start_pos : j ] <EOL> self . finish_starttag ( tag , attrs ) <EOL> return j <EOL> def _convert_ref ( self , match ) : <EOL> if match . group ( <NUM_LIT:2> ) : <EOL> return self . convert_charref ( match . group ( <NUM_LIT:2> ) ) or '<STR_LIT>' % match . groups ( ) [ <NUM_LIT:1> : ] <EOL> elif match . group ( <NUM_LIT:3> ) : <EOL> return self . convert_entityref ( match . group ( <NUM_LIT:1> ) ) or '<STR_LIT>' % match . group ( <NUM_LIT:1> ) <EOL> else : <EOL> return '<STR_LIT>' % match . group ( <NUM_LIT:1> ) <EOL> def parse_endtag ( self , i ) : <EOL> rawdata = self . rawdata <EOL> match = endbracket . search ( rawdata , i + <NUM_LIT:1> ) <EOL> if not match : <EOL> return - <NUM_LIT:1> <EOL> j = match . start ( <NUM_LIT:0> ) <EOL> tag = rawdata [ i + <NUM_LIT:2> : j ] . strip ( ) . lower ( ) <EOL> if rawdata [ j ] == '<STR_LIT:>>' : <EOL> j = j + <NUM_LIT:1> <EOL> self . finish_endtag ( tag ) <EOL> return j <EOL> def finish_shorttag ( self , tag , data ) : <EOL> self . finish_starttag ( tag , [ ] ) <EOL> self . handle_data ( data ) <EOL> self . finish_endtag ( tag ) <EOL> def finish_starttag ( self , tag , attrs ) : <EOL> try : <EOL> method = getattr ( self , '<STR_LIT>' + tag ) <EOL> except AttributeError : <EOL> try : <EOL> method = getattr ( self , '<STR_LIT>' + tag ) <EOL> except AttributeError : <EOL> self . unknown_starttag ( tag , attrs ) <EOL> return - <NUM_LIT:1> <EOL> else : <EOL> self . handle_starttag ( tag , method , attrs ) <EOL> return <NUM_LIT:0> <EOL> else : <EOL> self . stack . append ( tag ) <EOL> self . handle_starttag ( tag , method , attrs ) <EOL> return <NUM_LIT:1> <EOL> def finish_endtag ( self , tag ) : <EOL> if not tag : <EOL> found = len ( self . stack ) - <NUM_LIT:1> <EOL> if found < <NUM_LIT:0> : <EOL> self . unknown_endtag ( tag ) <EOL> return <EOL> else : <EOL> if tag not in self . stack : <EOL> try : <EOL> method = getattr ( self , '<STR_LIT>' + tag ) <EOL> except AttributeError : <EOL> self . unknown_endtag ( tag ) <EOL> else : <EOL> self . report_unbalanced ( tag ) <EOL> return <EOL> found = len ( self . stack ) <EOL> for i in range ( found ) : <EOL> if self . stack [ i ] == tag : found = i <EOL> while len ( self . stack ) > found : <EOL> tag = self . stack [ - <NUM_LIT:1> ] <EOL> try : <EOL> method = getattr ( self , '<STR_LIT>' + tag ) <EOL> except AttributeError : <EOL> method = None <EOL> if method : <EOL> self . handle_endtag ( tag , method ) <EOL> else : <EOL> self . unknown_endtag ( tag ) <EOL> del self . stack [ - <NUM_LIT:1> ] <EOL> def handle_starttag ( self , tag , method , attrs ) : <EOL> method ( attrs ) <EOL> def handle_endtag ( self , tag , method ) : <EOL> method ( ) <EOL> def report_unbalanced ( self , tag ) : <EOL> if self . verbose : <EOL> print '<STR_LIT>' + tag + '<STR_LIT:>>' <EOL> print '<STR_LIT>' , self . stack <EOL> def convert_charref ( self , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "try :"}, {"prompt": "<s> import logging <EOL>", "answer": "import paho . mqtt . client as mqtt"}, {"prompt": "<s> from collections import namedtuple <EOL> import json <EOL> import logging <EOL> import os <EOL> import six <EOL> import warnings <EOL> from cassandra import metadata <EOL> from cassandra . cqlengine import CQLEngineException <EOL> from cassandra . cqlengine import columns <EOL> from cassandra . cqlengine . connection import execute , get_cluster <EOL> from cassandra . cqlengine . models import Model <EOL> from cassandra . cqlengine . named import NamedTable <EOL> from cassandra . cqlengine . usertype import UserType <EOL> CQLENG_ALLOW_SCHEMA_MANAGEMENT = '<STR_LIT>' <EOL> Field = namedtuple ( '<STR_LIT>' , [ '<STR_LIT:name>' , '<STR_LIT:type>' ] ) <EOL> log = logging . getLogger ( __name__ ) <EOL> schema_columnfamilies = NamedTable ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def create_keyspace_simple ( name , replication_factor , durable_writes = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _create_keyspace ( name , durable_writes , '<STR_LIT>' , <EOL> { '<STR_LIT>' : replication_factor } ) <EOL> def create_keyspace_network_topology ( name , dc_replication_map , durable_writes = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _create_keyspace ( name , durable_writes , '<STR_LIT>' , dc_replication_map ) <EOL> def _create_keyspace ( name , durable_writes , strategy_class , strategy_options ) : <EOL> if not _allow_schema_modification ( ) : <EOL> return <EOL> cluster = get_cluster ( ) <EOL> if name not in cluster . metadata . keyspaces : <EOL> log . info ( \"<STR_LIT>\" , name ) <EOL> ks_meta = metadata . KeyspaceMetadata ( name , durable_writes , strategy_class , strategy_options ) <EOL> execute ( ks_meta . as_cql_query ( ) ) <EOL> else : <EOL> log . info ( \"<STR_LIT>\" , name ) <EOL> def drop_keyspace ( name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not _allow_schema_modification ( ) : <EOL> return <EOL> cluster = get_cluster ( ) <EOL> if name in cluster . metadata . keyspaces : <EOL> execute ( \"<STR_LIT>\" . format ( metadata . protect_name ( name ) ) ) <EOL> def _get_index_name_by_column ( table , column_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> protected_name = metadata . protect_name ( column_name ) <EOL> possible_index_values = [ protected_name , \"<STR_LIT>\" % protected_name ] <EOL> for index_metadata in table . indexes . values ( ) : <EOL> options = dict ( index_metadata . index_options ) <EOL> if options . get ( '<STR_LIT:target>' ) in possible_index_values : <EOL> return index_metadata . name <EOL> def sync_table ( model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not _allow_schema_modification ( ) : <EOL> return <EOL> if not issubclass ( model , Model ) : <EOL> raise CQLEngineException ( \"<STR_LIT>\" ) <EOL> if model . __abstract__ : <EOL> raise CQLEngineException ( \"<STR_LIT>\" ) <EOL> cf_name = model . column_family_name ( ) <EOL> raw_cf_name = model . _raw_column_family_name ( ) <EOL> ks_name = model . _get_keyspace ( ) <EOL> cluster = get_cluster ( ) <EOL> try : <EOL> keyspace = cluster . metadata . keyspaces [ ks_name ] <EOL> except KeyError : <EOL> raise CQLEngineException ( \"<STR_LIT>\" . format ( ks_name , model ) ) <EOL> tables = keyspace . tables <EOL> syncd_types = set ( ) <EOL> for col in model . _columns . values ( ) : <EOL> udts = [ ] <EOL> columns . resolve_udts ( col , udts ) <EOL> for udt in [ u for u in udts if u not in syncd_types ] : <EOL> _sync_type ( ks_name , udt , syncd_types ) <EOL> if raw_cf_name not in tables : <EOL> log . debug ( \"<STR_LIT>\" , cf_name ) <EOL> qs = _get_create_table ( model ) <EOL> try : <EOL> execute ( qs ) <EOL> except CQLEngineException as ex : <EOL> if \"<STR_LIT>\" not in unicode ( ex ) : <EOL> raise <EOL> else : <EOL> log . debug ( \"<STR_LIT>\" , cf_name ) <EOL> table_meta = tables [ raw_cf_name ] <EOL> _validate_pk ( model , table_meta ) <EOL> table_columns = table_meta . columns <EOL> model_fields = set ( ) <EOL> for model_name , col in model . _columns . items ( ) : <EOL> db_name = col . db_field_name <EOL> model_fields . add ( db_name ) <EOL> if db_name in table_columns : <EOL> col_meta = table_columns [ db_name ] <EOL> if col_meta . cql_type != col . db_type : <EOL> msg = '<STR_LIT>' '<STR_LIT>' . format ( cf_name , db_name , col_meta . cql_type , col . db_type ) <EOL> warnings . warn ( msg ) <EOL> log . warning ( msg ) <EOL> continue <EOL> if col . primary_key or col . primary_key : <EOL> raise CQLEngineException ( \"<STR_LIT>\" . format ( model_name , db_name , cf_name ) ) <EOL> query = \"<STR_LIT>\" . format ( cf_name , col . get_column_def ( ) ) <EOL> execute ( query ) <EOL> db_fields_not_in_model = model_fields . symmetric_difference ( table_columns ) <EOL> if db_fields_not_in_model : <EOL> log . info ( \"<STR_LIT>\" . format ( cf_name , db_fields_not_in_model ) ) <EOL> _update_options ( model ) <EOL> table = cluster . metadata . keyspaces [ ks_name ] . tables [ raw_cf_name ] <EOL> indexes = [ c for n , c in model . _columns . items ( ) if c . index ] <EOL> for column in indexes : <EOL> index_name = _get_index_name_by_column ( table , column . db_field_name ) <EOL> if index_name : <EOL> continue <EOL> qs = [ '<STR_LIT>' ] <EOL> qs += [ '<STR_LIT>' . format ( cf_name ) ] <EOL> qs += [ '<STR_LIT>' . format ( column . db_field_name ) ] <EOL> qs = '<STR_LIT:U+0020>' . join ( qs ) <EOL> execute ( qs ) <EOL> def _validate_pk ( model , table_meta ) : <EOL> model_partition = [ c . db_field_name for c in model . _partition_keys . values ( ) ] <EOL> meta_partition = [ c . name for c in table_meta . partition_key ] <EOL> model_clustering = [ c . db_field_name for c in model . _clustering_keys . values ( ) ] <EOL> meta_clustering = [ c . name for c in table_meta . clustering_key ] <EOL> if model_partition != meta_partition or model_clustering != meta_clustering : <EOL> def _pk_string ( partition , clustering ) : <EOL> return \"<STR_LIT>\" . format ( '<STR_LIT:U+002CU+0020>' . join ( partition ) , '<STR_LIT:U+002CU+0020>' + '<STR_LIT:U+002CU+0020>' . join ( clustering ) if clustering else '<STR_LIT>' ) <EOL> raise CQLEngineException ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" . format ( model , model . column_family_name ( ) , <EOL> _pk_string ( model_partition , model_clustering ) , <EOL> _pk_string ( meta_partition , meta_clustering ) ) ) <EOL> def sync_type ( ks_name , type_model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not _allow_schema_modification ( ) : <EOL> return <EOL> if not issubclass ( type_model , UserType ) : <EOL> raise CQLEngineException ( \"<STR_LIT>\" ) <EOL> _sync_type ( ks_name , type_model ) <EOL> def _sync_type ( ks_name , type_model , omit_subtypes = None ) : <EOL> syncd_sub_types = omit_subtypes or set ( ) <EOL> for field in type_model . _fields . values ( ) : <EOL> udts = [ ] <EOL> columns . resolve_udts ( field , udts ) <EOL> for udt in [ u for u in udts if u not in syncd_sub_types ] : <EOL> _sync_type ( ks_name , udt , syncd_sub_types ) <EOL> syncd_sub_types . add ( udt ) <EOL> type_name = type_model . type_name ( ) <EOL> type_name_qualified = \"<STR_LIT>\" % ( ks_name , type_name ) <EOL> cluster = get_cluster ( ) <EOL> keyspace = cluster . metadata . keyspaces [ ks_name ] <EOL> defined_types = keyspace . user_types <EOL> if type_name not in defined_types : <EOL> log . debug ( \"<STR_LIT>\" , type_name_qualified ) <EOL> cql = get_create_type ( type_model , ks_name ) <EOL> execute ( cql ) <EOL> cluster . refresh_user_type_metadata ( ks_name , type_name ) <EOL> type_model . register_for_keyspace ( ks_name ) <EOL> else : <EOL> type_meta = defined_types [ type_name ] <EOL> defined_fields = type_meta . field_names <EOL> model_fields = set ( ) <EOL> for field in type_model . _fields . values ( ) : <EOL> model_fields . add ( field . db_field_name ) <EOL> if field . db_field_name not in defined_fields : <EOL> execute ( \"<STR_LIT>\" . format ( type_name_qualified , field . get_column_def ( ) ) ) <EOL> else : <EOL> field_type = type_meta . field_types [ defined_fields . index ( field . db_field_name ) ] <EOL> if field_type != field . db_type : <EOL>", "answer": "msg = '<STR_LIT>' '<STR_LIT>' . format ( type_name_qualified , field . db_field_name , field_type , field . db_type )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import division , print_function , absolute_import <EOL> import math <EOL> import numpy as np <EOL> import scipy . linalg <EOL> from . _trustregion import ( _minimize_trust_region , BaseQuadraticSubproblem ) <EOL> __all__ = [ ] <EOL> def _minimize_trust_ncg ( fun , x0 , args = ( ) , jac = None , hess = None , hessp = None , <EOL> ** trust_region_options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if jac is None : <EOL> raise ValueError ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> if hess is None and hessp is None : <EOL> raise ValueError ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> return _minimize_trust_region ( fun , x0 , args = args , jac = jac , hess = hess , <EOL> hessp = hessp , subproblem = CGSteihaugSubproblem , <EOL> ** trust_region_options ) <EOL> class CGSteihaugSubproblem ( BaseQuadraticSubproblem ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def solve ( self , trust_radius ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> p_origin = np . zeros_like ( self . jac ) <EOL> tolerance = min ( <NUM_LIT:0.5> , math . sqrt ( self . jac_mag ) ) * self . jac_mag <EOL> if self . jac_mag < tolerance : <EOL> hits_boundary = False <EOL> return p_origin , hits_boundary <EOL> z = p_origin <EOL> r = self . jac <EOL> d = - r <EOL> while True : <EOL> Bd = self . hessp ( d ) <EOL> dBd = np . dot ( d , Bd ) <EOL> if dBd <= <NUM_LIT:0> : <EOL> ta , tb = self . get_boundaries_intersections ( z , d , trust_radius ) <EOL>", "answer": "pa = z + ta * d"}, {"prompt": "<s> from . . excel_comparsion_test import ExcelComparisonTest <EOL> from ... workbook import Workbook <EOL> class TestCompareXLSXFiles ( ExcelComparisonTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . maxDiff = None <EOL> filename = '<STR_LIT>' <EOL> test_dir = '<STR_LIT>' <EOL> self . got_filename = test_dir + '<STR_LIT>' + filename <EOL> self . exp_filename = test_dir + '<STR_LIT>' + filename <EOL> self . ignore_files = [ ] <EOL> self . ignore_elements = { } <EOL> def test_create_file ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> workbook = Workbook ( self . got_filename ) <EOL> worksheet = workbook . add_worksheet ( ) <EOL>", "answer": "chart = workbook . add_chart ( { '<STR_LIT:type>' : '<STR_LIT>' } )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import imaplib <EOL> import sys <EOL> import unittest <EOL> from imap_cli import const <EOL> from imap_cli import list_mail <EOL> from imap_cli import tests <EOL> class ListMailTests ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> imaplib . IMAP4_SSL = tests . ImapConnectionMock ( ) <EOL>", "answer": "def test_list_command ( self ) :"}, {"prompt": "<s> import unittest <EOL> from pyramid import testing <EOL> class Test_set_yaml ( unittest . TestCase ) : <EOL> def _callFUT ( self , registry ) : <EOL> from . import set_yaml <EOL> return set_yaml ( registry ) <EOL> def test_loader_and_dumper_set ( self ) : <EOL> registry = DummyRegistry ( None ) <EOL> self . _callFUT ( registry ) <EOL> self . assertEqual ( registry [ '<STR_LIT>' ] . __name__ , '<STR_LIT>' ) <EOL> self . assertEqual ( registry [ '<STR_LIT>' ] . __name__ , '<STR_LIT>' ) <EOL> def test_iface_representer ( self ) : <EOL> import io <EOL> import yaml <EOL> registry = DummyRegistry ( None ) <EOL> self . _callFUT ( registry ) <EOL> stream = io . BytesIO ( ) <EOL> yaml . dump ( DummyInterface , stream , Dumper = registry [ '<STR_LIT>' ] , <EOL> encoding = '<STR_LIT:utf-8>' ) <EOL> self . assertEqual ( <EOL> stream . getvalue ( ) , <EOL> b\"<STR_LIT>\" <EOL> ) <EOL> def test_iface_constructor ( self ) : <EOL> import io <EOL> import yaml <EOL> registry = DummyRegistry ( None ) <EOL> self . _callFUT ( registry ) <EOL> stream = io . BytesIO ( <EOL> b\"<STR_LIT>\" <EOL> ) <EOL> result = yaml . load ( stream , Loader = registry [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( result , DummyInterface ) <EOL> def test_blob_representer ( self ) : <EOL> import io <EOL> import yaml <EOL> from ZODB . blob import Blob <EOL> registry = DummyRegistry ( None ) <EOL> self . _callFUT ( registry ) <EOL> stream = io . BytesIO ( ) <EOL> blob = Blob ( b'<STR_LIT:abc>' ) <EOL> yaml . dump ( blob , stream , Dumper = registry [ '<STR_LIT>' ] , <EOL> encoding = '<STR_LIT:utf-8>' ) <EOL> self . assertEqual ( <EOL> stream . getvalue ( ) , <EOL> b\"<STR_LIT>\" <EOL> ) <EOL> def test_blob_constructor ( self ) : <EOL> import io <EOL> import yaml <EOL> registry = DummyRegistry ( None ) <EOL> self . _callFUT ( registry ) <EOL> stream = io . BytesIO ( <EOL> b\"<STR_LIT>\" <EOL> ) <EOL> result = yaml . load ( stream , Loader = registry [ '<STR_LIT>' ] ) <EOL> with result . open ( '<STR_LIT:r>' ) as f : <EOL> self . assertEqual ( f . read ( ) , b'<STR_LIT:abc>' ) <EOL> class Test_get_dumpers ( unittest . TestCase ) : <EOL> def _callFUT ( self , registry ) : <EOL> from . import get_dumpers <EOL> return get_dumpers ( registry ) <EOL> def test_ordered_is_not_None ( self ) : <EOL> def f ( n , reg ) : <EOL> self . assertEqual ( n , <NUM_LIT:1> ) <EOL> self . assertEqual ( reg , registry ) <EOL> return '<STR_LIT>' <EOL> registry = DummyRegistry ( [ ( <NUM_LIT:1> , f ) ] ) <EOL> result = self . _callFUT ( registry ) <EOL> self . assertEqual ( result , [ '<STR_LIT>' ] ) <EOL> def test_ordered_is_None ( self ) : <EOL> def f ( n , reg ) : <EOL> self . assertEqual ( n , <NUM_LIT:1> ) <EOL> self . assertEqual ( reg , registry ) <EOL> return '<STR_LIT>' <EOL> registry = DummyRegistry ( None ) <EOL> registry [ '<STR_LIT>' ] = [ ( <NUM_LIT:1> , f , None , None ) ] <EOL> result = self . _callFUT ( registry ) <EOL> self . assertEqual ( result , [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( registry . ordered , [ ( <NUM_LIT:1> , f ) ] ) <EOL> class Test_DumpAndLoad ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . config = testing . setUp ( ) <EOL> def tearDown ( self ) : <EOL> testing . tearDown ( ) <EOL> def _makeOne ( self ) : <EOL> from . import _DumpAndLoad <EOL> return _DumpAndLoad ( ) <EOL> def test__make_dump_context ( self ) : <EOL> inst = self . _makeOne ( ) <EOL> c = inst . _make_dump_context ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , True , False ) <EOL> self . assertEqual ( c . __class__ . __name__ , '<STR_LIT>' ) <EOL> def test__make_load_context ( self ) : <EOL> inst = self . _makeOne ( ) <EOL> c = inst . _make_load_context ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , True , False ) <EOL> self . assertEqual ( c . __class__ . __name__ , '<STR_LIT>' ) <EOL> def test_dump_no_subresources ( self ) : <EOL> inst = self . _makeOne ( ) <EOL> resource = testing . DummyResource ( ) <EOL> context = DummyResourceDumpContext ( ) <EOL> inst . _make_dump_context = lambda * arg , ** kw : context <EOL> inst . dump ( resource , '<STR_LIT>' , subresources = False ) <EOL> self . assertEqual ( context . dumped , resource ) <EOL> def test_dump_with_subresources_resource_is_not_folder ( self ) : <EOL> inst = self . _makeOne ( ) <EOL> resource = testing . DummyResource ( ) <EOL> resource [ '<STR_LIT:a>' ] = testing . DummyResource ( ) <EOL> context = DummyResourceDumpContext ( ) <EOL> inst . _make_dump_context = lambda * arg , ** kw : context <EOL> inst . dump ( resource , '<STR_LIT>' , subresources = True ) <EOL> self . assertEqual ( context . dumped , resource ) <EOL> def test_dump_with_subresources_resource_is_folder ( self ) : <EOL> from zope . interface import directlyProvides <EOL> from substanced . interfaces import IFolder <EOL> inst = self . _makeOne ( ) <EOL> resource = testing . DummyResource ( ) <EOL> directlyProvides ( resource , IFolder ) <EOL> resource [ '<STR_LIT:a>' ] = testing . DummyResource ( ) <EOL> context = DummyResourceDumpContext ( ) <EOL> inst . _make_dump_context = lambda * arg , ** kw : context <EOL> inst . dump ( resource , '<STR_LIT>' , subresources = True ) <EOL> self . assertEqual ( context . dumped , resource [ '<STR_LIT:a>' ] ) <EOL> def test_dump_callbacks ( self ) : <EOL> from zope . interface import directlyProvides <EOL> from substanced . interfaces import IFolder <EOL> self . config . registry <EOL> inst = self . _makeOne ( ) <EOL> def callback ( rsrc ) : <EOL> self . assertEqual ( rsrc , resource ) <EOL> self . config . registry [ '<STR_LIT>' ] = [ callback ] <EOL> resource = testing . DummyResource ( ) <EOL> directlyProvides ( resource , IFolder ) <EOL> context = DummyResourceDumpContext ( ) <EOL> inst . _make_dump_context = lambda * arg , ** kw : context <EOL> inst . dump ( resource , '<STR_LIT>' , subresources = True ) <EOL> self . assertEqual ( context . dumped , resource ) <EOL> def test_load_no_subresources ( self ) : <EOL> inst = self . _makeOne ( ) <EOL> resource = testing . DummyResource ( ) <EOL> context = DummyResourceDumpContext ( resource ) <EOL> inst . _make_load_context = lambda * arg , ** kw : context <EOL> result = inst . load ( '<STR_LIT>' , subresources = False ) <EOL> self . assertEqual ( result , resource ) <EOL> def test_load_with_subresources ( self ) : <EOL> inst = self . _makeOne ( ) <EOL> inst . ospath = DummyOSPath ( ) <EOL> inst . oslistdir = DummyOSListdir ( [ '<STR_LIT:a>' ] ) <EOL> resource = testing . DummyResource ( ) <EOL> context = DummyResourceDumpContext ( resource ) <EOL> inst . _make_load_context = lambda * arg , ** kw : context <EOL> result = inst . load ( '<STR_LIT>' , subresources = True ) <EOL> self . assertEqual ( result , resource ) <EOL> def test_load_loader_callbacks ( self ) : <EOL> inst = self . _makeOne ( ) <EOL> resource = testing . DummyResource ( ) <EOL> def cb ( rsrc ) : <EOL> self . assertEqual ( rsrc , resource ) <EOL> self . config . registry [ '<STR_LIT>' ] = [ cb ] <EOL> context = DummyResourceDumpContext ( resource ) <EOL> inst . _make_load_context = lambda * arg , ** kw : context <EOL> result = inst . load ( '<STR_LIT>' , subresources = False ) <EOL> self . assertEqual ( result , resource ) <EOL> class Test_FileOperations ( unittest . TestCase ) : <EOL> def _makeOne ( self ) : <EOL> from . import _FileOperations <EOL> return _FileOperations ( ) <EOL> def test__makedirs ( self ) : <EOL> import os , tempfile , shutil <EOL> inst = self . _makeOne ( ) <EOL> try : <EOL> td = tempfile . mkdtemp ( ) <EOL> dn = os . path . join ( td , '<STR_LIT:foo>' ) <EOL> inst . _makedirs ( dn ) <EOL> self . assertTrue ( os . path . isdir ( dn ) ) <EOL> finally : <EOL> shutil . rmtree ( td ) <EOL> def test__open ( self ) : <EOL> import os <EOL> foo = os . path . join ( <EOL> os . path . dirname ( os . path . abspath ( __file__ ) ) , <EOL> '<STR_LIT>' , '<STR_LIT>' <EOL> ) <EOL> inst = self . _makeOne ( ) <EOL> with inst . _open ( foo , '<STR_LIT:rb>' ) as fp : <EOL> self . assertEqual ( fp . read ( ) , b'<STR_LIT>' ) <EOL> def test__exists ( self ) : <EOL> import os <EOL> foo = os . path . join ( <EOL> os . path . dirname ( os . path . abspath ( __file__ ) ) , <EOL> '<STR_LIT>' , '<STR_LIT>' <EOL> ) <EOL> inst = self . _makeOne ( ) <EOL> self . assertTrue ( inst . _exists ( foo ) ) <EOL> def test__get_fullpath_makedirs_true ( self ) : <EOL> import os <EOL> inst = self . _makeOne ( ) <EOL> prefix = os . path . dirname ( os . path . abspath ( __file__ ) ) <EOL> def makedirs ( dn ) : <EOL> self . assertEqual ( os . path . normpath ( dn ) , os . path . normpath ( prefix ) ) <EOL> inst . _exists = lambda * arg : False <EOL> inst . _makedirs = makedirs <EOL> inst . directory = os . path . join ( prefix ) <EOL> result = inst . _get_fullpath ( '<STR_LIT:bar>' , makedirs = True ) <EOL> self . assertEqual ( result , os . path . join ( prefix , '<STR_LIT:bar>' ) ) <EOL> def test__get_fullpath_makedirs_false ( self ) : <EOL> import os <EOL> inst = self . _makeOne ( ) <EOL> prefix = os . path . dirname ( os . path . abspath ( __file__ ) ) <EOL> inst . directory = os . path . join ( prefix ) <EOL> result = inst . _get_fullpath ( '<STR_LIT:bar>' , makedirs = False ) <EOL> self . assertEqual ( result , os . path . join ( prefix , '<STR_LIT:bar>' ) ) <EOL> def test_openfile_w ( self ) : <EOL> inst = self . _makeOne ( ) <EOL> def _get_fullpath ( fn , makedirs ) : <EOL> self . assertEqual ( fn , '<STR_LIT:a>' ) <EOL> self . assertEqual ( makedirs , True ) <EOL> return fn <EOL> inst . _get_fullpath = _get_fullpath <EOL> def _open ( path , mode ) : <EOL> self . assertEqual ( path , '<STR_LIT:a>' ) <EOL> self . assertEqual ( mode , '<STR_LIT:w>' ) <EOL> return '<STR_LIT>' <EOL> inst . _open = _open <EOL> self . assertEqual ( inst . openfile_w ( '<STR_LIT:a>' ) , '<STR_LIT>' ) <EOL> def test_openfile_r ( self ) : <EOL> inst = self . _makeOne ( ) <EOL> def _get_fullpath ( fn , makedirs = False ) : <EOL> self . assertEqual ( fn , '<STR_LIT:a>' ) <EOL> self . assertEqual ( makedirs , False ) <EOL> return fn <EOL> inst . _get_fullpath = _get_fullpath <EOL> def _open ( path , mode ) : <EOL> self . assertEqual ( path , '<STR_LIT:a>' ) <EOL> self . assertEqual ( mode , '<STR_LIT:r>' ) <EOL> return '<STR_LIT>' <EOL> inst . _open = _open <EOL> self . assertEqual ( inst . openfile_r ( '<STR_LIT:a>' ) , '<STR_LIT>' ) <EOL> def test_exists ( self ) : <EOL> inst = self . _makeOne ( ) <EOL> def _get_fullpath ( fn , makedirs = False ) : <EOL> self . assertEqual ( fn , '<STR_LIT:a>' ) <EOL> self . assertEqual ( makedirs , False ) <EOL> return fn <EOL> inst . _get_fullpath = _get_fullpath <EOL> def _exists ( path ) : <EOL> self . assertEqual ( path , '<STR_LIT:a>' ) <EOL> return True <EOL> inst . _exists = _exists <EOL> self . assertEqual ( inst . exists ( '<STR_LIT:a>' ) , True ) <EOL> class Test_YAMLOperations ( unittest . TestCase ) : <EOL> def _makeOne ( self ) : <EOL> from . import _YAMLOperations <EOL> return _YAMLOperations ( ) <EOL> def test_load_yaml ( self ) : <EOL> import contextlib <EOL> import io <EOL> from yaml . loader import Loader <EOL> inst = self . _makeOne ( ) <EOL> stream = io . BytesIO ( b'<STR_LIT>' ) <EOL> @ contextlib . contextmanager <EOL> def openfile ( fn , mode ) : <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> self . assertEqual ( mode , '<STR_LIT:rb>' ) <EOL> yield stream <EOL> inst . openfile_r = openfile <EOL> inst . registry = { '<STR_LIT>' : Loader } <EOL> result = inst . load_yaml ( '<STR_LIT>' ) <EOL> self . assertEqual ( result , '<STR_LIT>' ) <EOL> def test_dump_yaml ( self ) : <EOL> import contextlib <EOL> import io <EOL> from yaml . dumper import Dumper <EOL> inst = self . _makeOne ( ) <EOL> stream = io . BytesIO ( ) <EOL> @ contextlib . contextmanager <EOL> def openfile ( fn , mode ) : <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> self . assertEqual ( mode , '<STR_LIT:wb>' ) <EOL> yield stream <EOL> inst . openfile_w = openfile <EOL> inst . registry = { '<STR_LIT>' : Dumper } <EOL> result = inst . dump_yaml ( '<STR_LIT:abc>' , '<STR_LIT>' ) <EOL> self . assertEqual ( result , None ) <EOL> self . assertEqual ( stream . getvalue ( ) , b'<STR_LIT>' ) <EOL> class Test_ResourceContext ( unittest . TestCase ) : <EOL> def _makeOne ( self ) : <EOL> from . import _ResourceContext <EOL> return _ResourceContext ( ) <EOL> def test_resolve_dotted_name ( self ) : <EOL> import substanced . dump . tests <EOL> inst = self . _makeOne ( ) <EOL> result = inst . resolve_dotted_name ( '<STR_LIT>' ) <EOL> self . assertEqual ( result , substanced . dump . tests ) <EOL> def test_get_dotted_name ( self ) : <EOL> import substanced . dump . tests <EOL> inst = self . _makeOne ( ) <EOL> result = inst . get_dotted_name ( substanced . dump . tests ) <EOL> self . assertEqual ( result , '<STR_LIT>' ) <EOL> class Test_ResourceDumpContext ( unittest . TestCase ) : <EOL> def _makeOne ( self , directory , registry , dumpers , verbose , dry_run ) : <EOL> from . import _ResourceDumpContext <EOL> return _ResourceDumpContext ( <EOL> directory , registry , dumpers , verbose , dry_run <EOL> ) <EOL> def test_dump_resource ( self ) : <EOL> from zope . interface import directlyProvides <EOL> from . . interfaces import IService <EOL> registry = { } <EOL> inst = self . _makeOne ( None , registry , None , None , None ) <EOL> resource = testing . DummyResource ( ) <EOL> resource . __name__ = '<STR_LIT:foo>' <EOL> directlyProvides ( resource , IService ) <EOL> def get_content_type ( rsrc , reg ) : <EOL> self . assertEqual ( rsrc , resource ) <EOL> self . assertEqual ( reg , registry ) <EOL> return '<STR_LIT>' <EOL> def get_oid ( resource ) : <EOL> return '<STR_LIT>' <EOL> def dump_yaml ( data , filename ) : <EOL> self . assertEqual ( data [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( data [ '<STR_LIT:name>' ] , resource . __name__ ) <EOL> self . assertEqual ( data [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> return '<STR_LIT>' <EOL> inst . get_content_type = get_content_type <EOL> inst . get_oid = get_oid <EOL> inst . dump_yaml = dump_yaml <EOL> result = inst . dump_resource ( resource ) <EOL> self . assertEqual ( result , '<STR_LIT>' ) <EOL> def test_dump ( self ) : <EOL> resource = testing . DummyResource ( ) <EOL> dumper = DummyDumperAndLoader ( ) <EOL> inst = self . _makeOne ( None , None , [ dumper ] , None , None ) <EOL> def dump_resource ( rsrc ) : <EOL> self . assertEqual ( rsrc , resource ) <EOL> inst . dump_resource = dump_resource <EOL> inst . dump ( resource ) <EOL> self . assertEqual ( dumper . context , inst ) <EOL> def test_add_callback ( self ) : <EOL> registry = { } <EOL> inst = self . _makeOne ( None , registry , None , None , None ) <EOL> inst . add_callback ( True ) <EOL> self . assertEqual ( registry [ '<STR_LIT>' ] , [ True ] ) <EOL> class Test_ResourceLoadContext ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . config = testing . setUp ( ) <EOL> def tearDown ( self ) : <EOL> testing . tearDown ( ) <EOL> def _makeOne ( self , directory , registry , dumpers , verbose , dry_run ) : <EOL> from . import _ResourceLoadContext <EOL> return _ResourceLoadContext ( <EOL> directory , registry , dumpers , verbose , dry_run <EOL> ) <EOL> def test_load_resource ( self ) : <EOL> import datetime <EOL> from . import RESOURCE_FILENAME <EOL> from . . interfaces import IService <EOL> registry = self . config . registry <EOL> resource = testing . DummyResource ( ) <EOL> content = DummyContentRegistry ( resource ) <EOL> registry . content = content <EOL> now = datetime . datetime . now ( ) <EOL> data = { <EOL> '<STR_LIT:name>' : '<STR_LIT:name>' , <EOL> '<STR_LIT>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : now , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> def load_yaml ( fn ) : <EOL> self . assertEqual ( fn , RESOURCE_FILENAME ) <EOL> return data <EOL> inst = self . _makeOne ( None , registry , None , None , None ) <EOL> inst . load_yaml = load_yaml <EOL> name , result = inst . load_resource ( ) <EOL> self . assertEqual ( name , '<STR_LIT:name>' ) <EOL> self . assertEqual ( result , resource ) <EOL> self . assertEqual ( resource . __name__ , '<STR_LIT:name>' ) <EOL> self . assertEqual ( resource . __oid__ , <NUM_LIT:1> ) <EOL> self . assertEqual ( content . content_type , '<STR_LIT>' ) <EOL> self . assertEqual ( content . oid , <NUM_LIT:1> ) <EOL> def test_load_resource_create_exc ( self ) : <EOL> import datetime <EOL> from . import RESOURCE_FILENAME <EOL> registry = self . config . registry <EOL> resource = testing . DummyResource ( ) <EOL> content = DummyContentRegistry ( resource , raises = ValueError ) <EOL> registry . content = content <EOL> now = datetime . datetime . now ( ) <EOL> data = { <EOL> '<STR_LIT:name>' : '<STR_LIT:name>' , <EOL> '<STR_LIT>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : now , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> def load_yaml ( fn ) : <EOL> self . assertEqual ( fn , RESOURCE_FILENAME ) <EOL> return data <EOL> inst = self . _makeOne ( None , registry , None , None , None ) <EOL> inst . load_yaml = load_yaml <EOL> class DummyLogger ( object ) : <EOL> def __init__ ( self ) : <EOL> self . _errors = [ ] <EOL> def error ( self , * args , ** kw ) : <EOL> self . _errors . append ( ( args , kw ) ) <EOL> inst . logger = logger = DummyLogger ( ) <EOL> self . assertRaises ( ValueError , inst . load_resource ) <EOL> def test_load ( self ) : <EOL> resource = testing . DummyResource ( ) <EOL> def load_resource ( ) : <EOL> return '<STR_LIT:name>' , resource <EOL> loader = DummyDumperAndLoader ( ) <EOL> registry = self . config . registry <EOL> inst = self . _makeOne ( None , registry , [ loader ] , None , None ) <EOL> inst . load_resource = load_resource <EOL> parent = DummyParent ( ) <EOL> result = inst . load ( parent ) <EOL> self . assertEqual ( result , resource ) <EOL> self . assertEqual ( parent . name , '<STR_LIT:name>' ) <EOL> self . assertEqual ( parent . resource , resource ) <EOL> self . assertEqual ( loader . context , inst ) <EOL> def test_add_callback ( self ) : <EOL> registry = { } <EOL> inst = self . _makeOne ( None , registry , None , None , None ) <EOL> inst . add_callback ( True ) <EOL> self . assertEqual ( registry [ '<STR_LIT>' ] , [ True ] ) <EOL> class TestACLDumper ( unittest . TestCase ) : <EOL> def _makeOne ( self , name , registry ) : <EOL> from . import ACLDumper <EOL> return ACLDumper ( name , registry ) <EOL> def test_init_adds_yaml_stuff ( self ) : <EOL> from pyramid . security import ALL_PERMISSIONS <EOL> from . . _compat import u <EOL> yamlthing = DummyYAMLDumperLoader ( ) <EOL> registry = { '<STR_LIT>' : yamlthing , '<STR_LIT>' : yamlthing } <EOL> self . _makeOne ( '<STR_LIT:name>' , registry ) <EOL> self . assertEqual ( len ( yamlthing . constructors ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( yamlthing . representers ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( <EOL> yamlthing . constructors [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ( None , None ) , ALL_PERMISSIONS <EOL> ) <EOL> dumper = testing . DummyResource ( ) <EOL> def represent_scalar ( one , two ) : <EOL> self . assertEqual ( one , u ( '<STR_LIT>' ) ) <EOL> dumper . represent_scalar = represent_scalar <EOL> yamlthing . representers [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ( dumper , None ) <EOL> def test_dump_no_acl ( self ) : <EOL> yamlthing = DummyYAMLDumperLoader ( ) <EOL> registry = { '<STR_LIT>' : yamlthing , '<STR_LIT>' : yamlthing } <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , registry ) <EOL> context = testing . DummyResource ( ) <EOL> resource = testing . DummyResource ( ) <EOL> context . resource = resource <EOL> result = inst . dump ( context ) <EOL> self . assertEqual ( result , None ) <EOL> def test_dump_with_acl ( self ) : <EOL> yamlthing = DummyYAMLDumperLoader ( ) <EOL> registry = { '<STR_LIT>' : yamlthing , '<STR_LIT>' : yamlthing } <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , registry ) <EOL> resource = testing . DummyResource ( ) <EOL> resource . __acl__ = [ ] <EOL> context = DummyResourceDumpContext ( resource ) <EOL> context . resource = resource <EOL> result = inst . dump ( context ) <EOL> self . assertEqual ( result , None ) <EOL> self . assertEqual ( context . dumped , [ ] ) <EOL> def test_load ( self ) : <EOL> yamlthing = DummyYAMLDumperLoader ( ) <EOL> registry = { '<STR_LIT>' : yamlthing , '<STR_LIT>' : yamlthing } <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , registry ) <EOL> resource = testing . DummyResource ( ) <EOL> context = DummyResourceDumpContext ( [ ] ) <EOL> context . resource = resource <EOL> inst . load ( context ) <EOL> self . assertEqual ( resource . __acl__ , [ ] ) <EOL> class TestWorkflowDumper ( unittest . TestCase ) : <EOL> def _makeOne ( self , name , registry ) : <EOL> from . import WorkflowDumper <EOL> return WorkflowDumper ( name , registry ) <EOL> def test_dump ( self ) : <EOL> from . import STATE_ATTR <EOL> def dump_yaml ( v , fn ) : <EOL> self . assertEqual ( v , True ) <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> context = testing . DummyResource ( ) <EOL> context . dump_yaml = dump_yaml <EOL> resource = testing . DummyResource ( ) <EOL> context . resource = resource <EOL> setattr ( resource , STATE_ATTR , True ) <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , None ) <EOL> inst . dump ( context ) <EOL> def test_load ( self ) : <EOL> from . import STATE_ATTR <EOL> def load_yaml ( fn ) : <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> return True <EOL> context = testing . DummyResource ( ) <EOL> context . exists = lambda * arg : True <EOL> context . load_yaml = load_yaml <EOL> resource = testing . DummyResource ( ) <EOL> context . resource = resource <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , None ) <EOL> inst . load ( context ) <EOL> self . assertEqual ( getattr ( resource , STATE_ATTR ) , True ) <EOL> class TestReferencesDumper ( unittest . TestCase ) : <EOL> def _makeOne ( self , name , registry ) : <EOL> from . import ReferencesDumper <EOL> return ReferencesDumper ( name , registry ) <EOL> def test_dump ( self ) : <EOL> context = testing . DummyResource ( ) <EOL> resource = testing . DummyResource ( ) <EOL> context . resource = resource <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , None ) <EOL> objectmap = DummyObjectmap ( [ <NUM_LIT:1> ] , [ <NUM_LIT:2> ] ) <EOL> inst . find_objectmap = lambda * arg : objectmap <EOL> def dump_yaml ( references , fn ) : <EOL> self . assertEqual ( <EOL> references , <EOL> { '<STR_LIT>' : { '<STR_LIT>' : [ <NUM_LIT:1> ] , '<STR_LIT>' : [ <NUM_LIT:2> ] } } <EOL> ) <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> context . dump_yaml = dump_yaml <EOL> inst . dump ( context ) <EOL> def test_load ( self ) : <EOL> context = testing . DummyResource ( ) <EOL> context . exists = lambda * arg : True <EOL> resource = testing . DummyResource ( ) <EOL> context . resource = resource <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , None ) <EOL> inst . get_oid = lambda * arg : <NUM_LIT:0> <EOL> objectmap = DummyObjectmap ( [ <NUM_LIT:1> ] , [ <NUM_LIT:2> ] ) <EOL> inst . find_objectmap = lambda * arg : objectmap <EOL> def load_yaml ( fn ) : <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> return { '<STR_LIT>' : { '<STR_LIT>' : [ <NUM_LIT:1> ] , '<STR_LIT>' : [ <NUM_LIT:2> ] } } <EOL> callbacks = [ ] <EOL> def add_callback ( f ) : <EOL> callbacks . append ( f ) <EOL> context . load_yaml = load_yaml <EOL> context . add_callback = add_callback <EOL> inst . load ( context ) <EOL> self . assertEqual ( len ( callbacks ) , <NUM_LIT:1> ) <EOL> callbacks [ <NUM_LIT:0> ] ( inst ) <EOL> self . assertEqual ( <EOL> objectmap . connected , <EOL> [ ( <NUM_LIT:0> , <NUM_LIT:2> , '<STR_LIT>' ) , ( <NUM_LIT:1> , <NUM_LIT:0> , '<STR_LIT>' ) ] <EOL> ) <EOL> class TestSDIPropertiesDumper ( unittest . TestCase ) : <EOL> def _makeOne ( self , name , registry ) : <EOL> from . import SDIPropertiesDumper <EOL> return SDIPropertiesDumper ( name , registry ) <EOL> def test_dump ( self ) : <EOL> context = testing . DummyResource ( ) <EOL> resource = testing . DummyResource ( ) <EOL> def _p_activate ( ) : <EOL> pass <EOL> context . resource = resource <EOL> resource . _p_activate = _p_activate <EOL> resource . __sdi_hidden__ = True <EOL> def dump_yaml ( v , fn ) : <EOL> self . assertEqual ( v , { '<STR_LIT>' : True } ) <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> context . dump_yaml = dump_yaml <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , None ) <EOL> inst . dump ( context ) <EOL> def test_load ( self ) : <EOL> context = testing . DummyResource ( ) <EOL> resource = testing . DummyResource ( ) <EOL> context . exists = lambda * arg : True <EOL> def _p_activate ( ) : <EOL> pass <EOL> context . resource = resource <EOL> resource . _p_activate = _p_activate <EOL> def load_yaml ( fn ) : <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> return { '<STR_LIT:a>' : <NUM_LIT:1> } <EOL> context . load_yaml = load_yaml <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , None ) <EOL> inst . load ( context ) <EOL> self . assertTrue ( resource . _p_changed ) <EOL> self . assertEqual ( resource . a , <NUM_LIT:1> ) <EOL> class TestDirectlyProvidedInterfacesDumper ( unittest . TestCase ) : <EOL> def _makeOne ( self , name , registry ) : <EOL> from . import DirectlyProvidedInterfacesDumper <EOL> return DirectlyProvidedInterfacesDumper ( name , registry ) <EOL> def test_dump ( self ) : <EOL> from zope . interface import directlyProvides <EOL> context = testing . DummyResource ( ) <EOL> resource = testing . DummyResource ( ) <EOL> context . resource = resource <EOL> def get_dotted_name ( i ) : <EOL> return '<STR_LIT>' <EOL> context . get_dotted_name = get_dotted_name <EOL> directlyProvides ( resource , IDummy ) <EOL> def dump_yaml ( v , fn ) : <EOL> self . assertEqual ( v , [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> context . dump_yaml = dump_yaml <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , None ) <EOL> inst . dump ( context ) <EOL> def test_load ( self ) : <EOL> from zope . interface import directlyProvidedBy <EOL> context = testing . DummyResource ( ) <EOL> resource = testing . DummyResource ( ) <EOL> context . exists = lambda * arg : True <EOL> context . resource = resource <EOL> def resolve_dotted_name ( n ) : <EOL> return IDummy <EOL> context . resolve_dotted_name = resolve_dotted_name <EOL> def load_yaml ( fn ) : <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> return [ '<STR_LIT>' ] <EOL> context . load_yaml = load_yaml <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , None ) <EOL> inst . load ( context ) <EOL> self . assertEqual ( list ( directlyProvidedBy ( resource ) . interfaces ( ) ) , <EOL> [ IDummy ] ) <EOL> class TestFolderOrderDumper ( unittest . TestCase ) : <EOL> def _makeOne ( self , name , registry ) : <EOL> from . import FolderOrderDumper <EOL> return FolderOrderDumper ( name , registry ) <EOL> def test_dump ( self ) : <EOL> from zope . interface import directlyProvides <EOL> from substanced . interfaces import IFolder <EOL> context = testing . DummyResource ( ) <EOL> resource = testing . DummyResource ( ) <EOL> resource . order = [ '<STR_LIT:a>' ] <EOL> context . resource = resource <EOL> def is_ordered ( ) : <EOL> return True <EOL> resource . is_ordered = is_ordered <EOL> directlyProvides ( resource , IFolder ) <EOL> def dump_yaml ( v , fn ) : <EOL> self . assertEqual ( v , [ '<STR_LIT:a>' ] ) <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> context . dump_yaml = dump_yaml <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , None ) <EOL> inst . dump ( context ) <EOL> def test_load ( self ) : <EOL> context = testing . DummyResource ( ) <EOL> resource = testing . DummyResource ( ) <EOL> context . exists = lambda * arg : True <EOL> context . resource = resource <EOL> def load_yaml ( fn ) : <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> return [ '<STR_LIT:a>' ] <EOL> context . load_yaml = load_yaml <EOL> callbacks = [ ] <EOL> def add_callback ( f ) : <EOL> callbacks . append ( f ) <EOL> context . add_callback = add_callback <EOL> registry = { } <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , registry ) <EOL> inst . load ( context ) <EOL> callbacks [ <NUM_LIT:0> ] ( inst ) <EOL> self . assertEqual ( resource . order , [ '<STR_LIT:a>' ] ) <EOL> class TestPropertySheetDumper ( unittest . TestCase ) : <EOL> def _makeOne ( self , name , registry ) : <EOL> from . import PropertySheetDumper <EOL> return PropertySheetDumper ( name , registry ) <EOL> def test_init_adds_yaml_stuff ( self ) : <EOL> import colander <EOL> from . . _compat import u <EOL> yamlthing = DummyYAMLDumperLoader ( ) <EOL> registry = { '<STR_LIT>' : yamlthing , '<STR_LIT>' : yamlthing } <EOL> self . _makeOne ( '<STR_LIT:name>' , registry ) <EOL> self . assertEqual ( len ( yamlthing . constructors ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( yamlthing . representers ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( <EOL> yamlthing . constructors [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ( None , None ) , colander . null <EOL> ) <EOL> dumper = testing . DummyResource ( ) <EOL> def represent_scalar ( one , two ) : <EOL> self . assertEqual ( one , u ( '<STR_LIT>' ) ) <EOL> dumper . represent_scalar = represent_scalar <EOL> yamlthing . representers [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ( dumper , None ) <EOL> def test__get_sheets ( self ) : <EOL> yamlthing = DummyYAMLDumperLoader ( ) <EOL> registry = DummyRegistry ( None ) <EOL> registry . update ( { '<STR_LIT>' : yamlthing , '<STR_LIT>' : yamlthing } ) <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , registry ) <EOL> context = testing . DummyResource ( ) <EOL> resource = testing . DummyResource ( ) <EOL> context . exists = lambda * arg : True <EOL> context . resource = resource <EOL> sheet = DummySheet ( None ) <EOL> def sheetfactory ( rsrc , req ) : <EOL> self . assertEqual ( rsrc , resource ) <EOL> self . assertEqual ( req . __class__ . __name__ , '<STR_LIT>' ) <EOL> return sheet <EOL> content = DummyContentRegistry ( [ ( '<STR_LIT>' , sheetfactory ) ] ) <EOL> registry . content = content <EOL> val = inst . _get_sheets ( context ) <EOL> result = list ( val ) <EOL> self . assertEqual ( <EOL> result , <EOL> [ ( '<STR_LIT>' , sheet ) ] <EOL> ) <EOL> self . assertEqual ( sheet . deleted , '<STR_LIT>' ) <EOL> def test_dump ( self ) : <EOL> yamlthing = DummyYAMLDumperLoader ( ) <EOL> registry = DummyRegistry ( None ) <EOL> registry . update ( { '<STR_LIT>' : yamlthing , '<STR_LIT>' : yamlthing } ) <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , registry ) <EOL> context = testing . DummyResource ( ) <EOL> sheet = DummySheet ( { '<STR_LIT:a>' : <NUM_LIT:1> } ) <EOL> def _get_sheets ( ctx ) : <EOL> self . assertEqual ( ctx , context ) <EOL> return [ ( '<STR_LIT>' , sheet ) ] <EOL> inst . _get_sheets = _get_sheets <EOL> def dump_yaml ( cstruct , fn ) : <EOL> self . assertEqual ( cstruct , { '<STR_LIT:a>' : <NUM_LIT:1> } ) <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> context . dump_yaml = dump_yaml <EOL> inst . dump ( context ) <EOL> def test_load ( self ) : <EOL> yamlthing = DummyYAMLDumperLoader ( ) <EOL> registry = DummyRegistry ( None ) <EOL> registry . update ( { '<STR_LIT>' : yamlthing , '<STR_LIT>' : yamlthing } ) <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , registry ) <EOL> context = testing . DummyResource ( ) <EOL> def add_callback ( cb ) : <EOL> context . cb = cb <EOL> context . exists = lambda * arg : True <EOL> context . add_callback = add_callback <EOL> sheet = DummySheet ( None ) <EOL> def _get_sheets ( ctx ) : <EOL> self . assertEqual ( ctx , context ) <EOL> return [ ( '<STR_LIT>' , sheet ) ] <EOL> inst . _get_sheets = _get_sheets <EOL> def load_yaml ( fn ) : <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> return { '<STR_LIT:a>' : <NUM_LIT:1> } <EOL> context . load_yaml = load_yaml <EOL> inst . load ( context ) <EOL> context . cb ( None ) <EOL> self . assertEqual ( sheet . appstruct , { '<STR_LIT:a>' : <NUM_LIT:1> } ) <EOL> class TestAdhocAttrDumper ( unittest . TestCase ) : <EOL> def _makeOne ( self , name , registry ) : <EOL> from . import AdhocAttrDumper <EOL> return AdhocAttrDumper ( name , registry ) <EOL> def test_dump ( self ) : <EOL> def dump_yaml ( v , fn ) : <EOL> self . assertEqual ( v , { '<STR_LIT:a>' : <NUM_LIT:1> } ) <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> context = testing . DummyResource ( ) <EOL> context . dump_yaml = dump_yaml <EOL> resource = testing . DummyResource ( ) <EOL> context . resource = resource <EOL> def dump ( ) : <EOL> return { '<STR_LIT:a>' : <NUM_LIT:1> } <EOL> resource . __dump__ = dump <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , None ) <EOL> inst . dump ( context ) <EOL> def test_load ( self ) : <EOL> def load_yaml ( fn ) : <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> return { '<STR_LIT:a>' : <NUM_LIT:1> } <EOL> context = testing . DummyResource ( ) <EOL> context . exists = lambda * arg : True <EOL> context . load_yaml = load_yaml <EOL> resource = testing . DummyResource ( ) <EOL> context . resource = resource <EOL> def load ( values ) : <EOL> self . assertEqual ( values , { '<STR_LIT:a>' : <NUM_LIT:1> } ) <EOL> resource . __load__ = load <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , None ) <EOL> inst . load ( context ) <EOL> def test_load_without_underunder_load ( self ) : <EOL> def load_yaml ( fn ) : <EOL> self . assertEqual ( fn , '<STR_LIT>' ) <EOL> return { '<STR_LIT:a>' : <NUM_LIT:1> } <EOL> context = testing . DummyResource ( ) <EOL> context . exists = lambda * arg : True <EOL> context . load_yaml = load_yaml <EOL> resource = testing . DummyResource ( ) <EOL> context . resource = resource <EOL> inst = self . _makeOne ( '<STR_LIT:name>' , None ) <EOL> inst . load ( context ) <EOL> self . assertEqual ( resource . a , <NUM_LIT:1> ) <EOL> class Test_add_dumper ( unittest . TestCase ) : <EOL> def _callFUT ( <EOL> self , config , dumper_name , dumper_factory , before = None , after = None <EOL> ) : <EOL> from . import add_dumper <EOL> return add_dumper ( <EOL> config , dumper_name , dumper_factory , before = before , after = after <EOL> ) <EOL> def test_it ( self ) : <EOL> config = DummyConfigurator ( ) <EOL> registry = { } <EOL> config . registry = registry <EOL> self . _callFUT ( config , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertEqual ( config . discriminator , ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> config . callable ( ) <EOL> self . assertEqual ( <EOL> registry [ '<STR_LIT>' ] , <EOL> [ [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ] <EOL> ) <EOL> from zope . interface import Interface <EOL> class IDummy ( Interface ) : <EOL> pass <EOL> class DummyConfigurator ( object ) : <EOL> def action ( self , discriminator , callable = None ) : <EOL> self . discriminator = discriminator <EOL> self . callable = callable <EOL> class DummySheet ( object ) : <EOL> def __init__ ( self , result ) : <EOL> self . result = result <EOL> def get_schema ( self ) : <EOL> return self <EOL> def set_schema ( self , schema ) : <EOL> self . _schema = schema <EOL> schema = property ( get_schema , set_schema ) <EOL> def __contains__ ( self , val ) : <EOL> return True <EOL> def __delitem__ ( self , val ) : <EOL> self . deleted = val <EOL> def bind ( self , request = None , context = None , loading = None ) : <EOL> self . request = request <EOL> self . context = context <EOL> self . loading = loading <EOL> def get ( self ) : <EOL> return self . result <EOL> def set ( self , appstruct ) : <EOL> self . appstruct = appstruct <EOL> def serialize ( self , appstruct ) : <EOL> return appstruct <EOL> def deserialize ( self , cstruct ) : <EOL> return cstruct <EOL> class DummyObjectmap ( object ) : <EOL> def __init__ ( self , sourceids , targetids ) : <EOL> self . _sourceids = sourceids <EOL> self . _targetids = targetids <EOL> self . connected = [ ] <EOL> def has_references ( self , resource ) : <EOL> return True <EOL> def get_reftypes ( self ) : <EOL> return [ '<STR_LIT>' ] <EOL>", "answer": "def sourceids ( self , resource , reftype ) :"}, {"prompt": "<s> import sys <EOL> from nose2 . tests . _common import FunctionalTestCase , support_file <EOL> import nose2 . plugins . loader . eggdiscovery <EOL> try : <EOL> import pkg_resources <EOL> except ImportError : <EOL> pkg_resources = None <EOL> else : <EOL> class EggDiscoveryFunctionalTest ( FunctionalTestCase ) : <EOL> def setUp ( self ) : <EOL> for m in [ m for m in sys . modules if m . startswith ( '<STR_LIT>' ) ] : <EOL> del sys . modules [ m ] <EOL> self . egg_path = support_file ( '<STR_LIT>' ) <EOL> sys . path . append ( self . egg_path ) <EOL> def tearDown ( self ) : <EOL> if self . egg_path in sys . path : <EOL> sys . path . remove ( self . egg_path ) <EOL> for m in [ m for m in sys . modules if m . startswith ( '<STR_LIT>' ) ] : <EOL> del sys . modules [ m ] <EOL>", "answer": "def test_non_egg_discoverer_does_not_fail_when_looking_in_egg ( self ) :"}, {"prompt": "<s> from expr import Expr <EOL> from stmt import Stmt <EOL> class Struct ( Expr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , args , type = None , source_info = None ) : <EOL> self . args = tuple ( args ) <EOL> self . type = type <EOL> self . source_info = source_info <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( \"<STR_LIT:U+002CU+0020>\" . join ( str ( arg ) for arg in self . args ) , self . type ) <EOL> def children ( self ) : <EOL> return self . args <EOL> def __hash__ ( self ) : <EOL> self . args = tuple ( self . args ) <EOL> return hash ( self . args ) <EOL> class Alloc ( Expr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , elt_type , count , type = None , source_info = None ) : <EOL> self . elt_type = elt_type <EOL> self . count = count <EOL> self . type = type <EOL> self . source_info = source_info <EOL> def __str__ ( self ) : <EOL>", "answer": "return \"<STR_LIT>\" % ( self . elt_type , self . count , self . type )"}, {"prompt": "<s> import sys , os <EOL> extensions = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' , '<STR_LIT>' ,"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import gzip <EOL> import os <EOL>", "answer": "import sys"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> import unittest <EOL> import tempfile <EOL> import os <EOL> import io <EOL> import six <EOL> import shutil <EOL> import multiprocessing <EOL> import numpy as np <EOL> import lockfile <EOL> from time import sleep <EOL> from datetime import datetime <EOL> from six . moves import range <EOL> from pyexperiment import state <EOL> from pyexperiment . State import StateHandler <EOL> from pyexperiment . utils . stdout_redirector import stdout_redirector <EOL> class StateTester ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . list_val = [ <NUM_LIT:1> , <NUM_LIT:2> , '<STR_LIT:a>' , <NUM_LIT> ] <EOL> self . dict_val = { '<STR_LIT:a>' : <NUM_LIT:1> , <NUM_LIT:1> : <NUM_LIT> } <EOL> self . int_val = <NUM_LIT> <EOL> def tearDown ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> state . reset_instance ( ) <EOL> def _setup_basic_state ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> state [ '<STR_LIT:list>' ] = self . list_val <EOL> state [ '<STR_LIT>' ] = self . dict_val <EOL> state [ '<STR_LIT>' ] = self . int_val <EOL> class TestBasicState ( StateTester ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def test_set_get_first_level ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> state [ '<STR_LIT:a>' ] = <NUM_LIT> <EOL> self . assertEqual ( state [ '<STR_LIT:a>' ] , <NUM_LIT> ) <EOL> def test_set_get_higher_levels ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> state [ '<STR_LIT>' ] = <NUM_LIT> <EOL> state [ '<STR_LIT>' ] = <NUM_LIT> <EOL> self . assertEqual ( state [ '<STR_LIT>' ] , <NUM_LIT> ) <EOL> self . assertEqual ( state [ '<STR_LIT>' ] , <NUM_LIT> ) <EOL> def test_get_section ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> state [ '<STR_LIT>' ] = <NUM_LIT:12> <EOL> state [ '<STR_LIT>' ] = <NUM_LIT> <EOL> state [ '<STR_LIT:c>' ] = <NUM_LIT> <EOL> self . assertIn ( '<STR_LIT:a>' , state ) <EOL> section_a = state [ '<STR_LIT:a>' ] <EOL> self . assertIn ( '<STR_LIT:a>' , section_a ) <EOL> self . assertIn ( '<STR_LIT:b>' , section_a ) <EOL> self . assertNotIn ( '<STR_LIT:c>' , section_a ) <EOL> self . assertEqual ( section_a [ '<STR_LIT:a>' ] , <NUM_LIT:12> ) <EOL> self . assertEqual ( section_a [ '<STR_LIT:b>' ] , <NUM_LIT> ) <EOL> def test_get_inexistent ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . assertRaises ( KeyError , state . __getitem__ , '<STR_LIT:a>' ) <EOL> def test_show ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> state [ '<STR_LIT>' ] = <NUM_LIT:12> <EOL> state [ '<STR_LIT>' ] = <NUM_LIT> <EOL> buf = io . StringIO ( ) <EOL> with stdout_redirector ( buf ) : <EOL> state . show ( ) <EOL> self . assertNotEqual ( len ( buf . getvalue ( ) ) , <NUM_LIT:0> ) <EOL> self . assertRegexpMatches ( buf . getvalue ( ) , r\"<STR_LIT>\" ) <EOL> self . assertRegexpMatches ( buf . getvalue ( ) , r\"<STR_LIT>\" ) <EOL> self . assertRegexpMatches ( buf . getvalue ( ) , r\"<STR_LIT:b>\" ) <EOL> self . assertRegexpMatches ( buf . getvalue ( ) , r\"<STR_LIT>\" ) <EOL> self . assertRegexpMatches ( buf . getvalue ( ) , r\"<STR_LIT>\" ) <EOL> self . assertRegexpMatches ( buf . getvalue ( ) , r\"<STR_LIT>\" ) <EOL> def test_in_lazy ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _setup_basic_state ( ) <EOL> with tempfile . NamedTemporaryFile ( ) as temp : <EOL> state . save ( temp . name ) <EOL> state . reset_instance ( ) <EOL> self . assertNotIn ( '<STR_LIT:list>' , state ) <EOL> state . load ( temp . name , lazy = True ) <EOL> self . assertIn ( '<STR_LIT:list>' , state ) <EOL> def test_setting_increases_length ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . assertEqual ( len ( state ) , <NUM_LIT:0> ) <EOL> state [ '<STR_LIT:a>' ] = <NUM_LIT:12> <EOL> self . assertEqual ( len ( state ) , <NUM_LIT:1> ) <EOL> state [ '<STR_LIT>' ] = <NUM_LIT> <EOL> self . assertEqual ( len ( state ) , <NUM_LIT:2> ) <EOL> def test_delete_from_state ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> state [ '<STR_LIT:list>' ] = [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] <EOL> self . assertIn ( '<STR_LIT:list>' , state ) <EOL> del state [ '<STR_LIT:list>' ] <EOL> self . assertNotIn ( '<STR_LIT:list>' , state ) <EOL> def test_delete_reduces_length ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _setup_basic_state ( ) <EOL> no_items = len ( state ) <EOL> del state [ '<STR_LIT:list>' ] <EOL> self . assertEqual ( len ( state ) , no_items - <NUM_LIT:1> ) <EOL> def test_delete_removes_key ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _setup_basic_state ( ) <EOL> del state [ '<STR_LIT:list>' ] <EOL> self . assertNotIn ( '<STR_LIT:list>' , state . keys ( ) ) <EOL> def test_show_lazy ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> state [ '<STR_LIT>' ] = <NUM_LIT:12> <EOL> buf = io . StringIO ( ) <EOL> with tempfile . NamedTemporaryFile ( ) as temp : <EOL> state . save ( temp . name ) <EOL> state [ '<STR_LIT>' ] = <NUM_LIT> <EOL> state . load ( temp . name , lazy = True ) <EOL> with stdout_redirector ( buf ) : <EOL> state . show ( ) <EOL>", "answer": "self . assertNotEqual ( len ( buf . getvalue ( ) ) , <NUM_LIT:0> )"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Weapon ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = <NUM_LIT:10>"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> from django . views . generic import list as list_views <EOL> from services . configuration . models import segments as segment_models <EOL> from services . communications import models as comms_models <EOL> class PassiveMessages ( list_views . ListView ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> model = comms_models . PassiveMessage <EOL> context_object_name = '<STR_LIT>' <EOL> template_name = '<STR_LIT>' <EOL> paginate_by = <NUM_LIT:10> <EOL> def get_queryset ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> user_groundstations = segment_models . GroundStation . objects . filter ( <EOL> user = self . request . user <EOL> ) . all ( ) <EOL>", "answer": "return self . model . objects . filter ("}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> revision = '<STR_LIT>' <EOL> down_revision = '<STR_LIT>' <EOL> from alembic import op <EOL> def upgrade ( ) : <EOL> op . drop_constraint ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> op . create_foreign_key ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] , [ '<STR_LIT:id>' ] , ondelete = '<STR_LIT>' ) <EOL> op . drop_constraint ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> op . create_foreign_key ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] , [ '<STR_LIT:id>' ] , ondelete = '<STR_LIT>' ) <EOL>", "answer": "op . drop_constraint ( '<STR_LIT>' , '<STR_LIT>' )"}, {"prompt": "<s> import pygtk <EOL> pygtk . require ( '<STR_LIT>' ) <EOL> import gtk <EOL> class ServerGUI ( gtk . Window ) : <EOL> def __init__ ( self ) : <EOL> super ( ServerGUI , self ) . __init__ ( ) <EOL> self . set_title ( '<STR_LIT>' ) <EOL> self . set_size_request ( <NUM_LIT> , <NUM_LIT> ) <EOL> self . set_position ( gtk . WIN_POS_CENTER ) <EOL> '''<STR_LIT>''' <EOL> vbox = gtk . VBox ( False , <NUM_LIT:8> ) <EOL> sw = gtk . ScrolledWindow ( ) <EOL> vbox . pack_start ( sw , True , True , <NUM_LIT:0> ) <EOL> store = self . createModel ( ) <EOL> self . show_all ( ) <EOL> def createModel ( self ) : <EOL> store = gtk . ListStore ( str , str ) <EOL> store . append ( [ '<STR_LIT:test>' , '<STR_LIT>' ] ) <EOL>", "answer": "return store "}, {"prompt": "<s> from diffscuss . mailbox import check , set_default_inbox , make_inbox , init_mailbox , post , bounce , done <EOL> mod_map = { '<STR_LIT>' : check , <EOL> '<STR_LIT>' : set_default_inbox , <EOL> '<STR_LIT>' : make_inbox , <EOL> '<STR_LIT>' : init_mailbox , <EOL> '<STR_LIT>' : post , <EOL>", "answer": "'<STR_LIT>' : bounce ,"}, {"prompt": "<s> import numpy as np <EOL> import numpy . random as npr <EOL> import kayak <EOL> from . import * <EOL> from nose . tools import assert_less <EOL> def test_tanh_values ( ) : <EOL> npr . seed ( <NUM_LIT:1> ) <EOL> for ii in xrange ( NUM_TRIALS ) : <EOL> np_X = npr . randn ( <NUM_LIT:6> , <NUM_LIT:5> ) <EOL> X = kayak . Parameter ( np_X ) <EOL> Y = kayak . TanH ( X ) <EOL> assert np . all ( close_float ( np . tanh ( np_X ) , Y . value ) ) <EOL> def test_tanh_grad ( ) : <EOL> npr . seed ( <NUM_LIT:2> ) <EOL>", "answer": "for ii in xrange ( NUM_TRIALS ) :"}, {"prompt": "<s> import pytest <EOL> import pip . wheel <EOL> import pip . pep425tags <EOL> from pkg_resources import parse_version , Distribution <EOL> from pip . req import InstallRequirement <EOL> from pip . index import ( <EOL> InstallationCandidate , PackageFinder , Link , FormatControl , <EOL> fmt_ctl_formats ) <EOL> from pip . exceptions import BestVersionAlreadyInstalled , DistributionNotFound <EOL> from pip . download import PipSession <EOL> from mock import Mock , patch <EOL> def test_no_mpkg ( data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> finder = PackageFinder ( [ data . find_links ] , [ ] , session = PipSession ( ) ) <EOL> req = InstallRequirement . from_line ( \"<STR_LIT>\" ) <EOL> found = finder . find_requirement ( req , False ) <EOL> assert found . url . endswith ( \"<STR_LIT>\" ) , found <EOL> def test_no_partial_name_match ( data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> finder = PackageFinder ( [ data . find_links ] , [ ] , session = PipSession ( ) ) <EOL> req = InstallRequirement . from_line ( \"<STR_LIT>\" ) <EOL> found = finder . find_requirement ( req , False ) <EOL> assert found . url . endswith ( \"<STR_LIT>\" ) , found <EOL> def test_tilde ( data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> session = PipSession ( ) <EOL> with patch ( '<STR_LIT>' , return_value = True ) : <EOL> finder = PackageFinder ( [ '<STR_LIT>' ] , [ ] , session = session ) <EOL> req = InstallRequirement . from_line ( \"<STR_LIT>\" ) <EOL> with pytest . raises ( DistributionNotFound ) : <EOL> finder . find_requirement ( req , False ) <EOL> def test_duplicates_sort_ok ( data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> finder = PackageFinder ( <EOL> [ data . find_links , data . find_links2 ] , <EOL> [ ] , <EOL> session = PipSession ( ) , <EOL> ) <EOL> req = InstallRequirement . from_line ( \"<STR_LIT>\" ) <EOL> found = finder . find_requirement ( req , False ) <EOL> assert found . url . endswith ( \"<STR_LIT>\" ) , found <EOL> def test_finder_detects_latest_find_links ( data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> req = InstallRequirement . from_line ( '<STR_LIT>' , None ) <EOL> finder = PackageFinder ( [ data . find_links ] , [ ] , session = PipSession ( ) ) <EOL> link = finder . find_requirement ( req , False ) <EOL> assert link . url . endswith ( \"<STR_LIT>\" ) <EOL> def test_incorrect_case_file_index ( data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> req = InstallRequirement . from_line ( '<STR_LIT>' , None ) <EOL> finder = PackageFinder ( [ ] , [ data . find_links3 ] , session = PipSession ( ) ) <EOL> link = finder . find_requirement ( req , False ) <EOL> assert link . url . endswith ( \"<STR_LIT>\" ) <EOL> @ pytest . mark . network <EOL> def test_finder_detects_latest_already_satisfied_find_links ( data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> req = InstallRequirement . from_line ( '<STR_LIT>' , None ) <EOL> latest_version = \"<STR_LIT>\" <EOL> satisfied_by = Mock ( <EOL> location = \"<STR_LIT>\" , <EOL> parsed_version = parse_version ( latest_version ) , <EOL> version = latest_version <EOL> ) <EOL> req . satisfied_by = satisfied_by <EOL> finder = PackageFinder ( [ data . find_links ] , [ ] , session = PipSession ( ) ) <EOL> with pytest . raises ( BestVersionAlreadyInstalled ) : <EOL>", "answer": "finder . find_requirement ( req , True )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . . import fixer_base <EOL> from . . fixer_util import Call , Name , parenthesize <EOL> class FixRepr ( fixer_base . BaseFix ) : <EOL> BM_compatible = True <EOL> PATTERN = \"\"\"<STR_LIT>\"\"\" <EOL> def transform ( self , node , results ) : <EOL> expr = results [ \"<STR_LIT>\" ] . clone ( ) <EOL> if expr . type == self . syms . testlist1 : <EOL>", "answer": "expr = parenthesize ( expr )"}, {"prompt": "<s> from behave import given , when , then <EOL> from django . core import management <EOL> from connect . accounts . factories import ( <EOL> InvitedPendingFactory , ModeratorFactory , RequestedPendingFactory , UserFactory <EOL> ) <EOL> DEFAULT_WAIT = <NUM_LIT:5> <EOL> @ when ( '<STR_LIT>' ) <EOL> def impl ( context ) : <EOL> context . browser . find_by_css ( '<STR_LIT>' ) . click ( ) <EOL> @ then ( '<STR_LIT>' ) <EOL>", "answer": "def impl ( context ) :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> __version__ = version = '<STR_LIT>' <EOL> from . core import httpretty , httprettified , EmptyRequestHeaders <EOL> from . errors import HTTPrettyError , UnmockedError <EOL> from . core import URIInfo <EOL> HTTPretty = httpretty <EOL> activate = httprettified <EOL> enable = httpretty . enable <EOL> register_uri = httpretty . register_uri <EOL> disable = httpretty . disable <EOL> is_enabled = httpretty . is_enabled <EOL> reset = httpretty . reset <EOL> Response = httpretty . Response <EOL> GET = httpretty . GET <EOL> PUT = httpretty . PUT <EOL> POST = httpretty . POST <EOL> DELETE = httpretty . DELETE <EOL> HEAD = httpretty . HEAD <EOL>", "answer": "PATCH = httpretty . PATCH"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import unittest <EOL> from weakref import proxy <EOL> from functools import partial <EOL> class BaseClass ( object ) : <EOL> uid = <NUM_LIT:0> <EOL> def __init__ ( self , ** kwargs ) : <EOL> super ( BaseClass , self ) . __init__ ( ) <EOL> self . proxy_ref = proxy ( self ) <EOL> self . children = [ ] <EOL> self . parent = None <EOL> self . binded_func = { } <EOL> self . id = None <EOL> self . ids = { } <EOL> self . cls = [ ] <EOL> self . ids = { } <EOL> self . uid = BaseClass . uid <EOL> BaseClass . uid += <NUM_LIT:1> <EOL> def add_widget ( self , widget ) : <EOL> self . children . append ( widget ) <EOL> widget . parent = self <EOL> def create_property ( self , name , value = None ) : <EOL> pass <EOL> def is_event_type ( self , key ) : <EOL> return key . startswith ( '<STR_LIT>' ) <EOL> def fbind ( self , name , func , * largs ) : <EOL> self . binded_func [ name ] = partial ( func , * largs ) <EOL> return True <EOL> class TestClass ( BaseClass ) : <EOL> obj = None <EOL> class TestClass2 ( BaseClass ) : <EOL> obj = None <EOL> class TestClass3 ( BaseClass ) : <EOL> obj = None <EOL> class LangTestCase ( unittest . TestCase ) : <EOL> def import_builder ( self ) : <EOL> from kivy . factory import Factory <EOL> from kivy . lang import BuilderBase <EOL> Builder = BuilderBase ( ) <EOL> Factory . register ( '<STR_LIT>' , cls = TestClass ) <EOL> Factory . register ( '<STR_LIT>' , cls = TestClass2 ) <EOL> Factory . register ( '<STR_LIT>' , cls = TestClass3 ) <EOL> return Builder <EOL> def test_loading_failed_1 ( self ) : <EOL> Builder = self . import_builder ( ) <EOL> from kivy . lang import ParserException <EOL> try : <EOL> Builder . load_string ( '''<STR_LIT>''' ) <EOL> self . fail ( '<STR_LIT>' ) <EOL> except ParserException : <EOL> pass <EOL> def test_parser_numeric_1 ( self ) : <EOL> Builder = self . import_builder ( ) <EOL> Builder . load_string ( '<STR_LIT>' ) <EOL> wid = TestClass ( ) <EOL> Builder . apply ( wid ) <EOL> self . assertEqual ( wid . obj , ( <NUM_LIT:0.5> , <NUM_LIT:0.5> , <NUM_LIT:0.5> ) ) <EOL> def test_parser_numeric_2 ( self ) : <EOL> Builder = self . import_builder ( ) <EOL> Builder . load_string ( '<STR_LIT>' ) <EOL> wid = TestClass ( ) <EOL> Builder . apply ( wid ) <EOL> self . assertEqual ( wid . obj , ( <NUM_LIT:0.5> , <NUM_LIT:0.5> , <NUM_LIT:0.5> ) ) <EOL> def test_references ( self ) : <EOL> Builder = self . import_builder ( ) <EOL> Builder . load_string ( '''<STR_LIT>''' ) <EOL> wid = TestClass ( ) <EOL> Builder . apply ( wid ) <EOL> self . assertTrue ( hasattr ( wid , '<STR_LIT>' ) ) <EOL> self . assertTrue ( getattr ( wid , '<STR_LIT>' ) is not None ) <EOL> def test_references_with_template ( self ) : <EOL> Builder = self . import_builder ( ) <EOL> Builder . load_string ( '''<STR_LIT>''' ) <EOL> wid = TestClass ( ) <EOL> Builder . apply ( wid ) <EOL> self . assertTrue ( hasattr ( wid , '<STR_LIT>' ) ) <EOL> self . assertTrue ( getattr ( wid , '<STR_LIT>' ) is not None ) <EOL> def test_references_with_template_case_2 ( self ) : <EOL> Builder = self . import_builder ( ) <EOL> Builder . load_string ( '''<STR_LIT>''' ) <EOL> wid = TestClass ( ) <EOL> Builder . apply ( wid ) <EOL> self . assertTrue ( hasattr ( wid , '<STR_LIT>' ) ) <EOL> self . assertTrue ( getattr ( wid , '<STR_LIT>' ) is not None ) <EOL>", "answer": "def test_references_with_template_case_3 ( self ) :"}, {"prompt": "<s> import os <EOL> import sys <EOL> import re <EOL> import logging <EOL> from optparse import OptionParser <EOL> from ksscommand import KssCommand , KssCommandException , KssCommandOptException <EOL> import __cmd__ <EOL> try : <EOL> import karesansui <EOL> from karesansui import __version__ <EOL> from karesansui . lib . utils import load_locale , execute_command <EOL> from karesansui . lib . const import ISCSI_CMD , ISCSI_CMD_OPTION_MODE , ISCSI_CMD_OPTION_MODE_NODE , ISCSI_CMD_OPTION_OPERATOR , ISCSI_CMD_OPTION_OPERATOR_DELETE , ISCSI_CMD_OPTION_TARGETNAME , ISCSI_CMD_OPTION_PORTAL <EOL> except ImportError , e : <EOL> print >> sys . stderr , \"<STR_LIT>\" % e <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> _ = load_locale ( ) <EOL> usage = '<STR_LIT>' <EOL> def getopts ( ) : <EOL> optp = OptionParser ( usage = usage , version = __version__ ) <EOL> optp . add_option ( '<STR_LIT>' , '<STR_LIT>' , dest = '<STR_LIT:host>' , help = _ ( '<STR_LIT>' ) , default = None ) <EOL> optp . add_option ( '<STR_LIT>' , '<STR_LIT>' , dest = '<STR_LIT>' , help = _ ( '<STR_LIT>' ) , default = None ) <EOL> return optp . parse_args ( ) <EOL> def chkopts ( opts ) : <EOL> reg = re . compile ( \"<STR_LIT>\" ) <EOL> if opts . iqn : <EOL> if reg . search ( opts . iqn ) : <EOL> raise KssCommandOptException ( '<STR_LIT>' % ( '<STR_LIT>' , opts . iqn ) ) <EOL> else : <EOL> raise KssCommandOptException ( '<STR_LIT>' % '<STR_LIT>' ) <EOL>", "answer": "if opts . host :"}, {"prompt": "<s> from os import path <EOL> from ConfigParser import ConfigParser <EOL> from nose . plugins import collect <EOL> def _extract_test_names ( tests ) : <EOL> return [ '<STR_LIT>' . format ( test . test . __module__ , <EOL> type ( test . test ) . __name__ , <EOL> test . test . _testMethodName ) for test in tests ] <EOL> def _build_suites ( tests , number_of_suites ) : <EOL> number_of_tests = len ( tests ) <EOL> number_of_suite_tests , remainder = divmod ( number_of_tests , <EOL> number_of_suites ) <EOL> offset = <NUM_LIT:0> <EOL> suites = [ ] <EOL> for i in range ( number_of_suites ) : <EOL> start = offset + i * number_of_suite_tests <EOL> end = offset + i * number_of_suite_tests + number_of_suite_tests <EOL> if remainder : <EOL>", "answer": "offset += <NUM_LIT:1>"}, {"prompt": "<s> import os <EOL> import inspect <EOL> import sys <EOL> directory = os . path . dirname ( inspect . getfile ( inspect . currentframe ( ) ) ) <EOL> sys . path . append ( directory ) <EOL> import rendering <EOL> import async <EOL> import window <EOL> import vim <EOL> import time <EOL> import string <EOL> import signal <EOL> from utils import * <EOL> class Do : <EOL> def __init__ ( self ) : <EOL> self . __process_pool = async . ProcessPool ( ) <EOL> self . __processes = ProcessCollection ( ) <EOL> self . __process_renderer = rendering . ProcessRenderer ( ) <EOL> self . __au_assigned = False <EOL> self . __last_check = time . time ( ) * <NUM_LIT:1000> <EOL> def __del__ ( self ) : <EOL> self . stop ( ) <EOL> def execute ( self , cmd , quiet = False ) : <EOL> pid = self . __process_pool . execute ( cmd ) <EOL> log ( \"<STR_LIT>\" % ( pid , cmd ) ) <EOL> process = self . __processes . add ( cmd , pid ) <EOL> self . __process_renderer . add_process ( process , quiet ) <EOL> self . __assign_autocommands ( ) <EOL> self . check ( ) <EOL> def reload_options ( self ) : <EOL> Options . reload ( ) <EOL> def toggle_command_window ( self ) : <EOL> self . __process_renderer . toggle_command_window ( ) <EOL> def mark_command_window_as_closed ( self ) : <EOL> self . __process_renderer . destroy_command_window ( ) <EOL> def mark_process_window_as_closed ( self ) : <EOL> try : <EOL> self . __process_renderer . destroy_process_window ( ) <EOL> except Exception , e : <EOL> log ( \"<STR_LIT>\" % str ( e ) ) <EOL> def show_process_from_command_window ( self ) : <EOL> lineno = vim . current . window . cursor [ <NUM_LIT:0> ] <EOL> pid = self . __process_renderer . get_pid_by_line_number ( lineno ) <EOL> process = self . __processes . get_by_pid ( pid ) <EOL> if process is not None : <EOL> self . __process_renderer . show_process ( process ) <EOL> def check ( self ) : <EOL> log ( \"<STR_LIT>\" ) <EOL> if ( <NUM_LIT:1000> * time . time ( ) ) - self . __last_check > Options . check_interval ( ) : <EOL> self . check_now ( ) <EOL> self . __last_check = time . time ( ) * <NUM_LIT:1000> <EOL> def check_now ( self ) : <EOL> log ( \"<STR_LIT>\" ) <EOL> outputs = self . __process_pool . get_outputs ( ) <EOL> changed_processes = set ( ) <EOL> for output in outputs : <EOL> if output [ <NUM_LIT:1> ] is not None : <EOL> log ( \"<STR_LIT>\" <EOL> % ( output [ <NUM_LIT:0> ] , output [ <NUM_LIT:1> ] ) ) <EOL> process = self . __processes . update ( * output ) <EOL> changed_processes . add ( process ) <EOL> for process in changed_processes : <EOL> self . __process_renderer . update_process ( process ) <EOL> self . __process_pool . cleanup ( ) <EOL> if self . __processes . all_finished ( ) : <EOL> log ( \"<STR_LIT>\" ) <EOL> self . __unassign_autocommands ( ) <EOL> else : <EOL> s = '<STR_LIT>' % Options . refresh_key ( ) <EOL> log ( s ) <EOL> vim . eval ( s ) <EOL> def enable_logger ( self , path ) : <EOL> Log . set_logger ( FileLogger ( Logger . DEBUG , path ) ) <EOL> def stop ( self ) : <EOL> self . __processes . kill_all ( ) <EOL> self . __process_pool . stop ( ) <EOL> def __assign_autocommands ( self ) : <EOL> if self . __au_assigned : <EOL> return <EOL> log ( \"<STR_LIT>\" ) <EOL> vim . command ( '<STR_LIT>' ) <EOL> self . __au_assigned = True <EOL> def __unassign_autocommands ( self ) : <EOL> log ( \"<STR_LIT>\" ) <EOL> vim . command ( '<STR_LIT>' ) <EOL> self . __au_assigned = False <EOL> class ProcessCollection : <EOL> def __init__ ( self ) : <EOL> self . __processes = { } <EOL> def add ( self , command , pid ) : <EOL> process = Process ( command , pid ) <EOL> self . __processes [ pid ] = process <EOL> return process <EOL> def get_by_pid ( self , pid ) : <EOL> return next ( ( p for p in self . __processes . values ( ) if p . get_pid ( ) == pid ) , None ) <EOL> def update ( self , pid , exit_status , stdout , stderr ) : <EOL> process = self . __processes [ pid ] <EOL> if process is not None : <EOL> if exit_status is not None : <EOL> process . mark_as_complete ( exit_status ) <EOL> if stdout or stderr : <EOL> process . output ( ) . append ( stdout , stderr ) <EOL> return process <EOL> def all_finished ( self ) : <EOL> return len ( self . get_running ( ) ) == <NUM_LIT:0> <EOL> def get_running ( self ) : <EOL> return filter ( lambda p : p . is_running ( ) , self . __processes . values ( ) ) <EOL> def kill_all ( self ) : <EOL> for process in self . get_running ( ) : <EOL> process . kill ( ) <EOL> class Process : <EOL> def __init__ ( self , command , pid ) : <EOL> self . __command = command <EOL> self . __pid = str ( pid ) <EOL> self . __start_time = time . time ( ) <EOL> self . __output = Output ( ) <EOL> self . __exit_code = None <EOL> self . __time = None <EOL> def mark_as_complete ( self , exit_code ) : <EOL> self . __exit_code = str ( exit_code ) <EOL> self . __time = round ( ( time . time ( ) - self . __start_time ) * <NUM_LIT:1000> ) <EOL> def has_finished ( self ) : <EOL> return self . __exit_code is not None <EOL> def is_running ( self ) : <EOL> return not self . has_finished ( ) <EOL> def get_pid ( self ) : <EOL> return self . __pid <EOL> def get_status ( self ) : <EOL>", "answer": "if self . __exit_code is None :"}, {"prompt": "<s> import json <EOL> import mock <EOL> from cliquet . utils import decode_header <EOL> from . support import ( BaseWebTest , unittest , MINIMALIST_RECORD , <EOL> MINIMALIST_GROUP , MINIMALIST_BUCKET , <EOL> MINIMALIST_COLLECTION , get_user_headers ) <EOL> class RecordsViewTest ( BaseWebTest , unittest . TestCase ) : <EOL> collection_url = '<STR_LIT>' <EOL> _record_url = '<STR_LIT>' <EOL> def setUp ( self ) : <EOL> super ( RecordsViewTest , self ) . setUp ( ) <EOL> self . app . put_json ( '<STR_LIT>' , MINIMALIST_BUCKET , <EOL> headers = self . headers ) <EOL> self . app . put_json ( '<STR_LIT>' , <EOL> MINIMALIST_COLLECTION , <EOL> headers = self . headers ) <EOL> resp = self . app . post_json ( self . collection_url , <EOL> MINIMALIST_RECORD , <EOL> headers = self . headers ) <EOL> self . record = resp . json [ '<STR_LIT:data>' ] <EOL> self . record_url = self . _record_url % self . record [ '<STR_LIT:id>' ] <EOL> def test_records_can_be_accessed_by_id ( self ) : <EOL> self . app . get ( self . record_url , headers = self . headers ) <EOL> def test_unknown_bucket_raises_403 ( self ) : <EOL> other_bucket = self . collection_url . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . app . get ( other_bucket , headers = self . headers , status = <NUM_LIT> ) <EOL> def test_unknown_collection_raises_404 ( self ) : <EOL> other_collection = self . collection_url . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . app . get ( other_collection , headers = self . headers , status = <NUM_LIT> ) <EOL> def test_parent_collection_is_fetched_only_once_in_batch ( self ) : <EOL> batch = { '<STR_LIT>' : [ ] } <EOL> nb_create = <NUM_LIT> <EOL> for i in range ( nb_create ) : <EOL> request = { '<STR_LIT>' : '<STR_LIT:POST>' , <EOL> '<STR_LIT:path>' : self . collection_url , <EOL> '<STR_LIT:body>' : MINIMALIST_RECORD } <EOL> batch [ '<STR_LIT>' ] . append ( request ) <EOL> with mock . patch . object ( self . storage , '<STR_LIT>' , <EOL> wraps = self . storage . get ) as patched : <EOL> self . app . post_json ( '<STR_LIT>' , batch , headers = self . headers ) <EOL> self . assertEqual ( patched . call_count , <NUM_LIT:1> ) <EOL> def test_individual_collections_can_be_deleted ( self ) : <EOL> resp = self . app . get ( self . collection_url , headers = self . headers ) <EOL> self . assertEqual ( len ( resp . json [ '<STR_LIT:data>' ] ) , <NUM_LIT:1> ) <EOL> self . app . delete ( self . collection_url , headers = self . headers ) <EOL> resp = self . app . get ( self . collection_url , headers = self . headers ) <EOL> self . assertEqual ( len ( resp . json [ '<STR_LIT:data>' ] ) , <NUM_LIT:0> ) <EOL> def test_records_can_be_added_to_collections ( self ) : <EOL> response = self . app . get ( self . record_url , headers = self . headers ) <EOL> record = response . json [ '<STR_LIT:data>' ] <EOL> del record [ '<STR_LIT:id>' ] <EOL> del record [ '<STR_LIT>' ] <EOL> self . assertEquals ( record , MINIMALIST_RECORD [ '<STR_LIT:data>' ] ) <EOL> def test_records_are_isolated_by_bucket_and_by_collection ( self ) : <EOL> self . app . put_json ( '<STR_LIT>' , <EOL> MINIMALIST_BUCKET , <EOL> headers = self . headers ) <EOL> other_collection = self . record_url . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . app . get ( other_collection , headers = self . headers , status = <NUM_LIT> ) <EOL> self . app . put_json ( '<STR_LIT>' , <EOL> MINIMALIST_BUCKET , <EOL> headers = self . headers ) <EOL> self . app . put_json ( '<STR_LIT>' , <EOL> MINIMALIST_COLLECTION , <EOL> headers = self . headers ) <EOL> other_bucket = self . record_url . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . app . get ( other_bucket , headers = self . headers , status = <NUM_LIT> ) <EOL> self . app . put_json ( '<STR_LIT>' , <EOL> MINIMALIST_BUCKET , <EOL> headers = self . headers ) <EOL> self . app . put_json ( '<STR_LIT>' , <EOL> MINIMALIST_COLLECTION , <EOL> headers = self . headers ) <EOL> other = self . record_url . replace ( '<STR_LIT>' , '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . app . get ( other , headers = self . headers , status = <NUM_LIT> ) <EOL> def test_a_collection_named_group_do_not_interfere_with_groups ( self ) : <EOL> self . app . put_json ( '<STR_LIT>' , <EOL> MINIMALIST_GROUP , <EOL> headers = self . headers ) <EOL> self . app . put_json ( '<STR_LIT>' , <EOL> MINIMALIST_COLLECTION , <EOL> headers = self . headers ) <EOL> collection_group = self . collection_url . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . app . post_json ( collection_group , <EOL> MINIMALIST_RECORD , <EOL> headers = self . headers ) <EOL> resp = self . app . get ( '<STR_LIT>' , headers = self . headers ) <EOL> self . assertEqual ( len ( resp . json [ '<STR_LIT:data>' ] ) , <NUM_LIT:1> ) <EOL> def test_records_can_be_filtered_on_any_field ( self ) : <EOL> self . app . post_json ( self . collection_url , <EOL> MINIMALIST_RECORD , <EOL> headers = self . headers ) <EOL> response = self . app . get ( self . collection_url + '<STR_LIT>' , <EOL> headers = self . headers ) <EOL> self . assertEqual ( len ( response . json [ '<STR_LIT:data>' ] ) , <NUM_LIT:0> ) <EOL> def test_records_can_be_sorted_on_any_field ( self ) : <EOL> for i in range ( <NUM_LIT:3> ) : <EOL> record = MINIMALIST_RECORD . copy ( ) <EOL> record [ '<STR_LIT:data>' ] [ '<STR_LIT:name>' ] = '<STR_LIT>' % i <EOL> self . app . post_json ( self . collection_url , <EOL> record , <EOL> headers = self . headers ) <EOL> response = self . app . get ( self . collection_url + '<STR_LIT>' , <EOL> headers = self . headers ) <EOL> names = [ i [ '<STR_LIT:name>' ] for i in response . json [ '<STR_LIT:data>' ] ] <EOL> self . assertEqual ( names , <EOL> [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def test_wrong_create_permissions_cannot_be_added_on_records ( self ) : <EOL> record = MINIMALIST_RECORD . copy ( ) <EOL> record [ '<STR_LIT>' ] = { '<STR_LIT>' : [ '<STR_LIT>' ] } <EOL> self . app . put_json ( self . record_url , <EOL> record , <EOL> headers = self . headers , <EOL> status = <NUM_LIT> ) <EOL> def test_create_a_record_update_collection_timestamp ( self ) : <EOL> collection_resp = self . app . get ( self . collection_url , <EOL> headers = self . headers ) <EOL> old_timestamp = int ( <EOL> decode_header ( json . loads ( collection_resp . headers [ '<STR_LIT>' ] ) ) ) <EOL> self . app . post_json ( self . collection_url , <EOL> MINIMALIST_RECORD , <EOL> headers = self . headers , <EOL> status = <NUM_LIT> ) <EOL> collection_resp = self . app . get ( self . collection_url , <EOL> headers = self . headers ) <EOL> new_timestamp = int ( <EOL> decode_header ( json . loads ( collection_resp . headers [ '<STR_LIT>' ] ) ) ) <EOL> assert old_timestamp < new_timestamp <EOL> def test_update_a_record_update_collection_timestamp ( self ) : <EOL> collection_resp = self . app . get ( self . collection_url , <EOL> headers = self . headers ) <EOL> old_timestamp = int ( <EOL> decode_header ( json . loads ( collection_resp . headers [ '<STR_LIT>' ] ) ) ) <EOL> self . app . put_json ( self . record_url , <EOL> MINIMALIST_RECORD , <EOL> headers = self . headers , <EOL> status = <NUM_LIT:200> ) <EOL> collection_resp = self . app . get ( self . collection_url , <EOL> headers = self . headers ) <EOL> new_timestamp = int ( <EOL> decode_header ( json . loads ( collection_resp . headers [ '<STR_LIT>' ] ) ) ) <EOL> assert old_timestamp < new_timestamp <EOL> def test_delete_a_record_update_collection_timestamp ( self ) : <EOL> collection_resp = self . app . get ( self . collection_url , <EOL> headers = self . headers ) <EOL> old_timestamp = int ( <EOL> decode_header ( json . loads ( collection_resp . headers [ '<STR_LIT>' ] ) ) ) <EOL> self . app . delete ( self . record_url , <EOL> headers = self . headers , <EOL> status = <NUM_LIT:200> ) <EOL> collection_resp = self . app . get ( self . collection_url , <EOL> headers = self . headers ) <EOL> new_timestamp = int ( <EOL> decode_header ( json . loads ( collection_resp . headers [ '<STR_LIT>' ] ) ) ) <EOL> assert old_timestamp < new_timestamp <EOL> def test_record_is_accessible_by_group_member ( self ) : <EOL> self . aaron_headers = self . headers . copy ( ) <EOL> self . aaron_headers . update ( ** get_user_headers ( '<STR_LIT>' ) ) <EOL> resp = self . app . get ( '<STR_LIT:/>' , <EOL> headers = self . aaron_headers , <EOL> status = <NUM_LIT:200> ) <EOL> self . create_group ( '<STR_LIT>' , '<STR_LIT>' , [ resp . json [ '<STR_LIT:user>' ] [ '<STR_LIT:id>' ] ] ) <EOL> record = MINIMALIST_RECORD . copy ( ) <EOL> record [ '<STR_LIT>' ] = { '<STR_LIT>' : [ '<STR_LIT>' ] } <EOL> self . app . put_json ( self . record_url , <EOL> record , <EOL> headers = self . headers , <EOL> status = <NUM_LIT:200> ) <EOL> self . app . get ( self . record_url , <EOL> headers = self . aaron_headers , <EOL> status = <NUM_LIT:200> ) <EOL> def test_records_should_reject_unaccepted_request_content_type ( self ) : <EOL> headers = self . headers . copy ( ) <EOL> headers [ '<STR_LIT:Content-Type>' ] = '<STR_LIT>' <EOL> self . app . put ( self . record_url , <EOL> MINIMALIST_RECORD , <EOL>", "answer": "headers = headers ,"}, {"prompt": "<s> import balanced <EOL>", "answer": "balanced . configure ( '<STR_LIT>' )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import qisys . error <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> class DagError ( qisys . error . Error ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , node , parent , result ) : <EOL> self . node = node <EOL> self . parent = parent <EOL> self . result = result <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . node , self . parent , self . node , self . result ) <EOL> def assert_dag ( data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "for node , _ in data . items ( ) :"}, {"prompt": "<s> class CuratorException ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class ConfigurationError ( CuratorException ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class MissingArgument ( CuratorException ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "class NoIndices ( CuratorException ) :"}, {"prompt": "<s> class C ( object ) : <EOL> def __getattr__ ( self , attr ) : <EOL> raise ValueError ( ) <EOL> def f ( ) : <EOL> c = C ( ) <EOL> for i in xrange ( <NUM_LIT> ) : <EOL> try : <EOL> c . foo ( ) <EOL>", "answer": "except ValueError :"}, {"prompt": "<s> import sqlite3 as sqlite <EOL> import os <EOL> class db : <EOL> def setdb ( self , dbfile ) : <EOL> self . con = sqlite . connect ( dbfile ) <EOL> self . con . execute ( '<STR_LIT>' ) <EOL> self . con . execute ( '<STR_LIT>' ) <EOL> self . curs = self . con . cursor ( ) <EOL> def insertItem ( self , path = os . getcwd ( ) + '<STR_LIT>' ) : <EOL> try : <EOL> for line in open ( path + '<STR_LIT>' ) : <EOL>", "answer": "( theid , thetitle ) = line . split ( '<STR_LIT:|>' ) [ <NUM_LIT:0> : <NUM_LIT:2> ]"}, {"prompt": "<s> from msrest . serialization import Model <EOL>", "answer": "class BootDiagnosticsInstanceView ( Model ) :"}, {"prompt": "<s> from django . db import models <EOL> class Tag ( models . Model ) : <EOL> title = models . CharField ( max_length = <NUM_LIT:50> ) <EOL>", "answer": "def to_dict ( self ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from snakeserver . snakelet import Snakelet <EOL> import os , sys , time , rfc822 , unittest , urlparse , urllib , re , stat , cgi <EOL> import fetch , simplejson <EOL> from sets import Set <EOL> from BeautifulSoup import BeautifulSoup , BeautifulStoneSoup <EOL> from yaki . Page import Page <EOL> from yaki . Store import Store , BASE_FILENAME <EOL> from yaki . Cache import Cache <EOL> from yaki . Utils import * <EOL> from yaki . Layout import * <EOL> import yaki . Plugins <EOL> from yaki . Locale import * <EOL> try : <EOL> import cPickle as pickle <EOL> except ImportError : <EOL> import pickle <EOL> def renderReferences ( ac , headers ) : <EOL> buffer = [ ] <EOL> if not ac . indexer . done : <EOL> return \"<STR_LIT>\" <EOL> if [ '<STR_LIT>' ] in headers . keys ( ) : <EOL> thread = { } <EOL> for page in headers [ '<STR_LIT>' ] . split ( '<STR_LIT:U+002C>' ) : <EOL> page = page . strip ( ) <EOL> try : <EOL> date = ac . indexer . pageinfo [ page ] [ '<STR_LIT:date>' ] <EOL> title = ac . index . pageinfo [ page ] [ '<STR_LIT:title>' ] <EOL> thread [ date ] = { '<STR_LIT>' : page , '<STR_LIT:title>' : title } <EOL> except : <EOL> pass <EOL> linear = [ date for date in thread . keys ( ) ] <EOL> linear . sort ( ) <EOL> prev = next = None <EOL> for i in linear : <EOL> if i < headers [ '<STR_LIT:date>' ] : <EOL> prev = i <EOL> if i > headers [ '<STR_LIT:date>' ] : <EOL> next = i <EOL> break <EOL> if prev : <EOL> buffer . append ( '<STR_LIT>' % ( ac . base + thread [ prev ] [ '<STR_LIT>' ] , shrink ( thread [ prev ] [ '<STR_LIT:title>' ] , <NUM_LIT:20> ) ) ) <EOL> if next : <EOL> buffer . append ( '<STR_LIT>' % ( ac . base + thread [ next ] [ '<STR_LIT>' ] , shrink ( thread [ next ] [ '<STR_LIT:title>' ] , <NUM_LIT:20> ) ) ) <EOL> return '<STR_LIT>' . join ( buffer ) <EOL> def subRender ( c , page , request , response , indexing ) : <EOL> soup = BeautifulSoup ( page . render ( c . defaultmarkup ) , selfClosingTags = [ '<STR_LIT>' ] , convertEntities = [ '<STR_LIT:html>' , '<STR_LIT>' ] ) <EOL> for tag in soup ( '<STR_LIT>' ) : <EOL> c . plugins . run ( tag , '<STR_LIT>' , page . headers [ '<STR_LIT:name>' ] , soup , request , response , indexing ) <EOL> c . plugins . runForAllTags ( page . headers [ '<STR_LIT:name>' ] , soup , request , response , indexing ) <EOL> return soup . renderContents ( ) . decode ( '<STR_LIT:utf-8>' ) <EOL> def renderPage ( c , page , request = None , response = None , cache = True , indexing = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if request is None : <EOL> key = \"<STR_LIT>\" + '<STR_LIT:_>' + page . headers [ '<STR_LIT:name>' ] <EOL> else : <EOL> key = \"<STR_LIT>\" + page . headers [ '<STR_LIT:name>' ] <EOL> if not cache : <EOL> return subRender ( c , page , request , response , indexing ) <EOL> else : <EOL> if \"<STR_LIT>\" in page . headers . keys ( ) : <EOL> control = page . headers [ \"<STR_LIT>\" ] . lower ( ) <EOL> m = MAX_AGE_REGEX . match ( control ) <EOL> if m : <EOL> seconds = int ( m . group ( <NUM_LIT:3> ) ) <EOL> try : <EOL> if ( c . cache . mtime ( key ) + seconds ) < time . time ( ) : <EOL> del ( c . cache [ key ] ) <EOL> except KeyError : <EOL> pass <EOL> try : <EOL> if c . store . mtime ( page . headers [ '<STR_LIT:name>' ] ) > c . cache . mtime ( key ) : <EOL> del ( c . cache [ key ] ) <EOL> raise KeyError <EOL> else : <EOL> return c . cache [ key ] <EOL> except KeyError : <EOL> c . cache [ key ] = buffer = subRender ( c , page , request , response , indexing ) <EOL> return buffer <EOL> class Attachment ( Snakelet ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def getDescription ( self ) : <EOL> return \"<STR_LIT>\" <EOL> def allowCaching ( self ) : <EOL> return False <EOL> def requiresSession ( self ) : <EOL> return self . SESSION_NOT_NEEDED <EOL> def serve ( self , request , response ) : <EOL> request . setEncoding ( \"<STR_LIT>\" ) <EOL> response . setEncoding ( \"<STR_LIT>\" ) <EOL> a = self . getWebApp ( ) <EOL> c = request . getContext ( ) <EOL> c . fullurl = request . getBaseURL ( ) + request . getFullQueryArgs ( ) <EOL> path = urllib . unquote ( ( request . getPathInfo ( ) ) [ <NUM_LIT:1> : ] ) <EOL> ( page , attachment ) = os . path . split ( path ) <EOL> if attachment != BASE_FILENAME : <EOL> c = self . getAppContext ( ) <EOL> filename = c . store . getAttachmentFilename ( page , attachment ) <EOL> if os . path . exists ( filename ) : <EOL> stats = os . stat ( filename ) <EOL> response . setHeader ( \"<STR_LIT>\" , '<STR_LIT>' ) <EOL> response . setHeader ( \"<STR_LIT>\" , httpTime ( time . time ( ) + <NUM_LIT> ) ) <EOL> ( etag , lmod ) = a . create_ETag_LMod_headers ( stats . st_mtime , stats . st_size , stats . st_ino ) <EOL> response . setHeader ( \"<STR_LIT>\" , lmod ) <EOL> response . setHeader ( \"<STR_LIT>\" , etag ) <EOL> a . serveStaticFile ( filename , response , useResponseHeaders = False ) <EOL> response . setResponse ( <NUM_LIT> , \"<STR_LIT>\" ) <EOL> return None <EOL> class Starting ( Exception ) : <EOL> print \"<STR_LIT>\" <EOL> pass <EOL> class Wiki ( Snakelet ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def getDescription ( self ) : <EOL> return \"<STR_LIT>\" <EOL> def allowCaching ( self ) : <EOL> return False <EOL> def serve ( self , request , response ) : <EOL> request . setEncoding ( \"<STR_LIT>\" ) <EOL> response . setEncoding ( \"<STR_LIT>\" ) <EOL> ac = self . getAppContext ( ) <EOL> a = self . getWebApp ( ) <EOL> if ac . indexer . ready != True : <EOL> ac = request . getContext ( ) <EOL> response . setHeader ( \"<STR_LIT>\" , '<STR_LIT>' ) <EOL> raise Starting <EOL> return <EOL> c = request . getContext ( ) <EOL> c . fullurl = request . getBaseURL ( ) + request . getFullQueryArgs ( ) <EOL> self . i18n = yaki . Locale . i18n [ ac . locale ] <EOL> try : <EOL> c . path = unicode ( ( request . getPathInfo ( ) ) [ <NUM_LIT:1> : ] , '<STR_LIT>' ) <EOL> if c . path == '<STR_LIT>' : <EOL> c . path = '<STR_LIT>' <EOL> page = self . getPage ( request , response ) <EOL> if page == None : <EOL> return <EOL> ( c . headers , c . content ) = page <EOL> c . title = c . headers [ '<STR_LIT:title>' ] <EOL> c . postinfo = renderInfo ( self . i18n , c . headers ) <EOL> author = c . headers [ '<STR_LIT>' ] <EOL> created = plainTime ( self . i18n , c . headers [ '<STR_LIT:date>' ] , False ) <EOL> if c . headers [ '<STR_LIT:date>' ] == c . headers [ '<STR_LIT>' ] : <EOL> updated = self . i18n [ '<STR_LIT>' ] <EOL> else : <EOL> updated = plainTime ( self . i18n , c . headers [ '<STR_LIT>' ] , False ) <EOL> r = request . getSessionContext ( ) <EOL> if r is not None : <EOL> try : <EOL> if c . headers [ '<STR_LIT:name>' ] not in r . trail : <EOL> r . trail . append ( c . headers [ '<STR_LIT:name>' ] ) <EOL> if len ( r . trail ) > <NUM_LIT:10> : <EOL> r . trail = r . trail [ - <NUM_LIT:10> : ] <EOL> except : <EOL> r . trail = [ c . headers [ '<STR_LIT:name>' ] ] <EOL> try : <EOL> trail = [ ] <EOL> for crumb in r . trail : <EOL> info = ac . indexer . pageinfo [ crumb ] <EOL> info [ '<STR_LIT>' ] = ac . base + info [ '<STR_LIT:name>' ] <EOL> trail . append ( info ) <EOL> c . trail = '<STR_LIT>' + self . i18n [ '<STR_LIT>' ] + '<STR_LIT>' + pagetrail ( trail [ - <NUM_LIT:10> : ] ) + '<STR_LIT>' <EOL> except : <EOL> c . trail = '<STR_LIT>' <EOL> references = { } <EOL> c . seealso = \"<STR_LIT>\" <EOL> try : <EOL> links = ac . indexer . backlinks [ c . headers [ '<STR_LIT:name>' ] ] <EOL> links . extend ( ac . indexer . wikilinks [ c . headers [ '<STR_LIT:name>' ] ] ) <EOL> unique = Set ( links ) <EOL> links = [ unique . pop ( ) for i in range ( <NUM_LIT:0> , len ( unique ) ) ] <EOL> if len ( links ) > <NUM_LIT:0> : <EOL> for link in links : <EOL> references [ ac . base + link ] = ac . indexer . pageinfo [ link ] <EOL> c . seealso = \"<STR_LIT>\" % self . i18n [ '<STR_LIT>' ] + seeAlsoLinkTable ( self . i18n , references ) <EOL> except KeyError : <EOL> c . seealso = '<STR_LIT>' + self . i18n [ '<STR_LIT>' ] + '<STR_LIT>' <EOL> maxage = self . getWebApp ( ) . getConfigItem ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in c . headers . keys ( ) : <EOL> c . cachecontrol = \"<STR_LIT>\" + c . headers [ '<STR_LIT>' ] <EOL> m = MAX_AGE_REGEX . match ( c . headers [ '<STR_LIT>' ] ) <EOL> if m : <EOL> maxage = int ( m . group ( <NUM_LIT:3> ) ) <EOL> response . setHeader ( \"<STR_LIT>\" , '<STR_LIT>' ) <EOL> try : <EOL> stats = ac . cache . stats ( \"<STR_LIT>\" + c . path ) <EOL> ( c . etag , c . lastmodified ) = a . create_ETag_LMod_headers ( stats [ <NUM_LIT:0> ] , stats [ <NUM_LIT:1> ] , stats [ <NUM_LIT:2> ] ) <EOL> except : <EOL> response . setHeader ( \"<STR_LIT>\" , '<STR_LIT>' ) <EOL> c . etag = '<STR_LIT>' <EOL> c . lastmodified = httpTime ( time . time ( ) ) <EOL> c . cachecontrol = '<STR_LIT>' <EOL> if ac . indexer . done : <EOL> c . expires = httpTime ( time . time ( ) + maxage ) <EOL> else : <EOL> c . expires = httpTime ( time . time ( ) ) <EOL> formatComments ( ac , request , c . path ) <EOL> posttitle = c . title <EOL> permalink = plainpermalink = u\"<STR_LIT>\" % ( ac . base , c . path ) <EOL> description = self . i18n [ '<STR_LIT>' ] <EOL> c . headers [ '<STR_LIT>' ] = request . getBaseURL ( ) + permalink <EOL> if SANITIZE_TITLE_REGEX . match ( c . path ) : <EOL> permalink = permalink + u\"<STR_LIT>\" % sanitizeTitle ( c . title ) <EOL> linkclass = \"<STR_LIT>\" <EOL> if \"<STR_LIT>\" in c . headers : <EOL> uri = c . headers [ '<STR_LIT>' ] <EOL> ( schema , netloc , path , parameters , query , fragment ) = urlparse . urlparse ( uri ) <EOL> permalink = uri <EOL> linkclass = self . i18n [ '<STR_LIT>' ] [ schema ] [ '<STR_LIT:class>' ] <EOL> description = self . i18n [ '<STR_LIT>' ] % cgi . escape ( uri ) <EOL> if \"<STR_LIT>\" in c . headers : <EOL> tags = c . headers [ '<STR_LIT>' ] <EOL> else : <EOL> tags = '<STR_LIT>' <EOL> c . keywords = tags <EOL> postinfo = c . postinfo <EOL> content = c . content <EOL> comments = c . comments <EOL> if c . path [ : <NUM_LIT:4> ] == '<STR_LIT>' or '<STR_LIT>' in c . headers . keys ( ) : <EOL> date = \"<STR_LIT>\" <EOL> metadata = '<STR_LIT>' <EOL> else : <EOL> date = plainDate ( self . i18n , c . headers [ '<STR_LIT:date>' ] ) <EOL> metadata = renderEntryMetaData ( self . i18n , c . headers , False ) <EOL> references = '<STR_LIT>' <EOL> if c . path == \"<STR_LIT>\" : <EOL> c . postbody = ac . templates [ '<STR_LIT>' ] % locals ( ) <EOL> else : <EOL> c . postbody = ac . templates [ '<STR_LIT>' ] % locals ( ) <EOL> c . sitename = ac . siteinfo [ '<STR_LIT>' ] <EOL> c . sitedescription = ac . siteinfo [ '<STR_LIT>' ] <EOL> self . redirect ( '<STR_LIT>' , request , response ) <EOL> except Warning , e : <EOL> c . status = e . value <EOL> ( c . headers , c . content ) = self . getPage ( request , response ) <EOL> self . redirect ( '<STR_LIT>' , request , response ) <EOL> def requiresSession ( self ) : <EOL> return self . SESSION_WANTED <EOL> def dumpTable ( self , request ) : <EOL> h = request . getAllHeaders ( ) <EOL> buffer = '<STR_LIT>' <EOL>", "answer": "i = <NUM_LIT:0>"}, {"prompt": "<s> from goldsberry . masterclass import NbaDataProvider <EOL>", "answer": "from goldsberry . apiparams import *"}, {"prompt": "<s> from distutils . core import setup <EOL> setup ( name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL>", "answer": "url = '<STR_LIT>' ,"}, {"prompt": "<s> from functools import partial <EOL> import numpy as np <EOL> import unittest <EOL> from hyperopt import hp , Trials , fmin , tpe , anneal , rand <EOL> import hyperopt . pyll . stochastic <EOL> class TestPChoice ( unittest . TestCase ) : <EOL> def test_basic ( self ) : <EOL> space = hp . pchoice ( '<STR_LIT>' , <EOL> [ ( <NUM_LIT> , '<STR_LIT>' ) , <EOL> ( <NUM_LIT> , '<STR_LIT>' ) , <EOL> ( <NUM_LIT> , '<STR_LIT>' ) ] ) <EOL> a , b , c = <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> <EOL> rng = np . random . RandomState ( <NUM_LIT> ) <EOL> for i in range ( <NUM_LIT:0> , <NUM_LIT:1000> ) : <EOL> nesto = hyperopt . pyll . stochastic . sample ( space , rng = rng ) <EOL> if nesto == '<STR_LIT>' : <EOL> a += <NUM_LIT:1> <EOL> elif nesto == '<STR_LIT>' : <EOL> b += <NUM_LIT:1> <EOL> elif nesto == '<STR_LIT>' : <EOL> c += <NUM_LIT:1> <EOL> print ( a , b , c ) <EOL> assert a + b + c == <NUM_LIT:1000> <EOL> assert <NUM_LIT> < a < <NUM_LIT> <EOL> assert <NUM_LIT:0> < b < <NUM_LIT> <EOL> assert <NUM_LIT> < c < <NUM_LIT> <EOL> def test_basic2 ( self ) : <EOL> space = hp . choice ( '<STR_LIT>' , [ <EOL> hp . pchoice ( '<STR_LIT>' , <EOL> [ ( <NUM_LIT> , '<STR_LIT>' ) , <EOL> ( <NUM_LIT> , '<STR_LIT>' ) , <EOL> ( <NUM_LIT> , <NUM_LIT:2> ) ] ) , <EOL> hp . choice ( '<STR_LIT>' , [ <NUM_LIT:10> , <NUM_LIT:20> ] ) <EOL> ] ) <EOL> a , b , c = <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> <EOL> rng = np . random . RandomState ( <NUM_LIT> ) <EOL> for i in range ( <NUM_LIT:0> , <NUM_LIT:1000> ) : <EOL> nesto = hyperopt . pyll . stochastic . sample ( space , rng = rng ) <EOL> if nesto == '<STR_LIT>' : <EOL> a += <NUM_LIT:1> <EOL> elif nesto == '<STR_LIT>' : <EOL> b += <NUM_LIT:1> <EOL> elif nesto == <NUM_LIT:2> : <EOL> c += <NUM_LIT:1> <EOL> elif nesto in ( <NUM_LIT:10> , <NUM_LIT:20> ) : <EOL> pass <EOL> else : <EOL> assert <NUM_LIT:0> , nesto <EOL> print ( a , b , c ) <EOL> assert b > <NUM_LIT:2> * a <EOL> assert b > <NUM_LIT:2> * c <EOL> def test_basic3 ( self ) : <EOL> space = hp . pchoice ( '<STR_LIT>' , [ <EOL> ( <NUM_LIT> , hp . pchoice ( '<STR_LIT>' , [ ( <NUM_LIT> , <NUM_LIT:2> ) , ( <NUM_LIT> , <NUM_LIT:1> ) ] ) ) , <EOL> ( <NUM_LIT> , hp . pchoice ( '<STR_LIT>' , [ ( <NUM_LIT> , <NUM_LIT:5> ) , ( <NUM_LIT> , <NUM_LIT:6> ) ] ) ) <EOL> ] ) <EOL> a , b , c , d = <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> <EOL> rng = np . random . RandomState ( <NUM_LIT> ) <EOL> for i in range ( <NUM_LIT:0> , <NUM_LIT> ) : <EOL> nesto = hyperopt . pyll . stochastic . sample ( space , rng = rng ) <EOL> if nesto == <NUM_LIT:2> : <EOL> a += <NUM_LIT:1> <EOL> elif nesto == <NUM_LIT:1> : <EOL> b += <NUM_LIT:1> <EOL> elif nesto == <NUM_LIT:5> : <EOL> c += <NUM_LIT:1> <EOL> elif nesto == <NUM_LIT:6> : <EOL> d += <NUM_LIT:1> <EOL> else : <EOL> assert <NUM_LIT:0> , nesto <EOL> print ( a , b , c , d ) <EOL> assert a + b + c + d == <NUM_LIT> <EOL> assert <NUM_LIT> < a + b < <NUM_LIT> <EOL> assert <NUM_LIT> < c + d < <NUM_LIT> <EOL>", "answer": "assert a * <NUM_LIT> > b"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "from neutron . db . migration import cli"}, {"prompt": "<s> from swgpy . command import BaseSwgCommand <EOL> from swgpy import POSTURE <EOL> class StandCommand ( BaseSwgCommand ) : <EOL> base_run_speed = <NUM_LIT> <EOL> def getCommandName ( self ) : <EOL>", "answer": "return '<STR_LIT>'"}, {"prompt": "<s> try : <EOL> import multiprocessing <EOL>", "answer": "except ImportError :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from application import app <EOL> from google . appengine . runtime . apiproxy_errors import CapabilityDisabledError <EOL> from google . appengine . api import mail <EOL> from flask import render_template , render_template_string , request , flash , g , url_for , redirect , session <EOL> from models import MailingAddress <EOL> from decorators import admin_required <EOL> from forms import RegistrationForm , LoginForm , StripeSubscriptionForm , AddressForm <EOL> from flaskext . auth import Auth , login , logout , login_required <EOL> from flaskext . auth . models . gae import User <EOL> from flaskext . oauth import OAuth <EOL> import stripe <EOL> FACEBOOK_APP_ID = '<STR_LIT>' <EOL> FACEBOOK_APP_SECRET = '<STR_LIT>' <EOL> STRIPE_SECRET = '<STR_LIT>' <EOL> STRIPE_PUB_KEY = '<STR_LIT>' <EOL> Auth ( app , login_url_name = '<STR_LIT>' ) <EOL> oauth = OAuth ( ) <EOL> facebook = oauth . remote_app ( '<STR_LIT>' , <EOL> base_url = '<STR_LIT>' , <EOL> request_token_url = None , <EOL> access_token_url = '<STR_LIT>' , <EOL> authorize_url = '<STR_LIT>' , <EOL> consumer_key = FACEBOOK_APP_ID , <EOL> consumer_secret = FACEBOOK_APP_SECRET , <EOL> request_token_params = { '<STR_LIT>' : '<STR_LIT:email>' } <EOL> ) <EOL> @ app . context_processor <EOL> def inject_user ( ) : <EOL> user = User . load_current_user ( ) <EOL> if user : <EOL> return dict ( user = user ) <EOL> return dict ( ) <EOL> @ app . route ( '<STR_LIT:/>' ) <EOL> def home ( ) : <EOL> return redirect ( url_for ( '<STR_LIT>' ) ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT:GET>' , '<STR_LIT:POST>' ] ) <EOL> def login_view ( ) : <EOL> form = LoginForm ( request . form ) <EOL> if request . method == '<STR_LIT:POST>' and form . validate ( ) : <EOL> user = User . get_by_username ( form . email . data ) <EOL> if user is not None : <EOL> if user . authenticate ( form . password . data ) : <EOL> flash ( u'<STR_LIT>' ) <EOL> return redirect ( url_for ( '<STR_LIT>' ) ) <EOL> return '<STR_LIT>' <EOL> return render_template ( '<STR_LIT>' , form = form ) <EOL> @ app . route ( '<STR_LIT>' ) <EOL> def flogin ( ) : <EOL> return facebook . authorize ( callback = url_for ( '<STR_LIT>' , <EOL> next = request . args . get ( '<STR_LIT>' ) or request . referrer or None , <EOL> _external = True ) ) <EOL> @ app . route ( '<STR_LIT>' ) <EOL> @ facebook . authorized_handler <EOL> def facebook_authorized ( resp ) : <EOL> if resp is None : <EOL> flash ( u'<STR_LIT>' % ( <EOL> request . args [ '<STR_LIT>' ] , <EOL> request . args [ '<STR_LIT>' ] <EOL> ) ) <EOL> return redirect ( url_for ( '<STR_LIT>' ) ) <EOL> session [ '<STR_LIT>' ] = ( resp [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> me = facebook . get ( '<STR_LIT>' ) <EOL> user = User . get_by_username ( me . data [ '<STR_LIT:email>' ] ) <EOL> if user is not None : <EOL> login ( user ) <EOL> else : <EOL> user = User ( username = me . data [ '<STR_LIT:email>' ] , name = me . data [ '<STR_LIT:name>' ] ) <EOL> user . put ( ) <EOL> login ( user ) <EOL> flash ( u\"<STR_LIT>\" ) <EOL> return redirect ( url_for ( '<STR_LIT>' ) ) <EOL> @ facebook . tokengetter <EOL> def get_facebook_oauth_token ( ) : <EOL> return session . get ( '<STR_LIT>' ) <EOL> @ app . route ( '<STR_LIT>' ) <EOL> def logout_view ( ) : <EOL> user_data = logout ( ) <EOL> if user_data is None : <EOL> flash ( u'<STR_LIT>' ) <EOL> return redirect ( url_for ( '<STR_LIT>' ) ) <EOL> flash ( u'<STR_LIT>' ) <EOL> return redirect ( url_for ( '<STR_LIT>' ) ) <EOL> @ app . route ( '<STR_LIT>' ) <EOL> def new_user ( ) : <EOL> form = RegistrationForm ( ) <EOL> return render_template ( '<STR_LIT>' , form = form ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT:POST>' ] ) <EOL> def create_user ( ) : <EOL> form = RegistrationForm ( request . form ) <EOL> if form . validate ( ) : <EOL> user = User ( username = form . email . data ) <EOL> user . set_and_encrypt_password ( form . password . data ) <EOL> user . put ( ) <EOL> login ( user ) <EOL> flash ( u'<STR_LIT>' ) <EOL> return redirect ( url_for ( '<STR_LIT>' ) ) <EOL> return redirect ( url_for ( '<STR_LIT>' ) ) <EOL> @ app . route ( '<STR_LIT>' ) <EOL> @ login_required <EOL> def account ( ) : <EOL> user = User . load_current_user ( ) <EOL> stripe . api_key = STRIPE_SECRET <EOL> try : <EOL> customer = stripe . Customer . retrieve ( user . stripe_customer_id ) <EOL> except : <EOL> customer = False <EOL> mail = MailingAddress . get_by_username ( user . username ) <EOL> return render_template ( '<STR_LIT>' , customer = customer , mail = mail ) <EOL> @ app . route ( '<STR_LIT>' ) <EOL> @ login_required <EOL> def edit_address ( ) : <EOL> user = User . load_current_user ( ) <EOL> mail = MailingAddress . get_by_username ( user . username ) <EOL> form = AddressForm ( obj = mail ) <EOL> return render_template ( '<STR_LIT>' , form = form ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT:POST>' ] ) <EOL> @ login_required <EOL> def update_address ( ) : <EOL> user = User . load_current_user ( ) <EOL> form = AddressForm ( request . form ) <EOL> m = MailingAddress . get_by_username ( user . username ) <EOL> m . name = form . name . data <EOL> m . address1 = form . address1 . data <EOL> m . address2 = form . address2 . data <EOL> m . zipcode = form . zipcode . data <EOL> m . city = form . city . data <EOL> m . state = form . state . data <EOL> m . country = form . country . data <EOL> m . put ( ) <EOL> return redirect ( url_for ( '<STR_LIT>' ) ) <EOL> @ app . route ( '<STR_LIT>' ) <EOL> @ login_required <EOL> def cancel_subscription ( ) : <EOL> user = User . load_current_user ( ) <EOL> stripe . api_key = STRIPE_SECRET <EOL> try : <EOL> cu = stripe . Customer . retrieve ( user . stripe_customer_id ) <EOL> cu . cancel_subscription ( ) <EOL> flash ( u'<STR_LIT>' ) <EOL> except : <EOL> pass <EOL> return redirect ( url_for ( '<STR_LIT>' ) ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT:GET>' , '<STR_LIT:POST>' ] ) <EOL> @ login_required <EOL> def subscribe ( ) : <EOL> form = StripeSubscriptionForm ( request . form ) <EOL> if request . method == '<STR_LIT:POST>' : <EOL> stripe . api_key = STRIPE_SECRET <EOL> user = User . load_current_user ( ) <EOL> customer = stripe . Customer . create ( <EOL> card = form . stripeToken . data , <EOL> plan = \"<STR_LIT>\" , <EOL> email = user . username <EOL> ) <EOL> user . stripe_customer_id = customer . id <EOL> user . put ( ) <EOL> m = MailingAddress ( username = user . username , name = form . name . data , address1 = form . address1 . data , address2 = form . address2 . data , zipcode = form . zipcode . data , city = form . city . data , state = form . state . data , country = form . country . data ) <EOL> m . put ( ) <EOL> context = dict ( ) <EOL> bodytext = render_template_string ( '<STR_LIT>' , context = context ) <EOL> bodyhtml = render_template ( '<STR_LIT>' , context = context ) <EOL> mail . send_mail ( sender = \"<STR_LIT>\" , to = user . username , <EOL> subject = \"<STR_LIT>\" , body = bodytext , html = bodyhtml ) <EOL> return redirect ( url_for ( '<STR_LIT>' ) ) <EOL> return render_template ( '<STR_LIT>' , form = form , pub_key = STRIPE_PUB_KEY ) <EOL> @ app . route ( '<STR_LIT>' ) <EOL> @ admin_required <EOL>", "answer": "def admin_only ( ) :"}]