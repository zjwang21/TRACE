[{"prompt": "<s> import os , sys <EOL> import time <EOL> import signal <EOL> from threading import Timer <EOL> import subprocess <EOL> import msgpackrpc <EOL> from msgpackrpc . error import * <EOL> import logging <EOL> logging . getLogger ( ) . setLevel ( logging . ERROR ) <EOL> class TestUtil : <EOL> @ staticmethod <EOL> def check_server ( port ) : <EOL> cli = msgpackrpc . Client ( msgpackrpc . Address ( \"<STR_LIT:127.0.0.1>\" , port ) ) <EOL> try : <EOL> cli . call ( \"<STR_LIT>\" ) <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> except RPCError as e : <EOL> if e . args [ <NUM_LIT:0> ] == <NUM_LIT:1> : <EOL> cli . close ( ) <EOL>", "answer": "return True"}, {"prompt": "<s> from random import choice <EOL> from django . utils import unittest <EOL> from django import template <EOL> from django . conf . urls import patterns , url , include <EOL> from django . template import Template , Context <EOL> from siteblocks . models import Block <EOL> from siteblocks . siteblocksapp import SiteBlocks , register_dynamic_block <EOL> class MockRequest ( object ) : <EOL> def __init__ ( self , path , user_authorized ) : <EOL> self . path = path <EOL> self . user = MockUser ( user_authorized ) <EOL> class MockUser ( object ) : <EOL> def __init__ ( self , authorized ) : <EOL> self . authorized = authorized <EOL> def is_authenticated ( self ) : <EOL> return self . authorized <EOL> class MockUrlconfModule ( object ) : <EOL> urlpatterns = patterns ( '<STR_LIT>' , url ( r'<STR_LIT>' , lambda r : None , name = '<STR_LIT:url>' ) , ) <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL> url ( r'<STR_LIT>' , lambda r : None , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , include ( ( MockUrlconfModule , None , '<STR_LIT>' ) ) ) , <EOL> ) <EOL> def get_mock_context ( app = None , path = None , user_authorized = False ) : <EOL> ctx = template . Context ( { '<STR_LIT>' : MockRequest ( path , user_authorized ) } , current_app = app ) <EOL> return ctx <EOL> QUOTES = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> def get_quote ( ** kwargs ) : <EOL> return choice ( QUOTES ) <EOL> class TemplateTagsTest ( unittest . TestCase ) : <EOL> def test_siteblock ( self ) : <EOL> context = Context ( ) <EOL> context [ '<STR_LIT>' ] = MockRequest ( '<STR_LIT:/>' , user_authorized = False ) <EOL> result = Template ( '<STR_LIT>' ) . render ( context ) <EOL> self . assertEqual ( result , '<STR_LIT>' ) <EOL> b1 = Block ( alias = '<STR_LIT>' , url = '<STR_LIT:*>' , contents = '<STR_LIT>' ) <EOL> b1 . save ( force_insert = True ) <EOL> result = Template ( '<STR_LIT>' ) . render ( context ) <EOL> self . assertEqual ( result , '<STR_LIT>' ) <EOL> Template ( '<STR_LIT>' ) . render ( context ) <EOL> self . assertEqual ( context . get ( '<STR_LIT>' ) , '<STR_LIT>' ) <EOL> class TreeItemModelTest ( unittest . TestCase ) : <EOL> @ classmethod <EOL> def setUpClass ( cls ) : <EOL> cls . siteblocks = SiteBlocks ( ) <EOL> cls . b1 = Block ( alias = '<STR_LIT>' , url = '<STR_LIT:*>' , contents = '<STR_LIT>' ) <EOL>", "answer": "cls . b1 . save ( force_insert = True )"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django import template <EOL> register = template . Library ( ) <EOL> @ register . assignment_tag ( ) <EOL> def changedesc_user ( changedesc , model ) : <EOL>", "answer": "return changedesc . get_user ( model ) "}, {"prompt": "<s> import py <EOL> def test_BaseException ( ) : <EOL> assert issubclass ( IndexError , py . builtin . BaseException ) <EOL> assert issubclass ( Exception , py . builtin . BaseException ) <EOL> assert issubclass ( KeyboardInterrupt , py . builtin . BaseException ) <EOL> class MyRandomClass ( object ) : <EOL> pass <EOL> assert not issubclass ( MyRandomClass , py . builtin . BaseException ) <EOL> assert py . builtin . BaseException . __module__ == '<STR_LIT>' <EOL> assert Exception . __name__ == '<STR_LIT>' <EOL> def test_GeneratorExit ( ) : <EOL>", "answer": "assert py . builtin . GeneratorExit . __module__ == '<STR_LIT>'"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __docformat__ = '<STR_LIT>' <EOL> def ro ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return mergeOrderings ( [ _flatten ( object ) ] ) <EOL> def mergeOrderings ( orderings , seen = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if seen is None : <EOL> seen = { } <EOL> result = [ ] <EOL> orderings . reverse ( ) <EOL> for ordering in orderings : <EOL> ordering = list ( ordering ) <EOL> ordering . reverse ( ) <EOL> for o in ordering : <EOL> if o not in seen : <EOL> seen [ o ] = <NUM_LIT:1> <EOL> result . append ( o ) <EOL> result . reverse ( ) <EOL> return result <EOL> def _flatten ( ob ) : <EOL> result = [ ob ] <EOL> i = <NUM_LIT:0> <EOL>", "answer": "for ob in iter ( result ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "__version__ = '<STR_LIT>'"}, {"prompt": "<s> from django . contrib import admin <EOL> from django . utils . safestring import mark_safe <EOL> from . behaviors import Spammable <EOL> from . exceptions import SpamNotFound <EOL> from . models import SpammyPosting <EOL>", "answer": "from . utils import spammables"}, {"prompt": "<s> class xcconfig_item_base ( object ) : <EOL> def __init__ ( self , line ) : <EOL>", "answer": "line_end = line . find ( '<STR_LIT>' ) ;"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL>", "answer": "result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "<s> import json <EOL> import os <EOL> import shlex <EOL> import subprocess <EOL> import sys <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def drive_configuration ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> block_devices = [ ] <EOL> for device in os . listdir ( '<STR_LIT>' ) : <EOL> if os . path . exists ( '<STR_LIT>' % device ) : <EOL> with open ( '<STR_LIT>' % device ) as dev : <EOL> sectors = dev . read ( ) <EOL> with open ( '<STR_LIT>' % device ) as dev : <EOL> hw_sector_size = dev . read ( ) <EOL> size = int ( sectors ) * int ( hw_sector_size ) <EOL> pathname = os . path . join ( '<STR_LIT>' , device ) <EOL> partitions = [ ] <EOL> for partition_number in range ( <NUM_LIT:1> , <NUM_LIT> ) : <EOL> partition_path = '<STR_LIT>' % ( device , device , <EOL> partition_number ) <EOL> if os . path . exists ( partition_path ) : <EOL> with open ( os . path . join ( partition_path , '<STR_LIT:size>' ) ) as part : <EOL> partition_size = int ( part . read ( ) ) * int ( hw_sector_size ) <EOL> partitions . append ( { <EOL> '<STR_LIT>' : '<STR_LIT>' % ( device , partition_number ) , <EOL> '<STR_LIT>' : partition_size } ) <EOL> block_devices . append ( { '<STR_LIT:name>' : pathname , '<STR_LIT>' : size , <EOL> '<STR_LIT>' : partitions } ) <EOL> return block_devices <EOL> def dmidecode ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> hardware = { } <EOL> try : <EOL> output = subprocess . check_output ( [ '<STR_LIT>' ] ) <EOL> except subprocess . CalledProcessError : <EOL> output = '<STR_LIT>' <EOL> state = '<STR_LIT>' <EOL> for line in output . split ( '<STR_LIT:\\n>' ) : <EOL> if state == '<STR_LIT>' : <EOL> if line . startswith ( '<STR_LIT>' ) : <EOL> handle = '<STR_LIT:_>' + line [ <NUM_LIT:7> : <NUM_LIT> ] <EOL> state = '<STR_LIT>' <EOL> continue <EOL> if state == '<STR_LIT>' : <EOL> dmi = line . lower ( ) . strip ( ) . replace ( '<STR_LIT:U+0020>' , '<STR_LIT:_>' ) <EOL> if not hardware . get ( dmi ) : <EOL> hardware [ dmi ] = { } <EOL> hardware [ dmi ] [ handle ] = { } <EOL> state = '<STR_LIT>' <EOL> continue <EOL> if state == '<STR_LIT>' : <EOL> if line . strip ( ) == '<STR_LIT>' : <EOL> state = '<STR_LIT>' <EOL> else : <EOL> if '<STR_LIT::>' in line : <EOL> attr_val = line . split ( '<STR_LIT::>' ) <EOL> if len ( attr_val [ <NUM_LIT:1> ] ) > <NUM_LIT:1> : <EOL> attr = attr_val [ <NUM_LIT:0> ] . strip ( ) . lower ( ) . replace ( '<STR_LIT:U+0020>' , '<STR_LIT:_>' ) <EOL> val = attr_val [ <NUM_LIT:1> ] . strip ( ) . lower ( ) . replace ( '<STR_LIT:U+0020>' , '<STR_LIT:_>' ) <EOL> hardware [ dmi ] [ handle ] [ attr ] = val <EOL> else : <EOL> attr = attr_val [ <NUM_LIT:0> ] . strip ( ) . lower ( ) . replace ( '<STR_LIT:U+0020>' , '<STR_LIT:_>' ) <EOL> state = '<STR_LIT>' <EOL> hardware [ dmi ] [ handle ] [ attr ] = { } <EOL> idx = <NUM_LIT:0> <EOL> else : <EOL> pass <EOL> continue <EOL> if state == '<STR_LIT>' : <EOL> if line . strip ( ) == '<STR_LIT>' : <EOL> state = '<STR_LIT>' <EOL> elif '<STR_LIT::>' in line : <EOL> state = '<STR_LIT>' <EOL> attr_val = line . split ( '<STR_LIT::>' ) <EOL> attr = attr_val [ <NUM_LIT:0> ] . strip ( ) . lower ( ) . replace ( '<STR_LIT:U+0020>' , '<STR_LIT:_>' ) <EOL> val = attr_val [ <NUM_LIT:1> ] . strip ( ) . lower ( ) . replace ( '<STR_LIT:U+0020>' , '<STR_LIT:_>' ) <EOL> hardware [ dmi ] [ handle ] [ attr ] = val <EOL> else : <EOL> hardware [ dmi ] [ handle ] [ attr ] [ str ( idx ) ] = line . strip ( ) . lower ( ) . replace ( '<STR_LIT:U+0020>' , '<STR_LIT:_>' ) <EOL> idx += <NUM_LIT:1> <EOL> continue <EOL> dmidata = { } <EOL> for key in hardware . keys ( ) : <EOL> dmidata [ key ] = [ ] <EOL> for handle in hardware [ key ] : <EOL> newvalue = hardware . get ( key ) . get ( handle ) <EOL> newvalue [ '<STR_LIT>' ] = handle <EOL> dmidata [ key ] . append ( newvalue ) <EOL> return dmidata <EOL> def ip ( ) : <EOL> interfaces = [ ] <EOL> try : <EOL> output = subprocess . check_output ( [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> except subprocess . CalledProcessError : <EOL> output = '<STR_LIT>' <EOL> parser = '<STR_LIT>' <EOL> name = '<STR_LIT>' <EOL> state = '<STR_LIT>' <EOL> for line in output . split ( '<STR_LIT:\\n>' ) : <EOL> pieces = line . split ( ) <EOL> if len ( pieces ) == <NUM_LIT:0> : <EOL> continue <EOL> if parser == '<STR_LIT>' : <EOL> name = pieces [ <NUM_LIT:1> ] . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] <EOL> state = pieces [ <NUM_LIT:8> ] <EOL> parser = '<STR_LIT>' <EOL> else : <EOL> is_ether = False <EOL> if pieces [ <NUM_LIT:0> ] == '<STR_LIT>' and name . startswith ( '<STR_LIT>' ) : <EOL> is_ether = True <EOL> mac = pieces [ <NUM_LIT:1> ] <EOL> if is_ether : <EOL> interfaces . append ( { '<STR_LIT:name>' : name , <EOL> '<STR_LIT>' : [ { '<STR_LIT:name>' : name , <EOL> '<STR_LIT:state>' : state , <EOL> '<STR_LIT>' : mac } ] } ) <EOL> parser = '<STR_LIT>' <EOL> for interface in interfaces : <EOL> name = interface [ '<STR_LIT:name>' ] <EOL> try : <EOL> output = subprocess . check_output ( [ '<STR_LIT>' , '<STR_LIT:%s>' % name ] ) <EOL> except subprocess . CalledProcessError : <EOL> output = '<STR_LIT>' <EOL> dev_info = interface . get ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> for line in output . split ( '<STR_LIT:\\n>' ) : <EOL> if line . strip ( ) . startswith ( '<STR_LIT>' ) : <EOL> dev_info [ '<STR_LIT>' ] = line . strip ( ) . split ( ) [ <NUM_LIT:2> ] <EOL> elif line . strip ( ) . startswith ( '<STR_LIT>' ) : <EOL> dev_info [ '<STR_LIT>' ] = line . strip ( ) . split ( ) [ <NUM_LIT:1> ] <EOL> elif line . strip ( ) . startswith ( '<STR_LIT>' ) : <EOL> dev_info [ '<STR_LIT>' ] = line . strip ( ) . split ( ) [ <NUM_LIT:1> ] <EOL> return interfaces <EOL> def meminfo ( ) : <EOL> mem_info = { } <EOL> with open ( '<STR_LIT>' ) as lines : <EOL> for line in lines : <EOL> item = { } <EOL> name = line . split ( ) [ <NUM_LIT:0> ] . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] . lower ( ) <EOL> item [ '<STR_LIT:value>' ] = int ( line . split ( ) [ <NUM_LIT:1> ] . strip ( ) ) <EOL> try : <EOL> item [ '<STR_LIT>' ] = line . split ( ) [ <NUM_LIT:2> ] . strip ( ) <EOL> except IndexError : <EOL> pass <EOL> mem_info [ name ] = item <EOL> return mem_info <EOL> def dpkg ( ) : <EOL> packages = [ ] <EOL> try : <EOL> output = subprocess . check_output ( [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> except subprocess . CalledProcessError : <EOL> output = '<STR_LIT>' <EOL> parser = '<STR_LIT>' <EOL> for line in output . split ( '<STR_LIT:\\n>' ) : <EOL> if parser == '<STR_LIT>' : <EOL> if line . startswith ( '<STR_LIT>' ) : <EOL> parser = '<STR_LIT>' <EOL> else : <EOL> pieces = line . split ( ) <EOL> if len ( pieces ) == <NUM_LIT:0> : <EOL> continue <EOL> package = { <EOL> '<STR_LIT:status>' : pieces [ <NUM_LIT:0> ] , <EOL> '<STR_LIT:name>' : pieces [ <NUM_LIT:1> ] , <EOL> '<STR_LIT:version>' : str ( pieces [ <NUM_LIT:2> ] ) , <EOL> '<STR_LIT>' : pieces [ <NUM_LIT:3> ] , <EOL> '<STR_LIT:description>' : '<STR_LIT:U+0020>' . join ( pieces [ <NUM_LIT:4> : ] ) } <EOL> packages . append ( package ) <EOL> return packages <EOL> def main ( ) : <EOL> ipaddr = None <EOL> hostname = None <EOL> try : <EOL> args_file = sys . argv [ <NUM_LIT:1> ] <EOL> args_data = file ( args_file ) . read ( ) <EOL> arguments = shlex . split ( args_data ) <EOL> except ( IndexError , IOError ) : <EOL>", "answer": "arguments = sys . argv"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Static ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "<s> from django . template . loader import render_to_string <EOL> class BaseBackend ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , medium_id , spam_sensitivity = None ) : <EOL> self . medium_id = medium_id <EOL> if spam_sensitivity is not None : <EOL> self . spam_sensitivity = spam_sensitivity <EOL> def can_send ( self , user , notice_type ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from notification . models import should_send <EOL> if should_send ( user , notice_type , self . medium_id ) : <EOL> return True <EOL> return False <EOL> def deliver ( self , recipient , notice_type , extra_context ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplemented ( ) <EOL>", "answer": "def get_formatted_messages ( self , formats , label , context ) :"}, {"prompt": "<s> __revision__ = \"<STR_LIT>\" <EOL> from . md5 import * <EOL>", "answer": "from . import md5"}, {"prompt": "<s> from robotide . lib . robot . errors import DataError <EOL> try : <EOL> from docutils . core import publish_doctree , publish_from_doctree <EOL> from docutils . parsers . rst . directives import register_directive <EOL>", "answer": "from docutils . parsers . rst . directives . body import CodeBlock"}, {"prompt": "<s> def handle ( instance ) : <EOL> from core . models import Controller , ControllerSlice , ControllerNetwork , NetworkSlice <EOL> networks = [ ns . network for ns in NetworkSlice . objects . filter ( slice = instance . slice ) ] <EOL> controller_networks = ControllerNetwork . objects . filter ( network__in = networks , <EOL> controller = instance . node . site_deployment . controller ) <EOL> for cn in controller_networks : <EOL>", "answer": "if ( cn . lazy_blocked ) :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from leapcast . services . leap_factory import LEAPfactory <EOL> class ChromeCast ( LEAPfactory ) : <EOL> url = \"<STR_LIT>\" <EOL> class YouTube ( LEAPfactory ) : <EOL> url = \"<STR_LIT>\" <EOL> class PlayMovies ( LEAPfactory ) : <EOL> url = \"<STR_LIT>\" <EOL> supported_protocols = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> class GoogleMusic ( LEAPfactory ) : <EOL> url = \"<STR_LIT>\" <EOL>", "answer": "class GoogleCastSampleApp ( LEAPfactory ) :"}, {"prompt": "<s> import testtools <EOL> from openstack . orchestration import orchestration_service <EOL> class TestOrchestrationService ( testtools . TestCase ) : <EOL> def test_service ( self ) : <EOL> sot = orchestration_service . OrchestrationService ( ) <EOL> self . assertEqual ( '<STR_LIT>' , sot . service_type ) <EOL> self . assertEqual ( '<STR_LIT>' , sot . interface ) <EOL> self . assertIsNone ( sot . region ) <EOL>", "answer": "self . assertIsNone ( sot . service_name )"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import numpy as np <EOL> from scipy import stats <EOL> import os <EOL> from statsmodels . stats . descriptivestats import sign_test <EOL> def descstats ( data , cols = None , axis = <NUM_LIT:0> ) : <EOL> '''<STR_LIT>''' <EOL> x = np . array ( data ) <EOL> if cols is None : <EOL> if not isinstance ( x , np . recarray ) and x . ndim == <NUM_LIT:1> : <EOL> x = x [ : , None ] <EOL> if x . shape [ <NUM_LIT:1> ] == <NUM_LIT:1> : <EOL> desc = '''<STR_LIT>''' % { '<STR_LIT:name>' : cols , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : len ( x ) , '<STR_LIT>' : stats . mode ( x ) [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] , '<STR_LIT>' : stats . mode ( x ) [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , '<STR_LIT>' : x . mean ( ) , '<STR_LIT>' : np . median ( x ) , '<STR_LIT>' : '<STR_LIT:(>' + str ( x . min ( ) ) + '<STR_LIT:U+002CU+0020>' + str ( x . max ( ) ) + '<STR_LIT:)>' , '<STR_LIT>' : x . var ( ) , '<STR_LIT>' : x . std ( ) , '<STR_LIT>' : stats . variation ( x ) , '<STR_LIT>' : stats . skew ( x ) , '<STR_LIT>' : stats . kurtosis ( x ) , '<STR_LIT>' : np . sum ( x ** <NUM_LIT:2> , axis = <NUM_LIT:0> ) , '<STR_LIT>' : np . sum ( ( x - x . mean ( ) ) ** <NUM_LIT:2> , axis = <NUM_LIT:0> ) , '<STR_LIT>' : np . sum ( x ) } <EOL> desc += '''<STR_LIT>''' % tuple ( [ stats . scoreatpercentile ( x , per ) for per in ( <NUM_LIT:1> , <NUM_LIT:5> , <NUM_LIT:10> , <NUM_LIT> , <EOL> <NUM_LIT:50> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ] ) <EOL> t , p_t = stats . ttest_1samp ( x , <NUM_LIT:0> ) <EOL> M , p_M = sign_test ( x ) <EOL> S , p_S = stats . wilcoxon ( np . squeeze ( x ) ) <EOL> desc += '''<STR_LIT>''' % ( t , p_t , M , p_M , S , p_S ) <EOL> elif x . shape [ <NUM_LIT:1> ] > <NUM_LIT:1> : <EOL> desc = '''<STR_LIT>''' + os . linesep <EOL> for var in range ( x . shape [ <NUM_LIT:1> ] ) : <EOL> desc += \"<STR_LIT>\" % { '<STR_LIT:name>' : var , '<STR_LIT>' : len ( x [ : , var ] ) , '<STR_LIT>' : x [ : , var ] . mean ( ) , <EOL> '<STR_LIT>' : x [ : , var ] . std ( ) , '<STR_LIT>' : '<STR_LIT:(>' + str ( x [ : , var ] . min ( ) ) + '<STR_LIT:U+002CU+0020>' + str ( x [ : , var ] . max ( ) ) + '<STR_LIT:)>' + os . linesep } <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return desc <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import statsmodels . api as sm <EOL> import os <EOL> data = sm . datasets . longley . load ( ) <EOL> data . exog = sm . add_constant ( data . exog , prepend = False ) <EOL> sum1 = descstats ( data . exog ) <EOL> sum1a = descstats ( data . exog [ : , : <NUM_LIT:1> ] ) <EOL> if os . path . isfile ( '<STR_LIT>' ) : <EOL> data2 = np . recfromcsv ( '<STR_LIT>' ) <EOL> sum2 = descstats ( data2 . ahe ) <EOL> sum3 = descstats ( np . column_stack ( ( data2 . ahe , data2 . yrseduc ) ) ) <EOL>", "answer": "sum4 = descstats ( np . column_stack ( ( [ data2 [ _ ] for _ in data2 . dtype . names ] ) ) ) "}, {"prompt": "<s> from django . forms import ModelForm <EOL> from django . utils import translation <EOL> from hvad . admin import TranslatableModelAdminMixin <EOL> from hvad . forms import translatable_inlineformset_factory , translationformset_factory <EOL> from hvad . test_utils . testcase import HvadTestCase <EOL>", "answer": "from hvad . test_utils . project . app . models import Normal , Related"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "from traits . api import on_trait_change"}, {"prompt": "<s> import sys <EOL> import os <EOL> extensions = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> templates_path = [ '<STR_LIT>' ] <EOL> source_suffix = '<STR_LIT>' <EOL> master_doc = '<STR_LIT:index>' <EOL> project = u'<STR_LIT>' <EOL> copyright = u'<STR_LIT>' <EOL> version = '<STR_LIT>' <EOL> release = '<STR_LIT>' <EOL> exclude_patterns = [ '<STR_LIT>' ] <EOL> pygments_style = '<STR_LIT>' <EOL> html_theme = '<STR_LIT:default>' <EOL> html_static_path = [ '<STR_LIT>' ] <EOL> htmlhelp_basename = '<STR_LIT>' <EOL> latex_elements = { <EOL> } <EOL> latex_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> man_pages = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> [ u'<STR_LIT>' ] , <NUM_LIT:1> ) <EOL> ] <EOL> texinfo_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) , <EOL>", "answer": "] "}, {"prompt": "<s> from django . test import TestCase <EOL> from rest_framework_extensions . compat_drf import get_lookup_allowed_symbols <EOL> from rest_framework_extensions . utils import get_rest_framework_features <EOL>", "answer": "from rest_framework_extensions . routers import ExtendedSimpleRouter"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Building ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> import mock <EOL> import random <EOL> import string <EOL> from nose . tools import * <EOL> import website . app <EOL> from webtest_plus import TestApp <EOL> from website . util import api_url_for , web_url_for <EOL> from website . addons . base . testing import AddonTestCase <EOL> from website . addons . badges . util import get_node_badges <EOL> from tests . factories import AuthUserFactory <EOL> from utils import create_mock_badger , create_badge_dict , get_garbage <EOL> class TestBadgesViews ( AddonTestCase ) : <EOL> ADDON_SHORT_NAME = '<STR_LIT>' <EOL> def setUp ( self ) : <EOL> super ( TestBadgesViews , self ) . setUp ( ) <EOL> def set_node_settings ( self , settings ) : <EOL> return settings <EOL> def set_user_settings ( self , settings ) : <EOL> return create_mock_badger ( settings ) <EOL> def create_app ( self ) : <EOL> return TestApp ( app ) <EOL> @ mock . patch ( '<STR_LIT>' ) <EOL> def test_create_badge ( self , img_proc ) : <EOL> img_proc . return_value = '<STR_LIT>' <EOL> badge = create_badge_dict ( ) <EOL> ret = self . app . post_json ( api_url_for ( '<STR_LIT>' ) , badge , auth = self . user . auth ) <EOL> self . user_settings . reload ( ) <EOL> assert_equals ( ret . status_int , <NUM_LIT> ) <EOL> assert_equals ( ret . content_type , '<STR_LIT:application/json>' ) <EOL> assert_true ( ret . json [ '<STR_LIT>' ] in [ badge . _id for badge in self . user_settings . badges ] ) <EOL> @ mock . patch ( '<STR_LIT>' ) <EOL> def test_create_badge_no_data ( self , img_proc ) : <EOL> url = api_url_for ( '<STR_LIT>' ) <EOL> badge = { } <EOL> ret = self . app . post_json ( url , badge , auth = self . user . auth , expect_errors = True ) <EOL> assert_equals ( ret . status_int , <NUM_LIT> ) <EOL> @ mock . patch ( '<STR_LIT>' ) <EOL> def test_create_badge_some_data ( self , img_proc ) : <EOL> img_proc . return_value = '<STR_LIT>' <EOL> url = api_url_for ( '<STR_LIT>' ) <EOL> badge = { <EOL> '<STR_LIT>' : '<STR_LIT>' . join ( random . choice ( string . ascii_lowercase + string . digits ) for _ in range ( <NUM_LIT:4> ) ) , <EOL> '<STR_LIT:description>' : '<STR_LIT>' . join ( random . choice ( string . ascii_letters + string . digits ) for _ in range ( <NUM_LIT:6> ) ) <EOL> } <EOL> ret = self . app . post_json ( url , badge , auth = self . user . auth , expect_errors = True ) <EOL> assert_equals ( ret . status_int , <NUM_LIT> ) <EOL> @ mock . patch ( '<STR_LIT>' ) <EOL> def test_create_badge_empty_data ( self , img_proc ) : <EOL> img_proc . return_value = '<STR_LIT>' <EOL> url = api_url_for ( '<STR_LIT>' ) <EOL> badge = create_badge_dict ( ) <EOL> badge [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> ret = self . app . post_json ( url , badge , auth = self . user . auth , expect_errors = True ) <EOL> assert_equals ( ret . status_int , <NUM_LIT> ) <EOL> @ mock . patch ( '<STR_LIT>' ) <EOL> def test_create_badge_cant_issue ( self , img_proc ) : <EOL> img_proc . return_value = '<STR_LIT>' <EOL> self . user . delete_addon ( '<STR_LIT>' ) <EOL> url = api_url_for ( '<STR_LIT>' ) <EOL> badge = create_badge_dict ( ) <EOL> ret = self . app . post_json ( url , badge , auth = self . user . auth , expect_errors = True ) <EOL> assert_equals ( ret . status_int , <NUM_LIT> ) <EOL> def test_award_badge ( self ) : <EOL> badgeid = self . user_settings . badges [ <NUM_LIT:0> ] . _id <EOL> initnum = get_node_badges ( self . project ) . count ( ) <EOL> assert_true ( self . user_settings . can_award ) <EOL> url = api_url_for ( '<STR_LIT>' , pid = self . project . _id ) <EOL> ret = self . app . post_json ( url , { '<STR_LIT>' : badgeid } , auth = self . user . auth ) <EOL> self . project . reload ( ) <EOL> assert_equals ( ret . status_int , <NUM_LIT:200> ) <EOL> assert_equals ( initnum + <NUM_LIT:1> , get_node_badges ( self . project ) . count ( ) ) <EOL> def test_award_badge_bad_badge_id ( self ) : <EOL> badgeid = '<STR_LIT>' <EOL> assert_true ( self . user_settings . can_award ) <EOL> url = api_url_for ( '<STR_LIT>' , pid = self . project . _id ) <EOL> ret = self . app . post_json ( url , { '<STR_LIT>' : badgeid } , auth = self . user . auth , expect_errors = True ) <EOL> assert_equals ( ret . status_int , <NUM_LIT> ) <EOL> def test_award_badge_empty_badge_id ( self ) : <EOL> assert_true ( self . user_settings . can_award ) <EOL> url = api_url_for ( '<STR_LIT>' , pid = self . project . _id ) <EOL> ret = self . app . post_json ( url , { '<STR_LIT>' : '<STR_LIT>' } , auth = self . user . auth , expect_errors = True ) <EOL> assert_equals ( ret . status_int , <NUM_LIT> ) <EOL> def test_award_badge_no_badge_id ( self ) : <EOL> assert_true ( self . user_settings . can_award ) <EOL> url = api_url_for ( '<STR_LIT>' , pid = self . project . _id ) <EOL> ret = self . app . post_json ( url , { } , auth = self . user . auth , expect_errors = True ) <EOL> assert_equals ( ret . status_int , <NUM_LIT> ) <EOL> @ mock . patch ( '<STR_LIT>' ) <EOL> def test_badge_html ( self , img_proc ) : <EOL> img_proc . return_value = '<STR_LIT>' <EOL> badge = { <EOL> '<STR_LIT>' : get_garbage ( ) , <EOL> '<STR_LIT:description>' : get_garbage ( ) , <EOL> '<STR_LIT>' : get_garbage ( ) , <EOL> '<STR_LIT>' : get_garbage ( ) <EOL> } <EOL> ret = self . app . post_json ( api_url_for ( '<STR_LIT>' ) , badge , auth = self . user . auth ) <EOL> self . user_settings . reload ( ) <EOL> assert_equals ( ret . status_int , <NUM_LIT> ) <EOL> assert_equals ( ret . content_type , '<STR_LIT:application/json>' ) <EOL> assert_true ( ret . json [ '<STR_LIT>' ] in [ badge . _id for badge in self . user_settings . badges ] ) <EOL> with self . app . app . test_request_context ( ) : <EOL> bstr = str ( self . user_settings . badges [ <NUM_LIT:0> ] . to_openbadge ( ) ) <EOL> assert_false ( '<STR_LIT:>>' in bstr ) <EOL> assert_false ( '<STR_LIT:<>' in bstr ) <EOL> def test_revoke_badge ( self ) : <EOL> badgeid = self . user_settings . badges [ <NUM_LIT:0> ] . _id <EOL> initnum = get_node_badges ( self . project ) . count ( ) <EOL> assert_true ( self . user_settings . can_award ) <EOL> url = api_url_for ( '<STR_LIT>' , pid = self . project . _id ) <EOL> ret = self . app . post_json ( url , { '<STR_LIT>' : badgeid } , auth = self . user . auth ) <EOL> self . project . reload ( ) <EOL> assert_equals ( ret . status_int , <NUM_LIT:200> ) <EOL> assert_equals ( initnum + <NUM_LIT:1> , get_node_badges ( self . project ) . count ( ) ) <EOL> assertion = get_node_badges ( self . project ) [ <NUM_LIT:0> ] <EOL> revoke = api_url_for ( '<STR_LIT>' , pid = self . project . _id ) <EOL> ret = self . app . post_json ( revoke , <EOL> { <EOL> '<STR_LIT:id>' : assertion . _id , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , auth = self . user . auth ) <EOL> self . project . reload ( ) <EOL> self . user_settings . reload ( ) <EOL> assertion . reload ( ) <EOL> assert_equals ( ret . status_int , <NUM_LIT:200> ) <EOL> assert_true ( get_node_badges ( self . project ) [ <NUM_LIT:0> ] . _id , assertion . _id ) <EOL> assert_true ( assertion . revoked ) <EOL> assert_true ( assertion . _id in self . user_settings . revocation_list ) <EOL> assert_equals ( len ( self . user_settings . revocation_list ) , <NUM_LIT:1> ) <EOL> def test_revoke_badge_reason ( self ) : <EOL> badgeid = self . user_settings . badges [ <NUM_LIT:0> ] . _id <EOL> initnum = get_node_badges ( self . project ) . count ( ) <EOL> assert_true ( self . user_settings . can_award ) <EOL> url = api_url_for ( '<STR_LIT>' , pid = self . project . _id ) <EOL> ret = self . app . post_json ( url , { '<STR_LIT>' : badgeid } , auth = self . user . auth ) <EOL> self . project . reload ( ) <EOL> assert_equals ( ret . status_int , <NUM_LIT:200> ) <EOL> assert_equals ( initnum + <NUM_LIT:1> , get_node_badges ( self . project ) . count ( ) ) <EOL> assertion = get_node_badges ( self . project ) [ <NUM_LIT:0> ] <EOL> revoke = api_url_for ( '<STR_LIT>' , pid = self . project . _id ) <EOL> ret = self . app . post_json ( revoke , <EOL> { <EOL> '<STR_LIT:id>' : assertion . _id , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , auth = self . user . auth ) <EOL> self . project . reload ( ) <EOL> self . user_settings . reload ( ) <EOL> assertion . reload ( ) <EOL> assert_equals ( ret . status_int , <NUM_LIT:200> ) <EOL> assert_true ( get_node_badges ( self . project ) [ <NUM_LIT:0> ] . _id , assertion . _id ) <EOL> assert_true ( assertion . _id in self . user_settings . revocation_list ) <EOL> assert_equals ( len ( self . user_settings . revocation_list ) , <NUM_LIT:1> ) <EOL> assert_true ( assertion . revoked ) <EOL> assert_equals ( self . user_settings . revocation_list [ assertion . _id ] , '<STR_LIT>' ) <EOL> def test_revoke_badge_no_addon ( self ) : <EOL> badgeid = self . user_settings . badges [ <NUM_LIT:0> ] . _id <EOL> initnum = get_node_badges ( self . project ) . count ( ) <EOL> assert_true ( self . user_settings . can_award ) <EOL> url = api_url_for ( '<STR_LIT>' , pid = self . project . _id ) <EOL> ret = self . app . post_json ( url , { '<STR_LIT>' : badgeid } , auth = self . user . auth ) <EOL> self . project . reload ( ) <EOL> assert_equals ( ret . status_int , <NUM_LIT:200> ) <EOL> assert_equals ( initnum + <NUM_LIT:1> , get_node_badges ( self . project ) . count ( ) ) <EOL> assertion = get_node_badges ( self . project ) [ <NUM_LIT:0> ] <EOL> revoke = api_url_for ( '<STR_LIT>' , pid = self . project . _id ) <EOL> self . user . delete_addon ( '<STR_LIT>' ) <EOL> self . user . save ( ) <EOL> self . user . reload ( ) <EOL> ret = self . app . post_json ( revoke , <EOL> { <EOL> '<STR_LIT:id>' : assertion . _id , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , auth = self . user . auth , expect_errors = True ) <EOL> self . project . reload ( ) <EOL> self . user_settings . reload ( ) <EOL> assertion . reload ( ) <EOL>", "answer": "assert_equals ( ret . status_int , <NUM_LIT> )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . db import models <EOL> class Publication ( models . Model ) : <EOL> title = models . CharField ( max_length = <NUM_LIT:30> ) <EOL> def __unicode__ ( self ) : <EOL>", "answer": "return self . title"}, {"prompt": "<s> class SessionInterface ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , host = '<STR_LIT:127.0.0.1>' , port = <NUM_LIT> , db_name = None ) : <EOL> self . host = host <EOL> self . port = port <EOL> self . db_name = db_name <EOL> self . _db = None <EOL> self . _setup_connection ( ) <EOL> def _setup_connection ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class CollectionModelInterface ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , session , model ) : <EOL> self . session = session <EOL> self . model = model <EOL> if type ( self . model ) == type : <EOL> self . collection_name = self . model . __name__ <EOL> else : <EOL> self . collection_name = type ( self . model ) . __name__ <EOL> def _return_model_object ( self , d ) : <EOL> if d : <EOL> this_model = self . model . create ( d ) <EOL> return this_model <EOL>", "answer": "else :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import unicode_literals <EOL> import logging <EOL> from django . conf import settings <EOL> from django . db import models <EOL> from django . db . models . base import ModelBase <EOL> from django . db . models . sql import compiler <EOL> from django . db . models import PROTECT , DO_NOTHING <EOL> from django . utils . deconstruct import deconstructible <EOL> from django . utils . six import with_metaclass <EOL> from salesforce . backend import manager <EOL> from salesforce . fields import SalesforceAutoField , SF_PK <EOL> from salesforce . fields import * <EOL> from salesforce import DJANGO_18_PLUS <EOL> log = logging . getLogger ( __name__ ) <EOL> class SalesforceModelBase ( ModelBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __new__ ( cls , name , bases , attrs ) : <EOL> attr_meta = attrs . get ( '<STR_LIT:Meta>' , None ) <EOL> if not DJANGO_18_PLUS and len ( getattr ( attr_meta , '<STR_LIT>' , '<STR_LIT>' ) ) > <NUM_LIT> : <EOL> attr_meta . verbose_name = attr_meta . verbose_name [ : <NUM_LIT> ] <EOL> supplied_db_table = getattr ( attr_meta , '<STR_LIT>' , None ) <EOL> result = super ( SalesforceModelBase , cls ) . __new__ ( cls , name , bases , attrs ) <EOL> if models . Model not in bases and supplied_db_table is None : <EOL> result . _meta . db_table = result . _meta . concrete_model . _meta . object_name <EOL> return result <EOL> def add_to_class ( cls , name , value ) : <EOL> if name == '<STR_LIT>' : <EOL> sf_custom = False <EOL> if hasattr ( value . meta , '<STR_LIT>' ) : <EOL> sf_custom = value . meta . custom <EOL> delattr ( value . meta , '<STR_LIT>' ) <EOL> super ( SalesforceModelBase , cls ) . add_to_class ( name , value ) <EOL> setattr ( cls . _meta , '<STR_LIT>' , sf_custom ) <EOL> else : <EOL> if type ( value ) is models . manager . Manager : <EOL> value = manager . SalesforceManager ( ) <EOL> super ( SalesforceModelBase , cls ) . add_to_class ( name , value ) <EOL> class SalesforceModel ( with_metaclass ( SalesforceModelBase , models . Model ) ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from __future__ import ( absolute_import , division , print_function , <EOL> unicode_literals ) <EOL> import collections <EOL> import inspect <EOL> import gevent <EOL> import functools <EOL> import copy <EOL> class EasyDecorator ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _instance = None <EOL> _thing = _othing = None <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . args = [ ] <EOL> self . kwargs = { } <EOL> if len ( args ) == <NUM_LIT:1> and not kwargs and ( inspect . isclass ( args [ <NUM_LIT:0> ] ) or isinstance ( args [ <NUM_LIT:0> ] , <EOL> collections . Callable ) ) : <EOL> self . _thing = args [ <NUM_LIT:0> ] <EOL> self . _mimic ( ) <EOL> else : <EOL> self . args = args <EOL> self . kwargs = kwargs <EOL> def _mimic ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for n in set ( dir ( self . _thing ) ) - set ( dir ( self ) ) : <EOL> setattr ( self , n , getattr ( self . _thing , n ) ) <EOL> self . __name__ = self . _thing . __name__ <EOL> self . __doc__ = self . _thing . __doc__ <EOL> def wrapper ( self , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . call ( * args , ** kwargs ) <EOL> def call ( self , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _thing ( * args , ** kwargs ) <EOL> def __get__ ( self , instance , klass ) : <EOL> self . _instance = instance <EOL> if self . _othing is None : <EOL> self . _othing = self . _thing <EOL> self . _thing = self . _othing . __get__ ( instance , klass ) <EOL> return copy . copy ( self ) <EOL> def __call__ ( self , * args , ** kwargs ) : <EOL> if self . _thing : <EOL> return self . wrapper ( * args , ** kwargs ) <EOL> else : <EOL> self . _thing = args [ <NUM_LIT:0> ] <EOL> self . _mimic ( ) <EOL> return self <EOL> def filterintree ( adict , block , stype = str , history = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not adict : <EOL> return adict <EOL> if history is None : <EOL> history = set ( ) <EOL> if id ( adict ) in history : <EOL> return <EOL> else : <EOL> history . add ( id ( adict ) ) <EOL> if isinstance ( adict , list ) : <EOL> for i in xrange ( len ( adict ) ) : <EOL> if isinstance ( adict [ i ] , stype ) : <EOL> adict [ i ] = block ( adict [ i ] ) <EOL> elif isinstance ( adict [ i ] , ( set , tuple ) ) : <EOL> adict [ i ] = filterintree ( adict [ i ] , block , stype , history ) <EOL> elif isinstance ( adict [ i ] , ( list , dict ) ) : <EOL> filterintree ( adict [ i ] , block , stype , history ) <EOL> elif isinstance ( adict , ( set , tuple ) ) : <EOL> c = list ( adict ) <EOL> filterintree ( c , block , stype , history ) <EOL> return type ( adict ) ( c ) <EOL> elif isinstance ( adict , dict ) : <EOL> for k , v in adict . iteritems ( ) : <EOL> if isinstance ( v , stype ) : <EOL> adict [ k ] = block ( v ) <EOL> elif isinstance ( v , ( dict , list ) ) : <EOL> filterintree ( v , block , stype , history ) <EOL> elif isinstance ( v , ( set , tuple ) ) : <EOL> adict [ k ] = filterintree ( v , block , stype , history ) <EOL> class utf8Decode ( EasyDecorator ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def wrapper ( self , * args , ** kwargs ) : <EOL> def decode ( s ) : <EOL> return s . decode ( '<STR_LIT:utf-8>' , '<STR_LIT:ignore>' ) <EOL> args = filterintree ( args , decode ) <EOL> filterintree ( kwargs , decode ) <EOL> return self . call ( * args , ** kwargs ) <EOL> class returnValue ( EasyDecorator ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def wrapper ( self , * args , ** kwargs ) : <EOL> def decode ( s ) : <EOL> return s . decode ( '<STR_LIT:utf-8>' , '<STR_LIT:ignore>' ) <EOL> value = [ self . call ( * args , ** kwargs ) ] <EOL> filterintree ( value , decode ) <EOL> return value [ <NUM_LIT:0> ] <EOL> class utf8Encode ( EasyDecorator ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def wrapper ( self , * args , ** kwargs ) : <EOL> def encode ( s ) : <EOL> return s . encode ( '<STR_LIT:utf-8>' , '<STR_LIT>' ) <EOL>", "answer": "args = filterintree ( args , encode , stype = unicode )"}, {"prompt": "<s> from pypy . rpython . ootypesystem import ootype <EOL> from pypy . translator . cli . node import Node <EOL> from pypy . translator . cli . cts import CTS <EOL> class Record ( Node ) : <EOL> def __init__ ( self , db , record , name ) : <EOL> self . db = db <EOL> self . cts = CTS ( db ) <EOL> self . record = record <EOL> self . name = name <EOL> def __hash__ ( self ) : <EOL> return hash ( self . record ) <EOL> def __eq__ ( self , other ) : <EOL> return self . record == other . record <EOL> def __ne__ ( self , other ) : <EOL> return not self == other <EOL>", "answer": "def get_name ( self ) :"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . import handler <EOL> from . _exceptions import SAXNotSupportedException , SAXNotRecognizedException <EOL> class XMLReader : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> self . _cont_handler = handler . ContentHandler ( ) <EOL> self . _dtd_handler = handler . DTDHandler ( ) <EOL> self . _ent_handler = handler . EntityResolver ( ) <EOL> self . _err_handler = handler . ErrorHandler ( ) <EOL> def parse ( self , source ) : <EOL> \"<STR_LIT>\" <EOL> raise NotImplementedError ( \"<STR_LIT>\" ) <EOL> def getContentHandler ( self ) : <EOL> \"<STR_LIT>\" <EOL> return self . _cont_handler <EOL> def setContentHandler ( self , handler ) : <EOL> \"<STR_LIT>\" <EOL> self . _cont_handler = handler <EOL> def getDTDHandler ( self ) : <EOL> \"<STR_LIT>\" <EOL> return self . _dtd_handler <EOL> def setDTDHandler ( self , handler ) : <EOL> \"<STR_LIT>\" <EOL> self . _dtd_handler = handler <EOL> def getEntityResolver ( self ) : <EOL> \"<STR_LIT>\" <EOL> return self . _ent_handler <EOL> def setEntityResolver ( self , resolver ) : <EOL> \"<STR_LIT>\" <EOL>", "answer": "self . _ent_handler = resolver"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> assignment_format_schema = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT:title>' : '<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , division , print_function <EOL> import math <EOL> import numpy as np <EOL> from . import rectangle , vector , vector3 <EOL> from . utils import all_parameters_as_numpy_arrays , parameters_as_numpy_arrays <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ all_parameters_as_numpy_arrays <EOL> def point_intersect_line ( point , line ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rl = line [ <NUM_LIT:1> ] - line [ <NUM_LIT:0> ] <EOL> rp = point - line [ <NUM_LIT:0> ] <EOL> cross = vector3 . cross ( rl , rp ) <EOL> if np . count_nonzero ( cross ) > <NUM_LIT:0> : <EOL> return None <EOL> return point <EOL> @ all_parameters_as_numpy_arrays <EOL> def point_intersect_line_segment ( point , line ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rl = line [ <NUM_LIT:1> ] - line [ <NUM_LIT:0> ] <EOL> rp = point - line [ <NUM_LIT:0> ] <EOL> cross = vector3 . cross ( rl , rp ) <EOL> dot = vector . dot ( rp , rl ) <EOL> squared_length = vector . squared_length ( rl ) <EOL> if np . count_nonzero ( cross ) > <NUM_LIT:0> : <EOL> return None <EOL> if dot < <NUM_LIT:0.0> or dot > squared_length : <EOL> return None <EOL> return point <EOL> @ all_parameters_as_numpy_arrays <EOL>", "answer": "def point_intersect_rectangle ( point , rect ) :"}, {"prompt": "<s> from __future__ import absolute_import , unicode_literals <EOL> from ... unittest import TestCase <EOL> from oauthlib . oauth2 import RequestValidator <EOL> class RequestValidatorTest ( TestCase ) : <EOL> def test_method_contracts ( self ) : <EOL> v = RequestValidator ( ) <EOL> self . assertRaises ( NotImplementedError , v . authenticate_client , '<STR_LIT:r>' ) <EOL> self . assertRaises ( NotImplementedError , v . authenticate_client_id , <EOL> '<STR_LIT>' , '<STR_LIT:r>' ) <EOL> self . assertRaises ( NotImplementedError , v . confirm_redirect_uri , <EOL> '<STR_LIT>' , '<STR_LIT:code>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertRaises ( NotImplementedError , v . get_default_redirect_uri , <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertRaises ( NotImplementedError , v . get_default_scopes , <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertRaises ( NotImplementedError , v . get_original_scopes , <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertFalse ( v . is_within_original_scope ( <EOL> [ '<STR_LIT>' ] , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> self . assertRaises ( NotImplementedError , v . invalidate_authorization_code , <EOL> '<STR_LIT>' , '<STR_LIT:code>' , '<STR_LIT>' ) <EOL> self . assertRaises ( NotImplementedError , v . save_authorization_code , <EOL> '<STR_LIT>' , '<STR_LIT:code>' , '<STR_LIT>' ) <EOL> self . assertRaises ( NotImplementedError , v . save_bearer_token , <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertRaises ( NotImplementedError , v . validate_bearer_token , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertRaises ( NotImplementedError , v . validate_client_id , <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertRaises ( NotImplementedError , v . validate_code , <EOL> '<STR_LIT>' , '<STR_LIT:code>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertRaises ( NotImplementedError , v . validate_grant_type , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertRaises ( NotImplementedError , v . validate_redirect_uri , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertRaises ( NotImplementedError , v . validate_refresh_token , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . assertRaises ( NotImplementedError , v . validate_response_type , <EOL>", "answer": "'<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' )"}, {"prompt": "<s> __author__ = '<STR_LIT>' <EOL> __copyright__ = '<STR_LIT>' <EOL> __licence__ = '<STR_LIT>' <EOL> from itertools import islice <EOL> try : <EOL> import itertools . izip as zip <EOL> except ImportError : <EOL> pass <EOL> from nose . tools import eq_ , ok_ <EOL> class BaseSSHSuite ( ) : <EOL> proxmox = None <EOL> client = None <EOL> session = None <EOL> def _split_cmd ( self , cmd ) : <EOL> splitted = cmd . split ( ) <EOL> eq_ ( splitted [ <NUM_LIT:0> ] , '<STR_LIT>' ) <EOL> options_set = set ( ( '<STR_LIT:U+0020>' . join ( ( k , v ) ) for k , v in <EOL> zip ( islice ( splitted , <NUM_LIT:3> , None , <NUM_LIT:2> ) , islice ( splitted , <NUM_LIT:4> , None , <NUM_LIT:2> ) ) ) ) <EOL> return '<STR_LIT:U+0020>' . join ( splitted [ <NUM_LIT:1> : <NUM_LIT:3> ] ) , options_set <EOL> def _get_called_cmd ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def _set_stdout ( self , stdout ) : <EOL> raise NotImplementedError ( ) <EOL> def _set_stderr ( self , stderr ) : <EOL> raise NotImplementedError ( ) <EOL> def test_get ( self ) : <EOL> self . _set_stdout ( \"\"\"<STR_LIT>\"\"\" ) <EOL> result = self . proxmox . nodes ( '<STR_LIT>' ) . storage ( '<STR_LIT>' ) . get ( ) <EOL> eq_ ( self . _get_called_cmd ( ) , '<STR_LIT>' ) <EOL> eq_ ( result [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , '<STR_LIT:status>' ) <EOL> eq_ ( result [ <NUM_LIT:1> ] [ '<STR_LIT>' ] , '<STR_LIT:content>' ) <EOL> eq_ ( result [ <NUM_LIT:2> ] [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> eq_ ( result [ <NUM_LIT:3> ] [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> eq_ ( result [ <NUM_LIT:4> ] [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> def test_delete ( self ) : <EOL> self . proxmox . nodes ( '<STR_LIT>' ) . openvz ( <NUM_LIT:100> ) . delete ( ) <EOL> eq_ ( self . _get_called_cmd ( ) , '<STR_LIT>' ) <EOL> self . proxmox . nodes ( '<STR_LIT>' ) . openvz ( '<STR_LIT>' ) . delete ( ) <EOL> eq_ ( self . _get_called_cmd ( ) , '<STR_LIT>' ) <EOL> self . proxmox . nodes ( '<STR_LIT>' ) . openvz . delete ( '<STR_LIT>' ) <EOL> eq_ ( self . _get_called_cmd ( ) , '<STR_LIT>' ) <EOL> def test_post ( self ) : <EOL> node = self . proxmox . nodes ( '<STR_LIT>' ) <EOL> node . openvz . create ( vmid = <NUM_LIT> , <EOL> ostemplate = '<STR_LIT>' , <EOL> hostname = '<STR_LIT:test>' , <EOL> storage = '<STR_LIT>' , <EOL> memory = <NUM_LIT> , <EOL> swap = <NUM_LIT> , <EOL> cpus = <NUM_LIT:1> , <EOL> disk = <NUM_LIT:4> , <EOL> password = '<STR_LIT>' , <EOL> ip_address = '<STR_LIT>' ) <EOL> cmd , options = self . _split_cmd ( self . _get_called_cmd ( ) ) <EOL> eq_ ( cmd , '<STR_LIT>' ) <EOL> ok_ ( '<STR_LIT>' in options ) <EOL> ok_ ( '<STR_LIT>' in options ) <EOL> ok_ ( '<STR_LIT>' in options ) <EOL> ok_ ( '<STR_LIT>' in options ) <EOL> ok_ ( '<STR_LIT>' in options ) <EOL> ok_ ( '<STR_LIT>' in options ) <EOL> ok_ ( '<STR_LIT>' in options ) <EOL> ok_ ( '<STR_LIT>' in options ) <EOL> ok_ ( '<STR_LIT>' in options ) <EOL> ok_ ( '<STR_LIT>' in options ) <EOL> node = self . proxmox . nodes ( '<STR_LIT>' ) <EOL> node . openvz . post ( vmid = <NUM_LIT> , <EOL> ostemplate = '<STR_LIT>' , <EOL>", "answer": "hostname = '<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from six . moves import range <EOL> from docutils import nodes <EOL> from docutils . parsers . rst import Directive , directives <EOL> from docutils . parsers . rst . directives . admonitions import BaseAdmonition <EOL> from docutils . parsers . rst . directives . misc import Class <EOL> from docutils . parsers . rst . directives . misc import Include as BaseInclude <EOL> from sphinx import addnodes <EOL> from sphinx . locale import versionlabels , _ <EOL> from sphinx . util import url_re , docname_join <EOL> from sphinx . util . nodes import explicit_title_re , set_source_info , process_index_entry <EOL> from sphinx . util . matching import patfilter <EOL> def int_or_nothing ( argument ) : <EOL> if not argument : <EOL> return <NUM_LIT> <EOL> return int ( argument ) <EOL> class TocTree ( Directive ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> has_content = True <EOL> required_arguments = <NUM_LIT:0> <EOL> optional_arguments = <NUM_LIT:0> <EOL> final_argument_whitespace = False <EOL> option_spec = { <EOL> '<STR_LIT>' : int , <EOL> '<STR_LIT:name>' : directives . unchanged , <EOL> '<STR_LIT>' : directives . unchanged_required , <EOL> '<STR_LIT>' : directives . flag , <EOL> '<STR_LIT>' : directives . flag , <EOL> '<STR_LIT>' : directives . flag , <EOL> '<STR_LIT>' : int_or_nothing , <EOL> '<STR_LIT>' : directives . flag , <EOL> } <EOL> def run ( self ) : <EOL> env = self . state . document . settings . env <EOL> suffixes = env . config . source_suffix <EOL> glob = '<STR_LIT>' in self . options <EOL> caption = self . options . get ( '<STR_LIT>' ) <EOL> if caption : <EOL> self . options . setdefault ( '<STR_LIT:name>' , nodes . fully_normalize_name ( caption ) ) <EOL> ret = [ ] <EOL> entries = [ ] <EOL> includefiles = [ ] <EOL> all_docnames = env . found_docs . copy ( ) <EOL> all_docnames . remove ( env . docname ) <EOL> for entry in self . content : <EOL> if not entry : <EOL> continue <EOL> if glob and ( '<STR_LIT:*>' in entry or '<STR_LIT:?>' in entry or '<STR_LIT:[>' in entry ) : <EOL> patname = docname_join ( env . docname , entry ) <EOL> docnames = sorted ( patfilter ( all_docnames , patname ) ) <EOL> for docname in docnames : <EOL> all_docnames . remove ( docname ) <EOL> entries . append ( ( None , docname ) ) <EOL> includefiles . append ( docname ) <EOL> if not docnames : <EOL> ret . append ( self . state . document . reporter . warning ( <EOL> '<STR_LIT>' <EOL> % entry , line = self . lineno ) ) <EOL> else : <EOL> m = explicit_title_re . match ( entry ) <EOL> if m : <EOL> ref = m . group ( <NUM_LIT:2> ) <EOL> title = m . group ( <NUM_LIT:1> ) <EOL> docname = ref <EOL> else : <EOL> ref = docname = entry <EOL> title = None <EOL> for suffix in suffixes : <EOL> if docname . endswith ( suffix ) : <EOL> docname = docname [ : - len ( suffix ) ] <EOL> break <EOL> docname = docname_join ( env . docname , docname ) <EOL> if url_re . match ( ref ) or ref == '<STR_LIT>' : <EOL> entries . append ( ( title , ref ) ) <EOL> elif docname not in env . found_docs : <EOL> ret . append ( self . state . document . reporter . warning ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' % docname , line = self . lineno ) ) <EOL> env . note_reread ( ) <EOL> else : <EOL> all_docnames . discard ( docname ) <EOL> entries . append ( ( title , docname ) ) <EOL> includefiles . append ( docname ) <EOL> subnode = addnodes . toctree ( ) <EOL> subnode [ '<STR_LIT>' ] = env . docname <EOL> subnode [ '<STR_LIT>' ] = entries <EOL> subnode [ '<STR_LIT>' ] = includefiles <EOL> subnode [ '<STR_LIT>' ] = self . options . get ( '<STR_LIT>' , - <NUM_LIT:1> ) <EOL> subnode [ '<STR_LIT>' ] = caption <EOL> subnode [ '<STR_LIT>' ] = glob <EOL> subnode [ '<STR_LIT>' ] = '<STR_LIT>' in self . options <EOL> subnode [ '<STR_LIT>' ] = '<STR_LIT>' in self . options <EOL> subnode [ '<STR_LIT>' ] = self . options . get ( '<STR_LIT>' , <NUM_LIT:0> ) <EOL> subnode [ '<STR_LIT>' ] = '<STR_LIT>' in self . options <EOL> set_source_info ( self , subnode ) <EOL> wrappernode = nodes . compound ( classes = [ '<STR_LIT>' ] ) <EOL> wrappernode . append ( subnode ) <EOL> self . add_name ( wrappernode ) <EOL> ret . append ( wrappernode ) <EOL> return ret <EOL> class Author ( Directive ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "has_content = False"}, {"prompt": "<s> from unittest import TestCase <EOL> from mock import patch , MagicMock , call <EOL> from nose . tools import ok_ , eq_ <EOL> from pylease . ex import PyleaseError <EOL> from pylease import Pylease , InfoContainer <EOL> from pylease . util import SubclassIgnoreMark <EOL> from pylease . cmd import Command , NamedCommand <EOL> from pylease . cmd . task import BeforeTask , AfterTask <EOL> class CommandTest ( TestCase ) : <EOL> def test_command_global_init_should_ignore_marked_commands ( self ) : <EOL> inited = [ ] <EOL> class C0 ( Command ) : <EOL> def __init__ ( self , dummy ) : <EOL> super ( C0 , self ) . __init__ ( dummy , '<STR_LIT>' , '<STR_LIT>' ) <EOL> inited . append ( self . __class__ ) <EOL> def _process_command ( self , lizy , args ) : <EOL> pass <EOL> def _get_name ( self ) : <EOL> pass <EOL> class C1 ( C0 ) : <EOL> ignore_me = SubclassIgnoreMark ( '<STR_LIT>' ) <EOL> class C2 ( C1 ) : <EOL> pass <EOL> cmd_subparser = MagicMock ( ) <EOL> cmd_subparser . add_parser = MagicMock ( ) <EOL> Command . init_all ( Pylease ( None , cmd_subparser , None ) ) <EOL> ok_ ( C0 in inited ) <EOL> ok_ ( C1 not in inited ) <EOL> ok_ ( C2 in inited ) <EOL> def test_named_command_class_should_set_command_name_if_not_defined ( self ) : <EOL> description = '<STR_LIT>' <EOL> class SomeCommand ( NamedCommand ) : <EOL> def __init__ ( self , lizy ) : <EOL> super ( SomeCommand , self ) . __init__ ( lizy , description ) <EOL> def _process_command ( self , lizy , args ) : <EOL> return None , None <EOL> subparser_mock = lambda : <NUM_LIT:0> <EOL> subparser_mock . add_parser = MagicMock ( ) <EOL> no_name = SomeCommand ( Pylease ( None , subparser_mock , None ) ) <EOL> eq_ ( no_name . name , '<STR_LIT>' ) <EOL> subparser_mock . add_parser . assert_called_once_with ( '<STR_LIT>' , help = description ) <EOL> def test_calling_command_instance_should_fire_process_command_method ( self ) : <EOL> class C ( Command ) : <EOL> def __init__ ( self , lizy ) : <EOL> super ( C , self ) . __init__ ( lizy , '<STR_LIT:C>' , '<STR_LIT>' ) <EOL> def _process_command ( self , lizy , args ) : <EOL> return None , None <EOL> with patch . object ( C , '<STR_LIT>' ) as process_command : <EOL> process_command . return_value = None , None <EOL> subparser_mock = lambda : <NUM_LIT:0> <EOL> subparser_mock . add_parser = MagicMock ( ) <EOL> args_mock = lambda : <NUM_LIT:0> <EOL> args_mock . verbose = False <EOL> info_container = InfoContainer ( ) <EOL> info_container . is_empty = False <EOL> lizy = Pylease ( None , subparser_mock , info_container ) <EOL> c = C ( lizy ) <EOL> c ( args_mock ) <EOL> process_command . assert_called_once_with ( lizy , args_mock ) <EOL> def test_init_all_should_add_all_commands_to_lizy ( self ) : <EOL> class Base ( NamedCommand ) : <EOL> def __init__ ( self , lizy , description ) : <EOL> super ( Base , self ) . __init__ ( lizy , description ) <EOL> ignore_me = SubclassIgnoreMark ( '<STR_LIT>' ) <EOL> def _process_command ( self , lizy , args ) : <EOL> pass <EOL> class A ( Command ) : <EOL> NAME = '<STR_LIT:A>' <EOL> DESC = '<STR_LIT>' <EOL> def __init__ ( self , lizy ) : <EOL> super ( A , self ) . __init__ ( lizy , self . NAME , self . DESC ) <EOL> def _process_command ( self , lizy , args ) : <EOL> pass <EOL> class BCommand ( Base ) : <EOL> NAME = '<STR_LIT:B>' <EOL> DESC = '<STR_LIT>' <EOL> def __init__ ( self , lizy ) : <EOL> super ( BCommand , self ) . __init__ ( lizy , self . DESC ) <EOL> class CCommand ( Base ) : <EOL> NAME = '<STR_LIT:C>' <EOL> DESC = '<STR_LIT>' <EOL> def __init__ ( self , lizy ) : <EOL> super ( CCommand , self ) . __init__ ( lizy , self . DESC ) <EOL> subparser_mock = lambda : <NUM_LIT:0> <EOL> subparser_mock . add_parser = MagicMock ( ) <EOL> lizy = Pylease ( None , subparser_mock , None ) <EOL> Command . init_all ( lizy ) <EOL> calls = [ call ( A . NAME , help = A . DESC ) , call ( BCommand . NAME . lower ( ) , help = BCommand . DESC ) , <EOL> call ( CCommand . NAME . lower ( ) , help = CCommand . DESC ) ] <EOL> subparser_mock . add_parser . assert_has_calls ( calls , any_order = True ) <EOL> def test_command_must_execute_before_tasks_before_self_execution ( self ) : <EOL> class SuccessCommand ( NamedCommand ) : <EOL> def __init__ ( self , lizy ) : <EOL> super ( SuccessCommand , self ) . __init__ ( lizy , '<STR_LIT>' ) <EOL> def _process_command ( self , lizy , args ) : <EOL> return None , None <EOL> before = MagicMock ( ) <EOL> after = MagicMock ( ) <EOL> lizy = MagicMock ( ) <EOL> args = MagicMock ( ) <EOL> info_container = InfoContainer ( ) <EOL> info_container . is_empty = False <EOL> lizy . info_container = info_container <EOL> sc = SuccessCommand ( lizy ) <EOL> sc . add_before_task ( before ) <EOL> sc . add_after_task ( after ) <EOL> sc ( args ) <EOL> before . assert_called_once_with ( lizy , args ) <EOL> after . assert_called_once_with ( lizy , args ) <EOL> def test_command_must_not_execute_after_tasks_in_case_of_failure ( self ) : <EOL> class FailureCommand ( NamedCommand ) : <EOL> def __init__ ( self , lizy ) : <EOL> super ( FailureCommand , self ) . __init__ ( lizy , '<STR_LIT>' ) <EOL> def _process_command ( self , lizy , args ) : <EOL> raise PyleaseError ( ) <EOL> before = MagicMock ( ) <EOL> after = MagicMock ( ) <EOL> lizy = MagicMock ( ) <EOL> args = MagicMock ( ) <EOL> info_container = InfoContainer ( ) <EOL> info_container . is_empty = False <EOL> lizy . info_container = info_container <EOL> sc = FailureCommand ( lizy ) <EOL> sc . add_before_task ( before ) <EOL> sc . add_after_task ( after ) <EOL> sc ( args ) <EOL> before . assert_called_once_with ( lizy , args ) <EOL> ok_ ( not after . called ) <EOL> def test_all_actions_must_be_rolled_back_on_failure ( self ) : <EOL> before_rollback = MagicMock ( ) <EOL> command_rollback = MagicMock ( ) <EOL> after_rollback = MagicMock ( ) <EOL> class RollbackTestCommand ( NamedCommand ) : <EOL> def __init__ ( self , lizy ) : <EOL> super ( RollbackTestCommand , self ) . __init__ ( lizy , '<STR_LIT>' , command_rollback ) <EOL> def _process_command ( self , lizy , args ) : <EOL> return None <EOL> class B ( BeforeTask ) : <EOL> def __init__ ( self ) : <EOL> super ( B , self ) . __init__ ( before_rollback ) <EOL> self . enable_rollback ( before_rollback ) <EOL> def execute ( self , lizy , args ) : <EOL> pass <EOL> class A ( AfterTask ) : <EOL> def __init__ ( self ) : <EOL> super ( A , self ) . __init__ ( after_rollback ) <EOL> self . _needs_rollback = True <EOL> def execute ( self , lizy , args ) : <EOL>", "answer": "raise PyleaseError ( )"}, {"prompt": "<s> import hotshot <EOL> import hotshot . stats <EOL> import sys <EOL> import tempfile <EOL> from cStringIO import StringIO <EOL> from django . conf import settings <EOL> class ProfileMiddleware ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def process_request ( self , request ) : <EOL> if settings . DEBUG and '<STR_LIT>' in request . GET : <EOL> self . tmpfile = tempfile . NamedTemporaryFile ( ) <EOL> self . prof = hotshot . Profile ( self . tmpfile . name ) <EOL> def process_view ( self , request , callback , callback_args , callback_kwargs ) : <EOL> if settings . DEBUG and '<STR_LIT>' in request . GET : <EOL>", "answer": "return self . prof . runcall ( callback , request ,"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __docformat__ = '<STR_LIT>' <EOL> from mock import patch <EOL> from nose . tools import assert_is_instance <EOL> from six . moves . urllib . parse import urlparse <EOL>", "answer": "from ... api import create_handle , create_collection , whereis"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> import voluptuous as vol <EOL> import homeassistant . components . rfxtrx as rfxtrx <EOL> import homeassistant . helpers . config_validation as cv <EOL> from homeassistant . helpers . entity import Entity <EOL> from homeassistant . util import slugify <EOL> from homeassistant . components . rfxtrx import ( <EOL> ATTR_AUTOMATIC_ADD , ATTR_NAME , <EOL> CONF_DEVICES , ATTR_DATA_TYPE , DATA_TYPES ) <EOL> DEPENDENCIES = [ '<STR_LIT>' ] <EOL> _LOGGER = logging . getLogger ( __name__ ) <EOL> PLATFORM_SCHEMA = vol . Schema ( { <EOL> vol . Required ( \"<STR_LIT>\" ) : rfxtrx . DOMAIN , <EOL> vol . Optional ( CONF_DEVICES , default = { } ) : vol . All ( dict , rfxtrx . valid_sensor ) , <EOL> vol . Optional ( ATTR_AUTOMATIC_ADD , default = False ) : cv . boolean , <EOL> } , extra = vol . ALLOW_EXTRA ) <EOL> def setup_platform ( hass , config , add_devices_callback , discovery_info = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from RFXtrx import SensorEvent <EOL> sensors = [ ] <EOL> for packet_id , entity_info in config [ '<STR_LIT>' ] . items ( ) : <EOL> event = rfxtrx . get_rfx_object ( packet_id ) <EOL> device_id = \"<STR_LIT>\" + slugify ( event . device . id_string . lower ( ) ) <EOL> if device_id in rfxtrx . RFX_DEVICES : <EOL> continue <EOL> _LOGGER . info ( \"<STR_LIT>\" , entity_info [ ATTR_NAME ] ) <EOL> sub_sensors = { } <EOL> data_types = entity_info [ ATTR_DATA_TYPE ] <EOL> if len ( data_types ) == <NUM_LIT:0> : <EOL> for data_type in DATA_TYPES : <EOL> if data_type in event . values : <EOL> data_types = [ data_type ] <EOL> break <EOL> for _data_type in data_types : <EOL> new_sensor = RfxtrxSensor ( event , entity_info [ ATTR_NAME ] , <EOL> _data_type ) <EOL> sensors . append ( new_sensor ) <EOL> sub_sensors [ _data_type ] = new_sensor <EOL> rfxtrx . RFX_DEVICES [ device_id ] = sub_sensors <EOL> add_devices_callback ( sensors ) <EOL> def sensor_update ( event ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( event , SensorEvent ) : <EOL> return <EOL> device_id = \"<STR_LIT>\" + slugify ( event . device . id_string . lower ( ) ) <EOL> if device_id in rfxtrx . RFX_DEVICES : <EOL> sensors = rfxtrx . RFX_DEVICES [ device_id ] <EOL> for key in sensors : <EOL> sensors [ key ] . event = event <EOL> return <EOL> if not config [ ATTR_AUTOMATIC_ADD ] : <EOL> return <EOL> pkt_id = \"<STR_LIT>\" . join ( \"<STR_LIT>\" . format ( x ) for x in event . data ) <EOL> _LOGGER . info ( \"<STR_LIT>\" , <EOL> device_id ) <EOL> for data_type in DATA_TYPES : <EOL> if data_type in event . values : <EOL>", "answer": "new_sensor = RfxtrxSensor ( event , pkt_id , data_type )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "from envisage . api import Plugin"}, {"prompt": "<s> from setuptools import setup <EOL> def get_version ( ) : <EOL> with open ( '<STR_LIT>' ) as f : <EOL> for line in f : <EOL> if line . startswith ( '<STR_LIT>' ) : <EOL> return eval ( line . split ( '<STR_LIT:=>' ) [ - <NUM_LIT:1> ] ) <EOL>", "answer": "setup ("}, {"prompt": "<s> from cleo . commands import Command <EOL> class Foo5Command ( Command ) : <EOL>", "answer": "def __init__ ( self ) :"}, {"prompt": "<s> from . import google_drive <EOL> from . import gulp <EOL> from . import sass_preprocessor <EOL> from grow . common import utils <EOL> from protorpc import protojson <EOL> import json <EOL> _preprocessor_kinds_to_classes = { } <EOL>", "answer": "_builtins = ("}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import contextlib <EOL> import os <EOL> import struct <EOL> import sys <EOL> import threading <EOL> import time <EOL> import warnings <EOL> from collections import defaultdict <EOL> from functools import partial <EOL> from pymongo import MongoClient , monitoring <EOL> from pymongo . errors import AutoReconnect , OperationFailure <EOL>", "answer": "from pymongo . server_selectors import ( any_server_selector ,"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from rest_framework . response import Response <EOL> from sentry . api import client <EOL> from sentry . api . base import DocSection <EOL> from sentry . api . bases . group import GroupEndpoint <EOL>", "answer": "from sentry . models import Group"}, {"prompt": "<s> import os <EOL> import subprocess <EOL> import time <EOL> from django . conf import settings <EOL> import jinja2 <EOL> from jingo import register <EOL> from . utils import get_media_url , get_path <EOL> try : <EOL> from build import BUILD_ID_CSS , BUILD_ID_JS , BUILD_ID_IMG , BUNDLE_HASHES <EOL> except ImportError : <EOL> BUILD_ID_CSS = BUILD_ID_JS = BUILD_ID_IMG = '<STR_LIT>' <EOL> BUNDLE_HASHES = { } <EOL> def is_external ( url ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return url . startswith ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> def _get_item_path ( item ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if is_external ( item ) : <EOL> return item <EOL> return get_media_url ( ) + item <EOL> def _get_mtime ( item ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if item . startswith ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) : <EOL> return int ( time . time ( ) ) <EOL> return int ( os . path . getmtime ( get_path ( item ) ) ) <EOL> def _build_html ( items , wrapping ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return jinja2 . Markup ( '<STR_LIT:\\n>' . join ( ( wrapping % item for item in items ) ) ) <EOL> def get_js_urls ( bundle , debug = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if debug is None : <EOL> debug = settings . TEMPLATE_DEBUG <EOL> if debug : <EOL> return [ _get_item_path ( '<STR_LIT>' % ( item , _get_mtime ( item ) ) ) for <EOL> item in settings . MINIFY_BUNDLES [ '<STR_LIT>' ] [ bundle ] ] <EOL> else : <EOL> build_id = BUILD_ID_JS <EOL> bundle_full = '<STR_LIT>' % bundle <EOL> if bundle_full in BUNDLE_HASHES : <EOL> build_id = BUNDLE_HASHES [ bundle_full ] <EOL> return ( _get_item_path ( '<STR_LIT>' % ( bundle , build_id , ) ) , ) <EOL> def _get_compiled_css_url ( item ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ( ( item . endswith ( '<STR_LIT>' ) and <EOL> getattr ( settings , '<STR_LIT>' , False ) ) or <EOL> item . endswith ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) ) : <EOL> compile_css ( item ) <EOL> return item + '<STR_LIT>' <EOL> return item <EOL> def get_css_urls ( bundle , debug = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if debug is None : <EOL> debug = settings . TEMPLATE_DEBUG <EOL> if debug : <EOL> items = [ ] <EOL> for item in settings . MINIFY_BUNDLES [ '<STR_LIT>' ] [ bundle ] : <EOL> if ( ( item . endswith ( '<STR_LIT>' ) and <EOL> getattr ( settings , '<STR_LIT>' , False ) ) or <EOL> item . endswith ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) ) : <EOL> compile_css ( item ) <EOL> items . append ( '<STR_LIT>' % item ) <EOL> else : <EOL> items . append ( item ) <EOL> return [ _get_item_path ( '<STR_LIT>' % ( item , _get_mtime ( item ) ) ) for <EOL> item in items ] <EOL> else : <EOL> build_id = BUILD_ID_CSS <EOL> bundle_full = '<STR_LIT>' % bundle <EOL> if bundle_full in BUNDLE_HASHES : <EOL> build_id = BUNDLE_HASHES [ bundle_full ] <EOL> return ( _get_item_path ( '<STR_LIT>' % <EOL> ( bundle , build_id ) ) , ) <EOL> @ register . function <EOL> def js ( bundle , debug = None , defer = False , async = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> attrs = [ ] <EOL> urls = get_js_urls ( bundle , debug ) <EOL> attrs . append ( '<STR_LIT>' ) <EOL> if defer : <EOL> attrs . append ( '<STR_LIT>' ) <EOL> if async : <EOL> attrs . append ( '<STR_LIT>' ) <EOL> return _build_html ( urls , '<STR_LIT>' % '<STR_LIT:U+0020>' . join ( attrs ) ) <EOL> @ register . function <EOL> def css ( bundle , media = False , debug = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> urls = get_css_urls ( bundle , debug ) <EOL> if not media : <EOL> media = getattr ( settings , '<STR_LIT>' , '<STR_LIT>' ) <EOL> return _build_html ( urls , '<STR_LIT>' <EOL> % media ) <EOL> @ register . function <EOL> def inline_css ( bundle , media = False , debug = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if debug is None : <EOL> debug = getattr ( settings , '<STR_LIT>' , False ) <EOL> if debug : <EOL> items = [ _get_compiled_css_url ( i ) <EOL> for i in settings . MINIFY_BUNDLES [ '<STR_LIT>' ] [ bundle ] ] <EOL> else : <EOL> items = [ '<STR_LIT>' % bundle ] <EOL> if not media : <EOL> media = getattr ( settings , '<STR_LIT>' , '<STR_LIT>' ) <EOL> contents = [ ] <EOL> for css in items : <EOL> if is_external ( css ) : <EOL> return _build_html ( [ css ] , '<STR_LIT>' <EOL> '<STR_LIT>' % media ) <EOL> with open ( get_path ( css ) , '<STR_LIT:r>' ) as f : <EOL> contents . append ( f . read ( ) ) <EOL>", "answer": "return _build_html ( contents , '<STR_LIT>'"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> import pkg_resources <EOL> import sys <EOL> from django . core . management . base import NoArgsCommand <EOL> from reviewboard . scmtools . models import Tool <EOL> class Command ( NoArgsCommand ) : <EOL> def handle_noargs ( self , ** options ) : <EOL> registered_tools = { } <EOL> for tool in Tool . objects . all ( ) : <EOL> registered_tools [ tool . class_name ] = True <EOL> for entry in pkg_resources . iter_entry_points ( \"<STR_LIT>\" ) : <EOL> try : <EOL> scmtool_class = entry . load ( ) <EOL> except Exception as e : <EOL> sys . stderr . write ( \"<STR_LIT>\" % <EOL> ( entry , e ) ) <EOL> continue <EOL> class_name = \"<STR_LIT>\" % ( scmtool_class . __module__ , <EOL> scmtool_class . __name__ ) <EOL> if class_name not in registered_tools : <EOL>", "answer": "registered_tools [ class_name ] = True"}, {"prompt": "<s> from test . test_support import verbose , TestSkipped , run_unittest <EOL> from _locale import ( setlocale , LC_NUMERIC , RADIXCHAR , THOUSEP , nl_langinfo , <EOL> localeconv , Error ) <EOL> import unittest <EOL> from platform import uname <EOL> if uname ( ) [ <NUM_LIT:0> ] == \"<STR_LIT>\" : <EOL> maj , min , mic = [ int ( part ) for part in uname ( ) [ <NUM_LIT:2> ] . split ( \"<STR_LIT:.>\" ) ] <EOL> if ( maj , min , mic ) < ( <NUM_LIT:8> , <NUM_LIT:0> , <NUM_LIT:0> ) : <EOL> raise TestSkipped ( \"<STR_LIT>\" ) <EOL> candidate_locales = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> known_numerics = { '<STR_LIT>' : ( '<STR_LIT:U+002C>' , '<STR_LIT>' ) , '<STR_LIT>' : ( '<STR_LIT:.>' , '<STR_LIT:U+002C>' ) } <EOL> class _LocaleTests ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . oldlocale = setlocale ( LC_NUMERIC ) <EOL> def tearDown ( self ) : <EOL> setlocale ( LC_NUMERIC , self . oldlocale ) <EOL> lc_numeric_err_msg = \"<STR_LIT>\" <EOL> def numeric_tester ( self , calc_type , calc_value , data_type , used_locale ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> set_locale = setlocale ( LC_NUMERIC ) <EOL> except Error : <EOL> set_locale = \"<STR_LIT>\" <EOL> known_value = known_numerics . get ( used_locale , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) ) [ data_type is '<STR_LIT>' ] <EOL> if known_value and calc_value : <EOL> self . assertEquals ( calc_value , known_value , <EOL> self . lc_numeric_err_msg % ( <EOL> calc_value , known_value , <EOL>", "answer": "calc_type , data_type , set_locale ,"}, {"prompt": "<s> from django . conf . urls import url <EOL> from . views import PageView <EOL> urlpatterns = [ <EOL>", "answer": "url ( r'<STR_LIT>' , PageView . as_view ( ) , name = '<STR_LIT>' ) ,"}, {"prompt": "<s> import copy <EOL> import tempfile <EOL> import mock <EOL> import six <EOL> import testtools <EOL> from testtools . matchers import HasLength <EOL> from ironicclient . common import utils as common_utils <EOL> from ironicclient import exc <EOL> from ironicclient . tests . unit import utils <EOL> from ironicclient . v1 import node <EOL> if six . PY3 : <EOL> import io <EOL> file = io . BytesIO <EOL> NODE1 = { '<STR_LIT:id>' : <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { '<STR_LIT:user>' : '<STR_LIT:foo>' , '<STR_LIT:password>' : '<STR_LIT:bar>' } , <EOL> '<STR_LIT>' : { '<STR_LIT>' : <NUM_LIT:4> } , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { } } <EOL> NODE2 = { '<STR_LIT:id>' : <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { '<STR_LIT:user>' : '<STR_LIT:foo>' , '<STR_LIT:password>' : '<STR_LIT:bar>' } , <EOL> '<STR_LIT>' : { '<STR_LIT>' : <NUM_LIT:4> } , <EOL> '<STR_LIT>' : { } } <EOL> PORT = { '<STR_LIT:id>' : <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT:address>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { } } <EOL> POWER_STATE = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' } <EOL> DRIVER_IFACES = { '<STR_LIT>' : { '<STR_LIT:result>' : True } , <EOL> '<STR_LIT>' : { '<STR_LIT:result>' : False , '<STR_LIT>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:result>' : None , '<STR_LIT>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:result>' : None , '<STR_LIT>' : '<STR_LIT>' } } <EOL> NODE_STATES = { \"<STR_LIT>\" : None , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : None , <EOL> \"<STR_LIT>\" : None } <EOL> CONSOLE_DATA_ENABLED = { '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT>' } } <EOL> CONSOLE_DATA_DISABLED = { '<STR_LIT>' : False , '<STR_LIT>' : None } <EOL> CONSOLE_ENABLE = '<STR_LIT:true>' <EOL> BOOT_DEVICE = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : False } <EOL> SUPPORTED_BOOT_DEVICE = { '<STR_LIT>' : [ '<STR_LIT>' ] } <EOL> NODE_VENDOR_PASSTHRU_METHOD = { \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT:false>\" , <EOL> \"<STR_LIT>\" : [ \"<STR_LIT:POST>\" ] , <EOL> \"<STR_LIT:description>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT:true>\" } } <EOL> CREATE_NODE = copy . deepcopy ( NODE1 ) <EOL> del CREATE_NODE [ '<STR_LIT:id>' ] <EOL> del CREATE_NODE [ '<STR_LIT>' ] <EOL> del CREATE_NODE [ '<STR_LIT>' ] <EOL> del CREATE_NODE [ '<STR_LIT>' ] <EOL> UPDATED_NODE = copy . deepcopy ( NODE1 ) <EOL> NEW_DRIVER = '<STR_LIT>' <EOL> UPDATED_NODE [ '<STR_LIT>' ] = NEW_DRIVER <EOL> CREATE_WITH_UUID = copy . deepcopy ( NODE1 ) <EOL> del CREATE_WITH_UUID [ '<STR_LIT:id>' ] <EOL> del CREATE_WITH_UUID [ '<STR_LIT>' ] <EOL> del CREATE_WITH_UUID [ '<STR_LIT>' ] <EOL> fake_responses = { <EOL> '<STR_LIT>' : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE1 , NODE2 ] } <EOL> ) , <EOL> '<STR_LIT:POST>' : ( <EOL> { } , <EOL> CREATE_NODE , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE1 , NODE2 ] } <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE1 ] } <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE1 ] } , <EOL> ) <EOL> } , <EOL> '<STR_LIT>' : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE2 ] } , <EOL> ) <EOL> } , <EOL> '<STR_LIT>' : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE1 ] } , <EOL> ) <EOL> } , <EOL> '<STR_LIT>' : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE2 ] } , <EOL> ) <EOL> } , <EOL> '<STR_LIT>' : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE2 ] } , <EOL> ) <EOL> } , <EOL> '<STR_LIT>' : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE1 ] } , <EOL> ) <EOL> } , <EOL> '<STR_LIT>' : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE1 ] } , <EOL> ) <EOL> } , <EOL> '<STR_LIT>' % NODE2 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE2 ] } , <EOL> ) <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> NODE1 , <EOL> ) , <EOL> '<STR_LIT>' : ( <EOL> { } , <EOL> None , <EOL> ) , <EOL> '<STR_LIT>' : ( <EOL> { } , <EOL> UPDATED_NODE , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> NODE1 , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE2 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> NODE2 , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT:name>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> NODE1 , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ PORT ] } , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT:name>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ PORT ] } , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ PORT ] } , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT:name>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ PORT ] } , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ PORT ] } , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT>' : ( <EOL> { } , <EOL> None , <EOL> ) , <EOL> '<STR_LIT>' : ( <EOL> { } , <EOL> None , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT>' : ( <EOL> { } , <EOL> POWER_STATE , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> DRIVER_IFACES , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT>' : ( <EOL> { } , <EOL> None , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> NODE_STATES , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT>' : ( <EOL> { } , <EOL> None , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> CONSOLE_DATA_ENABLED , <EOL> ) , <EOL> '<STR_LIT>' : ( <EOL> { '<STR_LIT>' : CONSOLE_ENABLE } , <EOL> None , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE2 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> CONSOLE_DATA_DISABLED , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> BOOT_DEVICE , <EOL> ) , <EOL> '<STR_LIT>' : ( <EOL> { } , <EOL> None , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> SUPPORTED_BOOT_DEVICE , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> NODE_VENDOR_PASSTHRU_METHOD , <EOL> ) , <EOL> } , <EOL> } <EOL> fake_responses_pagination = { <EOL> '<STR_LIT>' : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE1 ] , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE2 ] } <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE2 ] } <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ PORT ] } , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % ( NODE1 [ '<STR_LIT>' ] , PORT [ '<STR_LIT>' ] ) : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ PORT ] } , <EOL> ) , <EOL> } , <EOL> } <EOL> fake_responses_sorting = { <EOL> '<STR_LIT>' : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE2 , NODE1 ] } <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ NODE2 , NODE1 ] } <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ PORT ] } , <EOL> ) , <EOL> } , <EOL> '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] : <EOL> { <EOL> '<STR_LIT:GET>' : ( <EOL> { } , <EOL> { \"<STR_LIT>\" : [ PORT ] } , <EOL> ) , <EOL> } , <EOL> } <EOL> class NodeManagerTest ( testtools . TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( NodeManagerTest , self ) . setUp ( ) <EOL> self . api = utils . FakeAPI ( fake_responses ) <EOL> self . mgr = node . NodeManager ( self . api ) <EOL> def test_node_list ( self ) : <EOL> nodes = self . mgr . list ( ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertEqual ( <NUM_LIT:2> , len ( nodes ) ) <EOL> def test_node_list_shows_name ( self ) : <EOL> nodes = self . mgr . list ( ) <EOL> self . assertIsNotNone ( getattr ( nodes [ <NUM_LIT:0> ] , '<STR_LIT:name>' ) ) <EOL> def test_node_list_limit ( self ) : <EOL> self . api = utils . FakeAPI ( fake_responses_pagination ) <EOL> self . mgr = node . NodeManager ( self . api ) <EOL> nodes = self . mgr . list ( limit = <NUM_LIT:1> ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertThat ( nodes , HasLength ( <NUM_LIT:1> ) ) <EOL> def test_node_list_marker ( self ) : <EOL> self . api = utils . FakeAPI ( fake_responses_pagination ) <EOL> self . mgr = node . NodeManager ( self . api ) <EOL> nodes = self . mgr . list ( marker = NODE1 [ '<STR_LIT>' ] ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] , { } , None ) <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertThat ( nodes , HasLength ( <NUM_LIT:1> ) ) <EOL> def test_node_list_pagination_no_limit ( self ) : <EOL> self . api = utils . FakeAPI ( fake_responses_pagination ) <EOL> self . mgr = node . NodeManager ( self . api ) <EOL> nodes = self . mgr . list ( limit = <NUM_LIT:0> ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) , <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertEqual ( <NUM_LIT:2> , len ( nodes ) ) <EOL> def test_node_list_sort_key ( self ) : <EOL> self . api = utils . FakeAPI ( fake_responses_sorting ) <EOL> self . mgr = node . NodeManager ( self . api ) <EOL> nodes = self . mgr . list ( sort_key = '<STR_LIT>' ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertEqual ( <NUM_LIT:2> , len ( nodes ) ) <EOL> def test_node_list_sort_dir ( self ) : <EOL> self . api = utils . FakeAPI ( fake_responses_sorting ) <EOL> self . mgr = node . NodeManager ( self . api ) <EOL> nodes = self . mgr . list ( sort_dir = '<STR_LIT>' ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertEqual ( <NUM_LIT:2> , len ( nodes ) ) <EOL> def test_node_list_associated ( self ) : <EOL> nodes = self . mgr . list ( associated = True ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertThat ( nodes , HasLength ( <NUM_LIT:1> ) ) <EOL> self . assertEqual ( NODE2 [ '<STR_LIT>' ] , getattr ( nodes [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> def test_node_list_unassociated ( self ) : <EOL> nodes = self . mgr . list ( associated = False ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertThat ( nodes , HasLength ( <NUM_LIT:1> ) ) <EOL> self . assertEqual ( NODE1 [ '<STR_LIT>' ] , getattr ( nodes [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> def test_node_list_unassociated_string ( self ) : <EOL> nodes = self . mgr . list ( associated = \"<STR_LIT:False>\" ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertThat ( nodes , HasLength ( <NUM_LIT:1> ) ) <EOL> self . assertEqual ( NODE1 [ '<STR_LIT>' ] , getattr ( nodes [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> def test_node_list_maintenance ( self ) : <EOL> nodes = self . mgr . list ( maintenance = True ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertThat ( nodes , HasLength ( <NUM_LIT:1> ) ) <EOL> self . assertEqual ( NODE2 [ '<STR_LIT>' ] , getattr ( nodes [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> def test_node_list_maintenance_string ( self ) : <EOL> nodes = self . mgr . list ( maintenance = \"<STR_LIT:True>\" ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertThat ( nodes , HasLength ( <NUM_LIT:1> ) ) <EOL> self . assertEqual ( NODE2 [ '<STR_LIT>' ] , getattr ( nodes [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> def test_node_list_provision_state ( self ) : <EOL> nodes = self . mgr . list ( provision_state = \"<STR_LIT>\" ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertThat ( nodes , HasLength ( <NUM_LIT:1> ) ) <EOL> self . assertEqual ( NODE1 [ '<STR_LIT>' ] , getattr ( nodes [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> def test_node_list_provision_state_fail ( self ) : <EOL> self . assertRaises ( KeyError , self . mgr . list , <EOL> provision_state = \"<STR_LIT:test>\" ) <EOL> def test_node_list_driver ( self ) : <EOL> nodes = self . mgr . list ( driver = \"<STR_LIT>\" ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertThat ( nodes , HasLength ( <NUM_LIT:1> ) ) <EOL> self . assertEqual ( NODE1 [ '<STR_LIT>' ] , getattr ( nodes [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> def test_node_list_no_maintenance ( self ) : <EOL> nodes = self . mgr . list ( maintenance = False ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertThat ( nodes , HasLength ( <NUM_LIT:1> ) ) <EOL> self . assertEqual ( NODE1 [ '<STR_LIT>' ] , getattr ( nodes [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> def test_node_list_associated_and_maintenance ( self ) : <EOL> nodes = self . mgr . list ( associated = True , maintenance = True ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertThat ( nodes , HasLength ( <NUM_LIT:1> ) ) <EOL> self . assertEqual ( NODE2 [ '<STR_LIT>' ] , getattr ( nodes [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> def test_node_list_detail ( self ) : <EOL> nodes = self . mgr . list ( detail = True ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertEqual ( <NUM_LIT:2> , len ( nodes ) ) <EOL> self . assertEqual ( nodes [ <NUM_LIT:0> ] . extra , { } ) <EOL> def test_node_list_fields ( self ) : <EOL> nodes = self . mgr . list ( fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertEqual ( <NUM_LIT:1> , len ( nodes ) ) <EOL> def test_node_list_detail_and_fields_fail ( self ) : <EOL> self . assertRaises ( exc . InvalidAttribute , self . mgr . list , <EOL> detail = True , fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def test_node_show ( self ) : <EOL> node = self . mgr . get ( NODE1 [ '<STR_LIT>' ] ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertEqual ( NODE1 [ '<STR_LIT>' ] , node . uuid ) <EOL> def test_node_show_by_instance ( self ) : <EOL> node = self . mgr . get_by_instance_uuid ( NODE2 [ '<STR_LIT>' ] ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' % <EOL> NODE2 [ '<STR_LIT>' ] , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertEqual ( NODE2 [ '<STR_LIT>' ] , node . uuid ) <EOL> def test_node_show_by_name ( self ) : <EOL> node = self . mgr . get ( NODE1 [ '<STR_LIT:name>' ] ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' % NODE1 [ '<STR_LIT:name>' ] , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertEqual ( NODE1 [ '<STR_LIT>' ] , node . uuid ) <EOL> def test_node_show_fields ( self ) : <EOL> node = self . mgr . get ( NODE1 [ '<STR_LIT>' ] , fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> expect = [ <EOL> ( '<STR_LIT:GET>' , '<STR_LIT>' % <EOL> NODE1 [ '<STR_LIT>' ] , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertEqual ( NODE1 [ '<STR_LIT>' ] , node . uuid ) <EOL> def test_create ( self ) : <EOL> node = self . mgr . create ( ** CREATE_NODE ) <EOL> expect = [ <EOL> ( '<STR_LIT:POST>' , '<STR_LIT>' , { } , CREATE_NODE ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertTrue ( node ) <EOL> def test_create_with_uuid ( self ) : <EOL> node = self . mgr . create ( ** CREATE_WITH_UUID ) <EOL> expect = [ <EOL> ( '<STR_LIT:POST>' , '<STR_LIT>' , { } , CREATE_WITH_UUID ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertTrue ( node ) <EOL> def test_delete ( self ) : <EOL> node = self . mgr . delete ( node_id = NODE1 [ '<STR_LIT>' ] ) <EOL> expect = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' % NODE1 [ '<STR_LIT>' ] , { } , None ) , <EOL> ] <EOL> self . assertEqual ( expect , self . api . calls ) <EOL> self . assertIsNone ( node ) <EOL> def test_update ( self ) : <EOL>", "answer": "patch = { '<STR_LIT>' : '<STR_LIT:replace>' ,"}, {"prompt": "<s> import unittest <EOL> import Tkinter as tkinter <EOL> from Tkinter import TclError <EOL> import os <EOL> import sys <EOL> from test . test_support import requires , run_unittest <EOL> from test_ttk . support import ( tcl_version , requires_tcl , get_tk_patchlevel , <EOL> widget_eq ) <EOL> from widget_tests import ( <EOL> add_standard_options , noconv , noconv_meth , int_round , pixels_round , <EOL> AbstractWidgetTest , StandardOptionsTests , <EOL> IntegerSizeTests , PixelSizeTests , <EOL> setUpModule ) <EOL> requires ( '<STR_LIT>' ) <EOL> class AbstractToplevelTest ( AbstractWidgetTest , PixelSizeTests ) : <EOL> _conv_pad_pixels = noconv_meth <EOL> def test_class ( self ) : <EOL> widget = self . create ( ) <EOL> self . assertEqual ( widget [ '<STR_LIT:class>' ] , <EOL> widget . __class__ . __name__ . title ( ) ) <EOL> self . checkInvalidParam ( widget , '<STR_LIT:class>' , '<STR_LIT>' , <EOL> errmsg = \"<STR_LIT>\" ) <EOL> widget2 = self . create ( class_ = '<STR_LIT>' ) <EOL> self . assertEqual ( widget2 [ '<STR_LIT:class>' ] , '<STR_LIT>' ) <EOL> def test_colormap ( self ) : <EOL> widget = self . create ( ) <EOL> self . assertEqual ( widget [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . checkInvalidParam ( widget , '<STR_LIT>' , '<STR_LIT>' , <EOL> errmsg = \"<STR_LIT>\" ) <EOL> widget2 = self . create ( colormap = '<STR_LIT>' ) <EOL> self . assertEqual ( widget2 [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> def test_container ( self ) : <EOL> widget = self . create ( ) <EOL> self . assertEqual ( widget [ '<STR_LIT>' ] , <NUM_LIT:0> if self . wantobjects else '<STR_LIT:0>' ) <EOL> self . checkInvalidParam ( widget , '<STR_LIT>' , <NUM_LIT:1> , <EOL> errmsg = \"<STR_LIT>\" ) <EOL> widget2 = self . create ( container = True ) <EOL> self . assertEqual ( widget2 [ '<STR_LIT>' ] , <NUM_LIT:1> if self . wantobjects else '<STR_LIT:1>' ) <EOL> def test_visual ( self ) : <EOL>", "answer": "widget = self . create ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "import os"}, {"prompt": "<s> from clock import clock <EOL> try : <EOL> True <EOL> except : <EOL> True = <NUM_LIT:1> <EOL> False = <NUM_LIT:0> <EOL> FACTOR = <NUM_LIT> <EOL> class RateMeasure : <EOL> def __init__ ( self ) : <EOL> self . last = None <EOL> self . time = <NUM_LIT:1.0> <EOL> self . got = <NUM_LIT:0.0> <EOL> self . remaining = None <EOL> self . broke = False <EOL> self . got_anything = False <EOL> self . last_checked = None <EOL> self . rate = <NUM_LIT:0> <EOL> self . lastten = False <EOL> def data_came_in ( self , amount ) : <EOL> if not self . got_anything : <EOL> self . got_anything = True <EOL> self . last = clock ( ) <EOL> return <EOL> self . update ( amount ) <EOL> def data_rejected ( self , amount ) : <EOL> pass <EOL> def get_time_left ( self , left ) : <EOL> t = clock ( ) <EOL> if not self . got_anything : <EOL> return None <EOL> if t - self . last > <NUM_LIT:15> : <EOL> self . update ( <NUM_LIT:0> ) <EOL> try : <EOL> remaining = left / self . rate <EOL> if not self . lastten and remaining <= <NUM_LIT:10> : <EOL> self . lastten = True <EOL> if self . lastten : <EOL> return remaining <EOL> delta = max ( remaining / <NUM_LIT:20> , <NUM_LIT:2> ) <EOL>", "answer": "if self . remaining is None :"}, {"prompt": "<s> from nova . network import model <EOL> def new_ip ( ip_dict = None , version = <NUM_LIT:4> ) : <EOL> if version == <NUM_LIT:6> : <EOL> new_ip = dict ( address = '<STR_LIT>' , version = <NUM_LIT:6> ) <EOL> elif version == <NUM_LIT:4> : <EOL> new_ip = dict ( address = '<STR_LIT>' ) <EOL> ip_dict = ip_dict or { } <EOL> new_ip . update ( ip_dict ) <EOL> return model . IP ( ** new_ip ) <EOL> def new_fixed_ip ( ip_dict = None , version = <NUM_LIT:4> ) : <EOL> if version == <NUM_LIT:6> : <EOL> new_fixed_ip = dict ( address = '<STR_LIT>' , version = <NUM_LIT:6> ) <EOL> elif version == <NUM_LIT:4> : <EOL> new_fixed_ip = dict ( address = '<STR_LIT>' ) <EOL> ip_dict = ip_dict or { } <EOL> new_fixed_ip . update ( ip_dict ) <EOL> return model . FixedIP ( ** new_fixed_ip ) <EOL> def new_route ( route_dict = None , version = <NUM_LIT:4> ) : <EOL> if version == <NUM_LIT:6> : <EOL> new_route = dict ( <EOL> cidr = '<STR_LIT>' , <EOL> gateway = new_ip ( dict ( address = '<STR_LIT>' ) , version = <NUM_LIT:6> ) , <EOL> interface = '<STR_LIT>' ) <EOL> elif version == <NUM_LIT:4> : <EOL> new_route = dict ( <EOL> cidr = '<STR_LIT>' , <EOL> gateway = new_ip ( dict ( address = '<STR_LIT>' ) ) , <EOL> interface = '<STR_LIT>' ) <EOL> route_dict = route_dict or { } <EOL> new_route . update ( route_dict ) <EOL> return model . Route ( ** new_route ) <EOL> def new_subnet ( subnet_dict = None , version = <NUM_LIT:4> ) : <EOL> if version == <NUM_LIT:6> : <EOL> new_subnet = dict ( <EOL> cidr = '<STR_LIT>' , <EOL> dns = [ new_ip ( dict ( address = '<STR_LIT>' ) , version = <NUM_LIT:6> ) , <EOL> new_ip ( dict ( address = '<STR_LIT>' ) , version = <NUM_LIT:6> ) ] , <EOL> gateway = new_ip ( dict ( address = '<STR_LIT>' ) , version = <NUM_LIT:6> ) , <EOL> ips = [ new_fixed_ip ( dict ( address = '<STR_LIT>' ) , version = <NUM_LIT:6> ) , <EOL> new_fixed_ip ( dict ( address = '<STR_LIT>' ) , version = <NUM_LIT:6> ) ] , <EOL> routes = [ new_route ( version = <NUM_LIT:6> ) ] , <EOL> version = <NUM_LIT:6> ) <EOL> elif version == <NUM_LIT:4> : <EOL> new_subnet = dict ( <EOL> cidr = '<STR_LIT>' , <EOL> dns = [ new_ip ( dict ( address = '<STR_LIT>' ) ) , <EOL> new_ip ( dict ( address = '<STR_LIT>' ) ) ] , <EOL> gateway = new_ip ( dict ( address = '<STR_LIT>' ) ) , <EOL> ips = [ new_fixed_ip ( dict ( address = '<STR_LIT>' ) ) , <EOL> new_fixed_ip ( dict ( address = '<STR_LIT>' ) ) ] , <EOL> routes = [ new_route ( ) ] ) <EOL> subnet_dict = subnet_dict or { } <EOL> new_subnet . update ( subnet_dict ) <EOL> return model . Subnet ( ** new_subnet ) <EOL> def new_network ( network_dict = None , version = <NUM_LIT:4> ) : <EOL> if version == <NUM_LIT:6> : <EOL> new_net = dict ( <EOL> id = <NUM_LIT:1> , <EOL> bridge = '<STR_LIT>' , <EOL> label = '<STR_LIT>' , <EOL> subnets = [ new_subnet ( version = <NUM_LIT:6> ) , <EOL> new_subnet ( dict ( cidr = '<STR_LIT>' ) , <EOL> version = <NUM_LIT:6> ) ] ) <EOL> elif version == <NUM_LIT:4> : <EOL> new_net = dict ( <EOL> id = <NUM_LIT:1> , <EOL> bridge = '<STR_LIT>' , <EOL> label = '<STR_LIT>' , <EOL> subnets = [ new_subnet ( ) , new_subnet ( dict ( cidr = '<STR_LIT>' ) ) ] ) <EOL> network_dict = network_dict or { } <EOL> new_net . update ( network_dict ) <EOL> return model . Network ( ** new_net ) <EOL> def new_vif ( vif_dict = None , version = <NUM_LIT:4> ) : <EOL> vif = dict ( <EOL> id = <NUM_LIT:1> , <EOL> address = '<STR_LIT>' , <EOL> type = '<STR_LIT>' , <EOL> network = new_network ( version = version ) ) <EOL>", "answer": "vif_dict = vif_dict or { }"}, {"prompt": "<s> from pyVmomi import vim <EOL> from pyVim . connect import SmartConnect , Disconnect <EOL> import time <EOL> def _get_obj ( content , vimtype , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> obj = None <EOL> container = content . viewManager . CreateContainerView ( content . rootFolder , vimtype , True ) <EOL> for c in container . view : <EOL> if c . name == name : <EOL> obj = c <EOL> break <EOL> return obj <EOL> def _get_all_objs ( content , vimtype ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> obj = { } <EOL> container = content . viewManager . CreateContainerView ( content . rootFolder , vimtype , True ) <EOL> for c in container . view : <EOL> obj . update ( { c : c . name } ) <EOL> return obj <EOL> def login_in_guest ( username , password ) : <EOL> return vim . vm . guest . NamePasswordAuthentication ( username = username , password = password ) <EOL> def start_process ( si , vm , auth , program_path , args = None , env = None , cwd = None ) : <EOL> cmdspec = vim . vm . guest . ProcessManager . ProgramSpec ( arguments = args , programPath = program_path , envVariables = env , workingDirectory = cwd ) <EOL> cmdpid = si . content . guestOperationsManager . processManager . StartProgramInGuest ( vm = vm , auth = auth , spec = cmdspec ) <EOL> return cmdpid <EOL> def is_ready ( vm ) : <EOL> while True : <EOL> system_ready = vm . guest . guestOperationsReady <EOL> system_state = vm . guest . guestState <EOL> system_uptime = vm . summary . quickStats . uptimeSeconds <EOL> if system_ready and system_state == '<STR_LIT>' and system_uptime > <NUM_LIT> : <EOL> break <EOL> time . sleep ( <NUM_LIT:10> ) <EOL> def get_vm_by_name ( si , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return _get_obj ( si . RetrieveContent ( ) , [ vim . VirtualMachine ] , name ) <EOL> def get_host_by_name ( si , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return _get_obj ( si . RetrieveContent ( ) , [ vim . HostSystem ] , name ) <EOL> def get_resource_pool ( si , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return _get_obj ( si . RetrieveContent ( ) , [ vim . ResourcePool ] , name ) <EOL> def get_resource_pools ( si ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return _get_all_objs ( si . RetrieveContent ( ) , [ vim . ResourcePool ] ) <EOL> def get_datastores ( si ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return _get_all_objs ( si . RetrieveContent ( ) , [ vim . Datastore ] ) <EOL> def get_hosts ( si ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return _get_all_objs ( si . RetrieveContent ( ) , [ vim . HostSystem ] ) <EOL> def get_datacenters ( si ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return _get_all_objs ( si . RetrieveContent ( ) , [ vim . Datacenter ] ) <EOL>", "answer": "def get_registered_vms ( si ) :"}, {"prompt": "<s> import os <EOL> from setuptools import setup , find_packages <EOL> def read_file ( filename ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = os . path . abspath ( os . path . dirname ( __file__ ) ) <EOL> filepath = os . path . join ( path , filename ) <EOL> try : <EOL> return open ( filepath ) . read ( ) <EOL> except IOError : <EOL> return '<STR_LIT>' <EOL> DESC = \"<STR_LIT:U+0020>\" . join ( __import__ ( '<STR_LIT>' ) . __doc__ . splitlines ( ) ) . strip ( ) <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = __import__ ( '<STR_LIT>' ) . get_version ( ) . replace ( '<STR_LIT:U+0020>' , '<STR_LIT:->' ) , <EOL> url = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> description = DESC , <EOL> long_description = read_file ( '<STR_LIT>' ) , <EOL> packages = find_packages ( ) , <EOL> include_package_data = True , <EOL> install_requires = read_file ( '<STR_LIT>' ) , <EOL> classifiers = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL>", "answer": "keywords = '<STR_LIT>' ,"}, {"prompt": "<s> import click <EOL> def pprint_header ( repo_name , issue , milestone ) : <EOL> click . echo ( '<STR_LIT>' + repo_name ) <EOL> if issue : <EOL> click . echo ( '<STR_LIT>' + str ( issue ) ) <EOL> if milestone : <EOL> click . echo ( '<STR_LIT>' + milestone ) <EOL> def pprint_entry ( entry , committer = None ) : <EOL> output = [ <EOL> \"<STR_LIT>\" . format ( entry . time ) , <EOL> \"<STR_LIT>\" . format ( entry . comment ) <EOL> ] <EOL>", "answer": "if committer :"}, {"prompt": "<s> from django . core . management . base import BaseCommand <EOL> from denorm import denorms <EOL> class Command ( BaseCommand ) : <EOL> help = \"<STR_LIT>\" <EOL>", "answer": "def handle ( self , model_name = None , * args , ** kwargs ) :"}, {"prompt": "<s> from scrapy . contrib . spiders import CrawlSpider , Rule <EOL> from scrapy . contrib . linkextractors . sgml import SgmlLinkExtractor <EOL> from scrapy . selector import HtmlXPathSelector <EOL> from openrecipes . items import RecipeItem , RecipeItemLoader <EOL> class AspicyperspectivecrawlSpider ( CrawlSpider ) : <EOL> name = \"<STR_LIT>\" <EOL> allowed_domains = [ \"<STR_LIT>\" ] <EOL> start_urls = [ <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> rules = ( <EOL> Rule ( SgmlLinkExtractor ( allow = ( '<STR_LIT>' ) ) ) , <EOL> Rule ( SgmlLinkExtractor ( allow = ( '<STR_LIT>' ) ) , callback = '<STR_LIT>' ) , <EOL> ) <EOL> def parse_item ( self , response ) : <EOL> hxs = HtmlXPathSelector ( response ) <EOL> base_path = \"\"\"<STR_LIT>\"\"\" <EOL> recipes_scopes = hxs . select ( base_path ) <EOL> name_path = '<STR_LIT>' <EOL> image_path = '<STR_LIT>' <EOL> prepTime_path = '<STR_LIT>' <EOL> cookTime_path = '<STR_LIT>' <EOL> recipeYield_path = '<STR_LIT>' <EOL> ingredients_path = '<STR_LIT>' <EOL>", "answer": "recipes = [ ]"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from django . core . urlresolvers import reverse <EOL> from sentry . rules import rules <EOL> from sentry . models import Rule <EOL> from sentry . web . frontend . base import ProjectView <EOL> from sentry . utils import json <EOL> class ProjectRuleEditView ( ProjectView ) : <EOL> required_scope = '<STR_LIT>' <EOL> def get ( self , request , organization , team , project , rule_id = None ) : <EOL> if rule_id : <EOL> try : <EOL> rule = Rule . objects . get ( project = project , id = rule_id ) <EOL> except Rule . DoesNotExist : <EOL> path = reverse ( '<STR_LIT>' , args = [ organization . slug , project . slug ] ) <EOL> return self . redirect ( path ) <EOL> else : <EOL> rule = Rule ( project = project ) <EOL> action_list = [ ] <EOL> condition_list = [ ] <EOL> for rule_type , rule_cls in rules : <EOL> node = rule_cls ( project ) <EOL> context = { <EOL> '<STR_LIT:id>' : node . id , <EOL> '<STR_LIT:label>' : node . label , <EOL> '<STR_LIT:html>' : node . render_form ( ) , <EOL> } <EOL> if rule_type . startswith ( '<STR_LIT>' ) : <EOL> condition_list . append ( context ) <EOL>", "answer": "elif rule_type . startswith ( '<STR_LIT>' ) :"}, {"prompt": "<s> from six . moves . urllib . request import urlopen <EOL> import vcr <EOL>", "answer": "def test_ignore_localhost ( tmpdir , httpserver ) :"}, {"prompt": "<s> <NUM_LIT:2> <EOL> <NUM_LIT:3> + <NUM_LIT:5> <EOL> <NUM_LIT:2> + <NUM_LIT:3> * <NUM_LIT:5> <EOL> a + b * c <EOL> a << <NUM_LIT:2> <EOL> ( a - <NUM_LIT:2> ) * ( b + c ) / d <EOL> a % b <EOL> ( c >> <NUM_LIT:3> ) * d <EOL> ( a | b ) ^ ( c & d ) <EOL> ( a and b ) or ( c and d ) <EOL> ( a < b ) and ( c <= d ) or ( e > f ) and ( g > h ) <EOL> ( a == b ) <EOL> ( a != b ) <EOL> not ( a == b ) <EOL> ( - a ) <EOL> ( + a ) <EOL> a < b < c <EOL> a <= b > c <EOL> a in x <EOL> a not in y <EOL> a is None <EOL> b is not None <EOL> ( <NUM_LIT:2> , <NUM_LIT:3> ) <EOL> [ <NUM_LIT:5> , <NUM_LIT:6> ] <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" != x <EOL> a . x <EOL> b . y . z <EOL> x if condition else y <EOL> [ <NUM_LIT:2> * x for x in li if x % <NUM_LIT:2> == <NUM_LIT:0> if x % <NUM_LIT:3> == <NUM_LIT:0> ] <EOL> ( g for g in it ) <EOL> ( <NUM_LIT:3> * g for g in [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ] ) <EOL> lambda x : <NUM_LIT:2> * x <EOL> lambda x_y : x_y [ <NUM_LIT:0> ] + x_y [ <NUM_LIT:1> ] <EOL> lambda x , * y : y <EOL>", "answer": "li [ <NUM_LIT:0> ]"}, {"prompt": "<s> from django_openid_auth . views import login_begin as django_login_begin , login_complete <EOL> from desktop . lib . django_util import render <EOL> from django . core import urlresolvers <EOL> import libopenid . conf <EOL> from libopenid . backend import OpenIDBackend <EOL> from libopenid . forms import OpenIDLoginFormExt <EOL> from django . conf import settings <EOL> import logging <EOL> from django . shortcuts import render_to_response <EOL> from django . template import RequestContext <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def login_begin ( request ) : <EOL> redirect_to = request . REQUEST . get ( '<STR_LIT>' , '<STR_LIT:/>' ) <EOL> is_first_login_ever = OpenIDBackend . is_first_login_ever ( ) <EOL> request . session . set_test_cookie ( ) <EOL> openid_url = getattr ( settings , '<STR_LIT>' , None ) <EOL> identity_url_prefix = getattr ( settings , '<STR_LIT>' , None ) <EOL> if openid_url is not None : <EOL> if request . method == '<STR_LIT:GET>' : <EOL> return render_to_response ( '<STR_LIT>' , { <EOL> '<STR_LIT:action>' : urlresolvers . reverse ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : redirect_to , <EOL> '<STR_LIT>' : is_first_login_ever , <EOL> '<STR_LIT>' : True <EOL> } , context_instance = RequestContext ( request ) ) <EOL> return django_login_begin ( request , template_name = '<STR_LIT>' , form_class = OpenIDLoginFormExt ) <EOL> setattr ( login_begin , '<STR_LIT>' , True ) <EOL>", "answer": "setattr ( login_complete , '<STR_LIT>' , True ) "}, {"prompt": "<s> from apicapi import apic_mapper <EOL> from oslo_utils import excutils <EOL> from networking_cisco . _i18n import _ <EOL> from neutron . db import db_base_plugin_v2 <EOL> from neutron . db import extraroute_db <EOL> from neutron . db import l3_dvr_db <EOL> from neutron . plugins . common import constants <EOL> from networking_cisco . plugins . ml2 . drivers . cisco . apic import mechanism_apic <EOL> class ApicL3ServicePlugin ( db_base_plugin_v2 . NeutronDbPluginV2 , <EOL> l3_dvr_db . L3_NAT_with_dvr_db_mixin , <EOL> extraroute_db . ExtraRoute_db_mixin ) : <EOL> supported_extension_aliases = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> def __init__ ( self ) : <EOL> super ( ApicL3ServicePlugin , self ) . __init__ ( ) <EOL> self . manager = mechanism_apic . APICMechanismDriver . get_apic_manager ( ) <EOL> self . name_mapper = self . manager . apic_mapper <EOL> self . synchronizer = None <EOL> self . manager . ensure_infra_created_on_apic ( ) <EOL> self . manager . ensure_bgp_pod_policy_created_on_apic ( ) <EOL> def _map_names ( self , context , <EOL> tenant_id , router_id , net_id , subnet_id ) : <EOL> context . _plugin = self <EOL> with apic_mapper . mapper_context ( context ) as ctx : <EOL> atenant_id = tenant_id and self . name_mapper . tenant ( ctx , tenant_id ) <EOL> arouter_id = router_id and self . name_mapper . router ( ctx , router_id ) <EOL> anet_id = net_id and self . name_mapper . network ( ctx , net_id ) <EOL> asubnet_id = subnet_id and self . name_mapper . subnet ( ctx , subnet_id ) <EOL> return atenant_id , arouter_id , anet_id , asubnet_id <EOL> @ staticmethod <EOL> def get_plugin_type ( ) : <EOL> return constants . L3_ROUTER_NAT <EOL> @ staticmethod <EOL> def get_plugin_description ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return _ ( \"<STR_LIT>\" ) <EOL> def sync_init ( f ) : <EOL> def inner ( inst , * args , ** kwargs ) : <EOL> if not inst . synchronizer : <EOL> inst . synchronizer = ( <EOL> mechanism_apic . APICMechanismDriver . <EOL> get_router_synchronizer ( inst ) ) <EOL> inst . synchronizer . sync_router ( ) <EOL> return f ( inst , * args , ** kwargs ) <EOL> return inner <EOL> def add_router_interface_postcommit ( self , context , router_id , <EOL> interface_info ) : <EOL> router = self . get_router ( context , router_id ) <EOL> self . update_router_postcommit ( context , router ) <EOL> if '<STR_LIT>' in interface_info : <EOL> subnet = self . get_subnet ( context , interface_info [ '<STR_LIT>' ] ) <EOL> network_id = subnet [ '<STR_LIT>' ] <EOL> tenant_id = subnet [ '<STR_LIT>' ] <EOL> else : <EOL> port = self . get_port ( context , interface_info [ '<STR_LIT>' ] ) <EOL> network_id = port [ '<STR_LIT>' ] <EOL> tenant_id = port [ '<STR_LIT>' ] <EOL> atenant_id , arouter_id , anetwork_id , _ = self . _map_names ( <EOL> context , tenant_id , router_id , network_id , None ) <EOL> self . manager . add_router_interface ( atenant_id , arouter_id , <EOL> anetwork_id ) <EOL> def remove_router_interface_precommit ( self , context , router_id , <EOL> interface_info ) : <EOL> if '<STR_LIT>' in interface_info : <EOL> subnet = self . get_subnet ( context , interface_info [ '<STR_LIT>' ] ) <EOL> network_id = subnet [ '<STR_LIT>' ] <EOL> tenant_id = subnet [ '<STR_LIT>' ] <EOL> else : <EOL> port = self . get_port ( context , interface_info [ '<STR_LIT>' ] ) <EOL> network_id = port [ '<STR_LIT>' ] <EOL> tenant_id = port [ '<STR_LIT>' ] <EOL> atenant_id , arouter_id , anetwork_id , _ = self . _map_names ( <EOL> context , tenant_id , router_id , network_id , None ) <EOL> self . manager . remove_router_interface ( atenant_id , arouter_id , <EOL> anetwork_id ) <EOL> def delete_router_precommit ( self , context , router_id ) : <EOL> context . _plugin = self <EOL> with apic_mapper . mapper_context ( context ) as ctx : <EOL> arouter_id = router_id and self . name_mapper . router ( ctx , router_id ) <EOL> self . manager . delete_router ( arouter_id ) <EOL> def update_router_postcommit ( self , context , router ) : <EOL> context . _plugin = self <EOL> with apic_mapper . mapper_context ( context ) as ctx : <EOL> arouter_id = router [ '<STR_LIT:id>' ] and self . name_mapper . router ( ctx , <EOL> router [ '<STR_LIT:id>' ] ) <EOL> with self . manager . apic . transaction ( ) as trs : <EOL> self . manager . create_router ( arouter_id , transaction = trs ) <EOL> if router [ '<STR_LIT>' ] : <EOL> self . manager . enable_router ( arouter_id , transaction = trs ) <EOL> else : <EOL> self . manager . disable_router ( arouter_id , transaction = trs ) <EOL> @ sync_init <EOL> def create_router ( self , * args , ** kwargs ) : <EOL> return super ( ApicL3ServicePlugin , self ) . create_router ( * args , ** kwargs ) <EOL> @ sync_init <EOL> def update_router ( self , context , id , router ) : <EOL> result = super ( ApicL3ServicePlugin , self ) . update_router ( context , <EOL> id , router ) <EOL> self . update_router_postcommit ( context , result ) <EOL> return result <EOL> @ sync_init <EOL> def get_router ( self , * args , ** kwargs ) : <EOL> return super ( ApicL3ServicePlugin , self ) . get_router ( * args , ** kwargs ) <EOL> @ sync_init <EOL> def get_routers ( self , * args , ** kwargs ) : <EOL> return super ( ApicL3ServicePlugin , self ) . get_routers ( * args , ** kwargs ) <EOL> @ sync_init <EOL> def get_routers_count ( self , * args , ** kwargs ) : <EOL> return super ( ApicL3ServicePlugin , self ) . get_routers_count ( * args , <EOL> ** kwargs ) <EOL> def delete_router ( self , context , router_id ) : <EOL> self . delete_router_precommit ( context , router_id ) <EOL> result = super ( ApicL3ServicePlugin , self ) . delete_router ( context , <EOL> router_id ) <EOL>", "answer": "return result"}, {"prompt": "<s> from __future__ import division <EOL> from vistrails . core import debug <EOL> import vistrails . core . modules . basic_modules as basic <EOL> import vistrails . core . modules . module_registry <EOL> from vistrails . core . modules . vistrails_module import Module , ModuleError , new_module , IncompleteImplementation <EOL> from vistrails . core . system import list2cmdline <EOL> import os <EOL> class ImageMagick ( Module ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def compute ( self ) : <EOL> raise IncompleteImplementation <EOL> def input_file_description ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> i = self . get_input ( \"<STR_LIT:input>\" ) <EOL> if self . has_input ( '<STR_LIT>' ) : <EOL> return self . get_input ( '<STR_LIT>' ) + '<STR_LIT::>' + i . name <EOL> else : <EOL> return i . name <EOL> def create_output_file ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . has_input ( '<STR_LIT>' ) : <EOL> s = '<STR_LIT:.>' + self . get_input ( '<STR_LIT>' ) <EOL> return self . interpreter . filePool . create_file ( suffix = s ) <EOL> else : <EOL> return self . interpreter . filePool . create_file ( suffix = '<STR_LIT>' ) <EOL> def run ( self , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = None <EOL> if configuration . check ( '<STR_LIT:path>' ) : <EOL> path = configuration . path <EOL>", "answer": "if path :"}, {"prompt": "<s> from BeautifulSoup import BeautifulSoup <EOL> from datetime import date , timedelta <EOL> from django . contrib . auth . models import User <EOL> from django . core . urlresolvers import reverse <EOL> from django . test . client import Client <EOL> from easy_split . experiments . models import ( Experiment , Participant , <EOL> DailyEngagementReport , <EOL> AnonymousVisitor , <EOL> GoalType , DailyConversionReport , <EOL> DailyConversionReportGoalData ) <EOL> from easy_split . experiments . tests . utils import TestCase <EOL> def get_tables ( html ) : <EOL> results = [ ] <EOL> soup = BeautifulSoup ( html ) <EOL> for table in soup . findAll ( '<STR_LIT>' ) : <EOL> rows = table . findAll ( '<STR_LIT>' ) <EOL> header = rows . pop ( <NUM_LIT:0> ) . findAll ( '<STR_LIT>' , text = True ) <EOL> header = [ h . strip ( ) for h in header if h . strip ( ) ] <EOL> data = [ r . findAll ( '<STR_LIT>' , text = True ) for r in rows ] <EOL> for row in data : <EOL> row [ : ] = [ d . strip ( ) for d in row if d . strip ( ) ] <EOL> results . append ( ( header , data ) ) <EOL> return results <EOL> def days_ago ( days ) : <EOL> return date . today ( ) - timedelta ( days = days ) <EOL> class TestExperimentViews ( object ) : <EOL> urls = '<STR_LIT>' <EOL> def setUp ( self ) : <EOL> staff_user = User ( username = \"<STR_LIT>\" , email = \"<STR_LIT>\" , <EOL> is_staff = True ) <EOL> staff_user . save ( ) <EOL> staff_user . set_password ( \"<STR_LIT>\" ) <EOL> staff_user . save ( ) <EOL> self . experiment1 = Experiment ( name = \"<STR_LIT>\" ) <EOL> self . experiment1 . save ( ) <EOL> self . experiment1 . state = Experiment . ENABLED_STATE <EOL> self . experiment1 . save ( ) <EOL> self . experiment1 . start_date -= timedelta ( days = <NUM_LIT:5> ) <EOL> self . experiment1 . save ( ) <EOL> goal_types = [ GoalType . objects . create ( name = '<STR_LIT>' % i ) <EOL> for i in range ( <NUM_LIT:3> ) ] <EOL> for i in range ( <NUM_LIT:1> , <NUM_LIT:6> ) : <EOL> DailyEngagementReport . objects . create ( date = days_ago ( i ) , <EOL> experiment = self . experiment1 , <EOL> control_score = <NUM_LIT> , <EOL> test_score = <NUM_LIT> , <EOL> control_group_size = <NUM_LIT:3> , <EOL> test_group_size = <NUM_LIT:5> , <EOL> confidence = <NUM_LIT> ) <EOL> conversion_report = DailyConversionReport . objects . create ( <EOL> date = days_ago ( i ) , <EOL> experiment = self . experiment1 , <EOL> overall_test_conversion = <NUM_LIT:12> , <EOL> overall_control_conversion = <NUM_LIT:9> , <EOL> test_group_size = <NUM_LIT> , <EOL> control_group_size = <NUM_LIT> , <EOL> confidence = <NUM_LIT> ) <EOL> for goal_type in goal_types : <EOL> DailyConversionReportGoalData . objects . create ( <EOL> report = conversion_report , <EOL> goal_type = goal_type , <EOL> test_conversion = <NUM_LIT:11> , <EOL> control_conversion = <NUM_LIT:7> , <EOL> confidence = <NUM_LIT> ) <EOL> self . experiment2 = Experiment ( name = \"<STR_LIT>\" ) <EOL> self . experiment2 . save ( ) <EOL> self . experiment3 = Experiment ( name = \"<STR_LIT>\" ) <EOL> self . experiment3 . save ( ) <EOL> self . experiment3 . state = Experiment . ENABLED_STATE <EOL> self . experiment3 . save ( ) <EOL> self . experiment3 . state = Experiment . PROMOTED_STATE <EOL> self . experiment3 . save ( ) <EOL> def testListExperimentsView ( self ) : <EOL> url = reverse ( '<STR_LIT>' ) <EOL> response = self . client . get ( url ) <EOL> self . assertEquals ( response . status_code , <NUM_LIT:200> ) <EOL> header , data = get_tables ( response . content ) [ <NUM_LIT:0> ] <EOL> data . sort ( ) <EOL> self . assertEquals ( [ u'<STR_LIT:Name>' , u'<STR_LIT>' , u'<STR_LIT>' , u'<STR_LIT>' ] , <EOL> header ) <EOL> self . assertEquals ( [ [ u'<STR_LIT>' , u'<STR_LIT>' , <EOL> unicode ( self . experiment1 . start_date ) , u'<STR_LIT:None>' ] , <EOL> [ u'<STR_LIT>' , u'<STR_LIT>' , u'<STR_LIT:None>' , u'<STR_LIT:None>' ] , <EOL> [ u'<STR_LIT>' , u'<STR_LIT>' , <EOL> unicode ( self . experiment3 . start_date ) , <EOL> unicode ( self . experiment3 . end_date ) ] ] , <EOL> data ) <EOL> def testAnonymousUserCannotAccessReports ( self ) : <EOL> self . client . logout ( ) <EOL> url = reverse ( '<STR_LIT>' , <EOL> args = [ '<STR_LIT>' ] ) <EOL> response = self . client . get ( url ) <EOL> self . assertEquals ( response . status_code , <NUM_LIT:200> ) <EOL> self . assertTrue ( '<STR_LIT>' in response . content ) <EOL> url = reverse ( '<STR_LIT>' ) <EOL> response = self . client . get ( url ) <EOL> self . assertEquals ( response . status_code , <NUM_LIT:200> ) <EOL> self . assertTrue ( '<STR_LIT>' in response . content ) <EOL> def testRegularUserCannotAccessReports ( self ) : <EOL> self . client . logout ( ) <EOL> regular_user = User ( username = \"<STR_LIT>\" , email = \"<STR_LIT>\" ) <EOL> regular_user . save ( ) <EOL> regular_user . set_password ( \"<STR_LIT>\" ) <EOL> regular_user . save ( ) <EOL> self . assertTrue ( self . client . login ( username = '<STR_LIT>' , <EOL> password = '<STR_LIT>' ) ) <EOL> url = reverse ( '<STR_LIT>' , <EOL> args = [ '<STR_LIT>' ] ) <EOL> response = self . client . get ( url ) <EOL> self . assertEquals ( response . status_code , <NUM_LIT:200> ) <EOL> self . assertTrue ( '<STR_LIT>' in response . content ) <EOL> url = reverse ( '<STR_LIT>' ) <EOL> response = self . client . get ( url ) <EOL> self . assertEquals ( response . status_code , <NUM_LIT:200> ) <EOL> self . assertTrue ( '<STR_LIT>' in response . content ) <EOL> def test404IfExperimentDoesntExist ( self ) : <EOL> url = reverse ( '<STR_LIT>' , <EOL> args = [ '<STR_LIT>' ] ) <EOL> response = self . client . get ( url ) <EOL> self . assertEquals ( response . status_code , <NUM_LIT> ) <EOL> def testExperimentDetailsView ( self ) : <EOL> url = reverse ( '<STR_LIT>' , <EOL> args = [ '<STR_LIT>' ] ) <EOL> response = self . client . get ( url ) <EOL> self . assertEquals ( response . status_code , <NUM_LIT:200> ) <EOL> tables = get_tables ( response . content ) <EOL> experiment_properties = tables . pop ( <NUM_LIT:0> ) <EOL> self . assertEquals ( [ u'<STR_LIT>' , u'<STR_LIT>' ] , <EOL> experiment_properties [ <NUM_LIT:0> ] ) <EOL> self . assertEquals ( [ [ u'<STR_LIT>' , u'<STR_LIT>' ] , <EOL> [ u'<STR_LIT>' , u'<STR_LIT>' ] , <EOL> [ u'<STR_LIT>' , <EOL> unicode ( self . experiment1 . start_date ) ] , <EOL> [ u'<STR_LIT>' , u'<STR_LIT:None>' ] ] , <EOL> experiment_properties [ <NUM_LIT:1> ] ) <EOL> conversion_summary = tables . pop ( <NUM_LIT:0> ) <EOL> self . assertEquals ( [ u'<STR_LIT>' , u'<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , u'<STR_LIT>' ] , <EOL> conversion_summary [ <NUM_LIT:0> ] ) <EOL> self . assertEquals ( [ [ u'<STR_LIT>' , u'<STR_LIT>' , u'<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' ] , <EOL> [ u'<STR_LIT>' , u'<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , u'<STR_LIT>' ] , <EOL> [ u'<STR_LIT>' , u'<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , u'<STR_LIT>' ] , <EOL> [ u'<STR_LIT>' , u'<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , u'<STR_LIT>' ] , <EOL> [ u'<STR_LIT>' , u'<STR_LIT>' , u'<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' ] ] , <EOL> conversion_summary [ <NUM_LIT:1> ] ) <EOL> engagement_summary = tables . pop ( <NUM_LIT:0> ) <EOL> self . assertEquals ( [ u'<STR_LIT>' , u'<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , u'<STR_LIT>' ] , <EOL> engagement_summary [ <NUM_LIT:0> ] ) <EOL> self . assertEquals ( [ [ u'<STR_LIT>' , u'<STR_LIT:3>' , u'<STR_LIT:5>' , u'<STR_LIT>' , u'<STR_LIT>' ] , <EOL> [ u'<STR_LIT>' , u'<STR_LIT>' , u'<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' ] ] , <EOL> engagement_summary [ <NUM_LIT:1> ] ) <EOL> conversion_details = tables . pop ( <NUM_LIT:0> ) <EOL> self . assertTrue ( conversion_details [ <NUM_LIT:0> ] ) <EOL> self . assertTrue ( conversion_details [ <NUM_LIT:1> ] ) <EOL> engagement_details = tables . pop ( <NUM_LIT:0> ) <EOL> self . assertEquals ( [ u'<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' ] , <EOL> engagement_details [ <NUM_LIT:0> ] ) <EOL> self . assertEquals ( [ unicode ( days_ago ( <NUM_LIT:1> ) ) , u'<STR_LIT:3>' , u'<STR_LIT>' , u'<STR_LIT:5>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , u'<STR_LIT>' ] , <EOL> engagement_details [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] ) <EOL> self . assertEquals ( [ ] , tables ) <EOL> def testVerifyHuman ( self ) : <EOL> experiment = Experiment ( name = \"<STR_LIT>\" ) <EOL> experiment . save ( ) <EOL> experiment . state = Experiment . ENABLED_STATE <EOL> experiment . save ( ) <EOL> other_experiment = Experiment ( name = \"<STR_LIT>\" ) <EOL> other_experiment . save ( ) <EOL> other_experiment . state = Experiment . ENABLED_STATE <EOL> other_experiment . save ( ) <EOL> self . client = Client ( ) <EOL> original_participants_count = Participant . objects . all ( ) . count ( ) <EOL> original_anonymous_visitors_count = AnonymousVisitor . objects . all ( ) . count ( ) <EOL> experiment_url = reverse ( '<STR_LIT>' , <EOL> args = [ experiment . name ] ) <EOL> response = self . client . get ( experiment_url ) <EOL> self . assertEquals ( response . status_code , <NUM_LIT:200> ) <EOL> self . assertEquals ( original_participants_count , <EOL> Participant . objects . all ( ) . count ( ) ) <EOL> self . assertEquals ( original_anonymous_visitors_count , <EOL> AnonymousVisitor . objects . all ( ) . count ( ) ) <EOL> confirm_human_url = reverse ( '<STR_LIT>' ) <EOL> response = self . client . get ( confirm_human_url ) <EOL> self . assertEquals ( response . status_code , <NUM_LIT> ) <EOL> self . assertEquals ( <NUM_LIT:0> , len ( response . content ) ) <EOL> self . assertEquals ( original_participants_count + <NUM_LIT:1> , <EOL> Participant . objects . all ( ) . count ( ) ) <EOL> self . assertEquals ( original_anonymous_visitors_count + <NUM_LIT:1> , <EOL> AnonymousVisitor . objects . all ( ) . count ( ) ) <EOL> response = self . client . get ( confirm_human_url ) <EOL>", "answer": "self . assertEquals ( response . status_code , <NUM_LIT> )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from . attribute_groups import DEFAULT_DELIM , PatternFieldGroup <EOL> from . properties import * <EOL> from . vocabs import VocabString <EOL> from . data_segment import DataSegment , DataSize <EOL> from . datetimewithprecision import DateTimeWithPrecision , DateWithPrecision <EOL> from . daterange import DateRange <EOL> from . digitalsignature import DigitalSignature , DigitalSignatureList <EOL> from . environment_variable import EnvironmentVariable , EnvironmentVariableList <EOL> from . hashes import Hash , HashList , HashName <EOL> from . object_properties import ObjectProperties , Property <EOL> from . structured_text import StructuredText <EOL> from . time import Time <EOL>", "answer": "from . tools import ToolInformation , ToolInformationList , ToolType"}, {"prompt": "<s> studybuddy_1 = '<STR_LIT>' <EOL>", "answer": "studybuddy_2 = '<STR_LIT>'"}, {"prompt": "<s> import os <EOL> from angular_scaffold . management . commands . helpers . _update_dependencies import update_dependencies <EOL> _routes = \"\"\"<STR_LIT>\"\"\" <EOL> def generate_routes ( directory ) : <EOL> filename = os . path . join ( directory , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> print \"<STR_LIT>\" + filename <EOL> with open ( filename , '<STR_LIT:w>' ) as f : <EOL> f . write ( _routes ) <EOL>", "answer": "print \"<STR_LIT>\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function <EOL> import cmd <EOL> import itertools <EOL> import pkg_resources <EOL> import platform <EOL> from prettytable import PrettyTable <EOL> import six <EOL> import sys <EOL> from oslo_serialization import jsonutils <EOL> from networking_cisco . apps . saf . common import config <EOL> from networking_cisco . apps . saf . common import constants <EOL> from networking_cisco . apps . saf . common import dfa_exceptions as dexc <EOL> from networking_cisco . apps . saf . common import rpc <EOL> from networking_cisco . apps . saf . common import utils <EOL> from networking_cisco . apps . saf . server import cisco_dfa_rest as cdr <EOL> class DfaCli ( cmd . Cmd ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> prompt = '<STR_LIT>' <EOL> intro = '<STR_LIT>' <EOL> def __init__ ( self ) : <EOL> self . ctl_host = platform . node ( ) <EOL> cmd . Cmd . __init__ ( self ) <EOL> self . _cfg = config . CiscoDFAConfig ( ) . cfg <EOL> self . dcnm_client = cdr . DFARESTClient ( self . _cfg ) <EOL> self . setup_client_rpc ( ) <EOL> self . clnt = None <EOL> def setup_client_rpc ( self ) : <EOL> url = self . _cfg . dfa_rpc . transport_url % ( <EOL> { '<STR_LIT>' : self . ctl_host } ) <EOL> self . clnt = rpc . DfaRpcClient ( url , constants . DFA_SERVER_QUEUE ) <EOL> def set_static_ip_address ( self , ipaddr , macaddr ) : <EOL> context = { } <EOL> args = jsonutils . dumps ( dict ( mac = macaddr , ip = ipaddr ) ) <EOL> msg = self . clnt . make_msg ( '<STR_LIT>' , context , msg = args ) <EOL> resp = self . clnt . cast ( msg ) <EOL> return resp <EOL> def do_set_static_ip ( self , line ) : <EOL> args = line . split ( ) <EOL> ip_mac = dict ( itertools . izip_longest ( args [ : : <NUM_LIT:2> ] , args [ <NUM_LIT:1> : : <NUM_LIT:2> ] , <EOL> fillvalue = '<STR_LIT>' ) ) <EOL> ipaddr = ip_mac . get ( '<STR_LIT>' ) <EOL> macaddr = ip_mac . get ( '<STR_LIT>' ) <EOL> if ( not ipaddr or not macaddr or <EOL> not utils . is_valid_ipv4 ( ipaddr ) <EOL> or not utils . is_valid_mac ( macaddr ) ) : <EOL> print ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> return <EOL> self . set_static_ip_address ( ipaddr , macaddr ) <EOL> def do_get_config_profile ( self , line ) : <EOL> try : <EOL> cfgp_list = self . dcnm_client . config_profile_list ( ) <EOL> if not cfgp_list : <EOL> print ( '<STR_LIT>' ) <EOL> return <EOL> except dexc . DfaClientRequestFailed : <EOL> print ( '<STR_LIT>' ) <EOL> return <EOL> cfg_table = PrettyTable ( [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> for cfg in cfgp_list : <EOL> if cfg . startswith ( '<STR_LIT>' ) : <EOL> cfg_alias = cfg . split ( '<STR_LIT>' ) [ <NUM_LIT:1> ] . split ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> elif cfg . endswith ( '<STR_LIT>' ) : <EOL> cfg_alias = cfg . split ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> else : <EOL> cfg_alias = cfg <EOL> cfg_table . add_row ( [ cfg , cfg_alias ] ) <EOL> print ( cfg_table ) <EOL> def do_list_networks ( self , line ) : <EOL> tenant_name = line <EOL> if not tenant_name : <EOL> print ( '<STR_LIT>' ) <EOL> return <EOL> try : <EOL> part_name = self . _cfg . dcnm . default_partition_name <EOL> net_list = self . dcnm_client . list_networks ( tenant_name , part_name ) <EOL> if not net_list : <EOL> print ( '<STR_LIT>' ) <EOL> return <EOL> except dexc . DfaClientRequestFailed : <EOL> print ( '<STR_LIT>' ) <EOL> return <EOL> list_table = None <EOL> for net in net_list : <EOL> columns = net . keys ( ) <EOL> if list_table is None : <EOL> list_table = PrettyTable ( columns ) <EOL> if list_table : <EOL> list_table . add_row ( net . values ( ) ) <EOL> print ( list_table ) <EOL> def do_get_network ( self , line ) : <EOL> args = line . split ( ) <EOL> if len ( args ) < <NUM_LIT:2> : <EOL> print ( '<STR_LIT>' ) <EOL> return <EOL> if not args [ <NUM_LIT:1> ] . isdigit ( ) : <EOL> print ( '<STR_LIT>' , args [ <NUM_LIT:1> ] ) <EOL> return <EOL> try : <EOL> net = self . dcnm_client . get_network ( args [ <NUM_LIT:0> ] , args [ <NUM_LIT:1> ] ) <EOL> if not net : <EOL> print ( '<STR_LIT>' ) <EOL> return <EOL> except dexc . DfaClientRequestFailed : <EOL> print ( '<STR_LIT>' ) <EOL> return <EOL> net_table = PrettyTable ( net . keys ( ) ) <EOL> row = [ ] <EOL> for key , val in six . iteritems ( net ) : <EOL> if key == '<STR_LIT>' or key == '<STR_LIT>' : <EOL> val = str ( val ) <EOL> row . append ( val ) <EOL> net_table . add_row ( row ) <EOL> print ( net_table ) <EOL> def do_list_organizations ( self , line ) : <EOL> '''<STR_LIT>''' <EOL> org_list = self . dcnm_client . list_organizations ( ) <EOL> if not org_list : <EOL> print ( '<STR_LIT>' ) <EOL> return <EOL>", "answer": "org_table = PrettyTable ( [ '<STR_LIT>' ] )"}, {"prompt": "<s> from __future__ import with_statement , absolute_import <EOL> from gevent . monkey import patch_os <EOL> patch_os ( ) <EOL> import os <EOL> import sys <EOL> import errno <EOL> import logging <EOL> from signal import SIGHUP , SIGKILL , SIGQUIT , SIGINT , SIGTERM <EOL> import atexit <EOL> from zope . interface import implements <EOL> from gevent import sleep , spawn , socket , signal , version_info <EOL> from gevent . server import StreamServer <EOL> from gevent . event import Event <EOL> try : <EOL> from gevent . lock import Semaphore <EOL> except ImportError : <EOL> from gevent . coros import Semaphore <EOL> from . interfaces import IRequest <EOL> from . const import ( <EOL> FCGI_ABORT_REQUEST , <EOL> FCGI_AUTHORIZER , <EOL> FCGI_BEGIN_REQUEST , <EOL> FCGI_END_REQUEST , <EOL> FCGI_FILTER , <EOL> FCGI_GET_VALUES , <EOL> FCGI_GET_VALUES_RESULT , <EOL> FCGI_KEEP_CONN , <EOL> FCGI_NULL_REQUEST_ID , <EOL> FCGI_PARAMS , <EOL> FCGI_REQUEST_COMPLETE , <EOL> FCGI_RESPONDER , <EOL> FCGI_STDIN , <EOL> FCGI_DATA , <EOL> FCGI_UNKNOWN_ROLE , <EOL> FCGI_UNKNOWN_TYPE , <EOL> EXISTING_REQUEST_RECORD_TYPES , <EOL> ) <EOL> from . base import ( <EOL> Connection , <EOL> Record , <EOL> InputStream , <EOL> StdoutStream , <EOL> StderrStream , <EOL> ) <EOL> from . utils import ( <EOL> pack_pairs , <EOL> unpack_pairs , <EOL> unpack_begin_request , <EOL> pack_end_request , <EOL> pack_unknown_type , <EOL> ) <EOL> __all__ = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Request ( object ) : <EOL> implements ( IRequest ) <EOL> def __init__ ( self , conn , request_id , role ) : <EOL> self . conn = conn <EOL> self . id = request_id <EOL> self . role = role <EOL> self . environ = { } <EOL> self . stdin = InputStream ( ) <EOL> self . stdout = StdoutStream ( conn , request_id ) <EOL> self . stderr = StderrStream ( conn , request_id ) <EOL> self . greenlet = None <EOL> self . _environ = InputStream ( ) <EOL> class ServerConnection ( Connection ) : <EOL> def __init__ ( self , * args , ** kw ) : <EOL> super ( ServerConnection , self ) . __init__ ( * args , ** kw ) <EOL> self . lock = Semaphore ( ) <EOL> def write_record ( self , record ) : <EOL> with self . lock : <EOL> super ( ServerConnection , self ) . write_record ( record ) <EOL> HANDLE_RECORD_ATTR = '<STR_LIT>' <EOL> def record_handler ( record_type ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def decorator ( method ) : <EOL> setattr ( method , HANDLE_RECORD_ATTR , record_type ) <EOL> return method <EOL> return decorator <EOL> class ConnectionHandler ( object ) : <EOL> class __metaclass__ ( type ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __new__ ( cls , name , bases , attrs ) : <EOL> attrs [ '<STR_LIT>' ] = dict ( <EOL> ( getattr ( method , HANDLE_RECORD_ATTR ) , method ) <EOL> for name , method in attrs . items ( ) <EOL> if hasattr ( method , HANDLE_RECORD_ATTR ) ) <EOL> return type ( name , bases , attrs ) <EOL> def __init__ ( self , conn , role , capabilities , request_handler ) : <EOL> self . conn = conn <EOL> self . role = role <EOL> self . capabilities = capabilities <EOL> self . request_handler = request_handler <EOL> self . requests = { } <EOL> self . keep_open = None <EOL> self . closing = False <EOL> self . _job_is_done = Event ( ) <EOL> def run ( self ) : <EOL> reader = spawn ( self . read_records ) <EOL> reader . link ( self . _report_finished_job ) <EOL> event = self . _job_is_done <EOL> while True : <EOL> event . wait ( ) <EOL> event . clear ( ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if self . requests : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> elif self . keep_open and not reader . ready ( ) : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> else : <EOL> break <EOL> reader . kill ( ) <EOL> reader . join ( ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . conn . close ( ) <EOL> def handle_request ( self , request ) : <EOL> try : <EOL> logger . debug ( '<STR_LIT>' . format ( request . id ) ) <EOL> self . request_handler ( request ) <EOL> except : <EOL> logger . exception ( '<STR_LIT>' ) <EOL> raise <EOL> finally : <EOL> self . end_request ( request ) <EOL> def end_request ( self , request , request_status = FCGI_REQUEST_COMPLETE , <EOL> app_status = <NUM_LIT:0> ) : <EOL> try : <EOL> request . stdout . close ( ) <EOL> request . stderr . close ( ) <EOL> self . send_record ( FCGI_END_REQUEST , pack_end_request ( <EOL> app_status , request_status ) , request . id ) <EOL> finally : <EOL> del self . requests [ request . id ] <EOL> logger . debug ( '<STR_LIT>' . format ( request . id ) ) <EOL> def read_records ( self ) : <EOL> record_handlers = self . _record_handlers <EOL> requests = self . requests <EOL> for record in self . conn : <EOL> handler = record_handlers . get ( record . type ) <EOL> if handler is None : <EOL> logger . error ( '<STR_LIT>' . format ( record ) ) <EOL> self . send_record ( FCGI_UNKNOWN_TYPE , <EOL> pack_unknown_type ( record . type ) ) <EOL> break <EOL> if record . type in EXISTING_REQUEST_RECORD_TYPES : <EOL> request = requests . get ( record . request_id ) <EOL> if request is None : <EOL> logger . error ( <EOL> '<STR_LIT>' . format ( record ) ) <EOL> break <EOL> handler ( self , record , request ) <EOL> else : <EOL> handler ( self , record ) <EOL> def send_record ( <EOL> self , record_type , content = '<STR_LIT>' , request_id = FCGI_NULL_REQUEST_ID ) : <EOL> self . conn . write_record ( Record ( record_type , content , request_id ) ) <EOL> @ record_handler ( FCGI_GET_VALUES ) <EOL> def handle_get_values_record ( self , record ) : <EOL> pairs = ( ( name , self . capabilities . get ( name ) ) for name , _ in <EOL> unpack_pairs ( record . content ) ) <EOL> content = pack_pairs ( <EOL> ( name , str ( value ) ) for name , value in pairs ) <EOL> self . send_record ( FCGI_GET_VALUES_RESULT , content ) <EOL> self . _report_finished_job ( ) <EOL> @ record_handler ( FCGI_BEGIN_REQUEST ) <EOL> def handle_begin_request_record ( self , record ) : <EOL> role , flags = unpack_begin_request ( record . content ) <EOL> if role != self . role : <EOL> self . send_record ( FCGI_END_REQUEST , pack_end_request ( <EOL> <NUM_LIT:0> , FCGI_UNKNOWN_ROLE ) , record . request_id ) <EOL> logger . error ( <EOL> '<STR_LIT>' . format ( <EOL> role , self . role ) ) <EOL> self . _report_finished_job ( ) <EOL> else : <EOL> if self . keep_open is None : <EOL> self . keep_open = bool ( FCGI_KEEP_CONN & flags ) <EOL> request = Request ( self . conn , record . request_id , role ) <EOL> if role == FCGI_FILTER : <EOL> request . data = InputStream ( ) <EOL> self . requests [ request . id ] = request <EOL> @ record_handler ( FCGI_STDIN ) <EOL> def handle_stdin_record ( self , record , request ) : <EOL> request . stdin . feed ( record . content ) <EOL> @ record_handler ( FCGI_DATA ) <EOL> def handle_data_record ( self , record , request ) : <EOL> request . data . feed ( record . content ) <EOL> if not record . content and request . role == FCGI_FILTER : <EOL> self . spawn_request_handler ( request ) <EOL> @ record_handler ( FCGI_PARAMS ) <EOL> def handle_params_record ( self , record , request ) : <EOL> request . _environ . feed ( record . content ) <EOL> if not record . content : <EOL> request . environ = dict ( unpack_pairs ( request . _environ . read ( ) ) ) <EOL> del request . _environ <EOL> if request . role in ( FCGI_RESPONDER , FCGI_AUTHORIZER ) : <EOL> self . spawn_request_handler ( request ) <EOL> @ record_handler ( FCGI_ABORT_REQUEST ) <EOL> def handle_abort_request_record ( self , record , request ) : <EOL> logger . warn ( '<STR_LIT>' . format ( request . id ) ) <EOL> if request . id in self . requests : <EOL> greenlet = request . greenlet <EOL> if greenlet is None : <EOL> self . end_request ( request ) <EOL> self . _report_finished_job ( ) <EOL> else : <EOL> logger . warn ( '<STR_LIT>' . format ( <EOL> greenlet , request . id ) ) <EOL> greenlet . kill ( ) <EOL> greenlet . join ( ) <EOL> else : <EOL> logger . debug ( '<STR_LIT>' . format ( request . id ) ) <EOL> def spawn_request_handler ( self , request ) : <EOL> request . greenlet = g = spawn ( self . handle_request , request ) <EOL> g . link ( self . _report_finished_job ) <EOL> def _report_finished_job ( self , source = None ) : <EOL> self . _job_is_done . set ( ) <EOL> class FastCGIServer ( StreamServer ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , listener , request_handler , role = FCGI_RESPONDER , <EOL> num_workers = <NUM_LIT:1> , buffer_size = <NUM_LIT> , max_conns = <NUM_LIT> , <EOL> socket_mode = None , ** kwargs ) : <EOL> if isinstance ( listener , basestring ) : <EOL> self . _socket_file = listener <EOL> self . _socket_mode = socket_mode <EOL> self . _backlog = kwargs . pop ( '<STR_LIT>' , None ) <EOL> if self . _backlog is None : <EOL> self . _backlog = max_conns <EOL> listener = socket . socket ( socket . AF_UNIX , socket . SOCK_STREAM ) <EOL> super ( FastCGIServer , self ) . __init__ ( <EOL> listener , self . handle_connection , spawn = max_conns , ** kwargs ) <EOL> if role not in ( FCGI_RESPONDER , FCGI_FILTER , FCGI_AUTHORIZER ) : <EOL> raise ValueError ( '<STR_LIT>' . format ( role ) ) <EOL> self . max_conns = max_conns <EOL> self . role = role <EOL> self . request_handler = request_handler <EOL> self . buffer_size = buffer_size <EOL> self . capabilities = dict ( <EOL> FCGI_MAX_CONNS = str ( max_conns ) , <EOL> FCGI_MAX_REQS = str ( max_conns * <NUM_LIT> ) , <EOL> FCGI_MPXS_CONNS = '<STR_LIT:1>' , <EOL> ) <EOL> self . num_workers = int ( num_workers ) <EOL> assert self . num_workers > <NUM_LIT:0> , '<STR_LIT>' <EOL> self . _workers = [ ] <EOL> def start ( self ) : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if not self . started : <EOL> if hasattr ( self , '<STR_LIT>' ) : <EOL> self . _create_socket_file ( ) <EOL> super ( FastCGIServer , self ) . start ( ) <EOL> if self . num_workers > <NUM_LIT:1> : <EOL> self . _start_workers ( ) <EOL> self . _supervisor = spawn ( self . _watch_workers ) <EOL> atexit . register ( self . _cleanup ) <EOL> for signum in SIGINT , SIGTERM , SIGQUIT : <EOL> signal ( signum , sys . exit , <NUM_LIT:1> ) <EOL> def start_accepting ( self ) : <EOL> if self . _workers is None or self . num_workers == <NUM_LIT:1> : <EOL> super ( FastCGIServer , self ) . start_accepting ( ) <EOL> def stop_accepting ( self ) : <EOL> if self . _workers is None or self . num_workers == <NUM_LIT:1> : <EOL> super ( FastCGIServer , self ) . stop_accepting ( ) <EOL> def handle_connection ( self , sock , addr ) : <EOL> if sock . family in ( socket . AF_INET , socket . AF_INET6 ) : <EOL> sock . setsockopt ( socket . SOL_TCP , socket . TCP_NODELAY , <NUM_LIT:1> ) <EOL> sock . setsockopt ( socket . SOL_SOCKET , socket . SO_RCVBUF , <EOL> self . buffer_size ) <EOL> sock . setsockopt ( socket . SOL_SOCKET , socket . SO_SNDBUF , <EOL> self . buffer_size ) <EOL> conn = ServerConnection ( sock , self . buffer_size ) <EOL> handler = ConnectionHandler ( <EOL> conn , self . role , self . capabilities , self . request_handler ) <EOL> handler . run ( ) <EOL> if version_info < ( <NUM_LIT:1> , ) : <EOL> def kill ( self ) : <EOL> super ( FastCGIServer , self ) . kill ( ) <EOL> self . _cleanup ( ) <EOL> else : <EOL> def close ( self ) : <EOL> super ( FastCGIServer , self ) . close ( ) <EOL> self . _cleanup ( ) <EOL> def _start_workers ( self ) : <EOL> while len ( self . _workers ) < self . num_workers : <EOL> self . _start_worker ( ) <EOL> def _start_worker ( self ) : <EOL> pid = os . fork ( ) <EOL> if pid : <EOL> self . _workers . append ( pid ) <EOL> logger . debug ( '<STR_LIT>' . format ( pid ) ) <EOL> return pid <EOL> else : <EOL> try : <EOL> self . _workers = None <EOL> devnull_fd = os . open ( os . devnull , os . O_RDWR ) <EOL> try : <EOL> for fd in ( <NUM_LIT:0> , ) : <EOL> os . dup2 ( devnull_fd , fd ) <EOL> finally : <EOL> os . close ( devnull_fd ) <EOL> signal ( SIGHUP , self . stop ) <EOL> self . start_accepting ( ) <EOL> super ( FastCGIServer , self ) . serve_forever ( ) <EOL> finally : <EOL> os . _exit ( <NUM_LIT:0> ) <EOL> def _watch_workers ( self , check_interval = <NUM_LIT:5> ) : <EOL> keep_running = True <EOL> while keep_running : <EOL> self . _start_workers ( ) <EOL> try : <EOL> try : <EOL> sleep ( check_interval ) <EOL> self . _reap_workers ( ) <EOL> except self . Stop : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> keep_running = False <EOL> self . _reap_workers ( True ) <EOL> except OSError , e : <EOL> if e . errno != errno . ECHILD : <EOL> logger . exception ( '<STR_LIT>' ) <EOL> else : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def _reap_workers ( self , block = False ) : <EOL> flags = <NUM_LIT:0> if block else os . WNOHANG <EOL> while True : <EOL> pid , status = os . waitpid ( - <NUM_LIT:1> , flags ) <EOL> if pid == <NUM_LIT:0> : <EOL> break <EOL> elif pid in self . _workers : <EOL> logger . debug ( '<STR_LIT>' . format ( pid ) ) <EOL> self . _workers . remove ( pid ) <EOL> def _cleanup ( self ) : <EOL> if hasattr ( self , '<STR_LIT>' ) : <EOL> if self . _workers is not None : <EOL> try : <EOL> self . _kill_workers ( ) <EOL> finally : <EOL> self . _remove_socket_file ( ) <EOL> else : <EOL> self . _remove_socket_file ( ) <EOL> def _kill_workers ( self , kill_timeout = <NUM_LIT:2> ) : <EOL> for pid , sig in self . _killing_sequence ( kill_timeout ) : <EOL> try : <EOL> logger . debug ( <EOL> '<STR_LIT>' . format ( pid , sig ) ) <EOL> os . kill ( pid , sig ) <EOL> except OSError , x : <EOL> if x . errno == errno . ESRCH : <EOL> logger . error ( '<STR_LIT>' . format ( pid ) ) <EOL> if pid in self . _workers : <EOL> self . _workers . remove ( pid ) <EOL> elif x . errno == errno . ECHILD : <EOL> logger . error ( '<STR_LIT>' ) <EOL> self . _workers = [ ] <EOL>", "answer": "break"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> import sre_parse <EOL> import sre_compile <EOL> import sre_constants <EOL> from re import VERBOSE , MULTILINE , DOTALL <EOL> from sre_constants import BRANCH , SUBPATTERN <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> FLAGS = ( VERBOSE | MULTILINE | DOTALL ) <EOL> class Scanner ( object ) : <EOL> def __init__ ( self , lexicon , flags = FLAGS ) : <EOL> self . actions = [ None ] <EOL> s = sre_parse . Pattern ( ) <EOL> s . flags = flags <EOL> p = [ ] <EOL> for idx , token in enumerate ( lexicon ) : <EOL> phrase = token . pattern <EOL>", "answer": "try :"}, {"prompt": "<s> from conans . errors import AuthenticationException <EOL> class UserService ( object ) : <EOL> def __init__ ( self , authenticator , credentials_manager ) : <EOL>", "answer": "self . authenticator = authenticator"}, {"prompt": "<s> from . linter import Linter <EOL> from . import ( <EOL> highlight , <EOL> linter , <EOL> modules , <EOL> persist , <EOL> update , <EOL>", "answer": "util ,"}, {"prompt": "<s> import commands <EOL> def test ( data_path ) : <EOL> folder_data = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> file_data = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> output = '<STR_LIT>' <EOL> status = <NUM_LIT:0> <EOL> pad = <NUM_LIT:2> <EOL> cmd = '<STR_LIT>' + data_path + folder_data [ <NUM_LIT:0> ] + file_data [ <NUM_LIT:0> ] + '<STR_LIT>' + '<STR_LIT>' + str ( pad ) <EOL> output += '<STR_LIT>' + cmd + '<STR_LIT>' <EOL> s0 , o0 = commands . getstatusoutput ( cmd ) <EOL> status += s0 <EOL> output += o0 <EOL>", "answer": "cmd = '<STR_LIT>' + data_path + folder_data [ <NUM_LIT:1> ] + file_data [ <NUM_LIT:1> ] + '<STR_LIT>'"}, {"prompt": "<s> from __future__ import absolute_import , print_function , with_statement <EOL> import unittest <EOL> from mock import Mock , patch <EOL> from nose . tools import * <EOL> import six <EOL> from six . moves import range <EOL> from six . moves import zip <EOL> from behave . model_core import FileLocation <EOL> from behave . model import Feature , Scenario , ScenarioOutline , Step <EOL> from behave . model import Table , Row <EOL> from behave . matchers import NoMatch <EOL> from behave . configuration import Configuration <EOL> from behave . compat . collections import OrderedDict <EOL> from behave import step_registry <EOL> _text = six . text_type <EOL> class TestFeatureRun ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . runner = Mock ( ) <EOL> self . runner . feature . tags = [ ] <EOL> self . config = self . runner . config = Mock ( ) <EOL> self . context = self . runner . context = Mock ( ) <EOL> self . formatters = self . runner . formatters = [ Mock ( ) ] <EOL> self . run_hook = self . runner . run_hook = Mock ( ) <EOL> def test_formatter_feature_called ( self ) : <EOL> feature = Feature ( '<STR_LIT>' , <NUM_LIT:1> , u'<STR_LIT>' , u'<STR_LIT:foo>' , <EOL> background = Mock ( ) ) <EOL> feature . run ( self . runner ) <EOL> self . formatters [ <NUM_LIT:0> ] . feature . assert_called_with ( feature ) <EOL> def test_formatter_background_called_when_feature_has_background ( self ) : <EOL> feature = Feature ( '<STR_LIT>' , <NUM_LIT:1> , u'<STR_LIT>' , u'<STR_LIT:foo>' , <EOL> background = Mock ( ) ) <EOL> feature . run ( self . runner ) <EOL> self . formatters [ <NUM_LIT:0> ] . background . assert_called_with ( feature . background ) <EOL> def test_formatter_background_not_called_when_feature_has_no_background ( self ) : <EOL> feature = Feature ( '<STR_LIT>' , <NUM_LIT:1> , u'<STR_LIT>' , u'<STR_LIT:foo>' ) <EOL> feature . run ( self . runner ) <EOL> assert not self . formatters [ <NUM_LIT:0> ] . background . called <EOL> def test_run_runs_scenarios ( self ) : <EOL> scenarios = [ Mock ( ) , Mock ( ) ] <EOL> for scenario in scenarios : <EOL> scenario . tags = [ ] <EOL> scenario . run . return_value = False <EOL> self . config . tags . check . return_value = True <EOL> self . config . name = [ ] <EOL> feature = Feature ( '<STR_LIT>' , <NUM_LIT:1> , u'<STR_LIT>' , u'<STR_LIT:foo>' , <EOL> scenarios = scenarios ) <EOL> feature . run ( self . runner ) <EOL> for scenario in scenarios : <EOL> scenario . run . assert_called_with ( self . runner ) <EOL> def test_run_runs_named_scenarios ( self ) : <EOL> scenarios = [ Mock ( Scenario ) , Mock ( Scenario ) ] <EOL> scenarios [ <NUM_LIT:0> ] . name = '<STR_LIT>' <EOL> scenarios [ <NUM_LIT:1> ] . name = '<STR_LIT>' <EOL> scenarios [ <NUM_LIT:0> ] . tags = [ ] <EOL> scenarios [ <NUM_LIT:1> ] . tags = [ ] <EOL> scenarios [ <NUM_LIT:0> ] . should_run_with_name_select . return_value = True <EOL> scenarios [ <NUM_LIT:1> ] . should_run_with_name_select . return_value = False <EOL> for scenario in scenarios : <EOL> scenario . run . return_value = False <EOL> self . config . tags . check . return_value = True <EOL> self . config . name = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> self . config . name_re = Configuration . build_name_re ( self . config . name ) <EOL> feature = Feature ( '<STR_LIT>' , <NUM_LIT:1> , u'<STR_LIT>' , u'<STR_LIT:foo>' , <EOL> scenarios = scenarios ) <EOL> feature . run ( self . runner ) <EOL> scenarios [ <NUM_LIT:0> ] . run . assert_called_with ( self . runner ) <EOL> assert not scenarios [ <NUM_LIT:1> ] . run . called <EOL> scenarios [ <NUM_LIT:0> ] . should_run_with_name_select . assert_called_with ( self . config ) <EOL> scenarios [ <NUM_LIT:1> ] . should_run_with_name_select . assert_called_with ( self . config ) <EOL> def test_run_runs_named_scenarios_with_regexp ( self ) : <EOL> scenarios = [ Mock ( ) , Mock ( ) ] <EOL> scenarios [ <NUM_LIT:0> ] . name = '<STR_LIT>' <EOL> scenarios [ <NUM_LIT:1> ] . name = '<STR_LIT>' <EOL> scenarios [ <NUM_LIT:0> ] . tags = [ ] <EOL> scenarios [ <NUM_LIT:1> ] . tags = [ ] <EOL> scenarios [ <NUM_LIT:0> ] . should_run_with_name_select . return_value = False <EOL> scenarios [ <NUM_LIT:1> ] . should_run_with_name_select . return_value = True <EOL> for scenario in scenarios : <EOL> scenario . run . return_value = False <EOL> self . config . tags . check . return_value = True <EOL> self . config . name = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> self . config . name_re = Configuration . build_name_re ( self . config . name ) <EOL> feature = Feature ( '<STR_LIT>' , <NUM_LIT:1> , u'<STR_LIT>' , u'<STR_LIT:foo>' , <EOL> scenarios = scenarios ) <EOL> feature . run ( self . runner ) <EOL> assert not scenarios [ <NUM_LIT:0> ] . run . called <EOL> scenarios [ <NUM_LIT:1> ] . run . assert_called_with ( self . runner ) <EOL> scenarios [ <NUM_LIT:0> ] . should_run_with_name_select . assert_called_with ( self . config ) <EOL> scenarios [ <NUM_LIT:1> ] . should_run_with_name_select . assert_called_with ( self . config ) <EOL> def test_feature_hooks_not_run_if_feature_not_being_run ( self ) : <EOL> self . config . tags . check . return_value = False <EOL> feature = Feature ( '<STR_LIT>' , <NUM_LIT:1> , u'<STR_LIT>' , u'<STR_LIT:foo>' ) <EOL> feature . run ( self . runner ) <EOL> assert not self . run_hook . called <EOL> class TestScenarioRun ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . runner = Mock ( ) <EOL> self . runner . feature . tags = [ ] <EOL> self . config = self . runner . config = Mock ( ) <EOL> self . config . dry_run = False <EOL> self . context = self . runner . context = Mock ( ) <EOL> self . formatters = self . runner . formatters = [ Mock ( ) ] <EOL> self . run_hook = self . runner . run_hook = Mock ( ) <EOL> def test_run_invokes_formatter_scenario_and_steps_correctly ( self ) : <EOL> self . config . stdout_capture = False <EOL> self . config . log_capture = False <EOL> self . config . tags . check . return_value = True <EOL> steps = [ Mock ( ) , Mock ( ) ] <EOL> scenario = Scenario ( '<STR_LIT>' , <NUM_LIT> , u'<STR_LIT>' , u'<STR_LIT:foo>' , <EOL> steps = steps ) <EOL> scenario . run ( self . runner ) <EOL> self . formatters [ <NUM_LIT:0> ] . scenario . assert_called_with ( scenario ) <EOL> for step in steps : <EOL> step . run . assert_called_with ( self . runner ) <EOL> if six . PY3 : <EOL> stringio_target = '<STR_LIT>' <EOL> else : <EOL> stringio_target = '<STR_LIT>' <EOL> def test_handles_stdout_and_log_capture ( self ) : <EOL> self . config . stdout_capture = True <EOL> self . config . log_capture = True <EOL> self . config . tags . check . return_value = True <EOL> steps = [ Mock ( ) , Mock ( ) ] <EOL> scenario = Scenario ( '<STR_LIT>' , <NUM_LIT> , u'<STR_LIT>' , u'<STR_LIT:foo>' , <EOL> steps = steps ) <EOL> scenario . run ( self . runner ) <EOL> self . runner . setup_capture . assert_called_with ( ) <EOL> self . runner . teardown_capture . assert_called_with ( ) <EOL> def test_failed_step_causes_remaining_steps_to_be_skipped ( self ) : <EOL> self . config . stdout_capture = False <EOL> self . config . log_capture = False <EOL> self . config . tags . check . return_value = True <EOL> steps = [ Mock ( ) , Mock ( ) ] <EOL> scenario = Scenario ( '<STR_LIT>' , <NUM_LIT> , u'<STR_LIT>' , u'<STR_LIT:foo>' , <EOL> steps = steps ) <EOL> steps [ <NUM_LIT:0> ] . run . return_value = False <EOL> steps [ <NUM_LIT:1> ] . step_type = \"<STR_LIT>\" <EOL> steps [ <NUM_LIT:1> ] . name = \"<STR_LIT>\" <EOL> def step1_function ( context ) : <EOL> pass <EOL> my_step_registry = step_registry . StepRegistry ( ) <EOL> my_step_registry . add_step_definition ( \"<STR_LIT>\" , \"<STR_LIT>\" , step1_function ) <EOL> with patch ( \"<STR_LIT>\" , my_step_registry ) : <EOL> assert scenario . run ( self . runner ) <EOL> eq_ ( steps [ <NUM_LIT:1> ] . status , '<STR_LIT>' ) <EOL> def test_failed_step_causes_context_failure_to_be_set ( self ) : <EOL> self . config . stdout_capture = False <EOL> self . config . log_capture = False <EOL> self . config . tags . check . return_value = True <EOL> steps = [ <EOL> Mock ( step_type = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) , <EOL> Mock ( step_type = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) , <EOL> ] <EOL> scenario = Scenario ( '<STR_LIT>' , <NUM_LIT> , u'<STR_LIT>' , u'<STR_LIT:foo>' , <EOL> steps = steps ) <EOL> steps [ <NUM_LIT:0> ] . run . return_value = False <EOL> assert scenario . run ( self . runner ) <EOL> self . context . _set_root_attribute . assert_called_with ( '<STR_LIT>' , True ) <EOL> def test_undefined_step_causes_failed_scenario_status ( self ) : <EOL> self . config . stdout_capture = False <EOL> self . config . log_capture = False <EOL> self . config . tags . check . return_value = True <EOL> passed_step = Mock ( ) <EOL> undefined_step = Mock ( ) <EOL> steps = [ passed_step , undefined_step ] <EOL> scenario = Scenario ( '<STR_LIT>' , <NUM_LIT> , u'<STR_LIT>' , u'<STR_LIT:foo>' , <EOL> steps = steps ) <EOL> passed_step . run . return_value = True <EOL> passed_step . status = '<STR_LIT>' <EOL> undefined_step . run . return_value = False <EOL> undefined_step . status = '<STR_LIT>' <EOL> assert scenario . run ( self . runner ) <EOL> eq_ ( undefined_step . status , '<STR_LIT>' ) <EOL> eq_ ( scenario . status , '<STR_LIT>' ) <EOL> self . context . _set_root_attribute . assert_called_with ( '<STR_LIT>' , True ) <EOL> def test_skipped_steps_set_step_status_and_scenario_status_if_not_set ( self ) : <EOL> self . config . stdout_capture = False <EOL> self . config . log_capture = False <EOL> self . config . tags . check . return_value = False <EOL> steps = [ Mock ( ) , Mock ( ) ] <EOL> scenario = Scenario ( '<STR_LIT>' , <NUM_LIT> , u'<STR_LIT>' , u'<STR_LIT:foo>' , <EOL> steps = steps ) <EOL> scenario . run ( self . runner ) <EOL> assert False not in [ s . status == '<STR_LIT>' for s in steps ] <EOL> eq_ ( scenario . status , '<STR_LIT>' ) <EOL> def test_scenario_hooks_not_run_if_scenario_not_being_run ( self ) : <EOL> self . config . tags . check . return_value = False <EOL> scenario = Scenario ( '<STR_LIT>' , <NUM_LIT> , u'<STR_LIT>' , u'<STR_LIT:foo>' ) <EOL> scenario . run ( self . runner ) <EOL> assert not self . run_hook . called <EOL> def test_should_run_with_name_select ( self ) : <EOL> scenario_name = u\"<STR_LIT>\" <EOL> scenario = Scenario ( \"<STR_LIT>\" , <NUM_LIT> , u\"<STR_LIT>\" , scenario_name ) <EOL> self . config . name = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> self . config . name_re = Configuration . build_name_re ( self . config . name ) <EOL> assert scenario . should_run_with_name_select ( self . config ) <EOL> class TestScenarioOutline ( unittest . TestCase ) : <EOL> def test_run_calls_run_on_each_generated_scenario ( self ) : <EOL> outline = ScenarioOutline ( '<STR_LIT>' , <NUM_LIT> , u'<STR_LIT>' , <EOL> u'<STR_LIT:foo>' ) <EOL> outline . _scenarios = [ Mock ( ) , Mock ( ) ] <EOL> for scenario in outline . _scenarios : <EOL> scenario . run . return_value = False <EOL> runner = Mock ( ) <EOL> runner . context = Mock ( ) <EOL> outline . run ( runner ) <EOL> for s in outline . _scenarios : <EOL> s . run . assert_called_with ( runner ) <EOL> def test_run_stops_on_first_failure_if_requested ( self ) : <EOL> outline = ScenarioOutline ( '<STR_LIT>' , <NUM_LIT> , u'<STR_LIT>' , <EOL> u'<STR_LIT:foo>' ) <EOL> outline . _scenarios = [ Mock ( ) , Mock ( ) ] <EOL> outline . _scenarios [ <NUM_LIT:0> ] . run . return_value = True <EOL> runner = Mock ( ) <EOL> runner . context = Mock ( ) <EOL> config = runner . config = Mock ( ) <EOL> config . stop = True <EOL> outline . run ( runner ) <EOL> outline . _scenarios [ <NUM_LIT:0> ] . run . assert_called_with ( runner ) <EOL> assert not outline . _scenarios [ <NUM_LIT:1> ] . run . called <EOL> def test_run_sets_context_variable_for_outline ( self ) : <EOL> outline = ScenarioOutline ( '<STR_LIT>' , <NUM_LIT> , u'<STR_LIT>' , <EOL> u'<STR_LIT:foo>' ) <EOL> outline . _scenarios = [ Mock ( ) , Mock ( ) , Mock ( ) ] <EOL> for scenario in outline . _scenarios : <EOL> scenario . run . return_value = False <EOL> runner = Mock ( ) <EOL> context = runner . context = Mock ( ) <EOL> config = runner . config = Mock ( ) <EOL> config . stop = True <EOL> outline . run ( runner ) <EOL> eq_ ( context . _set_root_attribute . call_args_list , [ <EOL> ( ( '<STR_LIT>' , outline . _scenarios [ <NUM_LIT:0> ] . _row ) , { } ) , <EOL> ( ( '<STR_LIT>' , outline . _scenarios [ <NUM_LIT:1> ] . _row ) , { } ) , <EOL> ( ( '<STR_LIT>' , outline . _scenarios [ <NUM_LIT:2> ] . _row ) , { } ) , <EOL> ( ( '<STR_LIT>' , None ) , { } ) , <EOL> ] ) <EOL> def test_run_should_pass_when_all_examples_pass ( self ) : <EOL> outline = ScenarioOutline ( '<STR_LIT>' , <NUM_LIT> , u'<STR_LIT>' , <EOL> u'<STR_LIT:foo>' ) <EOL> outline . _scenarios = [ Mock ( ) , Mock ( ) , Mock ( ) ] <EOL> for scenario in outline . _scenarios : <EOL> scenario . run . return_value = False <EOL> runner = Mock ( ) <EOL> context = runner . context = Mock ( ) <EOL> config = runner . config = Mock ( ) <EOL>", "answer": "config . stop = True"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> from tastypie . authorization import Authorization <EOL> from tastypie . exceptions import Unauthorized <EOL> logger = logging . getLogger ( __name__ ) <EOL> class GuardianAuthorization ( Authorization ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def base_checks ( self , request , model_klass ) : <EOL> if not model_klass or not getattr ( model_klass , '<STR_LIT>' , None ) : <EOL> return False <EOL> if not hasattr ( request , '<STR_LIT:user>' ) : <EOL> return False <EOL> return model_klass <EOL> def read_list ( self , object_list , bundle ) : <EOL> klass = self . base_checks ( bundle . request , object_list . model ) <EOL> has_results = False <EOL> has_objects = object_list . count ( ) <EOL> if klass is False : <EOL> return [ ] <EOL> permission = '<STR_LIT>' % ( klass . _meta . verbose_name ) <EOL> for obj in object_list : <EOL> if bundle . request . user . has_perms ( permission , obj ) : <EOL> has_results = True <EOL> else : <EOL> object_list . exclude ( id = obj . id ) <EOL> if has_results : <EOL> return object_list <EOL> if has_objects > <NUM_LIT:0> and not has_results : <EOL> raise Unauthorized ( \"<STR_LIT>\" ) <EOL> return object_list <EOL> def read_detail ( self , object_list , bundle ) : <EOL> klass = self . base_checks ( bundle . request , bundle . obj . __class__ ) <EOL> read_list = [ ] <EOL> if klass is False : <EOL> raise Unauthorized ( \"<STR_LIT>\" ) <EOL> permission = '<STR_LIT>' % ( klass . _meta . verbose_name ) <EOL> for obj in object_list : <EOL> if bundle . request . user . has_perms ( permission , obj ) : <EOL> read_list . append ( obj ) <EOL> if read_list : <EOL> return True <EOL> raise Unauthorized ( \"<STR_LIT>\" ) <EOL> def create_list ( self , object_list , bundle ) : <EOL> klass = self . base_checks ( bundle . request , object_list . model ) <EOL> create_list = [ ] <EOL> logger . debug ( object_list ) <EOL> if klass is False : <EOL> return [ ] <EOL>", "answer": "permission = '<STR_LIT>' % ( klass . _meta . verbose_name )"}, {"prompt": "<s> from test import test_support <EOL> import symtable <EOL> import unittest <EOL> class SymtableTest ( unittest . TestCase ) : <EOL> def test_invalid_args ( self ) : <EOL> self . assertRaises ( TypeError , symtable . symtable , \"<STR_LIT>\" ) <EOL> self . assertRaises ( ValueError , symtable . symtable , \"<STR_LIT>\" , \"<STR_LIT:?>\" , \"<STR_LIT>\" ) <EOL> def test_eval ( self ) : <EOL> symbols = symtable . symtable ( \"<STR_LIT>\" , \"<STR_LIT:?>\" , \"<STR_LIT>\" ) <EOL> def test_single ( self ) : <EOL> symbols = symtable . symtable ( \"<STR_LIT>\" , \"<STR_LIT:?>\" , \"<STR_LIT>\" ) <EOL> def test_exec ( self ) : <EOL> symbols = symtable . symtable ( \"<STR_LIT>\" , \"<STR_LIT:?>\" , \"<STR_LIT>\" ) <EOL>", "answer": "def test_main ( ) :"}, {"prompt": "<s> r\"\"\"<STR_LIT>\"\"\" <EOL> __version__ = '<STR_LIT>' <EOL> __all__ = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> ] <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import warnings <EOL> warnings . warn ( '<STR_LIT>' , DeprecationWarning ) <EOL> from simplejson . decoder import JSONDecoder <EOL> from simplejson . encoder import JSONEncoder <EOL> else : <EOL> from decoder import JSONDecoder <EOL> from encoder import JSONEncoder <EOL> _default_encoder = JSONEncoder ( <EOL> skipkeys = False , <EOL> ensure_ascii = True , <EOL> check_circular = True , <EOL> allow_nan = True , <EOL> indent = None , <EOL> separators = None , <EOL> encoding = '<STR_LIT:utf-8>' , <EOL> default = None , <EOL> ) <EOL> def dump ( obj , fp , skipkeys = False , ensure_ascii = True , check_circular = True , <EOL> allow_nan = True , cls = None , indent = None , separators = None , <EOL> encoding = '<STR_LIT:utf-8>' , default = None , ** kw ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ( skipkeys is False and ensure_ascii is True and <EOL> check_circular is True and allow_nan is True and <EOL> cls is None and indent is None and separators is None and <EOL> encoding == '<STR_LIT:utf-8>' and default is None and not kw ) : <EOL> iterable = _default_encoder . iterencode ( obj ) <EOL> else : <EOL> if cls is None : <EOL> cls = JSONEncoder <EOL> iterable = cls ( skipkeys = skipkeys , ensure_ascii = ensure_ascii , <EOL> check_circular = check_circular , allow_nan = allow_nan , indent = indent , <EOL> separators = separators , encoding = encoding , <EOL> default = default , ** kw ) . iterencode ( obj ) <EOL> for chunk in iterable : <EOL> fp . write ( chunk ) <EOL> def dumps ( obj , skipkeys = False , ensure_ascii = True , check_circular = True , <EOL> allow_nan = True , cls = None , indent = None , separators = None , <EOL> encoding = '<STR_LIT:utf-8>' , default = None , ** kw ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ( skipkeys is False and ensure_ascii is True and <EOL> check_circular is True and allow_nan is True and <EOL> cls is None and indent is None and separators is None and <EOL> encoding == '<STR_LIT:utf-8>' and default is None and not kw ) : <EOL> return _default_encoder . encode ( obj ) <EOL> if cls is None : <EOL> cls = JSONEncoder <EOL> return cls ( <EOL> skipkeys = skipkeys , ensure_ascii = ensure_ascii , <EOL> check_circular = check_circular , allow_nan = allow_nan , indent = indent , <EOL> separators = separators , encoding = encoding , default = default , <EOL> ** kw ) . encode ( obj ) <EOL> _default_decoder = JSONDecoder ( encoding = None , object_hook = None ) <EOL> def load ( fp , encoding = None , cls = None , object_hook = None , parse_float = None , <EOL> parse_int = None , parse_constant = None , ** kw ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return loads ( fp . read ( ) , <EOL> encoding = encoding , cls = cls , object_hook = object_hook , <EOL> parse_float = parse_float , parse_int = parse_int , <EOL> parse_constant = parse_constant , ** kw ) <EOL> def loads ( s , encoding = None , cls = None , object_hook = None , parse_float = None , <EOL> parse_int = None , parse_constant = None , ** kw ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ( cls is None and encoding is None and object_hook is None and <EOL> parse_int is None and parse_float is None and <EOL> parse_constant is None and not kw ) : <EOL> return _default_decoder . decode ( s ) <EOL> if cls is None : <EOL> cls = JSONDecoder <EOL> if object_hook is not None : <EOL> kw [ '<STR_LIT>' ] = object_hook <EOL> if parse_float is not None : <EOL> kw [ '<STR_LIT>' ] = parse_float <EOL> if parse_int is not None : <EOL> kw [ '<STR_LIT>' ] = parse_int <EOL> if parse_constant is not None : <EOL> kw [ '<STR_LIT>' ] = parse_constant <EOL> return cls ( encoding = encoding , ** kw ) . decode ( s ) <EOL> def decode ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> import warnings <EOL> warnings . warn ( \"<STR_LIT>\" , <EOL> DeprecationWarning ) <EOL> return loads ( s ) <EOL> def encode ( obj ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from pythonforandroid . recipe import PythonRecipe <EOL> class PyusbRecipe ( PythonRecipe ) : <EOL> name = '<STR_LIT>' <EOL> version = '<STR_LIT>' <EOL> url = '<STR_LIT>' <EOL> depends = [ ( '<STR_LIT>' , '<STR_LIT>' ) ] <EOL> site_packages_name = '<STR_LIT>' <EOL> patches = [ '<STR_LIT>' ] <EOL>", "answer": "recipe = PyusbRecipe ( ) "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . db import models <EOL> from django . utils . encoding import python_2_unicode_compatible <EOL> @ python_2_unicode_compatible <EOL> class Publication ( models . Model ) : <EOL> title = models . CharField ( max_length = <NUM_LIT:30> ) <EOL> def __str__ ( self ) : <EOL> return self . title <EOL> class Meta : <EOL> ordering = ( '<STR_LIT:title>' , ) <EOL> @ python_2_unicode_compatible <EOL> class Article ( models . Model ) : <EOL> headline = models . CharField ( max_length = <NUM_LIT:100> ) <EOL> publications = models . ManyToManyField ( Publication ) <EOL> def __str__ ( self ) : <EOL> return self . headline <EOL>", "answer": "class Meta :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import migrations , models <EOL> def set_default_date ( apps , schema_editor ) : <EOL> obj = apps . get_model ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for o in obj . objects . all ( ) : <EOL> o . date = o . created <EOL> o . save ( ) <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL>", "answer": "migrations . AddField ("}, {"prompt": "<s> from __future__ import with_statement <EOL> import logging <EOL> import os <EOL> from alembic import context <EOL> from sqlalchemy import MetaData <EOL> from sqlalchemy import engine_from_config , pool <EOL> from h . settings import database_url <EOL> config = context . config <EOL> from h import db <EOL> from h . api import db as api_db <EOL> from h import models <EOL> from h . api . models import annotation <EOL> target_metadata = MetaData ( naming_convention = db . Base . metadata . naming_convention ) <EOL> for metadata in [ db . Base . metadata , api_db . Base . metadata ] : <EOL> for t in metadata . tables . values ( ) : <EOL> t . tometadata ( target_metadata ) <EOL> def configure_logging ( ) : <EOL>", "answer": "logging . basicConfig ( format = '<STR_LIT>'"}, {"prompt": "<s> from datetime import date <EOL> from stdnet . utils import test <EOL> from stdnet . apps . columnts import ColumnTS <EOL> from . main import ColumnMixin , nan <EOL> class TestReadOnly ( ColumnMixin , test . TestCase ) : <EOL> @ classmethod <EOL> def after_setup ( cls ) : <EOL> cls . ts1 = yield cls . data . data1 . create ( cls ) <EOL> cls . ts2 = yield cls . data . data2 . create ( cls ) <EOL> cls . ts3 = yield cls . data . data3 . create ( cls ) <EOL> cls . mul1 = yield cls . data . data_mul1 . create ( cls ) <EOL> cls . mul2 = yield cls . data . data_mul2 . create ( cls ) <EOL> def test_info_simple ( self ) : <EOL> ts = yield self . empty ( ) <EOL> info = yield ts . info ( ) <EOL> self . assertEqual ( info [ '<STR_LIT:size>' ] , <NUM_LIT:0> ) <EOL> self . assertFalse ( '<STR_LIT:start>' in info ) <EOL> d1 = date ( <NUM_LIT> , <NUM_LIT:5> , <NUM_LIT:15> ) <EOL> d2 = date ( <NUM_LIT> , <NUM_LIT:5> , <NUM_LIT:16> ) <EOL> yield ts . update ( { d1 : { '<STR_LIT>' : <NUM_LIT> } , <EOL> d2 : { '<STR_LIT>' : <NUM_LIT> } } ) <EOL> info = yield ts . info ( ) <EOL> self . assertEqual ( info [ '<STR_LIT:size>' ] , <NUM_LIT:2> ) <EOL> self . assertEqual ( info [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <NUM_LIT:0> ) <EOL> self . assertEqual ( info [ '<STR_LIT:start>' ] . date ( ) , d1 ) <EOL>", "answer": "self . assertEqual ( info [ '<STR_LIT>' ] . date ( ) , d2 )"}, {"prompt": "<s> import json <EOL> import pyglet <EOL> from . parsers import TextureParser <EOL> class ScopedDict ( dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , arg = None , parent = None ) : <EOL> if arg is None : <EOL> arg = { } <EOL> super ( ScopedDict , self ) . __init__ ( ) <EOL> self . parent = parent <EOL> for k , v in arg . items ( ) : <EOL> if isinstance ( v , dict ) : <EOL> self [ k ] = ScopedDict ( v , self ) <EOL> else : <EOL> self [ k ] = v <EOL> def __getitem__ ( self , key ) : <EOL> if key is None : <EOL> return self <EOL> elif isinstance ( key , list ) or isinstance ( key , tuple ) : <EOL> if len ( key ) > <NUM_LIT:1> : <EOL> return self . __getitem__ ( key [ <NUM_LIT:0> ] ) . __getitem__ ( key [ <NUM_LIT:1> : ] ) <EOL> elif len ( key ) == <NUM_LIT:1> : <EOL> return self . __getitem__ ( key [ <NUM_LIT:0> ] ) <EOL> else : <EOL> return self <EOL> else : <EOL> try : <EOL> return dict . __getitem__ ( self , key ) <EOL> except KeyError : <EOL> if self . parent is not None : <EOL> return self . parent . __getitem__ ( key ) <EOL> else : <EOL> raise <EOL> def __setitem__ ( self , key , value ) : <EOL> if isinstance ( value , dict ) : <EOL> dict . __setitem__ ( self , key , ScopedDict ( value , self ) ) <EOL> else : <EOL> dict . __setitem__ ( self , key , value ) <EOL> def get ( self , key , default = None ) : <EOL> if isinstance ( key , list ) or isinstance ( key , tuple ) : <EOL> if len ( key ) > <NUM_LIT:1> : <EOL> return self . __getitem__ ( key [ <NUM_LIT:0> ] ) . get ( key [ <NUM_LIT:1> : ] , default ) <EOL> elif len ( key ) == <NUM_LIT:1> : <EOL> return self . get ( key [ <NUM_LIT:0> ] , default ) <EOL> else : <EOL> raise KeyError ( key ) <EOL> if key in self : <EOL> return dict . get ( self , key ) <EOL> elif self . parent : <EOL> return self . parent . get ( key , default ) <EOL> else : <EOL> return default <EOL> def get_path ( self , path , default = None ) : <EOL> assert isinstance ( path , list ) or isinstance ( path , tuple ) <EOL> if len ( path ) == <NUM_LIT:1> : <EOL> return self . get ( path [ <NUM_LIT:0> ] , default ) <EOL> else : <EOL> return self . __getitem__ ( path [ <NUM_LIT:0> ] ) . get_path ( path [ <NUM_LIT:1> : ] , default ) <EOL> def set_path ( self , path , value ) : <EOL> assert isinstance ( path , list ) or isinstance ( path , tuple ) <EOL> if len ( path ) == <NUM_LIT:1> : <EOL> return self . __setitem__ ( path [ <NUM_LIT:0> ] , value ) <EOL> else : <EOL> return self . __getitem__ ( path [ <NUM_LIT:0> ] ) . set_path ( path [ <NUM_LIT:1> : ] , value ) <EOL> class Theme ( ScopedDict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , dictionary , resources_path ) : <EOL> ScopedDict . __init__ ( self , dictionary , None ) <EOL> self . _parsers = [ TextureParser ( resources_path ) ] <EOL> self . build ( self , dictionary ) <EOL> def update ( self , E = None , ** F ) : <EOL> super ( Theme , self ) . update ( E , ** F ) <EOL> self . build ( self , E ) <EOL> def build_element ( self , key , value , target ) : <EOL> for parser in self . _parsers : <EOL> if parser . condition_fulfilled ( key ) : <EOL> target [ key ] = parser . parse_element ( value ) <EOL> return <EOL> if isinstance ( value , dict ) : <EOL> target [ key ] = ScopedDict ( parent = target ) <EOL> self . build ( target [ key ] , value ) <EOL> else : <EOL> target [ key ] = value <EOL> def build ( self , target , input_dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for key , value in input_dict . items ( ) : <EOL> self . build_element ( key , value , target ) <EOL> class ThemeFromPath ( Theme ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def __init__ ( self , resources_path ) :"}, {"prompt": "<s> from __future__ import absolute_import , division , print_function <EOL> import logging ; _L = logging . getLogger ( '<STR_LIT>' ) <EOL> from . compat import standard_library , PY2 <EOL> import ogr <EOL> import os <EOL> import errno <EOL> import socket <EOL> import mimetypes <EOL> import shutil <EOL> import re <EOL> import simplejson as json <EOL> from os import mkdir <EOL> from hashlib import md5 <EOL> from os . path import join , basename , exists , abspath , splitext <EOL> from urllib . parse import urlparse <EOL> from subprocess import check_output <EOL> from tempfile import mkstemp <EOL> from hashlib import sha1 <EOL> from shutil import move <EOL> import requests <EOL> import requests_ftp <EOL> requests_ftp . monkeypatch_session ( ) <EOL> _http_timeout = <NUM_LIT> <EOL> from . compat import csvopen , csvDictWriter <EOL> from . conform import X_FIELDNAME , Y_FIELDNAME , GEOM_FIELDNAME , attrib_types <EOL> def mkdirsp ( path ) : <EOL> try : <EOL> os . makedirs ( path ) <EOL> except OSError as exc : <EOL> if exc . errno == errno . EEXIST and os . path . isdir ( path ) : <EOL> pass <EOL> else : <EOL> raise <EOL> def request ( method , url , ** kwargs ) : <EOL> try : <EOL> _L . debug ( \"<STR_LIT>\" , url , kwargs . get ( '<STR_LIT>' ) or kwargs . get ( '<STR_LIT:data>' ) ) <EOL> return requests . request ( method , url , timeout = _http_timeout , ** kwargs ) <EOL> except requests . exceptions . SSLError as e : <EOL> _L . warning ( \"<STR_LIT>\" , url ) <EOL> return requests . request ( method , url , timeout = _http_timeout , verify = False , ** kwargs ) <EOL> class CacheResult : <EOL> cache = None <EOL> fingerprint = None <EOL>", "answer": "version = None"}, {"prompt": "<s> import matplotlib . pyplot as plt <EOL> import theanets <EOL> from utils import load_mnist , plot_filters <EOL> train , valid , _ = load_mnist ( labels = True ) <EOL> X , y = train <EOL> train = X . reshape ( ( - <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:1> ) ) , y <EOL> X , y = valid <EOL> valid = X . reshape ( ( - <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:1> ) ) , y <EOL> N = <NUM_LIT:10> <EOL> net = theanets . convolution . Classifier ( [ <EOL> <NUM_LIT:1> , <EOL>", "answer": "dict ( form = '<STR_LIT>' , size = N * N , filter_size = ( <NUM_LIT> , <NUM_LIT> ) ) ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import base64 <EOL> import urllib2 <EOL> import uuid <EOL> from googleads import dfp <EOL> ADVERTISER_ID = '<STR_LIT>' <EOL> ICON_URL = ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> APP_ICON_SMALL = ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> def main ( client , advertiser_id ) : <EOL> creative_service = client . GetService ( '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> creative_template_id = '<STR_LIT>' <EOL> image_data = urllib2 . urlopen ( ICON_URL ) . read ( ) <EOL> image_data = base64 . b64encode ( image_data ) <EOL> app_icon_data = urllib2 . urlopen ( APP_ICON_SMALL ) . read ( ) <EOL> app_icon_data = base64 . b64encode ( app_icon_data ) <EOL> creative = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' % uuid . uuid4 ( ) , <EOL> '<STR_LIT>' : advertiser_id , <EOL> '<STR_LIT:size>' : { '<STR_LIT:width>' : '<STR_LIT:1>' , '<STR_LIT>' : '<STR_LIT:1>' , '<STR_LIT>' : False } , <EOL> '<STR_LIT>' : creative_template_id , <EOL> '<STR_LIT>' : ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : image_data , <EOL> '<STR_LIT>' : '<STR_LIT>' % uuid . uuid4 ( ) <EOL> } <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : app_icon_data , <EOL> '<STR_LIT>' : '<STR_LIT>' % uuid . uuid4 ( ) <EOL> } <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:value>' : '<STR_LIT>' <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' : '<STR_LIT>' ,"}, {"prompt": "<s> try : <EOL> from urllib import urlencode <EOL> except ImportError : <EOL> from urllib . parse import urlencode <EOL> from pyshorteners import Shortener , Shorteners <EOL> from pyshorteners . shorteners import Awsm <EOL> from pyshorteners . exceptions import ( ShorteningErrorException , <EOL> ExpandingErrorException ) <EOL> import responses <EOL> import pytest <EOL> api_key = '<STR_LIT>' <EOL> s = Shortener ( Shorteners . AWSM , api_key = api_key , tool = '<STR_LIT>' ) <EOL> short_url = '<STR_LIT>' <EOL> expanded = '<STR_LIT>' <EOL> @ responses . activate <EOL> def test_awsm_short_method ( ) : <EOL> params = urlencode ( { <EOL> '<STR_LIT:url>' : expanded , <EOL> '<STR_LIT:key>' : api_key , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:v>' : <NUM_LIT:3> <EOL> } ) <EOL> url = '<STR_LIT>' . format ( s . api_url , params ) <EOL> responses . add ( responses . POST , url , body = short_url , match_querystring = True ) <EOL> shorten = s . short ( expanded ) <EOL> assert shorten == short_url <EOL> @ responses . activate <EOL> def test_awsm_short_method_bad_response ( ) : <EOL> url = '<STR_LIT>' . format ( s . api_url ) <EOL> responses . add ( responses . POST , url , body = short_url , status = <NUM_LIT> ) <EOL> with pytest . raises ( ShorteningErrorException ) : <EOL> s . short ( expanded ) <EOL> @ responses . activate <EOL> def test_awsm_expand_method_bad_response ( ) : <EOL> responses . add ( responses . GET , short_url , body = '<STR_LIT>' , status = <NUM_LIT> , <EOL> match_querystring = True ) <EOL>", "answer": "with pytest . raises ( ExpandingErrorException ) :"}, {"prompt": "<s> from django import template <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from horizon . browsers . breadcrumb import Breadcrumb <EOL> from horizon . tables import DataTable <EOL> from horizon . utils import html <EOL> class ResourceBrowser ( html . HTMLElement ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = None <EOL> verbose_name = None <EOL> navigation_table_class = None <EOL> content_table_class = None <EOL> navigation_kwarg_name = \"<STR_LIT>\" <EOL> content_kwarg_name = \"<STR_LIT>\" <EOL> navigable_item_name = _ ( \"<STR_LIT>\" ) <EOL>", "answer": "template = \"<STR_LIT>\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from os . path import join , abspath , dirname <EOL> from mayavi . scripts import mayavi2 <EOL> from mayavi . sources . vtk_file_reader import VTKFileReader <EOL> from mayavi . modules . outline import Outline <EOL>", "answer": "from mayavi . modules . grid_plane import GridPlane"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import random <EOL> import socket <EOL> from time import time <EOL> from itertools import izip , groupby <EOL> from warnings import warn <EOL> from functools import partial <EOL> from twisted . application import service <EOL> from twisted . internet import defer , protocol , error <EOL> from twisted . python import failure , log <EOL> from thrift import Thrift <EOL> from thrift . transport import TTwisted , TTransport <EOL> from thrift . protocol import TBinaryProtocol <EOL> from telephus . protocol import ( ManagedThriftRequest , ClientBusy , <EOL> InvalidThriftRequest ) <EOL> from telephus . cassandra import ttypes , Cassandra <EOL> from telephus . client import CassandraClient <EOL> from telephus . _sasl import ThriftSASLClientProtocol <EOL> ConsistencyLevel = ttypes . ConsistencyLevel <EOL> noop = lambda * a , ** kw : None <EOL> SYSTEM_KEYSPACES = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class NoKeyspacesAvailable ( UserWarning ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class NoNodesAvailable ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def lame_log_insufficient_nodes ( poolsize , pooltarget , pending_reqs , waittime ) : <EOL> msg = '<STR_LIT>' '<STR_LIT>' % ( pooltarget , poolsize , pending_reqs ) <EOL> if waittime is None : <EOL> msg += '<STR_LIT:)>' <EOL> else : <EOL> msg += '<STR_LIT>' % waittime <EOL> log . msg ( msg ) <EOL> class CassandraPoolParticipantClient ( TTwisted . ThriftClientProtocol ) : <EOL> thriftFactory = TBinaryProtocol . TBinaryProtocolAcceleratedFactory <EOL> def __init__ ( self ) : <EOL> TTwisted . ThriftClientProtocol . __init__ ( self , Cassandra . Client , <EOL> self . thriftFactory ( ) ) <EOL> def connectionMade ( self ) : <EOL> TTwisted . ThriftClientProtocol . connectionMade ( self ) <EOL> self . factory . clientConnectionMade ( self ) <EOL> def connectionLost ( self , reason ) : <EOL> tex = TTransport . TTransportException ( <EOL> type = TTransport . TTransportException . END_OF_FILE , <EOL> message = '<STR_LIT>' % reason ) <EOL> while self . client . _reqs : <EOL> k = iter ( self . client . _reqs ) . next ( ) <EOL> v = self . client . _reqs . pop ( k ) <EOL> v . errback ( tex ) <EOL> del self . client . _reqs <EOL> del self . client <EOL> class CassandraPoolParticipantSASLClient ( ThriftSASLClientProtocol ) : <EOL> thriftFactory = TBinaryProtocol . TBinaryProtocolAcceleratedFactory <EOL> def __init__ ( self , sasl_cred_factory ) : <EOL> ThriftSASLClientProtocol . __init__ ( self , Cassandra . Client , <EOL> self . thriftFactory ( ) ) <EOL> self . sasl_cred_factory = sasl_cred_factory <EOL> @ defer . inlineCallbacks <EOL> def connectionMade ( self ) : <EOL> peer = self . transport . getPeer ( ) <EOL> sasl_kwargs = yield defer . maybeDeferred ( <EOL> self . sasl_cred_factory , peer . host , peer . port ) <EOL> self . createSASLClient ( ** sasl_kwargs ) <EOL> try : <EOL> yield ThriftSASLClientProtocol . connectionMade ( self ) <EOL> except Exception , exc : <EOL> self . transport . loseConnection ( ) <EOL> self . factory . clientConnectionFailed ( self . factory . connector , failure . Failure ( exc ) ) <EOL> else : <EOL> self . factory . clientConnectionMade ( self ) <EOL> def connectionLost ( self , reason ) : <EOL> tex = TTransport . TTransportException ( <EOL> type = TTransport . TTransportException . END_OF_FILE , <EOL> message = '<STR_LIT>' % reason ) <EOL> if self . client : <EOL> while self . client . _reqs : <EOL> k = iter ( self . client . _reqs ) . next ( ) <EOL> v = self . client . _reqs . pop ( k ) <EOL> v . errback ( tex ) <EOL> del self . client . _reqs <EOL> del self . client <EOL> class CassandraPoolReconnectorFactory ( protocol . ClientFactory ) : <EOL> connector = None <EOL> last_error = None <EOL> noisy = False <EOL> keyspace = None <EOL> def __init__ ( self , node , service , sasl_cred_factory = None , describe_lock = None ) : <EOL> if not describe_lock : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> self . describe_lock = describe_lock <EOL> self . node = node <EOL> self . service = service <EOL> self . my_proto = None <EOL> self . job_d = self . jobphase = None <EOL> if not sasl_cred_factory : <EOL> self . protocol = partial ( CassandraPoolParticipantClient ) <EOL> else : <EOL> self . protocol = partial ( CassandraPoolParticipantSASLClient , sasl_cred_factory ) <EOL> def clientConnectionMade ( self , proto ) : <EOL> assert self . my_proto is None <EOL> assert self . jobphase is None , '<STR_LIT>' % ( self . jobphase , ) <EOL> if self . service is None : <EOL> proto . transport . loseConnection ( ) <EOL> else : <EOL> self . my_proto = proto <EOL> self . service . client_conn_made ( self ) <EOL> def clientConnectionFailed ( self , connector , reason ) : <EOL> assert self . my_proto is None <EOL> assert self . jobphase is None , '<STR_LIT>' % ( self . jobphase , ) <EOL> self . my_proto = None <EOL> if self . service is not None : <EOL> self . connector = connector <EOL> self . service . client_conn_failed ( reason , self ) <EOL> def clientConnectionLost ( self , connector , reason ) : <EOL> self . logstate ( '<STR_LIT>' ) <EOL> p = self . my_proto <EOL> self . my_proto = None <EOL> self . stop_working_on_queue ( ) <EOL> if p is not None and self . service is not None : <EOL> self . connector = connector <EOL> self . service . client_conn_lost ( self , reason ) <EOL> def stopFactory ( self ) : <EOL> self . logstate ( '<STR_LIT>' ) <EOL> protocol . ClientFactory . stopFactory ( self ) <EOL> if self . connector : <EOL> try : <EOL> self . connector . stopConnecting ( ) <EOL> except error . NotConnectingError : <EOL> pass <EOL> self . connector = None <EOL> p = self . my_proto <EOL> self . my_proto = None <EOL> self . stop_working_on_queue ( ) <EOL> if p is not None and p . transport is not None : <EOL> p . transport . loseConnection ( ) <EOL> def isConnecting ( self ) : <EOL> if self . connector is None : <EOL> if self . my_proto is None : <EOL> return True <EOL> else : <EOL> return False <EOL> return self . connector . state == '<STR_LIT>' <EOL> def retry ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . connector is None : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> if self . service is None : <EOL> return <EOL> self . connector . connect ( ) <EOL> def prep_connection ( self , creds = None , keyspace = None , node_auto_discovery = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> d = defer . succeed ( None ) <EOL> if creds is not None : <EOL> d . addCallback ( lambda _ : self . my_login ( creds ) ) <EOL> if keyspace is not None : <EOL> d . addCallback ( lambda _ : self . my_set_keyspace ( keyspace ) ) <EOL> if node_auto_discovery : <EOL> d . addCallback ( lambda _ : self . my_describe_ring ( keyspace ) ) <EOL> return d <EOL> def my_login ( self , creds ) : <EOL> req = ttypes . AuthenticationRequest ( credentials = creds ) <EOL> return self . execute ( ManagedThriftRequest ( '<STR_LIT>' , req ) ) <EOL> def my_set_keyspace ( self , keyspace ) : <EOL> return self . execute ( ManagedThriftRequest ( '<STR_LIT>' , keyspace ) ) <EOL> def done_describing ( self , result ) : <EOL> self . describe_lock . release_lock ( ) <EOL> return result <EOL> def done_describing_err ( self , f ) : <EOL> self . describe_lock . release_lock ( ) <EOL> return f <EOL> def my_describe_ring ( self , keyspace = None ) : <EOL> if keyspace is None or keyspace in SYSTEM_KEYSPACES : <EOL> d = self . my_pick_non_system_keyspace ( ) <EOL> else : <EOL> d = defer . succeed ( keyspace ) <EOL> if not self . describe_lock . get_lock ( ) : <EOL> self . describe_lock . set_lock ( d ) <EOL> d . addCallback ( lambda k : self . execute ( ManagedThriftRequest ( '<STR_LIT>' , k ) ) ) <EOL> def suppress_no_keyspaces_error ( f ) : <EOL> f . trap ( NoKeyspacesAvailable ) <EOL> return ( ) <EOL> d . addCallback ( self . done_describing ) <EOL> d . addErrback ( self . done_describing_err ) <EOL> d . addErrback ( suppress_no_keyspaces_error ) <EOL> else : <EOL> d = self . describe_lock . get_lock ( ) <EOL> return d <EOL> def my_describe_version ( self ) : <EOL> return self . execute ( ManagedThriftRequest ( '<STR_LIT>' ) ) <EOL> def my_describe_keyspaces ( self ) : <EOL> return self . execute ( ManagedThriftRequest ( '<STR_LIT>' ) ) <EOL> def my_pick_non_system_keyspace ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> d = self . my_describe_keyspaces ( ) <EOL> def pick_non_system ( klist ) : <EOL> for k in klist : <EOL> if k . name not in SYSTEM_KEYSPACES : <EOL> return k . name <EOL> err = NoKeyspacesAvailable ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> warn ( err ) <EOL> raise err <EOL> d . addCallback ( pick_non_system ) <EOL> return d <EOL> def store_successful_keyspace_set ( self , val , ksname ) : <EOL> self . keyspace = ksname <EOL> return val <EOL> def execute ( self , req , keyspace = None ) : <EOL> if self . my_proto is None : <EOL> return defer . fail ( error . ConnectionClosed ( <EOL> '<STR_LIT>' <EOL> % ( req . method , ) ) ) <EOL> method = getattr ( self . my_proto . client , req . method , None ) <EOL> if method is None : <EOL> raise InvalidThriftRequest ( \"<STR_LIT>\" % req . method ) <EOL> d = defer . succeed ( <NUM_LIT:0> ) <EOL> if req . method == '<STR_LIT>' : <EOL> newksname = req . args [ <NUM_LIT:0> ] <EOL> d . addCallback ( lambda _ : method ( newksname ) ) <EOL> d . addCallback ( self . store_successful_keyspace_set , newksname ) <EOL> else : <EOL> if keyspace is not None and keyspace != self . keyspace : <EOL> d . addCallback ( lambda _ : self . my_set_keyspace ( keyspace ) ) <EOL> d . addCallback ( lambda _ : method ( * ( req . args ) ) ) <EOL> return d <EOL> def clear_job ( self , x ) : <EOL> self . logstate ( '<STR_LIT>' % ( self . jobphase , x ) ) <EOL> self . jobphase = None <EOL> self . job_d = None <EOL> return x <EOL> def job ( self , _name , _func , * args , ** kw ) : <EOL> self . logstate ( '<STR_LIT>' % _name ) <EOL> if self . jobphase is not None : <EOL> raise ClientBusy ( '<STR_LIT>' <EOL> % ( _name , self . jobphase ) ) <EOL> self . jobphase = _name <EOL> d = defer . maybeDeferred ( _func , * args , ** kw ) <EOL> self . job_d = d <EOL> d . addBoth ( self . clear_job ) <EOL> return d <EOL> def process_request_error ( self , err , req , keyspace , req_d , retries ) : <EOL> self . logstate ( '<STR_LIT>' % ( err , retries ) ) <EOL> self . last_error = err <EOL> if retries > <NUM_LIT:0> and self . service is not None and err . check ( * self . service . retryables ) : <EOL> self . logstate ( '<STR_LIT>' ) <EOL> assert self . jobphase is None , '<STR_LIT>' <EOL> self . service . resubmit ( req , keyspace , req_d , retries - <NUM_LIT:1> ) <EOL> else : <EOL> self . logstate ( '<STR_LIT>' <EOL> % ( retries , self . service , err . value ) ) <EOL> req_d . errback ( err ) <EOL> def work_on_request ( self , reqtuple ) : <EOL> req , keyspace , req_d , retries = reqtuple <EOL> if req_d . called : <EOL> return <EOL> d = self . job ( '<STR_LIT>' , self . execute , req , keyspace ) <EOL> d . addCallback ( req_d . callback ) <EOL> d . addErrback ( self . process_request_error , req , keyspace , req_d , retries ) <EOL> return d <EOL> def maybe_do_more_work ( self , _ , q ) : <EOL> def _real_maybe_do_more_work ( ) : <EOL> if not self . keep_working : <EOL> self . stopFactory ( ) <EOL> elif self . service is not None : <EOL> self . work_on_queue ( q ) <EOL> if self . service is not None : <EOL> self . service . reactor . callLater ( <NUM_LIT:0> , _real_maybe_do_more_work ) <EOL> def scream_like_a_little_girl ( self , fail ) : <EOL> if self . service is not None : <EOL> complain = self . service . err <EOL> else : <EOL> complain = log . err <EOL> complain ( fail , \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % ( self . node , ) ) <EOL> def work_on_queue ( self , q ) : <EOL> self . logstate ( '<STR_LIT>' ) <EOL> self . keep_working = True <EOL> d = self . job ( '<STR_LIT>' , q . get ) <EOL> d . addCallback ( self . work_on_request ) <EOL> d . addCallback ( self . maybe_do_more_work , q ) <EOL> d . addErrback ( lambda f : f . trap ( defer . CancelledError ) ) <EOL> d . addErrback ( self . scream_like_a_little_girl ) <EOL> return d <EOL> def stop_working_on_queue ( self ) : <EOL> self . logstate ( '<STR_LIT>' % self . jobphase ) <EOL> self . keep_working = False <EOL> if self . jobphase == '<STR_LIT>' : <EOL> self . job_d . cancel ( ) <EOL> def finish_and_die ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . logstate ( '<STR_LIT>' ) <EOL> self . stop_working_on_queue ( ) <EOL> if self . jobphase != '<STR_LIT>' : <EOL> self . stopFactory ( ) <EOL> def logstate ( self , msg ) : <EOL> if getattr ( self , '<STR_LIT>' , False ) : <EOL> log . msg ( '<STR_LIT>' <EOL> % ( id ( self ) , self . node , self . jobphase , msg ) ) <EOL> class CassandraKeyspaceConnection : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , pool , keyspace ) : <EOL> self . pool = pool <EOL> self . keyspace = keyspace <EOL> def pushRequest ( self , req , retries = None ) : <EOL> return self . pool . pushRequest ( req , retries = retries , keyspace = self . keyspace ) <EOL> def set_keyspace ( self , keyspace ) : <EOL> raise RuntimeError ( \"<STR_LIT>\" ) <EOL> def login ( self , credentials ) : <EOL> return self . pool . login ( credentials ) <EOL> class CassandraNode : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> history_interval = <NUM_LIT> <EOL> max_delay = <NUM_LIT> <EOL> initial_delay = <NUM_LIT> <EOL> factor = protocol . ReconnectingClientFactory . factor <EOL> jitter = protocol . ReconnectingClientFactory . jitter <EOL> def __init__ ( self , host , port ) : <EOL> self . host = host <EOL> self . port = port <EOL> self . reconnect_delay = self . initial_delay <EOL> self . can_reconnect_at = <NUM_LIT:0> <EOL> self . history = [ ] <EOL> def record_hist ( self , value ) : <EOL> now = time ( ) <EOL> if self . history and self . history [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] < ( now - self . history_interval * <NUM_LIT:2> ) : <EOL> cutoff = now - self . history_interval <EOL> for n , ( tstamp , hval ) in enumerate ( self . history ) : <EOL> if tstamp > cutoff : <EOL> break <EOL> self . history = self . history [ n : ] <EOL> self . history . append ( ( now , value ) ) <EOL> def conn_success ( self ) : <EOL> self . reconnect_delay = self . initial_delay <EOL> self . can_reconnect_at = <NUM_LIT:0> <EOL> self . record_hist ( None ) <EOL> def conn_fail ( self , reason ) : <EOL> is_notable = self . is_failure_notable ( reason ) <EOL> self . record_hist ( reason . value ) <EOL> if is_notable : <EOL> newdelay = min ( self . reconnect_delay * self . factor , self . max_delay ) <EOL> if self . jitter : <EOL> newdelay = random . normalvariate ( newdelay , newdelay * self . jitter ) <EOL> self . reconnect_delay = newdelay <EOL> self . can_reconnect_at = time ( ) + newdelay <EOL> else : <EOL> self . can_reconnect_at = time ( ) + self . reconnect_delay <EOL> return is_notable <EOL> def is_failure_notable ( self , reason ) : <EOL> try : <EOL> tstamp , last_err = self . history [ - <NUM_LIT:1> ] <EOL> except IndexError : <EOL> pass <EOL> else : <EOL> if type ( last_err ) is type ( reason . value ) : <EOL> if time ( ) < self . can_reconnect_at : <EOL> return False <EOL> return True <EOL> def seconds_until_connect_ok ( self ) : <EOL> return self . can_reconnect_at - time ( ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ , <EOL> self . host , self . port , id ( self ) ) <EOL> __repr__ = __str__ <EOL> def __eq__ ( self , other ) : <EOL> return self . __class__ == other . __class__ and self . host == other . host and self . port == other . port <EOL> def __cmp__ ( self , other ) : <EOL> return cmp ( ( self . host , self . port ) , ( other . host , other . port ) ) <EOL> def __hash__ ( self ) : <EOL> return hash ( ( self . __class__ , self . host , self . port ) ) <EOL> def get_endpoints_from_tokenrange ( tokenrange ) : <EOL> if hasattr ( tokenrange , \"<STR_LIT>\" ) and tokenrange . rpc_endpoints : <EOL> def good_addr ( ep , rpc ) : <EOL> return rpc if not rpc . startswith ( \"<STR_LIT>\" ) else ep <EOL> return map ( good_addr , tokenrange . endpoints , tokenrange . rpc_endpoints ) <EOL> else : <EOL> return tokenrange . endpoints <EOL> class CassandraClusterPool ( service . Service , object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> default_cassandra_thrift_port = <NUM_LIT> <EOL> max_connections_per_node = <NUM_LIT> <EOL> on_insufficient_nodes = staticmethod ( lame_log_insufficient_nodes ) <EOL> on_insufficient_conns = staticmethod ( noop ) <EOL> request_retries = <NUM_LIT:4> <EOL> conn_factory = CassandraPoolReconnectorFactory <EOL> retryables = [ IOError , socket . error , Thrift . TException , <EOL> TTransport . TTransportException ] <EOL> def __init__ ( self , seed_list , keyspace = None , creds = None , thrift_port = None , <EOL> pool_size = None , conn_timeout = <NUM_LIT:10> , bind_address = None , <EOL> log_cb = log . msg , reactor = None , ssl_ctx_factory = None , <EOL> sasl_cred_factory = None , auto_node_discovery = True , fill_pool_throttle = <NUM_LIT:0.5> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . describing_ring = False <EOL> self . seed_list = list ( seed_list ) <EOL> if thrift_port is None : <EOL> thrift_port = self . default_cassandra_thrift_port <EOL> self . thrift_port = thrift_port <EOL> if pool_size is None : <EOL> pool_size = len ( self . seed_list ) <EOL> self . target_pool_size = pool_size <EOL> self . log = log_cb <EOL> self . conn_timeout = conn_timeout <EOL> self . bind_address = bind_address <EOL> self . keyspace = keyspace <EOL> self . creds = creds <EOL> self . ssl_ctx_factory = ssl_ctx_factory <EOL> self . sasl_cred_factory = sasl_cred_factory <EOL> self . request_queue = defer . DeferredQueue ( ) <EOL> self . future_fill_pool = None <EOL> self . removed_nodes = set ( ) <EOL> self . _client_instance = CassandraClient ( self ) <EOL> self . auto_node_discovery = auto_node_discovery <EOL> self . fill_pool_throttle = fill_pool_throttle <EOL> self . throttle_timer = None <EOL> self . fill_pool_last_called = None <EOL> if reactor is None : <EOL> from twisted . internet import reactor <EOL> self . reactor = reactor <EOL> self . retryables . extend ( ( ttypes . TimedOutException , <EOL> ttypes . UnavailableException ) ) <EOL> self . nodes = set ( ) <EOL> self . connectors = set ( ) <EOL> self . good_conns = set ( ) <EOL> self . dying_conns = set ( ) <EOL> def startService ( self ) : <EOL> service . Service . startService ( self ) <EOL> for addr in self . seed_list : <EOL> if isinstance ( addr , tuple ) and len ( addr ) == <NUM_LIT:2> : <EOL> self . addNode ( addr ) <EOL> else : <EOL> self . addNode ( ( addr , self . thrift_port ) ) <EOL> self . fill_pool ( ) <EOL> def stopService ( self ) : <EOL> service . Service . stopService ( self ) <EOL> if self . future_fill_pool is not None and self . future_fill_pool . active ( ) : <EOL> self . future_fill_pool . cancel ( ) <EOL> for factory in self . connectors . copy ( ) : <EOL> factory . service = None <EOL> factory . stopFactory ( ) <EOL> self . connectors = set ( ) <EOL> self . good_conns = set ( ) <EOL> self . dying_conns = set ( ) <EOL> def addNode ( self , node ) : <EOL> if not isinstance ( node , CassandraNode ) : <EOL> node = CassandraNode ( * node ) <EOL> if node in self . nodes : <EOL> raise ValueError ( \"<STR_LIT>\" % ( node , ) ) <EOL> if node in self . removed_nodes : <EOL> self . removed_nodes . remove ( node ) <EOL> self . nodes . add ( node ) <EOL> def removeNode ( self , node ) : <EOL> if not isinstance ( node , CassandraNode ) : <EOL> node = CassandraNode ( * node ) <EOL> for f in self . all_connectors_to ( node ) : <EOL> f . stopFactory ( ) <EOL> self . remove_connector ( f ) <EOL> for f in self . dying_conns . copy ( ) : <EOL> if f . node == node : <EOL> f . stopFactory ( ) <EOL> self . remove_connector ( f ) <EOL> self . removed_nodes . add ( node ) <EOL> self . nodes . remove ( node ) <EOL> self . fill_pool ( ) <EOL> def err ( self , _stuff = None , _why = None , ** kw ) : <EOL> if _stuff is None : <EOL> _stuff = failure . Failure ( ) <EOL> kw [ '<STR_LIT>' ] = True <EOL> kw [ '<STR_LIT>' ] = _why <EOL> if isinstance ( _stuff , failure . Failure ) : <EOL> self . log ( failure = _stuff , ** kw ) <EOL> elif isinstance ( _stuff , Exception ) : <EOL> self . log ( failure = failure . Failure ( _stuff ) , ** kw ) <EOL> else : <EOL> self . log ( repr ( _stuff ) , ** kw ) <EOL> def all_connectors ( self ) : <EOL> return self . connectors . copy ( ) <EOL> def num_connectors ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return len ( self . connectors ) <EOL> def all_connectors_to ( self , node ) : <EOL> return [ f for f in self . connectors if f . node == node ] <EOL> def num_connectors_to ( self , host ) : <EOL> return len ( self . all_connectors_to ( host ) ) <EOL> def all_active_conns ( self ) : <EOL> return self . good_conns . copy ( ) <EOL> def num_active_conns ( self ) : <EOL> return len ( self . good_conns ) <EOL> def all_active_conns_to ( self , node ) : <EOL> return [ f for f in self . good_conns if f . node == node ] <EOL> def num_active_conns_to ( self , node ) : <EOL> return len ( self . all_active_conns_to ( node ) ) <EOL> def all_working_conns ( self ) : <EOL> return [ f for f in self . good_conns if f . jobphase == '<STR_LIT>' ] <EOL> def num_working_conns ( self ) : <EOL> return len ( self . all_working_conns ( ) ) <EOL> def all_pending_conns ( self ) : <EOL> return self . connectors - self . good_conns <EOL> def num_pending_conns ( self ) : <EOL> return len ( self . all_pending_conns ( ) ) <EOL> def all_pending_conns_to ( self , node ) : <EOL> return [ f for f in self . all_pending_conns ( ) if f . node == node ] <EOL> def num_pending_conns_to ( self , node ) : <EOL> return len ( self . all_pending_conns_to ( node ) ) <EOL> def add_connection_score ( self , node ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> conntime = node . seconds_until_connect_ok ( ) <EOL> if conntime > <NUM_LIT:0> : <EOL> self . log ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % ( node , conntime ) ) <EOL> return - conntime <EOL> numconns = self . num_connectors_to ( node ) <EOL> if numconns >= self . max_connections_per_node : <EOL> return float ( '<STR_LIT>' ) <EOL> return sys . maxint - numconns <EOL> def adjustPoolSize ( self , newsize ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if newsize < <NUM_LIT:0> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> self . log ( \"<STR_LIT>\" % ( self . target_pool_size , newsize ) ) <EOL> self . target_pool_size = newsize <EOL> self . kill_excess_pending_conns ( ) <EOL> self . kill_excess_conns ( ) <EOL> self . fill_pool ( ) <EOL> def update_known_nodes ( self , ring ) : <EOL> for tokenrange in ring : <EOL> endpoints = get_endpoints_from_tokenrange ( tokenrange ) <EOL> for addr in endpoints : <EOL> if '<STR_LIT::>' in addr : <EOL> addr , port = addr . split ( '<STR_LIT::>' , <NUM_LIT:1> ) <EOL> port = int ( port ) <EOL> else : <EOL> port = self . thrift_port <EOL> node = CassandraNode ( addr , port ) <EOL> if node not in self . removed_nodes and node not in self . nodes : <EOL> self . addNode ( node ) <EOL> def choose_nodes_to_connect ( self ) : <EOL> while True : <EOL> nodes = list ( self . nodes ) <EOL> scores = map ( self . add_connection_score , nodes ) <EOL> bestscore , bestnode = max ( zip ( scores , nodes ) ) <EOL> if bestscore < <NUM_LIT:0> : <EOL> raise NoNodesAvailable ( - bestscore ) <EOL> yield bestnode <EOL> def choose_pending_conns_to_kill ( self ) : <EOL> while True : <EOL> pending_conns = self . all_pending_conns ( ) <EOL> if len ( pending_conns ) == <NUM_LIT:0> : <EOL> break <EOL> yield max ( pending_conns , key = lambda f : self . num_connectors_to ( f . node ) ) <EOL> def choose_conns_to_kill ( self ) : <EOL> nodegetter = lambda f : f . node <EOL> while True : <EOL> active_conns = self . all_active_conns ( ) <EOL> if len ( active_conns ) == <NUM_LIT:0> : <EOL> break <EOL> nodes_and_conns = groupby ( sorted ( active_conns , key = nodegetter ) , nodegetter ) <EOL> nodes_and_counts = ( ( n , len ( list ( conns ) ) ) for ( n , conns ) in nodes_and_conns ) <EOL> bestnode , bestcount = max ( nodes_and_counts , key = lambda ( n , count ) : count ) <EOL> yield self . all_active_conns_to ( bestnode ) [ <NUM_LIT:0> ] <EOL> def kill_excess_pending_conns ( self ) : <EOL> killnum = self . num_connectors ( ) - self . target_pool_size <EOL> if killnum <= <NUM_LIT:0> : <EOL> return <EOL> for n , f in izip ( xrange ( killnum ) , self . choose_pending_conns_to_kill ( ) ) : <EOL>", "answer": "self . log ( \"<STR_LIT>\" % ( f . node , ) )"}, {"prompt": "<s> from __future__ import absolute_import , division , print_function <EOL> import pytest <EOL> sas7bdat = pytest . importorskip ( '<STR_LIT>' ) <EOL> pytest . importorskip ( '<STR_LIT>' ) <EOL> import os <EOL> import pandas as pd <EOL> from collections import Iterator <EOL> from sas7bdat import SAS7BDAT <EOL> from odo . backends . sas import discover , sas_to_iterator <EOL> from odo . utils import tmpfile , into_path <EOL> from odo import append , convert , resource , dshape <EOL> test_path = into_path ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> sasfile = SAS7BDAT ( test_path ) <EOL> columns = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:t>\" , \"<STR_LIT>\" ) <EOL> ds = dshape ( '''<STR_LIT>''' ) <EOL> def test_resource_sas7bdat ( ) : <EOL> assert isinstance ( resource ( test_path ) , SAS7BDAT ) <EOL> def test_discover_sas ( ) : <EOL> assert discover ( sasfile ) == ds <EOL> def test_convert_sas_to_dataframe ( ) : <EOL> df = convert ( pd . DataFrame , sasfile ) <EOL> assert isinstance ( df , pd . DataFrame ) <EOL> expected = str ( ds . measure ) . replace ( '<STR_LIT:date>' , '<STR_LIT>' ) <EOL> assert str ( discover ( df ) . measure ) . replace ( '<STR_LIT:?>' , '<STR_LIT>' ) == expected <EOL> def test_convert_sas_to_list ( ) : <EOL> out = convert ( list , sasfile ) <EOL> assert isinstance ( out , list ) <EOL>", "answer": "assert not any ( isinstance ( item , str ) for item in out [ <NUM_LIT:0> ] )"}, {"prompt": "<s> from humanize import naturaltime <EOL> from paasta_tools . cli . cmds . mark_for_deployment import mark_for_deployment <EOL> from paasta_tools . cli . utils import extract_tags <EOL> from paasta_tools . cli . utils import figure_out_service_name <EOL> from paasta_tools . cli . utils import lazy_choices_completer <EOL> from paasta_tools . cli . utils import list_services <EOL> from paasta_tools . generate_deployments_for_service import get_instance_config_for_service <EOL> from paasta_tools . remote_git import list_remote_refs <EOL> from paasta_tools . utils import datetime_from_utc_to_local <EOL> from paasta_tools . utils import DEFAULT_SOA_DIR <EOL> from paasta_tools . utils import format_table <EOL> from paasta_tools . utils import get_git_url <EOL> from paasta_tools . utils import PaastaColors <EOL> from paasta_tools . utils import parse_timestamp <EOL> def add_subparser ( subparsers ) : <EOL> list_parser = subparsers . add_parser ( <EOL> '<STR_LIT>' , <EOL> help = '<STR_LIT>' , <EOL> description = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) , <EOL> epilog = ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) , <EOL> ) <EOL> list_parser . add_argument ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> help = \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> required = False , <EOL> ) . completer = lazy_choices_completer ( list_previously_deployed_shas ) <EOL> list_parser . add_argument ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> help = '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> default = '<STR_LIT>' , <EOL> required = False , <EOL> ) <EOL> list_parser . add_argument ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> help = '<STR_LIT>' , <EOL> ) . completer = lazy_choices_completer ( list_services ) <EOL> list_parser . add_argument ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> dest = \"<STR_LIT>\" , <EOL> metavar = \"<STR_LIT>\" , <EOL> default = DEFAULT_SOA_DIR , <EOL> help = \"<STR_LIT>\" , <EOL> ) <EOL> list_parser . set_defaults ( command = paasta_rollback ) <EOL> def list_previously_deployed_shas ( parsed_args , ** kwargs ) : <EOL> service = parsed_args . service <EOL> soa_dir = parsed_args . soa_dir <EOL> deploy_groups = { deploy_group for deploy_group in parsed_args . deploy_groups . split ( '<STR_LIT:U+002C>' ) if deploy_group } <EOL> return ( sha for sha , _ in get_git_shas_for_service ( service , deploy_groups , soa_dir ) ) <EOL> def get_git_shas_for_service ( service , deploy_groups , soa_dir ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if service is None : <EOL> return [ ] <EOL> git_url = get_git_url ( service = service , soa_dir = soa_dir ) <EOL> all_deploy_groups = { config . get_deploy_group ( ) for config in get_instance_config_for_service ( <EOL> service = service , <EOL> soa_dir = soa_dir , <EOL> ) } <EOL> deploy_groups , _ = validate_given_deploy_groups ( all_deploy_groups , deploy_groups ) <EOL> previously_deployed_shas = { } <EOL> for ref , sha in list_remote_refs ( git_url ) . items ( ) : <EOL> regex_match = extract_tags ( ref ) <EOL> try : <EOL> deploy_group = regex_match [ '<STR_LIT>' ] <EOL> tstamp = regex_match [ '<STR_LIT>' ] <EOL> except KeyError : <EOL> pass <EOL> else : <EOL> if deploy_group in deploy_groups and tstamp > previously_deployed_shas . get ( sha , '<STR_LIT>' ) : <EOL> previously_deployed_shas [ sha ] = tstamp <EOL> return previously_deployed_shas . items ( ) <EOL> def validate_given_deploy_groups ( service_deploy_groups , args_deploy_groups ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( args_deploy_groups ) is <NUM_LIT:0> : <EOL> valid_deploy_groups = set ( service_deploy_groups ) <EOL> invalid_deploy_groups = set ( [ ] ) <EOL> else : <EOL> valid_deploy_groups = set ( args_deploy_groups ) . intersection ( service_deploy_groups ) <EOL> invalid_deploy_groups = set ( args_deploy_groups ) . difference ( service_deploy_groups ) <EOL> return valid_deploy_groups , invalid_deploy_groups <EOL> def list_previous_commits ( service , deploy_groups , any_given_deploy_groups , soa_dir ) : <EOL> def format_timestamp ( tstamp ) : <EOL>", "answer": "return naturaltime ( datetime_from_utc_to_local ( parse_timestamp ( tstamp ) ) )"}, {"prompt": "<s> import logging <EOL> import os <EOL> import commons <EOL> logging . getLogger ( \"<STR_LIT>\" ) . setLevel ( logging . DEBUG ) <EOL> def append_static_file ( text , file_path , file_type , add_newline = False ) : <EOL> assert file_type in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> if file_type == \"<STR_LIT>\" : <EOL> ref = '<STR_LIT>' % file_path <EOL> else : <EOL> ref = '<STR_LIT>' % file_path <EOL> if not add_newline : <EOL> static_files = \"<STR_LIT>\" % ( text , ref ) <EOL> else : <EOL> static_files = \"<STR_LIT>\" % ( text , ref ) <EOL> return static_files <EOL> def get_global_static_files ( ** view_settings ) : <EOL> static_files = \"<STR_LIT>\" <EOL> css_files = ( \"<STR_LIT>\" , ) <EOL> for i in css_files : <EOL> path = os . path . join ( \"<STR_LIT>\" , view_settings [ \"<STR_LIT>\" ] , \"<STR_LIT>\" , i ) <EOL> static_files = append_static_file ( static_files , path , file_type = \"<STR_LIT>\" ) <EOL> if view_settings [ \"<STR_LIT>\" ] : <EOL> path = os . path . join ( \"<STR_LIT>\" , view_settings [ \"<STR_LIT>\" ] , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> static_files = append_static_file ( static_files , path , file_type = \"<STR_LIT>\" ) <EOL> if view_settings [ \"<STR_LIT>\" ] : <EOL> path = os . path . join ( \"<STR_LIT>\" , view_settings [ \"<STR_LIT>\" ] , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> static_files = append_static_file ( static_files , path , file_type = \"<STR_LIT>\" ) <EOL> if view_settings [ \"<STR_LIT>\" ] : <EOL>", "answer": "path = os . path . join ( \"<STR_LIT>\" , view_settings [ \"<STR_LIT>\" ] , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "<s> from collections import namedtuple <EOL>", "answer": "from logging import getLogger"}, {"prompt": "<s> import datetime <EOL> from catwatch . lib . util_datetime import timedelta_months <EOL> from catwatch . lib . util_sqlalchemy import ResourceMixin <EOL> from catwatch . extensions import db <EOL>", "answer": "class CreditCard ( ResourceMixin , db . Model ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from nsot . conf . settings import * <EOL> import os . path <EOL>", "answer": "CONF_ROOT = os . path . dirname ( __file__ )"}, {"prompt": "<s> from __future__ import division , absolute_import , print_function , unicode_literals <EOL> import os <EOL> from django . db import models <EOL> from save_the_change . mixins import SaveTheChange , TrackChanges <EOL> class Enlightenment ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> aspect = models . CharField ( max_length = <NUM_LIT:32> ) <EOL> def __unicode__ ( self ) : <EOL> return self . aspect <EOL> class EnlightenedModel ( SaveTheChange , TrackChanges , models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> big_integer = models . BigIntegerField ( ) <EOL> boolean = models . BooleanField ( ) <EOL> char = models . CharField ( max_length = <NUM_LIT:32> ) <EOL> comma_seperated_integer = models . CommaSeparatedIntegerField ( max_length = <NUM_LIT:32> ) <EOL> date = models . DateField ( ) <EOL>", "answer": "date_time = models . DateTimeField ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> if sys . platform == '<STR_LIT:win32>' : <EOL> print \"<STR_LIT>\" <EOL> sys . exit ( <NUM_LIT:0> ) <EOL> import TestGyp <EOL> test = TestGyp . TestGyp ( formats = [ '<STR_LIT>' ] ) <EOL>", "answer": "test . relocate ( '<STR_LIT:src>' , '<STR_LIT>' )"}, {"prompt": "<s> from pyjamas . ui . Tree import Tree <EOL> from pyjamas . ui . TreeItem import TreeItem <EOL> from pyjamas . ui . Composite import Composite <EOL> from pyjamas . ui . RootPanel import RootPanel <EOL> from pyjamas . ui . HTML import HTML <EOL> from pyjamas import Window <EOL> from pyjamas . JSONService import JSONProxy <EOL> class Trees ( Composite ) : <EOL> def __init__ ( self ) : <EOL> Composite . __init__ ( self ) <EOL>", "answer": "self . fProto = [ ]"}, {"prompt": "<s> from south . utils import datetime_utils as datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> depends_on = ( <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ) <EOL> def forwards ( self , orm ) : <EOL> try : <EOL> if not db . dry_run : <EOL> afp = orm [ '<STR_LIT>' ] . objects . order_by ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> for o in orm [ '<STR_LIT>' ] . objects . all ( ) : <EOL> afp . afp_srv_dbpath = o . afp_dbpath <EOL> afp . save ( ) <EOL> break <EOL> except : <EOL> pass <EOL>", "answer": "db . delete_column ( u'<STR_LIT>' , '<STR_LIT>' )"}, {"prompt": "<s> from cms . publisher . manager import PublisherManager <EOL> from django . db . models . base import ModelBase <EOL> class PageMetaClass ( ModelBase ) : <EOL> def __new__ ( cls , name , bases , attrs ) : <EOL> super_new = super ( PageMetaClass , cls ) . __new__ <EOL> if '<STR_LIT>' in attrs : <EOL> if not isinstance ( attrs [ '<STR_LIT>' ] , PublisherManager ) : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) % ( name , ) <EOL> else : <EOL>", "answer": "attrs [ '<STR_LIT>' ] = PublisherManager ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> import codecs <EOL> from mako import parsetree , exceptions , compat <EOL> from mako . pygen import adjust_whitespace <EOL> _regexp_cache = { } <EOL> class Lexer ( object ) : <EOL> def __init__ ( self , text , filename = None , <EOL> disable_unicode = False , <EOL> input_encoding = None , preprocessor = None ) : <EOL> self . text = text <EOL> self . filename = filename <EOL> self . template = parsetree . TemplateNode ( self . filename ) <EOL> self . matched_lineno = <NUM_LIT:1> <EOL> self . matched_charpos = <NUM_LIT:0> <EOL> self . lineno = <NUM_LIT:1> <EOL> self . match_position = <NUM_LIT:0> <EOL> self . tag = [ ] <EOL> self . control_line = [ ] <EOL> self . ternary_stack = [ ] <EOL> self . disable_unicode = disable_unicode <EOL> self . encoding = input_encoding <EOL> if compat . py3k and disable_unicode : <EOL> raise exceptions . UnsupportedError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> if preprocessor is None : <EOL> self . preprocessor = [ ] <EOL> elif not hasattr ( preprocessor , '<STR_LIT>' ) : <EOL> self . preprocessor = [ preprocessor ] <EOL> else : <EOL> self . preprocessor = preprocessor <EOL> @ property <EOL> def exception_kwargs ( self ) : <EOL> return { '<STR_LIT:source>' : self . text , <EOL> '<STR_LIT>' : self . matched_lineno , <EOL> '<STR_LIT>' : self . matched_charpos , <EOL> '<STR_LIT:filename>' : self . filename } <EOL> def match ( self , regexp , flags = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> reg = _regexp_cache [ ( regexp , flags ) ] <EOL>", "answer": "except KeyError :"}, {"prompt": "<s> import time <EOL> from functools import wraps <EOL> from datetime import datetime , timedelta <EOL> from pulsar import ImproperlyConfigured , Http401 <EOL> from pulsar . utils . pep import to_string <EOL> from pulsar . apps . wsgi import Route , wsgi_request <EOL> from lux . core import app_attribute <EOL> try : <EOL> import jwt <EOL> except ImportError : <EOL> jwt = None <EOL> class TokenBackendMixin : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def session_expiry ( self , request ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> session_expiry = request . config [ '<STR_LIT>' ] <EOL> if session_expiry : <EOL> return datetime . now ( ) + timedelta ( seconds = session_expiry ) <EOL> def encode_token ( self , request , user = None , expiry = None , ** token ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not jwt : <EOL> raise ImproperlyConfigured ( '<STR_LIT>' ) <EOL> if expiry : <EOL> token [ '<STR_LIT>' ] = int ( time . mktime ( expiry . timetuple ( ) ) ) <EOL> request . app . fire ( '<STR_LIT>' , request , token , user ) <EOL> return to_string ( jwt . encode ( token , request . config [ '<STR_LIT>' ] ) ) <EOL> def decode_token ( self , request , token ) : <EOL> if not jwt : <EOL> raise ImproperlyConfigured ( '<STR_LIT>' ) <EOL> try : <EOL> return jwt . decode ( token , request . config [ '<STR_LIT>' ] ) <EOL> except jwt . ExpiredSignature : <EOL> request . app . logger . warning ( '<STR_LIT>' ) <EOL> raise Http401 ( '<STR_LIT>' ) <EOL> except jwt . DecodeError as exc : <EOL> request . app . logger . warning ( str ( exc ) ) <EOL> raise Http401 ( '<STR_LIT>' ) <EOL> def create_token ( self , request , user , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> @ app_attribute <EOL> def exclude_urls ( app ) : <EOL> urls = [ ] <EOL> for url in app . config [ '<STR_LIT>' ] : <EOL> urls . append ( Route ( url ) ) <EOL> return tuple ( urls ) <EOL> def skip_on_exclude ( method ) : <EOL> @ wraps ( method ) <EOL> def _ ( self , request , * args ) : <EOL> path = request . path [ <NUM_LIT:1> : ] <EOL> for url in exclude_urls ( request . app ) : <EOL> if url . match ( path ) : <EOL> return <EOL> return method ( self , request , * args ) <EOL> return _ <EOL> class SessionBackendMixin ( TokenBackendMixin ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def logout ( self , request ) : <EOL> request . cache . user = self . anonymous ( ) <EOL> request . cache . session = self . create_session ( request ) <EOL> @ skip_on_exclude <EOL> def login ( self , request , user ) : <EOL> session = self . create_session ( request , user ) <EOL> request . cache . session = session <EOL> token = session . encoded <EOL> request . response . status_code = <NUM_LIT> <EOL> return { '<STR_LIT:success>' : True , <EOL> '<STR_LIT>' : token } <EOL> def on_html_document ( self , app , request , doc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "if request . method == '<STR_LIT:GET>' :"}, {"prompt": "<s> from rx import Observable <EOL> from rx . internal import extensionmethod <EOL> from . firstordefault import first_or_default_async <EOL>", "answer": "@ extensionmethod ( Observable )"}, {"prompt": "<s> import sys , itertools <EOL> import _ast <EOL> def to_tuple ( t ) : <EOL> if t is None or isinstance ( t , ( basestring , int , long , complex ) ) : <EOL> return t <EOL> elif isinstance ( t , list ) : <EOL> return [ to_tuple ( e ) for e in t ] <EOL> result = [ t . __class__ . __name__ ] <EOL> if hasattr ( t , '<STR_LIT>' ) and hasattr ( t , '<STR_LIT>' ) : <EOL> result . append ( ( t . lineno , t . col_offset ) ) <EOL> if t . _fields is None : <EOL> return tuple ( result ) <EOL> for f in t . _fields : <EOL> result . append ( to_tuple ( getattr ( t , f ) ) ) <EOL> return tuple ( result ) <EOL> exec_tests = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT:1>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> single_tests = [ <EOL> \"<STR_LIT>\" <EOL> ] <EOL> eval_tests = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL>", "answer": "\"<STR_LIT>\" ,"}, {"prompt": "<s> from setuptools import setup , find_packages <EOL> from woven import get_version <EOL> setup ( name = '<STR_LIT>' , <EOL> version = get_version ( ) , <EOL> description = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> url = '<STR_LIT>' , <EOL> download_url = '<STR_LIT>' , <EOL> package_dir = { '<STR_LIT>' : '<STR_LIT>' } , <EOL> packages = find_packages ( ) , <EOL> scripts = [ '<STR_LIT>' ] , <EOL> include_package_data = True , <EOL> package_data = { '<STR_LIT>' : [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> from lixian_plugins . api import name_filter <EOL> @ name_filter ( protocol = '<STR_LIT:name>' ) <EOL>", "answer": "def filter_by_raw_text ( keyword , name ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import hashlib <EOL> import os <EOL> from grr . client import client_actions <EOL> from grr . lib import flags <EOL> from grr . lib import test_lib <EOL> from grr . lib . rdfvalues import client as rdf_client <EOL> from grr . lib . rdfvalues import paths as rdf_paths <EOL> class FilehashTest ( test_lib . EmptyActionTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testHashFile ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "path = os . path . join ( self . base_path , \"<STR_LIT>\" )"}, {"prompt": "<s> from jobman import DD , flatten <EOL> config = DD ( { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : DD ( { <EOL> '<STR_LIT>' : None <EOL> } ) , <EOL> '<STR_LIT>' : DD ( { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:description>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : \"<STR_LIT>\" <EOL> } ) , <EOL> '<STR_LIT>' : DD ( { <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:0.5> ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : ( ( <NUM_LIT> , <NUM_LIT> ) , float ) , <EOL> '<STR_LIT>' : ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) , <EOL> } ) , <EOL> '<STR_LIT>' : DD ( { <EOL> '<STR_LIT>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : DD ( { <EOL> '<STR_LIT>' : <NUM_LIT:100> , <EOL> '<STR_LIT>' : <NUM_LIT:5> , <EOL>", "answer": "'<STR_LIT>' : '<STR_LIT>' ,"}, {"prompt": "<s> import abc <EOL> import argparse <EOL> import os <EOL> import six <EOL> from stevedore import extension <EOL> from cinderclient . openstack . common . apiclient import exceptions <EOL> _discovered_plugins = { } <EOL> def discover_auth_systems ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> global _discovered_plugins <EOL> _discovered_plugins = { } <EOL> def add_plugin ( ext ) : <EOL> _discovered_plugins [ ext . name ] = ext . plugin <EOL> ep_namespace = \"<STR_LIT>\" <EOL> mgr = extension . ExtensionManager ( ep_namespace ) <EOL> mgr . map ( add_plugin ) <EOL> def load_auth_system_opts ( parser ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> group = parser . add_argument_group ( \"<STR_LIT>\" ) <EOL> BaseAuthPlugin . add_common_opts ( group ) <EOL> for name , auth_plugin in six . iteritems ( _discovered_plugins ) : <EOL> group = parser . add_argument_group ( <EOL> \"<STR_LIT>\" % name , <EOL> conflict_handler = \"<STR_LIT>\" ) <EOL> auth_plugin . add_opts ( group ) <EOL> def load_plugin ( auth_system ) : <EOL> try : <EOL> plugin_class = _discovered_plugins [ auth_system ] <EOL> except KeyError : <EOL> raise exceptions . AuthSystemNotFound ( auth_system ) <EOL> return plugin_class ( auth_system = auth_system ) <EOL> def load_plugin_from_args ( args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> auth_system = args . os_auth_system <EOL> if auth_system : <EOL> plugin = load_plugin ( auth_system ) <EOL> plugin . parse_opts ( args ) <EOL> plugin . sufficient_options ( ) <EOL> return plugin <EOL> for plugin_auth_system in sorted ( six . iterkeys ( _discovered_plugins ) ) : <EOL> plugin_class = _discovered_plugins [ plugin_auth_system ] <EOL> plugin = plugin_class ( ) <EOL> plugin . parse_opts ( args ) <EOL> try : <EOL> plugin . sufficient_options ( ) <EOL> except exceptions . AuthPluginOptionsMissing : <EOL> continue <EOL> return plugin <EOL> raise exceptions . AuthPluginOptionsMissing ( [ \"<STR_LIT>\" ] ) <EOL> @ six . add_metaclass ( abc . ABCMeta ) <EOL> class BaseAuthPlugin ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> auth_system = None <EOL> opt_names = [ ] <EOL> common_opt_names = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT:username>\" , <EOL> \"<STR_LIT:password>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> def __init__ ( self , auth_system = None , ** kwargs ) : <EOL> self . auth_system = auth_system or self . auth_system <EOL> self . opts = dict ( ( name , kwargs . get ( name ) ) <EOL> for name in self . opt_names ) <EOL> @ staticmethod <EOL> def _parser_add_opt ( parser , opt ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> dashed_opt = opt . replace ( \"<STR_LIT:_>\" , \"<STR_LIT:->\" ) <EOL> env_var = \"<STR_LIT>\" % opt . upper ( ) <EOL> arg_default = os . environ . get ( env_var , \"<STR_LIT>\" ) <EOL> arg_help = \"<STR_LIT>\" % env_var <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" % dashed_opt , <EOL> metavar = \"<STR_LIT>\" % dashed_opt , <EOL> default = arg_default , <EOL> help = arg_help ) <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" % opt , <EOL> metavar = \"<STR_LIT>\" % dashed_opt , <EOL> help = argparse . SUPPRESS ) <EOL> @ classmethod <EOL> def add_opts ( cls , parser ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for opt in cls . opt_names : <EOL> if opt not in BaseAuthPlugin . common_opt_names : <EOL> cls . _parser_add_opt ( parser , opt ) <EOL> @ classmethod <EOL> def add_common_opts ( cls , parser ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for opt in cls . common_opt_names : <EOL> cls . _parser_add_opt ( parser , opt ) <EOL> @ staticmethod <EOL> def get_opt ( opt_name , args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return ( opt_name , getattr ( args , \"<STR_LIT>\" % opt_name , None ) ) <EOL> def parse_opts ( self , args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . opts . update ( dict ( self . get_opt ( opt_name , args ) <EOL> for opt_name in self . opt_names ) ) <EOL> def authenticate ( self , http_client ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . sufficient_options ( ) <EOL> self . _do_authenticate ( http_client ) <EOL>", "answer": "@ abc . abstractmethod"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . conf import settings <EOL> from django . utils . safestring import mark_safe <EOL> from django . utils . translation import ugettext as _ <EOL> try : <EOL> from django . utils import six <EOL> except ImportError : <EOL> import six <EOL> class BreadcrumbsInvalidFormat ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL>", "answer": "class BreadcrumbsNotSet ( Exception ) :"}, {"prompt": "<s> import subprocess <EOL> from ajenti . api import * <EOL> from api import PackageInfo , PackageManager <EOL> @ plugin <EOL> @ rootcontext <EOL> @ persistent <EOL> class DebianPackageManager ( PackageManager ) : <EOL> platforms = [ '<STR_LIT>' ] <EOL> def refresh ( self ) : <EOL> out_u = subprocess . check_output ( [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> out_a = subprocess . check_output ( [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> self . all = self . _parse_dpkg ( out_a ) <EOL> self . all_dict = dict ( ( x . name , x ) for x in self . all ) <EOL> self . upgradeable = self . _parse_asv ( out_u ) <EOL> def search ( self , query ) : <EOL> out_s = subprocess . check_output ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , query ] ) <EOL> r = [ ] <EOL> found = { } <EOL> for l in out_s . split ( '<STR_LIT:\\n>' ) : <EOL> s = l . split ( ) <EOL> if len ( s ) < <NUM_LIT:4> : <EOL> continue <EOL> p = PackageInfo ( ) <EOL> p . name = s [ <NUM_LIT:0> ] <EOL> p . state = '<STR_LIT:i>' if p . name in self . all_dict else '<STR_LIT:r>' <EOL> p . version = s [ <NUM_LIT:1> ] <EOL> if not p . name in found or found [ p . name ] < p . version : <EOL> r . append ( p ) <EOL> found [ p . name ] = p . version <EOL> return r <EOL> def get_lists ( self ) : <EOL> self . context . launch ( '<STR_LIT>' , command = '<STR_LIT>' ) <EOL> def do ( self , actions , callback = lambda : <NUM_LIT:0> ) : <EOL> cmd = '<STR_LIT>' <EOL> for a in actions : <EOL> cmd += a . name + { '<STR_LIT:r>' : '<STR_LIT:->' , '<STR_LIT:i>' : '<STR_LIT:+>' } [ a . action ] + '<STR_LIT:U+0020>' <EOL> self . context . launch ( '<STR_LIT>' , command = cmd , callback = callback ) <EOL> def _parse_asv ( self , d ) : <EOL> r = [ ] <EOL> for l in d . split ( '<STR_LIT:\\n>' ) : <EOL> s = l . split ( '<STR_LIT:/>' ) <EOL> if len ( s ) == <NUM_LIT:0> or not s [ <NUM_LIT:0> ] : <EOL> continue <EOL> p = PackageInfo ( ) <EOL> p . name = s [ <NUM_LIT:0> ] <EOL> p . version = s [ - <NUM_LIT:1> ] . split ( '<STR_LIT:U+0020>' ) [ - <NUM_LIT:1> ] <EOL> r . append ( p ) <EOL> return r <EOL> def _parse_apt ( self , d ) : <EOL> r = [ ] <EOL> for l in d . split ( '<STR_LIT:\\n>' ) : <EOL> s = filter ( None , l . split ( '<STR_LIT:U+0020>' ) ) <EOL> if len ( s ) == <NUM_LIT:0> : <EOL> continue <EOL> p = PackageInfo ( ) <EOL>", "answer": "if s [ <NUM_LIT:0> ] == '<STR_LIT>' :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from . . entity import Entity <EOL> class SitePlacement ( Entity ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> collection = '<STR_LIT>' <EOL> resource = '<STR_LIT>' <EOL> _relations = { <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> } <EOL> _deal_sources = Entity . _enum ( { '<STR_LIT>' , '<STR_LIT>' } , '<STR_LIT>' ) <EOL> _media_types = Entity . _enum ( { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } , '<STR_LIT>' ) <EOL> _pmp_types = Entity . _enum ( { '<STR_LIT>' , '<STR_LIT>' } , '<STR_LIT>' ) <EOL> _pull = { <EOL> '<STR_LIT>' : Entity . _int_to_bool , <EOL> '<STR_LIT>' : Entity . _strpt , <EOL> '<STR_LIT>' : None , <EOL>", "answer": "'<STR_LIT>' : None ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import json <EOL> from urllib . parse import quote <EOL> from tornado import web , gen <EOL> from . . import orm <EOL> from . . utils import token_authenticated <EOL> from . base import APIHandler <EOL> class TokenAPIHandler ( APIHandler ) : <EOL> @ token_authenticated <EOL> def get ( self , token ) : <EOL> orm_token = orm . APIToken . find ( self . db , token ) <EOL> if orm_token is None : <EOL> raise web . HTTPError ( <NUM_LIT> ) <EOL> self . write ( json . dumps ( self . user_model ( self . users [ orm_token . user ] ) ) ) <EOL> @ gen . coroutine <EOL> def post ( self ) : <EOL> if self . authenticator is not None : <EOL> data = self . get_json_body ( ) <EOL> username = yield self . authenticator . authenticate ( self , data ) <EOL> if username is None : <EOL> raise web . HTTPError ( <NUM_LIT> ) <EOL> user = self . find_user ( username ) <EOL> api_token = user . new_api_token ( ) <EOL> self . write ( json . dumps ( { \"<STR_LIT>\" : api_token } ) ) <EOL> else : <EOL>", "answer": "raise web . HTTPError ( <NUM_LIT> )"}, {"prompt": "<s> from __pyjamas__ import JS , debugger <EOL> overrides = None <EOL> loadpath = None <EOL> stacktrace = None <EOL> appname = None <EOL> version_info = ( <NUM_LIT:2> , <NUM_LIT:5> , <NUM_LIT:0> , '<STR_LIT>' , <NUM_LIT:0> ) <EOL> subversion = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def setloadpath ( lp ) : <EOL> global loadpath <EOL> loadpath = lp <EOL> def setappname ( an ) : <EOL> global appname <EOL> appname = an <EOL> def getloadpath ( ) : <EOL> return loadpath <EOL> def addoverride ( module_name , path ) : <EOL> overrides [ module_name ] = path <EOL> def exc_info ( ) : <EOL> le = JS ( '<STR_LIT>' ) <EOL> if not le : <EOL> return ( None , None , None ) <EOL> if not hasattr ( le . error , '<STR_LIT>' ) : <EOL> cls = None <EOL> else : <EOL> cls = le . error . __class__ <EOL> tb = JS ( '<STR_LIT>' ) <EOL> if tb : <EOL> start = tb . start <EOL> while tb and start > <NUM_LIT:0> : <EOL> tb = tb . tb_next <EOL> start -= <NUM_LIT:1> <EOL> return ( cls , le . error , tb ) <EOL> def exc_clear ( ) : <EOL> JS ( '<STR_LIT>' ) <EOL> JS ( \"\"\"<STR_LIT>\"\"\" ) <EOL> JS ( \"\"\"<STR_LIT>\"\"\" ) <EOL> def trackstacklist ( stack = None , limit = None ) : <EOL> if stack is None : <EOL> stack = JS ( '<STR_LIT>' ) <EOL> else : <EOL> if JS ( \"\"\"<STR_LIT>\"\"\" ) : <EOL> stack = _exception_from_trackstack ( stack ) <EOL> if stack is None : <EOL> return '<STR_LIT>' <EOL> stackstrings = [ ] <EOL> msg = '<STR_LIT>' <EOL> if limit is None : <EOL> limit = - <NUM_LIT:1> <EOL> while stack and limit : <EOL> JS ( \"<STR_LIT>\" ) <EOL> JS ( \"<STR_LIT>\" ) <EOL> if msg : <EOL> stackstrings . append ( msg + '<STR_LIT:\\n>' ) <EOL> else : <EOL> stackstrings . append ( '<STR_LIT>' % ( stack . module , stack . lineno ) ) <EOL> stack = stack . tb_next <EOL> limit -= <NUM_LIT:1> <EOL> return stackstrings <EOL> def trackstackstr ( stack = None , limit = None ) : <EOL> stackstrings = trackstacklist ( stack , limit = limit ) <EOL> return '<STR_LIT>' . join ( stackstrings ) <EOL> def _get_traceback_list ( err , tb = None , limit = None ) : <EOL> msg = [ str ( err ) + '<STR_LIT:\\n>' , '<STR_LIT>' ] <EOL> try : <EOL> msg . extend ( trackstacklist ( tb , limit = limit ) ) <EOL> except : <EOL> pass <EOL> return msg <EOL>", "answer": "def _get_traceback ( err , tb = None , limit = None ) :"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> from django . db import models <EOL> import constants <EOL> class Worker ( models . Model ) : <EOL> name = models . CharField ( default = '<STR_LIT>' , max_length = constants . MAX_NAME_LENGTH ) <EOL>", "answer": "purpose = models . CharField ( max_length = constants . MAX_PURPOSE_LENGTH )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import sys <EOL> from shutil import rmtree <EOL> from tempfile import mkdtemp <EOL> from multiprocessing import Pool <EOL> import scipy . sparse as sp <EOL> from scipy . io import loadmat <EOL> from multimodal . experiment import TwoModalitiesExperiment <EOL> from multimodal . db . objects import ObjectsLoader <EOL> from multimodal . db . acorns import Year1Loader as AcornsLoader <EOL> from multimodal . lib . window import ( concat_from_list_of_wavs , BasicTimeWindow , <EOL> ConcatTimeWindow , slider ) <EOL> from multimodal . learner import MultimodalLearner <EOL> from multimodal . lib . metrics import cosine_diff <EOL> from multimodal . evaluation import all_distances <EOL> from multimodal . features . hac import hac <EOL> from multimodal . local import CONFIG <EOL> CODEBOOK_PATH = os . path . join ( CONFIG [ '<STR_LIT>' ] , \"<STR_LIT>\" ) <EOL> DEBUG = False <EOL> if len ( sys . argv ) > <NUM_LIT:1> and sys . argv [ <NUM_LIT:1> ] == '<STR_LIT>' : <EOL> DEBUG = True <EOL> sys . argv . pop ( <NUM_LIT:1> ) <EOL> exp = TwoModalitiesExperiment ( { '<STR_LIT>' : ObjectsLoader ( [ '<STR_LIT>' , '<STR_LIT>' ] ) , <EOL> '<STR_LIT>' : AcornsLoader ( <NUM_LIT:1> ) } , <EOL> <NUM_LIT:50> , <NUM_LIT:50> , <NUM_LIT:50> , debug = DEBUG , run_mode = '<STR_LIT>' ) <EOL> if len ( sys . argv ) > <NUM_LIT:1> : <EOL> path = '<STR_LIT>' <EOL> if len ( sys . argv ) > <NUM_LIT:2> : <EOL> path = os . path . expanduser ( sys . argv [ <NUM_LIT:2> ] ) <EOL> path = os . path . join ( os . getcwd ( ) , path ) <EOL> exp . set_out_path_and_name ( path , sys . argv [ <NUM_LIT:1> ] ) <EOL> exp . run ( ) <EOL> exp . print_result_table ( ) <EOL> WIDTH = <NUM_LIT> <EOL> SHIFT = <NUM_LIT> <EOL> sound_modality = exp . modalities . index ( '<STR_LIT>' ) <EOL> objects_modality = exp . modalities . index ( '<STR_LIT>' ) <EOL> test_idx = exp . logger . get_last_value ( '<STR_LIT:test>' ) <EOL> test_labels = [ exp . labels [ t ] for t in test_idx ] <EOL> assoc_idx = exp . logger . get_value ( '<STR_LIT>' ) <EOL> if DEBUG : <EOL> test_idx = test_idx [ : <NUM_LIT:10> ] <EOL> test_labels = test_labels [ : <NUM_LIT:10> ] <EOL> assoc_idx = assoc_idx [ : <NUM_LIT:10> ] <EOL> sound_loader = exp . loaders [ sound_modality ] <EOL> test_wavs = [ sound_loader . records [ i [ sound_modality ] ] . get_audio_path ( ) <EOL> for i in assoc_idx ] <EOL> print ( '<STR_LIT>' ) <EOL> test_sound_wins = concat_from_list_of_wavs ( test_wavs ) <EOL> test_sound_idx_wins = ConcatTimeWindow ( [ <EOL> BasicTimeWindow ( w . absolute_start , w . absolute_end , obj = i [ sound_modality ] ) <EOL>", "answer": "for i , w in zip ( assoc_idx , test_sound_wins . windows )"}, {"prompt": "<s> import re <EOL> import sys <EOL> from . ansi import AnsiFore , AnsiBack , AnsiStyle , Style <EOL>", "answer": "from . winterm import WinTerm , WinColor , WinStyle"}, {"prompt": "<s> import os <EOL> import sys <EOL> import ogr <EOL> from shapely . geometry import Polygon <EOL> from random import uniform <EOL> import sqlite3 <EOL> from globalmaptiles import GlobalMercator <EOL> import zipfile <EOL> from time import time <EOL> def make_ogr_point ( x , y ) : <EOL> return ogr . Geometry ( wkt = \"<STR_LIT>\" % ( x , y ) ) <EOL> def get_bbox ( geom ) : <EOL> ll = float ( \"<STR_LIT>\" ) <EOL> bb = float ( \"<STR_LIT>\" ) <EOL> rr = float ( \"<STR_LIT>\" ) <EOL> tt = float ( \"<STR_LIT>\" ) <EOL> ch = geom . ConvexHull ( ) <EOL> if not ch : <EOL> return None <EOL> bd = ch . GetBoundary ( ) <EOL> if not bd : <EOL> return None <EOL> pts = bd . GetPoints ( ) <EOL> if not pts : <EOL> return None <EOL> for x , y in pts : <EOL> ll = min ( ll , x ) <EOL> rr = max ( rr , x ) <EOL> bb = min ( bb , y ) <EOL> tt = max ( tt , y ) <EOL> return ( ll , bb , rr , tt ) <EOL> def confirm ( prompt = None , resp = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if prompt is None : <EOL> prompt = '<STR_LIT>' <EOL> if resp : <EOL> prompt = '<STR_LIT>' % ( prompt , '<STR_LIT:y>' , '<STR_LIT:n>' ) <EOL> else : <EOL> prompt = '<STR_LIT>' % ( prompt , '<STR_LIT:n>' , '<STR_LIT:y>' ) <EOL> while True : <EOL> ans = raw_input ( prompt ) <EOL> if not ans : <EOL> return resp <EOL> if ans not in [ '<STR_LIT:y>' , '<STR_LIT:Y>' , '<STR_LIT:n>' , '<STR_LIT:N>' ] : <EOL> print '<STR_LIT>' <EOL> continue <EOL> if ans == '<STR_LIT:y>' or ans == '<STR_LIT:Y>' : <EOL> return True <EOL> if ans == '<STR_LIT:n>' or ans == '<STR_LIT:N>' : <EOL> return False <EOL> def unlock ( filename ) : <EOL> import commands <EOL> import re <EOL> PID = commands . getoutput ( \"<STR_LIT>\" % filename ) <EOL> PID = re . search ( '<STR_LIT>' , PID ) . group ( <NUM_LIT:0> ) <EOL> print \"<STR_LIT>\" % PID <EOL> os . environ [ '<STR_LIT>' ] = PID <EOL> os . system ( \"<STR_LIT>\" ) <EOL> if os . path . isfile ( filename ) : <EOL> os . system ( \"<STR_LIT>\" % filename ) <EOL> def main ( input_filename , output_filename ) : <EOL> print \"<STR_LIT>\" % input_filename <EOL> merc = GlobalMercator ( ) <EOL> ds = ogr . Open ( input_filename ) <EOL> if ds is None : <EOL> print \"<STR_LIT>\" <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> lyr = ds . GetLayerByIndex ( <NUM_LIT:0> ) <EOL> lyr . ResetReading ( ) <EOL> feat_defn = lyr . GetLayerDefn ( ) <EOL> field_defns = [ feat_defn . GetFieldDefn ( i ) for i in range ( feat_defn . GetFieldCount ( ) ) ] <EOL> for i , defn in enumerate ( field_defns ) : <EOL> if defn . GetName ( ) == \"<STR_LIT>\" : <EOL> pop_field = i <EOL> if os . path . isfile ( output_filename ) : <EOL> if not confirm ( \"<STR_LIT>\" % output_filename , False ) : <EOL> return False <EOL> else : <EOL> os . system ( \"<STR_LIT>\" % output_filename ) <EOL> if os . path . isfile ( output_filename ) : <EOL> if not confirm ( \"<STR_LIT>\" % output_filename , False ) : <EOL> return False <EOL> else : <EOL> unlock ( output_filename ) <EOL> if os . path . isfile ( output_filename ) : <EOL> print \"<STR_LIT>\" <EOL> sys . exit ( ) <EOL> else : <EOL> print \"<STR_LIT>\" <EOL> conn = sqlite3 . connect ( output_filename ) <EOL> c = conn . cursor ( ) <EOL> c . execute ( \"<STR_LIT>\" ) <EOL> n_features = len ( lyr ) <EOL> for j , feat in enumerate ( lyr ) : <EOL> if j % <NUM_LIT:1000> == <NUM_LIT:0> : <EOL> conn . commit ( ) <EOL> if j % <NUM_LIT> == <NUM_LIT:0> : <EOL> print \"<STR_LIT>\" % ( j + <NUM_LIT:1> , n_features , <NUM_LIT:100> * ( ( j + <NUM_LIT:1> ) / float ( n_features ) ) ) <EOL>", "answer": "else :"}, {"prompt": "<s> class String ( object ) : <EOL> def __init__ ( self , choices = None ) : <EOL> if choices : <EOL> choices = [ str ( c ) for c in choices ] <EOL> self . choices = choices <EOL> def __call__ ( self , value ) : <EOL> value = str ( value ) <EOL> if self . choices and value not in self . choices : <EOL> raise ValueError ( '<STR_LIT>' % <EOL> ( value , self . choices ) ) <EOL> return value <EOL> def __repr__ ( self ) : <EOL> obj = '<STR_LIT>' <EOL> if self . choices : <EOL> obj += '<STR_LIT>' % '<STR_LIT:U+002C>' . join ( self . choices ) <EOL> return obj <EOL> class Boolean ( object ) : <EOL> TRUEVALUES = [ '<STR_LIT:yes>' , '<STR_LIT:true>' , '<STR_LIT:1>' , '<STR_LIT>' ] <EOL> FALSEVALUES = [ '<STR_LIT>' , '<STR_LIT:false>' , '<STR_LIT:0>' , '<STR_LIT>' ] <EOL> def __call__ ( self , value ) : <EOL> if str ( value ) . lower ( ) in self . TRUEVALUES : <EOL> return True <EOL> elif str ( value ) . lower ( ) in self . FALSEVALUES : <EOL> return False <EOL> else : <EOL> raise ValueError ( '<STR_LIT>' % value ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' <EOL> class Integer ( object ) : <EOL> def __init__ ( self , min_value = None , max_value = None ) : <EOL> self . min_value = min_value <EOL> self . max_value = max_value <EOL> def __call__ ( self , value ) : <EOL> try : <EOL> value = int ( value ) <EOL> except ValueError : <EOL> raise ValueError ( '<STR_LIT>' % value ) <EOL> if self . min_value is not None and value < self . min_value : <EOL> raise ValueError ( '<STR_LIT>' % <EOL> ( value , self . min_value ) ) <EOL> if self . max_value is not None and value > self . max_value : <EOL> raise ValueError ( '<STR_LIT>' % <EOL> ( value , self . max_value ) ) <EOL> return value <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . min_value , self . max_value ) <EOL> class List ( object ) : <EOL> def __init__ ( self , delimiter = '<STR_LIT:U+002C>' ) : <EOL> self . delimiter = delimiter <EOL> def __call__ ( self , value ) : <EOL> if isinstance ( value , list ) : <EOL> return value <EOL>", "answer": "return str ( value ) . split ( self . delimiter )"}, {"prompt": "<s> from django . db . models import signals <EOL> from django import VERSION <EOL> from django . apps import AppConfig <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> class ConstanceConfig ( AppConfig ) : <EOL> name = '<STR_LIT>' <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> def ready ( self ) : <EOL> super ( ConstanceConfig , self ) . ready ( ) <EOL> signals . post_migrate . connect ( self . create_perm , <EOL> dispatch_uid = '<STR_LIT>' ) <EOL> def create_perm ( self , * args , ** kwargs ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> import natlink <EOL> import natlinkmain <EOL> import pprint <EOL> import redis <EOL> def myCallback ( command , args ) : <EOL> if command == \"<STR_LIT>\" : <EOL> try : <EOL> print \"<STR_LIT>\" % args <EOL> r = redis . Redis ( ) <EOL> r . set ( '<STR_LIT>' , args ) <EOL> except Exception as e : <EOL> print e <EOL> print \"<STR_LIT>\" <EOL> apply ( natlinkmain . changeCallback , [ command , args ] ) <EOL> natlink . setChangeCallback ( myCallback ) <EOL> def unload ( ) : <EOL> print \"<STR_LIT>\" <EOL>", "answer": "natlink . setChangeCallback ( natlinkmain . changeCallback ) "}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL> def convert_defaults ( apps , schema_editor ) : <EOL> PlayerDB = apps . get_model ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "for player in PlayerDB . objects . filter ( db_typeclass_path = \"<STR_LIT>\" ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import division <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> from numpy import hstack , empty , ones , zeros , cumsum , arange , reshape , array , isscalar , asarray , std , sum , trunc , log10 , logspace <EOL> from . import util <EOL> class Crossover ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def __init__ ( self , CR , weight = None ) :"}, {"prompt": "<s> from metakernel . tests . utils import ( get_kernel , get_log_text , <EOL> clear_log_text , EvalKernel ) <EOL> import os <EOL> def test_download_magic ( ) : <EOL> kernel = get_kernel ( EvalKernel ) <EOL> kernel . do_execute ( \"<STR_LIT>\" ) <EOL> text = get_log_text ( kernel ) <EOL> assert \"<STR_LIT>\" in text , text <EOL> assert os . path . isfile ( \"<STR_LIT>\" ) , \"<STR_LIT>\" <EOL> clear_log_text ( kernel ) <EOL> kernel . do_execute ( \"<STR_LIT>\" ) <EOL> text = get_log_text ( kernel ) <EOL> assert \"<STR_LIT>\" in text , text <EOL> assert os . path . isfile ( \"<STR_LIT>\" ) , \"<STR_LIT>\" <EOL> def teardown ( ) : <EOL> for fname in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> try : <EOL> os . remove ( fname ) <EOL>", "answer": "except :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = <NUM_LIT:9>"}, {"prompt": "<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> from pants_test . backend . jvm . tasks . jvm_compile . base_compile_integration_test import BaseCompileIT <EOL> DIR_DEPS_WHITELISTED = '<STR_LIT>' <EOL> JAR_DEPS_WHITELISTED = '<STR_LIT>' <EOL> class DeclaredDepsIntegrationTest ( BaseCompileIT ) : <EOL> def test_direct_source_dep ( self ) : <EOL> self . do_test_success_and_failure ( <EOL> DIR_DEPS_WHITELISTED , <EOL> [ '<STR_LIT>' ] , <EOL> [ '<STR_LIT>' ] , <EOL> ) <EOL> def test_direct_jar_dep ( self ) : <EOL> self . do_test_success_and_failure ( <EOL> JAR_DEPS_WHITELISTED , <EOL> [ '<STR_LIT>' ] , <EOL> [ '<STR_LIT>' ] , <EOL> ) <EOL> def test_invalid_subsystem_option_location ( self ) : <EOL> with self . do_test_compile ( JAR_DEPS_WHITELISTED , <EOL> expect_failure = True , <EOL> extra_args = [ '<STR_LIT>' ] ) : <EOL> pass <EOL> def test_missing_source_dep_whitelist ( self ) : <EOL> self . do_test_success_and_failure ( <EOL> DIR_DEPS_WHITELISTED , <EOL> [ '<STR_LIT>' . format ( DIR_DEPS_WHITELISTED ) ] , <EOL> [ ] , <EOL> shared_args = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "] ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> class Var ( object ) : <EOL> \"<STR_LIT>\" <EOL> def __init__ ( self , master = None , value = None , name = None ) : <EOL> self . master = master <EOL> self . value = value <EOL> self . name = name <EOL> def set ( self , value ) : <EOL> self . value = value <EOL> def get ( self ) : <EOL> return self . value <EOL> class Mbox_func ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> self . result = None <EOL> def __call__ ( self , title , message , * args , ** kwds ) : <EOL> self . title = title <EOL> self . message = message <EOL> self . args = args <EOL> self . kwds = kwds <EOL> return self . result <EOL> class Mbox ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> askokcancel = Mbox_func ( ) <EOL> askquestion = Mbox_func ( ) <EOL> askretrycancel = Mbox_func ( ) <EOL> askyesno = Mbox_func ( ) <EOL> askyesnocancel = Mbox_func ( ) <EOL> showerror = Mbox_func ( ) <EOL>", "answer": "showinfo = Mbox_func ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from construct import * <EOL> from ethernet import MacAddressAdapter <EOL> from construct . protocols . layer3 . ipv4 import IpAddressAdapter <EOL> def HwAddress ( name ) : <EOL> return IfThenElse ( name , lambda ctx : ctx . hardware_type == \"<STR_LIT>\" , <EOL> MacAddressAdapter ( Field ( \"<STR_LIT:data>\" , lambda ctx : ctx . hwaddr_length ) ) , <EOL> Field ( \"<STR_LIT:data>\" , lambda ctx : ctx . hwaddr_length ) <EOL> ) <EOL> def ProtoAddress ( name ) : <EOL> return IfThenElse ( name , lambda ctx : ctx . protocol_type == \"<STR_LIT>\" , <EOL> IpAddressAdapter ( Field ( \"<STR_LIT:data>\" , lambda ctx : ctx . protoaddr_length ) ) , <EOL> Field ( \"<STR_LIT:data>\" , lambda ctx : ctx . protoaddr_length ) <EOL> ) <EOL> arp_header = Struct ( \"<STR_LIT>\" , <EOL> Enum ( UBInt16 ( \"<STR_LIT>\" ) , <EOL> ETHERNET = <NUM_LIT:1> , <EOL> EXPERIMENTAL_ETHERNET = <NUM_LIT:2> , <EOL> ProNET_TOKEN_RING = <NUM_LIT:4> , <EOL> CHAOS = <NUM_LIT:5> , <EOL> IEEE802 = <NUM_LIT:6> , <EOL> ARCNET = <NUM_LIT:7> , <EOL> HYPERCHANNEL = <NUM_LIT:8> , <EOL> ULTRALINK = <NUM_LIT> , <EOL> FRAME_RELAY = <NUM_LIT:15> , <EOL> FIBRE_CHANNEL = <NUM_LIT> , <EOL> IEEE1394 = <NUM_LIT> , <EOL> HIPARP = <NUM_LIT> , <EOL> ISO7816_3 = <NUM_LIT> , <EOL> ARPSEC = <NUM_LIT:30> , <EOL> IPSEC_TUNNEL = <NUM_LIT> , <EOL> INFINIBAND = <NUM_LIT:32> , <EOL>", "answer": ") ,"}, {"prompt": "<s> import unittest <EOL> from graphserver . core import * <EOL> class TestSPTVertex ( unittest . TestCase ) : <EOL> def test_basic ( self ) : <EOL> vv = Vertex ( \"<STR_LIT>\" ) <EOL> v = SPTVertex ( vv ) <EOL> assert v . mirror . soul == vv . soul <EOL> assert v <EOL> def test_init_hop ( self ) : <EOL> v = SPTVertex ( Vertex ( \"<STR_LIT:A>\" ) ) <EOL> assert v . hop == <NUM_LIT:0> <EOL> v = SPTVertex ( Vertex ( \"<STR_LIT:B>\" ) , <NUM_LIT:1> ) <EOL>", "answer": "assert v . hop == <NUM_LIT:1>"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> import time <EOL> from apiclient . discovery import build <EOL> from apiclient . errors import HttpError <EOL> from apiclient . http import MediaFileUpload <EOL> import httplib2 <EOL> from oauth2client . client import SignedJwtAssertionCredentials <EOL> from grr . lib import config_lib <EOL> BIGQUERY_SCOPE = \"<STR_LIT>\" <EOL> class Error ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class BigQueryJobUploadError ( Error ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def GetBigQueryClient ( service_account = None , private_key = None , project_id = None , <EOL> dataset_id = None ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> import os <EOL> import sys <EOL> sys . path . insert ( <NUM_LIT:0> , os . path . abspath ( '<STR_LIT>' ) ) <EOL>", "answer": "extensions = ["}, {"prompt": "<s> import sys , os <EOL> extensions = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> templates_path = [ '<STR_LIT>' ] <EOL> source_suffix = '<STR_LIT>' <EOL> master_doc = '<STR_LIT:index>' <EOL> project = u'<STR_LIT>' <EOL> copyright = u'<STR_LIT>' <EOL> version = \"<STR_LIT>\" <EOL> release = \"<STR_LIT>\" <EOL>", "answer": "exclude_patterns = [ '<STR_LIT>' ]"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from collections import Counter , namedtuple , defaultdict <EOL> import os . path <EOL> import re <EOL> from chunkedfile import ChunkedFile <EOL> from utils import Timer , open_compressed <EOL> IMDbRating = namedtuple ( '<STR_LIT>' , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> IMDbPlot = namedtuple ( '<STR_LIT>' , ( '<STR_LIT>' ) ) <EOL> def parsers ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for parsername , parser in sorted ( globals ( ) . items ( ) ) : <EOL> if parsername [ <NUM_LIT:0> ] == '<STR_LIT:_>' or not parsername . endswith ( '<STR_LIT>' ) : <EOL> continue <EOL> if hasattr ( parser , '<STR_LIT>' ) : <EOL> yield ( parsername [ <NUM_LIT:4> : - <NUM_LIT:6> ] , parser ) <EOL> IMDbParsedTitle = namedtuple ( '<STR_LIT>' , <EOL> ( '<STR_LIT:title>' , '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> IMDbParsedName = namedtuple ( '<STR_LIT>' , <EOL> ( '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> TITLERE = re . compile ( r'<STR_LIT>' <EOL> + r'<STR_LIT>' <EOL> + r'<STR_LIT>' <EOL> + r'<STR_LIT>' , <EOL> re . UNICODE ) <EOL> NAMERE = re . compile ( r'<STR_LIT>' <EOL> + r'<STR_LIT>' , <EOL> re . UNICODE ) <EOL> CASTRE = re . compile ( r'<STR_LIT>' <EOL> + r'<STR_LIT>' <EOL> + r'<STR_LIT>' <EOL> + r'<STR_LIT>' , <EOL> re . UNICODE ) <EOL> def parse_title ( title ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> match = TITLERE . match ( title ) <EOL> if not match or match . group ( '<STR_LIT>' ) : <EOL> raise ValueError ( '<STR_LIT>' % ( title , ) ) <EOL> name = match . group ( '<STR_LIT:name>' ) <EOL> year = match . group ( '<STR_LIT>' ) <EOL> if year == u'<STR_LIT>' : <EOL> year = None <EOL> unique = match . group ( '<STR_LIT>' ) <EOL> cat = None <EOL> if name [ <NUM_LIT:0> ] == '<STR_LIT:\">' and name [ - <NUM_LIT:1> ] == '<STR_LIT:\">' : <EOL> name = name [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> assert ( cat is None ) <EOL> cat = \"<STR_LIT>\" <EOL> return IMDbParsedTitle ( title , name , year , unique , cat ) <EOL> def parse_name ( name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> match = NAMERE . match ( name ) <EOL> if not match : <EOL> raise ValueError ( '<STR_LIT>' % ( name , ) ) <EOL> first = match . group ( '<STR_LIT>' ) or None <EOL> last = match . group ( '<STR_LIT>' ) <EOL> unique = match . group ( '<STR_LIT>' ) <EOL> return IMDbParsedName ( name , first , last , unique ) <EOL> def _skip_to ( fileobj , indicator , additional_skips ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> i = <NUM_LIT:1> <EOL> for line in fileobj : <EOL> if line . strip ( ) == indicator : <EOL> break <EOL> i += <NUM_LIT:1> <EOL> else : <EOL> raise SyntaxError ( \"<STR_LIT>\" ) <EOL> for i in xrange ( additional_skips ) : <EOL> next ( fileobj ) <EOL> return i + additional_skips <EOL> def _find_seeks_index ( dbfile , indexname , queries , debug = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> timer = Timer ( rl_min_dur = <NUM_LIT:1> ) <EOL> locs = Counter ( ) <EOL> if debug : <EOL> print \"<STR_LIT>\" <EOL> indexfh = ChunkedFile ( dbfile , indexname , mode = '<STR_LIT:r>' ) <EOL> last_bookmark = <NUM_LIT:0> <EOL> for query in sorted ( queries ) : <EOL> bookmark = indexfh . find_bookmark ( query . encode ( '<STR_LIT:utf-8>' ) ) <EOL> if bookmark != last_bookmark : <EOL> indexfh . seek ( bookmark ) <EOL> last_bookmark = bookmark <EOL> for i , line in enumerate ( indexfh ) : <EOL> title , nums = line . decode ( '<STR_LIT:utf-8>' ) . split ( '<STR_LIT:\\t>' ) <EOL> if i % <NUM_LIT:100> == <NUM_LIT:0> : <EOL> timer . step ( ) <EOL> if title in queries : <EOL> locs . update ( int ( x ) for x in nums . split ( '<STR_LIT:U+0020>' ) ) <EOL> elif title > query : <EOL> break <EOL> indexfh . close ( ) <EOL> for start , nresults in sorted ( locs . items ( ) ) : <EOL> yield ( start , None , nresults ) <EOL> if debug : <EOL> print '<STR_LIT>' , timer , '<STR_LIT>' <EOL> def _find_seeks_bookmarks ( fileobj , queries , debug = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> timer = Timer ( ) <EOL> locs = Counter ( ) <EOL> endlocs = { } <EOL> if debug : <EOL> print \"<STR_LIT>\" <EOL> for query in sorted ( queries ) : <EOL> start , end = fileobj . find_bookmark ( query . encode ( '<STR_LIT:utf-8>' ) , <EOL> give_range = True ) <EOL> if not end : <EOL> endlocs [ start ] = None <EOL> elif start not in endlocs or endlocs [ start ] < end : <EOL> endlocs [ start ] = end <EOL> locs . update ( ( start , ) ) <EOL> start = <NUM_LIT:0> <EOL> end = <NUM_LIT:0> <EOL> nresults = <NUM_LIT:0> <EOL> for nextstart , nextnresults in sorted ( locs . items ( ) ) : <EOL> nextend = endlocs [ nextstart ] if nextstart in endlocs else None <EOL> assert ( nextnresults > <NUM_LIT:0> ) <EOL> if end is None or nextstart <= end : <EOL> if nextend is None or ( end is not None and nextend > end ) : <EOL> end = nextend <EOL> nresults += nextnresults <EOL> else : <EOL> if nresults > <NUM_LIT:0> : <EOL> yield ( start , end , nresults ) <EOL> start = nextstart <EOL> end = nextend <EOL> nresults = nextnresults <EOL> if nresults > <NUM_LIT:0> : <EOL> yield ( start , end , nresults ) <EOL> if debug : <EOL> print '<STR_LIT>' , timer , '<STR_LIT>' <EOL> class _IMDbParser ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> filenames = [ ] <EOL> default = None <EOL> def __init__ ( self , dbfile , dbdir = None , debug = False ) : <EOL> self . dbfile = dbfile <EOL> self . listname = self . __class__ . __name__ [ <NUM_LIT:4> : - <NUM_LIT:6> ] . lower ( ) <EOL> self . indexname = self . listname + '<STR_LIT>' <EOL> if dbdir : <EOL> self . origfiles = [ os . path . join ( dbdir , fn + '<STR_LIT>' ) for fn in self . filenames ] <EOL> else : <EOL> self . listorig = None <EOL> self . skip_tvvg = False <EOL> self . debug = debug <EOL> def rebuild_index ( self , do_copy = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if do_copy : <EOL> copy_to = ChunkedFile ( self . dbfile , self . listname , mode = '<STR_LIT:a>' , <EOL> autoflush = True if self . indexname else False ) <EOL> tellobj = copy_to <EOL> filenames = self . origfiles <EOL> else : <EOL> copy_to = None <EOL> raise NotImplementedError <EOL> indexobj = defaultdict ( list ) <EOL> for filename in filenames : <EOL> if do_copy : <EOL> try : <EOL> fileobj = open_compressed ( filename ) <EOL>", "answer": "except IOError as e :"}, {"prompt": "<s> from msrest . serialization import Model <EOL> class ClassicMobileServiceCollection ( Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _attribute_map = { <EOL> '<STR_LIT:value>' : { '<STR_LIT:key>' : '<STR_LIT:value>' , '<STR_LIT:type>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:key>' : '<STR_LIT>' , '<STR_LIT:type>' : '<STR_LIT:str>' } , <EOL> } <EOL> def __init__ ( self , value = None , next_link = None ) : <EOL>", "answer": "self . value = value"}, {"prompt": "<s> from __future__ import print_function <EOL> __author__ = '<STR_LIT>' <EOL> from scipy import dot , argmax <EOL> from random import shuffle <EOL> from math import isnan <EOL> from pybrain . supervised . trainers . trainer import Trainer <EOL> from pybrain . utilities import fListToString <EOL> from pybrain . auxiliary import GradientDescent <EOL> class BackpropTrainer ( Trainer ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , module , dataset = None , learningrate = <NUM_LIT> , lrdecay = <NUM_LIT:1.0> , <EOL> momentum = <NUM_LIT:0.> , verbose = False , batchlearning = False , <EOL> weightdecay = <NUM_LIT:0.> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Trainer . __init__ ( self , module ) <EOL> self . setData ( dataset ) <EOL> self . verbose = verbose <EOL> self . batchlearning = batchlearning <EOL> self . weightdecay = weightdecay <EOL> self . epoch = <NUM_LIT:0> <EOL> self . totalepochs = <NUM_LIT:0> <EOL> self . descent = GradientDescent ( ) <EOL> self . descent . alpha = learningrate <EOL> self . descent . momentum = momentum <EOL> self . descent . alphadecay = lrdecay <EOL> self . descent . init ( module . params ) <EOL> def train ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert len ( self . ds ) > <NUM_LIT:0> , \"<STR_LIT>\" <EOL> self . module . resetDerivatives ( ) <EOL> errors = <NUM_LIT:0> <EOL> ponderation = <NUM_LIT:0.> <EOL> shuffledSequences = [ ] <EOL> for seq in self . ds . _provideSequences ( ) : <EOL> shuffledSequences . append ( seq ) <EOL> shuffle ( shuffledSequences ) <EOL> for seq in shuffledSequences : <EOL> e , p = self . _calcDerivs ( seq ) <EOL> errors += e <EOL> ponderation += p <EOL> if not self . batchlearning : <EOL> gradient = self . module . derivs - self . weightdecay * self . module . params <EOL> new = self . descent ( gradient , errors ) <EOL> if new is not None : <EOL> self . module . params [ : ] = new <EOL> self . module . resetDerivatives ( ) <EOL> if self . verbose : <EOL> print ( \"<STR_LIT>\" . format ( z = errors / ponderation ) ) <EOL> if self . batchlearning : <EOL> self . module . _setParameters ( self . descent ( self . module . derivs ) ) <EOL> self . epoch += <NUM_LIT:1> <EOL> self . totalepochs += <NUM_LIT:1> <EOL> return errors / ponderation <EOL> def _calcDerivs ( self , seq ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . module . reset ( ) <EOL> for sample in seq : <EOL> self . module . activate ( sample [ <NUM_LIT:0> ] ) <EOL> error = <NUM_LIT:0> <EOL> ponderation = <NUM_LIT:0.> <EOL> for offset , sample in reversed ( list ( enumerate ( seq ) ) ) : <EOL> target = sample [ <NUM_LIT:1> ] <EOL> outerr = target - self . module . outputbuffer [ offset ] <EOL> if len ( sample ) > <NUM_LIT:2> : <EOL> importance = sample [ <NUM_LIT:2> ] <EOL> error += <NUM_LIT:0.5> * dot ( importance , outerr ** <NUM_LIT:2> ) <EOL> ponderation += sum ( importance ) <EOL> self . module . backActivate ( outerr * importance ) <EOL> else : <EOL> error += <NUM_LIT:0.5> * sum ( outerr ** <NUM_LIT:2> ) <EOL> ponderation += len ( target ) <EOL> str ( outerr ) <EOL> self . module . backActivate ( outerr ) <EOL>", "answer": "return error , ponderation"}, {"prompt": "<s> import os <EOL> import sys <EOL> import heapq <EOL> from collections import defaultdict <EOL> def readNMerge ( fileLst , outFile ) : <EOL> '''<STR_LIT>''' <EOL> candLst = [ ] <EOL> tgtDict = { } <EOL> total_rules = <NUM_LIT:0> <EOL> stop_iteration = False <EOL> fileTrackLst = [ <NUM_LIT:1> for file in fileLst ] <EOL> print \"<STR_LIT>\" <EOL> fHLst = [ open ( file , '<STR_LIT:r>' ) for file in fileLst ] <EOL> oF = open ( outFile , '<STR_LIT:w>' ) <EOL> while True : <EOL> if stop_iteration : <EOL> break <EOL> for indx , f_track in enumerate ( fileTrackLst ) : <EOL> if f_track == <NUM_LIT:0> or f_track == <NUM_LIT:9> : <EOL> continue <EOL> fileTrackLst [ indx ] = <NUM_LIT:0> <EOL> line = fHLst [ indx ] . readline ( ) <EOL> line = line . strip ( ) <EOL> if line == '<STR_LIT>' : <EOL> fileTrackLst [ indx ] = <NUM_LIT:9> <EOL> stop_iteration = True <EOL> continue <EOL> stop_iteration = False <EOL> ( tgt , r_count ) = line . split ( '<STR_LIT>' ) <EOL> r_count = float ( r_count ) <EOL> if tgtDict . has_key ( tgt ) : <EOL> valTup = ( tgtDict [ tgt ] [ <NUM_LIT:0> ] + r_count , tgtDict [ tgt ] [ <NUM_LIT:1> ] + [ indx ] ) <EOL> tgtDict [ tgt ] = valTup <EOL> else : <EOL> tgtDict [ tgt ] = ( r_count , [ indx ] ) <EOL> heapq . heappush ( candLst , tgt ) <EOL> if len ( candLst ) == <NUM_LIT:0> : continue <EOL> popped_tgt = heapq . heappop ( candLst ) <EOL> ( r_count , indxLst ) = tgtDict . pop ( popped_tgt ) <EOL> oF . write ( \"<STR_LIT>\" % ( popped_tgt , r_count ) ) <EOL> total_rules += <NUM_LIT:1> <EOL> for indx1 in indxLst : <EOL> fileTrackLst [ indx1 ] = <NUM_LIT:1> <EOL> stop_iteration = False <EOL> for fH in fHLst : <EOL> fH . close ( ) <EOL> oF . close ( ) <EOL> print ( \"<STR_LIT>\" % ( total_rules ) ) <EOL> def main ( ) : <EOL> tgtPath = sys . argv [ <NUM_LIT:1> ] <EOL> fileLst = [ ] <EOL>", "answer": "for f in os . listdir ( tgtPath ) :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> __author__ = '<STR_LIT>' <EOL>", "answer": "VERSION = ( <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT:3> )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL>", "answer": "import sys"}, {"prompt": "<s> from werkzeug . exceptions import HTTPException <EOL> __author__ = '<STR_LIT>' <EOL> __version__ = '<STR_LIT>' <EOL> from flask import Flask <EOL> from flask_restful import Api <EOL> from flask_cors import CORS <EOL> from datetime import timedelta <EOL> from util import safe_get_config , get_class , Utility , Email , DisabledVoiceVerify , RonglianVoiceVerify , DisabledSms , ChinaTelecomSms <EOL> from hackathon_factory import factory , RequiredFeature <EOL> from hackathon_scheduler import HackathonScheduler <EOL> from hackathon_response import * <EOL> from hackathon_exception import * <EOL> from log import log <EOL> from context import Context <EOL> __all__ = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> app = Flask ( __name__ ) <EOL> app . config [ '<STR_LIT>' ] = safe_get_config ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> class HackathonApi ( Api ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def handle_error ( self , e ) : <EOL> log . error ( e ) <EOL> if isinstance ( e , HTTPException ) : <EOL> message = e . description <EOL> if hasattr ( e , \"<STR_LIT:data>\" ) and \"<STR_LIT:message>\" in e . data : <EOL> message = e . data [ \"<STR_LIT:message>\" ] <EOL> if e . code == <NUM_LIT> : <EOL> return self . make_response ( bad_request ( message ) , <NUM_LIT:200> ) <EOL> if e . code == <NUM_LIT> : <EOL> return self . make_response ( unauthorized ( message ) , <NUM_LIT:200> ) <EOL> if e . code == <NUM_LIT> : <EOL> return self . make_response ( forbidden ( message ) , <NUM_LIT:200> ) <EOL> if e . code == <NUM_LIT> : <EOL> return self . make_response ( not_found ( message ) , <NUM_LIT:200> ) <EOL> if e . code == <NUM_LIT> : <EOL> return self . make_response ( conflict ( message ) , <NUM_LIT:200> ) <EOL> if e . code == <NUM_LIT> : <EOL> return self . make_response ( precondition_failed ( message ) , <NUM_LIT:200> ) <EOL>", "answer": "if e . code == <NUM_LIT> :"}, {"prompt": "<s> import sys <EOL> from os . path import dirname , abspath <EOL> import django <EOL> from django . conf import settings <EOL> if len ( sys . argv ) > <NUM_LIT:1> and '<STR_LIT>' in sys . argv : <EOL> sys . argv . remove ( '<STR_LIT>' ) <EOL> db_engine = '<STR_LIT>' <EOL> db_name = '<STR_LIT>' <EOL> else : <EOL> db_engine = '<STR_LIT>' <EOL> db_name = '<STR_LIT>' <EOL> if not settings . configured : <EOL> if django . VERSION < ( <NUM_LIT:1> , <NUM_LIT:4> ) : <EOL> tl = ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) <EOL> else : <EOL> tl = ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) <EOL> settings . configure ( <EOL> DATABASES = dict ( default = dict ( ENGINE = db_engine , NAME = db_name ) ) , <EOL> SITE_ID = <NUM_LIT:1> , <EOL> TEMPLATE_LOADERS = tl , <EOL> MIDDLEWARE_CLASSES = ( <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) , <EOL> ROOT_URLCONF = '<STR_LIT>' , <EOL>", "answer": "INSTALLED_APPS = ["}, {"prompt": "<s> import logging <EOL> import time <EOL> from nymms . daemon import NymmsDaemon <EOL> from nymms . resources import Node <EOL> from nymms . scheduler . lock . SchedulerLock import NoOpLock <EOL> from nymms . schemas import Task <EOL> logger = logging . getLogger ( __name__ ) <EOL> class Scheduler ( NymmsDaemon ) : <EOL> task_id_template = \"<STR_LIT>\" <EOL> def __init__ ( self , node_backend , lock = None ) : <EOL> self . _node_backend = node_backend <EOL> if not lock : <EOL> lock = NoOpLock ( ) <EOL> self . _lock = lock <EOL> super ( Scheduler , self ) . __init__ ( ) <EOL> def get_tasks ( self ) : <EOL> tasks = { } <EOL> self . _node_backend . load_nodes ( ) <EOL> nodes = Node . registry <EOL> for node_name , node in nodes . iteritems ( ) : <EOL> tasks [ node_name ] = node . monitors <EOL> return tasks <EOL> def submit_task ( self , task , ** kwargs ) : <EOL> raise NotImplementedError <EOL> def run ( self , ** kwargs ) : <EOL> interval = kwargs . get ( '<STR_LIT>' ) <EOL> while True : <EOL> start = time . time ( ) <EOL> if self . _lock . acquire ( ) : <EOL> self . run_once ( ** kwargs ) <EOL> run_time = time . time ( ) - start <EOL> logger . info ( \"<STR_LIT>\" , run_time ) <EOL> sleep_time = interval - max ( run_time , <NUM_LIT:0> ) <EOL> logger . info ( \"<STR_LIT>\" , sleep_time ) <EOL> else : <EOL> sleep_time = <NUM_LIT:10> <EOL> logger . info ( \"<STR_LIT>\" , <EOL> sleep_time ) <EOL> time . sleep ( sleep_time ) <EOL> def run_once ( self , ** kwargs ) : <EOL> tasks = self . get_tasks ( ) <EOL> while True : <EOL> working_index = tasks . keys ( ) <EOL> if not working_index : <EOL> break <EOL> for node in working_index : <EOL> try : <EOL> task_context = tasks [ node ] . pop ( ) <EOL> task_id = self . task_id_template . format ( ** task_context ) <EOL> task = Task ( { <EOL> '<STR_LIT:id>' : task_id , <EOL> '<STR_LIT>' : task_context } ) <EOL> except IndexError : <EOL> del ( tasks [ node ] ) <EOL> continue <EOL>", "answer": "self . submit_task ( task , ** kwargs ) "}, {"prompt": "<s> import fixtures <EOL> from authomatic . providers import openid <EOL> conf = fixtures . get_configuration ( '<STR_LIT>' ) <EOL> OPENID_IDENTIFIER = '<STR_LIT>' . format ( conf . user_username ) <EOL> CONFIG = { <EOL> '<STR_LIT>' : OPENID_IDENTIFIER , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' : '<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . NodeBases import ChildrenHavingMixin , ExpressionChildrenHavingBase <EOL> class ExpressionOutlineBody ( ExpressionChildrenHavingBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> kind = \"<STR_LIT>\" <EOL> named_children = ( <EOL> \"<STR_LIT:body>\" , <EOL> ) <EOL> def __init__ ( self , provider , name , source_ref , body = None ) : <EOL>", "answer": "assert name != \"<STR_LIT>\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> import os . path <EOL> from compass . utils import setting_wrapper as setting <EOL> class FileFilter ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __repr__ ( self ) : <EOL> return self . __class__ . __name__ <EOL> def filter ( self , pathname ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( str ( self ) ) <EOL> class CompositeFileFilter ( FileFilter ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , filters ) : <EOL> self . filters_ = filters <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % self . filters_ <EOL> def append_filter ( self , file_filter ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . filters_ . append ( file_filter ) <EOL> def filter ( self , pathname ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for file_filter in self . filters_ : <EOL> if not file_filter . filter ( pathname ) : <EOL> return False <EOL> return True <EOL> class FilterFileExist ( FileFilter ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def filter ( self , pathname ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> file_exist = os . path . isfile ( pathname ) <EOL> if not file_exist : <EOL> logging . debug ( \"<STR_LIT>\" , pathname ) <EOL> return file_exist <EOL> def get_file_filter ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> composite_filter = CompositeFileFilter ( [ FilterFileExist ( ) ] ) <EOL> return composite_filter <EOL> class FileReader ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , pathname , log_history ) : <EOL> self . pathname_ = pathname <EOL> self . log_history_ = log_history <EOL> def __repr__ ( self ) : <EOL> return ( <EOL> '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , self . pathname_ , <EOL> self . log_history_ <EOL> ) <EOL> ) <EOL> def readline ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> old_position = self . log_history_ [ '<STR_LIT>' ] <EOL> position = self . log_history_ [ '<STR_LIT>' ] <EOL> partial_line = self . log_history_ [ '<STR_LIT>' ] <EOL> try : <EOL> with open ( self . pathname_ ) as logfile : <EOL> logfile . seek ( position ) <EOL> while True : <EOL> line = logfile . readline ( ) <EOL> partial_line += line <EOL> position = logfile . tell ( ) <EOL> if position > self . log_history_ [ '<STR_LIT>' ] : <EOL> self . log_history_ [ '<STR_LIT>' ] = position <EOL> if partial_line . endswith ( '<STR_LIT:\\n>' ) : <EOL> self . log_history_ [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> yield partial_line <EOL> partial_line = self . log_history_ [ '<STR_LIT>' ] <EOL> else : <EOL> self . log_history_ [ '<STR_LIT>' ] = partial_line <EOL> break <EOL> if partial_line : <EOL> yield partial_line <EOL> except Exception as error : <EOL> logging . error ( '<STR_LIT>' , self . pathname_ ) <EOL> raise error <EOL> logging . debug ( <EOL> '<STR_LIT>' , <EOL> self . pathname_ , position - old_position , position <EOL> ) <EOL> class FileReaderFactory ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , logdir ) : <EOL> self . logdir_ = logdir <EOL> self . filefilter_ = get_file_filter ( ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL>", "answer": "self . __class__ . __name__ , self . logdir_ , self . filefilter_ )"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import sklearn . metrics . cluster . supervised as supervised <EOL> from math import log <EOL> import CGAT . Experiment as E <EOL> import numpy as np <EOL> import pandas as pd <EOL> import itertools <EOL> import os <EOL> import sys <EOL> import math <EOL> from rpy2 . robjects import pandas2ri <EOL> from rpy2 . robjects . packages import importr <EOL> from rpy2 . robjects import r as R <EOL> import rpy2 . robjects as ro <EOL> import random <EOL> import cmetrics as c2m <EOL> def get_r_path ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return os . path . dirname ( __file__ ) <EOL> def get_label_map ( labels ) : <EOL> '''<STR_LIT>''' <EOL> label_set = set ( ) <EOL> map_dict = { } <EOL> for val in labels : <EOL> label_set . update ( val ) <EOL> for lab , integer in enumerate ( label_set ) : <EOL> map_dict [ integer ] = lab <EOL> return map_dict <EOL> def make_mapped_matrix ( map_dict , input_frame ) : <EOL> '''<STR_LIT>''' <EOL> frame_index = input_frame . index . tolist ( ) <EOL> nindex = len ( frame_index ) <EOL> ncols = len ( input_frame . columns ) <EOL> integer_matrix = np . ndarray ( ( nindex , ncols ) , <EOL> dtype = np . int32 ) <EOL> E . info ( \"<STR_LIT>\" ) <EOL> matrix_idx = [ h for h , g in enumerate ( frame_index ) ] <EOL> for idx in matrix_idx : <EOL> for col in range ( ncols ) : <EOL> mod = input_frame . iloc [ idx ] [ col + <NUM_LIT:1> ] <EOL> integer_matrix [ idx ] [ col ] = map_dict [ mod ] <EOL> return integer_matrix <EOL> def randIndexes ( clustering_results ) : <EOL> '''<STR_LIT>''' <EOL> cluster_labels = clustering_results . values <EOL> map_dict = get_label_map ( cluster_labels ) <EOL> gene_map = { } <EOL> for r , gene in enumerate ( clustering_results . index ) : <EOL> gene_map [ gene ] = r <EOL> E . info ( \"<STR_LIT>\" ) <EOL> integer_matrix = make_mapped_matrix ( map_dict , clustering_results ) <EOL> E . info ( \"<STR_LIT>\" ) <EOL> cy_rand = c2m . consensus_metrics ( integer_matrix ) <EOL> E . info ( \"<STR_LIT>\" ) <EOL> return cy_rand <EOL> def unravel_arrays ( metric_array ) : <EOL> '''<STR_LIT>''' <EOL> dim = metric_array . shape [ <NUM_LIT:0> ] <EOL> flat_array = [ ] <EOL> for indx in itertools . combinations ( range ( <NUM_LIT:0> , dim ) , r = <NUM_LIT:2> ) : <EOL> if indx [ <NUM_LIT:0> ] != indx [ <NUM_LIT:1> ] : <EOL> flat_array . append ( metric_array [ indx [ <NUM_LIT:1> ] , indx [ <NUM_LIT:0> ] ] ) <EOL> else : <EOL> pass <EOL> return flat_array <EOL> def mutualInformation ( cluster1 , cluster2 ) : <EOL> '''<STR_LIT>''' <EOL> cont = contingency ( cluster1 , cluster2 ) <EOL> cont_sum = np . sum ( cont ) <EOL> pi = np . sum ( cont , axis = <NUM_LIT:1> ) <EOL> pj = np . sum ( cont , axis = <NUM_LIT:0> ) <EOL> outer = np . outer ( pi , pj ) <EOL> nnz = cont != <NUM_LIT:0> <EOL> cont_nm = cont [ nnz ] <EOL> log_cont_nm = np . log ( cont_nm ) <EOL> cont_nm /= cont_sum <EOL> log_outer = - np . log ( outer [ nnz ] ) + log ( pi . sum ( ) ) + log ( pj . sum ( ) ) <EOL> mi = ( cont_nm * ( log_cont_nm - log ( cont_sum ) ) + ( cont_nm * log_outer ) ) <EOL> return mi . sum ( ) <EOL> def contingency ( cluster1 , cluster2 ) : <EOL> '''<STR_LIT>''' <EOL> cont = pd . DataFrame ( columns = cluster1 . keys ( ) , index = cluster2 . keys ( ) ) <EOL> cont = cont . fillna ( <NUM_LIT:0.0> ) <EOL> for x in itertools . product ( cluster1 . keys ( ) , cluster2 . keys ( ) ) : <EOL> set1 = cluster1 [ x [ <NUM_LIT:0> ] ] <EOL> set2 = cluster2 [ x [ <NUM_LIT:1> ] ] <EOL> intersect = len ( set1 . intersection ( set2 ) ) <EOL> cont [ x [ <NUM_LIT:0> ] ] [ x [ <NUM_LIT:1> ] ] = intersect <EOL> cont = cont . as_matrix ( ) <EOL> return cont <EOL> def entropy ( cluster_labels ) : <EOL> '''<STR_LIT>''' <EOL> if len ( cluster_labels ) == <NUM_LIT:0> : <EOL> return <NUM_LIT:1.0> <EOL> else : <EOL> pass <EOL> cluster_prob = [ len ( cluster_labels [ x ] ) for x in cluster_labels . keys ( ) ] <EOL> pi = np . array ( cluster_prob ) . astype ( np . float ) <EOL> pi = pi [ pi > <NUM_LIT:0> ] <EOL> pi_sum = np . sum ( pi ) <EOL> entropy = - np . sum ( ( pi / pi_sum ) * ( np . log ( pi ) - log ( pi_sum ) ) ) <EOL> return entropy <EOL> def adjustedMutualInformation ( cluster1 , cluster2 ) : <EOL> '''<STR_LIT>''' <EOL> cont = contingency ( cluster1 , cluster2 ) <EOL> mi = mutualInformation ( cluster1 , cluster2 ) <EOL> sample_size = float ( sum ( [ len ( cluster1 [ x ] ) for x in cluster1 . keys ( ) ] ) ) <EOL> emi = supervised . expected_mutual_information ( cont , sample_size ) <EOL> h_clust1 , h_clust2 = entropy ( cluster1 ) , entropy ( cluster2 ) <EOL> if abs ( h_clust1 ) == <NUM_LIT:0.0> : <EOL> h_clust1 = <NUM_LIT:0.0> <EOL> else : <EOL> pass <EOL> if abs ( h_clust2 ) == <NUM_LIT:0.0> : <EOL> h_clust2 = <NUM_LIT:0.0> <EOL> else : <EOL> pass <EOL> ami = ( mi - emi ) / ( max ( h_clust1 , h_clust2 ) - emi ) <EOL> if np . isnan ( ami ) : <EOL> ami = np . nan_to_num ( ami ) <EOL> else : <EOL> pass <EOL> return ami <EOL> def deseqNormalize ( infile , <EOL> time_points , <EOL> reps , <EOL> conditions = None ) : <EOL> '''<STR_LIT>''' <EOL> pandas2ri . activate ( ) <EOL> reps = reps <EOL> R ( '''<STR_LIT>''' ) <EOL> E . info ( \"<STR_LIT>\" ) <EOL> if infile . split ( \"<STR_LIT:.>\" ) [ - <NUM_LIT:1> ] == \"<STR_LIT>\" : <EOL> comp = \"<STR_LIT>\" <EOL> else : <EOL> comp = None <EOL> data_frame = pd . read_table ( infile , <EOL> index_col = <NUM_LIT:0> , <EOL> header = <NUM_LIT:0> , <EOL> sep = \"<STR_LIT:\\t>\" , <EOL> compression = comp ) <EOL> pandas2ri . activate ( ) <EOL> rdf = pandas2ri . py2ri ( data_frame ) <EOL> if not conditions : <EOL> time_rep_comb = [ x for x in itertools . product ( time_points , reps ) ] <EOL> time_cond = ro . StrVector ( [ x [ <NUM_LIT:0> ] for x in time_rep_comb ] ) <EOL> rep_cond = ro . StrVector ( [ x [ <NUM_LIT:1> ] for x in time_rep_comb ] ) <EOL> R . assign ( '<STR_LIT>' , rdf ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % ( time_cond . r_repr ( ) , <EOL> rep_cond . r_repr ( ) ) ) <EOL> elif conditions : <EOL> design_dict = { } <EOL> for x in data_frame . columns . values : <EOL> sample_dict = { } <EOL> sample_dict [ '<STR_LIT>' ] = str ( x ) . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:0> ] <EOL> sample_dict [ '<STR_LIT>' ] = int ( str ( x ) . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:1> ] ) <EOL> sample_dict [ '<STR_LIT>' ] = str ( x ) . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:2> ] <EOL> design_dict [ x ] = sample_dict <EOL> design_frame = pd . DataFrame ( design_dict ) <EOL> design_frame = design_frame . T <EOL> des_cond = design_frame [ '<STR_LIT>' ] . values . tolist ( ) <EOL> des_time = design_frame [ '<STR_LIT>' ] . values . tolist ( ) <EOL> des_reps = design_frame [ '<STR_LIT>' ] . values . tolist ( ) <EOL> cond_cond = ro . StrVector ( [ x for x in des_cond ] ) <EOL> time_cond = ro . StrVector ( [ x for x in des_time ] ) <EOL> rep_cond = ro . StrVector ( [ x for x in des_reps ] ) <EOL> R . assign ( '<STR_LIT>' , rdf ) <EOL> R . assign ( '<STR_LIT>' , design_frame ) <EOL> E . info ( \"<STR_LIT>\" ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> E . info ( \"<STR_LIT>\" ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' % rep_cond . r_repr ( ) ) <EOL> R ( '''<STR_LIT>''' % time_cond . r_repr ( ) ) <EOL> if conditions : <EOL> R ( '''<STR_LIT>''' % cond_cond . r_repr ( ) ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) <EOL> else : <EOL> R ( '''<STR_LIT>''' ) <EOL> data_file = pandas2ri . ri2py ( R [ \"<STR_LIT>\" ] ) <EOL> return data_file <EOL> def avTimeExpression ( infile ) : <EOL> '''<STR_LIT>''' <EOL> if infile . split ( \"<STR_LIT:.>\" ) [ - <NUM_LIT:1> ] == \"<STR_LIT>\" : <EOL> comp = \"<STR_LIT>\" <EOL> else : <EOL> comp = None <EOL> df = pd . read_table ( infile , sep = \"<STR_LIT:\\t>\" , <EOL> header = <NUM_LIT:0> , index_col = <NUM_LIT:0> , <EOL> compression = comp ) <EOL> df_groups = df . groupby ( by = '<STR_LIT>' ) <EOL> data_frame = pd . DataFrame ( index = df . columns , <EOL> columns = None ) <EOL> for names , groups in df_groups : <EOL> _df = groups . drop ( [ '<STR_LIT>' , '<STR_LIT>' ] , axis = <NUM_LIT:1> ) <EOL> _df = _df . apply ( np . mean , axis = <NUM_LIT:0> ) <EOL> data_frame [ names ] = _df <EOL> try : <EOL> data_frame . drop ( [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> inplace = True , <EOL> axis = <NUM_LIT:0> ) <EOL> except KeyError : <EOL> pass <EOL> return data_frame <EOL> def covarFilter ( infile , <EOL> time_points , <EOL> replicates , <EOL> quantile ) : <EOL> '''<STR_LIT>''' <EOL> time_points . sort ( ) <EOL> time_rep_comb = [ x for x in itertools . product ( time_points , replicates ) ] <EOL> time_cond = ro . StrVector ( [ x [ <NUM_LIT:0> ] for x in time_rep_comb ] ) <EOL> rep_cond = ro . StrVector ( [ x [ <NUM_LIT:1> ] for x in time_rep_comb ] ) <EOL> df = pd . read_table ( infile , sep = \"<STR_LIT:\\t>\" , header = <NUM_LIT:0> , index_col = <NUM_LIT:0> ) <EOL> df . drop ( [ '<STR_LIT>' ] , inplace = True , axis = <NUM_LIT:1> ) <EOL> df . drop ( [ '<STR_LIT>' ] , inplace = True , axis = <NUM_LIT:1> ) <EOL> df = df . fillna ( <NUM_LIT:0.0> ) <EOL> pandas2ri . activate ( ) <EOL> R . assign ( '<STR_LIT>' , pandas2ri . py2ri ( df ) ) <EOL> E . info ( \"<STR_LIT>\" ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' % time_cond . r_repr ( ) ) <EOL> R ( '''<STR_LIT>''' % rep_cond . r_repr ( ) ) <EOL> E . info ( \"<STR_LIT>\" ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> E . info ( \"<STR_LIT>\" ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) <EOL> filtered_frame = pandas2ri . ri2py ( R [ \"<STR_LIT>\" ] ) . T <EOL> return filtered_frame <EOL> def clusterPCA ( infile , <EOL> cluster_file , <EOL> image_dir ) : <EOL> '''<STR_LIT>''' <EOL> header = cluster_file . split ( \"<STR_LIT:/>\" ) [ - <NUM_LIT:1> ] . split ( \"<STR_LIT:->\" ) [ <NUM_LIT:0> ] <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' % os . path . join ( get_r_path ( ) , \"<STR_LIT>\" ) ) <EOL> R ( '''<STR_LIT>''' % os . path . join ( get_r_path ( ) , \"<STR_LIT>\" ) ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> eigen_frame = pandas2ri . ri2py ( R [ \"<STR_LIT>\" ] ) <EOL> eigen_frame . index = eigen_frame [ '<STR_LIT>' ] <EOL> eigen_frame . drop ( [ '<STR_LIT>' ] , inplace = True , axis = <NUM_LIT:1> ) <EOL> return eigen_frame <EOL> def conditionDESeq2 ( data_frame , header , alpha , res_dir ) : <EOL> '''<STR_LIT>''' <EOL> E . info ( \"<STR_LIT>\" % header ) <EOL> cols = data_frame . columns <EOL> pandas2ri . activate ( ) <EOL> counts = pandas2ri . py2ri ( data_frame ) <EOL> des_times = ro . IntVector ( [ x . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:1> ] for x in cols ] ) <EOL> des_reps = ro . StrVector ( [ x . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:2> ] for x in cols ] ) <EOL> des_cond = ro . StrVector ( [ x . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:0> ] for x in cols ] ) <EOL> genes = ro . StrVector ( [ x for x in data_frame . index ] ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' % des_times . r_repr ( ) ) <EOL> R ( '''<STR_LIT>''' % des_reps . r_repr ( ) ) <EOL> R ( '''<STR_LIT>''' % des_cond . r_repr ( ) ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' % counts . r_repr ( ) ) <EOL> R ( '''<STR_LIT>''' % genes . r_repr ( ) ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' % ( res_dir , <EOL> header ) ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' % ( res_dir , <EOL> header ) ) <EOL> R ( '''<STR_LIT>''' % alpha ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> df = pandas2ri . ri2py ( R [ '<STR_LIT>' ] ) <EOL> return df <EOL> def timepointDESeq2 ( data_frame , header , alpha , res_dir ) : <EOL> '''<STR_LIT>''' <EOL> E . info ( \"<STR_LIT>\" % header ) <EOL> cols = data_frame . columns <EOL> pandas2ri . activate ( ) <EOL> counts = pandas2ri . py2ri ( data_frame ) <EOL> des_times = ro . IntVector ( [ x . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:1> ] for x in cols ] ) <EOL> des_reps = ro . StrVector ( [ x . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:2> ] for x in cols ] ) <EOL> genes = ro . StrVector ( [ x for x in data_frame . index ] ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' % des_times . r_repr ( ) ) <EOL> R ( '''<STR_LIT>''' % des_reps . r_repr ( ) ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' % counts . r_repr ( ) ) <EOL> R ( '''<STR_LIT>''' % genes . r_repr ( ) ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' % ( res_dir , <EOL> header ) ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' % ( res_dir , <EOL> header ) ) <EOL> R ( '''<STR_LIT>''' % alpha ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> df = pandas2ri . ri2py ( R [ '<STR_LIT>' ] ) <EOL> return df <EOL> def genSigGenes ( file_list , alpha , out_dir ) : <EOL> '''<STR_LIT>''' <EOL> alpha = float ( alpha ) <EOL> deg_dict = { } <EOL> for infle in file_list : <EOL> if infle . split ( \"<STR_LIT:/>\" ) [ <NUM_LIT:0> ] . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:0> ] == \"<STR_LIT>\" : <EOL> header = infle . split ( \"<STR_LIT:/>\" ) [ <NUM_LIT:1> ] . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:1> ] <EOL> header = header . rstrip ( \"<STR_LIT>\" ) <EOL> header = \"<STR_LIT:%s>\" % header <EOL> elif infle . split ( \"<STR_LIT:/>\" ) [ <NUM_LIT:0> ] . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:0> ] == \"<STR_LIT>\" : <EOL> header = infle . split ( \"<STR_LIT:/>\" ) [ <NUM_LIT:1> ] . split ( \"<STR_LIT:->\" ) [ <NUM_LIT:0> ] <EOL> header = \"<STR_LIT>\" % ( header . split ( \"<STR_LIT:_>\" ) [ <NUM_LIT:0> ] , <EOL> header . split ( \"<STR_LIT:_>\" ) [ <NUM_LIT:2> ] ) <EOL> in_df = pd . read_table ( infle , sep = \"<STR_LIT:\\t>\" , header = <NUM_LIT:0> , index_col = <NUM_LIT:0> ) <EOL> sig_genes = in_df [ in_df [ '<STR_LIT>' ] <= alpha ] <EOL> deg_dict [ header ] = sig_genes . index . tolist ( ) <EOL> if file_list [ <NUM_LIT:0> ] . split ( \"<STR_LIT:/>\" ) [ <NUM_LIT:0> ] . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:0> ] == \"<STR_LIT>\" : <EOL> condition = file_list [ <NUM_LIT:0> ] . split ( \"<STR_LIT:/>\" ) [ <NUM_LIT:1> ] . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:0> ] <EOL> condition = \"<STR_LIT>\" % condition <EOL> elif file_list [ <NUM_LIT:0> ] . split ( \"<STR_LIT:/>\" ) [ <NUM_LIT:0> ] . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:0> ] == \"<STR_LIT>\" : <EOL> condition = file_list [ <NUM_LIT:0> ] . split ( \"<STR_LIT:/>\" ) [ <NUM_LIT:1> ] . split ( \"<STR_LIT:_>\" ) [ <NUM_LIT:0> ] <EOL> condition = \"<STR_LIT>\" % condition <EOL> drawVennDiagram ( deg_dict , condition , out_dir ) <EOL> def drawVennDiagram ( deg_dict , header , out_dir ) : <EOL> '''<STR_LIT>''' <EOL> keys = deg_dict . keys ( ) <EOL> try : <EOL> keys = sorted ( keys , key = lambda x : int ( x . split ( \"<STR_LIT:_>\" ) [ <NUM_LIT:1> ] . rstrip ( \"<STR_LIT>\" ) ) ) <EOL> except IndexError : <EOL> pass <EOL> venn_size = len ( keys ) <EOL> R ( '''<STR_LIT>''' ) <EOL> n1 = set ( deg_dict [ keys [ <NUM_LIT:0> ] ] ) <EOL> n2 = set ( deg_dict [ keys [ <NUM_LIT:1> ] ] ) <EOL> area1 = len ( n1 ) <EOL> area2 = len ( n2 ) <EOL> n12 = len ( n1 . intersection ( n2 ) ) <EOL> if venn_size == <NUM_LIT:3> : <EOL> n3 = set ( deg_dict [ keys [ <NUM_LIT:2> ] ] ) <EOL> area3 = len ( n3 ) <EOL> n13 = len ( n1 . intersection ( n3 ) ) <EOL> n23 = len ( n2 . intersection ( n3 ) ) <EOL> n123 = len ( ( n1 . intersection ( n2 ) ) . intersection ( n3 ) ) <EOL> cat1 , cat2 , cat3 = keys <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' ) <EOL> elif venn_size == <NUM_LIT:4> : <EOL> n3 = set ( deg_dict [ keys [ <NUM_LIT:2> ] ] ) <EOL> area3 = len ( n3 ) <EOL> n13 = len ( n1 . intersection ( n3 ) ) <EOL> n23 = len ( n2 . intersection ( n3 ) ) <EOL> n123 = len ( ( n1 . intersection ( n2 ) ) . intersection ( n3 ) ) <EOL> n4 = set ( deg_dict [ keys [ <NUM_LIT:3> ] ] ) <EOL> area4 = len ( n4 ) <EOL> n14 = len ( n1 . intersection ( n4 ) ) <EOL> n24 = len ( n2 . intersection ( n4 ) ) <EOL> n34 = len ( n3 . intersection ( n4 ) ) <EOL> n124 = len ( ( n1 . intersection ( n2 ) ) . intersection ( n4 ) ) <EOL> n134 = len ( ( n1 . intersection ( n3 ) ) . intersection ( n4 ) ) <EOL> n234 = len ( ( n2 . intersection ( n3 ) ) . intersection ( n4 ) ) <EOL> n1234 = len ( ( ( n1 . intersection ( n2 ) ) . intersection ( n3 ) ) . intersection ( n4 ) ) <EOL> cat1 , cat2 , cat3 , cat4 = keys <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' ) <EOL> elif venn_size == <NUM_LIT:5> : <EOL> n3 = set ( deg_dict [ keys [ <NUM_LIT:2> ] ] ) <EOL> area3 = len ( n3 ) <EOL> n13 = len ( n1 . intersection ( n3 ) ) <EOL> n23 = len ( n2 . intersection ( n3 ) ) <EOL> n123 = len ( ( n1 . intersection ( n2 ) ) . intersection ( n3 ) ) <EOL> n4 = set ( deg_dict [ keys [ <NUM_LIT:3> ] ] ) <EOL> area4 = len ( n4 ) <EOL> n14 = len ( n1 . intersection ( n4 ) ) <EOL> n24 = len ( n2 . intersection ( n4 ) ) <EOL> n34 = len ( n3 . intersection ( n4 ) ) <EOL> n124 = len ( ( n1 . intersection ( n2 ) ) . intersection ( n4 ) ) <EOL> n134 = len ( ( n1 . intersection ( n3 ) ) . intersection ( n4 ) ) <EOL> n234 = len ( ( n2 . intersection ( n3 ) ) . intersection ( n4 ) ) <EOL> n1234 = len ( ( ( n1 . intersection ( n2 ) ) . intersection ( n3 ) ) . intersection ( n4 ) ) <EOL> n5 = set ( deg_dict [ keys [ <NUM_LIT:4> ] ] ) <EOL> area5 = len ( n5 ) <EOL> n15 = len ( n1 . intersection ( n5 ) ) <EOL> n25 = len ( n2 . intersection ( n5 ) ) <EOL> n35 = len ( n3 . intersection ( n5 ) ) <EOL> n45 = len ( n4 . intersection ( n5 ) ) <EOL> n125 = len ( ( n1 . intersection ( n2 ) ) . intersection ( n5 ) ) <EOL> n135 = len ( ( n1 . intersection ( n3 ) ) . intersection ( n5 ) ) <EOL> n145 = len ( ( n1 . intersection ( n4 ) ) . intersection ( n5 ) ) <EOL> n235 = len ( ( n2 . intersection ( n3 ) ) . intersection ( n5 ) ) <EOL> n245 = len ( ( n2 . intersection ( n4 ) ) . intersection ( n5 ) ) <EOL> n345 = len ( ( n3 . intersection ( n4 ) ) . intersection ( n5 ) ) <EOL> n1235 = len ( ( ( n1 . intersection ( n2 ) ) . intersection ( n3 ) ) . intersection ( n5 ) ) <EOL> n1245 = len ( ( ( n1 . intersection ( n2 ) ) . intersection ( n4 ) ) . intersection ( n5 ) ) <EOL> n1345 = len ( ( ( n1 . intersection ( n3 ) ) . intersection ( n4 ) ) . intersection ( n5 ) ) <EOL> n2345 = len ( ( ( n2 . intersection ( n3 ) ) . intersection ( n4 ) ) . intersection ( n5 ) ) <EOL> nstep = ( ( n1 . intersection ( n2 ) ) . intersection ( n3 ) ) <EOL> n12345 = len ( ( nstep . intersection ( n4 ) ) . intersection ( n5 ) ) <EOL> cat1 , cat2 , cat3 , cat4 , cat5 = keys <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' ) <EOL> elif venn_size > <NUM_LIT:5> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def maSigPro ( infile , <EOL> order_terms = <NUM_LIT:1> , <EOL> fdr = <NUM_LIT> , <EOL> adjust = \"<STR_LIT>\" , <EOL> stepwise = \"<STR_LIT>\" , <EOL> include_p = <NUM_LIT> , <EOL> rsq = <NUM_LIT> , <EOL> var_group = \"<STR_LIT:all>\" ) : <EOL> '''<STR_LIT>''' <EOL> ref_gtf = str ( infile ) . split ( \"<STR_LIT:->\" ) [ <NUM_LIT:1> ] <EOL> data_frame = pd . read_table ( infile , sep = \"<STR_LIT:\\t>\" , index_col = <NUM_LIT:0> , header = <NUM_LIT:0> ) <EOL> design_dict = { } <EOL> for x in data_frame . index . values : <EOL> sample_dict = { } <EOL> condition = str ( x ) . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:0> ] <EOL> sample_dict [ condition ] = <NUM_LIT:1> <EOL> sample_dict [ '<STR_LIT>' ] = int ( str ( x ) . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:1> ] ) <EOL> sample_dict [ '<STR_LIT>' ] = str ( x ) . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:2> ] <EOL> design_dict [ x ] = sample_dict <EOL> design_frame = pd . DataFrame ( design_dict ) <EOL> design_frame = design_frame . T <EOL> cols = [ '<STR_LIT>' , '<STR_LIT>' , condition ] <EOL> design_frame = design_frame [ cols ] <EOL> design_file = \"<STR_LIT>\" % ( condition , ref_gtf ) <EOL> design_frame . to_csv ( design_file , sep = \"<STR_LIT:\\t>\" ) <EOL> data_file = \"<STR_LIT>\" % ( condition , ref_gtf ) <EOL> results_file = \"<STR_LIT>\" % ( condition , ref_gtf ) <EOL> masigpro_out = \"<STR_LIT>\" <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' ) <EOL> E . info ( \"<STR_LIT>\" ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' % locals ( ) ) <EOL> E . info ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % order_terms ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> E . info ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % fdr ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> p_file = \"<STR_LIT>\" % locals ( ) <EOL> coef_file = \"<STR_LIT>\" % ( condition , <EOL> ref_gtf ) <EOL> p_frame = pd . read_table ( p_file , sep = \"<STR_LIT:\\t>\" ) <EOL> coef_frame = pd . read_table ( coef_file , sep = \"<STR_LIT:\\t>\" ) <EOL> results_frame = pd . merge ( coef_frame , p_frame , <EOL> how = '<STR_LIT:right>' , <EOL> left_index = True , <EOL> right_index = True ) <EOL> results_frame . to_csv ( results_file , sep = \"<STR_LIT:\\t>\" ) <EOL> R ( '''<STR_LIT>''' % locals ( ) ) <EOL> diff_genes = pandas2ri . ri2py [ R'<STR_LIT>' ] <EOL> return diff_genes <EOL> def splitReplicates ( infile , <EOL> axis , <EOL> group_var , <EOL> outdir ) : <EOL> '''<STR_LIT>''' <EOL> if axis == \"<STR_LIT>\" : <EOL> axis = <NUM_LIT:1> <EOL> elif axis == \"<STR_LIT>\" : <EOL> axis = <NUM_LIT:0> <EOL> inf_prefix = infile . split ( \"<STR_LIT:/>\" ) [ <NUM_LIT:1> ] . split ( \"<STR_LIT:->\" ) <EOL> inf_prefix = inf_prefix [ <NUM_LIT:0> ] + \"<STR_LIT:->\" + inf_prefix [ <NUM_LIT:1> ] <EOL> df = pd . read_table ( infile , <EOL> sep = \"<STR_LIT:\\t>\" , <EOL> header = <NUM_LIT:0> , <EOL> index_col = <NUM_LIT:0> ) . T <EOL> rep_groups = df . groupby ( by = group_var , <EOL> axis = axis ) <EOL> for name , groups in rep_groups : <EOL> outfile = outdir + \"<STR_LIT:/>\" + inf_prefix + \"<STR_LIT>\" % name <EOL> _df = groups . T <EOL> _df . columns = _df . loc [ '<STR_LIT>' ] <EOL> _df . drop ( [ '<STR_LIT>' ] , axis = axis , inplace = True ) <EOL> _df . drop ( [ '<STR_LIT>' ] , axis = axis , inplace = True ) <EOL> _df . to_csv ( outfile , sep = \"<STR_LIT:\\t>\" , index_label = \"<STR_LIT>\" ) <EOL> def genResampleData ( data_frame , <EOL> multiple_index , <EOL> replicates , <EOL> sample_reps , <EOL> times , <EOL> condition , <EOL> ref_gtf , <EOL> out_dir , <EOL> seed ) : <EOL> '''<STR_LIT>''' <EOL> vst_long = data_frame . T <EOL> vst_long . index = multiple_index <EOL> reps_dict = { } <EOL> random . seed ( seed ) <EOL> for it in range ( <NUM_LIT:1> , replicates + <NUM_LIT:1> ) : <EOL> df = pd . DataFrame ( ) <EOL> df_dict = { } <EOL> for i in times : <EOL> k = str ( random . randint ( <NUM_LIT:1> , <EOL> len ( sample_reps ) ) ) <EOL> series = vst_long . loc [ str ( i ) , '<STR_LIT>' % k ] <EOL> df_dict [ str ( i ) ] = series <EOL> df = pd . DataFrame ( df_dict ) <EOL> cols = df . columns . tolist ( ) <EOL> cols = [ int ( x ) for x in cols ] <EOL> cols . sort ( ) <EOL> cols = [ str ( x ) for x in cols ] <EOL> df = df [ cols ] <EOL> reps_dict [ str ( it ) ] = df <EOL> table = \"<STR_LIT>\" % ( condition , <EOL> ref_gtf , <EOL> it ) <EOL> seg_file = \"<STR_LIT>\" % ( out_dir , table ) <EOL> df . to_csv ( seg_file , sep = \"<STR_LIT:\\t>\" ) <EOL> sys . stdout . write ( \"<STR_LIT>\" % replicates ) <EOL> def temporalCorrelate ( series1 , series2 ) : <EOL> '''<STR_LIT>''' <EOL> series1 = list ( series1 ) <EOL> series2 = list ( series2 ) <EOL> sum_prod = [ ] <EOL> sum_usq = [ ] <EOL> sum_vsq = [ ] <EOL> for i in range ( len ( series1 ) - <NUM_LIT:1> ) : <EOL> u = float ( series1 [ i + <NUM_LIT:1> ] ) - float ( series1 [ i ] ) <EOL> v = float ( series2 [ i + <NUM_LIT:1> ] ) - float ( series2 [ i ] ) <EOL> prod = u * v <EOL> sum_prod . append ( prod ) <EOL> sq_u = u ** <NUM_LIT:2> <EOL> sq_v = v ** <NUM_LIT:2> <EOL> sum_usq . append ( sq_u ) <EOL> sum_vsq . append ( sq_v ) <EOL> nume = sum ( sum_prod ) <EOL> denom = math . sqrt ( sum ( sum_usq ) ) * math . sqrt ( sum ( sum_vsq ) ) <EOL> if denom != <NUM_LIT:0> : <EOL> return ( nume / float ( denom ) ) <EOL> else : <EOL> return <NUM_LIT:0> <EOL> def crossCorrelate ( t , s , lag = <NUM_LIT:0> ) : <EOL> '''<STR_LIT>''' <EOL> t_mean = np . mean ( t ) <EOL> s_mean = np . mean ( s ) <EOL> t_std = np . std ( t ) <EOL> s_std = np . std ( s ) <EOL> len_t = len ( t ) <EOL> t_norm = [ ( ( x - t_mean ) / ( t_std * len_t ) ) for x in t ] <EOL> s_norm = [ ( ( y - s_mean ) / s_std ) for y in s ] <EOL> if lag == <NUM_LIT:0> : <EOL> xcorr = np . correlate ( t_norm , s_norm ) <EOL> elif lag != <NUM_LIT:0> : <EOL> xcorr = np . correlate ( t_norm , s_norm , mode = <NUM_LIT:2> ) [ len_t - <NUM_LIT:1> + lag ] <EOL> return xcorr <EOL> def adaptiveTune ( value , k ) : <EOL> '''<STR_LIT>''' <EOL> if k == <NUM_LIT:0> : <EOL> return <NUM_LIT:1.0> <EOL> else : <EOL> return ( <NUM_LIT:2> / ( <NUM_LIT:1> + math . exp ( k * abs ( value ) ) ) ) <EOL> def dtwWrapper ( data , rows , columns , k ) : <EOL> '''<STR_LIT>''' <EOL> DTW = importr ( \"<STR_LIT>\" ) <EOL> df_ = pd . DataFrame ( index = rows , <EOL> columns = columns ) <EOL> df_ = df_ . fillna ( <NUM_LIT:0.0> ) . astype ( np . float64 ) <EOL> pandas2ri . activate ( ) <EOL> for i in rows : <EOL> E . info ( \"<STR_LIT>\" % i ) <EOL> for j in columns : <EOL> series1 = data . loc [ i ] . values . tolist ( ) <EOL> series2 = data . loc [ j ] . values . tolist ( ) <EOL> DTW_value = ( R . dtw ( series1 , <EOL> series2 ) ) . rx ( '<STR_LIT>' ) [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] <EOL> cort_value = temporalCorrelate ( series1 , series2 ) <EOL> tuned_value = adaptiveTune ( cort_value , k ) <EOL> time_dist = DTW_value * tuned_value <EOL> df_ . loc [ i ] [ j ] = float ( time_dist ) <EOL> df_ [ j ] [ i ] = float ( time_dist ) <EOL> return df_ <EOL> def correlateDistanceMetric ( data , rows , columns , method , lag = <NUM_LIT:0> ) : <EOL> '''<STR_LIT>''' <EOL> df_ = pd . DataFrame ( index = rows , <EOL> columns = columns ) <EOL> df_ = df_ . fillna ( <NUM_LIT:0.0> ) <EOL> if method == \"<STR_LIT>\" : <EOL> for i in rows : <EOL> E . info ( \"<STR_LIT>\" % i ) <EOL> for j in columns : <EOL> series1 = data . loc [ i ] . values . tolist ( ) <EOL> series2 = data . loc [ j ] . values . tolist ( ) <EOL> corr = crossCorrelate ( series1 , series2 , lag = lag ) <EOL> df_ . loc [ i ] [ j ] = <NUM_LIT:1.0> - abs ( corr ) <EOL> df_ [ j ] [ i ] = <NUM_LIT:1.0> - abs ( corr ) <EOL> elif method == \"<STR_LIT>\" : <EOL> for i in rows : <EOL> E . info ( \"<STR_LIT>\" % i ) <EOL> for j in columns : <EOL> series1 = data . loc [ i ] . tolist ( ) <EOL> series2 = data . loc [ j ] . tolist ( ) <EOL> corr = temporalCorrelate ( series1 , series2 ) <EOL> df_ . loc [ i ] [ j ] = <NUM_LIT:1.0> - abs ( corr ) <EOL> df_ [ j ] [ i ] = <NUM_LIT:1.0> - abs ( corr ) <EOL> return df_ <EOL> def splitFiles ( infile , nchunks , out_dir ) : <EOL> '''<STR_LIT>''' <EOL> df = pd . read_table ( infile , sep = \"<STR_LIT:\\t>\" , header = <NUM_LIT:0> , index_col = <NUM_LIT:0> ) <EOL> total = len ( df . index . tolist ( ) ) <EOL> if total / nchunks < <NUM_LIT:100> : <EOL> step = <NUM_LIT:100> <EOL> E . warn ( \"<STR_LIT>\" ) <EOL> elif total / nchunks > <NUM_LIT> : <EOL> step = <NUM_LIT> <EOL> E . warn ( \"<STR_LIT>\" ) <EOL> else : <EOL> step = total / nchunks <EOL> E . info ( \"<STR_LIT>\" % step ) <EOL> file_pattern = infile . split ( \"<STR_LIT:/>\" ) [ <NUM_LIT:1> ] . rstrip ( \"<STR_LIT>\" ) <EOL> idx = <NUM_LIT:0> <EOL> for i in range ( step , total , step ) : <EOL> start = \"<STR_LIT:%s>\" % idx <EOL> end = \"<STR_LIT:%s>\" % i <EOL> file_name = \"<STR_LIT>\" % ( out_dir , <EOL> file_pattern , <EOL> start , <EOL> end ) <EOL> with open ( file_name , \"<STR_LIT:w>\" ) as file_handle : <EOL> file_handle . write ( file_name + \"<STR_LIT:\\n>\" ) <EOL> idx = i <EOL> start = \"<STR_LIT:%s>\" % idx <EOL> end = \"<STR_LIT:%s>\" % total <EOL> file_name = \"<STR_LIT>\" % ( out_dir , <EOL> file_pattern , <EOL> start , <EOL> end ) <EOL> with open ( file_name , \"<STR_LIT:w>\" ) as file_handle : <EOL> file_handle . write ( file_name + \"<STR_LIT:\\n>\" ) <EOL> def mergeFiles ( file_list , outfile ) : <EOL> '''<STR_LIT>''' <EOL> res_list = sorted ( file_list , <EOL> key = lambda x : int ( x . split ( \"<STR_LIT:/>\" ) [ - <NUM_LIT:1> ] . split ( \"<STR_LIT:->\" ) [ <NUM_LIT:3> ] . split ( \"<STR_LIT:_>\" ) [ <NUM_LIT:0> ] ) ) <EOL> full_frame = pd . read_table ( res_list [ <NUM_LIT:0> ] , sep = \"<STR_LIT:\\t>\" , index_col = <NUM_LIT:0> , header = <NUM_LIT:0> ) <EOL> res_list . remove ( res_list [ <NUM_LIT:0> ] ) <EOL> for fle in res_list : <EOL> df = pd . read_table ( fle , sep = \"<STR_LIT:\\t>\" , index_col = <NUM_LIT:0> , header = <NUM_LIT:0> ) <EOL> full_frame = pd . merge ( left = full_frame , <EOL> right = df , <EOL> how = '<STR_LIT>' , <EOL> left_index = True , <EOL> right_index = True ) <EOL> full_frame . to_csv ( outfile , sep = \"<STR_LIT:\\t>\" ) <EOL> def treeCutting ( infile , <EOL> expression_file , <EOL> cluster_file , <EOL> cluster_algorithm , <EOL> deepsplit = False ) : <EOL> '''<STR_LIT>''' <EOL> wgcna_out = \"<STR_LIT>\" <EOL> E . info ( \"<STR_LIT>\" ) <EOL> df = pd . read_table ( infile , sep = \"<STR_LIT:\\t>\" , <EOL> header = <NUM_LIT:0> , index_col = <NUM_LIT:0> ) <EOL> df = df . fillna ( <NUM_LIT:0.0> ) <EOL> genes = df . index <EOL> genes_r = ro . StrVector ( [ g for g in genes ] ) <EOL> pandas2ri . activate ( ) <EOL> rdf = pandas2ri . py2ri ( df ) <EOL> R . assign ( \"<STR_LIT>\" , rdf ) <EOL> R . assign ( \"<STR_LIT>\" , genes_r ) <EOL> R ( '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> E . info ( \"<STR_LIT>\" % cluster_algorithm ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> if deepsplit : <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) <EOL> else : <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' % locals ( ) ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' <EOL> '''<STR_LIT>''' ) <EOL> R ( '''<STR_LIT>''' ) <EOL> cluster_frame = pandas2ri . ri2py ( R [ \"<STR_LIT>\" ] ) <EOL> cluster_frame . columns = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> cluster_frame . index = cluster_frame [ '<STR_LIT>' ] <EOL> cluster_frame . drop ( [ '<STR_LIT>' ] , inplace = True , axis = <NUM_LIT:1> ) <EOL> return cluster_frame <EOL> def clusterAverage ( file_list ) : <EOL> '''<STR_LIT>''' <EOL> df_dict = { } <EOL> for fle in file_list : <EOL> f = fle . split ( \"<STR_LIT:/>\" ) [ - <NUM_LIT:1> ] <EOL> rep = f . split ( \"<STR_LIT:->\" ) [ <NUM_LIT:2> ] <EOL> _df = pd . read_table ( fle , sep = \"<STR_LIT:\\t>\" , <EOL> header = <NUM_LIT:0> , index_col = <NUM_LIT:0> ) <EOL> df_dict [ rep ] = _df <EOL> concat_df = pd . concat ( df_dict ) <EOL> group_df = concat_df . groupby ( level = <NUM_LIT:1> ) <EOL> agg_dict = { } <EOL> for names , groups in group_df : <EOL> agg_dict [ names ] = np . mean ( groups , axis = <NUM_LIT:0> ) <EOL> agg_df = pd . DataFrame ( agg_dict ) <EOL> return agg_df <EOL> def clusterAgreement ( infile ) : <EOL> '''<STR_LIT>''' <EOL> df = pd . read_table ( infile , sep = \"<STR_LIT:\\t>\" , header = <NUM_LIT:0> , index_col = <NUM_LIT:0> ) <EOL> genes = df . index . values <EOL> dmat = pd . DataFrame ( index = genes , <EOL>", "answer": "columns = genes )"}, {"prompt": "<s> import time <EOL> from gensim . models . word2vec import Word2Vec <EOL> from Utils . string_utils import clean_str <EOL> from Utils . file_utils import find_files <EOL> from analysis_pipeline import analyze , debug_analyze <EOL> from analysis_pipeline import build_synonym_filter , fact_case_sensitive_stop_word_filter , fact_stop_word_filter <EOL> from analysis_pipeline import fact_is_synonym_filter , white_space_tokenize , remove_punct_at_end_filter , lower_case_filter , remove_empty_tokens_filter <EOL> from Config . train_word2vec_model_config import TrainWord2VecModelConfig <EOL> import sys <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( sys . argv ) != <NUM_LIT:2> : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> config = TrainWord2VecModelConfig ( sys . argv [ <NUM_LIT:1> ] ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> syn_mapper = build_synonym_filter ( config . keywords_files , config . case_sensitive ) <EOL> if config . case_sensitive : <EOL> stop_filter = fact_case_sensitive_stop_word_filter ( config . stop_words_file ) <EOL> else : <EOL> stop_filter = fact_stop_word_filter ( config . stop_words_file ) <EOL> is_a_synonym_filter = fact_is_synonym_filter ( syn_mapper ) <EOL> analysis_chain = [ clean_str , <EOL>", "answer": "white_space_tokenize ,"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Tangible ( )"}, {"prompt": "<s> from django . conf import settings <EOL> try : <EOL> from django . conf . urls import patterns , url , include <EOL>", "answer": "except ImportError :"}, {"prompt": "<s> import sys , os <EOL> sys . path . append ( os . path . abspath ( '<STR_LIT>' ) ) <EOL> extensions = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> templates_path = [ '<STR_LIT>' ] <EOL> source_suffix = '<STR_LIT>' <EOL> master_doc = '<STR_LIT:index>' <EOL> project = u'<STR_LIT>' <EOL> copyright = u'<STR_LIT>' <EOL> version = '<STR_LIT>' <EOL> release = '<STR_LIT>' <EOL> exclude_patterns = [ '<STR_LIT>' ] <EOL>", "answer": "html_theme = '<STR_LIT>'"}, {"prompt": "<s> import pymongo <EOL> from bson . objectid import ObjectId <EOL> from flask import Flask <EOL> from flask . ext import admin <EOL> from wtforms import form , fields <EOL> from flask . ext . admin . form import Select2Widget <EOL> from flask . ext . admin . contrib . pymongo import ModelView , filters <EOL> from flask . ext . admin . model . fields import InlineFormField , InlineFieldList <EOL> app = Flask ( __name__ ) <EOL> app . config [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> conn = pymongo . Connection ( ) <EOL> db = conn . test <EOL> class InnerForm ( form . Form ) : <EOL> name = fields . TextField ( '<STR_LIT:Name>' ) <EOL> test = fields . TextField ( '<STR_LIT>' ) <EOL> class UserForm ( form . Form ) : <EOL> name = fields . TextField ( '<STR_LIT:Name>' ) <EOL> email = fields . TextField ( '<STR_LIT>' ) <EOL> password = fields . TextField ( '<STR_LIT>' ) <EOL> inner = InlineFormField ( InnerForm ) <EOL> form_list = InlineFieldList ( InlineFormField ( InnerForm ) ) <EOL> class UserView ( ModelView ) : <EOL> column_list = ( '<STR_LIT:name>' , '<STR_LIT:email>' , '<STR_LIT:password>' ) <EOL> column_sortable_list = ( '<STR_LIT:name>' , '<STR_LIT:email>' , '<STR_LIT:password>' ) <EOL> form = UserForm <EOL> class TweetForm ( form . Form ) : <EOL> name = fields . TextField ( '<STR_LIT:Name>' ) <EOL> user_id = fields . SelectField ( '<STR_LIT>' , widget = Select2Widget ( ) ) <EOL> text = fields . TextField ( '<STR_LIT>' ) <EOL> testie = fields . BooleanField ( '<STR_LIT>' ) <EOL> class TweetView ( ModelView ) : <EOL> column_list = ( '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT:text>' ) <EOL> column_sortable_list = ( '<STR_LIT:name>' , '<STR_LIT:text>' ) <EOL> column_filters = ( filters . FilterEqual ( '<STR_LIT:name>' , '<STR_LIT:Name>' ) , <EOL> filters . FilterNotEqual ( '<STR_LIT:name>' , '<STR_LIT:Name>' ) , <EOL> filters . FilterLike ( '<STR_LIT:name>' , '<STR_LIT:Name>' ) , <EOL> filters . FilterNotLike ( '<STR_LIT:name>' , '<STR_LIT:Name>' ) , <EOL> filters . BooleanEqualFilter ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> column_searchable_list = ( '<STR_LIT:name>' , '<STR_LIT:text>' ) <EOL> form = TweetForm <EOL> def get_list ( self , * args , ** kwargs ) : <EOL> count , data = super ( TweetView , self ) . get_list ( * args , ** kwargs ) <EOL> query = { '<STR_LIT>' : { '<STR_LIT>' : [ x [ '<STR_LIT>' ] for x in data ] } } <EOL> users = db . user . find ( query , fields = ( '<STR_LIT:name>' , ) ) <EOL> users_map = dict ( ( x [ '<STR_LIT>' ] , x [ '<STR_LIT:name>' ] ) for x in users ) <EOL> for item in data : <EOL> item [ '<STR_LIT>' ] = users_map . get ( item [ '<STR_LIT>' ] ) <EOL> return count , data <EOL>", "answer": "def _feed_user_choices ( self , form ) :"}, {"prompt": "<s> from datetime import datetime <EOL> from django . core . exceptions import ValidationError <EOL> from django . db import models <EOL> from django . test import TestCase <EOL> def validate_answer_to_universe ( value ) : <EOL> if value != <NUM_LIT> : <EOL>", "answer": "raise ValidationError ( '<STR_LIT>' , code = '<STR_LIT>' )"}, {"prompt": "<s> from boto . resultset import ResultSet <EOL>", "answer": "class AppCookieStickinessPolicy ( object ) :"}, {"prompt": "<s> import ctypes <EOL> import functools <EOL> from ctypes . wintypes import * <EOL> from windows . generated_def . winstructs import * <EOL> from windows . generated_def . windef import * <EOL> import windows . generated_def . winfuncs as winfuncs <EOL> from windows . generated_def . ntstatus import NtStatusException <EOL> from windows . dbgprint import dbgprint <EOL> class Kernel32Error ( WindowsError ) : <EOL> def __new__ ( cls , func_name ) : <EOL> win_error = ctypes . WinError ( ) <EOL> api_error = super ( Kernel32Error , cls ) . __new__ ( cls ) <EOL> api_error . api_name = func_name <EOL> api_error . winerror = win_error . winerror <EOL> api_error . strerror = win_error . strerror <EOL> api_error . args = ( func_name , win_error . winerror , win_error . strerror ) <EOL> return api_error <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" . format ( self . api_name , super ( Kernel32Error , self ) . __repr__ ( ) ) <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" . format ( self . api_name , super ( Kernel32Error , self ) . __str__ ( ) ) <EOL> class IphlpapiError ( Kernel32Error ) : <EOL> def __new__ ( cls , func_name , code , strerror = None ) : <EOL> win_error = ctypes . WinError ( code ) <EOL> api_error = super ( Kernel32Error , cls ) . __new__ ( cls ) <EOL> api_error . api_name = func_name <EOL> api_error . winerror = win_error . winerror <EOL> if strerror is not None : <EOL> api_error . strerror = strerror <EOL> else : <EOL> api_error . strerror = win_error . strerror <EOL> api_error . args = ( func_name , api_error . winerror , api_error . strerror ) <EOL> return api_error <EOL> def __init__ ( self , func_name , code , strerror = None ) : <EOL> pass <EOL> def no_error_check ( func_name , result , func , args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return args <EOL> def minus_one_error_check ( func_name , result , func , args ) : <EOL> if result == - <NUM_LIT:1> : <EOL> raise Kernel32Error ( func_name ) <EOL> return args <EOL> def kernel32_error_check ( func_name , result , func , args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not result : <EOL> raise Kernel32Error ( func_name ) <EOL> return args <EOL> def kernel32_zero_check ( func_name , result , func , args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if result : <EOL> raise Kernel32Error ( func_name ) <EOL> return args <EOL> def iphlpapi_error_check ( func_name , result , func , args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if result : <EOL> raise IphlpapiError ( func_name , result ) <EOL> return args <EOL> def error_ntstatus ( func_name , result , func , args ) : <EOL> if result : <EOL> raise NtStatusException ( result & <NUM_LIT> ) <EOL> return args <EOL> class ExportNotFound ( AttributeError ) : <EOL> def __init__ ( self , func_name , api_name ) : <EOL> self . func_name = func_name <EOL> self . api_name = api_name <EOL> super ( ExportNotFound , self ) . __init__ ( \"<STR_LIT>\" . format ( func_name , api_name ) ) <EOL> class ApiProxy ( object ) : <EOL> APIDLL = None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , func_name , error_check = None ) : <EOL> self . func_name = func_name <EOL> if error_check is None : <EOL> error_check = self . default_error_check <EOL> self . error_check = functools . wraps ( error_check ) ( functools . partial ( error_check , func_name ) ) <EOL> self . _cprototyped = None <EOL> def __call__ ( self , python_proxy , ) : <EOL> prototype = getattr ( winfuncs , self . func_name + \"<STR_LIT>\" ) <EOL> params = getattr ( winfuncs , self . func_name + \"<STR_LIT>\" ) <EOL> python_proxy . prototype = prototype <EOL> python_proxy . params = params <EOL> python_proxy . errcheck = self . error_check <EOL> params_name = [ param [ <NUM_LIT:1> ] for param in params ] <EOL> if ( self . error_check . __doc__ ) : <EOL> doc = python_proxy . __doc__ <EOL> doc = doc if doc else \"<STR_LIT>\" <EOL> python_proxy . __doc__ = doc + \"<STR_LIT>\" + self . error_check . __doc__ <EOL> def generate_ctypes_function ( ) : <EOL> try : <EOL> c_prototyped = prototype ( ( self . func_name , getattr ( ctypes . windll , self . APIDLL ) ) , params ) <EOL> except ( AttributeError , WindowsError ) : <EOL> raise ExportNotFound ( self . func_name , self . APIDLL ) <EOL> c_prototyped . errcheck = self . error_check <EOL> self . _cprototyped = c_prototyped <EOL> def perform_call ( * args ) : <EOL> if len ( params_name ) != len ( args ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( \"<STR_LIT>\" . format ( params_name ) ) <EOL> print ( \"<STR_LIT>\" . format ( args ) ) <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> for param_name , param_value in zip ( params_name , args ) : <EOL> if param_value is NeededParameter : <EOL> raise TypeError ( \"<STR_LIT>\" . format ( self . func_name , param_name ) ) <EOL> if self . _cprototyped is None : <EOL> generate_ctypes_function ( ) <EOL> return self . _cprototyped ( * args ) <EOL> setattr ( python_proxy , \"<STR_LIT>\" , perform_call ) <EOL> setattr ( python_proxy , \"<STR_LIT>\" , generate_ctypes_function ) <EOL> return python_proxy <EOL> class Kernel32Proxy ( ApiProxy ) : <EOL> APIDLL = \"<STR_LIT>\" <EOL> default_error_check = staticmethod ( kernel32_error_check ) <EOL> class Advapi32Proxy ( ApiProxy ) : <EOL> APIDLL = \"<STR_LIT>\" <EOL> default_error_check = staticmethod ( kernel32_error_check ) <EOL> class IphlpapiProxy ( ApiProxy ) : <EOL> APIDLL = \"<STR_LIT>\" <EOL> default_error_check = staticmethod ( iphlpapi_error_check ) <EOL> class NtdllProxy ( ApiProxy ) : <EOL> APIDLL = \"<STR_LIT>\" <EOL> default_error_check = staticmethod ( kernel32_zero_check ) <EOL> class WinTrustProxy ( ApiProxy ) : <EOL> APIDLL = \"<STR_LIT>\" <EOL> default_error_check = staticmethod ( no_error_check ) <EOL> class Ole32Proxy ( ApiProxy ) : <EOL> APIDLL = \"<STR_LIT>\" <EOL> default_error_check = staticmethod ( no_error_check ) <EOL> class PsapiProxy ( ApiProxy ) : <EOL> APIDLL = \"<STR_LIT>\" <EOL> default_error_check = staticmethod ( kernel32_error_check ) <EOL> class User32Proxy ( ApiProxy ) : <EOL> APIDLL = \"<STR_LIT>\" <EOL> default_error_check = staticmethod ( kernel32_error_check ) <EOL> class VersionProxy ( ApiProxy ) : <EOL> APIDLL = \"<STR_LIT:version>\" <EOL> default_error_check = staticmethod ( kernel32_error_check ) <EOL> class OptionalExport ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , subdecorator ) : <EOL> self . subdecorator = subdecorator <EOL> def __call__ ( self , f ) : <EOL> try : <EOL> x = self . subdecorator ( f ) <EOL> x . force_resolution ( ) <EOL> return x <EOL> except ExportNotFound as e : <EOL> dbgprint ( \"<STR_LIT>\" . format ( e = e ) , \"<STR_LIT>\" ) <EOL> return None <EOL> class TransparentApiProxy ( object ) : <EOL> def __init__ ( self , DLLNAME , func_name , error_check ) : <EOL> self . dll_name = DLLNAME <EOL> self . func_name = func_name <EOL> self . error_check = error_check <EOL> self . _ctypes_function = None <EOL> self . prototype = getattr ( winfuncs , func_name + \"<STR_LIT>\" ) <EOL> self . params = getattr ( winfuncs , func_name + \"<STR_LIT>\" ) <EOL> self . args = getattr ( winfuncs , func_name + \"<STR_LIT>\" ) <EOL> def __call__ ( self , * args , ** kwargs ) : <EOL> if self . _ctypes_function is None : <EOL> self . force_resolution ( ) <EOL> return self . _ctypes_function ( * args , ** kwargs ) <EOL> def force_resolution ( self ) : <EOL> try : <EOL> c_prototyped = self . prototype ( ( self . func_name , getattr ( ctypes . windll , self . dll_name ) ) , self . args ) <EOL> except AttributeError : <EOL> raise ExportNotFound ( self . func_name , self . dll_name ) <EOL> c_prototyped . errcheck = functools . wraps ( self . error_check ) ( functools . partial ( self . error_check , self . func_name ) ) <EOL> self . _ctypes_function = c_prototyped <EOL> TransparentKernel32Proxy = lambda func_name , error_check = kernel32_error_check : TransparentApiProxy ( \"<STR_LIT>\" , func_name , error_check ) <EOL> TransparentUser32Proxy = lambda func_name , error_check = kernel32_error_check : TransparentApiProxy ( \"<STR_LIT>\" , func_name , error_check ) <EOL> TransparentAdvapi32Proxy = lambda func_name , error_check = kernel32_error_check : TransparentApiProxy ( \"<STR_LIT>\" , func_name , error_check ) <EOL> TransparentIphlpapiProxy = lambda func_name , error_check = iphlpapi_error_check : TransparentApiProxy ( \"<STR_LIT>\" , func_name , error_check ) <EOL> class NeededParameterType ( object ) : <EOL> _inst = None <EOL> def __new__ ( cls ) : <EOL> if cls . _inst is None : <EOL> cls . _inst = super ( NeededParameterType , cls ) . __new__ ( cls ) <EOL> return cls . _inst <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" <EOL> NeededParameter = NeededParameterType ( ) <EOL> ExitProcess = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> TerminateProcess = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> CloseHandle = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetProcAddress = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> LoadLibraryA = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> LoadLibraryW = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetLastError = TransparentKernel32Proxy ( \"<STR_LIT>\" , no_error_check ) <EOL> GetCurrentProcess = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetCurrentProcessorNumber = TransparentKernel32Proxy ( \"<STR_LIT>\" , no_error_check ) <EOL> GetCurrentThread = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> AllocConsole = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> FreeConsole = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetStdHandle = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> SetStdHandle = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetCurrentThreadId = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> TerminateThread = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> ExitThread = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> SuspendThread = TransparentKernel32Proxy ( \"<STR_LIT>\" , minus_one_error_check ) <EOL> ResumeThread = TransparentKernel32Proxy ( \"<STR_LIT>\" , minus_one_error_check ) <EOL> GetThreadId = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> VirtualQueryEx = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetExitCodeThread = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetExitCodeProcess = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetProcessId = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> lstrcmpA = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> lstrcmpW = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetVersionExA = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetVersionExW = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetComputerNameA = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetComputerNameW = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> Wow64DisableWow64FsRedirection = OptionalExport ( TransparentKernel32Proxy ) ( \"<STR_LIT>\" ) <EOL> Wow64RevertWow64FsRedirection = OptionalExport ( TransparentKernel32Proxy ) ( \"<STR_LIT>\" ) <EOL> Wow64EnableWow64FsRedirection = OptionalExport ( TransparentKernel32Proxy ) ( \"<STR_LIT>\" ) <EOL> Wow64GetThreadContext = OptionalExport ( TransparentKernel32Proxy ) ( \"<STR_LIT>\" ) <EOL> def CreateFile_error_check ( func_name , result , func , args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if result == INVALID_HANDLE_VALUE : <EOL> raise Kernel32Error ( func_name ) <EOL> return args <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" , error_check = CreateFile_error_check ) <EOL> def CreateFileA ( lpFileName , dwDesiredAccess = GENERIC_READ , dwShareMode = <NUM_LIT:0> , lpSecurityAttributes = None , dwCreationDisposition = OPEN_EXISTING , dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL , hTemplateFile = None ) : <EOL> return CreateFileA . ctypes_function ( lpFileName , dwDesiredAccess , dwShareMode , lpSecurityAttributes , dwCreationDisposition , dwFlagsAndAttributes , hTemplateFile ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" , error_check = CreateFile_error_check ) <EOL> def CreateFileW ( lpFileName , dwDesiredAccess = GENERIC_READ , dwShareMode = <NUM_LIT:0> , lpSecurityAttributes = None , dwCreationDisposition = OPEN_EXISTING , dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL , hTemplateFile = None ) : <EOL> return CreateFileA . ctypes_function ( lpFileName , dwDesiredAccess , dwShareMode , lpSecurityAttributes , dwCreationDisposition , dwFlagsAndAttributes , hTemplateFile ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def VirtualAlloc ( lpAddress = <NUM_LIT:0> , dwSize = NeededParameter , flAllocationType = MEM_COMMIT , flProtect = PAGE_EXECUTE_READWRITE ) : <EOL> return VirtualAlloc . ctypes_function ( lpAddress , dwSize , flAllocationType , flProtect ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def VirtualFree ( lpAddress , dwSize = <NUM_LIT:0> , dwFreeType = MEM_RELEASE ) : <EOL> return VirtualFree . ctypes_function ( lpAddress , dwSize , dwFreeType ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def VirtualAllocEx ( hProcess , lpAddress = <NUM_LIT:0> , dwSize = NeededParameter , flAllocationType = MEM_COMMIT , flProtect = PAGE_EXECUTE_READWRITE ) : <EOL> return VirtualAllocEx . ctypes_function ( hProcess , lpAddress , dwSize , flAllocationType , flProtect ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def VirtualFreeEx ( hProcess , lpAddress , dwSize = <NUM_LIT:0> , dwFreeType = MEM_RELEASE ) : <EOL> return VirtualFreeEx . ctypes_function ( hProcess , lpAddress , dwSize , dwFreeType ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def CreateThread ( lpThreadAttributes = None , dwStackSize = <NUM_LIT:0> , lpStartAddress = NeededParameter , lpParameter = NeededParameter , dwCreationFlags = <NUM_LIT:0> , lpThreadId = None ) : <EOL> return CreateThread . ctypes_function ( lpThreadAttributes , dwStackSize , lpStartAddress , lpParameter , dwCreationFlags , lpThreadId ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def CreateRemoteThread ( hProcess = NeededParameter , lpThreadAttributes = None , dwStackSize = <NUM_LIT:0> , <EOL> lpStartAddress = NeededParameter , lpParameter = NeededParameter , dwCreationFlags = <NUM_LIT:0> , lpThreadId = None ) : <EOL> return CreateRemoteThread . ctypes_function ( hProcess , lpThreadAttributes , dwStackSize , lpStartAddress , lpParameter , dwCreationFlags , lpThreadId ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def VirtualProtect ( lpAddress , dwSize , flNewProtect , lpflOldProtect = None ) : <EOL> if lpflOldProtect is None : <EOL> lpflOldProtect = ctypes . byref ( DWORD ( ) ) <EOL> return VirtualProtect . ctypes_function ( lpAddress , dwSize , flNewProtect , lpflOldProtect ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def VirtualProtectEx ( hProcess , lpAddress , dwSize , flNewProtect , lpflOldProtect = None ) : <EOL> if lpflOldProtect is None : <EOL> lpflOldProtect = ctypes . byref ( DWORD ( ) ) <EOL> return VirtualProtectEx . ctypes_function ( hProcess , lpAddress , dwSize , flNewProtect , lpflOldProtect ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def CreateProcessA ( lpApplicationName , lpCommandLine = None , lpProcessAttributes = None , lpThreadAttributes = None , bInheritHandles = False , <EOL> dwCreationFlags = <NUM_LIT:0> , lpEnvironment = None , lpCurrentDirectory = None , lpStartupInfo = None , lpProcessInformation = None ) : <EOL> if lpStartupInfo is None : <EOL> StartupInfo = STARTUPINFOA ( ) <EOL> StartupInfo . cb = ctypes . sizeof ( StartupInfo ) <EOL> StartupInfo . dwFlags = STARTF_USESHOWWINDOW <EOL> StartupInfo . wShowWindow = SW_HIDE <EOL> lpStartupInfo = ctypes . byref ( StartupInfo ) <EOL> if lpProcessInformation is None : <EOL> lpProcessInformation = ctypes . byref ( PROCESS_INFORMATION ( ) ) <EOL> return CreateProcessA . ctypes_function ( lpApplicationName , lpCommandLine , lpProcessAttributes , lpThreadAttributes , bInheritHandles , dwCreationFlags , lpEnvironment , lpCurrentDirectory , lpStartupInfo , lpProcessInformation ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def CreateProcessW ( lpApplicationName , lpCommandLine = None , lpProcessAttributes = None , lpThreadAttributes = None , bInheritHandles = False , <EOL> dwCreationFlags = <NUM_LIT:0> , lpEnvironment = None , lpCurrentDirectory = None , lpStartupInfo = None , lpProcessInformation = None ) : <EOL> if lpStartupInfo is None : <EOL> StartupInfo = STARTUPINFOW ( ) <EOL> StartupInfo . cb = ctypes . sizeof ( StartupInfo ) <EOL> StartupInfo . dwFlags = STARTF_USESHOWWINDOW <EOL> StartupInfo . wShowWindow = SW_HIDE <EOL> lpStartupInfo = ctypes . byref ( StartupInfo ) <EOL> if lpProcessInformation is None : <EOL> lpProcessInformation = ctypes . byref ( PROCESS_INFORMATION ( ) ) <EOL> return CreateProcessW . ctypes_function ( lpApplicationName , lpCommandLine , lpProcessAttributes , lpThreadAttributes , bInheritHandles , dwCreationFlags , lpEnvironment , lpCurrentDirectory , lpStartupInfo , lpProcessInformation ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def GetThreadContext ( hThread , lpContext = None ) : <EOL> if lpContext is None : <EOL> Context = CONTEXT ( ) <EOL> context . ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS <EOL> lpContext = ctypes . byref ( Context ) <EOL> return GetThreadContext . ctypes_function ( hThread , lpContext ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def SetThreadContext ( hThread , lpContext ) : <EOL> return SetThreadContext . ctypes_function ( hThread , lpContext ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def Wow64SetThreadContext ( hThread , lpContext ) : <EOL> return Wow64SetThreadContext . ctypes_function ( hThread , lpContext ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def OpenThread ( dwDesiredAccess = THREAD_ALL_ACCESS , bInheritHandle = <NUM_LIT:0> , dwThreadId = NeededParameter ) : <EOL> return OpenThread . ctypes_function ( dwDesiredAccess , bInheritHandle , dwThreadId ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def OpenProcess ( dwDesiredAccess = PROCESS_ALL_ACCESS , bInheritHandle = <NUM_LIT:0> , dwProcessId = NeededParameter ) : <EOL> return OpenProcess . ctypes_function ( dwDesiredAccess , bInheritHandle , dwProcessId ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def ReadProcessMemory ( hProcess , lpBaseAddress , lpBuffer , nSize , lpNumberOfBytesRead = None ) : <EOL> return ReadProcessMemory . ctypes_function ( hProcess , lpBaseAddress , lpBuffer , nSize , lpNumberOfBytesRead ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def WriteProcessMemory ( hProcess , lpBaseAddress , lpBuffer , nSize = None , lpNumberOfBytesWritten = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if nSize is None : <EOL> nSize = len ( lpBuffer ) <EOL> return WriteProcessMemory . ctypes_function ( hProcess , lpBaseAddress , lpBuffer , nSize , lpNumberOfBytesWritten ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def GetProcessTimes ( hProcess , lpCreationTime , lpExitTime , lpKernelTime , lpUserTime ) : <EOL> return GetProcessTimes . ctypes_function ( hProcess , lpCreationTime , lpExitTime , lpKernelTime , lpUserTime ) <EOL> @ Kernel32Proxy ( '<STR_LIT>' ) <EOL> def SetThreadAffinityMask ( hThread = None , dwThreadAffinityMask = NeededParameter ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if hThread is None : <EOL> hThread = GetCurrentThread ( ) <EOL> return SetThreadAffinityMask . ctypes_function ( hThread , dwThreadAffinityMask ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def CreateToolhelp32Snapshot ( dwFlags , th32ProcessID = <NUM_LIT:0> ) : <EOL> return CreateToolhelp32Snapshot . ctypes_function ( dwFlags , th32ProcessID ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def Thread32First ( hSnapshot , lpte ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if type ( lpte ) == THREADENTRY32 : <EOL> lpte = ctypes . byref ( lpte ) <EOL> return Thread32First . ctypes_function ( hSnapshot , lpte ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" , no_error_check ) <EOL> def Thread32Next ( hSnapshot , lpte ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if type ( lpte ) == THREADENTRY32 : <EOL> lpte = ctypes . byref ( lpte ) <EOL> return Thread32Next . ctypes_function ( hSnapshot , lpte ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def Process32First ( hSnapshot , lpte ) : <EOL> return Process32First . ctypes_function ( hSnapshot , lpte ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" , no_error_check ) <EOL> def Process32Next ( hSnapshot , lpte ) : <EOL> return Process32Next . ctypes_function ( hSnapshot , lpte ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def OpenEventA ( dwDesiredAccess , bInheritHandle , lpName ) : <EOL> return OpenEventA . ctypes_function ( dwDesiredAccess , bInheritHandle , lpName ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def OpenEventW ( dwDesiredAccess , bInheritHandle , lpName ) : <EOL> return OpenEventA . ctypes_function ( dwDesiredAccess , bInheritHandle , lpName ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def WriteFile ( hFile , lpBuffer , nNumberOfBytesToWrite = None , lpNumberOfBytesWritten = None , lpOverlapped = None ) : <EOL> if nNumberOfBytesToWrite is None : <EOL> nNumberOfBytesToWrite = len ( lpBuffer ) <EOL> if lpOverlapped is None and lpNumberOfBytesWritten is None : <EOL> lpNumberOfBytesWritten = ctypes . byref ( DWORD ( ) ) <EOL> return WriteFile . ctypes_function ( hFile , lpBuffer , nNumberOfBytesToWrite , lpNumberOfBytesWritten , lpOverlapped ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def AddVectoredContinueHandler ( FirstHandler = <NUM_LIT:1> , VectoredHandler = NeededParameter ) : <EOL> return AddVectoredContinueHandler . ctypes_function ( FirstHandler , VectoredHandler ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def AddVectoredExceptionHandler ( FirstHandler = <NUM_LIT:1> , VectoredHandler = NeededParameter ) : <EOL> return AddVectoredExceptionHandler . ctypes_function ( FirstHandler , VectoredHandler ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def RemoveVectoredExceptionHandler ( Handler ) : <EOL> return RemoveVectoredExceptionHandler . ctypes_function ( Handler ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" , kernel32_zero_check ) <EOL> def WaitForSingleObject ( hHandle , dwMilliseconds = INFINITE ) : <EOL> return WaitForSingleObject . ctypes_function ( hHandle , dwMilliseconds ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def DeviceIoControl ( hDevice , dwIoControlCode , lpInBuffer , nInBufferSize = None , lpOutBuffer = NeededParameter , nOutBufferSize = None , lpBytesReturned = None , lpOverlapped = None ) : <EOL> if nInBufferSize is None : <EOL> nInBufferSize = len ( lpInBuffer ) <EOL> if nOutBufferSize is None : <EOL> nOutBufferSize = len ( lpOutBuffer ) <EOL> if lpBytesReturned is None : <EOL> lpBytesReturned = ctypes . byref ( DWORD ( ) ) <EOL> return DeviceIoControl . ctypes_function ( hDevice , dwIoControlCode , lpInBuffer , nInBufferSize , lpOutBuffer , nOutBufferSize , lpBytesReturned , lpOverlapped ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def CreateFileMappingA ( hFile , lpFileMappingAttributes = None , flProtect = PAGE_READWRITE , dwMaximumSizeHigh = <NUM_LIT:0> , dwMaximumSizeLow = NeededParameter , lpName = NeededParameter ) : <EOL> return CreateFileMappingA . ctypes_function ( hFile , lpFileMappingAttributes , flProtect , dwMaximumSizeHigh , dwMaximumSizeLow , lpName ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def CreateFileMappingW ( hFile , lpFileMappingAttributes = None , flProtect = PAGE_READWRITE , dwMaximumSizeHigh = <NUM_LIT:0> , dwMaximumSizeLow = <NUM_LIT:0> , lpName = NeededParameter ) : <EOL> return CreateFileMappingW . ctypes_function ( hFile , lpFileMappingAttributes , flProtect , dwMaximumSizeHigh , dwMaximumSizeLow , lpName ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def MapViewOfFile ( hFileMappingObject , dwDesiredAccess = FILE_MAP_ALL_ACCESS , dwFileOffsetHigh = <NUM_LIT:0> , dwFileOffsetLow = <NUM_LIT:0> , dwNumberOfBytesToMap = NeededParameter ) : <EOL> return MapViewOfFile . ctypes_function ( hFileMappingObject , dwDesiredAccess , dwFileOffsetHigh , dwFileOffsetLow , dwNumberOfBytesToMap ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def DuplicateHandle ( hSourceProcessHandle , hSourceHandle , hTargetProcessHandle , lpTargetHandle , dwDesiredAccess = <NUM_LIT:0> , bInheritHandle = False , dwOptions = <NUM_LIT:0> ) : <EOL> return DuplicateHandle . ctypes_function ( hSourceProcessHandle , hSourceHandle , hTargetProcessHandle , lpTargetHandle , dwDesiredAccess , bInheritHandle , dwOptions ) <EOL> def GetMappedFileNameWWrapper ( hProcess , lpv , lpFilename , nSize = None ) : <EOL> if nSize is None : <EOL> nSize = ctypes . sizeof ( lpFilename ) <EOL> return GetMappedFileNameWWrapper . ctypes_function ( hProcess , lpv , lpFilename , nSize ) <EOL> GetMappedFileNameW = OptionalExport ( Kernel32Proxy ( \"<STR_LIT>\" ) ) ( GetMappedFileNameWWrapper ) <EOL> def GetMappedFileNameAWrapper ( hProcess , lpv , lpFilename , nSize = None ) : <EOL> if nSize is None : <EOL> nSize = ctypes . sizeof ( lpFilename ) <EOL> return GetMappedFileNameAWrapper . ctypes_function ( hProcess , lpv , lpFilename , nSize ) <EOL> GetMappedFileNameA = OptionalExport ( Kernel32Proxy ( \"<STR_LIT>\" ) ) ( GetMappedFileNameAWrapper ) <EOL> def QueryWorkingSetWrapper ( hProcess , pv , cb ) : <EOL> return QueryWorkingSet . ctypes_function ( hProcess , pv , cb ) <EOL> QueryWorkingSet = OptionalExport ( Kernel32Proxy ( \"<STR_LIT>\" ) ) ( QueryWorkingSetWrapper ) <EOL> def QueryWorkingSetExWrapper ( hProcess , pv , cb ) : <EOL> return QueryWorkingSetEx . ctypes_function ( hProcess , pv , cb ) <EOL> QueryWorkingSetEx = OptionalExport ( Kernel32Proxy ( \"<STR_LIT>\" ) ) ( QueryWorkingSetExWrapper ) <EOL> if GetMappedFileNameA is None : <EOL> GetMappedFileNameW = PsapiProxy ( \"<STR_LIT>\" ) ( GetMappedFileNameWWrapper ) <EOL> GetMappedFileNameA = PsapiProxy ( \"<STR_LIT>\" ) ( GetMappedFileNameAWrapper ) <EOL> QueryWorkingSet = PsapiProxy ( \"<STR_LIT>\" ) ( QueryWorkingSetWrapper ) <EOL> QueryWorkingSetEx = PsapiProxy ( \"<STR_LIT>\" ) ( QueryWorkingSetExWrapper ) <EOL> def GetModuleBaseNameAWrapper ( hProcess , hModule , lpBaseName , nSize = None ) : <EOL> if nSize is None : <EOL> nSize = len ( lpBaseName ) <EOL> return GetModuleBaseNameAWrapper . ctypes_function ( hProcess , hModule , lpBaseName , nSize ) <EOL> GetModuleBaseNameA = OptionalExport ( Kernel32Proxy ( \"<STR_LIT>\" ) ) ( GetModuleBaseNameAWrapper ) <EOL> def GetModuleBaseNameWWrapper ( hProcess , hModule , lpBaseName , nSize = None ) : <EOL> if nSize is None : <EOL> nSize = len ( lpBaseName ) <EOL> return GetModuleBaseNameWWrapper . ctypes_function ( hProcess , hModule , lpBaseName , nSize ) <EOL> GetModuleBaseNameA = OptionalExport ( Kernel32Proxy ( \"<STR_LIT>\" ) ) ( GetModuleBaseNameWWrapper ) <EOL> if GetModuleBaseNameA is None : <EOL> GetModuleBaseNameA = PsapiProxy ( \"<STR_LIT>\" ) ( GetModuleBaseNameAWrapper ) <EOL> GetModuleBaseNameW = PsapiProxy ( \"<STR_LIT>\" ) ( GetModuleBaseNameWWrapper ) <EOL> def GetProcessImageFileNameAWrapper ( hProcess , lpImageFileName , nSize = None ) : <EOL> if nSize is None : <EOL> nSize = len ( lpImageFileName ) <EOL> return GetProcessImageFileNameAWrapper . ctypes_function ( hProcess , lpImageFileName , nSize ) <EOL> GetProcessImageFileNameA = OptionalExport ( Kernel32Proxy ( \"<STR_LIT>\" ) ) ( GetProcessImageFileNameAWrapper ) <EOL> def GetProcessImageFileNameWWrapper ( hProcess , lpImageFileName , nSize = None ) : <EOL> if nSize is None : <EOL> nSize = len ( lpImageFileName ) <EOL> return GetProcessImageFileNameWWrapper . ctypes_function ( hProcess , lpImageFileName , nSize ) <EOL> GetProcessImageFileNameW = OptionalExport ( Kernel32Proxy ( \"<STR_LIT>\" ) ) ( GetProcessImageFileNameWWrapper ) <EOL> if GetProcessImageFileNameA is None : <EOL> GetProcessImageFileNameA = PsapiProxy ( \"<STR_LIT>\" ) ( GetProcessImageFileNameAWrapper ) <EOL> GetProcessImageFileNameW = PsapiProxy ( \"<STR_LIT>\" ) ( GetProcessImageFileNameWWrapper ) <EOL> DebugBreak = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> ContinueDebugEvent = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> DebugActiveProcess = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> DebugActiveProcessStop = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> DebugSetProcessKillOnExit = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> DebugBreakProcess = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def WaitForDebugEvent ( lpDebugEvent , dwMilliseconds = INFINITE ) : <EOL> return WaitForDebugEvent . ctypes_function ( lpDebugEvent , dwMilliseconds ) <EOL> GetLogicalDriveStringsA = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetLogicalDriveStringsW = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetDriveTypeA = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetDriveTypeW = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> QueryDosDeviceA = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> QueryDosDeviceW = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetVolumeNameForVolumeMountPointA = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> GetVolumeNameForVolumeMountPointW = TransparentKernel32Proxy ( \"<STR_LIT>\" ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def GetVolumeInformationA ( lpRootPathName , lpVolumeNameBuffer , nVolumeNameSize , lpVolumeSerialNumber , lpMaximumComponentLength , lpFileSystemFlags , lpFileSystemNameBuffer , nFileSystemNameSize ) : <EOL> if nVolumeNameSize == <NUM_LIT:0> and lpVolumeNameBuffer is not None : <EOL> nVolumeNameSize = len ( lpVolumeNameBuffer ) <EOL> if nFileSystemNameSize == <NUM_LIT:0> and lpFileSystemNameBuffer is not None : <EOL> nFileSystemNameSize = len ( lpFileSystemNameBuffer ) <EOL> return GetVolumeInformationA . ctypes_function ( lpRootPathName , lpVolumeNameBuffer , nVolumeNameSize , lpVolumeSerialNumber , lpMaximumComponentLength , lpFileSystemFlags , lpFileSystemNameBuffer , nFileSystemNameSize ) <EOL> @ Kernel32Proxy ( \"<STR_LIT>\" ) <EOL> def GetVolumeInformationW ( lpRootPathName , lpVolumeNameBuffer = None , nVolumeNameSize = <NUM_LIT:0> , lpVolumeSerialNumber = None , lpMaximumComponentLength = None , lpFileSystemFlags = None , lpFileSystemNameBuffer = None , nFileSystemNameSize = <NUM_LIT:0> ) : <EOL> if nVolumeNameSize == <NUM_LIT:0> and lpVolumeNameBuffer is not None : <EOL> nVolumeNameSize = len ( lpVolumeNameBuffer ) <EOL> if nFileSystemNameSize == <NUM_LIT:0> and lpFileSystemNameBuffer is not None : <EOL> nFileSystemNameSize = len ( lpFileSystemNameBuffer ) <EOL> return GetVolumeInformationW . ctypes_function ( lpRootPathName , lpVolumeNameBuffer , nVolumeNameSize , lpVolumeSerialNumber , lpMaximumComponentLength , lpFileSystemFlags , lpFileSystemNameBuffer , nFileSystemNameSize ) <EOL> @ OptionalExport ( NtdllProxy ( '<STR_LIT>' , error_ntstatus ) ) <EOL> def NtWow64ReadVirtualMemory64 ( hProcess , lpBaseAddress , lpBuffer , nSize , lpNumberOfBytesRead = None ) : <EOL> return NtWow64ReadVirtualMemory64 . ctypes_function ( hProcess , lpBaseAddress , lpBuffer , nSize , lpNumberOfBytesRead ) <EOL> @ OptionalExport ( NtdllProxy ( '<STR_LIT>' , error_ntstatus ) ) <EOL> def NtWow64WriteVirtualMemory64 ( hProcess , lpBaseAddress , lpBuffer , nSize , lpNumberOfBytesWritten = None ) : <EOL> return NtWow64WriteVirtualMemory64 . ctypes_function ( hProcess , lpBaseAddress , lpBuffer , nSize , lpNumberOfBytesWritten ) <EOL> def ntquerysysteminformation_error_check ( func_name , result , func , args ) : <EOL> if result == <NUM_LIT:0> : <EOL> return args <EOL> if result == STATUS_INFO_LENGTH_MISMATCH and args [ <NUM_LIT:1> ] is None : <EOL> return args <EOL> raise Kernel32Error ( \"<STR_LIT>\" . format ( func_name , hex ( result ) ) ) <EOL> @ NtdllProxy ( \"<STR_LIT>\" , error_ntstatus ) <EOL> def NtGetContextThread ( hThread , lpContext ) : <EOL> return NtGetContextThread . ctypes_function ( hThread , lpContext ) <EOL> @ NtdllProxy ( \"<STR_LIT>\" , error_ntstatus ) <EOL> def LdrLoadDll ( PathToFile , Flags , ModuleFileName , ModuleHandle ) : <EOL> return LdrLoadDll . ctypes_function ( PathToFile , Flags , ModuleFileName , ModuleHandle ) <EOL> @ NtdllProxy ( '<STR_LIT>' , ntquerysysteminformation_error_check ) <EOL> def NtQuerySystemInformation ( SystemInformationClass , SystemInformation = None , SystemInformationLength = <NUM_LIT:0> , ReturnLength = NeededParameter ) : <EOL> if SystemInformation is not None and SystemInformationLength == <NUM_LIT:0> : <EOL> SystemInformationLength = ctypes . sizeof ( SystemInformation ) <EOL> return NtQuerySystemInformation . ctypes_function ( SystemInformationClass , SystemInformation , SystemInformationLength , ReturnLength ) <EOL> @ OptionalExport ( NtdllProxy ( '<STR_LIT>' , error_ntstatus ) ) <EOL> def NtQueryInformationProcess ( ProcessHandle , ProcessInformationClass , ProcessInformation , ProcessInformationLength = <NUM_LIT:0> , ReturnLength = None ) : <EOL> if ProcessInformation is not None and ProcessInformationLength == <NUM_LIT:0> : <EOL> ProcessInformationLength = ctypes . sizeof ( ProcessInformation ) <EOL> if type ( ProcessInformation ) == PROCESS_BASIC_INFORMATION : <EOL> ProcessInformation = byref ( ProcessInformation ) <EOL> if ReturnLength is None : <EOL> ReturnLength = byref ( ULONG ( ) ) <EOL> return NtQueryInformationProcess . ctypes_function ( ProcessHandle , ProcessInformationClass , ProcessInformation , ProcessInformationLength , ReturnLength ) <EOL> @ NtdllProxy ( '<STR_LIT>' , error_ntstatus ) <EOL> def NtQueryInformationThread ( ThreadHandle , ThreadInformationClass , ThreadInformation , ThreadInformationLength = <NUM_LIT:0> , ReturnLength = None ) : <EOL>", "answer": "if ReturnLength is None :"}, {"prompt": "<s> from website . files . models . base import * <EOL> from website . files . models . s3 import * <EOL> from website . files . models . box import * <EOL> from website . files . models . github import * <EOL>", "answer": "from website . files . models . dropbox import *"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL>", "answer": "class Migration ( migrations . Migration ) :"}, {"prompt": "<s> import boto <EOL> import boto . s3 . connection <EOL> from django . conf import settings <EOL> import logging <EOL> log = logging . getLogger ( __name__ ) <EOL>", "answer": "def get_s3_connection ( ) :"}, {"prompt": "<s> import unittest <EOL> import numpy <EOL> import six <EOL> from chainer import cuda <EOL> from chainer import gradient_check <EOL> from chainer import testing <EOL> from chainer . testing import attr <EOL> from chainer . testing import condition <EOL> def _uniform ( * shape ) : <EOL>", "answer": "return numpy . random . uniform ( - <NUM_LIT:1> , <NUM_LIT:1> , shape ) . astype ( numpy . float32 )"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Ship ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL>", "answer": "result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "<s> import numpy as np <EOL> n = <NUM_LIT:30> <EOL> bsize = <NUM_LIT:10> <EOL> A = np . random . rand ( n , n ) <EOL> B = np . random . rand ( n , n ) <EOL> num_blocks = n // bsize + <NUM_LIT:1> <EOL> C = np . zeros ( ( n , n ) ) <EOL> for i in range ( num_blocks ) : <EOL> i *= bsize <EOL> si = slice ( i , i + bsize ) <EOL>", "answer": "for j in range ( num_blocks ) :"}, {"prompt": "<s> from __future__ import absolute_import , print_function , division <EOL> import pycuda . autoinit <EOL> import pycuda . driver as drv <EOL> import numpy <EOL> from pycuda . compiler import SourceModule <EOL>", "answer": "mod = SourceModule ( \"\"\"<STR_LIT>\"\"\" )"}, {"prompt": "<s> import wx <EOL> import wx . stc <EOL> import platformspec <EOL> from util import * <EOL> STYLE_NORMAL = <NUM_LIT:1> <EOL> STYLE_COMMIT = <NUM_LIT:2> <EOL> STYLE_FILE = <NUM_LIT:3> <EOL> STYLE_HUNK = <NUM_LIT:4> <EOL> STYLE_ADD = <NUM_LIT:5> <EOL> STYLE_REMOVE = <NUM_LIT:6> <EOL> MARK_FILE = <NUM_LIT:1> <EOL> STYLE_COLORS = [ <EOL> None , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , wx . FONTWEIGHT_NORMAL ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , wx . FONTWEIGHT_BOLD ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , wx . FONTWEIGHT_BOLD ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , wx . FONTWEIGHT_NORMAL ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , wx . FONTWEIGHT_NORMAL ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , wx . FONTWEIGHT_NORMAL ) <EOL> ] <EOL> class DiffViewer ( wx . Panel ) : <EOL> def __init__ ( self , parent , id ) : <EOL> wx . Panel . __init__ ( self , parent , id ) <EOL> self . sizer = wx . BoxSizer ( wx . VERTICAL ) <EOL> self . SetSizer ( self . sizer ) <EOL> self . textCtrl = wx . stc . StyledTextCtrl ( self , - <NUM_LIT:1> ) <EOL> self . sizer . Add ( self . textCtrl , True , wx . EXPAND ) <EOL> self . textCtrl . MarkerDefine ( MARK_FILE , <EOL> wx . stc . STC_MARK_BACKGROUND , <EOL> wx . Colour ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:255> ) , <EOL> wx . Colour ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:255> ) <EOL> ) <EOL> for style in xrange ( <NUM_LIT:1> , len ( STYLE_COLORS ) ) : <EOL> fg , bg , weight = STYLE_COLORS [ style ] <EOL> font = platformspec . Font ( <NUM_LIT:10> , wx . FONTFAMILY_TELETYPE ) <EOL> self . textCtrl . StyleSetFont ( style , font ) <EOL> self . textCtrl . StyleSetForeground ( style , fg ) <EOL> self . textCtrl . StyleSetBackground ( style , bg ) <EOL> def Clear ( self ) : <EOL> self . textCtrl . SetReadOnly ( False ) <EOL> self . textCtrl . SetText ( '<STR_LIT>' ) <EOL> self . textCtrl . SetReadOnly ( True ) <EOL> def SetDiffText ( self , text , commit_mode = False ) : <EOL> self . Clear ( ) <EOL> self . textCtrl . SetReadOnly ( False ) <EOL> if commit_mode : <EOL> in_commit_header = True <EOL> in_commit_msg = False <EOL> else : <EOL> in_commit_header = False <EOL> in_commit_msg = False <EOL> in_hunk = False <EOL> style = STYLE_NORMAL <EOL> pos = <NUM_LIT:0> <EOL> lineno = <NUM_LIT:0> <EOL>", "answer": "for line in text . split ( '<STR_LIT:\\n>' ) :"}, {"prompt": "<s> import os <EOL> import sys <EOL> from django . conf import settings <EOL> from django . db . backends . creation import BaseDatabaseCreation <EOL> class DatabaseCreation ( BaseDatabaseCreation ) : <EOL> data_types = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT:bool>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT:date>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT:bool>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT:text>' , <EOL> '<STR_LIT>' : '<STR_LIT:time>' , <EOL> } <EOL> def sql_for_pending_references ( self , model , style , pending_references ) : <EOL> \"<STR_LIT>\" <EOL> return [ ] <EOL> def sql_remove_table_constraints ( self , model , references_to_delete , style ) : <EOL> \"<STR_LIT>\" <EOL> return [ ] <EOL> def _create_test_db ( self , verbosity , autoclobber ) : <EOL> if settings . TEST_DATABASE_NAME and settings . TEST_DATABASE_NAME != \"<STR_LIT>\" : <EOL> test_database_name = settings . TEST_DATABASE_NAME <EOL> if verbosity >= <NUM_LIT:1> : <EOL> print \"<STR_LIT>\" <EOL> if os . access ( test_database_name , os . F_OK ) : <EOL> if not autoclobber : <EOL> confirm = raw_input ( \"<STR_LIT>\" % test_database_name ) <EOL> if autoclobber or confirm == '<STR_LIT:yes>' : <EOL> try : <EOL>", "answer": "if verbosity >= <NUM_LIT:1> :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> from datetime import timedelta <EOL> from uuid import UUID , uuid4 <EOL> from unittest import SkipTest , skipIf <EOL> from testtools import run_test_with <EOL> from testtools . matchers import MatchesListwise , AfterPreprocessing , Equals <EOL> from twisted . internet import reactor <EOL> from flocker import __version__ as HEAD_FLOCKER_VERSION <EOL> from flocker . common . version import get_installable_version <EOL> from ... common import loop_until <EOL> from ... testtools import AsyncTestCase , flaky , async_runner <EOL> from ... node . agents . blockdevice import ICloudAPI <EOL> from ... provision import PackageSource <EOL> from ... node import backends <EOL> from . . testtools import ( <EOL> require_cluster , require_moving_backend , create_dataset , <EOL> skip_backend , get_backend_api , verify_socket , <EOL> get_default_volume_size , ACCEPTANCE_TEST_TIMEOUT <EOL> ) <EOL> class DatasetAPITests ( AsyncTestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> run_tests_with = async_runner ( timeout = ACCEPTANCE_TEST_TIMEOUT ) <EOL> @ flaky ( u'<STR_LIT>' ) <EOL> @ require_cluster ( <NUM_LIT:1> ) <EOL> def test_dataset_creation ( self , cluster ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return create_dataset ( self , cluster ) <EOL> def _get_package_source ( self , default_version = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> env_vars = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> defaultable = frozenset ( [ '<STR_LIT>' , <EOL> '<STR_LIT>' ] ) <EOL> missing_vars = list ( var for var in env_vars if var not in os . environ ) <EOL> if missing_vars : <EOL> message = ( '<STR_LIT>' % <EOL> '<STR_LIT:U+002CU+0020>' . join ( missing_vars ) ) <EOL> missing_defaultable = list ( var for var in missing_vars <EOL> if var in defaultable ) <EOL> if missing_defaultable : <EOL> message += ( '<STR_LIT>' <EOL> '<STR_LIT>' % <EOL> '<STR_LIT:U+002CU+0020>' . join ( missing_defaultable ) ) <EOL> raise SkipTest ( message ) <EOL> version = ( os . environ [ '<STR_LIT>' ] or <EOL> default_version ) <EOL> return PackageSource ( <EOL> version = version , <EOL> branch = os . environ [ '<STR_LIT>' ] , <EOL> build_server = os . environ [ '<STR_LIT>' ] ) <EOL> @ skip_backend ( <EOL> unsupported = { backends . LOOPBACK } , <EOL> reason = \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> @ skip_backend ( <EOL> unsupported = { backends . GCE } , <EOL> reason = \"<STR_LIT>\" ) <EOL> @ run_test_with ( async_runner ( timeout = timedelta ( minutes = <NUM_LIT:6> ) ) ) <EOL> @ require_cluster ( <NUM_LIT:1> ) <EOL> def test_upgrade ( self , cluster ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> node = cluster . nodes [ <NUM_LIT:0> ] <EOL> SAMPLE_STR = '<STR_LIT>' * <NUM_LIT:100> <EOL> upgrade_from_version = get_installable_version ( HEAD_FLOCKER_VERSION ) <EOL> d = cluster . client . version ( ) <EOL> original_package_source = [ None ] <EOL> def setup_restore_original_flocker ( version ) : <EOL> version_bytes = version . get ( '<STR_LIT>' , u'<STR_LIT>' ) . encode ( '<STR_LIT:ascii>' ) <EOL> original_package_source [ <NUM_LIT:0> ] = ( <EOL> self . _get_package_source ( <EOL> default_version = version_bytes or None ) <EOL> ) <EOL> self . addCleanup ( <EOL> lambda : cluster . install_flocker_version ( <EOL> original_package_source [ <NUM_LIT:0> ] ) ) <EOL> return version <EOL> d . addCallback ( setup_restore_original_flocker ) <EOL> d . addCallback ( lambda _ : cluster . clean_nodes ( ) ) <EOL> d . addCallback ( <EOL>", "answer": "lambda _ : cluster . install_flocker_version ("}, {"prompt": "<s> from django . conf . urls . defaults import * <EOL>", "answer": "urlpatterns = patterns ( '<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from warnings import warnpy3k <EOL> warnpy3k ( \"<STR_LIT>\" , <EOL> stacklevel = <NUM_LIT:2> ) <EOL> del warnpy3k <EOL> import markupbase <EOL> import re <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> interesting = re . compile ( '<STR_LIT>' ) <EOL> incomplete = re . compile ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> entityref = re . compile ( '<STR_LIT>' ) <EOL> charref = re . compile ( '<STR_LIT>' ) <EOL> starttagopen = re . compile ( '<STR_LIT>' ) <EOL> shorttagopen = re . compile ( '<STR_LIT>' ) <EOL> shorttag = re . compile ( '<STR_LIT>' ) <EOL> piclose = re . compile ( '<STR_LIT:>>' ) <EOL> endbracket = re . compile ( '<STR_LIT>' ) <EOL> tagfind = re . compile ( '<STR_LIT>' ) <EOL> attrfind = re . compile ( <EOL> r'<STR_LIT>' <EOL> r'<STR_LIT>' ) <EOL> class SGMLParseError ( RuntimeError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class SGMLParser ( markupbase . ParserBase ) : <EOL> entity_or_charref = re . compile ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> def __init__ ( self , verbose = <NUM_LIT:0> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . verbose = verbose <EOL> self . reset ( ) <EOL> def reset ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . __starttag_text = None <EOL> self . rawdata = '<STR_LIT>' <EOL> self . stack = [ ] <EOL> self . lasttag = '<STR_LIT>' <EOL> self . nomoretags = <NUM_LIT:0> <EOL> self . literal = <NUM_LIT:0> <EOL> markupbase . ParserBase . reset ( self ) <EOL> def setnomoretags ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . nomoretags = self . literal = <NUM_LIT:1> <EOL> def setliteral ( self , * args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . literal = <NUM_LIT:1> <EOL> def feed ( self , data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . rawdata = self . rawdata + data <EOL> self . goahead ( <NUM_LIT:0> ) <EOL> def close ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . goahead ( <NUM_LIT:1> ) <EOL> def error ( self , message ) : <EOL> raise SGMLParseError ( message ) <EOL> def goahead ( self , end ) : <EOL> rawdata = self . rawdata <EOL> i = <NUM_LIT:0> <EOL> n = len ( rawdata ) <EOL> while i < n : <EOL> if self . nomoretags : <EOL> self . handle_data ( rawdata [ i : n ] ) <EOL> i = n <EOL> break <EOL> match = interesting . search ( rawdata , i ) <EOL> if match : j = match . start ( ) <EOL> else : j = n <EOL> if i < j : <EOL> self . handle_data ( rawdata [ i : j ] ) <EOL> i = j <EOL> if i == n : break <EOL> if rawdata [ i ] == '<STR_LIT:<>' : <EOL> if starttagopen . match ( rawdata , i ) : <EOL> if self . literal : <EOL> self . handle_data ( rawdata [ i ] ) <EOL> i = i + <NUM_LIT:1> <EOL> continue <EOL> k = self . parse_starttag ( i ) <EOL> if k < <NUM_LIT:0> : break <EOL> i = k <EOL> continue <EOL> if rawdata . startswith ( \"<STR_LIT>\" , i ) : <EOL> k = self . parse_endtag ( i ) <EOL> if k < <NUM_LIT:0> : break <EOL> i = k <EOL> self . literal = <NUM_LIT:0> <EOL> continue <EOL> if self . literal : <EOL> if n > ( i + <NUM_LIT:1> ) : <EOL> self . handle_data ( \"<STR_LIT:<>\" ) <EOL> i = i + <NUM_LIT:1> <EOL> else : <EOL> break <EOL> continue <EOL> if rawdata . startswith ( \"<STR_LIT>\" , i ) : <EOL> k = self . parse_comment ( i ) <EOL> if k < <NUM_LIT:0> : break <EOL> i = k <EOL> continue <EOL> if rawdata . startswith ( \"<STR_LIT>\" , i ) : <EOL> k = self . parse_pi ( i ) <EOL> if k < <NUM_LIT:0> : break <EOL> i = i + k <EOL> continue <EOL> if rawdata . startswith ( \"<STR_LIT>\" , i ) : <EOL> k = self . parse_declaration ( i ) <EOL> if k < <NUM_LIT:0> : break <EOL> i = k <EOL> continue <EOL> elif rawdata [ i ] == '<STR_LIT:&>' : <EOL> if self . literal : <EOL> self . handle_data ( rawdata [ i ] ) <EOL> i = i + <NUM_LIT:1> <EOL> continue <EOL> match = charref . match ( rawdata , i ) <EOL> if match : <EOL> name = match . group ( <NUM_LIT:1> ) <EOL> self . handle_charref ( name ) <EOL> i = match . end ( <NUM_LIT:0> ) <EOL> if rawdata [ i - <NUM_LIT:1> ] != '<STR_LIT:;>' : i = i - <NUM_LIT:1> <EOL> continue <EOL> match = entityref . match ( rawdata , i ) <EOL> if match : <EOL> name = match . group ( <NUM_LIT:1> ) <EOL> self . handle_entityref ( name ) <EOL> i = match . end ( <NUM_LIT:0> ) <EOL> if rawdata [ i - <NUM_LIT:1> ] != '<STR_LIT:;>' : i = i - <NUM_LIT:1> <EOL> continue <EOL> else : <EOL> self . error ( '<STR_LIT>' ) <EOL> match = incomplete . match ( rawdata , i ) <EOL> if not match : <EOL> self . handle_data ( rawdata [ i ] ) <EOL> i = i + <NUM_LIT:1> <EOL> continue <EOL> j = match . end ( <NUM_LIT:0> ) <EOL> if j == n : <EOL> break <EOL> self . handle_data ( rawdata [ i : j ] ) <EOL> i = j <EOL> if end and i < n : <EOL> self . handle_data ( rawdata [ i : n ] ) <EOL> i = n <EOL> self . rawdata = rawdata [ i : ] <EOL> _decl_otherchars = '<STR_LIT:=>' <EOL> def parse_pi ( self , i ) : <EOL> rawdata = self . rawdata <EOL> if rawdata [ i : i + <NUM_LIT:2> ] != '<STR_LIT>' : <EOL> self . error ( '<STR_LIT>' ) <EOL> match = piclose . search ( rawdata , i + <NUM_LIT:2> ) <EOL> if not match : <EOL> return - <NUM_LIT:1> <EOL> j = match . start ( <NUM_LIT:0> ) <EOL> self . handle_pi ( rawdata [ i + <NUM_LIT:2> : j ] ) <EOL> j = match . end ( <NUM_LIT:0> ) <EOL> return j - i <EOL> def get_starttag_text ( self ) : <EOL> return self . __starttag_text <EOL> def parse_starttag ( self , i ) : <EOL> self . __starttag_text = None <EOL> start_pos = i <EOL> rawdata = self . rawdata <EOL> if shorttagopen . match ( rawdata , i ) : <EOL> match = shorttag . match ( rawdata , i ) <EOL> if not match : <EOL> return - <NUM_LIT:1> <EOL> tag , data = match . group ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> self . __starttag_text = '<STR_LIT>' % tag <EOL> tag = tag . lower ( ) <EOL> k = match . end ( <NUM_LIT:0> ) <EOL> self . finish_shorttag ( tag , data ) <EOL> self . __starttag_text = rawdata [ start_pos : match . end ( <NUM_LIT:1> ) + <NUM_LIT:1> ] <EOL> return k <EOL> match = endbracket . search ( rawdata , i + <NUM_LIT:1> ) <EOL> if not match : <EOL> return - <NUM_LIT:1> <EOL> j = match . start ( <NUM_LIT:0> ) <EOL> attrs = [ ] <EOL> if rawdata [ i : i + <NUM_LIT:2> ] == '<STR_LIT>' : <EOL> k = j <EOL> tag = self . lasttag <EOL> else : <EOL> match = tagfind . match ( rawdata , i + <NUM_LIT:1> ) <EOL> if not match : <EOL> self . error ( '<STR_LIT>' ) <EOL> k = match . end ( <NUM_LIT:0> ) <EOL> tag = rawdata [ i + <NUM_LIT:1> : k ] . lower ( ) <EOL> self . lasttag = tag <EOL> while k < j : <EOL> match = attrfind . match ( rawdata , k ) <EOL> if not match : break <EOL> attrname , rest , attrvalue = match . group ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) <EOL> if not rest : <EOL> attrvalue = attrname <EOL> else : <EOL> if ( attrvalue [ : <NUM_LIT:1> ] == \"<STR_LIT:'>\" == attrvalue [ - <NUM_LIT:1> : ] or <EOL> attrvalue [ : <NUM_LIT:1> ] == '<STR_LIT:\">' == attrvalue [ - <NUM_LIT:1> : ] ) : <EOL> attrvalue = attrvalue [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> attrvalue = self . entity_or_charref . sub ( <EOL> self . _convert_ref , attrvalue ) <EOL> attrs . append ( ( attrname . lower ( ) , attrvalue ) ) <EOL> k = match . end ( <NUM_LIT:0> ) <EOL> if rawdata [ j ] == '<STR_LIT:>>' : <EOL> j = j + <NUM_LIT:1> <EOL> self . __starttag_text = rawdata [ start_pos : j ] <EOL> self . finish_starttag ( tag , attrs ) <EOL> return j <EOL> def _convert_ref ( self , match ) : <EOL> if match . group ( <NUM_LIT:2> ) : <EOL> return self . convert_charref ( match . group ( <NUM_LIT:2> ) ) or '<STR_LIT>' % match . groups ( ) [ <NUM_LIT:1> : ] <EOL> elif match . group ( <NUM_LIT:3> ) : <EOL> return self . convert_entityref ( match . group ( <NUM_LIT:1> ) ) or '<STR_LIT>' % match . group ( <NUM_LIT:1> ) <EOL> else : <EOL> return '<STR_LIT>' % match . group ( <NUM_LIT:1> ) <EOL> def parse_endtag ( self , i ) : <EOL> rawdata = self . rawdata <EOL> match = endbracket . search ( rawdata , i + <NUM_LIT:1> ) <EOL> if not match : <EOL> return - <NUM_LIT:1> <EOL> j = match . start ( <NUM_LIT:0> ) <EOL> tag = rawdata [ i + <NUM_LIT:2> : j ] . strip ( ) . lower ( ) <EOL> if rawdata [ j ] == '<STR_LIT:>>' : <EOL> j = j + <NUM_LIT:1> <EOL> self . finish_endtag ( tag ) <EOL> return j <EOL> def finish_shorttag ( self , tag , data ) : <EOL> self . finish_starttag ( tag , [ ] ) <EOL> self . handle_data ( data ) <EOL> self . finish_endtag ( tag ) <EOL> def finish_starttag ( self , tag , attrs ) : <EOL> try : <EOL> method = getattr ( self , '<STR_LIT>' + tag ) <EOL> except AttributeError : <EOL> try : <EOL> method = getattr ( self , '<STR_LIT>' + tag ) <EOL> except AttributeError : <EOL> self . unknown_starttag ( tag , attrs ) <EOL> return - <NUM_LIT:1> <EOL> else : <EOL> self . handle_starttag ( tag , method , attrs ) <EOL> return <NUM_LIT:0> <EOL> else : <EOL> self . stack . append ( tag ) <EOL> self . handle_starttag ( tag , method , attrs ) <EOL> return <NUM_LIT:1> <EOL> def finish_endtag ( self , tag ) : <EOL> if not tag : <EOL> found = len ( self . stack ) - <NUM_LIT:1> <EOL> if found < <NUM_LIT:0> : <EOL> self . unknown_endtag ( tag ) <EOL> return <EOL> else : <EOL> if tag not in self . stack : <EOL> try : <EOL> method = getattr ( self , '<STR_LIT>' + tag ) <EOL> except AttributeError : <EOL> self . unknown_endtag ( tag ) <EOL> else : <EOL> self . report_unbalanced ( tag ) <EOL> return <EOL> found = len ( self . stack ) <EOL> for i in range ( found ) : <EOL> if self . stack [ i ] == tag : found = i <EOL> while len ( self . stack ) > found : <EOL> tag = self . stack [ - <NUM_LIT:1> ] <EOL> try : <EOL> method = getattr ( self , '<STR_LIT>' + tag ) <EOL> except AttributeError : <EOL> method = None <EOL> if method : <EOL> self . handle_endtag ( tag , method ) <EOL> else : <EOL> self . unknown_endtag ( tag ) <EOL> del self . stack [ - <NUM_LIT:1> ] <EOL> def handle_starttag ( self , tag , method , attrs ) : <EOL> method ( attrs ) <EOL> def handle_endtag ( self , tag , method ) : <EOL> method ( ) <EOL> def report_unbalanced ( self , tag ) : <EOL> if self . verbose : <EOL> print '<STR_LIT>' + tag + '<STR_LIT:>>' <EOL> print '<STR_LIT>' , self . stack <EOL> def convert_charref ( self , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "try :"}, {"prompt": "<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> from colors import blue , cyan , green <EOL>", "answer": "from pants . help . build_dictionary_info_extracter import BuildDictionaryInfoExtracter"}, {"prompt": "<s> from __future__ import print_function <EOL> import os <EOL> import sys <EOL> import qisys . command <EOL> import qisys . error <EOL> import qisys . qixml <EOL> from qisys . qixml import etree <EOL> import qibuild . find <EOL> import qipkg . builder <EOL> import qipkg . package <EOL> from qibuild . test . test_qibuild_deploy import get_ssh_url <EOL> import mock <EOL> import pytest <EOL> def test_ls_package ( qipkg_action , record_messages ) : <EOL> pkg_path = os . path . join ( os . path . dirname ( __file__ ) , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> qipkg_action ( \"<STR_LIT>\" , pkg_path ) <EOL> assert record_messages . find ( \"<STR_LIT>\" ) <EOL> assert record_messages . find ( \"<STR_LIT>\" ) <EOL> def test_make_package ( qipkg_action , qipy_action ) : <EOL> tmpdir = qipy_action . worktree . tmpdir <EOL> qipkg_action . add_test_project ( \"<STR_LIT>\" ) <EOL> qipkg_action . add_test_project ( \"<STR_LIT>\" ) <EOL> c_pkg_proj = qipkg_action . add_test_project ( \"<STR_LIT>\" ) <EOL> qipy_action ( \"<STR_LIT>\" ) <EOL> pml = os . path . join ( c_pkg_proj . path , \"<STR_LIT>\" ) <EOL> qipkg_action ( \"<STR_LIT>\" , pml ) <EOL> qipkg_action ( \"<STR_LIT>\" , pml ) <EOL> pkg = qipkg_action ( \"<STR_LIT>\" , pml ) <EOL> qipkg_action ( \"<STR_LIT>\" , pkg ) <EOL> extracted = tmpdir . join ( \"<STR_LIT>\" ) . strpath <EOL> expected_paths = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> for path in expected_paths : <EOL> full_path = os . path . join ( extracted , path ) <EOL> assert os . path . exists ( full_path ) <EOL> qibuild . find . find_lib ( [ extracted ] , \"<STR_LIT:foo>\" , expect_one = True ) <EOL> def test_extract_package ( qipkg_action , tmpdir ) : <EOL> d_proj = qipkg_action . add_test_project ( \"<STR_LIT>\" ) <EOL> pml = os . path . join ( d_proj . path , \"<STR_LIT>\" ) <EOL> package = qipkg_action ( \"<STR_LIT>\" , pml ) <EOL> dest = tmpdir . join ( \"<STR_LIT>\" ) <EOL> extracted = qipkg_action ( \"<STR_LIT>\" , package , \"<STR_LIT>\" , dest . strpath ) <EOL> assert os . path . exists ( os . path . join ( extracted , \"<STR_LIT>\" ) ) <EOL> def test_make_package_empty_uuid ( qipkg_action ) : <EOL> pml = os . path . join ( os . path . dirname ( __file__ ) , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> error = qipkg_action ( \"<STR_LIT>\" , pml , raises = True ) <EOL> assert \"<STR_LIT>\" in error <EOL> def test_make_package_empty_version ( qipkg_action ) : <EOL> pml = os . path . join ( os . path . dirname ( __file__ ) , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> error = qipkg_action ( \"<STR_LIT>\" , pml , raises = True ) <EOL> assert \"<STR_LIT:version>\" in error <EOL> def test_breakpad_symbols ( qipkg_action ) : <EOL> dump_syms = qisys . command . find_program ( \"<STR_LIT>\" , raises = False ) <EOL> if not dump_syms : <EOL> return <EOL> a_cpp_proj = qipkg_action . add_test_project ( \"<STR_LIT>\" ) <EOL> pml = os . path . join ( a_cpp_proj . path , \"<STR_LIT>\" ) <EOL> qipkg_action ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , pml ) <EOL> qipkg_action ( \"<STR_LIT>\" , pml ) <EOL> pkg , symbols_archive = qipkg_action ( \"<STR_LIT>\" , \"<STR_LIT>\" , pml ) <EOL> assert os . path . exists ( symbols_archive ) <EOL> def test_meta ( qipkg_action ) : <EOL> tmpdir = qipkg_action . worktree . tmpdir <EOL> qipkg_action . add_test_project ( \"<STR_LIT>\" ) <EOL> qipkg_action . add_test_project ( \"<STR_LIT>\" ) <EOL> meta_pkg_proj = qipkg_action . add_test_project ( \"<STR_LIT>\" ) <EOL> meta_pml = os . path . join ( meta_pkg_proj . path , \"<STR_LIT>\" ) <EOL> qipkg_action ( \"<STR_LIT>\" , meta_pml ) <EOL> qipkg_action ( \"<STR_LIT>\" , meta_pml ) <EOL> pkgs = qipkg_action ( \"<STR_LIT>\" , meta_pml ) <EOL> expected_paths = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ] <EOL> actual_paths = [ os . path . basename ( x ) for x in pkgs ] <EOL> assert actual_paths == expected_paths <EOL> def test_no_worktree_pure_pml ( tmpdir , monkeypatch ) : <EOL> project = tmpdir . mkdir ( \"<STR_LIT>\" ) <EOL> project . ensure ( \"<STR_LIT>\" , \"<STR_LIT>\" , file = True ) <EOL> manifest_path = project . join ( \"<STR_LIT>\" ) <EOL> manifest_path . write ( \"\"\"<STR_LIT>\"\"\" ) <EOL> pml_path = project . join ( \"<STR_LIT>\" ) <EOL> pml_path . write ( \"\"\"<STR_LIT>\"\"\" ) <EOL> monkeypatch . chdir ( tmpdir ) <EOL> package = qisys . script . run_action ( \"<STR_LIT>\" , [ pml_path . strpath ] ) <EOL> dest = tmpdir . mkdir ( \"<STR_LIT>\" ) <EOL> monkeypatch . chdir ( dest ) <EOL> qisys . script . run_action ( \"<STR_LIT>\" , [ package ] ) <EOL> assert dest . join ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . check ( file = True ) <EOL> assert dest . join ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) . check ( file = True ) <EOL> def test_no_worktre_bad_pml ( tmpdir , monkeypatch ) : <EOL> project = tmpdir . mkdir ( \"<STR_LIT>\" ) <EOL> manifest_path = project . join ( \"<STR_LIT>\" ) <EOL> manifest_path . write ( \"\"\"<STR_LIT>\"\"\" ) <EOL> pml_path = project . join ( \"<STR_LIT>\" ) <EOL> pml_path . write ( \"\"\"<STR_LIT>\"\"\" ) <EOL> monkeypatch . chdir ( tmpdir ) <EOL> with pytest . raises ( qisys . error . Error ) as error : <EOL> package = qisys . script . run_action ( \"<STR_LIT>\" , [ pml_path . strpath ] ) <EOL> assert \"<STR_LIT>\" in error . value . message <EOL> @ pytest . mark . skipif ( not qisys . command . find_program ( \"<STR_LIT>\" , raises = False ) , <EOL> reason = \"<STR_LIT>\" ) <EOL> def test_translations ( qipkg_action , tmpdir ) : <EOL> tr_project = qipkg_action . add_test_project ( \"<STR_LIT>\" ) <EOL> pml_path = os . path . join ( tr_project . path , \"<STR_LIT>\" ) <EOL> package = qipkg_action ( \"<STR_LIT>\" , pml_path ) <EOL> dest = tmpdir . mkdir ( \"<STR_LIT>\" ) <EOL> qipkg_action . chdir ( dest ) <EOL> qipkg_action ( \"<STR_LIT>\" , package ) <EOL> assert dest . join ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) . check ( file = True ) <EOL> def test_validate_package ( qipkg_action ) : <EOL> pkg_path = os . path . join ( os . path . dirname ( __file__ ) , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> qipkg_action ( \"<STR_LIT>\" , pkg_path ) <EOL> def test_validate_package_exception ( qipkg_action ) : <EOL> pkg_path = os . path . join ( os . path . dirname ( __file__ ) , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> error = qipkg_action ( \"<STR_LIT>\" , pkg_path , raises = True ) <EOL> assert error == \"<STR_LIT>\" <EOL>", "answer": "def test_release_package ( qipkg_action , tmpdir ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import unicode_literals <EOL> from django . contrib . auth . models import Permission <EOL> from django . contrib . contenttypes . models import ContentType <EOL> from django . core . exceptions import ObjectDoesNotExist <EOL> from django . db import models <EOL> from django . contrib . auth import get_user_model <EOL> from django . conf import settings <EOL> from django . utils . translation import ugettext_lazy as _ , ugettext <EOL> from django import VERSION <EOL> from django . utils . encoding import python_2_unicode_compatible <EOL> from helpdesk import settings as helpdesk_settings <EOL> try : <EOL> from django . utils import timezone <EOL> except ImportError : <EOL> from datetime import datetime as timezone <EOL> @ python_2_unicode_compatible <EOL> class Queue ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> title = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:100> , <EOL> ) <EOL> slug = models . SlugField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:50> , <EOL> unique = True , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> email_address = models . EmailField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> locale = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:10> , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> allow_public_submission = models . BooleanField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> default = False , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> allow_email_submission = models . BooleanField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> default = False , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> escalate_days = models . IntegerField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> new_ticket_cc = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> max_length = <NUM_LIT:200> , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> updated_ticket_cc = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> max_length = <NUM_LIT:200> , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> email_box_type = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:5> , <EOL> choices = ( ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) ) , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> email_box_host = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:200> , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> email_box_port = models . IntegerField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> email_box_ssl = models . BooleanField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> default = False , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> email_box_user = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:200> , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> email_box_pass = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:200> , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> email_box_imap_folder = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:100> , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> permission_name = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:50> , <EOL> blank = True , <EOL> null = True , <EOL> editable = False , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> email_box_interval = models . IntegerField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> default = '<STR_LIT:5>' , <EOL> ) <EOL> email_box_last_check = models . DateTimeField ( <EOL> blank = True , <EOL> null = True , <EOL> editable = False , <EOL> ) <EOL> socks_proxy_type = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:8> , <EOL> choices = ( ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) ) , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> socks_proxy_host = models . GenericIPAddressField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> socks_proxy_port = models . IntegerField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> default_owner = models . ForeignKey ( <EOL> settings . AUTH_USER_MODEL , <EOL> related_name = '<STR_LIT>' , <EOL> blank = True , <EOL> null = True , <EOL> verbose_name = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT:%s>\" % self . title <EOL> class Meta : <EOL> ordering = ( '<STR_LIT:title>' , ) <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> verbose_name_plural = _ ( '<STR_LIT>' ) <EOL> def _from_address ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . email_address : <EOL> return u'<STR_LIT>' % settings . DEFAULT_FROM_EMAIL <EOL> else : <EOL> return u'<STR_LIT>' % ( self . title , self . email_address ) <EOL> from_address = property ( _from_address ) <EOL> def prepare_permission_name ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> basename = \"<STR_LIT>\" % self . slug <EOL> self . permission_name = \"<STR_LIT>\" % basename <EOL> return basename <EOL> def save ( self , * args , ** kwargs ) : <EOL> if self . email_box_type == '<STR_LIT>' and not self . email_box_imap_folder : <EOL> self . email_box_imap_folder = '<STR_LIT>' <EOL> if self . socks_proxy_type : <EOL> if not self . socks_proxy_host : <EOL> self . socks_proxy_host = '<STR_LIT:127.0.0.1>' <EOL> if not self . socks_proxy_port : <EOL> self . socks_proxy_port = <NUM_LIT> <EOL> else : <EOL> self . socks_proxy_host = None <EOL> self . socks_proxy_port = None <EOL> if not self . email_box_port : <EOL> if self . email_box_type == '<STR_LIT>' and self . email_box_ssl : <EOL> self . email_box_port = <NUM_LIT> <EOL> elif self . email_box_type == '<STR_LIT>' and not self . email_box_ssl : <EOL> self . email_box_port = <NUM_LIT> <EOL> elif self . email_box_type == '<STR_LIT>' and self . email_box_ssl : <EOL> self . email_box_port = <NUM_LIT> <EOL> elif self . email_box_type == '<STR_LIT>' and not self . email_box_ssl : <EOL> self . email_box_port = <NUM_LIT> <EOL> if not self . id : <EOL> basename = self . prepare_permission_name ( ) <EOL> Permission . objects . create ( <EOL> name = _ ( \"<STR_LIT>\" ) + self . title , <EOL> content_type = ContentType . objects . get ( model = \"<STR_LIT>\" ) , <EOL> codename = basename , <EOL> ) <EOL> super ( Queue , self ) . save ( * args , ** kwargs ) <EOL> def delete ( self , * args , ** kwargs ) : <EOL> permission_name = self . permission_name <EOL> super ( Queue , self ) . delete ( * args , ** kwargs ) <EOL> if permission_name : <EOL> try : <EOL> p = Permission . objects . get ( codename = permission_name [ <NUM_LIT:9> : ] ) <EOL> p . delete ( ) <EOL> except ObjectDoesNotExist : <EOL> pass <EOL> class Ticket ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> OPEN_STATUS = <NUM_LIT:1> <EOL> REOPENED_STATUS = <NUM_LIT:2> <EOL> RESOLVED_STATUS = <NUM_LIT:3> <EOL> CLOSED_STATUS = <NUM_LIT:4> <EOL> DUPLICATE_STATUS = <NUM_LIT:5> <EOL> STATUS_CHOICES = ( <EOL> ( OPEN_STATUS , _ ( '<STR_LIT>' ) ) , <EOL> ( REOPENED_STATUS , _ ( '<STR_LIT>' ) ) , <EOL> ( RESOLVED_STATUS , _ ( '<STR_LIT>' ) ) , <EOL> ( CLOSED_STATUS , _ ( '<STR_LIT>' ) ) , <EOL> ( DUPLICATE_STATUS , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> PRIORITY_CHOICES = ( <EOL> ( <NUM_LIT:1> , _ ( '<STR_LIT>' ) ) , <EOL> ( <NUM_LIT:2> , _ ( '<STR_LIT>' ) ) , <EOL> ( <NUM_LIT:3> , _ ( '<STR_LIT>' ) ) , <EOL> ( <NUM_LIT:4> , _ ( '<STR_LIT>' ) ) , <EOL> ( <NUM_LIT:5> , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> title = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:200> , <EOL> ) <EOL> queue = models . ForeignKey ( <EOL> Queue , <EOL> verbose_name = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> created = models . DateTimeField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> modified = models . DateTimeField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> submitter_email = models . EmailField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> assigned_to = models . ForeignKey ( <EOL> settings . AUTH_USER_MODEL , <EOL> related_name = '<STR_LIT>' , <EOL> blank = True , <EOL> null = True , <EOL> verbose_name = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> status = models . IntegerField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> choices = STATUS_CHOICES , <EOL> default = OPEN_STATUS , <EOL> ) <EOL> on_hold = models . BooleanField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> default = False , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> description = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> resolution = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> priority = models . IntegerField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> choices = PRIORITY_CHOICES , <EOL> default = <NUM_LIT:3> , <EOL> blank = <NUM_LIT:3> , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> due_date = models . DateTimeField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> ) <EOL> last_escalation = models . DateTimeField ( <EOL> blank = True , <EOL> null = True , <EOL> editable = False , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> def _get_assigned_to ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . assigned_to : <EOL> return _ ( '<STR_LIT>' ) <EOL> else : <EOL> if self . assigned_to . get_full_name ( ) : <EOL> return self . assigned_to . get_full_name ( ) <EOL> else : <EOL> return self . assigned_to . get_username ( ) <EOL> get_assigned_to = property ( _get_assigned_to ) <EOL> def _get_ticket ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return u\"<STR_LIT>\" % ( self . ticket_for_url ) <EOL> ticket = property ( _get_ticket ) <EOL> def _get_ticket_for_url ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return u\"<STR_LIT>\" % ( self . queue . slug , self . id ) <EOL> ticket_for_url = property ( _get_ticket_for_url ) <EOL> def _get_priority_img ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from django . conf import settings <EOL> return u\"<STR_LIT>\" % ( settings . MEDIA_URL , self . priority ) <EOL> get_priority_img = property ( _get_priority_img ) <EOL> def _get_priority_css_class ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . priority == <NUM_LIT:2> : <EOL> return \"<STR_LIT>\" <EOL> elif self . priority == <NUM_LIT:1> : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> get_priority_css_class = property ( _get_priority_css_class ) <EOL> def _get_status ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> held_msg = '<STR_LIT>' <EOL> if self . on_hold : held_msg = _ ( '<STR_LIT>' ) <EOL> dep_msg = '<STR_LIT>' <EOL> if self . can_be_resolved == False : dep_msg = _ ( '<STR_LIT>' ) <EOL> return u'<STR_LIT>' % ( self . get_status_display ( ) , held_msg , dep_msg ) <EOL> get_status = property ( _get_status ) <EOL> def _get_ticket_url ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from django . contrib . sites . models import Site <EOL> from django . core . urlresolvers import reverse <EOL> try : <EOL> site = Site . objects . get_current ( ) <EOL> except : <EOL> site = Site ( domain = '<STR_LIT>' ) <EOL> return u\"<STR_LIT>\" % ( <EOL> site . domain , <EOL> reverse ( '<STR_LIT>' ) , <EOL> self . ticket_for_url , <EOL> self . submitter_email <EOL> ) <EOL> ticket_url = property ( _get_ticket_url ) <EOL> def _get_staff_url ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from django . contrib . sites . models import Site <EOL> from django . core . urlresolvers import reverse <EOL> try : <EOL> site = Site . objects . get_current ( ) <EOL> except : <EOL> site = Site ( domain = '<STR_LIT>' ) <EOL> return u\"<STR_LIT>\" % ( <EOL> site . domain , <EOL> reverse ( '<STR_LIT>' , <EOL> args = [ self . id ] ) <EOL> ) <EOL> staff_url = property ( _get_staff_url ) <EOL> def _can_be_resolved ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> OPEN_STATUSES = ( Ticket . OPEN_STATUS , Ticket . REOPENED_STATUS ) <EOL> return TicketDependency . objects . filter ( ticket = self ) . filter ( depends_on__status__in = OPEN_STATUSES ) . count ( ) == <NUM_LIT:0> <EOL> can_be_resolved = property ( _can_be_resolved ) <EOL> class Meta : <EOL> get_latest_by = \"<STR_LIT>\" <EOL> ordering = ( '<STR_LIT:id>' , ) <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> verbose_name_plural = _ ( '<STR_LIT>' ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % ( self . id , self . title ) <EOL> def get_absolute_url ( self ) : <EOL> return ( '<STR_LIT>' , ( self . id , ) ) <EOL> get_absolute_url = models . permalink ( get_absolute_url ) <EOL> def save ( self , * args , ** kwargs ) : <EOL> if not self . id : <EOL> self . created = timezone . now ( ) <EOL> if not self . priority : <EOL> self . priority = <NUM_LIT:3> <EOL> self . modified = timezone . now ( ) <EOL> super ( Ticket , self ) . save ( * args , ** kwargs ) <EOL> class FollowUpManager ( models . Manager ) : <EOL> def private_followups ( self ) : <EOL> return self . filter ( public = False ) <EOL> def public_followups ( self ) : <EOL> return self . filter ( public = True ) <EOL> @ python_2_unicode_compatible <EOL> class FollowUp ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ticket = models . ForeignKey ( <EOL> Ticket , <EOL> verbose_name = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> date = models . DateTimeField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> default = timezone . now <EOL> ) <EOL> title = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:200> , <EOL> blank = True , <EOL> null = True , <EOL> ) <EOL> comment = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> ) <EOL> public = models . BooleanField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> default = False , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> user = models . ForeignKey ( <EOL> settings . AUTH_USER_MODEL , <EOL> blank = True , <EOL> null = True , <EOL> verbose_name = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> new_status = models . IntegerField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> choices = Ticket . STATUS_CHOICES , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> objects = FollowUpManager ( ) <EOL> class Meta : <EOL> ordering = [ '<STR_LIT:date>' ] <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> verbose_name_plural = _ ( '<STR_LIT>' ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT:%s>' % self . title <EOL> def get_absolute_url ( self ) : <EOL> return u\"<STR_LIT>\" % ( self . ticket . get_absolute_url ( ) , self . id ) <EOL> def save ( self , * args , ** kwargs ) : <EOL> t = self . ticket <EOL> t . modified = timezone . now ( ) <EOL> t . save ( ) <EOL> super ( FollowUp , self ) . save ( * args , ** kwargs ) <EOL> @ python_2_unicode_compatible <EOL> class TicketChange ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> followup = models . ForeignKey ( <EOL> FollowUp , <EOL> verbose_name = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> field = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:100> , <EOL> ) <EOL> old_value = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> ) <EOL> new_value = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> ) <EOL> def __str__ ( self ) : <EOL> out = '<STR_LIT>' % self . field <EOL> if not self . new_value : <EOL> out += ugettext ( '<STR_LIT>' ) <EOL> elif not self . old_value : <EOL> out += ugettext ( '<STR_LIT>' ) % self . new_value <EOL> else : <EOL> out += ugettext ( '<STR_LIT>' ) % { <EOL> '<STR_LIT>' : self . old_value , <EOL> '<STR_LIT>' : self . new_value <EOL> } <EOL> return out <EOL> class Meta : <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> verbose_name_plural = _ ( '<STR_LIT>' ) <EOL> def attachment_path ( instance , filename ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> from django . conf import settings <EOL> os . umask ( <NUM_LIT:0> ) <EOL> path = '<STR_LIT>' % ( instance . followup . ticket . ticket_for_url , instance . followup . id ) <EOL> att_path = os . path . join ( settings . MEDIA_ROOT , path ) <EOL> if settings . DEFAULT_FILE_STORAGE == \"<STR_LIT>\" : <EOL> if not os . path . exists ( att_path ) : <EOL> os . makedirs ( att_path , <NUM_LIT> ) <EOL> return os . path . join ( path , filename ) <EOL> @ python_2_unicode_compatible <EOL> class Attachment ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> followup = models . ForeignKey ( <EOL> FollowUp , <EOL> verbose_name = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> file = models . FileField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> upload_to = attachment_path , <EOL> max_length = <NUM_LIT:1000> , <EOL> ) <EOL> filename = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:1000> , <EOL> ) <EOL> mime_type = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:255> , <EOL> ) <EOL> size = models . IntegerField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> def get_upload_to ( self , field_attname ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . id : <EOL> return u'<STR_LIT>' <EOL> return u'<STR_LIT>' % ( <EOL> self . followup . ticket . ticket_for_url , <EOL> self . followup . id <EOL> ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT:%s>' % self . filename <EOL> class Meta : <EOL> ordering = [ '<STR_LIT:filename>' , ] <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> verbose_name_plural = _ ( '<STR_LIT>' ) <EOL> @ python_2_unicode_compatible <EOL> class PreSetReply ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> queues = models . ManyToManyField ( <EOL> Queue , <EOL> blank = True , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> name = models . CharField ( <EOL> _ ( '<STR_LIT:Name>' ) , <EOL> max_length = <NUM_LIT:100> , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> body = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> class Meta : <EOL> ordering = [ '<STR_LIT:name>' , ] <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> verbose_name_plural = _ ( '<STR_LIT>' ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT:%s>' % self . name <EOL> @ python_2_unicode_compatible <EOL> class EscalationExclusion ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> queues = models . ManyToManyField ( <EOL> Queue , <EOL> blank = True , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> name = models . CharField ( <EOL> _ ( '<STR_LIT:Name>' ) , <EOL> max_length = <NUM_LIT:100> , <EOL> ) <EOL> date = models . DateField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT:%s>' % self . name <EOL> class Meta : <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> verbose_name_plural = _ ( '<STR_LIT>' ) <EOL> @ python_2_unicode_compatible <EOL> class EmailTemplate ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> template_name = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:100> , <EOL> ) <EOL> subject = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:100> , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> heading = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:100> , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> plain_text = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> html = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> locale = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:10> , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT:%s>' % self . template_name <EOL> class Meta : <EOL> ordering = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> verbose_name_plural = _ ( '<STR_LIT>' ) <EOL> @ python_2_unicode_compatible <EOL> class KBCategory ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> title = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:100> , <EOL> ) <EOL> slug = models . SlugField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> ) <EOL> description = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT:%s>' % self . title <EOL> class Meta : <EOL> ordering = [ '<STR_LIT:title>' , ] <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> verbose_name_plural = _ ( '<STR_LIT>' ) <EOL> def get_absolute_url ( self ) : <EOL> return ( '<STR_LIT>' , ( ) , { '<STR_LIT>' : self . slug } ) <EOL> get_absolute_url = models . permalink ( get_absolute_url ) <EOL> @ python_2_unicode_compatible <EOL> class KBItem ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> category = models . ForeignKey ( <EOL> KBCategory , <EOL> verbose_name = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> title = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:100> , <EOL> ) <EOL> question = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> ) <EOL> answer = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> ) <EOL> votes = models . IntegerField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> default = <NUM_LIT:0> , <EOL> ) <EOL> recommendations = models . IntegerField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> default = <NUM_LIT:0> , <EOL> ) <EOL> last_updated = models . DateTimeField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> blank = True , <EOL> ) <EOL> def save ( self , * args , ** kwargs ) : <EOL> if not self . last_updated : <EOL> self . last_updated = timezone . now ( ) <EOL> return super ( KBItem , self ) . save ( * args , ** kwargs ) <EOL> def _score ( self ) : <EOL> if self . votes > <NUM_LIT:0> : <EOL> return int ( self . recommendations / self . votes ) <EOL> else : <EOL> return _ ( '<STR_LIT>' ) <EOL> score = property ( _score ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT:%s>' % self . title <EOL> class Meta : <EOL> ordering = [ '<STR_LIT:title>' , ] <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> verbose_name_plural = _ ( '<STR_LIT>' ) <EOL> def get_absolute_url ( self ) : <EOL> return ( '<STR_LIT>' , ( self . id , ) ) <EOL> get_absolute_url = models . permalink ( get_absolute_url ) <EOL> @ python_2_unicode_compatible <EOL> class SavedSearch ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> user = models . ForeignKey ( <EOL> settings . AUTH_USER_MODEL , <EOL> verbose_name = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> title = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:100> , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> shared = models . BooleanField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> default = False , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> query = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> def __str__ ( self ) : <EOL> if self . shared : <EOL> return '<STR_LIT>' % self . title <EOL> else : <EOL> return '<STR_LIT:%s>' % self . title <EOL> class Meta : <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> verbose_name_plural = _ ( '<STR_LIT>' ) <EOL> @ python_2_unicode_compatible <EOL> class UserSettings ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> user = models . OneToOneField ( settings . AUTH_USER_MODEL ) <EOL> settings_pickled = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> ) <EOL> def _set_settings ( self , data ) : <EOL> try : <EOL> import pickle <EOL> except ImportError : <EOL> import cPickle as pickle <EOL> from helpdesk . lib import b64encode <EOL> self . settings_pickled = b64encode ( pickle . dumps ( data ) ) <EOL> def _get_settings ( self ) : <EOL> try : <EOL> import pickle <EOL> except ImportError : <EOL> import cPickle as pickle <EOL> from helpdesk . lib import b64decode <EOL> try : <EOL> return pickle . loads ( b64decode ( str ( self . settings_pickled ) ) ) <EOL> except pickle . UnpicklingError : <EOL> return { } <EOL> settings = property ( _get_settings , _set_settings ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % self . user <EOL> class Meta : <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> verbose_name_plural = _ ( '<STR_LIT>' ) <EOL> def create_usersettings ( sender , instance , created , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from helpdesk . settings import DEFAULT_USER_SETTINGS <EOL> if created : <EOL> UserSettings . objects . create ( user = instance , settings = DEFAULT_USER_SETTINGS ) <EOL> try : <EOL> if VERSION < ( <NUM_LIT:1> , <NUM_LIT:7> ) : <EOL> raise ValueError <EOL> models . signals . post_save . connect ( create_usersettings , sender = settings . AUTH_USER_MODEL ) <EOL> except : <EOL> signal_user = get_user_model ( ) <EOL> models . signals . post_save . connect ( create_usersettings , sender = signal_user ) <EOL> @ python_2_unicode_compatible <EOL> class IgnoreEmail ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> queues = models . ManyToManyField ( <EOL> Queue , <EOL> blank = True , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> name = models . CharField ( <EOL> _ ( '<STR_LIT:Name>' ) , <EOL> max_length = <NUM_LIT:100> , <EOL> ) <EOL> date = models . DateField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> editable = False <EOL> ) <EOL> email_address = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT> , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> keep_in_mailbox = models . BooleanField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> default = False , <EOL> help_text = _ ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) , <EOL> ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT:%s>' % self . name <EOL> def save ( self , * args , ** kwargs ) : <EOL> if not self . date : <EOL> self . date = timezone . now ( ) <EOL> return super ( IgnoreEmail , self ) . save ( * args , ** kwargs ) <EOL> def test ( self , email ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> own_parts = self . email_address . split ( \"<STR_LIT:@>\" ) <EOL> email_parts = email . split ( \"<STR_LIT:@>\" ) <EOL> if self . email_address == email or own_parts [ <NUM_LIT:0> ] == \"<STR_LIT:*>\" and own_parts [ <NUM_LIT:1> ] == email_parts [ <NUM_LIT:1> ] or own_parts [ <NUM_LIT:1> ] == \"<STR_LIT:*>\" and own_parts [ <NUM_LIT:0> ] == email_parts [ <NUM_LIT:0> ] or own_parts [ <NUM_LIT:0> ] == \"<STR_LIT:*>\" and own_parts [ <NUM_LIT:1> ] == \"<STR_LIT:*>\" : <EOL> return True <EOL> else : <EOL> return False <EOL> class Meta : <EOL> verbose_name = _ ( '<STR_LIT>' ) <EOL> verbose_name_plural = _ ( '<STR_LIT>' ) <EOL> @ python_2_unicode_compatible <EOL> class TicketCC ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ticket = models . ForeignKey ( <EOL> Ticket , <EOL> verbose_name = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> user = models . ForeignKey ( <EOL> settings . AUTH_USER_MODEL , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> verbose_name = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> email = models . EmailField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> can_view = models . BooleanField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> default = False , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> can_update = models . BooleanField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> default = False , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> def _email_address ( self ) : <EOL> if self . user and self . user . email is not None : <EOL> return self . user . email <EOL> else : <EOL> return self . email <EOL> email_address = property ( _email_address ) <EOL> def _display ( self ) : <EOL> if self . user : <EOL> return self . user <EOL> else : <EOL> return self . email <EOL> display = property ( _display ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % ( self . display , self . ticket . title ) <EOL> class CustomFieldManager ( models . Manager ) : <EOL> def get_queryset ( self ) : <EOL> return super ( CustomFieldManager , self ) . get_queryset ( ) . order_by ( '<STR_LIT>' ) <EOL> @ python_2_unicode_compatible <EOL> class CustomField ( models . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> name = models . SlugField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> unique = True , <EOL> ) <EOL> label = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:30> , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> help_text = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True <EOL> ) <EOL> DATA_TYPE_CHOICES = ( <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT:text>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT:list>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT:date>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT:time>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT:email>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT:url>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , _ ( '<STR_LIT>' ) ) , <EOL> ) <EOL> data_type = models . CharField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> max_length = <NUM_LIT:100> , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> choices = DATA_TYPE_CHOICES , <EOL> ) <EOL> max_length = models . IntegerField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> ) <EOL> decimal_places = models . IntegerField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> ) <EOL> empty_selection_list = models . BooleanField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> default = False , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> ) <EOL> list_values = models . TextField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> ) <EOL> ordering = models . IntegerField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> blank = True , <EOL> null = True , <EOL> ) <EOL> def _choices_as_array ( self ) : <EOL> from StringIO import StringIO <EOL> valuebuffer = StringIO ( self . list_values ) <EOL> choices = [ [ item . strip ( ) , item . strip ( ) ] for item in valuebuffer . readlines ( ) ] <EOL> valuebuffer . close ( ) <EOL> return choices <EOL> choices_as_array = property ( _choices_as_array ) <EOL> required = models . BooleanField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> default = False , <EOL> ) <EOL> staff_only = models . BooleanField ( <EOL> _ ( '<STR_LIT>' ) , <EOL> help_text = _ ( '<STR_LIT>' ) , <EOL> default = False , <EOL> ) <EOL> objects = CustomFieldManager ( ) <EOL>", "answer": "def __str__ ( self ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> try : <EOL>", "answer": "import urllib . request as url_lib"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from rlpy . Domains import InfCartPoleBalance <EOL> from rlpy . Agents import Q_Learning <EOL> from rlpy . Representations import * <EOL> from rlpy . Policies import eGreedy <EOL> from rlpy . Experiments import Experiment <EOL> import numpy as np <EOL> from hyperopt import hp <EOL> param_space = { <EOL> \"<STR_LIT>\" : hp . qloguniform ( \"<STR_LIT>\" , np . log ( <NUM_LIT> ) , np . log ( <NUM_LIT> ) , <NUM_LIT:1> ) , <EOL> '<STR_LIT>' : hp . quniform ( \"<STR_LIT>\" , <NUM_LIT:3> , <NUM_LIT:30> , <NUM_LIT:1> ) , <EOL> '<STR_LIT>' : hp . uniform ( \"<STR_LIT>\" , <NUM_LIT:0.> , <NUM_LIT:1.> ) , <EOL> '<STR_LIT>' : hp . loguniform ( \"<STR_LIT>\" , np . log ( <NUM_LIT> ) , np . log ( <NUM_LIT> ) ) , <EOL> '<STR_LIT>' : hp . loguniform ( \"<STR_LIT>\" , np . log ( <NUM_LIT> ) , np . log ( <NUM_LIT:1> ) ) } <EOL> def make_experiment ( <EOL> exp_id = <NUM_LIT:1> , path = \"<STR_LIT>\" , <EOL> boyan_N0 = <NUM_LIT> , <EOL> initial_learn_rate = <NUM_LIT> , <EOL> resolution = <NUM_LIT> , <EOL> num_rbfs = <NUM_LIT> , <EOL> lambda_ = <NUM_LIT> ) : <EOL> opt = { } <EOL> opt [ \"<STR_LIT>\" ] = exp_id <EOL> opt [ \"<STR_LIT:path>\" ] = path <EOL>", "answer": "opt [ \"<STR_LIT>\" ] = <NUM_LIT>"}, {"prompt": "<s> from __future__ import print_function <EOL> import numpy as np <EOL> import numba . unittest_support as unittest <EOL> from numba . compiler import compile_isolated , Flags <EOL> from numba import numpy_support , types <EOL> from . support import TestCase , tag <EOL> enable_pyobj_flags = Flags ( ) <EOL> enable_pyobj_flags . set ( \"<STR_LIT>\" ) <EOL> force_pyobj_flags = Flags ( ) <EOL> force_pyobj_flags . set ( \"<STR_LIT>\" ) <EOL> no_pyobj_flags = Flags ( ) <EOL> def int_tuple_iter_usecase ( ) : <EOL> res = <NUM_LIT:0> <EOL> for i in ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT> , <NUM_LIT:3> ) : <EOL> res += i <EOL> return res <EOL> def float_tuple_iter_usecase ( ) : <EOL> res = <NUM_LIT:0.0> <EOL> for i in ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) : <EOL> res += i <EOL> return res <EOL> def tuple_tuple_iter_usecase ( ) : <EOL> res = <NUM_LIT:0.0> <EOL> for i in ( ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) ) : <EOL> for j in i : <EOL> res += j <EOL> res = res * <NUM_LIT:2> <EOL> return res <EOL> def enumerate_nested_tuple_usecase ( ) : <EOL> res = <NUM_LIT:0.0> <EOL> for i , j in enumerate ( ( ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) ) ) : <EOL> for l in j : <EOL> res += i * l <EOL> res = res * <NUM_LIT:2> <EOL> return res <EOL> def nested_enumerate_usecase ( ) : <EOL> res = <NUM_LIT:0.0> <EOL> for i , ( j , k ) in enumerate ( enumerate ( ( ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT> , <NUM_LIT> ) ) ) ) : <EOL> for l in k : <EOL> res += i * j * l <EOL> res = res * <NUM_LIT:2> <EOL> return res <EOL> def scalar_iter_usecase ( iterable ) : <EOL> res = <NUM_LIT:0.0> <EOL> for x in iterable : <EOL> res += x <EOL> return res <EOL> def record_iter_usecase ( iterable ) : <EOL> res = <NUM_LIT:0.0> <EOL> for x in iterable : <EOL> res += x . a * x . b <EOL> return res <EOL> def record_iter_mutate_usecase ( iterable ) : <EOL> for x in iterable : <EOL> x . a = x . a + x . b <EOL> record_dtype = np . dtype ( [ ( '<STR_LIT:a>' , np . float64 ) , <EOL> ( '<STR_LIT:b>' , np . int32 ) , <EOL> ] ) <EOL> class IterationTest ( TestCase ) : <EOL> def run_nullary_func ( self , pyfunc , flags ) : <EOL> cr = compile_isolated ( pyfunc , ( ) , flags = flags ) <EOL> cfunc = cr . entry_point <EOL> expected = pyfunc ( ) <EOL> self . assertPreciseEqual ( cfunc ( ) , expected ) <EOL> def test_int_tuple_iter ( self , flags = force_pyobj_flags ) : <EOL> self . run_nullary_func ( int_tuple_iter_usecase , flags ) <EOL> @ tag ( '<STR_LIT>' ) <EOL> def test_int_tuple_iter_npm ( self ) : <EOL> self . test_int_tuple_iter ( flags = no_pyobj_flags ) <EOL> def test_float_tuple_iter ( self , flags = force_pyobj_flags ) : <EOL> self . run_nullary_func ( float_tuple_iter_usecase , flags ) <EOL> def test_float_tuple_iter_npm ( self ) : <EOL> self . test_float_tuple_iter ( flags = no_pyobj_flags ) <EOL> def test_tuple_tuple_iter ( self , flags = force_pyobj_flags ) : <EOL> self . run_nullary_func ( tuple_tuple_iter_usecase , flags ) <EOL> @ tag ( '<STR_LIT>' ) <EOL> def test_tuple_tuple_iter_npm ( self ) : <EOL> self . test_tuple_tuple_iter ( flags = no_pyobj_flags ) <EOL> def test_enumerate_nested_tuple ( self , flags = force_pyobj_flags ) : <EOL> self . run_nullary_func ( enumerate_nested_tuple_usecase , flags ) <EOL> @ tag ( '<STR_LIT>' ) <EOL> def test_enumerate_nested_tuple_npm ( self ) : <EOL> self . test_enumerate_nested_tuple ( flags = no_pyobj_flags ) <EOL> def test_nested_enumerate ( self , flags = force_pyobj_flags ) : <EOL> self . run_nullary_func ( nested_enumerate_usecase , flags ) <EOL> @ tag ( '<STR_LIT>' ) <EOL> def test_nested_enumerate_npm ( self ) : <EOL> self . test_nested_enumerate ( flags = no_pyobj_flags ) <EOL> def run_array_1d ( self , item_type , arg , flags ) : <EOL> pyfunc = scalar_iter_usecase <EOL> cr = compile_isolated ( pyfunc , ( types . Array ( item_type , <NUM_LIT:1> , '<STR_LIT:A>' ) , ) , <EOL> item_type , flags = flags ) <EOL> cfunc = cr . entry_point <EOL> self . assertPreciseEqual ( cfunc ( arg ) , pyfunc ( arg ) ) <EOL> def test_array_1d_float ( self , flags = force_pyobj_flags ) : <EOL> self . run_array_1d ( types . float64 , np . arange ( <NUM_LIT> ) , flags ) <EOL> def test_array_1d_float_npm ( self ) : <EOL> self . test_array_1d_float ( no_pyobj_flags ) <EOL> def test_array_1d_complex ( self , flags = force_pyobj_flags ) : <EOL> self . run_array_1d ( types . complex128 , np . arange ( <NUM_LIT> ) * <NUM_LIT> , flags ) <EOL> @ tag ( '<STR_LIT>' ) <EOL> def test_array_1d_complex_npm ( self ) : <EOL> self . test_array_1d_complex ( no_pyobj_flags ) <EOL> def test_array_1d_record ( self , flags = force_pyobj_flags ) : <EOL> pyfunc = record_iter_usecase <EOL> item_type = numpy_support . from_dtype ( record_dtype ) <EOL>", "answer": "cr = compile_isolated ( pyfunc , ( types . Array ( item_type , <NUM_LIT:1> , '<STR_LIT:A>' ) , ) ,"}, {"prompt": "<s> import datetime <EOL> import logging <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . create_table ( '<STR_LIT>' , ( <EOL> ( '<STR_LIT:value>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT> ) ) , <EOL> ( '<STR_LIT:id>' , self . gf ( '<STR_LIT>' ) ( primary_key = True ) ) , <EOL> ( '<STR_LIT:key>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT:20> ) ) , <EOL> ( '<STR_LIT:user>' , self . gf ( '<STR_LIT>' ) ( to = orm [ '<STR_LIT>' ] ) ) , <EOL> ) ) <EOL> db . send_create_signal ( '<STR_LIT>' , [ '<STR_LIT>' ] ) <EOL> def backwards ( self , orm ) : <EOL> db . delete_table ( '<STR_LIT>' ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL>", "answer": "'<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import conf <EOL> def is_word ( token ) : <EOL> return not ( token . startswith ( \"<STR_LIT>\" ) or token in conf . PUNCTUATIONS ) <EOL> def is_pause ( token ) : <EOL> return token . startswith ( \"<STR_LIT>\" ) <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL> assert len ( sys . argv ) > <NUM_LIT:1> , \"<STR_LIT>\" <EOL> file_path = sys . argv [ <NUM_LIT:1> ] <EOL> with open ( file_path , '<STR_LIT:r>' ) as source : <EOL>", "answer": "with open ( file_path + \"<STR_LIT>\" , '<STR_LIT:w>' ) as target :"}, {"prompt": "<s> from nailgun . test . base import BaseIntegrationTest <EOL> from nailgun . utils import reverse <EOL> from oslo_serialization import jsonutils <EOL> class TestAssignmentHandlers ( BaseIntegrationTest ) : <EOL> def setUp ( self ) : <EOL> super ( TestAssignmentHandlers , self ) . setUp ( ) <EOL> self . cluster = self . env . create ( <EOL> cluster_kwargs = { \"<STR_LIT>\" : True } , <EOL> nodes_kwargs = [ { } ] <EOL> ) <EOL> self . link_data = { <EOL> '<STR_LIT:title>' : '<STR_LIT>' , <EOL> '<STR_LIT:url>' : '<STR_LIT>' , <EOL> '<STR_LIT:description>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : False , <EOL> } <EOL>", "answer": "def test_cluster_plugin_links_list_empty ( self ) :"}, {"prompt": "<s> from tastypie . resources import Resource as TastyResource <EOL> from tastypie . resources import ModelResource as TastyModelResource <EOL> from django . conf . urls . defaults import url <EOL> from django . core . exceptions import ObjectDoesNotExist , MultipleObjectsReturned <EOL> from tastytools import fields <EOL> from test . resources import TestData <EOL> from django . http import HttpResponse <EOL> from django . utils import simplejson <EOL> from tastypie import http <EOL> from tastytools . authentication import AuthenticationByMethod <EOL> from tastypie . authentication import Authentication <EOL> from tastypie . exceptions import ImmediateHttpResponse <EOL> from tastypie . utils import trailing_slash <EOL> import inspect <EOL> class Resource ( TastyResource ) : <EOL> resource_uri = fields . CharField ( help_text = '<STR_LIT>' , <EOL> readonly = True ) <EOL> class ModelResource ( TastyModelResource ) : <EOL> resource_uri = fields . CharField ( help_text = '<STR_LIT>' , <EOL> readonly = True ) <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ModelResource , self ) . __init__ ( * args , ** kwargs ) <EOL> for field_name , field_object in self . fields . items ( ) : <EOL> if field_name in getattr ( self . _meta , \"<STR_LIT>\" , [ ] ) : <EOL> field_object . readonly = True <EOL> def IHR ( self , response_class , data , request = None ) : <EOL> return ImmediateHttpResponse ( self . create_response ( <EOL> request , data , response_class ) ) <EOL> def save_m2m ( self , bundle ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for field_name , field_object in self . fields . items ( ) : <EOL> if not getattr ( field_object , '<STR_LIT>' , False ) : <EOL> continue <EOL> if not field_object . attribute : <EOL> continue <EOL> if field_object . readonly : <EOL> continue <EOL> if inspect . isfunction ( field_object . attribute ) : <EOL> continue <EOL> related_mngr = getattr ( bundle . obj , field_object . attribute ) <EOL> if hasattr ( related_mngr , '<STR_LIT>' ) : <EOL> related_mngr . clear ( ) <EOL> related_objs = [ ] <EOL> for related_bundle in bundle . data [ field_name ] : <EOL> related_bundle . obj . save ( ) <EOL> related_objs . append ( related_bundle . obj ) <EOL> if not hasattr ( related_mngr , '<STR_LIT>' ) : <EOL> func = \"<STR_LIT>\" % field_name <EOL> if not hasattr ( self , func ) : <EOL> msg = \"<STR_LIT>\" <EOL> msg %= ( field_name , func ) <EOL> raise Exception ( msg ) <EOL> getattr ( self , func ) ( bundle , related_objs ) <EOL> else : <EOL> related_mngr . add ( * related_objs ) <EOL> def apply_authorization_limits ( self , request , object_list ) : <EOL> if request is not None and request . method in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> json_data = simplejson . loads ( request . raw_post_data ) <EOL> for key in json_data . keys ( ) : <EOL> fld = self . fields . get ( key , None ) <EOL> if fld is not None and getattr ( fld , \"<STR_LIT>\" , False ) : <EOL> response = http . HttpUnauthorized ( \"<STR_LIT>\" ) <EOL> raise ImmediateHttpResponse ( response = response ) <EOL> return object_list <EOL> def method_requires_auth ( self , method ) : <EOL> if isinstance ( self . _meta . authentication , AuthenticationByMethod ) : <EOL> anon_methods = self . _meta . authentication . allowed_methods <EOL> elif isinstance ( self . _meta . authentication , Authentication ) : <EOL> anon_methods = self . _meta . allowed_methods <EOL> else : <EOL> anon_methods = [ ] <EOL> if method in anon_methods : <EOL> return False <EOL> else : <EOL> return True <EOL> def can_patch ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> list_allowed = self . _meta . list_allowed_methods <EOL> detail_allowed = self . _meta . detail_allowed_methods <EOL> allowed = set ( list_allowed + detail_allowed ) <EOL> return '<STR_LIT>' in allowed <EOL> def base_urls ( self ) : <EOL> urls = [ ] <EOL> urlexp = r'<STR_LIT>' <EOL> urlexp %= self . _meta . resource_name <EOL> urls . append ( url ( urlexp , self . wrap_view ( '<STR_LIT>' ) , <EOL> name = '<STR_LIT>' ) ) <EOL> urlexp_2 = r'<STR_LIT>' <EOL> urlexp_2 %= self . _meta . resource_name <EOL> urls . append ( url ( urlexp_2 , self . wrap_view ( '<STR_LIT>' ) , <EOL> name = '<STR_LIT>' ) ) <EOL> upload_url = r\"<STR_LIT>\" <EOL> upload_url %= ( self . _meta . resource_name , trailing_slash ( ) ) <EOL> urls . append ( url ( upload_url , self . wrap_view ( \"<STR_LIT>\" ) , <EOL> name = \"<STR_LIT>\" ) ) <EOL> urls += super ( ModelResource , self ) . base_urls ( ) <EOL> return urls <EOL> def attach_upload ( self , request , resource_name , pk , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> obj = self . cached_obj_get ( <EOL> request = request , pk = pk , <EOL> ** self . remove_api_resource_names ( kwargs ) ) <EOL> except ObjectDoesNotExist : <EOL> return http . HttpNotFound ( ) <EOL> except MultipleObjectsReturned : <EOL> return http . HttpMultipleChoices ( <EOL> \"<STR_LIT>\" ) <EOL> for field_name in getattr ( self . _meta , \"<STR_LIT>\" , [ ] ) : <EOL> uploaded_file = request . FILES . get ( field_name , None ) <EOL> if uploaded_file is not None : <EOL> setattr ( obj , field_name , uploaded_file ) <EOL> obj . save ( ) <EOL> bundle = self . build_bundle ( obj = obj , request = request ) <EOL> bundle = self . full_dehydrate ( bundle ) <EOL> bundle = self . alter_detail_data_to_serialize ( request , bundle ) <EOL> return self . create_response ( request , bundle , http . HttpAccepted ) <EOL> def create_test_resource ( self , force = False , * args , ** kwargs ) : <EOL> force = force or { } <EOL> try : <EOL> return self . _meta . testdata . create_test_resource ( force = force , * args , <EOL> ** kwargs ) <EOL> except AttributeError as e : <EOL> msg = \"<STR_LIT>\" <EOL> msg %= ( e , self . __class__ . __name__ ) <EOL> raise Exception ( msg ) <EOL> def create_test_model ( self , data = None , * args , ** kwargs ) : <EOL> if data is None : <EOL> data = { } <EOL> return self . _meta . testdata . create_test_model ( data , * args , ** kwargs ) <EOL> def get_test_post_data ( self , data = None ) : <EOL> if data is None : <EOL> data = { } <EOL> out = self . _meta . testdata . post <EOL> if isinstance ( out , TestData ) : <EOL> out = out . data <EOL> return out <EOL> def get_testdata_data_view ( self , request , api_name = None , <EOL> resource_name = None ) : <EOL>", "answer": "if self . _meta . testdata is not None :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Creature ( )"}, {"prompt": "<s> import datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> depends_on = ( <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ) <EOL>", "answer": "def forwards ( self , orm ) :"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> __all__ = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> from kivy . vector import Vector <EOL> def circumcircle ( a , b , c ) : <EOL> '''<STR_LIT>''' <EOL> P = Vector ( a [ <NUM_LIT:0> ] , a [ <NUM_LIT:1> ] ) <EOL> Q = Vector ( b [ <NUM_LIT:0> ] , b [ <NUM_LIT:1> ] ) <EOL> R = Vector ( c [ <NUM_LIT:0> ] , c [ <NUM_LIT:1> ] ) <EOL> mPQ = ( P + Q ) * <NUM_LIT> <EOL> mQR = ( Q + R ) * <NUM_LIT> <EOL> numer = - ( - mPQ . y * R . y + mPQ . y * Q . y + mQR . y * R . y - mQR . y * Q . y <EOL> - mPQ . x * R . x + mPQ . x * Q . x + mQR . x * R . x - mQR . x * Q . x ) <EOL> denom = ( - Q . x * R . y + P . x * R . y - P . x * Q . y + <EOL> Q . y * R . x - P . y * R . x + P . y * Q . x ) <EOL> t = numer / denom <EOL> cx = - t * ( Q . y - P . y ) + mPQ . x <EOL> cy = t * ( Q . x - P . x ) + mPQ . y <EOL> return ( ( cx , cy ) , ( P - ( cx , cy ) ) . length ( ) ) <EOL> def minimum_bounding_circle ( points ) : <EOL> '''<STR_LIT>''' <EOL> points = [ Vector ( p [ <NUM_LIT:0> ] , p [ <NUM_LIT:1> ] ) for p in points ] <EOL> if len ( points ) == <NUM_LIT:1> : <EOL> return ( points [ <NUM_LIT:0> ] . x , points [ <NUM_LIT:0> ] . y ) , <NUM_LIT:0.0> <EOL> if len ( points ) == <NUM_LIT:2> : <EOL> p1 , p2 = points <EOL> return ( p1 + p2 ) * <NUM_LIT> , ( ( p1 - p2 ) * <NUM_LIT> ) . length ( ) <EOL> P = min ( points , key = lambda p : p . y ) <EOL> def x_axis_angle ( q ) : <EOL> if q == P : <EOL> return <NUM_LIT> <EOL> return abs ( ( q - P ) . angle ( ( <NUM_LIT:1> , <NUM_LIT:0> ) ) ) <EOL> Q = min ( points , key = x_axis_angle ) <EOL> for p in points : <EOL> def angle_pq ( r ) : <EOL> if r in ( P , Q ) : <EOL> return <NUM_LIT> <EOL> return abs ( ( r - P ) . angle ( r - Q ) ) <EOL> R = min ( points , key = angle_pq ) <EOL> if angle_pq ( R ) > <NUM_LIT> : <EOL> return ( P + Q ) * <NUM_LIT> , ( ( P - Q ) * <NUM_LIT> ) . length ( ) <EOL> if abs ( ( R - P ) . angle ( Q - P ) ) > <NUM_LIT> : <EOL> P = R <EOL>", "answer": "continue"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from OpenSSL import rand , crypto , SSL <EOL> from OpenSSL . version import ( <EOL> __author__ , __copyright__ , __email__ , __license__ , __summary__ , __title__ , <EOL>", "answer": "__uri__ , __version__ ,"}, {"prompt": "<s> import json <EOL> import os <EOL> import tempfile <EOL> import unittest <EOL> import mock <EOL> import six <EOL> from shutil import rmtree <EOL> from swiftlm . utils import utility <EOL> from swiftlm . utils . utility import RingDeviceEntry <EOL> from swiftlm . utils . values import Severity , ServerType <EOL> if six . PY2 : <EOL> BUILTIN_OPEN = '<STR_LIT>' <EOL> COMMANDS_MODULE = '<STR_LIT>' <EOL> else : <EOL> BUILTIN_OPEN = '<STR_LIT>' <EOL> COMMANDS_MODULE = '<STR_LIT>' <EOL> class TestUtility ( unittest . TestCase ) : <EOL> @ mock . patch ( '<STR_LIT>' ) <EOL> def test_server_type ( self , mock_isfile ) : <EOL> mock_isfile . return_value = True <EOL> expected = { <EOL> '<STR_LIT:object>' : True , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : True <EOL> } <EOL> actual = utility . server_type ( ) <EOL> self . assertDictEqual ( expected , actual ) <EOL> is_o = utility . server_type ( ServerType . object ) <EOL> self . assertTrue ( is_o ) <EOL> is_o , is_a = utility . server_type ( ServerType . object , ServerType . account ) <EOL> self . assertTrue ( is_o ) <EOL> self . assertTrue ( is_a ) <EOL> with self . assertRaisesRegexp ( ValueError , '<STR_LIT>' ) : <EOL> utility . server_type ( '<STR_LIT:test>' ) <EOL> @ mock . patch ( COMMANDS_MODULE + '<STR_LIT>' ) <EOL> def test_ip_to_interface ( self , mock_command ) : <EOL> mock_data = '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT:\\n>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT:\\n>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT:\\n>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT:\\n>' '<STR_LIT>' '<STR_LIT:\\n>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' <EOL> mock_command . return_value = mock_data <EOL> d = utility . ip_to_interface ( ) <EOL> self . assertEqual ( d , { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' } ) <EOL> class TestDumpUptimeStatsFile ( unittest . TestCase ) : <EOL> def test_file_truncated ( self ) : <EOL> testdir = tempfile . mkdtemp ( ) <EOL> fake_logger = mock . MagicMock ( ) <EOL> data = json . dumps ( [ { '<STR_LIT>' : '<STR_LIT:foo>' , <EOL>", "answer": "'<STR_LIT>' : {"}, {"prompt": "<s> import logging <EOL> import tornado . autoreload <EOL> import tornado . ioloop <EOL> import tornado . web <EOL> from pfrock . core . web import MyApplication <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class PFrock ( object ) : <EOL> def __init__ ( self , auto_reload = True , port = <NUM_LIT> ) : <EOL> self . app = MyApplication ( autoreload = True ) <EOL> self . auto_reload = auto_reload <EOL>", "answer": "self . port = port"}, {"prompt": "<s> from hedwig . stats import scorefunctions <EOL> from hedwig . stats import adjustment <EOL> from hedwig . stats import significance <EOL>", "answer": "from hedwig . stats . validate import Validate"}, {"prompt": "<s> import json <EOL> from django . http import HttpResponse <EOL> from django . views . decorators . http import require_POST <EOL> from django . views . decorators . csrf import csrf_exempt <EOL> from tapiriik . auth import User <EOL> from tapiriik . sync import Sync , SynchronizationTask <EOL> from tapiriik . database import db <EOL> from tapiriik . services import Service <EOL> from tapiriik . settings import MONGO_FULL_WRITE_CONCERN <EOL> from datetime import datetime <EOL> import zlib <EOL> def sync_status ( req ) : <EOL> if not req . user : <EOL> return HttpResponse ( status = <NUM_LIT> ) <EOL> stats = db . stats . find_one ( ) <EOL> syncHash = <NUM_LIT:1> <EOL> conns = User . GetConnectionRecordsByUser ( req . user ) <EOL> def svc_id ( svc ) : <EOL> return svc . Service . ID <EOL> def err_msg ( err ) : <EOL> return err [ \"<STR_LIT>\" ] <EOL> for conn in sorted ( conns , key = svc_id ) : <EOL> syncHash = zlib . adler32 ( bytes ( conn . HasExtendedAuthorizationDetails ( ) ) , syncHash ) <EOL> if not hasattr ( conn , \"<STR_LIT>\" ) : <EOL> continue <EOL> for err in sorted ( conn . SyncErrors , key = err_msg ) : <EOL> syncHash = zlib . adler32 ( bytes ( err_msg ( err ) , \"<STR_LIT>\" ) , syncHash ) <EOL> pendingSyncTime = req . user [ \"<STR_LIT>\" ] if \"<STR_LIT>\" in req . user else None <EOL> if \"<STR_LIT>\" in req . user and req . user [ \"<STR_LIT>\" ] : <EOL> pendingSyncTime = req . user [ \"<STR_LIT>\" ] <EOL> sync_status_dict = { \"<STR_LIT>\" : ( pendingSyncTime . ctime ( ) + \"<STR_LIT>\" ) if pendingSyncTime else None , <EOL> \"<STR_LIT>\" : ( req . user [ \"<STR_LIT>\" ] . ctime ( ) + \"<STR_LIT>\" ) if \"<STR_LIT>\" in req . user and req . user [ \"<STR_LIT>\" ] is not None else None , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" in req . user , <EOL> \"<STR_LIT>\" : req . user [ \"<STR_LIT>\" ] if \"<STR_LIT>\" in req . user else None , <EOL> \"<STR_LIT>\" : req . user [ \"<STR_LIT>\" ] if \"<STR_LIT>\" in req . user else None , <EOL> \"<STR_LIT>\" : None , <EOL> \"<STR_LIT>\" : syncHash } <EOL> if stats and \"<STR_LIT>\" in stats : <EOL> sync_status_dict [ \"<STR_LIT>\" ] = ( stats [ \"<STR_LIT>\" ] - ( datetime . utcnow ( ) - req . user [ \"<STR_LIT>\" ] ) . total_seconds ( ) ) if \"<STR_LIT>\" in req . user and req . user [ \"<STR_LIT>\" ] is not None else None <EOL> return HttpResponse ( json . dumps ( sync_status_dict ) , content_type = \"<STR_LIT:application/json>\" ) <EOL> def sync_recent_activity ( req ) : <EOL> if not req . user : <EOL> return HttpResponse ( status = <NUM_LIT> ) <EOL> res = SynchronizationTask . RecentSyncActivity ( req . user ) <EOL> return HttpResponse ( json . dumps ( res ) , content_type = \"<STR_LIT:application/json>\" ) <EOL> @ require_POST <EOL> def sync_schedule_immediate ( req ) : <EOL> if not req . user : <EOL> return HttpResponse ( status = <NUM_LIT> ) <EOL> if \"<STR_LIT>\" in req . user and req . user [ \"<STR_LIT>\" ] is not None and datetime . utcnow ( ) - req . user [ \"<STR_LIT>\" ] < Sync . MinimumSyncInterval : <EOL> return HttpResponse ( status = <NUM_LIT> ) <EOL> exhaustive = None <EOL> if \"<STR_LIT>\" in req . user and req . user [ \"<STR_LIT>\" ] is not None and datetime . utcnow ( ) - req . user [ \"<STR_LIT>\" ] > Sync . MaximumIntervalBeforeExhaustiveSync : <EOL> exhaustive = True <EOL> Sync . ScheduleImmediateSync ( req . user , exhaustive ) <EOL> return HttpResponse ( ) <EOL> @ require_POST <EOL> def sync_clear_errorgroup ( req , service , group ) : <EOL> if not req . user : <EOL> return HttpResponse ( status = <NUM_LIT> ) <EOL> rec = User . GetConnectionRecord ( req . user , service ) <EOL> if not rec : <EOL> return HttpResponse ( status = <NUM_LIT> ) <EOL> to_clear_count = <NUM_LIT:0> <EOL> for x in rec . SyncErrors : <EOL> if \"<STR_LIT>\" in x and \"<STR_LIT>\" in x [ \"<STR_LIT>\" ] and x [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] == group : <EOL> to_clear_count += <NUM_LIT:1> <EOL> if to_clear_count > <NUM_LIT:0> : <EOL> db . connections . update ( { \"<STR_LIT>\" : rec . _id } , { \"<STR_LIT>\" : { \"<STR_LIT>\" : { \"<STR_LIT>\" : group } } } ) <EOL> db . users . update ( { \"<STR_LIT>\" : req . user [ \"<STR_LIT>\" ] } , { '<STR_LIT>' : { \"<STR_LIT>\" : - to_clear_count } } ) <EOL> Sync . ScheduleImmediateSync ( req . user , True ) <EOL> return HttpResponse ( ) <EOL> return HttpResponse ( status = <NUM_LIT> ) <EOL>", "answer": "@ csrf_exempt"}, {"prompt": "<s> from django . db . models import F <EOL> from django . contrib . auth . models import User <EOL> from django . core . management . base import BaseCommand <EOL> from hc . accounts . models import Profile <EOL> from hc . api . models import Ping <EOL> class Command ( BaseCommand ) : <EOL> help = '<STR_LIT>' <EOL> def handle ( self , * args , ** options ) : <EOL> for user in User . objects . filter ( profile = None ) : <EOL> Profile . objects . for_user ( user ) <EOL> q = Ping . objects <EOL> q = q . annotate ( limit = F ( \"<STR_LIT>\" ) ) <EOL> q = q . filter ( n__lt = F ( \"<STR_LIT>\" ) - F ( \"<STR_LIT>\" ) ) <EOL>", "answer": "q = q . filter ( n__gt = <NUM_LIT:0> )"}, {"prompt": "<s> from itertools import count <EOL> import uuid <EOL> from django . contrib . auth . models import User <EOL> from django . db import models <EOL> from tastypie . utils import now , aware_datetime <EOL> class DateRecord ( models . Model ) : <EOL> date = models . DateField ( ) <EOL> username = models . CharField ( max_length = <NUM_LIT:20> ) <EOL> message = models . CharField ( max_length = <NUM_LIT:20> ) <EOL> class Note ( models . Model ) : <EOL> author = models . ForeignKey ( User , related_name = '<STR_LIT>' , blank = True , null = True ) <EOL> title = models . CharField ( \"<STR_LIT>\" , max_length = <NUM_LIT:100> ) <EOL> slug = models . SlugField ( ) <EOL> content = models . TextField ( blank = True ) <EOL> is_active = models . BooleanField ( default = True ) <EOL> created = models . DateTimeField ( default = now ) <EOL> updated = models . DateTimeField ( default = now ) <EOL> def __unicode__ ( self ) : <EOL> return self . title <EOL> def save ( self , * args , ** kwargs ) : <EOL> self . updated = now ( ) <EOL> return super ( Note , self ) . save ( * args , ** kwargs ) <EOL> def what_time_is_it ( self ) : <EOL> return aware_datetime ( <NUM_LIT> , <NUM_LIT:4> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT> ) <EOL>", "answer": "def get_absolute_url ( self ) :"}, {"prompt": "<s> from django import forms <EOL> from django . contrib import admin <EOL> from . models import ( <EOL> Author , BinaryTree , CapoFamiglia , Chapter , ChildModel1 , ChildModel2 , <EOL> Consigliere , EditablePKBook , ExtraTerrestrial , Fashionista , Holder , <EOL> Holder2 , Holder3 , Holder4 , Inner , Inner2 , Inner3 , Inner4Stacked , <EOL> Inner4Tabular , NonAutoPKBook , Novel , ParentModelWithCustomPk , Poll , <EOL> Profile , ProfileCollection , Question , ReadOnlyInline , ShoppingWeakness , <EOL>", "answer": "Sighting , SomeChildModel , SomeParentModel , SottoCapo , Title ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import saml2 <EOL> from saml2 import SamlBase <EOL> NAMESPACE = '<STR_LIT>' <EOL> class PhysicalVerification ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , '<STR_LIT:None>' , False ) <EOL> def __init__ ( self , <EOL> credential_level = None , <EOL> text = None , <EOL> extension_elements = None , <EOL> extension_attributes = None , <EOL> ) : <EOL> SamlBase . __init__ ( self , <EOL> text = text , <EOL> extension_elements = extension_elements , <EOL> extension_attributes = extension_attributes , <EOL> ) <EOL> self . credential_level = credential_level <EOL> def physical_verification_from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( PhysicalVerification , xml_string ) <EOL> class Generation ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , '<STR_LIT:None>' , True ) <EOL> def __init__ ( self , <EOL> mechanism = None , <EOL> text = None , <EOL> extension_elements = None , <EOL> extension_attributes = None , <EOL> ) : <EOL> SamlBase . __init__ ( self , <EOL> text = text , <EOL> extension_elements = extension_elements , <EOL> extension_attributes = extension_attributes , <EOL> ) <EOL> self . mechanism = mechanism <EOL> def generation_from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( Generation , xml_string ) <EOL> class NymType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_value_type = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] } <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> def nym_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( NymType_ , xml_string ) <EOL> class GoverningAgreementRefType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> c_attributes [ '<STR_LIT>' ] = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , True ) <EOL> def __init__ ( self , <EOL> governing_agreement_ref = None , <EOL> text = None , <EOL> extension_elements = None , <EOL> extension_attributes = None , <EOL> ) : <EOL> SamlBase . __init__ ( self , <EOL> text = text , <EOL> extension_elements = extension_elements , <EOL> extension_attributes = extension_attributes , <EOL> ) <EOL> self . governing_agreement_ref = governing_agreement_ref <EOL> def governing_agreement_ref_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( GoverningAgreementRefType_ , <EOL> xml_string ) <EOL> class KeySharingType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , '<STR_LIT>' , True ) <EOL> def __init__ ( self , <EOL> sharing = None , <EOL> text = None , <EOL> extension_elements = None , <EOL> extension_attributes = None , <EOL> ) : <EOL> SamlBase . __init__ ( self , <EOL> text = text , <EOL> extension_elements = extension_elements , <EOL> extension_attributes = extension_attributes , <EOL> ) <EOL> self . sharing = sharing <EOL> def key_sharing_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( KeySharingType_ , xml_string ) <EOL> class RestrictedLengthType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , '<STR_LIT:None>' , True ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , '<STR_LIT>' , False ) <EOL> def __init__ ( self , <EOL> min = None , <EOL> max = None , <EOL> text = None , <EOL> extension_elements = None , <EOL> extension_attributes = None , <EOL> ) : <EOL> SamlBase . __init__ ( self , <EOL> text = text , <EOL> extension_elements = extension_elements , <EOL> extension_attributes = extension_attributes , <EOL> ) <EOL> self . min = min <EOL> self . max = max <EOL> def restricted_length_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( RestrictedLengthType_ , xml_string ) <EOL> class AlphabetType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , '<STR_LIT:string>' , True ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , '<STR_LIT:string>' , False ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , '<STR_LIT:string>' , False ) <EOL> def __init__ ( self , <EOL> required_chars = None , <EOL> excluded_chars = None , <EOL> case = None , <EOL> text = None , <EOL> extension_elements = None , <EOL> extension_attributes = None , <EOL> ) : <EOL> SamlBase . __init__ ( self , <EOL> text = text , <EOL> extension_elements = extension_elements , <EOL> extension_attributes = extension_attributes , <EOL> ) <EOL> self . required_chars = required_chars <EOL> self . excluded_chars = excluded_chars <EOL> self . case = case <EOL> def alphabet_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( AlphabetType_ , xml_string ) <EOL> class DeviceTypeType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_value_type = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' ] } <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> def device_type_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( DeviceTypeType_ , xml_string ) <EOL> class BooleanType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_value_type = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : [ '<STR_LIT:true>' , '<STR_LIT:false>' ] } <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> def boolean_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( BooleanType_ , xml_string ) <EOL> class TimeSyncTokenType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , DeviceTypeType_ , True ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , '<STR_LIT>' , True ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , BooleanType_ , True ) <EOL> def __init__ ( self , <EOL> device_type = None , <EOL> seed_length = None , <EOL> device_in_hand = None , <EOL> text = None , <EOL> extension_elements = None , <EOL> extension_attributes = None , <EOL> ) : <EOL> SamlBase . __init__ ( self , <EOL> text = text , <EOL> extension_elements = extension_elements , <EOL> extension_attributes = extension_attributes , <EOL> ) <EOL> self . device_type = device_type <EOL> self . seed_length = seed_length <EOL> self . device_in_hand = device_in_hand <EOL> def time_sync_token_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( TimeSyncTokenType_ , xml_string ) <EOL> class ActivationLimitDurationType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , '<STR_LIT>' , True ) <EOL> def __init__ ( self , <EOL> duration = None , <EOL> text = None , <EOL> extension_elements = None , <EOL> extension_attributes = None , <EOL> ) : <EOL> SamlBase . __init__ ( self , <EOL> text = text , <EOL> extension_elements = extension_elements , <EOL> extension_attributes = extension_attributes , <EOL> ) <EOL> self . duration = duration <EOL> def activation_limit_duration_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( ActivationLimitDurationType_ , <EOL> xml_string ) <EOL> class ActivationLimitUsagesType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , '<STR_LIT>' , True ) <EOL> def __init__ ( self , <EOL> number = None , <EOL> text = None , <EOL> extension_elements = None , <EOL> extension_attributes = None , <EOL> ) : <EOL> SamlBase . __init__ ( self , <EOL> text = text , <EOL> extension_elements = extension_elements , <EOL> extension_attributes = extension_attributes , <EOL> ) <EOL> self . number = number <EOL> def activation_limit_usages_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( ActivationLimitUsagesType_ , <EOL> xml_string ) <EOL> class ActivationLimitSessionType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> def activation_limit_session_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( ActivationLimitSessionType_ , <EOL> xml_string ) <EOL> class LengthType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , '<STR_LIT>' , True ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , '<STR_LIT>' , False ) <EOL> def __init__ ( self , <EOL> min = None , <EOL> max = None , <EOL> text = None , <EOL> extension_elements = None , <EOL> extension_attributes = None , <EOL> ) : <EOL> SamlBase . __init__ ( self , <EOL> text = text , <EOL> extension_elements = extension_elements , <EOL> extension_attributes = extension_attributes , <EOL> ) <EOL> self . min = min <EOL> self . max = max <EOL> def length_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( LengthType_ , xml_string ) <EOL> class MediumType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_value_type = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] } <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> def medium_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( MediumType_ , xml_string ) <EOL> class KeyStorageType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , MediumType_ , True ) <EOL> def __init__ ( self , <EOL> medium = None , <EOL> text = None , <EOL> extension_elements = None , <EOL> extension_attributes = None , <EOL> ) : <EOL> SamlBase . __init__ ( self , <EOL> text = text , <EOL> extension_elements = extension_elements , <EOL> extension_attributes = extension_attributes , <EOL> ) <EOL> self . medium = medium <EOL> def key_storage_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( KeyStorageType_ , xml_string ) <EOL> class ExtensionType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> def extension_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( ExtensionType_ , xml_string ) <EOL> class PublicKeyType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL> c_cardinality = SamlBase . c_cardinality . copy ( ) <EOL> c_attributes [ '<STR_LIT>' ] = ( '<STR_LIT>' , '<STR_LIT>' , False ) <EOL> def __init__ ( self , <EOL> key_validation = \"<STR_LIT>\" , <EOL> text = None , <EOL> extension_elements = None , <EOL> extension_attributes = None ) : <EOL> SamlBase . __init__ ( self , <EOL> text = text , <EOL> extension_elements = extension_elements , <EOL> extension_attributes = extension_attributes ) <EOL> def public_key_type__from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( PublicKeyType_ , xml_string ) <EOL> class KeySharing ( KeySharingType_ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = KeySharingType_ . c_children . copy ( ) <EOL> c_attributes = KeySharingType_ . c_attributes . copy ( ) <EOL> c_child_order = KeySharingType_ . c_child_order [ : ] <EOL> c_cardinality = KeySharingType_ . c_cardinality . copy ( ) <EOL> def key_sharing_from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( KeySharing , xml_string ) <EOL> class KeyStorage ( KeyStorageType_ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = KeyStorageType_ . c_children . copy ( ) <EOL> c_attributes = KeyStorageType_ . c_attributes . copy ( ) <EOL> c_child_order = KeyStorageType_ . c_child_order [ : ] <EOL> c_cardinality = KeyStorageType_ . c_cardinality . copy ( ) <EOL> def key_storage_from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( KeyStorage , xml_string ) <EOL> class TimeSyncToken ( TimeSyncTokenType_ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = TimeSyncTokenType_ . c_children . copy ( ) <EOL> c_attributes = TimeSyncTokenType_ . c_attributes . copy ( ) <EOL> c_child_order = TimeSyncTokenType_ . c_child_order [ : ] <EOL> c_cardinality = TimeSyncTokenType_ . c_cardinality . copy ( ) <EOL> def time_sync_token_from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( TimeSyncToken , xml_string ) <EOL> class Length ( LengthType_ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = LengthType_ . c_children . copy ( ) <EOL> c_attributes = LengthType_ . c_attributes . copy ( ) <EOL> c_child_order = LengthType_ . c_child_order [ : ] <EOL> c_cardinality = LengthType_ . c_cardinality . copy ( ) <EOL> def length_from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( Length , xml_string ) <EOL> class DigSig ( PublicKeyType_ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = PublicKeyType_ . c_children . copy ( ) <EOL> c_attributes = PublicKeyType_ . c_attributes . copy ( ) <EOL> c_child_order = PublicKeyType_ . c_child_order [ : ] <EOL> c_cardinality = PublicKeyType_ . c_cardinality . copy ( ) <EOL> def dig_sig_from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( DigSig , xml_string ) <EOL> class AsymmetricDecryption ( PublicKeyType_ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = PublicKeyType_ . c_children . copy ( ) <EOL> c_attributes = PublicKeyType_ . c_attributes . copy ( ) <EOL> c_child_order = PublicKeyType_ . c_child_order [ : ] <EOL> c_cardinality = PublicKeyType_ . c_cardinality . copy ( ) <EOL> def asymmetric_decryption_from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( AsymmetricDecryption , xml_string ) <EOL> class AsymmetricKeyAgreement ( PublicKeyType_ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = PublicKeyType_ . c_children . copy ( ) <EOL> c_attributes = PublicKeyType_ . c_attributes . copy ( ) <EOL> c_child_order = PublicKeyType_ . c_child_order [ : ] <EOL> c_cardinality = PublicKeyType_ . c_cardinality . copy ( ) <EOL> def asymmetric_key_agreement_from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( AsymmetricKeyAgreement , <EOL> xml_string ) <EOL> class GoverningAgreementRef ( GoverningAgreementRefType_ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = GoverningAgreementRefType_ . c_children . copy ( ) <EOL> c_attributes = GoverningAgreementRefType_ . c_attributes . copy ( ) <EOL> c_child_order = GoverningAgreementRefType_ . c_child_order [ : ] <EOL> c_cardinality = GoverningAgreementRefType_ . c_cardinality . copy ( ) <EOL> def governing_agreement_ref_from_string ( xml_string ) : <EOL> return saml2 . create_class_from_xml_string ( GoverningAgreementRef , xml_string ) <EOL> class GoverningAgreementsType_ ( SamlBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> c_tag = '<STR_LIT>' <EOL> c_namespace = NAMESPACE <EOL> c_children = SamlBase . c_children . copy ( ) <EOL> c_attributes = SamlBase . c_attributes . copy ( ) <EOL> c_child_order = SamlBase . c_child_order [ : ] <EOL>", "answer": "c_cardinality = SamlBase . c_cardinality . copy ( )"}, {"prompt": "<s> from tests . compat import mock , unittest <EOL> from boto . dynamodb2 import exceptions <EOL> from boto . dynamodb2 . fields import ( HashKey , RangeKey , <EOL> AllIndex , KeysOnlyIndex , IncludeIndex , <EOL> GlobalAllIndex , GlobalKeysOnlyIndex , <EOL> GlobalIncludeIndex ) <EOL> from boto . dynamodb2 . items import Item <EOL> from boto . dynamodb2 . layer1 import DynamoDBConnection <EOL> from boto . dynamodb2 . results import ResultSet , BatchGetResultSet <EOL> from boto . dynamodb2 . table import Table <EOL> from boto . dynamodb2 . types import ( STRING , NUMBER , BINARY , <EOL> FILTER_OPERATORS , QUERY_OPERATORS ) <EOL> from boto . exception import JSONResponseError <EOL> from boto . compat import six , long_type <EOL> FakeDynamoDBConnection = mock . create_autospec ( DynamoDBConnection ) <EOL> class SchemaFieldsTestCase ( unittest . TestCase ) : <EOL> def test_hash_key ( self ) : <EOL> hash_key = HashKey ( '<STR_LIT:hello>' ) <EOL> self . assertEqual ( hash_key . name , '<STR_LIT:hello>' ) <EOL> self . assertEqual ( hash_key . data_type , STRING ) <EOL> self . assertEqual ( hash_key . attr_type , '<STR_LIT>' ) <EOL> self . assertEqual ( hash_key . definition ( ) , { <EOL> '<STR_LIT>' : '<STR_LIT:hello>' , <EOL> '<STR_LIT>' : '<STR_LIT:S>' <EOL> } ) <EOL> self . assertEqual ( hash_key . schema ( ) , { <EOL> '<STR_LIT>' : '<STR_LIT:hello>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } ) <EOL> def test_range_key ( self ) : <EOL> range_key = RangeKey ( '<STR_LIT:hello>' ) <EOL> self . assertEqual ( range_key . name , '<STR_LIT:hello>' ) <EOL> self . assertEqual ( range_key . data_type , STRING ) <EOL> self . assertEqual ( range_key . attr_type , '<STR_LIT>' ) <EOL> self . assertEqual ( range_key . definition ( ) , { <EOL> '<STR_LIT>' : '<STR_LIT:hello>' , <EOL> '<STR_LIT>' : '<STR_LIT:S>' <EOL> } ) <EOL> self . assertEqual ( range_key . schema ( ) , { <EOL> '<STR_LIT>' : '<STR_LIT:hello>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } ) <EOL> def test_alternate_type ( self ) : <EOL> alt_key = HashKey ( '<STR_LIT>' , data_type = NUMBER ) <EOL> self . assertEqual ( alt_key . name , '<STR_LIT>' ) <EOL> self . assertEqual ( alt_key . data_type , NUMBER ) <EOL> self . assertEqual ( alt_key . attr_type , '<STR_LIT>' ) <EOL> self . assertEqual ( alt_key . definition ( ) , { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT:N>' <EOL> } ) <EOL> self . assertEqual ( alt_key . schema ( ) , { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } ) <EOL> class IndexFieldTestCase ( unittest . TestCase ) : <EOL> def test_all_index ( self ) : <EOL> all_index = AllIndex ( '<STR_LIT>' , parts = [ <EOL> HashKey ( '<STR_LIT:username>' ) , <EOL> RangeKey ( '<STR_LIT>' ) <EOL> ] ) <EOL> self . assertEqual ( all_index . name , '<STR_LIT>' ) <EOL> self . assertEqual ( [ part . attr_type for part in all_index . parts ] , [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] ) <EOL> self . assertEqual ( all_index . projection_type , '<STR_LIT>' ) <EOL> self . assertEqual ( all_index . definition ( ) , [ <EOL> { '<STR_LIT>' : '<STR_LIT:username>' , '<STR_LIT>' : '<STR_LIT:S>' } , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:S>' } <EOL> ] ) <EOL> self . assertEqual ( all_index . schema ( ) , { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT:username>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } ) <EOL> def test_keys_only_index ( self ) : <EOL> keys_only = KeysOnlyIndex ( '<STR_LIT>' , parts = [ <EOL> HashKey ( '<STR_LIT:username>' ) , <EOL> RangeKey ( '<STR_LIT>' ) <EOL> ] ) <EOL> self . assertEqual ( keys_only . name , '<STR_LIT>' ) <EOL> self . assertEqual ( [ part . attr_type for part in keys_only . parts ] , [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] ) <EOL> self . assertEqual ( keys_only . projection_type , '<STR_LIT>' ) <EOL> self . assertEqual ( keys_only . definition ( ) , [ <EOL> { '<STR_LIT>' : '<STR_LIT:username>' , '<STR_LIT>' : '<STR_LIT:S>' } , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:S>' } <EOL> ] ) <EOL> self . assertEqual ( keys_only . schema ( ) , { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT:username>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } ) <EOL> def test_include_index ( self ) : <EOL> include_index = IncludeIndex ( '<STR_LIT>' , parts = [ <EOL> HashKey ( '<STR_LIT:username>' ) , <EOL> RangeKey ( '<STR_LIT>' ) <EOL> ] , includes = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] ) <EOL> self . assertEqual ( include_index . name , '<STR_LIT>' ) <EOL> self . assertEqual ( [ part . attr_type for part in include_index . parts ] , [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] ) <EOL> self . assertEqual ( include_index . projection_type , '<STR_LIT>' ) <EOL> self . assertEqual ( include_index . definition ( ) , [ <EOL> { '<STR_LIT>' : '<STR_LIT:username>' , '<STR_LIT>' : '<STR_LIT:S>' } , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:S>' } <EOL> ] ) <EOL> self . assertEqual ( include_index . schema ( ) , { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT:username>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> } <EOL> } ) <EOL> def test_global_all_index ( self ) : <EOL> all_index = GlobalAllIndex ( '<STR_LIT>' , parts = [ <EOL> HashKey ( '<STR_LIT:username>' ) , <EOL> RangeKey ( '<STR_LIT>' ) <EOL> ] , <EOL> throughput = { <EOL> '<STR_LIT>' : <NUM_LIT:6> , <EOL> '<STR_LIT>' : <NUM_LIT:2> , <EOL> } ) <EOL> self . assertEqual ( all_index . name , '<STR_LIT>' ) <EOL> self . assertEqual ( [ part . attr_type for part in all_index . parts ] , [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] ) <EOL> self . assertEqual ( all_index . projection_type , '<STR_LIT>' ) <EOL> self . assertEqual ( all_index . definition ( ) , [ <EOL> { '<STR_LIT>' : '<STR_LIT:username>' , '<STR_LIT>' : '<STR_LIT:S>' } , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:S>' } <EOL> ] ) <EOL> self . assertEqual ( all_index . schema ( ) , { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT:username>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : <NUM_LIT:6> , <EOL> '<STR_LIT>' : <NUM_LIT:2> <EOL> } <EOL> } ) <EOL> def test_global_keys_only_index ( self ) : <EOL> keys_only = GlobalKeysOnlyIndex ( '<STR_LIT>' , parts = [ <EOL> HashKey ( '<STR_LIT:username>' ) , <EOL> RangeKey ( '<STR_LIT>' ) <EOL> ] , <EOL> throughput = { <EOL> '<STR_LIT>' : <NUM_LIT:3> , <EOL> '<STR_LIT>' : <NUM_LIT:4> , <EOL> } ) <EOL> self . assertEqual ( keys_only . name , '<STR_LIT>' ) <EOL> self . assertEqual ( [ part . attr_type for part in keys_only . parts ] , [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] ) <EOL> self . assertEqual ( keys_only . projection_type , '<STR_LIT>' ) <EOL> self . assertEqual ( keys_only . definition ( ) , [ <EOL> { '<STR_LIT>' : '<STR_LIT:username>' , '<STR_LIT>' : '<STR_LIT:S>' } , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:S>' } <EOL> ] ) <EOL> self . assertEqual ( keys_only . schema ( ) , { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT:username>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : <NUM_LIT:3> , <EOL> '<STR_LIT>' : <NUM_LIT:4> <EOL> } <EOL> } ) <EOL> def test_global_include_index ( self ) : <EOL> include_index = GlobalIncludeIndex ( '<STR_LIT>' , parts = [ <EOL> HashKey ( '<STR_LIT:username>' ) , <EOL> RangeKey ( '<STR_LIT>' ) <EOL> ] , includes = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] ) <EOL> self . assertEqual ( include_index . name , '<STR_LIT>' ) <EOL> self . assertEqual ( [ part . attr_type for part in include_index . parts ] , [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] ) <EOL> self . assertEqual ( include_index . projection_type , '<STR_LIT>' ) <EOL> self . assertEqual ( include_index . definition ( ) , [ <EOL> { '<STR_LIT>' : '<STR_LIT:username>' , '<STR_LIT>' : '<STR_LIT:S>' } , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:S>' } <EOL> ] ) <EOL> self . assertEqual ( include_index . schema ( ) , { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT:username>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : <NUM_LIT:5> , <EOL> '<STR_LIT>' : <NUM_LIT:5> <EOL> } <EOL> } ) <EOL> def test_global_include_index_throughput ( self ) : <EOL> include_index = GlobalIncludeIndex ( '<STR_LIT>' , parts = [ <EOL> HashKey ( '<STR_LIT:username>' ) , <EOL> RangeKey ( '<STR_LIT>' ) <EOL> ] , includes = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] , throughput = { <EOL> '<STR_LIT>' : <NUM_LIT:10> , <EOL> '<STR_LIT>' : <NUM_LIT:8> <EOL> } ) <EOL> self . assertEqual ( include_index . schema ( ) , { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT:username>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL> { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : <NUM_LIT:10> , <EOL> '<STR_LIT>' : <NUM_LIT:8> <EOL> } <EOL> } ) <EOL> class ItemTestCase ( unittest . TestCase ) : <EOL> if six . PY2 : <EOL> assertCountEqual = unittest . TestCase . assertItemsEqual <EOL> def setUp ( self ) : <EOL> super ( ItemTestCase , self ) . setUp ( ) <EOL> self . table = Table ( '<STR_LIT>' , connection = FakeDynamoDBConnection ( ) ) <EOL> self . johndoe = self . create_item ( { <EOL> '<STR_LIT:username>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } ) <EOL> def create_item ( self , data ) : <EOL> return Item ( self . table , data = data ) <EOL> def test_initialization ( self ) : <EOL> empty_item = Item ( self . table ) <EOL> self . assertEqual ( empty_item . table , self . table ) <EOL> self . assertEqual ( empty_item . _data , { } ) <EOL> full_item = Item ( self . table , data = { <EOL> '<STR_LIT:username>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } ) <EOL> self . assertEqual ( full_item . table , self . table ) <EOL> self . assertEqual ( full_item . _data , { <EOL> '<STR_LIT:username>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } ) <EOL> def test_keys ( self ) : <EOL> self . assertCountEqual ( self . johndoe . keys ( ) , [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT:username>' , <EOL> ] ) <EOL> def test_values ( self ) : <EOL> self . assertCountEqual ( self . johndoe . values ( ) , <EOL> [ <NUM_LIT> , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def test_contains ( self ) : <EOL> self . assertIn ( '<STR_LIT:username>' , self . johndoe ) <EOL> self . assertIn ( '<STR_LIT>' , self . johndoe ) <EOL> self . assertIn ( '<STR_LIT>' , self . johndoe ) <EOL> self . assertNotIn ( '<STR_LIT>' , self . johndoe ) <EOL> def test_iter ( self ) : <EOL> self . assertCountEqual ( self . johndoe , <EOL> [ '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> ] ) <EOL> def test_get ( self ) : <EOL> self . assertEqual ( self . johndoe . get ( '<STR_LIT:username>' ) , '<STR_LIT>' ) <EOL> self . assertEqual ( self . johndoe . get ( '<STR_LIT>' ) , '<STR_LIT>' ) <EOL> self . assertEqual ( self . johndoe . get ( '<STR_LIT>' ) , <NUM_LIT> ) <EOL> self . assertEqual ( self . johndoe . get ( '<STR_LIT>' ) , None ) <EOL> self . assertEqual ( self . johndoe . get ( '<STR_LIT>' , True ) , True ) <EOL> def test_items ( self ) : <EOL> self . assertCountEqual ( <EOL> self . johndoe . items ( ) , <EOL> [ <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT:username>' , '<STR_LIT>' ) , <EOL> ] ) <EOL> def test_attribute_access ( self ) : <EOL> self . assertEqual ( self . johndoe [ '<STR_LIT:username>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( self . johndoe [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( self . johndoe [ '<STR_LIT>' ] , <NUM_LIT> ) <EOL> self . assertEqual ( self . johndoe [ '<STR_LIT>' ] , None ) <EOL> self . johndoe [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> self . assertEqual ( self . johndoe [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> del self . johndoe [ '<STR_LIT>' ] <EOL> self . assertEqual ( self . johndoe [ '<STR_LIT>' ] , None ) <EOL> def test_needs_save ( self ) : <EOL> self . johndoe . mark_clean ( ) <EOL> self . assertFalse ( self . johndoe . needs_save ( ) ) <EOL> self . johndoe [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> self . assertTrue ( self . johndoe . needs_save ( ) ) <EOL> def test_needs_save_set_changed ( self ) : <EOL> self . johndoe . mark_clean ( ) <EOL> self . assertFalse ( self . johndoe . needs_save ( ) ) <EOL> self . johndoe [ '<STR_LIT>' ] = set ( [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> self . assertTrue ( self . johndoe . needs_save ( ) ) <EOL> self . johndoe . mark_clean ( ) <EOL> self . assertFalse ( self . johndoe . needs_save ( ) ) <EOL> self . johndoe [ '<STR_LIT>' ] . add ( '<STR_LIT>' ) <EOL> self . assertTrue ( self . johndoe . needs_save ( ) ) <EOL> def test_mark_clean ( self ) : <EOL> self . johndoe [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> self . assertTrue ( self . johndoe . needs_save ( ) ) <EOL> self . johndoe . mark_clean ( ) <EOL> self . assertFalse ( self . johndoe . needs_save ( ) ) <EOL> def test_load ( self ) : <EOL> empty_item = Item ( self . table ) <EOL> empty_item . load ( { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:username>' : { '<STR_LIT:S>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:S>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:S>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:N>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:N>' : '<STR_LIT:3>' } , <EOL> '<STR_LIT>' : { '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] } , <EOL> } <EOL> } ) <EOL> self . assertEqual ( empty_item [ '<STR_LIT:username>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( empty_item [ '<STR_LIT>' ] , <NUM_LIT> ) <EOL> self . assertEqual ( sorted ( empty_item [ '<STR_LIT>' ] ) , sorted ( [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] ) ) <EOL> def test_get_keys ( self ) : <EOL> self . table . schema = [ <EOL> HashKey ( '<STR_LIT:username>' ) , <EOL> RangeKey ( '<STR_LIT>' ) , <EOL> ] <EOL> self . assertEqual ( self . johndoe . get_keys ( ) , { <EOL> '<STR_LIT:username>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> } ) <EOL> def test_get_raw_keys ( self ) : <EOL> self . table . schema = [ <EOL> HashKey ( '<STR_LIT:username>' ) , <EOL> RangeKey ( '<STR_LIT>' ) , <EOL> ] <EOL> self . assertEqual ( self . johndoe . get_raw_keys ( ) , { <EOL> '<STR_LIT:username>' : { '<STR_LIT:S>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT:N>' : '<STR_LIT>' } , <EOL> } ) <EOL> def test_build_expects ( self ) : <EOL> self . assertEqual ( self . johndoe . build_expects ( ) , { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> '<STR_LIT:username>' : { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> } ) <EOL> self . johndoe . mark_clean ( ) <EOL> self . assertEqual ( self . johndoe . build_expects ( ) , { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:S>' : '<STR_LIT>' , <EOL> } , <EOL> } , <EOL> '<STR_LIT:username>' : { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:S>' : '<STR_LIT>' , <EOL> } , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:N>' : '<STR_LIT>' , <EOL> } , <EOL> } , <EOL> } ) <EOL> self . johndoe [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> self . johndoe [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> del self . johndoe [ '<STR_LIT>' ] <EOL> self . assertEqual ( self . johndoe . build_expects ( ) , { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:S>' : '<STR_LIT>' , <EOL> } , <EOL> } , <EOL> '<STR_LIT>' : { <EOL>", "answer": "'<STR_LIT>' : False ,"}, {"prompt": "<s> import unittest <EOL> from whoosh import analysis , fields , index , store , writing <EOL> class TestReading ( unittest . TestCase ) : <EOL> def _create_index ( self ) : <EOL> s = fields . Schema ( f1 = fields . KEYWORD ( stored = True ) , <EOL> f2 = fields . KEYWORD , <EOL> f3 = fields . KEYWORD ) <EOL> st = store . RamStorage ( ) <EOL> ix = index . Index ( st , s , create = True ) <EOL> return ix <EOL> def _one_segment_index ( self ) : <EOL> ix = self . _create_index ( ) <EOL> w = writing . IndexWriter ( ix ) <EOL> w . add_document ( f1 = u\"<STR_LIT>\" , f2 = u\"<STR_LIT>\" , f3 = u\"<STR_LIT>\" ) <EOL> w . add_document ( f1 = u\"<STR_LIT>\" , f2 = u\"<STR_LIT>\" , f3 = u\"<STR_LIT>\" ) <EOL> w . add_document ( f1 = u\"<STR_LIT>\" , f2 = u\"<STR_LIT>\" , f3 = u\"<STR_LIT>\" ) <EOL> w . add_document ( f1 = u\"<STR_LIT>\" , f2 = u\"<STR_LIT>\" , f3 = u\"<STR_LIT>\" ) <EOL> w . add_document ( f1 = u\"<STR_LIT>\" , f2 = u\"<STR_LIT>\" , f3 = u\"<STR_LIT>\" ) <EOL> w . commit ( ) <EOL> return ix <EOL>", "answer": "def _multi_segment_index ( self ) :"}, {"prompt": "<s> __time = __import__ ( '<STR_LIT:time>' ) <EOL> from eventlet . patcher import slurp_properties <EOL> __patched__ = [ '<STR_LIT>' ] <EOL>", "answer": "slurp_properties ( __time , globals ( ) , ignore = __patched__ , srckeys = dir ( __time ) )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import networkx as nx <EOL> from . dinitz_alg import dinitz <EOL> from . edmondskarp import edmonds_karp <EOL> from . preflowpush import preflow_push <EOL> from . shortestaugmentingpath import shortest_augmenting_path <EOL> from . utils import build_flow_dict <EOL> default_flow_func = preflow_push <EOL> flow_funcs = [ dinitz , edmonds_karp , preflow_push , shortest_augmenting_path ] <EOL> __all__ = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> def maximum_flow ( G , s , t , capacity = '<STR_LIT>' , flow_func = None , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if flow_func is None : <EOL> if kwargs : <EOL> raise nx . NetworkXError ( \"<STR_LIT>\" <EOL>", "answer": "\"<STR_LIT>\" )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> class Solution : <EOL> def summaryRanges ( self , nums ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ret = [ ] <EOL> n = len ( nums ) <EOL> if n < <NUM_LIT:1> : <EOL> return ret <EOL> bgn = nums [ <NUM_LIT:0> ] <EOL> pre = nums [ <NUM_LIT:0> ] <EOL> for i in xrange ( <NUM_LIT:1> , n ) : <EOL> if nums [ i ] != pre + <NUM_LIT:1> : <EOL> if pre != bgn : <EOL> ret . append ( \"<STR_LIT>\" % ( bgn , pre ) ) <EOL> else : <EOL> ret . append ( \"<STR_LIT>\" % bgn ) <EOL>", "answer": "bgn = nums [ i ]"}, {"prompt": "<s> from tasks . models import Tasks <EOL> from . base import library <EOL> @ library . register ( '<STR_LIT>' ) <EOL> def dummy_service ( data ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> import time <EOL> import datetime <EOL> from wtforms import fields , widgets <EOL> from flask . ext . admin . babel import gettext <EOL> from flask . ext . admin . _compat import text_type , as_unicode <EOL> from . import widgets as admin_widgets <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> class DateTimeField ( fields . DateTimeField ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> widget = admin_widgets . DateTimePickerWidget ( ) <EOL> def __init__ ( self , label = None , validators = None , format = None , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( DateTimeField , self ) . __init__ ( label , validators , ** kwargs ) <EOL> self . format = format or '<STR_LIT>' <EOL> class TimeField ( fields . Field ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> widget = admin_widgets . TimePickerWidget ( ) <EOL> def __init__ ( self , label = None , validators = None , formats = None , <EOL> default_format = None , widget_format = None , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( TimeField , self ) . __init__ ( label , validators , ** kwargs ) <EOL> self . formats = formats or ( '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . default_format = default_format or '<STR_LIT>' <EOL> def _value ( self ) : <EOL> if self . raw_data : <EOL>", "answer": "return u'<STR_LIT:U+0020>' . join ( self . raw_data )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function <EOL> import hashlib <EOL> import hmac <EOL> import base64 <EOL> def generate_sha512_hmac ( password_salt , password ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return base64 . b64encode ( hmac . new ( password_salt , password . encode ( '<STR_LIT:utf-8>' ) , hashlib . sha512 ) . digest ( ) ) <EOL> def hash_password ( user_manager , password ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if user_manager . password_hash == '<STR_LIT>' : <EOL> return password <EOL> if user_manager . password_hash_mode == '<STR_LIT>' : <EOL> password = generate_sha512_hmac ( user_manager . password_salt , password ) <EOL> hashed_password = user_manager . password_crypt_context . encrypt ( password ) <EOL> return hashed_password <EOL>", "answer": "def verify_password ( user_manager , password , hashed_password ) :"}, {"prompt": "<s> ENABLED = False <EOL> defaultenabledwebapps = [ \"<STR_LIT:*>\" ] <EOL> virtualhosts = { <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:test>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> } <EOL>", "answer": "webroots = {"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import urllib <EOL> import textwrap <EOL> from django . http import HttpResponseRedirect <EOL> from django . core import urlresolvers <EOL> from django . shortcuts import render_to_response <EOL> from django . template import RequestContext <EOL> from django . core . exceptions import ObjectDoesNotExist <EOL> from django . contrib import comments <EOL> def next_redirect ( data , default , default_view , ** get_kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> next = data . get ( \"<STR_LIT>\" , default ) <EOL> if next is None : <EOL> next = urlresolvers . reverse ( default_view ) <EOL> if get_kwargs : <EOL> if '<STR_LIT:#>' in next : <EOL> tmp = next . rsplit ( '<STR_LIT:#>' , <NUM_LIT:1> ) <EOL>", "answer": "next = tmp [ <NUM_LIT:0> ]"}, {"prompt": "<s> import numpy as np <EOL> from pandas . core . base import PandasObject <EOL> from pandas . formats . printing import pprint_thing <EOL> from pandas . sparse . array import SparseArray <EOL> import pandas . _sparse as splib <EOL> import pandas . lib as lib <EOL> class SparseList ( PandasObject ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , data = None , fill_value = np . nan ) : <EOL> self . fill_value = fill_value <EOL> self . _chunks = [ ] <EOL> if data is not None : <EOL> self . append ( data ) <EOL> def __unicode__ ( self ) : <EOL> contents = '<STR_LIT:\\n>' . join ( repr ( c ) for c in self . _chunks ) <EOL> return '<STR_LIT>' % ( object . __repr__ ( self ) , pprint_thing ( contents ) ) <EOL> def __len__ ( self ) : <EOL> return sum ( len ( c ) for c in self . _chunks ) <EOL> def __getitem__ ( self , i ) : <EOL> if i < <NUM_LIT:0> : <EOL> if i + len ( self ) < <NUM_LIT:0> : <EOL> raise ValueError ( '<STR_LIT>' % i ) <EOL> i += len ( self ) <EOL> passed = <NUM_LIT:0> <EOL> j = <NUM_LIT:0> <EOL> while i >= passed + len ( self . _chunks [ j ] ) : <EOL> passed += len ( self . _chunks [ j ] ) <EOL> j += <NUM_LIT:1> <EOL> return self . _chunks [ j ] [ i - passed ] <EOL> def __setitem__ ( self , i , value ) : <EOL> raise NotImplementedError <EOL> @ property <EOL> def nchunks ( self ) : <EOL> return len ( self . _chunks ) <EOL> @ property <EOL> def is_consolidated ( self ) : <EOL> return self . nchunks == <NUM_LIT:1> <EOL> def consolidate ( self , inplace = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not inplace : <EOL> result = self . copy ( ) <EOL> else : <EOL> result = self <EOL> if result . is_consolidated : <EOL> return result <EOL> result . _consolidate_inplace ( ) <EOL> return result <EOL> def _consolidate_inplace ( self ) : <EOL> new_values = np . concatenate ( [ c . sp_values for c in self . _chunks ] ) <EOL> new_index = _concat_sparse_indexes ( [ c . sp_index for c in self . _chunks ] ) <EOL> new_arr = SparseArray ( new_values , sparse_index = new_index , <EOL> fill_value = self . fill_value ) <EOL> self . _chunks = [ new_arr ] <EOL> def copy ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> new_splist = SparseList ( fill_value = self . fill_value ) <EOL> new_splist . _chunks = list ( self . _chunks ) <EOL> return new_splist <EOL> def to_array ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . consolidate ( inplace = True ) <EOL> return self . _chunks [ <NUM_LIT:0> ] <EOL> def append ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if lib . isscalar ( value ) : <EOL> value = [ value ] <EOL> sparr = SparseArray ( value , fill_value = self . fill_value ) <EOL> self . _chunks . append ( sparr ) <EOL> self . _consolidated = False <EOL> def _concat_sparse_indexes ( indexes ) : <EOL> all_indices = [ ] <EOL> total_length = <NUM_LIT:0> <EOL> for index in indexes : <EOL>", "answer": "inds = index . to_int_index ( ) . indices + total_length"}, {"prompt": "<s> class AttributeDictionary ( object ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> d = kwargs <EOL> if args : <EOL> d = args [ <NUM_LIT:0> ] <EOL> super ( AttributeDictionary , self ) . __setattr__ ( \"<STR_LIT>\" , d ) <EOL> def __setattr__ ( self , name , value ) : <EOL> self [ name ] = value <EOL> def __getattr__ ( self , name ) : <EOL> if name in self . __dict__ : <EOL> return self . __dict__ [ name ] <EOL> try : <EOL> return self [ name ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( self . __class__ . __name__ , name ) ) <EOL> def __setitem__ ( self , name , value ) : <EOL> self . _dict [ name ] = self . _convert_value ( value ) <EOL> def __getitem__ ( self , name ) : <EOL> return self . _convert_value ( self . _dict [ name ] ) <EOL> def _convert_value ( self , value ) : <EOL> if isinstance ( value , dict ) and not isinstance ( value , AttributeDictionary ) : <EOL> return AttributeDictionary ( value ) <EOL> return value <EOL> def copy ( self ) : <EOL> return self . __class__ ( self . _dict . copy ( ) ) <EOL> def update ( self , * args , ** kwargs ) : <EOL> self . _dict . update ( * args , ** kwargs ) <EOL> def items ( self ) : <EOL> return self . _dict . items ( ) <EOL> def values ( self ) : <EOL> return self . _dict . values ( ) <EOL> def keys ( self ) : <EOL> return self . _dict . keys ( ) <EOL> def pop ( self , * args , ** kwargs ) : <EOL> return self . _dict . pop ( * args , ** kwargs ) <EOL> def get ( self , * args , ** kwargs ) : <EOL> return self . _dict . get ( * args , ** kwargs ) <EOL> def __repr__ ( self ) : <EOL> return self . _dict . __repr__ ( ) <EOL> def __unicode__ ( self ) : <EOL> return self . _dict . __unicode__ ( ) <EOL>", "answer": "def __str__ ( self ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import TestGyp <EOL> import os <EOL> import sys <EOL> def ls ( path ) : <EOL> '''<STR_LIT>''' <EOL> result = [ ] <EOL> for dirpath , _ , files in os . walk ( path ) : <EOL> for f in files : <EOL> result . append ( os . path . join ( dirpath , f ) [ len ( path ) + <NUM_LIT:1> : ] ) <EOL> return result <EOL> if sys . platform == '<STR_LIT>' : <EOL> test = TestGyp . TestGyp ( formats = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> test . run_gyp ( '<STR_LIT>' , chdir = '<STR_LIT>' ) <EOL> test . build ( '<STR_LIT>' , '<STR_LIT>' , chdir = '<STR_LIT>' ) <EOL> test . built_file_must_exist ( <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> from __future__ import ( <EOL> absolute_import , <EOL> print_function , <EOL> unicode_literals , <EOL>", "answer": ")"}, {"prompt": "<s> import gevent <EOL> import time , socket <EOL> socket . setdefaulttimeout ( <NUM_LIT> ) <EOL>", "answer": "class Speed ( ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from airflow import DAG <EOL> from airflow . operators import SimpleHttpOperator , HttpSensor <EOL> from datetime import datetime , timedelta <EOL> import json <EOL> seven_days_ago = datetime . combine ( datetime . today ( ) - timedelta ( <NUM_LIT:7> ) , <EOL> datetime . min . time ( ) ) <EOL> default_args = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : seven_days_ago , <EOL> '<STR_LIT:email>' : [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : False , <EOL>", "answer": "'<STR_LIT>' : <NUM_LIT:1> ,"}, {"prompt": "<s> from __future__ import print_function <EOL> import unittest <EOL> import numpy as np <EOL> import pyGPs <EOL> class InfTests ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . x = np . random . normal ( loc = <NUM_LIT:0.0> , scale = <NUM_LIT:1.0> , size = ( <NUM_LIT:20> , <NUM_LIT:2> ) ) <EOL> self . y = np . random . normal ( loc = <NUM_LIT:0.0> , scale = <NUM_LIT:1.0> , size = ( <NUM_LIT:20> , <NUM_LIT:1> ) ) <EOL> self . u = np . random . random ( size = ( <NUM_LIT:5> , <NUM_LIT:2> ) ) <EOL> def checkInferenceOutput ( self , post , nlZ , dnlZ ) : <EOL> n , D = self . x . shape <EOL> self . assertTrue ( post . alpha . shape [ <NUM_LIT:0> ] == n ) <EOL> self . assertTrue ( post . L . shape == ( n , n ) ) <EOL> self . assertTrue ( post . sW . shape == ( n , <NUM_LIT:1> ) ) <EOL> self . assertTrue ( type ( nlZ ) is np . float64 ) <EOL> for entry in dnlZ . mean : <EOL> self . assertTrue ( type ( entry ) is np . float64 ) <EOL> for entry in dnlZ . cov : <EOL> self . assertTrue ( type ( entry ) is np . float64 ) <EOL> for entry in dnlZ . lik : <EOL> self . assertTrue ( type ( entry ) is np . float64 ) <EOL> def checkFITCOutput ( self , post , nlZ , dnlZ ) : <EOL> n , D = self . x . shape <EOL> nu , D = self . u . shape <EOL> self . assertTrue ( post . alpha . shape [ <NUM_LIT:0> ] == nu ) <EOL> self . assertTrue ( post . L . shape == ( nu , nu ) ) <EOL> self . assertTrue ( post . sW . shape == ( n , <NUM_LIT:1> ) ) <EOL> self . assertTrue ( type ( nlZ ) is np . float64 ) <EOL> for entry in dnlZ . mean : <EOL> self . assertTrue ( type ( entry ) is np . float64 ) <EOL> for entry in dnlZ . cov : <EOL> self . assertTrue ( type ( entry ) is np . float64 ) <EOL> for entry in dnlZ . lik : <EOL> self . assertTrue ( type ( entry ) is np . float64 ) <EOL> def test_infExact ( self ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> inffunc = pyGPs . inf . Exact ( ) <EOL> meanfunc = pyGPs . mean . Zero ( ) <EOL> covfunc = pyGPs . cov . RBF ( ) <EOL> likfunc = pyGPs . lik . Gauss ( ) <EOL> post , nlZ , dnlZ = inffunc . evaluate ( meanfunc , covfunc , likfunc , self . x , self . y , nargout = <NUM_LIT:3> ) <EOL> self . checkInferenceOutput ( post , nlZ , dnlZ ) <EOL> def test_infFITC_Exact ( self ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> inffunc = pyGPs . inf . FITC_Exact ( ) <EOL> meanfunc = pyGPs . mean . Zero ( ) <EOL> covfunc = pyGPs . cov . RBF ( ) . fitc ( self . u ) <EOL> likfunc = pyGPs . lik . Gauss ( ) <EOL> post , nlZ , dnlZ = inffunc . evaluate ( meanfunc , covfunc , likfunc , self . x , self . y , nargout = <NUM_LIT:3> ) <EOL> self . checkFITCOutput ( post , nlZ , dnlZ ) <EOL> def test_infEP ( self ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> inffunc = pyGPs . inf . EP ( ) <EOL> meanfunc = pyGPs . mean . Zero ( ) <EOL> covfunc = pyGPs . cov . RBF ( ) <EOL> likfunc = pyGPs . lik . Gauss ( ) <EOL> post , nlZ , dnlZ = inffunc . evaluate ( meanfunc , covfunc , likfunc , self . x , self . y , nargout = <NUM_LIT:3> ) <EOL> self . checkInferenceOutput ( post , nlZ , dnlZ ) <EOL> def test_infFITC_EP ( self ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> inffunc = pyGPs . inf . FITC_EP ( ) <EOL> meanfunc = pyGPs . mean . Zero ( ) <EOL> covfunc = pyGPs . cov . RBF ( ) . fitc ( self . u ) <EOL> likfunc = pyGPs . lik . Gauss ( ) <EOL> post , nlZ , dnlZ = inffunc . evaluate ( meanfunc , covfunc , likfunc , self . x , self . y , nargout = <NUM_LIT:3> ) <EOL> self . checkFITCOutput ( post , nlZ , dnlZ ) <EOL> def test_infLaplace ( self ) : <EOL> print ( \"<STR_LIT>\" ) <EOL>", "answer": "inffunc = pyGPs . inf . Laplace ( )"}, {"prompt": "<s> from corehq . preindex import get_preindex_plugin <EOL> from corehq . util . couch_helpers import paginate_view <EOL> from dimagi . utils . chunked import chunked <EOL> def _get_all_docs_dbs ( ) : <EOL> return get_preindex_plugin ( '<STR_LIT>' ) . get_dbs ( '<STR_LIT>' ) <EOL> def get_all_doc_ids_for_domain_grouped_by_db ( domain ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for db in _get_all_docs_dbs ( ) : <EOL>", "answer": "results = db . view ("}, {"prompt": "<s> from django import forms <EOL>", "answer": "class LoginForm ( forms . Form ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> def gqn ( val ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( val , basestring ) : <EOL> if isinstance ( val , unicode ) : val = val . encode ( '<STR_LIT:ascii>' ) <EOL> return \"<STR_LIT>\" % val <EOL> else : <EOL> return str ( val ) <EOL> class SpatialOperation ( object ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "import TestGyp"}, {"prompt": "<s> import json <EOL> import uuid <EOL> import types <EOL> import os <EOL> import hashlib <EOL> import OpenSSL . crypto <EOL> import base64 <EOL> from collections import Counter <EOL> from twisted . internet import defer , task , reactor <EOL> from kademlia . network import Server <EOL> from kademlia . protocol import KademliaProtocol <EOL> from kademlia import crawling <EOL> from kademlia . utils import deferredDict , digest <EOL> from kademlia . storage import ForgetfulStorage <EOL> from kademlia . node import Node , NodeHeap <EOL> from kademlia import version as kademlia_version <EOL> from calvin . utilities import certificate <EOL> from calvin . utilities import calvinlogger <EOL> from calvin . utilities import calvinconfig <EOL> _conf = calvinconfig . get ( ) <EOL> _log = calvinlogger . get_logger ( __name__ ) <EOL> def logger ( node , message , level = None ) : <EOL> _log . debug ( \"<STR_LIT>\" . format ( node . id . encode ( \"<STR_LIT>\" ) . upper ( ) , <EOL> node . ip , <EOL> node . port , <EOL> message ) ) <EOL> def generate_challenge ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return os . urandom ( <NUM_LIT:8> ) . encode ( \"<STR_LIT>\" ) <EOL> class ForgetfulStorageFix ( ForgetfulStorage ) : <EOL> def get ( self , key , default = None ) : <EOL> self . cull ( ) <EOL> if key in self . data : <EOL> return ( True , self [ key ] ) <EOL> return ( False , default ) <EOL> class KademliaProtocolAppend ( KademliaProtocol ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . set_keys = kwargs . pop ( '<STR_LIT>' , set ( [ ] ) ) <EOL> KademliaProtocol . __init__ ( self , * args , ** kwargs ) <EOL> self . cert_conf = certificate . Config ( _conf . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> _conf . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) . configuration <EOL> try : <EOL> self . trustedStore = OpenSSL . crypto . X509Store ( ) <EOL> except : <EOL> logger ( self . sourceNode , \"<STR_LIT>\" ) <EOL> self . addCACert ( ) <EOL> def callCertFindValue ( self , nodeToAsk , nodeToFind ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> address = ( nodeToAsk . ip , nodeToAsk . port ) <EOL> challenge = generate_challenge ( ) <EOL> try : <EOL> private = OpenSSL . crypto . load_privatekey ( OpenSSL . crypto . FILETYPE_PEM , <EOL> self . priv_key , <EOL> '<STR_LIT>' ) <EOL> signature = OpenSSL . crypto . sign ( private , <EOL> nodeToAsk . id . encode ( \"<STR_LIT>\" ) . upper ( ) + challenge , <EOL> \"<STR_LIT>\" ) <EOL> except : <EOL> logger ( self . sourceNode , \"<STR_LIT>\" ) <EOL> return None <EOL> d = self . find_value ( address , <EOL> self . sourceNode . id , <EOL> nodeToFind . id , <EOL> challenge , <EOL> signature , <EOL> self . getOwnCert ( ) ) <EOL> return d . addCallback ( self . handleCertCallResponse , <EOL> nodeToAsk , <EOL> challenge ) <EOL> def callFindNode ( self , nodeToAsk , nodeToFind ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> address = ( nodeToAsk . ip , nodeToAsk . port ) <EOL> challenge = generate_challenge ( ) <EOL> try : <EOL> private = OpenSSL . crypto . load_privatekey ( OpenSSL . crypto . FILETYPE_PEM , <EOL> self . priv_key , <EOL> '<STR_LIT>' ) <EOL> signature = OpenSSL . crypto . sign ( private , <EOL> nodeToAsk . id . encode ( \"<STR_LIT>\" ) . upper ( ) + challenge , <EOL> \"<STR_LIT>\" ) <EOL> except : <EOL> logger ( self . sourceNode , \"<STR_LIT>\" ) <EOL> return None <EOL> d = self . find_node ( address , <EOL> self . sourceNode . id , <EOL> nodeToFind . id , <EOL> challenge , <EOL> signature ) <EOL> return d . addCallback ( self . handleSignedBucketResponse , <EOL> nodeToAsk , <EOL> challenge ) <EOL> def callFindValue ( self , nodeToAsk , nodeToFind ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> address = ( nodeToAsk . ip , nodeToAsk . port ) <EOL> challenge = generate_challenge ( ) <EOL> try : <EOL> private = OpenSSL . crypto . load_privatekey ( OpenSSL . crypto . FILETYPE_PEM , <EOL> self . priv_key , <EOL> '<STR_LIT>' ) <EOL> signature = OpenSSL . crypto . sign ( private , <EOL> nodeToAsk . id . encode ( \"<STR_LIT>\" ) . upper ( ) + challenge , <EOL> \"<STR_LIT>\" ) <EOL> except : <EOL> logger ( self . sourceNode , \"<STR_LIT>\" ) <EOL> return None <EOL> d = self . find_value ( address , <EOL> self . sourceNode . id , <EOL> nodeToFind . id , <EOL> challenge , <EOL> signature ) <EOL> return d . addCallback ( self . handleSignedValueResponse , <EOL> nodeToAsk , <EOL> challenge ) <EOL> def callPing ( self , nodeToAsk , cert = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> address = ( nodeToAsk . ip , nodeToAsk . port ) <EOL> challenge = generate_challenge ( ) <EOL> try : <EOL> private = OpenSSL . crypto . load_privatekey ( OpenSSL . crypto . FILETYPE_PEM , <EOL> self . priv_key , <EOL> '<STR_LIT>' ) <EOL> signature = OpenSSL . crypto . sign ( private , <EOL> nodeToAsk . id . encode ( \"<STR_LIT>\" ) . upper ( ) + challenge , <EOL> \"<STR_LIT>\" ) <EOL> except : <EOL> logger ( self . sourceNode , \"<STR_LIT>\" ) <EOL> return None <EOL> d = self . ping ( address , <EOL> self . sourceNode . id , <EOL> challenge , <EOL> signature , <EOL> cert ) <EOL> return d . addCallback ( self . handleSignedPingResponse , <EOL> nodeToAsk , <EOL> challenge ) <EOL> def callStore ( self , nodeToAsk , key , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> address = ( nodeToAsk . ip , nodeToAsk . port ) <EOL> challenge = generate_challenge ( ) <EOL> try : <EOL> private = OpenSSL . crypto . load_privatekey ( OpenSSL . crypto . FILETYPE_PEM , <EOL> self . priv_key , <EOL> '<STR_LIT>' ) <EOL> signature = OpenSSL . crypto . sign ( private , <EOL> nodeToAsk . id . encode ( \"<STR_LIT>\" ) . upper ( ) + challenge , <EOL> \"<STR_LIT>\" ) <EOL> except : <EOL> logger ( self . sourceNode , \"<STR_LIT>\" ) <EOL> return None <EOL> d = self . store ( address , <EOL> self . sourceNode . id , <EOL> key , <EOL> value , <EOL> challenge , <EOL> signature ) <EOL> logger ( self . sourceNode , \"<STR_LIT>\" ) <EOL> return d . addCallback ( self . handleSignedStoreResponse , <EOL> nodeToAsk , <EOL> challenge ) <EOL> def callAppend ( self , nodeToAsk , key , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> address = ( nodeToAsk . ip , nodeToAsk . port ) <EOL> challenge = generate_challenge ( ) <EOL> try : <EOL> private = OpenSSL . crypto . load_privatekey ( OpenSSL . crypto . FILETYPE_PEM , <EOL> self . priv_key , <EOL> '<STR_LIT>' ) <EOL> signature = OpenSSL . crypto . sign ( private , <EOL>", "answer": "nodeToAsk . id . encode ( \"<STR_LIT>\" ) . upper ( ) + challenge ,"}, {"prompt": "<s> from aliyunsdkcore . request import RpcRequest <EOL> class DescribeRegionsRequest ( RpcRequest ) : <EOL> def __init__ ( self ) : <EOL> RpcRequest . __init__ ( self , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def get_OwnerId ( self ) : <EOL> return self . get_query_params ( ) . get ( '<STR_LIT>' ) <EOL>", "answer": "def set_OwnerId ( self , OwnerId ) :"}, {"prompt": "<s> try : <EOL> from hashlib import md5 <EOL> except ImportError : <EOL> from md5 import md5 <EOL> from django . db . models import F <EOL> from app . utils import safe_string , log <EOL> from error . models import Group , Error <EOL> from error . agent import get <EOL> from error import signals <EOL> def generate_key ( instance ) : <EOL> keys = [ \"<STR_LIT:type>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:status>\" , \"<STR_LIT>\" ] <EOL> hsh = None <EOL> for key in keys : <EOL> value = safe_string ( getattr ( instance , key ) ) <EOL> if value : <EOL> if not hsh : <EOL> hsh = md5 ( ) <EOL> hsh . update ( value . encode ( \"<STR_LIT:ascii>\" , \"<STR_LIT:ignore>\" ) ) <EOL> return hsh <EOL> def default_grouping ( instance , ** kw ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> log ( \"<STR_LIT>\" ) <EOL> hsh = generate_key ( instance ) <EOL> if hsh : <EOL> digest = hsh . hexdigest ( ) <EOL> try : <EOL> created = False <EOL> group = Group . objects . get ( uid = digest ) <EOL> group . count = F ( '<STR_LIT:count>' ) + getattr ( instance , '<STR_LIT:count>' , <NUM_LIT:1> ) <EOL> group . save ( ) <EOL> except Group . DoesNotExist : <EOL> created = True <EOL> group = Group . objects . create ( uid = digest , count = getattr ( instance , '<STR_LIT:count>' , <NUM_LIT:1> ) ) <EOL> instance . group = group <EOL> instance . save ( ) <EOL> if created : <EOL> signals . group_assigned . send ( sender = group . __class__ , instance = group ) <EOL> signals . error_assigned . send ( sender = instance . __class__ , instance = instance ) <EOL> signals . error_created . connect ( default_grouping , <EOL> dispatch_uid = \"<STR_LIT>\" ) <EOL> def default_browser_parsing ( instance , ** kw ) : <EOL> log ( \"<STR_LIT>\" ) <EOL> if instance . user_agent : <EOL> bc = get ( ) <EOL>", "answer": "if bc :"}, {"prompt": "<s> from django . shortcuts import get_object_or_404 <EOL> from django . shortcuts import render <EOL> from core . vlan . models import Vlan <EOL> from core . vlan . forms import VlanForm <EOL> from core . views import ( <EOL> CoreDeleteView , CoreListView , CoreCreateView , CoreUpdateView <EOL> ) <EOL> class VlanView ( object ) : <EOL> model = Vlan <EOL> queryset = Vlan . objects . all ( ) <EOL> form_class = VlanForm <EOL> class VlanDeleteView ( VlanView , CoreDeleteView ) : <EOL>", "answer": "pass"}, {"prompt": "<s> __author__ = \"<STR_LIT>\" <EOL> __copyright__ = \"<STR_LIT>\" <EOL> __credits__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> __license__ = \"<STR_LIT>\" <EOL> __version__ = \"<STR_LIT>\" <EOL> __maintainer__ = \"<STR_LIT>\" <EOL> __email__ = \"<STR_LIT>\" <EOL> __status__ = \"<STR_LIT>\" <EOL> from skbio . stats . spatial import procrustes <EOL> from emperor . qiime_backports . parse import parse_mapping_file_to_dict <EOL> from numpy . ma . extras import apply_along_axis <EOL> from numpy . ma import MaskedArray <EOL> from numpy import ( shape , vstack , zeros , sum as numpy_sum , sort as numpy_sort , <EOL> nan as numpy_nan , array , median ) <EOL> def is_valid_git_refname ( refname ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( refname ) == <NUM_LIT:0> : <EOL> return False <EOL> if ( len ( [ True for element in refname . split ( '<STR_LIT:/>' ) if element . startswith ( '<STR_LIT:.>' ) or element . endswith ( '<STR_LIT>' ) ] ) != <NUM_LIT:0> ) : <EOL> return False <EOL> if '<STR_LIT:..>' in refname : <EOL> return False <EOL> if len ( [ True for refname_char in refname if ord ( refname_char ) < <NUM_LIT> or ord ( refname_char ) == <NUM_LIT> ] ) != <NUM_LIT:0> : <EOL> return False <EOL> if '<STR_LIT:U+0020>' in refname or '<STR_LIT>' in refname or '<STR_LIT>' in refname or '<STR_LIT::>' in refname : <EOL> return False <EOL> if '<STR_LIT:?>' in refname or '<STR_LIT:*>' in refname or '<STR_LIT:[>' in refname : <EOL> return False <EOL> if refname . startswith ( '<STR_LIT:/>' ) or refname . endswith ( '<STR_LIT:/>' ) or '<STR_LIT>' in refname : <EOL> return False <EOL> if refname . endswith ( '<STR_LIT:.>' ) : <EOL> return False <EOL> if '<STR_LIT>' in refname : <EOL> return False <EOL> if '<STR_LIT:\\\\>' in refname : <EOL> return False <EOL> return True <EOL> def is_valid_git_sha1 ( hash ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if len ( hash ) != <NUM_LIT> : <EOL> return False <EOL> try : <EOL> value = int ( hash , <NUM_LIT:16> ) <EOL> except ValueError : <EOL> return False <EOL> return True <EOL> class MetadataMap ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ staticmethod <EOL> def parseMetadataMap ( lines ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return MetadataMap ( * parse_mapping_file_to_dict ( lines ) ) <EOL> def __init__ ( self , sample_metadata , Comments ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _metadata = sample_metadata <EOL> self . Comments = Comments <EOL> def __eq__ ( self , other ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( other , self . __class__ ) : <EOL> return self . __dict__ == other . __dict__ <EOL> else : <EOL> return False <EOL> def __ne__ ( self , other ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return not self . __eq__ ( other ) <EOL> def getSampleMetadata ( self , sample_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _metadata [ sample_id ] <EOL> def getCategoryValue ( self , sample_id , category ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _metadata [ sample_id ] [ category ] <EOL> def getCategoryValues ( self , sample_ids , category ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return [ self . _metadata [ sid ] [ category ] for sid in sample_ids ] <EOL> def isNumericCategory ( self , category ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> category_values = self . getCategoryValues ( self . SampleIds , category ) <EOL> is_numeric = True <EOL> for category_value in category_values : <EOL> try : <EOL> float ( category_value ) <EOL> except ValueError : <EOL> is_numeric = False <EOL> return is_numeric <EOL> def hasUniqueCategoryValues ( self , category ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> category_values = self . getCategoryValues ( self . SampleIds , category ) <EOL> is_unique = False <EOL> if len ( set ( category_values ) ) == len ( self . SampleIds ) : <EOL> is_unique = True <EOL> return is_unique <EOL> def hasSingleCategoryValue ( self , category ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> category_values = self . getCategoryValues ( self . SampleIds , category ) <EOL> single_value = False <EOL> if len ( set ( category_values ) ) == <NUM_LIT:1> : <EOL> single_value = True <EOL> return single_value <EOL> @ property <EOL> def SampleIds ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return sorted ( self . _metadata . keys ( ) ) <EOL> @ property <EOL> def CategoryNames ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return sorted ( self . getSampleMetadata ( self . SampleIds [ <NUM_LIT:0> ] ) . keys ( ) ) if len ( self . SampleIds ) > <NUM_LIT:0> else [ ] <EOL> def filterSamples ( self , sample_ids_to_keep , strict = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for sid in self . SampleIds : <EOL> if sid not in sample_ids_to_keep : <EOL> del self . _metadata [ sid ] <EOL> if strict : <EOL> extra_samples = set ( sample_ids_to_keep ) - set ( self . SampleIds ) <EOL> if extra_samples : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % '<STR_LIT:U+002CU+0020>' . join ( extra_samples ) ) <EOL> def summarize_pcoas ( master_pcoa , support_pcoas , method = '<STR_LIT>' , apply_procrustes = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if apply_procrustes : <EOL> support_pcoas = [ list ( sp ) for sp in support_pcoas ] <EOL> master_pcoa = list ( master_pcoa ) <EOL> for i , pcoa in enumerate ( support_pcoas ) : <EOL> master_std , pcoa_std , m_squared = procrustes ( master_pcoa [ <NUM_LIT:1> ] , pcoa [ <NUM_LIT:1> ] ) <EOL> support_pcoas [ i ] [ <NUM_LIT:1> ] = pcoa_std <EOL> master_pcoa [ <NUM_LIT:1> ] = master_std <EOL> m_matrix = master_pcoa [ <NUM_LIT:1> ] <EOL> m_eigvals = master_pcoa [ <NUM_LIT:2> ] <EOL> m_names = master_pcoa [ <NUM_LIT:0> ] <EOL> jn_flipped_matrices = [ ] <EOL> all_eigvals = [ ] <EOL> for rep in support_pcoas : <EOL> matrix = rep [ <NUM_LIT:1> ] <EOL> eigvals = rep [ <NUM_LIT:2> ] <EOL> all_eigvals . append ( eigvals ) <EOL> jn_flipped_matrices . append ( _flip_vectors ( matrix , m_matrix ) ) <EOL> matrix_average , matrix_low , matrix_high = _compute_jn_pcoa_avg_ranges ( jn_flipped_matrices , method ) <EOL> all_eigvals_stack = vstack ( all_eigvals ) <EOL> eigval_sum = numpy_sum ( all_eigvals_stack , axis = <NUM_LIT:0> ) <EOL> eigval_average = eigval_sum / float ( len ( all_eigvals ) ) <EOL> return matrix_average , matrix_low , matrix_high , eigval_average , m_names <EOL> def _flip_vectors ( jn_matrix , m_matrix ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> m_matrix_trans = m_matrix . transpose ( ) <EOL> jn_matrix_trans = jn_matrix . transpose ( ) <EOL> new_matrix = zeros ( jn_matrix_trans . shape , float ) <EOL> for i , m_vector in enumerate ( m_matrix_trans ) : <EOL> jn_vector = jn_matrix_trans [ i ] <EOL> disT = list ( m_vector - jn_vector ) <EOL> disT = sum ( map ( abs , disT ) ) <EOL> jn_flip = jn_vector * [ - <NUM_LIT:1> ] <EOL> disF = list ( m_vector - jn_flip ) <EOL> disF = sum ( map ( abs , disF ) ) <EOL> if disT > disF : <EOL> new_matrix [ i ] = jn_flip <EOL> else : <EOL> new_matrix [ i ] = jn_vector <EOL> return new_matrix . transpose ( ) <EOL> def _compute_jn_pcoa_avg_ranges ( jn_flipped_matrices , method ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from neuralnet import * <EOL> from sparse_code_layer import * <EOL> import scipy . linalg <EOL> class SparseCoder ( NeuralNet ) : <EOL> def SetLayerAndEdgeClass ( self ) : <EOL> self . LayerClass = SparseCodeLayer <EOL> self . EdgeClass = Edge <EOL> def Show ( self ) : <EOL> encoder = self . encoder . params [ '<STR_LIT>' ] . asarray ( ) <EOL> decoder = self . decoder . params [ '<STR_LIT>' ] . asarray ( ) <EOL> recon = self . input_layer . approximator . asarray ( ) <EOL> recep_field = self . encoder . proto . receptive_field_width <EOL> rows = self . encoder . proto . display_rows <EOL> cols = self . encoder . proto . display_cols <EOL> visualize . display_wsorted ( encoder , recep_field , rows , cols , <NUM_LIT:1> , title = '<STR_LIT>' ) <EOL> visualize . display_wsorted ( decoder . T , recep_field , rows , cols , <NUM_LIT:2> , title = '<STR_LIT>' ) <EOL> visualize . display_w ( recon [ : , : <NUM_LIT:100> ] , recep_field , <NUM_LIT:10> , <NUM_LIT:10> , <NUM_LIT:3> , title = '<STR_LIT>' ) <EOL> visualize . display_hidden ( self . code_layer . state . asarray ( ) , <NUM_LIT:4> , '<STR_LIT>' , prob = False ) <EOL> def Sort ( self ) : <EOL> assert len ( self . layer ) == <NUM_LIT:2> <EOL> assert len ( self . edge ) == <NUM_LIT:2> <EOL> if self . layer [ <NUM_LIT:0> ] . is_input : <EOL> self . input_layer = self . layer [ <NUM_LIT:0> ] <EOL> self . code_layer = self . layer [ <NUM_LIT:1> ] <EOL> else : <EOL> self . input_layer = self . layer [ <NUM_LIT:1> ] <EOL> self . code_layer = self . layer [ <NUM_LIT:0> ] <EOL> if self . edge [ <NUM_LIT:0> ] . node1 == self . input_layer : <EOL> self . encoder = self . edge [ <NUM_LIT:0> ] <EOL> self . decoder = self . edge [ <NUM_LIT:1> ] <EOL> else : <EOL> self . encoder = self . edge [ <NUM_LIT:1> ] <EOL> self . decoder = self . edge [ <NUM_LIT:0> ] <EOL> return [ self . input_layer , self . code_layer ] <EOL> def SolveForZ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> input_layer = self . input_layer <EOL> code_layer = self . code_layer <EOL> z = code_layer . state <EOL> wd = self . decoder . params [ '<STR_LIT>' ] <EOL> hyp = code_layer . hyperparams <EOL> alpha = hyp . sc_alpha <EOL> beta = hyp . sc_beta <EOL> gamma = hyp . sc_gamma <EOL> temp = code_layer . m_by_m <EOL> temp2 = code_layer . deriv <EOL> eye_m_by_m = code_layer . eye_m_by_m <EOL> cm . dot ( wd , wd . T , target = temp ) <EOL> temp . mult ( beta ) <EOL> temp . add ( alpha ) <EOL> z_est . mult ( alpha , target = temp2 ) <EOL> temp2 . add_dot ( wd , x , mult = beta ) <EOL> temp2 . subtract ( gamma ) <EOL> A = temp . asarray ( ) <EOL> B = temp2 . asarray ( ) <EOL> Z = scipy . linalg . solve ( A , B , overwrite_a = True , overwrite_b = True ) <EOL> z . overwrite ( Z ) <EOL> def IterateForZ ( self , train = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> input_layer = self . input_layer <EOL> code_layer = self . code_layer <EOL> epsilon = <NUM_LIT> <EOL> steps = <NUM_LIT:20> <EOL> z = code_layer . state <EOL> wd = self . decoder . params [ '<STR_LIT>' ] <EOL> hyp = code_layer . hyperparams <EOL> alpha = hyp . sc_alpha <EOL> beta = hyp . sc_beta <EOL> gamma = hyp . sc_gamma <EOL> temp = code_layer . m_by_m <EOL> temp2 = code_layer . deriv <EOL> temp3 = code_layer . temp3 <EOL> grad = code_layer . grad <EOL> z_est = code_layer . approximator <EOL> avg_models = hyp . dropout and ( not hyp . dropout or not train ) <EOL> cm . dot ( wd , wd . T , target = temp ) <EOL> temp . mult ( beta ) <EOL> if avg_models : <EOL> temp . mult ( ( <NUM_LIT:1.0> - hyp . dropout_prob ) ** <NUM_LIT:2> ) <EOL> temp . mult_diagonal ( <NUM_LIT:1.> / ( <NUM_LIT:1.0> - hyp . dropout_prob ) ) <EOL> temp . add_diagonal ( alpha ) <EOL> z_est . mult ( alpha , target = temp2 ) <EOL> if avg_models : <EOL> temp2 . add_dot ( wd , input_layer . state , mult = beta * ( <NUM_LIT:1.0> - hyp . dropout_prob ) ) <EOL> elif hyp . dropout : <EOL> temp2 . add_dot ( wd , input_layer . state , mult = beta ) <EOL> temp2 . mult ( code_layer . mask ) <EOL> else : <EOL> temp2 . add_dot ( wd , input_layer . state , mult = beta ) <EOL> z . assign ( z_est ) <EOL> for i in range ( steps ) : <EOL> cm . dot ( temp , z , target = grad ) <EOL> grad . subtract ( temp2 ) <EOL> z . sign ( target = temp3 ) <EOL> grad . add_mult ( temp3 , alpha = gamma ) <EOL> if hyp . dropout and train : <EOL> grad . mult ( code_layer . mask ) <EOL> z . add_mult ( grad , alpha = - epsilon ) <EOL> def ForwardPropagate ( self , train = False , method = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> input_layer = self . input_layer <EOL> code_layer = self . code_layer <EOL> input_layer . GetData ( ) <EOL> inputs = input_layer . state <EOL> we = self . encoder . params [ '<STR_LIT>' ] <EOL> be = code_layer . params [ '<STR_LIT>' ] <EOL> scale = code_layer . params [ '<STR_LIT>' ] <EOL> hyp = code_layer . hyperparams <EOL> code_approx = code_layer . approximator <EOL> cm . dot ( we . T , inputs , target = code_approx ) <EOL> code_approx . add_col_vec ( be ) <EOL> code_layer . ApplyActivation ( code_approx ) <EOL> code_approx . mult_by_col ( scale ) <EOL> if hyp . dropout and train : <EOL> code_layer . mask . fill_with_rand ( ) <EOL> code_layer . mask . greater_than ( hyp . dropout_prob ) <EOL> code_approx . mult ( code_layer . mask ) <EOL> if train : <EOL> if method == '<STR_LIT>' : <EOL> self . IterateForZ ( train = train ) <EOL> elif method == '<STR_LIT>' : <EOL> self . SolveForZ ( ) <EOL> else : <EOL> if method == '<STR_LIT>' : <EOL>", "answer": "self . IterateForZ ( train = train )"}, {"prompt": "<s> import ldap <EOL> import re <EOL> import sys <EOL> import django <EOL> if django . VERSION >= ( <NUM_LIT:1> , <NUM_LIT:8> ) : <EOL> from django . db . models import aggregates <EOL> else : <EOL> from django . db . models . sql import aggregates <EOL> from django . db . models . sql import compiler <EOL> from django . db . models . sql . where import AND , OR <EOL> from ldapdb . models . fields import ListField <EOL> _ORDER_BY_LIMIT_OFFSET_RE = re . compile ( r'<STR_LIT>' ) <EOL> def get_lookup_operator ( lookup_type ) : <EOL> if lookup_type == '<STR_LIT>' : <EOL> return '<STR_LIT>' <EOL> elif lookup_type == '<STR_LIT>' : <EOL> return '<STR_LIT>' <EOL> else : <EOL> return '<STR_LIT:=>' <EOL> def query_as_ldap ( query ) : <EOL> if hasattr ( query , '<STR_LIT>' ) and query . is_empty ( ) : <EOL> return <EOL> filterstr = '<STR_LIT>' . join ( [ '<STR_LIT>' % cls for cls in <EOL> query . model . object_classes ] ) <EOL> sql , params = where_as_ldap ( query . where ) <EOL> filterstr += sql <EOL> return '<STR_LIT>' % filterstr <EOL> def where_as_ldap ( self ) : <EOL> bits = [ ] <EOL> for item in self . children : <EOL> if hasattr ( item , '<STR_LIT>' ) and hasattr ( item , '<STR_LIT>' ) : <EOL> item = item . lhs . target . column , item . lookup_name , None , item . rhs <EOL> elif hasattr ( item , '<STR_LIT>' ) : <EOL> sql , params = where_as_ldap ( item ) <EOL> bits . append ( sql ) <EOL> continue <EOL> constraint , lookup_type , y , values = item <EOL> if hasattr ( constraint , '<STR_LIT>' ) : <EOL> constraint = constraint . col <EOL> comp = get_lookup_operator ( lookup_type ) <EOL> if lookup_type == '<STR_LIT>' : <EOL> equal_bits = [ \"<STR_LIT>\" % ( constraint , comp , value ) for value <EOL> in values ] <EOL> clause = '<STR_LIT>' % '<STR_LIT>' . join ( equal_bits ) <EOL> else : <EOL> clause = \"<STR_LIT>\" % ( constraint , comp , values ) <EOL> bits . append ( clause ) <EOL> if not len ( bits ) : <EOL> return '<STR_LIT>' , [ ] <EOL> if len ( bits ) == <NUM_LIT:1> : <EOL> sql_string = bits [ <NUM_LIT:0> ] <EOL> elif self . connector == AND : <EOL> sql_string = '<STR_LIT>' % '<STR_LIT>' . join ( bits ) <EOL> elif self . connector == OR : <EOL> sql_string = '<STR_LIT>' % '<STR_LIT>' . join ( bits ) <EOL> else : <EOL> raise Exception ( \"<STR_LIT>\" % self . connector ) <EOL> if self . negated : <EOL> sql_string = ( '<STR_LIT>' % sql_string ) <EOL> return sql_string , [ ] <EOL> class SQLCompiler ( compiler . SQLCompiler ) : <EOL> def execute_sql ( self , result_type = compiler . SINGLE ) : <EOL> if result_type != compiler . SINGLE : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> filterstr = query_as_ldap ( self . query ) <EOL> if not filterstr : <EOL> return <EOL> try : <EOL> vals = self . connection . search_s ( <EOL> self . query . model . base_dn , <EOL> self . query . model . search_scope , <EOL> filterstr = filterstr , <EOL> attrlist = [ '<STR_LIT>' ] , <EOL> ) <EOL> except ldap . NO_SUCH_OBJECT : <EOL> vals = [ ] <EOL> if not vals : <EOL> return None <EOL> output = [ ] <EOL> if django . VERSION >= ( <NUM_LIT:1> , <NUM_LIT:8> ) : <EOL> self . setup_query ( ) <EOL> for e in self . select : <EOL> if isinstance ( e [ <NUM_LIT:0> ] , aggregates . Count ) : <EOL> sql = self . as_sql ( ) [ <NUM_LIT:0> ] <EOL> if hasattr ( self . query , '<STR_LIT>' ) : <EOL> sql = self . query . subquery <EOL> m = _ORDER_BY_LIMIT_OFFSET_RE . search ( sql ) <EOL> limit = m . group ( <NUM_LIT:2> ) <EOL> offset = m . group ( <NUM_LIT:3> ) <EOL> if limit and int ( limit ) >= <NUM_LIT:0> : <EOL> output . append ( int ( limit ) ) <EOL> elif offset : <EOL> output . append ( len ( vals ) - int ( offset ) ) <EOL> else : <EOL> output . append ( len ( vals ) ) <EOL> else : <EOL> output . append ( e [ <NUM_LIT:0> ] ) <EOL> else : <EOL> for alias , col in self . query . extra_select . iteritems ( ) : <EOL> output . append ( col [ <NUM_LIT:0> ] ) <EOL> for key , aggregate in self . query . aggregate_select . items ( ) : <EOL> if isinstance ( aggregate , aggregates . Count ) : <EOL> output . append ( len ( vals ) ) <EOL> else : <EOL> output . append ( None ) <EOL> return output <EOL> def results_iter ( self , results = None ) : <EOL> filterstr = query_as_ldap ( self . query ) <EOL> if not filterstr : <EOL> return <EOL> if hasattr ( self . query , '<STR_LIT>' ) and len ( self . query . select_fields ) : <EOL> fields = self . query . select_fields <EOL> elif len ( self . query . select ) : <EOL> fields = [ x . field for x in self . query . select ] <EOL> else : <EOL> fields = self . query . model . _meta . fields <EOL> attrlist = [ x . db_column for x in fields if x . db_column ] <EOL> try : <EOL> vals = self . connection . search_s ( <EOL> self . query . model . base_dn , <EOL> self . query . model . search_scope , <EOL> filterstr = filterstr , <EOL> attrlist = attrlist , <EOL> ) <EOL> except ldap . NO_SUCH_OBJECT : <EOL> return <EOL> if self . query . extra_order_by : <EOL> ordering = self . query . extra_order_by <EOL> elif not self . query . default_ordering : <EOL> ordering = self . query . order_by <EOL> else : <EOL> ordering = self . query . order_by or self . query . model . _meta . ordering <EOL> def cmpvals ( x , y ) : <EOL> for fieldname in ordering : <EOL> if fieldname . startswith ( '<STR_LIT:->' ) : <EOL> fieldname = fieldname [ <NUM_LIT:1> : ] <EOL> negate = True <EOL> else : <EOL> negate = False <EOL> if fieldname == '<STR_LIT>' : <EOL> fieldname = self . query . model . _meta . pk . name <EOL> field = self . query . model . _meta . get_field ( fieldname ) <EOL> attr_x = field . from_ldap ( x [ <NUM_LIT:1> ] . get ( field . db_column , [ ] ) , <EOL> connection = self . connection ) <EOL> attr_y = field . from_ldap ( y [ <NUM_LIT:1> ] . get ( field . db_column , [ ] ) , <EOL> connection = self . connection ) <EOL> if hasattr ( attr_x , '<STR_LIT>' ) : <EOL> attr_x = attr_x . lower ( ) <EOL> if hasattr ( attr_y , '<STR_LIT>' ) : <EOL> attr_y = attr_y . lower ( ) <EOL> val = negate and cmp ( attr_y , attr_x ) or cmp ( attr_x , attr_y ) <EOL> if val : <EOL> return val <EOL> return <NUM_LIT:0> <EOL> vals = sorted ( vals , cmp = cmpvals ) <EOL> pos = <NUM_LIT:0> <EOL> results = [ ] <EOL> for dn , attrs in vals : <EOL> if ( self . query . low_mark and pos < self . query . low_mark ) or ( self . query . high_mark is not None and <EOL> pos >= self . query . high_mark ) : <EOL> pos += <NUM_LIT:1> <EOL> continue <EOL> row = [ ] <EOL> if django . VERSION >= ( <NUM_LIT:1> , <NUM_LIT:8> ) : <EOL> self . setup_query ( ) <EOL> for e in self . select : <EOL> if isinstance ( e [ <NUM_LIT:0> ] , aggregates . Count ) : <EOL> value = <NUM_LIT:0> <EOL> if e [ <NUM_LIT:0> ] . input_field . field . attname == '<STR_LIT>' : <EOL> value = <NUM_LIT:1> <EOL> elif hasattr ( e [ <NUM_LIT:0> ] . input_field . field , '<STR_LIT>' ) : <EOL> result = e [ <NUM_LIT:0> ] . input_field . field . from_ldap ( <EOL> attrs . get ( e [ <NUM_LIT:0> ] . input_field . field . db_column , [ ] ) , <EOL> connection = self . connection ) <EOL> if result : <EOL> value = <NUM_LIT:1> <EOL> if isinstance ( e [ <NUM_LIT:0> ] . input_field . field , ListField ) : <EOL> value = len ( result ) <EOL> row . append ( value ) <EOL> else : <EOL> if e [ <NUM_LIT:0> ] . field . attname == '<STR_LIT>' : <EOL> row . append ( dn ) <EOL> elif hasattr ( e [ <NUM_LIT:0> ] . field , '<STR_LIT>' ) : <EOL> row . append ( e [ <NUM_LIT:0> ] . field . from_ldap ( <EOL> attrs . get ( e [ <NUM_LIT:0> ] . field . db_column , [ ] ) , <EOL> connection = self . connection ) ) <EOL> else : <EOL> row . append ( None ) <EOL> else : <EOL> for field in iter ( fields ) : <EOL> if field . attname == '<STR_LIT>' : <EOL> row . append ( dn ) <EOL> elif hasattr ( field , '<STR_LIT>' ) : <EOL> row . append ( field . from_ldap ( attrs . get ( field . db_column , [ ] ) , <EOL> connection = self . connection ) ) <EOL> else : <EOL> row . append ( None ) <EOL> for key , aggregate in self . query . aggregate_select . items ( ) : <EOL> if isinstance ( aggregate , aggregates . Count ) : <EOL> value = <NUM_LIT:0> <EOL> if aggregate . source . attname == '<STR_LIT>' : <EOL> value = <NUM_LIT:1> <EOL> elif hasattr ( aggregate . source , '<STR_LIT>' ) : <EOL> result = aggregate . source . from_ldap ( <EOL> attrs . get ( aggregate . source . db_column , [ ] ) , <EOL>", "answer": "connection = self . connection )"}, {"prompt": "<s> import pytest <EOL> from bravado . client import ResourceDecorator <EOL> def test_resource_exists ( petstore_client ) : <EOL> assert type ( petstore_client . pet ) == ResourceDecorator <EOL> def test_resource_not_found ( petstore_client ) : <EOL>", "answer": "with pytest . raises ( AttributeError ) as excinfo :"}, {"prompt": "<s> import json <EOL> import os <EOL> def from_envvars ( conf , prefix = None , envvars = None , as_json = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if prefix is None and envvars is None : <EOL> raise RuntimeError ( '<STR_LIT>' ) <EOL> if isinstance ( envvars , list ) : <EOL> envvars = { k : None for k in envvars } <EOL> if not envvars : <EOL> envvars = { k : k [ len ( prefix ) : ] for k in os . environ . keys ( ) <EOL> if k . startswith ( prefix ) } <EOL> for env_name , name in envvars . items ( ) : <EOL> if name is None : <EOL> name = env_name <EOL> if not env_name in os . environ : <EOL> continue <EOL> if as_json : <EOL> try : <EOL> conf [ name ] = json . loads ( os . environ [ env_name ] ) <EOL>", "answer": "except ValueError :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> from copy import copy <EOL> import gzip <EOL> from itertools import combinations , ifilter <EOL> import numpy as np <EOL> import rdkit <EOL> from rdkit import Chem <EOL> from rdkit . Chem import AllChem , Draw <EOL> from rdkit . Chem import Descriptors <EOL> from rdkit import RDConfig <EOL> _descDict = dict ( Descriptors . descList ) <EOL> import rdkit . DataStructs <EOL> import rdkit . Chem . MACCSkeys <EOL> import rdkit . Chem . AtomPairs . Pairs <EOL> import rdkit . Chem . AtomPairs . Torsions <EOL> from rdkit . Chem . Lipinski import NumRotatableBonds <EOL> from rdkit . Chem . AllChem import ComputeGasteigerCharges <EOL> from rdkit . Chem . Pharm2D import Gobbi_Pharm2D , Generate <EOL> from oddt . spatial import dihedral <EOL> backend = '<STR_LIT>' <EOL> elementtable = Chem . GetPeriodicTable ( ) <EOL> BOND_ORDERS = { Chem . BondType . SINGLE : <NUM_LIT:1.0> , Chem . BondType . DOUBLE : <NUM_LIT> , Chem . BondType . TRIPLE : <NUM_LIT> , Chem . BondType . AROMATIC : <NUM_LIT> , Chem . BondType . UNSPECIFIED : <NUM_LIT:0.0> } <EOL> SMARTS_DEF = { <EOL> '<STR_LIT>' : Chem . MolFromSmarts ( '<STR_LIT>' ) . GetBonds ( ) [ <NUM_LIT:0> ] <EOL> } <EOL> try : <EOL> from rdkit . Chem import CanonicalRankAtoms <EOL> except ImportError : <EOL> pass <EOL> try : <EOL> import Tkinter as tk <EOL> import Image as PIL <EOL> import ImageTk as PILtk <EOL> except : <EOL> PILtk = None <EOL> try : <EOL> import aggdraw <EOL> from rdkit . Chem . Draw import aggCanvas <EOL> except ImportError : <EOL> aggdraw = None <EOL> fps = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> descs = _descDict . keys ( ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _formats = { '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL> '<STR_LIT>' : \"<STR_LIT>\" } <EOL> _notinformats = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> _notoutformats = [ '<STR_LIT>' ] <EOL> if not Chem . INCHI_AVAILABLE : <EOL> _notinformats += [ '<STR_LIT>' ] <EOL> _notoutformats += [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> informats = dict ( [ ( _x , _formats [ _x ] ) for _x in _formats if _x not in _notinformats ] ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> outformats = dict ( [ ( _x , _formats [ _x ] ) for _x in _formats if _x not in _notoutformats ] ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> base_feature_factory = AllChem . BuildFeatureFactory ( os . path . join ( RDConfig . RDDataDir , '<STR_LIT>' ) ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _forcefields = { '<STR_LIT>' : AllChem . UFFOptimizeMolecule } <EOL> forcefields = _forcefields . keys ( ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _filereader_mol2 ( filename ) : <EOL> block = '<STR_LIT>' <EOL> data = '<STR_LIT>' <EOL> n = <NUM_LIT:0> <EOL> with gzip . open ( filename ) if filename . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] == '<STR_LIT>' else open ( filename ) as f : <EOL> for line in f : <EOL> if line [ : <NUM_LIT:1> ] == '<STR_LIT:#>' : <EOL> data += line <EOL> elif line [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> if n > <NUM_LIT:0> : <EOL> yield Molecule ( source = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:string>' : block } ) <EOL> n += <NUM_LIT:1> <EOL> block = data <EOL> data = '<STR_LIT>' <EOL> block += line <EOL> if block : <EOL> yield Molecule ( source = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:string>' : block } ) <EOL> def _filereader_sdf ( filename ) : <EOL> block = '<STR_LIT>' <EOL> n = <NUM_LIT:0> <EOL> with gzip . open ( filename ) if filename . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] == '<STR_LIT>' else open ( filename ) as f : <EOL> for line in f : <EOL> block += line <EOL> if line [ : <NUM_LIT:4> ] == '<STR_LIT>' : <EOL> yield Molecule ( source = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:string>' : block } ) <EOL> n += <NUM_LIT:1> <EOL> block = '<STR_LIT>' <EOL> if block : <EOL> yield Molecule ( source = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:string>' : block } ) <EOL> def _filereader_pdb ( filename , opt = None ) : <EOL> block = '<STR_LIT>' <EOL> n = <NUM_LIT:0> <EOL> with gzip . open ( filename ) if filename . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] == '<STR_LIT>' else open ( filename ) as f : <EOL> for line in f : <EOL> block += line <EOL> if line [ : <NUM_LIT:4> ] == '<STR_LIT>' : <EOL> yield Molecule ( source = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:string>' : block , '<STR_LIT>' : opt } ) <EOL> n += <NUM_LIT:1> <EOL> block = '<STR_LIT>' <EOL> if block : <EOL> yield Molecule ( source = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:string>' : block , '<STR_LIT>' : opt } ) <EOL> def readfile ( format , filename , lazy = False , opt = None , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not os . path . isfile ( filename ) : <EOL> raise IOError , \"<STR_LIT>\" % filename <EOL> format = format . lower ( ) <EOL> if format == \"<STR_LIT>\" : <EOL> return _filereader_sdf ( filename ) <EOL> elif format == \"<STR_LIT>\" : <EOL> def mol_reader ( ) : <EOL> yield Molecule ( Chem . MolFromMolFile ( filename , * args , ** kwargs ) ) <EOL> return mol_reader ( ) <EOL> elif format == \"<STR_LIT>\" : <EOL> def mol_reader ( ) : <EOL> yield Molecule ( Chem . MolFromPDBFile ( filename , * args , ** kwargs ) ) <EOL> return mol_reader ( ) <EOL> elif format == \"<STR_LIT>\" : <EOL> return _filereader_mol2 ( filename ) <EOL> elif format == \"<STR_LIT>\" : <EOL> iterator = Chem . SmilesMolSupplier ( filename , delimiter = \"<STR_LIT>\" , <EOL> titleLine = True , * args , ** kwargs ) <EOL> def smi_reader ( ) : <EOL> for mol in iterator : <EOL> yield Molecule ( mol ) <EOL> return smi_reader ( ) <EOL> elif format == '<STR_LIT>' and Chem . INCHI_AVAILABLE : <EOL> def inchi_reader ( ) : <EOL> for line in open ( filename , '<STR_LIT:r>' ) : <EOL> mol = Chem . inchi . MolFromInchi ( line . strip ( ) , * args , ** kwargs ) <EOL> yield Molecule ( mol ) <EOL> return inchi_reader ( ) <EOL> else : <EOL> raise ValueError , \"<STR_LIT>\" % format <EOL> def readstring ( format , string , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> format = format . lower ( ) <EOL> if format == \"<STR_LIT>\" or format == \"<STR_LIT>\" : <EOL> mol = Chem . MolFromMolBlock ( string , ** kwargs ) <EOL> elif format == \"<STR_LIT>\" : <EOL> mol = Chem . MolFromMol2Block ( string , ** kwargs ) <EOL> elif format == \"<STR_LIT>\" : <EOL> mol = Chem . MolFromPDBBlock ( string , ** kwargs ) <EOL> elif format == \"<STR_LIT>\" : <EOL> s = string . split ( ) <EOL> mol = Chem . MolFromSmiles ( s [ <NUM_LIT:0> ] , ** kwargs ) <EOL> mol . SetProp ( \"<STR_LIT>\" , '<STR_LIT:U+0020>' . join ( s [ <NUM_LIT:1> : ] ) ) <EOL> elif format == '<STR_LIT>' and Chem . INCHI_AVAILABLE : <EOL> mol = Chem . inchi . MolFromInchi ( string , ** kwargs ) <EOL> else : <EOL> raise ValueError , \"<STR_LIT>\" % format <EOL> return Molecule ( mol ) <EOL> class Outputfile ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def __init__ ( self , format , filename , overwrite = False ) :"}, {"prompt": "<s> from subprocess import Popen <EOL> from test_common import * <EOL>", "answer": "import socket , ssl , tempfile , os"}, {"prompt": "<s> import argparse , collections , math , os . path <EOL> import nltk . corpus , nltk . corpus . reader , nltk . data , nltk . tag , nltk . metrics <EOL> from nltk . corpus . util import LazyCorpusLoader <EOL> from nltk_trainer import load_corpus_reader , load_model , simplify_wsj_tag <EOL> from nltk_trainer . tagging import taggers <EOL> parser = argparse . ArgumentParser ( description = '<STR_LIT>' , <EOL> formatter_class = argparse . RawTextHelpFormatter ) <EOL> parser . add_argument ( '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , default = nltk . tag . _POS_TAGGER , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , default = <NUM_LIT:1> , type = int , <EOL> help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , action = '<STR_LIT:store_true>' , default = False , <EOL> help = '<STR_LIT>' ) <EOL> corpus_group = parser . add_argument_group ( '<STR_LIT>' ) <EOL> corpus_group . add_argument ( '<STR_LIT>' , default = None , <EOL> help = '''<STR_LIT>''' ) <EOL> corpus_group . add_argument ( '<STR_LIT>' , default = None , <EOL> help = '<STR_LIT>' ) <EOL> corpus_group . add_argument ( '<STR_LIT>' , default = <NUM_LIT:1.0> , type = float , <EOL>", "answer": "help = '''<STR_LIT>''' )"}, {"prompt": "<s> def addPKCS7Padding ( data , blocksize ) : <EOL> numBytes = blocksize - ( len ( data ) % blocksize ) ; <EOL> for i in range ( numBytes ) : <EOL> data += bytes ( chr ( numBytes ) , '<STR_LIT>' ) ; <EOL> return data <EOL> def test9 ( ) : <EOL> input1 = b'<STR_LIT>' ; <EOL> expected1 = b'<STR_LIT>' <EOL> result1 = addPKCS7Padding ( input1 , <NUM_LIT:8> ) ; <EOL> if ( expected1 != result1 ) : <EOL> return False ; <EOL> input2 = b'<STR_LIT>' ; <EOL> expected2 = b'<STR_LIT>' <EOL> result2 = addPKCS7Padding ( input2 , <NUM_LIT:16> ) ; <EOL> if ( expected2 != result2 ) : <EOL> return False ; <EOL> input3 = b'<STR_LIT>' <EOL> expected3 = b'<STR_LIT>' <EOL> result3 = addPKCS7Padding ( input3 , <NUM_LIT:16> ) ; <EOL> if ( expected3 != result3 ) : <EOL> return False ; <EOL> return True ; <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL>", "answer": "if ( test9 ( ) ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import copy <EOL> try : <EOL> all <EOL> except NameError : <EOL> def all ( iterable ) : <EOL> return True not in ( not x for x in iterable ) <EOL> def getid ( obj ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> return obj . id <EOL> except AttributeError : <EOL> return obj <EOL> class Manager ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> resource_class = None <EOL> def __init__ ( self , api ) : <EOL> self . api = api <EOL> def _list ( self , url , response_key = None , obj_class = None , <EOL> data = None , headers = { } ) : <EOL> resp , body = self . api . json_request ( '<STR_LIT:GET>' , url , data = data , <EOL> headers = headers ) <EOL> if obj_class is None : <EOL> obj_class = self . resource_class <EOL> if response_key : <EOL> if response_key not in body : <EOL> body [ response_key ] = [ ] <EOL> data = body [ response_key ] <EOL> else : <EOL> data = body <EOL> return [ obj_class ( self , res , loaded = True ) for res in data if res ] <EOL> def _delete ( self , url , headers = { } ) : <EOL> self . api . raw_request ( '<STR_LIT>' , url , headers = headers ) <EOL> def _update ( self , url , data , response_key = None , headers = { } ) : <EOL> resp , body = self . api . json_request ( '<STR_LIT>' , url , data = data , <EOL> headers = headers ) <EOL> if body : <EOL> if response_key : <EOL> return self . resource_class ( self , body [ response_key ] ) <EOL> return self . resource_class ( self , body ) <EOL> def _create ( self , url , data = None , response_key = None , <EOL> return_raw = False , headers = { } ) : <EOL> if data : <EOL> resp , body = self . api . json_request ( '<STR_LIT:POST>' , url , <EOL> data = data , headers = headers ) <EOL> else : <EOL> resp , body = self . api . json_request ( '<STR_LIT:POST>' , url , headers = headers ) <EOL> if return_raw : <EOL> if response_key : <EOL> return body [ response_key ] <EOL> return body <EOL> if response_key : <EOL> return self . resource_class ( self , body [ response_key ] ) <EOL> return self . resource_class ( self , body ) <EOL> def _act ( self , url , data , headers = { } ) : <EOL> self . api . json_request ( '<STR_LIT:POST>' , url , data = data , headers = headers ) <EOL> def _get ( self , url , response_key = None , return_raw = False , headers = { } ) : <EOL> resp , body = self . api . json_request ( '<STR_LIT:GET>' , url , headers = headers ) <EOL> if return_raw : <EOL> if response_key : <EOL> return body [ response_key ] <EOL> return body <EOL> if response_key : <EOL> return self . resource_class ( self , body [ response_key ] ) <EOL> return self . resource_class ( self , body ) <EOL> class Resource ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , manager , info , loaded = False ) : <EOL> self . manager = manager <EOL> self . _info = info <EOL> self . _add_details ( info ) <EOL> self . _loaded = loaded <EOL> def _add_details ( self , info ) : <EOL> for k , v in info . items ( ) : <EOL> setattr ( self , k , v ) <EOL> def __setstate__ ( self , d ) : <EOL> for k , v in d . items ( ) : <EOL> setattr ( self , k , v ) <EOL> def __getattr__ ( self , k ) : <EOL> if k not in self . __dict__ : <EOL> if not self . is_loaded ( ) : <EOL> self . get ( ) <EOL> return self . __getattr__ ( k ) <EOL> raise AttributeError ( k ) <EOL> else : <EOL> return self . __dict__ [ k ] <EOL>", "answer": "def __repr__ ( self ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "import numpy as np"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . conf import settings <EOL> from django . db import migrations , models <EOL> import django . db . models . deletion <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> migrations . swappable_dependency ( settings . AUTH_USER_MODEL ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT:20> , primary_key = True , serialize = False ) ) , <EOL> ] , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT>' , models . IntegerField ( primary_key = True , serialize = False , verbose_name = b'<STR_LIT>' ) ) , <EOL> ] , <EOL>", "answer": ") ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> PY3 = sys . version_info [ <NUM_LIT:0> ] == <NUM_LIT:3> <EOL> if PY3 : <EOL> text_type = str <EOL> binary_type = bytes <EOL> integer_types = int , <EOL> numeric_types = int , float <EOL> from urllib import request as urllib_request <EOL> from urllib . parse import urlencode , urlparse , urlunparse , quote , parse_qsl <EOL> from io import StringIO <EOL> else : <EOL> text_type = unicode <EOL> binary_type = str <EOL> integer_types = int , long <EOL>", "answer": "numeric_types = int , long , float"}, {"prompt": "<s> __author__ = \"<STR_LIT>\" <EOL> __doc__ = \"\"\"<STR_LIT>\"\"\" <EOL> from kitt . interfaces import moduleProvides , IDroneDService <EOL> from kitt . util import dictwrapper , getException <EOL> from twisted . web . resource import Resource <EOL> from twisted . web . server import NOT_DONE_YET <EOL> from twisted . web . error import NoResource <EOL> from twisted . python . failure import Failure <EOL> from droned . models . event import Event <EOL> import romeo <EOL> moduleProvides ( IDroneDService ) <EOL> parentService = None <EOL> service = None <EOL> SERVICENAME = '<STR_LIT>' <EOL> SERVICECONFIG = dictwrapper ( { } ) <EOL> dependant_service = '<STR_LIT>' <EOL> try : import simplejson as json <EOL> except ImportError : <EOL> try : import json <EOL> except : json = None <EOL> try : import cPickle as pickle <EOL> except ImportError : <EOL> import pickle <EOL> from yaml import dump as yaml_dumper <EOL> try : <EOL> from yaml import CLoader as Loader , CDumper as Dumper <EOL> except ImportError : <EOL> from yaml import Loader , Dumper <EOL> def resource_error ( func ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def decorator ( * args , ** kwargs ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import logging <EOL> import asyncio <EOL> import os <EOL> from hbmqtt . broker import Broker <EOL> from hbmqtt . version import get_version <EOL> from docopt import docopt <EOL> from . utils import read_yaml_config <EOL> default_config = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:default>' : { <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> } , <EOL> '<STR_LIT>' : <NUM_LIT:10> , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , \"<STR_LIT>\" ) , <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , '<STR_LIT>' <EOL> ] <EOL> } <EOL> } <EOL> logger = logging . getLogger ( __name__ ) <EOL> def main ( * args , ** kwargs ) : <EOL> if sys . version_info [ : <NUM_LIT:2> ] < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> logger . fatal ( \"<STR_LIT>\" ) <EOL> sys . exit ( - <NUM_LIT:1> ) <EOL> arguments = docopt ( __doc__ , version = get_version ( ) ) <EOL> formatter = \"<STR_LIT>\" <EOL> if arguments [ '<STR_LIT>' ] : <EOL> level = logging . DEBUG <EOL> else : <EOL> level = logging . INFO <EOL> logging . basicConfig ( level = level , format = formatter ) <EOL> config = None <EOL> if arguments [ '<STR_LIT:-c>' ] : <EOL> config = read_yaml_config ( arguments [ '<STR_LIT:-c>' ] ) <EOL> else : <EOL>", "answer": "config = read_yaml_config ( os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , '<STR_LIT>' ) )"}, {"prompt": "<s> from allauth . socialaccount . tests import OAuthTestsMixin <EOL> from allauth . tests import MockedResponse , TestCase <EOL> from . provider import FlickrProvider <EOL> class FlickrTests ( OAuthTestsMixin , TestCase ) : <EOL> provider_id = FlickrProvider . id <EOL> def get_mocked_response ( self ) : <EOL> return [ <EOL> MockedResponse ( <NUM_LIT:200> , r\"\"\"<STR_LIT>\"\"\" ) , <EOL> MockedResponse ( <NUM_LIT:200> , r\"\"\"<STR_LIT>\"\"\" ) ] <EOL> def test_login ( self ) : <EOL> account = super ( FlickrTests , self ) . test_login ( ) <EOL> f_account = account . get_provider_account ( ) <EOL> self . assertEqual ( account . user . first_name , <EOL>", "answer": "'<STR_LIT>' )"}, {"prompt": "<s> import sublime , sublime_plugin <EOL> import os . path <EOL> class OpenFileSettingsCommand ( sublime_plugin . WindowCommand ) : <EOL> def run ( self ) : <EOL> view = self . window . active_view ( ) <EOL> settings_name , _ = os . path . splitext ( os . path . basename ( view . settings ( ) . get ( '<STR_LIT>' ) ) ) <EOL> dir_name = os . path . join ( sublime . packages_path ( ) , '<STR_LIT>' ) <EOL>", "answer": "self . window . open_file ( os . path . join ( dir_name , settings_name + \"<STR_LIT>\" ) )"}, {"prompt": "<s> from oslo_config import cfg <EOL> from oslo_log import log as logging <EOL> import oslo_messaging as messaging <EOL> import six <EOL> from nova . compute import power_state <EOL> from nova . conductor . tasks import base <EOL> from nova import exception <EOL> from nova . i18n import _ <EOL> from nova import objects <EOL> from nova . scheduler import utils as scheduler_utils <EOL> from nova import utils <EOL> LOG = logging . getLogger ( __name__ ) <EOL> migrate_opt = cfg . IntOpt ( '<STR_LIT>' , <EOL> default = - <NUM_LIT:1> , <EOL> help = '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> CONF = cfg . CONF <EOL> CONF . register_opt ( migrate_opt ) <EOL> class LiveMigrationTask ( base . TaskBase ) : <EOL> def __init__ ( self , context , instance , destination , <EOL> block_migration , disk_over_commit , migration , compute_rpcapi , <EOL> servicegroup_api , scheduler_client , request_spec = None ) : <EOL> super ( LiveMigrationTask , self ) . __init__ ( context , instance ) <EOL> self . destination = destination <EOL> self . block_migration = block_migration <EOL> self . disk_over_commit = disk_over_commit <EOL> self . migration = migration <EOL> self . source = instance . host <EOL> self . migrate_data = None <EOL> self . compute_rpcapi = compute_rpcapi <EOL> self . servicegroup_api = servicegroup_api <EOL> self . scheduler_client = scheduler_client <EOL> self . request_spec = request_spec <EOL> def _execute ( self ) : <EOL> self . _check_instance_is_active ( ) <EOL> self . _check_host_is_up ( self . source ) <EOL> if not self . destination : <EOL> self . destination = self . _find_destination ( ) <EOL> self . migration . dest_compute = self . destination <EOL> self . migration . save ( ) <EOL> else : <EOL> self . _check_requested_destination ( ) <EOL> return self . compute_rpcapi . live_migration ( self . context , <EOL> host = self . source , <EOL> instance = self . instance , <EOL>", "answer": "dest = self . destination ,"}, {"prompt": "<s> import subprocess <EOL> import sys <EOL> from django . db . backends . base . creation import BaseDatabaseCreation <EOL> from . client import DatabaseClient <EOL> class DatabaseCreation ( BaseDatabaseCreation ) : <EOL> def sql_table_creation_suffix ( self ) : <EOL> suffix = [ ] <EOL> test_settings = self . connection . settings_dict [ '<STR_LIT>' ] <EOL> if test_settings [ '<STR_LIT>' ] : <EOL> suffix . append ( '<STR_LIT>' % test_settings [ '<STR_LIT>' ] ) <EOL> if test_settings [ '<STR_LIT>' ] : <EOL> suffix . append ( '<STR_LIT>' % test_settings [ '<STR_LIT>' ] ) <EOL> return '<STR_LIT:U+0020>' . join ( suffix ) <EOL> def _clone_test_db ( self , number , verbosity , keepdb = False ) : <EOL> qn = self . connection . ops . quote_name <EOL> source_database_name = self . connection . settings_dict [ '<STR_LIT>' ] <EOL> target_database_name = self . get_test_db_clone_settings ( number ) [ '<STR_LIT>' ] <EOL> with self . _nodb_connection . cursor ( ) as cursor : <EOL> try : <EOL> cursor . execute ( \"<STR_LIT>\" % qn ( target_database_name ) ) <EOL> except Exception as e : <EOL> if keepdb : <EOL> return <EOL> try : <EOL> if verbosity >= <NUM_LIT:1> : <EOL> print ( \"<STR_LIT>\" % ( <EOL> self . _get_database_display_str ( verbosity , target_database_name ) , <EOL> ) ) <EOL> cursor . execute ( \"<STR_LIT>\" % qn ( target_database_name ) ) <EOL> cursor . execute ( \"<STR_LIT>\" % qn ( target_database_name ) ) <EOL> except Exception as e : <EOL> sys . stderr . write ( \"<STR_LIT>\" % e ) <EOL> sys . exit ( <NUM_LIT:2> ) <EOL> dump_cmd = DatabaseClient . settings_to_cmd_args ( self . connection . settings_dict ) <EOL> dump_cmd [ <NUM_LIT:0> ] = '<STR_LIT>' <EOL> dump_cmd [ - <NUM_LIT:1> ] = source_database_name <EOL> load_cmd = DatabaseClient . settings_to_cmd_args ( self . connection . settings_dict ) <EOL> load_cmd [ - <NUM_LIT:1> ] = target_database_name <EOL>", "answer": "dump_proc = subprocess . Popen ( dump_cmd , stdout = subprocess . PIPE )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "SESSION_ID = '<STR_LIT>'"}, {"prompt": "<s> from textwrap import fill <EOL> import re <EOL> s = open ( \"<STR_LIT>\" ) . read ( ) <EOL> def repl1 ( obj ) : <EOL> eq = obj . group ( <NUM_LIT:1> ) <EOL> eq = eq . replace ( \"<STR_LIT:\\n>\" , \"<STR_LIT:U+0020>\" ) <EOL> eq = fill ( eq , <NUM_LIT> ) <EOL> return \"<STR_LIT>\" % eq <EOL> def repl6 ( obj ) : <EOL> eq = obj . group ( <NUM_LIT:1> ) <EOL> eq = eq . replace ( \"<STR_LIT:\\n>\" , \"<STR_LIT:U+0020>\" ) <EOL> eq = fill ( eq , <NUM_LIT> ) <EOL> return \"<STR_LIT>\" % eq <EOL> def repl4 ( obj ) : <EOL>", "answer": "eq = obj . group ( <NUM_LIT:1> )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import select <EOL> try : <EOL> import unittest2 as unittest <EOL> except ImportError : <EOL> import unittest <EOL> try : <EOL> from unittest import mock <EOL> except ImportError : <EOL> import mock <EOL> import errno <EOL> import os <EOL> import signal <EOL> import socket <EOL> import time <EOL> import threading <EOL> import pika <EOL> from pika . adapters import select_connection <EOL> from pika . adapters . select_connection import READ , WRITE <EOL> from functools import partial <EOL> class IOLoopBaseTest ( unittest . TestCase ) : <EOL> '''<STR_LIT>''' <EOL> SELECT_POLLER = None <EOL> TIMEOUT = <NUM_LIT:1.0> <EOL> def setUp ( self ) : <EOL> select_type_patch = mock . patch . multiple ( select_connection , <EOL> SELECT_TYPE = self . SELECT_POLLER ) <EOL> select_type_patch . start ( ) <EOL> self . addCleanup ( select_type_patch . stop ) <EOL> self . ioloop = select_connection . IOLoop ( ) <EOL> self . addCleanup ( setattr , self , '<STR_LIT>' , None ) <EOL> activate_poller_patch = mock . patch . object ( <EOL> self . ioloop . _poller , <EOL> '<STR_LIT>' , <EOL> wraps = self . ioloop . _poller . activate_poller ) <EOL> activate_poller_patch . start ( ) <EOL> self . addCleanup ( activate_poller_patch . stop ) <EOL> deactivate_poller_patch = mock . patch . object ( <EOL> self . ioloop . _poller , <EOL> '<STR_LIT>' , <EOL> wraps = self . ioloop . _poller . deactivate_poller ) <EOL> deactivate_poller_patch . start ( ) <EOL> self . addCleanup ( deactivate_poller_patch . stop ) <EOL> def shortDescription ( self ) : <EOL> method_desc = super ( IOLoopBaseTest , self ) . shortDescription ( ) <EOL> return \"<STR_LIT>\" % ( method_desc , self . SELECT_POLLER ) <EOL> def start ( self ) : <EOL> '''<STR_LIT>''' <EOL> fail_timer = self . ioloop . add_timeout ( self . TIMEOUT , self . on_timeout ) <EOL> self . addCleanup ( self . ioloop . remove_timeout , fail_timer ) <EOL> self . ioloop . start ( ) <EOL> self . ioloop . _poller . activate_poller . assert_called_once_with ( ) <EOL> self . ioloop . _poller . deactivate_poller . assert_called_once_with ( ) <EOL> def on_timeout ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . ioloop . stop ( ) <EOL> self . fail ( '<STR_LIT>' ) <EOL> class IOLoopThreadStopTestSelect ( IOLoopBaseTest ) : <EOL> '''<STR_LIT>''' <EOL> SELECT_POLLER = '<STR_LIT>' <EOL> def start_test ( self ) : <EOL> '''<STR_LIT>''' <EOL> timer = threading . Timer ( <NUM_LIT:0.1> , self . ioloop . stop ) <EOL> self . addCleanup ( timer . cancel ) <EOL> timer . start ( ) <EOL> self . start ( ) <EOL> @ unittest . skipIf ( <EOL> not hasattr ( select , '<STR_LIT>' ) or <EOL> not hasattr ( select . poll ( ) , '<STR_LIT>' ) , \"<STR_LIT>\" ) <EOL> class IOLoopThreadStopTestPoll ( IOLoopThreadStopTestSelect ) : <EOL> '''<STR_LIT>''' <EOL> SELECT_POLLER = '<STR_LIT>' <EOL> @ unittest . skipIf ( not hasattr ( select , '<STR_LIT>' ) , \"<STR_LIT>\" ) <EOL> class IOLoopThreadStopTestEPoll ( IOLoopThreadStopTestSelect ) : <EOL> '''<STR_LIT>''' <EOL> SELECT_POLLER = '<STR_LIT>' <EOL> @ unittest . skipIf ( not hasattr ( select , '<STR_LIT>' ) , \"<STR_LIT>\" ) <EOL> class IOLoopThreadStopTestKqueue ( IOLoopThreadStopTestSelect ) : <EOL> '''<STR_LIT>''' <EOL> SELECT_POLLER = '<STR_LIT>' <EOL> class IOLoopTimerTestSelect ( IOLoopBaseTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> NUM_TIMERS = <NUM_LIT:5> <EOL> TIMER_INTERVAL = <NUM_LIT> <EOL> SELECT_POLLER = '<STR_LIT>' <EOL> def set_timers ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . timer_stack = list ( ) <EOL> for i in range ( self . NUM_TIMERS , <NUM_LIT:0> , - <NUM_LIT:1> ) : <EOL> deadline = i * self . TIMER_INTERVAL <EOL> self . ioloop . add_timeout ( deadline , partial ( self . on_timer , i ) ) <EOL> self . timer_stack . append ( i ) <EOL> def start_test ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . set_timers ( ) <EOL> self . start ( ) <EOL> def on_timer ( self , val ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . assertEqual ( val , self . timer_stack . pop ( ) ) <EOL> if not self . timer_stack : <EOL> self . ioloop . stop ( ) <EOL> def test_normal ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . start_test ( ) <EOL> def test_timer_for_deleting_itself ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . timer_stack = list ( ) <EOL> handle_holder = [ ] <EOL> self . timer_got_fired = False <EOL> self . handle = self . ioloop . add_timeout ( <EOL> <NUM_LIT:0.1> , partial ( self . _on_timer_delete_itself , handle_holder ) ) <EOL> handle_holder . append ( self . handle ) <EOL> self . start ( ) <EOL> self . assertTrue ( self . timer_got_called ) <EOL> def _on_timer_delete_itself ( self , handle_holder ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . assertEqual ( self . handle , handle_holder . pop ( ) ) <EOL> self . timer_got_called = True <EOL> self . ioloop . remove_timeout ( self . handle ) <EOL> self . ioloop . stop ( ) <EOL> def test_timer_delete_another ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> holder_for_target_timer = [ ] <EOL> self . ioloop . add_timeout ( <EOL> <NUM_LIT> , partial ( self . _on_timer_delete_another , <EOL> holder_for_target_timer ) ) <EOL> timer_2 = self . ioloop . add_timeout ( <EOL> <NUM_LIT> , self . _on_timer_no_call ) <EOL> holder_for_target_timer . append ( timer_2 ) <EOL> time . sleep ( <NUM_LIT> ) <EOL> self . start ( ) <EOL> self . assertTrue ( self . deleted_another_timer ) <EOL> self . assertTrue ( self . concluded ) <EOL> def _on_timer_delete_another ( self , holder ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> target_timer = holder [ <NUM_LIT:0> ] <EOL> self . ioloop . remove_timeout ( target_timer ) <EOL> self . deleted_another_timer = True <EOL> def _on_timer_conclude ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . concluded = True <EOL> self . assertTrue ( self . deleted_another_timer ) <EOL> self . assertNotIn ( target_timer , self . ioloop . _poller . _timeouts ) <EOL> self . ioloop . stop ( ) <EOL> self . ioloop . add_timeout ( <NUM_LIT> , _on_timer_conclude ) <EOL> def _on_timer_no_call ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . fail ( '<STR_LIT>' ) <EOL> @ unittest . skipIf ( <EOL> not hasattr ( select , '<STR_LIT>' ) or <EOL> not hasattr ( select . poll ( ) , '<STR_LIT>' ) , \"<STR_LIT>\" ) <EOL> class IOLoopTimerTestPoll ( IOLoopTimerTestSelect ) : <EOL> '''<STR_LIT>''' <EOL> SELECT_POLLER = '<STR_LIT>' <EOL> @ unittest . skipIf ( not hasattr ( select , '<STR_LIT>' ) , \"<STR_LIT>\" ) <EOL> class IOLoopTimerTestEPoll ( IOLoopTimerTestSelect ) : <EOL> '''<STR_LIT>''' <EOL> SELECT_POLLER = '<STR_LIT>' <EOL> @ unittest . skipIf ( not hasattr ( select , '<STR_LIT>' ) , \"<STR_LIT>\" ) <EOL> class IOLoopTimerTestKqueue ( IOLoopTimerTestSelect ) : <EOL> '''<STR_LIT>''' <EOL> SELECT_POLLER = '<STR_LIT>' <EOL> class IOLoopSleepTimerTestSelect ( IOLoopTimerTestSelect ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def start_test ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . set_timers ( ) <EOL> time . sleep ( self . NUM_TIMERS * self . TIMER_INTERVAL ) <EOL> self . start ( ) <EOL> @ unittest . skipIf ( <EOL> not hasattr ( select , '<STR_LIT>' ) or <EOL> not hasattr ( select . poll ( ) , '<STR_LIT>' ) , \"<STR_LIT>\" ) <EOL> class IOLoopSleepTimerTestPoll ( IOLoopSleepTimerTestSelect ) : <EOL> '''<STR_LIT>''' <EOL> SELECT_POLLER = '<STR_LIT>' <EOL> @ unittest . skipIf ( not hasattr ( select , '<STR_LIT>' ) , \"<STR_LIT>\" ) <EOL> class IOLoopSleepTimerTestEPoll ( IOLoopSleepTimerTestSelect ) : <EOL> '''<STR_LIT>''' <EOL> SELECT_POLLER = '<STR_LIT>' <EOL> @ unittest . skipIf ( not hasattr ( select , '<STR_LIT>' ) , \"<STR_LIT>\" ) <EOL> class IOLoopSleepTimerTestKqueue ( IOLoopSleepTimerTestSelect ) : <EOL> '''<STR_LIT>''' <EOL> SELECT_POLLER = '<STR_LIT>' <EOL> class IOLoopSocketBaseSelect ( IOLoopBaseTest ) : <EOL> '''<STR_LIT>''' <EOL> SELECT_POLLER = '<STR_LIT>' <EOL> READ_SIZE = <NUM_LIT> <EOL> def save_sock ( self , sock ) : <EOL> '''<STR_LIT>''' <EOL> fd_ = sock . fileno ( ) <EOL> self . sock_map [ fd_ ] = sock <EOL> return fd_ <EOL> def setUp ( self ) : <EOL> super ( IOLoopSocketBaseSelect , self ) . setUp ( ) <EOL> self . sock_map = dict ( ) <EOL> self . create_accept_socket ( ) <EOL> def tearDown ( self ) : <EOL> for fd_ in self . sock_map : <EOL> self . ioloop . remove_handler ( fd_ ) <EOL> self . sock_map [ fd_ ] . close ( ) <EOL> super ( IOLoopSocketBaseSelect , self ) . tearDown ( ) <EOL> def create_accept_socket ( self ) : <EOL> '''<STR_LIT>''' <EOL> listen_sock = socket . socket ( ) <EOL> listen_sock . setblocking ( <NUM_LIT:0> ) <EOL> listen_sock . bind ( ( '<STR_LIT:localhost>' , <NUM_LIT:0> ) ) <EOL> listen_sock . listen ( <NUM_LIT:1> ) <EOL> fd_ = self . save_sock ( listen_sock ) <EOL> self . listen_addr = listen_sock . getsockname ( ) <EOL> self . ioloop . add_handler ( fd_ , self . do_accept , READ ) <EOL> def create_write_socket ( self , on_connected ) : <EOL> '''<STR_LIT>''' <EOL>", "answer": "write_sock = socket . socket ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import binascii <EOL> import io <EOL> import logging <EOL> from . opcodes import OPCODE_TO_INT , INT_TO_OPCODE <EOL> bytes_from_int = chr if bytes == str else lambda x : bytes ( [ x ] ) <EOL> bytes_to_ints = ( lambda x : ( ord ( c ) for c in x ) ) if bytes == str else lambda x : x <EOL> if hasattr ( int , \"<STR_LIT>\" ) : <EOL> int_to_bytes = lambda v : v . to_bytes ( ( v . bit_length ( ) + <NUM_LIT:7> ) // <NUM_LIT:8> , byteorder = \"<STR_LIT>\" ) <EOL> else : <EOL> def int_to_bytes ( v ) : <EOL> l = bytearray ( ) <EOL> while v > <NUM_LIT:0> : <EOL> v , mod = divmod ( v , <NUM_LIT> ) <EOL> l . append ( mod ) <EOL> l . reverse ( ) <EOL> return bytes ( l ) <EOL> if hasattr ( int , \"<STR_LIT>\" ) : <EOL> bytes_to_int = lambda v : int . from_bytes ( v , byteorder = \"<STR_LIT>\" ) <EOL> else : <EOL> def bytes_to_int ( s ) : <EOL> v = <NUM_LIT:0> <EOL> b = <NUM_LIT:0> <EOL> for c in bytes_to_ints ( s ) : <EOL> v += ( c << b ) <EOL> b += <NUM_LIT:8> <EOL> return v <EOL> def get_opcode ( script , pc ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> opcode = ord ( script [ pc : pc + <NUM_LIT:1> ] ) <EOL> pc += <NUM_LIT:1> <EOL> data = b'<STR_LIT>' <EOL> if opcode <= OPCODE_TO_INT [ \"<STR_LIT>\" ] : <EOL> if opcode < OPCODE_TO_INT [ \"<STR_LIT>\" ] : <EOL> size = opcode <EOL> elif opcode == OPCODE_TO_INT [ \"<STR_LIT>\" ] : <EOL> size = bytes_to_int ( script [ pc : pc + <NUM_LIT:1> ] ) <EOL> pc += <NUM_LIT:1> <EOL> elif opcode == OPCODE_TO_INT [ \"<STR_LIT>\" ] : <EOL> size = bytes_to_int ( script [ pc : pc + <NUM_LIT:2> ] ) <EOL> pc += <NUM_LIT:2> <EOL> elif opcode == OPCODE_TO_INT [ \"<STR_LIT>\" ] : <EOL> size = bytes_to_int ( script [ pc : pc + <NUM_LIT:4> ] ) <EOL> pc += <NUM_LIT:4> <EOL> data = script [ pc : pc + size ] <EOL> pc += size <EOL> return opcode , data , pc <EOL> def compile ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> f = io . BytesIO ( ) <EOL> for t in s . split ( ) : <EOL> if t in OPCODE_TO_INT : <EOL> f . write ( bytes_from_int ( OPCODE_TO_INT [ t ] ) ) <EOL> else : <EOL> t = binascii . unhexlify ( t . encode ( \"<STR_LIT:utf8>\" ) ) <EOL> f . write ( bytes_from_int ( len ( t ) ) ) <EOL> f . write ( t ) <EOL> return f . getvalue ( ) <EOL> def disassemble ( script ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> opcodes = [ ] <EOL> pc = <NUM_LIT:0> <EOL> while pc < len ( script ) : <EOL> opcode , data , pc = get_opcode ( script , pc ) <EOL> if len ( data ) > <NUM_LIT:0> : <EOL> opcodes . append ( binascii . hexlify ( data ) . decode ( \"<STR_LIT:utf8>\" ) ) <EOL> continue <EOL> if not opcode in INT_TO_OPCODE : <EOL> logging . info ( \"<STR_LIT>\" , opcode ) <EOL> continue <EOL> opcodes . append ( INT_TO_OPCODE [ opcode ] ) <EOL> return '<STR_LIT:U+0020>' . join ( opcodes ) <EOL> def delete_subscript ( script , subscript ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> new_script = bytearray ( ) <EOL> pc = <NUM_LIT:0> <EOL> size = len ( subscript ) <EOL> while pc < len ( script ) : <EOL> if script [ pc : pc + size ] == subscript : <EOL>", "answer": "pc += size"}, {"prompt": "<s> from rest_framework import serializers <EOL> from ralph . api import RalphAPISerializer <EOL> from ralph . assets . api . serializers import AssetSerializer , BaseObjectSerializer <EOL> from ralph . data_center . models import ( <EOL> Accessory , <EOL> Cluster , <EOL> ClusterType , <EOL> Database , <EOL> DataCenter , <EOL> DataCenterAsset , <EOL> Rack , <EOL>", "answer": "RackAccessory ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> from spockbot . plugins . core . settings import SettingsPlugin <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> base_warn = \"<STR_LIT>\" <EOL> pl_warn = base_warn + \"<STR_LIT>\" <EOL>", "answer": "class PluginLoader ( object ) :"}, {"prompt": "<s> import jinja2 <EOL> class Markup ( ) : <EOL> def __init__ ( self , url_slug , embed = False ) : <EOL> self . url_slug = url_slug <EOL> self . template = self . _create_template ( \"<STR_LIT>\" ) <EOL> self . context = { <EOL> \"<STR_LIT>\" : embed , <EOL> \"<STR_LIT>\" : url_slug <EOL> } <EOL> def _create_template ( self , template_name ) : <EOL>", "answer": "template_loader = jinja2 . FileSystemLoader ( searchpath = \"<STR_LIT>\" )"}, {"prompt": "<s> class CORSRule ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , allowed_method = None , allowed_origin = None , <EOL> id = None , allowed_header = None , max_age_seconds = None , <EOL> expose_header = None ) : <EOL> if allowed_method is None : <EOL> allowed_method = [ ] <EOL> self . allowed_method = allowed_method <EOL> if allowed_origin is None : <EOL> allowed_origin = [ ] <EOL> self . allowed_origin = allowed_origin <EOL> self . id = id <EOL> if allowed_header is None : <EOL> allowed_header = [ ] <EOL> self . allowed_header = allowed_header <EOL> self . max_age_seconds = max_age_seconds <EOL> if expose_header is None : <EOL> expose_header = [ ] <EOL> self . expose_header = expose_header <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % self . id <EOL> def startElement ( self , name , attrs , connection ) : <EOL> return None <EOL> def endElement ( self , name , value , connection ) : <EOL> if name == '<STR_LIT>' : <EOL> self . id = value <EOL> elif name == '<STR_LIT>' : <EOL> self . allowed_method . append ( value ) <EOL> elif name == '<STR_LIT>' : <EOL> self . allowed_origin . append ( value ) <EOL> elif name == '<STR_LIT>' : <EOL> self . allowed_header . append ( value ) <EOL> elif name == '<STR_LIT>' : <EOL> self . max_age_seconds = int ( value ) <EOL> elif name == '<STR_LIT>' : <EOL> self . expose_header . append ( value ) <EOL> else : <EOL> setattr ( self , name , value ) <EOL> def to_xml ( self ) : <EOL> s = '<STR_LIT>' <EOL> for allowed_method in self . allowed_method : <EOL> s += '<STR_LIT>' % allowed_method <EOL> for allowed_origin in self . allowed_origin : <EOL> s += '<STR_LIT>' % allowed_origin <EOL> for allowed_header in self . allowed_header : <EOL> s += '<STR_LIT>' % allowed_header <EOL> for expose_header in self . expose_header : <EOL> s += '<STR_LIT>' % expose_header <EOL> if self . max_age_seconds : <EOL> s += '<STR_LIT>' % self . max_age_seconds <EOL> if self . id : <EOL> s += '<STR_LIT>' % self . id <EOL> s += '<STR_LIT>' <EOL> return s <EOL> class CORSConfiguration ( list ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def startElement ( self , name , attrs , connection ) : <EOL> if name == '<STR_LIT>' : <EOL> rule = CORSRule ( ) <EOL> self . append ( rule ) <EOL> return rule <EOL> return None <EOL> def endElement ( self , name , value , connection ) : <EOL>", "answer": "setattr ( self , name , value )"}, {"prompt": "<s> from django . conf . urls import url <EOL> from . import views <EOL> urlpatterns = [ <EOL> url ( r'<STR_LIT>' , views . extra_view , { '<STR_LIT:message>' : '<STR_LIT>' } , name = '<STR_LIT>' ) , <EOL>", "answer": "] "}, {"prompt": "<s> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL>", "answer": "import multiple_definition_variable_instance"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> import os <EOL> import hotshot <EOL> import hotshot . stats <EOL> import threading <EOL> import cgi <EOL> import six <EOL> import time <EOL> from cStringIO import StringIO <EOL> from paste import response <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> class ProfileMiddleware ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> style = ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> def __init__ ( self , app , global_conf = None , <EOL> log_filename = '<STR_LIT>' , <EOL> limit = <NUM_LIT> ) : <EOL> self . app = app <EOL> self . lock = threading . Lock ( ) <EOL> self . log_filename = log_filename <EOL> self . limit = limit <EOL> def __call__ ( self , environ , start_response ) : <EOL> catch_response = [ ] <EOL> body = [ ] <EOL> def replace_start_response ( status , headers , exc_info = None ) : <EOL> catch_response . extend ( [ status , headers ] ) <EOL> start_response ( status , headers , exc_info ) <EOL> return body . append <EOL> def run_app ( ) : <EOL> app_iter = self . app ( environ , replace_start_response ) <EOL> try : <EOL> body . extend ( app_iter ) <EOL> finally : <EOL> if hasattr ( app_iter , '<STR_LIT>' ) : <EOL> app_iter . close ( ) <EOL> self . lock . acquire ( ) <EOL> try : <EOL> prof = hotshot . Profile ( self . log_filename ) <EOL> prof . addinfo ( '<STR_LIT>' , environ . get ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> try : <EOL> prof . runcall ( run_app ) <EOL> finally : <EOL> prof . close ( ) <EOL> body = '<STR_LIT>' . join ( body ) <EOL> headers = catch_response [ <NUM_LIT:1> ] <EOL> content_type = response . header_value ( headers , '<STR_LIT>' ) <EOL> if content_type is None or not content_type . startswith ( '<STR_LIT>' ) : <EOL> return [ body ] <EOL> stats = hotshot . stats . load ( self . log_filename ) <EOL> stats . strip_dirs ( ) <EOL> stats . sort_stats ( '<STR_LIT:time>' , '<STR_LIT>' ) <EOL> output = capture_output ( stats . print_stats , self . limit ) <EOL> output_callers = capture_output ( <EOL> stats . print_callers , self . limit ) <EOL> body += '<STR_LIT>' % ( <EOL> self . style , cgi . escape ( output ) , cgi . escape ( output_callers ) ) <EOL> return [ body ] <EOL> finally : <EOL> self . lock . release ( ) <EOL> def capture_output ( func , * args , ** kw ) : <EOL> out = StringIO ( ) <EOL> old_stdout = sys . stdout <EOL> sys . stdout = out <EOL> try : <EOL> func ( * args , ** kw ) <EOL> finally : <EOL> sys . stdout = old_stdout <EOL> return out . getvalue ( ) <EOL> def profile_decorator ( ** options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if options . get ( '<STR_LIT>' ) : <EOL> def decorator ( func ) : <EOL> return func <EOL> return decorator <EOL> def decorator ( func ) : <EOL> def replacement ( * args , ** kw ) : <EOL> return DecoratedProfile ( func , ** options ) ( * args , ** kw ) <EOL> return replacement <EOL> return decorator <EOL> class DecoratedProfile ( object ) : <EOL> lock = threading . Lock ( ) <EOL> def __init__ ( self , func , ** options ) : <EOL> self . func = func <EOL> self . options = options <EOL> def __call__ ( self , * args , ** kw ) : <EOL> self . lock . acquire ( ) <EOL> try : <EOL> return self . profile ( self . func , * args , ** kw ) <EOL> finally : <EOL> self . lock . release ( ) <EOL> def profile ( self , func , * args , ** kw ) : <EOL> ops = self . options <EOL> prof_filename = ops . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> prof = hotshot . Profile ( prof_filename ) <EOL> prof . addinfo ( '<STR_LIT>' , <EOL> self . format_function ( func , * args , ** kw ) ) <EOL> if ops . get ( '<STR_LIT>' ) : <EOL> prof . addinfo ( '<STR_LIT>' , ops [ '<STR_LIT>' ] ) <EOL> exc_info = None <EOL> try : <EOL>", "answer": "start_time = time . time ( )"}, {"prompt": "<s> import six <EOL> from nailgun . db import db <EOL> from nailgun . db . sqlalchemy . models import MasterNodeSettings <EOL> from nailgun import errors <EOL> from nailgun import logger <EOL> from nailgun . objects . base import NailgunObject <EOL> from nailgun . objects . serializers . master_node_settings import MasterNodeSettingsSerializer <EOL> class MasterNodeSettings ( NailgunObject ) : <EOL> model = MasterNodeSettings <EOL> serializer = MasterNodeSettingsSerializer <EOL> @ classmethod <EOL> def get_one ( cls , fail_if_not_found = False , lock_for_update = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> q = db ( ) . query ( cls . model ) <EOL> if lock_for_update : <EOL> q = q . with_lockmode ( '<STR_LIT>' ) <EOL>", "answer": "res = q . first ( )"}, {"prompt": "<s> from __future__ import unicode_literals <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import getopt <EOL> import json <EOL> import requests <EOL> import sys <EOL> import urllib <EOL> from keys import YAHOO_APP_ID <EOL> WHERE_API_BASE_URL = '<STR_LIT>' <EOL> WHERE_API_QUERY_URL = WHERE_API_BASE_URL + \"<STR_LIT>\" <EOL> WHERE_API_RESOLVE_URL = WHERE_API_BASE_URL + '<STR_LIT>' <EOL> class Usage ( Exception ) : <EOL> def __init__ ( self , msg ) : <EOL> self . msg = msg <EOL> def main ( argv = None ) : <EOL> OPT_STR = '<STR_LIT>' <EOL> OPT_LIST = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> is_query = True <EOL> if argv is None : <EOL> argv = sys . argv <EOL> try : <EOL> try : <EOL> progname = argv [ <NUM_LIT:0> ] <EOL> opts , args = getopt . getopt ( argv [ <NUM_LIT:1> : ] , <EOL> OPT_STR , <EOL> OPT_LIST ) <EOL> except getopt . error , msg : <EOL> raise Usage ( msg ) <EOL> for o , a in opts : <EOL> if o in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> print __doc__ <EOL> sys . exit ( <NUM_LIT:0> ) <EOL> elif o in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> is_query = True <EOL> elif o in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> is_query = False <EOL> if len ( args ) == <NUM_LIT:1> : <EOL> if is_query : <EOL> woeid = get_woeid ( args [ <NUM_LIT:0> ] ) <EOL> print woeid <EOL> else : <EOL> place = resolve_woeid ( args [ <NUM_LIT:0> ] ) <EOL> print place <EOL> else : <EOL> raise Usage ( '<STR_LIT>' ) <EOL> except Usage , err : <EOL> print >> sys . stderr , err . msg <EOL> print >> sys . stderr , \"<STR_LIT>\" <EOL> return <NUM_LIT> <EOL> def get_woeid ( location ) : <EOL> query = urllib . quote ( location , '<STR_LIT>' ) <EOL> values = { <EOL> '<STR_LIT>' : YAHOO_APP_ID , <EOL> '<STR_LIT>' : query , <EOL> } <EOL> url = WHERE_API_QUERY_URL % values <EOL> response = requests . get ( url ) <EOL> data = json . loads ( response . text ) <EOL> try : <EOL> places = data [ '<STR_LIT>' ] <EOL> if places [ '<STR_LIT:count>' ] > <NUM_LIT:0> : <EOL> place = places [ '<STR_LIT>' ] [ <NUM_LIT:0> ] <EOL> woeid = place [ '<STR_LIT>' ] <EOL> else : <EOL> woeid = None <EOL> except KeyError , k : <EOL> woeid = None <EOL> return woeid <EOL> def resolve_woeid ( woeid ) : <EOL> values = { <EOL> '<STR_LIT>' : YAHOO_APP_ID , <EOL> '<STR_LIT>' : woeid <EOL> } <EOL> url = WHERE_API_RESOLVE_URL % values <EOL> response = requests . get ( url ) <EOL>", "answer": "data = json . loads ( response . text )"}, {"prompt": "<s> import os <EOL> from ajenti . api import * <EOL> from ajenti . ui . binder import Binder <EOL> from ajenti . plugins . main . api import SectionPlugin <EOL> from ajenti . ui import on <EOL> from reconfigure . configs import NetatalkConfig <EOL> from reconfigure . items . netatalk import ShareData <EOL> @ plugin <EOL> class Netatalk ( SectionPlugin ) : <EOL> config_path = '<STR_LIT>' <EOL> def init ( self ) : <EOL> self . title = '<STR_LIT>' <EOL> self . icon = '<STR_LIT>' <EOL> self . category = _ ( '<STR_LIT>' ) <EOL> self . append ( self . ui . inflate ( '<STR_LIT>' ) ) <EOL> if not os . path . exists ( self . config_path ) : <EOL> open ( self . config_path , '<STR_LIT:w>' ) . write ( \"<STR_LIT>\" ) <EOL> self . binder = Binder ( None , self . find ( '<STR_LIT>' ) ) <EOL> self . find ( '<STR_LIT>' ) . new_item = lambda c : ShareData ( ) <EOL> self . config = NetatalkConfig ( path = self . config_path ) <EOL> def on_page_load ( self ) : <EOL> self . refresh ( ) <EOL>", "answer": "def refresh ( self ) :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Static ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import re <EOL> import tarfile <EOL> def _proc_pax ( self , filetar ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> buf = filetar . fileobj . read ( self . _block ( self . size ) ) <EOL> if self . type == tarfile . XGLTYPE : <EOL> pax_headers = filetar . pax_headers <EOL> else : <EOL> pax_headers = filetar . pax_headers . copy ( ) <EOL> regex = re . compile ( r\"<STR_LIT>\" , re . U ) <EOL> pos = <NUM_LIT:0> <EOL> while True : <EOL> match = regex . match ( buf , pos ) <EOL> if not match : <EOL> break <EOL> length , keyword = match . groups ( ) <EOL> length = int ( length ) <EOL> value = buf [ match . end ( <NUM_LIT:2> ) + <NUM_LIT:1> : match . start ( <NUM_LIT:1> ) + length - <NUM_LIT:1> ] <EOL> try : <EOL> keyword = keyword . decode ( \"<STR_LIT:utf8>\" ) <EOL> except Exception : <EOL> pass <EOL> try : <EOL> value = value . decode ( \"<STR_LIT:utf8>\" ) <EOL> except Exception : <EOL> pass <EOL> pax_headers [ keyword ] = value <EOL> pos += length <EOL> try : <EOL> next = self . fromtarfile ( filetar ) <EOL> except tarfile . HeaderError : <EOL> raise tarfile . SubsequentHeaderError ( \"<STR_LIT>\" ) <EOL> if self . type in ( tarfile . XHDTYPE , tarfile . SOLARIS_XHDTYPE ) : <EOL> next . _apply_pax_info ( pax_headers , filetar . encoding , filetar . errors ) <EOL> next . offset = self . offset <EOL> if \"<STR_LIT:size>\" in pax_headers : <EOL>", "answer": "offset = next . offset_data"}, {"prompt": "<s> from gluon . contrib . simplejson . ordered_dict import OrderedDict <EOL> from gluon import current , A , DIV , H3 , TAG , SQLFORM , IS_NOT_EMPTY , IS_EMAIL <EOL> from gluon . storage import Storage <EOL> def config ( settings ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> T = current . T <EOL> settings . base . prepopulate += ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> settings . base . system_name = T ( \"<STR_LIT>\" ) <EOL> settings . base . system_name_short = T ( \"<STR_LIT>\" ) <EOL> settings . base . theme = \"<STR_LIT>\" <EOL> settings . security . policy = <NUM_LIT:6> <EOL> settings . security . map = True <EOL> settings . auth . registration_requires_verification = True <EOL> settings . auth . registration_requires_approval = True <EOL> settings . auth . registration_requests_organisation = True <EOL> settings . auth . registration_pending = \"\"\"<STR_LIT>\"\"\" % settings . get_mail_approver ( ) <EOL> settings . auth . record_approval = True <EOL> settings . auth . record_approval_required_for = ( \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ) <EOL> settings . L10n . languages = OrderedDict ( [ <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> ] ) <EOL> settings . L10n . default_language = \"<STR_LIT>\" <EOL> settings . L10n . utc_offset = \"<STR_LIT>\" <EOL> settings . L10n . decimal_separator = \"<STR_LIT:.>\" <EOL> settings . L10n . thousands_separator = \"<STR_LIT:U+002C>\" <EOL> settings . fin . currencies = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> settings . gis . map_height = <NUM_LIT> <EOL> settings . gis . map_width = <NUM_LIT> <EOL> settings . gis . display_L0 = True <EOL> settings . gis . countries = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> settings . gis . poi_create_resources = None <EOL> settings . org . branches = True <EOL> settings . project . mode_3w = True <EOL> settings . project . mode_drr = True <EOL> settings . project . codes = True <EOL> settings . project . hazards = True <EOL> settings . project . multiple_organisations = True <EOL> settings . project . sectors = False <EOL> settings . project . themes = True <EOL> settings . project . organisation_roles = { <EOL> <NUM_LIT:1> : T ( \"<STR_LIT>\" ) , <EOL> <NUM_LIT:2> : T ( \"<STR_LIT>\" ) , <EOL> <NUM_LIT:3> : T ( \"<STR_LIT>\" ) , <EOL> <NUM_LIT:9> : T ( \"<STR_LIT>\" ) , <EOL> } <EOL> settings . ui . cluster = True <EOL> settings . ui . hide_report_options = False <EOL> settings . ui . hide_report_filter_options = True <EOL> settings . ui . export_formats = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> settings . ui . interim_save = True <EOL> settings . ui . datatables_responsive = False <EOL> def formstyle_row ( id , label , widget , comment , hidden = False ) : <EOL> if hidden : <EOL> hide = \"<STR_LIT>\" <EOL> else : <EOL> hide = \"<STR_LIT>\" <EOL> row = DIV ( DIV ( label , <EOL> _id = id + \"<STR_LIT>\" , <EOL> _class = \"<STR_LIT>\" ) , <EOL> DIV ( widget , <EOL> _id = id + \"<STR_LIT>\" , <EOL> _class = \"<STR_LIT>\" ) , <EOL> DIV ( comment , <EOL> _id = id + \"<STR_LIT>\" , <EOL> _class = \"<STR_LIT>\" ) , <EOL> _id = id , <EOL> _class = \"<STR_LIT>\" % hide , <EOL> ) <EOL> return row <EOL> def formstyle ( self , xfields ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> form = DIV ( ) <EOL> for id , a , b , c , in xfields : <EOL> form . append ( formstyle_row ( id , a , b , c ) ) <EOL> return form <EOL> settings . ui . formstyle_row = formstyle_row <EOL> settings . ui . formstyle = formstyle_row <EOL> def customise_project_project_controller ( ** attr ) : <EOL> db = current . db <EOL> s3db = current . s3db <EOL> s3 = current . response . s3 <EOL> tablename = \"<STR_LIT>\" <EOL> table = s3db [ tablename ] <EOL> s3db . add_components ( tablename , <EOL> project_drrpp = { \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : False , <EOL> } , <EOL> project_output = \"<STR_LIT>\" , <EOL> doc_document = ( <EOL> { \"<STR_LIT:name>\" : \"<STR_LIT:file>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT:url>\" , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , None ) , <EOL> } , <EOL> { \"<STR_LIT:name>\" : \"<STR_LIT:url>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT:file>\" , <EOL> \"<STR_LIT>\" : ( \"<STR_LIT>\" , None ) , <EOL> } , <EOL> ) , <EOL> ) <EOL> table . name . label = T ( \"<STR_LIT>\" ) <EOL> s3db . project_project . budget . label = T ( \"<STR_LIT>\" ) <EOL> location_id = s3db . project_location . location_id <EOL> location_id . label = \"<STR_LIT>\" <EOL> location_id . requires = s3db . gis_country_requires <EOL> location_id . widget = None <EOL> table = s3db . project_organisation <EOL> table . comments . label = T ( \"<STR_LIT>\" ) <EOL> table . comments . widget = SQLFORM . widgets . string . widget <EOL> table . amount . label = T ( \"<STR_LIT>\" ) <EOL> table = s3db . doc_document <EOL> table . file . widget = lambda field , value , download_url : SQLFORM . widgets . upload . widget ( field , value , download_url , _size = <NUM_LIT:15> ) <EOL> table . comments . widget = SQLFORM . widgets . string . widget <EOL> logged_in = current . auth . is_logged_in ( ) <EOL> if not logged_in : <EOL> table = s3db . project_drrpp <EOL> table . focal_person . required = True <EOL> table . email . required = True <EOL> table . email . requires = IS_EMAIL ( ) <EOL> s3 [ \"<STR_LIT>\" ] = '<STR_LIT>' <EOL> s3 . formats = Storage ( xls = None , xml = None ) <EOL> attr [ \"<STR_LIT>\" ] = None <EOL> attr [ \"<STR_LIT>\" ] = [ [ <NUM_LIT:10> , <NUM_LIT:50> , - <NUM_LIT:1> ] , [ <NUM_LIT:10> , <NUM_LIT:50> , T ( \"<STR_LIT>\" ) ] ] <EOL> s3 . dataTable_pageLength = <NUM_LIT:10> <EOL> standard_prep = s3 . prep <EOL> def custom_prep ( r ) : <EOL> resource = r . resource <EOL> if callable ( standard_prep ) : <EOL> result = standard_prep ( r ) <EOL> if not result : <EOL> return False <EOL> if r . method == \"<STR_LIT>\" : <EOL> list_fields = [ \"<STR_LIT:id>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT:name>\" , <EOL> \"<STR_LIT>\" , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ] <EOL> elif r . representation == \"<STR_LIT>\" : <EOL> list_fields = [ \"<STR_LIT:id>\" , <EOL> \"<STR_LIT:name>\" , <EOL> \"<STR_LIT:code>\" , <EOL> \"<STR_LIT:description>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> if logged_in : <EOL> list_fields . extend ( [ \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] ) <EOL> else : <EOL> list_fields = [ \"<STR_LIT:id>\" , <EOL> \"<STR_LIT:name>\" , <EOL> \"<STR_LIT>\" , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ] <EOL> resource . configure ( list_fields = list_fields ) <EOL> if r . method == \"<STR_LIT>\" : <EOL> report_fields = [ \"<STR_LIT:name>\" , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ] <EOL> if \"<STR_LIT>\" in r . get_vars and r . representation != \"<STR_LIT>\" : <EOL> s3 . crud_strings [ tablename ] . title_report = T ( \"<STR_LIT>\" ) <EOL> report_fact_default = \"<STR_LIT>\" <EOL> report_facts = [ ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ] <EOL> show_table = False <EOL> else : <EOL> s3 . crud_strings [ tablename ] . title_report = T ( \"<STR_LIT>\" ) <EOL> report_fact_default = \"<STR_LIT>\" <EOL> report_facts = [ ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ( T ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) , <EOL> ] <EOL> show_table = True <EOL> report_options = Storage ( rows = report_fields , <EOL> cols = report_fields , <EOL> fact = report_facts , <EOL> defaults = Storage ( rows = \"<STR_LIT>\" , <EOL> cols = \"<STR_LIT>\" , <EOL> fact = report_fact_default , <EOL> totals = True , <EOL> table = show_table , <EOL> ) <EOL> ) <EOL> resource . configure ( report_options = report_options ) <EOL> current . deployment_settings . ui . hide_report_options = True <EOL> if r . interactive : <EOL> if r . method is None and not r . id : <EOL> resource . configure ( editable = False , <EOL> deletable = False <EOL> ) <EOL> s3 . scripts . append ( \"<STR_LIT>\" % current . request . application ) <EOL> if r . method == \"<STR_LIT>\" : <EOL> table_pl = s3db . project_location <EOL> table_l = s3db . gis_location <EOL> countries = [ row . name for row in <EOL> db ( ( table_pl . project_id == r . record . id ) & <EOL> ( table_pl . location_id == table_l . id ) <EOL> ) . select ( table_l . name ) <EOL> ] <EOL> if not ( \"<STR_LIT>\" in countries and len ( countries ) == <NUM_LIT:1> ) : <EOL> s3db . project_drrpp . L1 . readable = False <EOL> s3db . project_drrpp . pifacc . readable = False <EOL> s3db . project_drrpp . jnap . readable = False <EOL> project_hfa_opts = s3db . project_hfa_opts ( ) <EOL> hfa_options = dict ( ( key , \"<STR_LIT>\" % key ) <EOL> for key in project_hfa_opts ) <EOL> project_rfa_opts = s3db . project_rfa_opts ( ) <EOL> rfa_options = dict ( ( key , \"<STR_LIT>\" % key ) <EOL> for key in project_rfa_opts ) <EOL> project_pifacc_opts = s3db . project_pifacc_opts ( ) <EOL> pifacc_options = dict ( ( key , \"<STR_LIT>\" % key ) <EOL> for key in project_pifacc_opts ) <EOL> project_jnap_opts = s3db . project_jnap_opts ( ) <EOL> jnap_options = dict ( ( key , \"<STR_LIT>\" % key ) <EOL> for key in project_jnap_opts ) <EOL> from s3 import S3TextFilter , S3OptionsFilter , s3_get_filter_opts <EOL> filter_widgets = [ <EOL> S3TextFilter ( [ \"<STR_LIT:name>\" , <EOL> \"<STR_LIT:code>\" , <EOL> \"<STR_LIT:description>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> label = T ( \"<STR_LIT>\" ) , <EOL> comment = T ( \"<STR_LIT>\" ) , <EOL> ) , <EOL> S3OptionsFilter ( \"<STR_LIT>\" , <EOL> label = T ( \"<STR_LIT>\" ) , <EOL> cols = <NUM_LIT:4> , <EOL> ) , <EOL> S3OptionsFilter ( \"<STR_LIT>\" , <EOL> label = T ( \"<STR_LIT>\" ) , <EOL> cols = <NUM_LIT:3> , <EOL> hidden = True , <EOL> ) , <EOL> S3OptionsFilter ( \"<STR_LIT>\" , <EOL> label = T ( \"<STR_LIT>\" ) , <EOL> options = lambda : s3_get_filter_opts ( \"<STR_LIT>\" , <EOL> translate = True ) , <EOL> help_field = s3db . project_hazard_help_fields , <EOL> cols = <NUM_LIT:4> , <EOL> hidden = True , <EOL> ) , <EOL> S3OptionsFilter ( \"<STR_LIT>\" , <EOL> label = T ( \"<STR_LIT>\" ) , <EOL> options = lambda : s3_get_filter_opts ( \"<STR_LIT>\" , <EOL> translate = True ) , <EOL> help_field = s3db . project_theme_help_fields , <EOL> cols = <NUM_LIT:4> , <EOL> size = None , <EOL> hidden = True , <EOL> ) , <EOL> S3OptionsFilter ( \"<STR_LIT>\" , <EOL> label = T ( \"<STR_LIT>\" ) , <EOL> options = hfa_options , <EOL> help_field = project_hfa_opts , <EOL> cols = <NUM_LIT:5> , <EOL> hidden = True , <EOL> ) , <EOL> S3OptionsFilter ( \"<STR_LIT>\" , <EOL> label = T ( \"<STR_LIT>\" ) , <EOL> options = rfa_options , <EOL> help_field = project_rfa_opts , <EOL> cols = <NUM_LIT:6> , <EOL> hidden = True , <EOL> ) , <EOL> S3OptionsFilter ( \"<STR_LIT>\" , <EOL> label = T ( \"<STR_LIT>\" ) , <EOL> options = pifacc_options , <EOL> help_field = project_pifacc_opts , <EOL> cols = <NUM_LIT:6> , <EOL> hidden = True , <EOL>", "answer": ") ,"}, {"prompt": "<s> import time <EOL> from selenium . common . exceptions import NoSuchElementException <EOL> from selenium . common . exceptions import TimeoutException <EOL> POLL_FREQUENCY = <NUM_LIT:0.5> <EOL> IGNORED_EXCEPTIONS = ( NoSuchElementException , ) <EOL> class WebDriverWait ( object ) : <EOL> def __init__ ( self , driver , timeout , poll_frequency = POLL_FREQUENCY , ignored_exceptions = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _driver = driver <EOL> self . _timeout = timeout <EOL> self . _poll = poll_frequency <EOL> if self . _poll == <NUM_LIT:0> : <EOL> self . _poll = POLL_FREQUENCY <EOL> exceptions = list ( IGNORED_EXCEPTIONS ) <EOL> if ignored_exceptions is not None : <EOL> try : <EOL> exceptions . extend ( iter ( ignored_exceptions ) ) <EOL> except TypeError : <EOL>", "answer": "exceptions . append ( ignored_exceptions )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import scipy as _sp <EOL> from OpenPNM . Geometry import models as gm <EOL> from OpenPNM . Geometry import GenericGeometry <EOL> class TestGeometry ( GenericGeometry ) : <EOL> r\"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , ** kwargs ) : <EOL> super ( ) . __init__ ( ** kwargs ) <EOL> self . _generate ( ) <EOL> def _generate ( self ) : <EOL> self . models . add ( propname = '<STR_LIT>' , <EOL> model = gm . pore_misc . random , <EOL> regen_mode = '<STR_LIT>' , <EOL> seed = <NUM_LIT:1> ) <EOL> self . models . add ( propname = '<STR_LIT>' , <EOL> model = gm . throat_misc . neighbor , <EOL> pore_prop = '<STR_LIT>' , <EOL> mode = '<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] <EOL> self [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] <EOL> self [ '<STR_LIT>' ] = _sp . pi / <NUM_LIT:6> * self [ '<STR_LIT>' ] ** <NUM_LIT:3> <EOL> self [ '<STR_LIT>' ] = _sp . constants . pi / <NUM_LIT:4> * self [ '<STR_LIT>' ] ** <NUM_LIT:2> <EOL> self . models . add ( propname = '<STR_LIT>' , <EOL>", "answer": "model = gm . throat_length . straight )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> import tempfile <EOL> import wave <EOL> import audioop <EOL> import pyaudio <EOL> import alteration <EOL> import jasperpath <EOL> class Mic : <EOL> speechRec = None <EOL> speechRec_persona = None <EOL> def __init__ ( self , speaker , passive_stt_engine , active_stt_engine ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _logger = logging . getLogger ( __name__ ) <EOL> self . speaker = speaker <EOL> self . passive_stt_engine = passive_stt_engine <EOL> self . active_stt_engine = active_stt_engine <EOL> self . _logger . info ( \"<STR_LIT>\" + <EOL> \"<STR_LIT>\" + <EOL> \"<STR_LIT>\" ) <EOL> self . _audio = pyaudio . PyAudio ( ) <EOL> self . _logger . info ( \"<STR_LIT>\" ) <EOL> def __del__ ( self ) : <EOL> self . _audio . terminate ( ) <EOL> def getScore ( self , data ) : <EOL> rms = audioop . rms ( data , <NUM_LIT:2> ) <EOL> score = rms / <NUM_LIT:3> <EOL> return score <EOL> def fetchThreshold ( self ) : <EOL> THRESHOLD_MULTIPLIER = <NUM_LIT> <EOL> RATE = <NUM_LIT> <EOL> CHUNK = <NUM_LIT> <EOL> THRESHOLD_TIME = <NUM_LIT:1> <EOL> stream = self . _audio . open ( format = pyaudio . paInt16 , <EOL> channels = <NUM_LIT:1> , <EOL> rate = RATE , <EOL> input = True , <EOL> frames_per_buffer = CHUNK ) <EOL> frames = [ ] <EOL> lastN = [ i for i in range ( <NUM_LIT:20> ) ] <EOL> for i in range ( <NUM_LIT:0> , RATE / CHUNK * THRESHOLD_TIME ) : <EOL> data = stream . read ( CHUNK ) <EOL> frames . append ( data ) <EOL> lastN . pop ( <NUM_LIT:0> ) <EOL> lastN . append ( self . getScore ( data ) ) <EOL> average = sum ( lastN ) / len ( lastN ) <EOL>", "answer": "stream . stop_stream ( )"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from __future__ import absolute_import , print_function <EOL> import datetime <EOL> import json <EOL> import logging <EOL> import time <EOL> from salt . exceptions import SaltInvocationError <EOL> import salt . utils . http <EOL> log = logging . getLogger ( __name__ ) <EOL> _api_key_missing_error = '<STR_LIT>' <EOL> def __virtual__ ( ) : <EOL> '''<STR_LIT>''' <EOL> if not __salt__ [ '<STR_LIT>' ] ( '<STR_LIT>' ) and not __salt__ [ '<STR_LIT>' ] ( '<STR_LIT>' ) : <EOL> return ( False , _api_key_missing_error ) <EOL> return True <EOL> def _query ( action = None , <EOL> routing_key = None , <EOL> args = None , <EOL> method = '<STR_LIT:GET>' , <EOL> header_dict = None , <EOL> data = None ) : <EOL> '''<STR_LIT>''' <EOL> api_key = __salt__ [ '<STR_LIT>' ] ( '<STR_LIT>' ) or __salt__ [ '<STR_LIT>' ] ( '<STR_LIT>' ) <EOL> path = '<STR_LIT>' <EOL> if action : <EOL> path += '<STR_LIT>' . format ( action ) <EOL> if api_key : <EOL> path += '<STR_LIT>' . format ( api_key ) <EOL> if routing_key : <EOL> path += routing_key <EOL> log . debug ( '<STR_LIT>' . format ( path ) ) <EOL> if not isinstance ( args , dict ) : <EOL> args = { } <EOL> if header_dict is None : <EOL> header_dict = { '<STR_LIT>' : '<STR_LIT:application/json>' } <EOL> if method != '<STR_LIT:POST>' : <EOL> header_dict [ '<STR_LIT>' ] = '<STR_LIT:application/json>' <EOL> decode = True <EOL> if method == '<STR_LIT>' : <EOL> decode = False <EOL> result = salt . utils . http . query ( <EOL>", "answer": "path ,"}, {"prompt": "<s> from unittest import TestCase <EOL> class TestPoint ( TestCase ) : <EOL> def make_point ( self ) : <EOL> from sebastian . core import Point <EOL> from sebastian . core import OFFSET_64 , DURATION_64 , MIDI_PITCH <EOL> retval = Point ( { <EOL> OFFSET_64 : <NUM_LIT:16> , <EOL> MIDI_PITCH : <NUM_LIT:50> , <EOL> DURATION_64 : <NUM_LIT> , <EOL> } ) <EOL> return retval <EOL> def test_point_tuple_arbitrary_data ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from sebastian . core import Point <EOL>", "answer": "p1 = Point ( a = <NUM_LIT:1> , b = \"<STR_LIT:foo>\" )"}, {"prompt": "<s> import json <EOL> import copy <EOL> import datetime <EOL> import unittest <EOL> import example . app as example <EOL> from mongoengine . context_managers import query_counter <EOL> def response_success ( response , code = None ) : <EOL> if code is None : <EOL> assert <NUM_LIT:200> <= response . status_code < <NUM_LIT> , '<STR_LIT>' % ( response . status_code , response . data ) <EOL> else : <EOL> assert code == response . status_code , '<STR_LIT>' % ( response . status_code , response . data ) <EOL> def response_error ( response , code = None ) : <EOL> if code is None : <EOL> assert <NUM_LIT> <= response . status_code < <NUM_LIT> , '<STR_LIT>' % ( response . status_code , response . data ) <EOL> else : <EOL> assert code == response . status_code , '<STR_LIT>' % ( response . status_code , response . data ) <EOL> def compare_req_resp ( req_obj , resp_obj ) : <EOL> for k , v in req_obj . iteritems ( ) : <EOL> assert k in resp_obj . keys ( ) , '<STR_LIT>' % ( k , resp_obj . keys ( ) ) <EOL> assert resp_obj [ k ] == v , '<STR_LIT>' % ( k , v , resp_obj [ k ] ) <EOL> class MongoRestTestCase ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . user_1 = { <EOL> '<STR_LIT:email>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> self . user_2 = { <EOL> '<STR_LIT:email>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> self . post_1 = { <EOL> '<STR_LIT:title>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ <EOL> { '<STR_LIT:text>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:text>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:text>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' } , <EOL> ] , <EOL> '<STR_LIT:content>' : { <EOL> '<STR_LIT:text>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> '<STR_LIT>' : True , <EOL> } <EOL> self . post_2 = { <EOL> '<STR_LIT:title>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : False , <EOL> } <EOL> self . app = example . app . test_client ( ) <EOL> example . documents . User . drop_collection ( ) <EOL> example . documents . Post . drop_collection ( ) <EOL> example . TestDocument . drop_collection ( ) <EOL> example . A . drop_collection ( ) <EOL> example . B . drop_collection ( ) <EOL> example . C . drop_collection ( ) <EOL> example . MethodTestDoc . drop_collection ( ) <EOL> example . DictDoc . drop_collection ( ) <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( self . user_1 ) ) <EOL> response_success ( resp ) <EOL> self . user_1_obj = json . loads ( resp . data ) <EOL> compare_req_resp ( self . user_1 , self . user_1_obj ) <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( self . user_2 ) ) <EOL> response_success ( resp ) <EOL> self . user_2_obj = json . loads ( resp . data ) <EOL> compare_req_resp ( self . user_2 , self . user_2_obj ) <EOL> def tearDown ( self ) : <EOL> resp = self . app . delete ( '<STR_LIT>' % self . user_1_obj [ '<STR_LIT:id>' ] ) <EOL> response_success ( resp ) <EOL> resp = self . app . get ( '<STR_LIT>' % self . user_1_obj [ '<STR_LIT:id>' ] ) <EOL> response_error ( resp , code = <NUM_LIT> ) <EOL> resp = self . app . delete ( '<STR_LIT>' % self . user_2_obj [ '<STR_LIT:id>' ] ) <EOL> response_success ( resp ) <EOL> resp = self . app . get ( '<STR_LIT>' % self . user_2_obj [ '<STR_LIT:id>' ] ) <EOL> response_error ( resp , code = <NUM_LIT> ) <EOL> def test_update_user ( self ) : <EOL> self . user_1_obj [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> self . user_1_obj [ '<STR_LIT>' ] = datetime . datetime . utcnow ( ) . isoformat ( ) <EOL> resp = self . app . put ( '<STR_LIT>' % self . user_1_obj [ '<STR_LIT:id>' ] , data = json . dumps ( self . user_1_obj ) ) <EOL> response_success ( resp ) <EOL> data_to_check = copy . copy ( self . user_1_obj ) <EOL> del data_to_check [ '<STR_LIT>' ] <EOL> compare_req_resp ( data_to_check , json . loads ( resp . data ) ) <EOL> resp = json . loads ( resp . data ) <EOL> resp2 = json . loads ( self . app . get ( '<STR_LIT>' % self . user_1_obj [ '<STR_LIT:id>' ] ) . data ) <EOL> self . assertEqual ( resp , resp2 ) <EOL> def test_model_validation ( self ) : <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( { <EOL> '<STR_LIT:email>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } ) ) <EOL> response_error ( resp ) <EOL> errors = json . loads ( resp . data ) <EOL> self . assertTrue ( '<STR_LIT>' in errors ) <EOL> self . assertEqual ( errors [ '<STR_LIT>' ] . keys ( ) , [ '<STR_LIT:email>' ] ) <EOL> resp = self . app . put ( '<STR_LIT>' % self . user_1_obj [ '<STR_LIT:id>' ] , data = json . dumps ( { <EOL> '<STR_LIT:email>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } ) ) <EOL> response_error ( resp ) <EOL> errors = json . loads ( resp . data ) <EOL> self . assertTrue ( '<STR_LIT>' in errors ) <EOL> self . assertEqual ( errors [ '<STR_LIT>' ] . keys ( ) , [ '<STR_LIT:email>' ] ) <EOL> resp = self . app . put ( '<STR_LIT>' % self . user_1_obj [ '<STR_LIT:id>' ] , data = json . dumps ( { <EOL> '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } ) ) <EOL> response_error ( resp ) <EOL> errors = json . loads ( resp . data ) <EOL> self . assertTrue ( '<STR_LIT>' in errors ) <EOL> self . assertEqual ( errors [ '<STR_LIT>' ] . keys ( ) , [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( errors [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] . keys ( ) , [ '<STR_LIT:1>' , '<STR_LIT:3>' ] ) <EOL> def test_resource_fields ( self ) : <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( { <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } ) ) <EOL> response_success ( resp ) <EOL> obj = json . loads ( resp . data ) <EOL> self . assertEqual ( set ( obj . keys ( ) ) , set ( [ '<STR_LIT:id>' , '<STR_LIT:name>' , '<STR_LIT>' ] ) ) <EOL> self . assertEqual ( obj [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( obj [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> resp = self . app . get ( '<STR_LIT>' % obj [ '<STR_LIT:id>' ] ) <EOL> response_success ( resp ) <EOL> obj = json . loads ( resp . data ) <EOL> self . assertEqual ( obj [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> resp = self . app . put ( '<STR_LIT>' % obj [ '<STR_LIT:id>' ] , data = json . dumps ( { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } ) ) <EOL> response_success ( resp ) <EOL> obj = json . loads ( resp . data ) <EOL> self . assertEqual ( obj [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( obj [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> resp = self . app . put ( '<STR_LIT>' % obj [ '<STR_LIT:id>' ] , data = json . dumps ( { <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } ) ) <EOL> response_success ( resp ) <EOL> obj = json . loads ( resp . data ) <EOL> self . assertEqual ( obj [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( obj [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> def test_restricted_auth ( self ) : <EOL> self . post_1 [ '<STR_LIT>' ] = self . user_1_obj [ '<STR_LIT:id>' ] <EOL> self . post_1 [ '<STR_LIT>' ] = self . user_2_obj [ '<STR_LIT:id>' ] <EOL> self . post_1 [ '<STR_LIT>' ] = [ self . user_1_obj [ '<STR_LIT:id>' ] , self . user_2_obj [ '<STR_LIT:id>' ] ] <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> objs = json . loads ( resp . data ) [ '<STR_LIT:data>' ] <EOL> self . assertEqual ( len ( objs ) , <NUM_LIT:2> ) <EOL> post = self . post_1 . copy ( ) <EOL> post [ \"<STR_LIT>\" ] = True <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( post ) ) <EOL> response_success ( resp , code = <NUM_LIT> ) <EOL> post [ \"<STR_LIT>\" ] = False <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( post ) ) <EOL> response_success ( resp , code = <NUM_LIT:200> ) <EOL> data = json . loads ( resp . data ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> tmp = json . loads ( resp . data ) <EOL> nposts = len ( tmp [ \"<STR_LIT:data>\" ] ) <EOL> self . assertEqual ( <NUM_LIT:2> , nposts ) <EOL> self . assertEqual ( tmp [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> tmp = json . loads ( resp . data ) <EOL> npubposts = len ( tmp [ \"<STR_LIT:data>\" ] ) <EOL> self . assertEqual ( <NUM_LIT:1> , npubposts ) <EOL> post [ \"<STR_LIT:title>\" ] = \"<STR_LIT>\" <EOL> resp = self . app . put ( '<STR_LIT>' % ( str ( data [ \"<STR_LIT:id>\" ] , ) ) , <EOL> data = json . dumps ( post ) ) <EOL> response_success ( resp , code = <NUM_LIT:200> ) <EOL> post [ \"<STR_LIT>\" ] = True <EOL> resp = self . app . put ( '<STR_LIT>' % ( str ( data [ \"<STR_LIT:id>\" ] , ) ) , <EOL> data = json . dumps ( post ) ) <EOL> response_success ( resp , code = <NUM_LIT:200> ) <EOL> post [ \"<STR_LIT:title>\" ] = \"<STR_LIT>\" <EOL> resp = self . app . put ( '<STR_LIT>' % ( str ( data [ \"<STR_LIT:id>\" ] , ) ) , <EOL> data = json . dumps ( post ) ) <EOL> response_success ( resp , code = <NUM_LIT> ) <EOL> resp = self . app . delete ( '<STR_LIT>' % ( str ( data [ \"<STR_LIT:id>\" ] , ) ) , <EOL> data = json . dumps ( post ) ) <EOL> response_success ( resp , code = <NUM_LIT> ) <EOL> post = self . post_1 . copy ( ) <EOL> post [ \"<STR_LIT>\" ] = False <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( post ) ) <EOL> response_success ( resp , code = <NUM_LIT:200> ) <EOL> data = json . loads ( resp . data ) <EOL> resp = self . app . delete ( '<STR_LIT>' % ( data [ \"<STR_LIT:id>\" ] , ) , <EOL> data = json . dumps ( post ) ) <EOL> response_success ( resp , code = <NUM_LIT:200> ) <EOL> def test_get ( self ) : <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> objs = json . loads ( resp . data ) [ '<STR_LIT:data>' ] <EOL> self . assertEqual ( len ( objs ) , <NUM_LIT:2> ) <EOL> def test_get_primary_user ( self ) : <EOL> self . post_1 [ '<STR_LIT>' ] = self . user_1_obj [ '<STR_LIT:id>' ] <EOL> self . post_1 [ '<STR_LIT>' ] = self . user_2_obj [ '<STR_LIT:id>' ] <EOL> self . post_1 [ '<STR_LIT>' ] = [ self . user_1_obj [ '<STR_LIT:id>' ] , self . user_2_obj [ '<STR_LIT:id>' ] ] <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( self . post_1 ) ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> objs = json . loads ( resp . data ) [ '<STR_LIT:data>' ] <EOL> self . assertEqual ( len ( objs ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( objs [ <NUM_LIT:0> ] [ '<STR_LIT:title>' ] , '<STR_LIT>' ) <EOL> self . assertTrue ( len ( objs [ <NUM_LIT:0> ] [ '<STR_LIT>' ] ) > <NUM_LIT:0> ) <EOL> def test_get_empty_primary_user ( self ) : <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( self . post_2 ) ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> objs = json . loads ( resp . data ) [ '<STR_LIT:data>' ] <EOL> self . assertEqual ( len ( objs ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( objs [ <NUM_LIT:0> ] [ '<STR_LIT:title>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( objs [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , None ) <EOL> def test_post ( self ) : <EOL> self . post_1 [ '<STR_LIT>' ] = self . user_1_obj [ '<STR_LIT:id>' ] <EOL> self . post_1 [ '<STR_LIT>' ] = self . user_2_obj [ '<STR_LIT:id>' ] <EOL> self . post_1 [ '<STR_LIT>' ] = [ self . user_1_obj [ '<STR_LIT:id>' ] , self . user_2_obj [ '<STR_LIT:id>' ] ] <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( self . post_1 ) ) <EOL> response_success ( resp ) <EOL> compare_req_resp ( self . post_1 , json . loads ( resp . data ) ) <EOL> self . post_1_obj = json . loads ( resp . data ) <EOL> resp = self . app . get ( '<STR_LIT>' % self . post_1_obj [ '<STR_LIT:id>' ] ) <EOL> response_success ( resp ) <EOL> compare_req_resp ( self . post_1_obj , json . loads ( resp . data ) ) <EOL> self . post_1_obj [ '<STR_LIT>' ] = self . user_2_obj [ '<STR_LIT:id>' ] <EOL> resp = self . app . put ( '<STR_LIT>' % self . post_1_obj [ '<STR_LIT:id>' ] , data = json . dumps ( self . post_1_obj ) ) <EOL> response_success ( resp ) <EOL> jd = json . loads ( resp . data ) <EOL> self . assertEqual ( self . post_1_obj [ '<STR_LIT>' ] , jd [ \"<STR_LIT>\" ] ) <EOL> response_success ( resp ) <EOL> compare_req_resp ( self . post_1_obj , json . loads ( resp . data ) ) <EOL> self . post_1_obj = json . loads ( resp . data ) <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( self . post_2 ) ) <EOL> response_success ( resp ) <EOL> compare_req_resp ( self . post_2 , json . loads ( resp . data ) ) <EOL> self . post_2_obj = json . loads ( resp . data ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> data_list = json . loads ( resp . data ) [ '<STR_LIT:data>' ] <EOL> compare_req_resp ( self . post_1_obj , data_list [ <NUM_LIT:0> ] ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> data_list = json . loads ( resp . data ) [ '<STR_LIT:data>' ] <EOL> self . assertEqual ( data_list , [ ] ) <EOL> resp = self . app . get ( '<STR_LIT>' % ( self . post_1_obj [ '<STR_LIT:title>' ] , self . post_2_obj [ '<STR_LIT:title>' ] ) ) <EOL> response_success ( resp ) <EOL> posts = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( posts [ '<STR_LIT:data>' ] ) , <NUM_LIT:2> ) <EOL> resp = self . app . get ( '<STR_LIT>' % '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> users = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( users [ '<STR_LIT:data>' ] ) , <NUM_LIT:1> ) <EOL> resp = self . app . get ( '<STR_LIT>' % '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> users = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( users [ '<STR_LIT:data>' ] ) , <NUM_LIT:2> ) <EOL> resp = self . app . get ( '<STR_LIT>' % '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> users = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( users [ '<STR_LIT:data>' ] ) , <NUM_LIT:2> ) <EOL> resp = self . app . get ( '<STR_LIT>' % ( self . post_1_obj [ '<STR_LIT:title>' ] , self . post_2_obj [ '<STR_LIT:title>' ] ) ) <EOL> response_success ( resp ) <EOL> posts = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( posts [ '<STR_LIT:data>' ] ) , <NUM_LIT:0> ) <EOL> resp = self . app . get ( '<STR_LIT>' % ( self . post_1_obj [ '<STR_LIT:title>' ] ) ) <EOL> response_success ( resp ) <EOL> posts = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( posts [ '<STR_LIT:data>' ] ) , <NUM_LIT:1> ) <EOL> resp = self . app . get ( '<STR_LIT>' % self . user_2_obj [ '<STR_LIT:id>' ] ) <EOL> response_success ( resp ) <EOL> data_list = json . loads ( resp . data ) [ '<STR_LIT:data>' ] <EOL> compare_req_resp ( self . post_1_obj , data_list [ <NUM_LIT:0> ] ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> data_list = json . loads ( resp . data ) [ '<STR_LIT:data>' ] <EOL> self . assertEqual ( len ( data_list ) , <NUM_LIT:1> ) <EOL> compare_req_resp ( self . post_1_obj , data_list [ <NUM_LIT:0> ] ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> data_list = json . loads ( resp . data ) [ '<STR_LIT:data>' ] <EOL> self . assertEqual ( len ( data_list ) , <NUM_LIT:1> ) <EOL> compare_req_resp ( self . post_2_obj , data_list [ <NUM_LIT:0> ] ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> data_list_1 = json . loads ( resp . data ) [ '<STR_LIT:data>' ] <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> data_list_2 = json . loads ( resp . data ) [ '<STR_LIT:data>' ] <EOL> self . assertEqual ( data_list_1 , data_list_2 ) <EOL> resp = self . app . put ( '<STR_LIT>' , data = json . dumps ( { <EOL> '<STR_LIT:description>' : '<STR_LIT>' <EOL> } ) ) <EOL> response_success ( resp ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( data [ '<STR_LIT:count>' ] , <NUM_LIT:1> ) <EOL> resp = self . app . put ( '<STR_LIT>' , data = json . dumps ( { <EOL> '<STR_LIT:description>' : '<STR_LIT>' <EOL> } ) ) <EOL> response_success ( resp ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( data [ '<STR_LIT:count>' ] , <NUM_LIT:2> ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> data_list = json . loads ( resp . data ) [ '<STR_LIT:data>' ] <EOL> self . assertEqual ( data_list [ <NUM_LIT:0> ] [ '<STR_LIT:description>' ] , '<STR_LIT>' ) <EOL> self . assertEqual ( data_list [ <NUM_LIT:1> ] [ '<STR_LIT:description>' ] , '<STR_LIT>' ) <EOL> resp = self . app . put ( '<STR_LIT>' , data = json . dumps ( { <EOL> '<STR_LIT:description>' : '<STR_LIT:X>' * <NUM_LIT> <EOL> } ) ) <EOL> response_error ( resp ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( data [ '<STR_LIT:count>' ] , <NUM_LIT:0> ) <EOL> self . assertEqual ( data [ '<STR_LIT>' ] . keys ( ) , [ '<STR_LIT:description>' ] ) <EOL> def test_post_auto_art_tag ( self ) : <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( { <EOL> '<STR_LIT:email>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } ) ) <EOL> response_success ( resp ) <EOL> author = json . loads ( resp . data ) [ '<STR_LIT:id>' ] <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( self . post_1 ) ) <EOL> response_success ( resp ) <EOL> post = json . loads ( resp . data ) <EOL> resp = self . app . put ( '<STR_LIT>' % post [ '<STR_LIT:id>' ] , data = json . dumps ( { <EOL> '<STR_LIT>' : author <EOL> } ) ) <EOL> response_success ( resp ) <EOL> post = json . loads ( resp . data ) <EOL> post_obj = example . documents . Post . objects . get ( pk = post [ '<STR_LIT:id>' ] ) <EOL> self . assertTrue ( '<STR_LIT>' in post_obj . tags ) <EOL> self . assertTrue ( '<STR_LIT>' in post [ '<STR_LIT>' ] ) <EOL> def test_broken_reference ( self ) : <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( { <EOL> '<STR_LIT:email>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } ) ) <EOL> response_success ( resp ) <EOL> user_3 = json . loads ( resp . data ) <EOL> post = self . post_1 . copy ( ) <EOL> post [ '<STR_LIT>' ] = self . user_1_obj [ '<STR_LIT:id>' ] <EOL> post [ '<STR_LIT>' ] = self . user_2_obj [ '<STR_LIT:id>' ] <EOL> post [ '<STR_LIT>' ] = [ user_3 [ '<STR_LIT:id>' ] ] <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( post ) ) <EOL> response_success ( resp ) <EOL> compare_req_resp ( post , json . loads ( resp . data ) ) <EOL> post = json . loads ( resp . data ) <EOL> resp = self . app . delete ( '<STR_LIT>' % user_3 [ '<STR_LIT:id>' ] ) <EOL> response_success ( resp ) <EOL> resp = self . app . get ( '<STR_LIT>' % post [ '<STR_LIT:id>' ] ) <EOL> response_success ( resp ) <EOL> self . assertEqual ( json . loads ( resp . data ) [ '<STR_LIT>' ] , [ ] ) <EOL> post [ '<STR_LIT>' ] = [ ] <EOL> compare_req_resp ( post , json . loads ( resp . data ) ) <EOL> def test_dummy_auth ( self ) : <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp , code = <NUM_LIT> ) <EOL> def test_pagination ( self ) : <EOL> post = self . post_1 . copy ( ) <EOL> for i in range ( <NUM_LIT:1> , <NUM_LIT> ) : <EOL> post [ '<STR_LIT:title>' ] = '<STR_LIT>' % i <EOL> resp = self . app . post ( '<STR_LIT>' , data = json . dumps ( post ) ) <EOL> response_success ( resp ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( data [ '<STR_LIT:data>' ] ) , <NUM_LIT:10> ) <EOL> self . assertEqual ( data [ '<STR_LIT>' ] , True ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( data [ '<STR_LIT:data>' ] ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( data [ '<STR_LIT>' ] , False ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( data [ '<STR_LIT:data>' ] ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( data [ '<STR_LIT>' ] , True ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( data [ '<STR_LIT:data>' ] ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( data [ '<STR_LIT>' ] , True ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( data [ '<STR_LIT:data>' ] ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( data [ '<STR_LIT>' ] , False ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( data [ '<STR_LIT:data>' ] ) , <NUM_LIT:100> ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_error ( resp , code = <NUM_LIT> ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( data [ '<STR_LIT:error>' ] , '<STR_LIT>' ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_error ( resp , code = <NUM_LIT> ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( data [ '<STR_LIT:error>' ] , '<STR_LIT>' ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( data [ '<STR_LIT:data>' ] ) , <NUM_LIT:10> ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( data [ '<STR_LIT:data>' ] ) , <NUM_LIT:5> ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_error ( resp , code = <NUM_LIT> ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( data [ '<STR_LIT:error>' ] , '<STR_LIT>' ) <EOL> resp = self . app . get ( '<STR_LIT>' ) <EOL> response_success ( resp ) <EOL> data = json . loads ( resp . data ) <EOL> self . assertEqual ( len ( data [ '<STR_LIT:data>' ] ) , <NUM_LIT:100> ) <EOL>", "answer": "resp = self . app . get ( '<STR_LIT>' )"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL> from owslib . wps import WebProcessingService , WPSExecution , WFSFeatureCollection , WFSQuery , GMLMultiPolygonFeatureCollection , monitorExecution , ComplexData , printInputOutput <EOL> from owslib . util import dump <EOL> verbose = True <EOL> wps = WebProcessingService ( '<STR_LIT>' , verbose = verbose ) <EOL> wps . getcapabilities ( ) <EOL> print ( '<STR_LIT>' % wps . identification . type ) <EOL>", "answer": "print ( '<STR_LIT>' % wps . identification . title )"}, {"prompt": "<s> def i ( y ) : <EOL> print y * <NUM_LIT:2> <EOL> return \"<STR_LIT:hello>\" <EOL>", "answer": "n = <NUM_LIT>"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL>", "answer": "result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from numpy import ( <EOL> arange , <EOL> datetime64 , <EOL> float64 , <EOL> ones , <EOL> uint32 , <EOL> ) <EOL> from numpy . testing import ( <EOL> assert_allclose , <EOL> assert_array_equal , <EOL> ) <EOL> from pandas import ( <EOL> concat , <EOL> DataFrame , <EOL> Int64Index , <EOL> Timestamp , <EOL> ) <EOL> from toolz . curried . operator import getitem <EOL> from zipline . lib . adjustment import Float64Multiply <EOL> from zipline . pipeline . loaders . synthetic import ( <EOL> NullAdjustmentReader , <EOL> make_daily_bar_data , <EOL> expected_daily_bar_values_2d , <EOL> ) <EOL> from zipline . pipeline . loaders . equity_pricing_loader import ( <EOL> USEquityPricingLoader , <EOL> ) <EOL> from zipline . errors import WindowLengthTooLong <EOL> from zipline . pipeline . data import USEquityPricing <EOL> from zipline . testing import ( <EOL> seconds_to_timestamp , <EOL> str_to_seconds , <EOL> MockDailyBarReader , <EOL> ) <EOL> from zipline . testing . fixtures import ( <EOL> WithAdjustmentReader , <EOL> ZiplineTestCase , <EOL> ) <EOL> TEST_CALENDAR_START = Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) <EOL> TEST_CALENDAR_STOP = Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) <EOL> TEST_QUERY_START = Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) <EOL> TEST_QUERY_STOP = Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) <EOL> EQUITY_INFO = DataFrame ( <EOL> [ <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } , <EOL> { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } , <EOL> ] , <EOL> index = arange ( <NUM_LIT:1> , <NUM_LIT:7> ) , <EOL> columns = [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> ) . astype ( datetime64 ) <EOL> TEST_QUERY_ASSETS = EQUITY_INFO . index <EOL> SPLITS = DataFrame ( <EOL> [ <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:1> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:6> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> ] , <EOL> columns = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> ) <EOL> MERGERS = DataFrame ( <EOL> [ <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:1> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:6> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:4> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> ] , <EOL> columns = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> ) <EOL> DIVIDENDS = DataFrame ( <EOL> [ <EOL> { '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:1> } , <EOL> { '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> { '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> { '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:6> } , <EOL> { '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> { '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : Timestamp ( '<STR_LIT>' , tz = '<STR_LIT>' ) . to_datetime64 ( ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> ] , <EOL> columns = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] , <EOL> ) <EOL> DIVIDENDS_EXPECTED = DataFrame ( <EOL> [ <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT:0.1> , <EOL> '<STR_LIT>' : <NUM_LIT:1> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:6> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> { '<STR_LIT>' : str_to_seconds ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:3> } , <EOL> ] , <EOL> columns = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> ) <EOL> class USEquityPricingLoaderTestCase ( WithAdjustmentReader , <EOL> ZiplineTestCase ) : <EOL> START_DATE = TEST_CALENDAR_START <EOL> END_DATE = TEST_CALENDAR_STOP <EOL> asset_ids = <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> <EOL> @ classmethod <EOL> def make_equity_info ( cls ) : <EOL> return EQUITY_INFO <EOL> @ classmethod <EOL> def make_splits_data ( cls ) : <EOL> return SPLITS <EOL> @ classmethod <EOL> def make_mergers_data ( cls ) : <EOL> return MERGERS <EOL>", "answer": "@ classmethod"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL>", "answer": "result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import datetime <EOL> import getpass <EOL> import logging <EOL> import optparse <EOL> import os <EOL> import shutil <EOL> import socket <EOL> import subprocess <EOL> import sys <EOL> import tempfile <EOL> import urllib <EOL> import gcl <EOL> import scm <EOL> import presubmit_support <EOL> import upload <EOL> __version__ = '<STR_LIT>' <EOL> HELP_STRING = \"<STR_LIT>\" <EOL> USAGE = r\"\"\"<STR_LIT>\"\"\" <EOL> class InvalidScript ( Exception ) : <EOL> def __str__ ( self ) : <EOL> return self . args [ <NUM_LIT:0> ] + '<STR_LIT:\\n>' + HELP_STRING <EOL> class NoTryServerAccess ( Exception ) : <EOL> def __str__ ( self ) : <EOL> return self . args [ <NUM_LIT:0> ] + '<STR_LIT:\\n>' + HELP_STRING <EOL> def PathDifference ( root , subpath ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if subpath . find ( root ) != <NUM_LIT:0> : <EOL> return None <EOL> if not root . endswith ( os . sep ) : <EOL> root += os . sep <EOL> return subpath [ len ( root ) : ] <EOL> def GetSourceRoot ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return os . path . abspath ( os . path . join ( gcl . GetRepositoryRoot ( ) , '<STR_LIT:..>' ) ) <EOL> def GetTryServerSettings ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _SafeResolve ( host ) : <EOL> try : <EOL> return socket . getaddrinfo ( host , None ) <EOL> except socket . gaierror : <EOL> return None <EOL> settings = { } <EOL> settings [ '<STR_LIT>' ] = gcl . GetCodeReviewSetting ( '<STR_LIT>' ) <EOL> settings [ '<STR_LIT>' ] = gcl . GetCodeReviewSetting ( '<STR_LIT>' ) <EOL> settings [ '<STR_LIT>' ] = gcl . GetCodeReviewSetting ( '<STR_LIT>' ) <EOL> settings [ '<STR_LIT>' ] = gcl . GetCodeReviewSetting ( '<STR_LIT>' ) <EOL> settings [ '<STR_LIT>' ] = gcl . GetCodeReviewSetting ( '<STR_LIT>' ) <EOL> default_patchlevel = gcl . GetCodeReviewSetting ( '<STR_LIT>' ) <EOL> if default_patchlevel : <EOL> default_patchlevel = int ( default_patchlevel ) <EOL> else : <EOL> default_patchlevel = <NUM_LIT:0> <EOL> settings [ '<STR_LIT>' ] = default_patchlevel <EOL> if ( settings [ '<STR_LIT>' ] and settings [ '<STR_LIT>' ] and <EOL> _SafeResolve ( settings [ '<STR_LIT>' ] ) ) : <EOL> settings [ '<STR_LIT>' ] = '<STR_LIT:http>' <EOL> elif settings . get ( '<STR_LIT>' ) : <EOL> settings [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> return settings <EOL> def EscapeDot ( name ) : <EOL> return name . replace ( '<STR_LIT:.>' , '<STR_LIT:->' ) <EOL> def RunCommand ( command ) : <EOL> output , retcode = gcl . RunShellWithReturnCode ( command ) <EOL> if retcode : <EOL> raise NoTryServerAccess ( '<STR_LIT:U+0020>' . join ( command ) + '<STR_LIT>' + output ) <EOL> return output <EOL> class SCM ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , options ) : <EOL> self . options = options <EOL> def ProcessOptions ( self ) : <EOL> raise NotImplementedError <EOL> class SVN ( SCM ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def GenerateDiff ( self , files , root ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> previous_cwd = os . getcwd ( ) <EOL> if root is None : <EOL> os . chdir ( gcl . GetRepositoryRoot ( ) ) <EOL> else : <EOL> os . chdir ( root ) <EOL> diff = filter ( None , [ scm . SVN . DiffItem ( f ) for f in files ] ) <EOL> os . chdir ( previous_cwd ) <EOL> return \"<STR_LIT>\" . join ( diff ) <EOL> def GetFileNames ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . change_info . GetFileNames ( ) <EOL> def GetLocalRoot ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . change_info . GetLocalRoot ( ) <EOL> def ProcessOptions ( self ) : <EOL> if not self . options . diff : <EOL> source_root = GetSourceRoot ( ) <EOL> prefix = PathDifference ( source_root , gcl . GetRepositoryRoot ( ) ) <EOL> adjusted_paths = [ os . path . join ( prefix , x ) for x in self . options . files ] <EOL> self . options . diff = self . GenerateDiff ( adjusted_paths , root = source_root ) <EOL> self . change_info = gcl . LoadChangelistInfoForMultiple ( self . options . name , <EOL> gcl . GetRepositoryRoot ( ) , True , True ) <EOL> if not self . options . email : <EOL> self . options . email = scm . SVN . GetEmail ( gcl . GetRepositoryRoot ( ) ) <EOL> class GIT ( SCM ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def GenerateDiff ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> branch = upload . RunShell ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) . strip ( ) <EOL> diff = upload . RunShell ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> branch , '<STR_LIT>' ] ) . splitlines ( True ) <EOL> for i in range ( len ( diff ) ) : <EOL> if diff [ i ] . startswith ( '<STR_LIT>' ) : <EOL> diff [ i ] = '<STR_LIT>' % diff [ i + <NUM_LIT:1> ] [ <NUM_LIT:4> : ] <EOL> return '<STR_LIT>' . join ( diff ) <EOL> def GetFileNames ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . options . files <EOL> def GetLocalRoot ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> root = upload . RunShell ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) . strip ( ) <EOL> return os . path . abspath ( root ) <EOL> def GetPatchName ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> branch = upload . RunShell ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) . strip ( ) <EOL> if not branch . startswith ( '<STR_LIT>' ) : <EOL> raise NoTryServerAccess ( \"<STR_LIT>\" ) <EOL> branch = branch [ len ( '<STR_LIT>' ) : ] <EOL> return branch <EOL> def ProcessOptions ( self ) : <EOL> if not self . options . diff : <EOL> self . options . diff = self . GenerateDiff ( ) <EOL> if not self . options . name : <EOL> self . options . name = self . GetPatchName ( ) <EOL> if not self . options . email : <EOL> self . options . email = scm . GIT . GetEmail ( '<STR_LIT:.>' ) <EOL> def _ParseSendChangeOptions ( options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> values = { } <EOL> if options . email : <EOL> values [ '<STR_LIT:email>' ] = options . email <EOL> values [ '<STR_LIT:user>' ] = options . user <EOL> values [ '<STR_LIT:name>' ] = options . name <EOL> if options . bot : <EOL> values [ '<STR_LIT>' ] = '<STR_LIT:U+002C>' . join ( options . bot ) <EOL> if options . revision : <EOL> values [ '<STR_LIT>' ] = options . revision <EOL> if options . clobber : <EOL> values [ '<STR_LIT>' ] = '<STR_LIT:true>' <EOL> if options . tests : <EOL> values [ '<STR_LIT>' ] = '<STR_LIT:U+002C>' . join ( options . tests ) <EOL> if options . root : <EOL> values [ '<STR_LIT:root>' ] = options . root <EOL> if options . patchlevel : <EOL> values [ '<STR_LIT>' ] = options . patchlevel <EOL> if options . issue : <EOL> values [ '<STR_LIT>' ] = options . issue <EOL> if options . patchset : <EOL> values [ '<STR_LIT>' ] = options . patchset <EOL> if options . target : <EOL> values [ '<STR_LIT:target>' ] = options . target <EOL> if options . project : <EOL> values [ '<STR_LIT>' ] = options . project <EOL> return values <EOL> def _SendChangeHTTP ( options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not options . host : <EOL> raise NoTryServerAccess ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> if not options . port : <EOL> raise NoTryServerAccess ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> values = _ParseSendChangeOptions ( options ) <EOL> values [ '<STR_LIT>' ] = options . diff <EOL> url = '<STR_LIT>' % ( options . host , options . port ) <EOL> proxies = None <EOL> if options . proxy : <EOL> if options . proxy . lower ( ) == '<STR_LIT:none>' : <EOL> proxies = { } <EOL> else : <EOL> proxies = { '<STR_LIT:http>' : options . proxy , '<STR_LIT>' : options . proxy } <EOL> try : <EOL> connection = urllib . urlopen ( url , urllib . urlencode ( values ) , proxies = proxies ) <EOL> except IOError , e : <EOL> if ( values . get ( '<STR_LIT>' ) and len ( e . args ) > <NUM_LIT:2> and <EOL> e . args [ <NUM_LIT:2> ] == '<STR_LIT>' ) : <EOL> raise NoTryServerAccess ( '<STR_LIT>' % url ) <EOL> else : <EOL> raise NoTryServerAccess ( '<STR_LIT>' % ( url , <EOL> str ( e . args ) ) ) <EOL> if not connection : <EOL> raise NoTryServerAccess ( '<STR_LIT>' % url ) <EOL> if connection . read ( ) != '<STR_LIT:OK>' : <EOL> raise NoTryServerAccess ( '<STR_LIT>' % url ) <EOL> def _SendChangeSVN ( options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not options . svn_repo : <EOL> raise NoTryServerAccess ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> values = _ParseSendChangeOptions ( options ) <EOL> description = '<STR_LIT>' <EOL> for ( k , v ) in values . iteritems ( ) : <EOL> description += \"<STR_LIT>\" % ( k , v ) <EOL> temp_dir = tempfile . mkdtemp ( ) <EOL> temp_file = tempfile . NamedTemporaryFile ( ) <EOL> temp_file_name = temp_file . name <EOL> try : <EOL> command = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> options . svn_repo , temp_dir ] <EOL> if options . email : <EOL> command += [ '<STR_LIT>' , options . email ] <EOL> use_shell = sys . platform . startswith ( \"<STR_LIT>\" ) <EOL> subprocess . Popen ( command , shell = use_shell ) . communicate ( ) <EOL> current_time = str ( datetime . datetime . now ( ) ) . replace ( '<STR_LIT::>' , '<STR_LIT:.>' ) <EOL> file_name = ( EscapeDot ( options . user ) + '<STR_LIT:.>' + EscapeDot ( options . name ) + <EOL> '<STR_LIT>' % current_time ) <EOL> full_path = os . path . join ( temp_dir , file_name ) <EOL> full_url = options . svn_repo + '<STR_LIT:/>' + file_name <EOL> file_found = False <EOL> try : <EOL> RunCommand ( [ '<STR_LIT>' , '<STR_LIT>' , full_url ] ) <EOL> file_found = True <EOL> except NoTryServerAccess : <EOL> pass <EOL> if file_found : <EOL> RunCommand ( [ '<STR_LIT>' , '<STR_LIT>' , full_path ] ) <EOL> f = open ( full_path , '<STR_LIT:wb>' ) <EOL> f . write ( options . diff ) <EOL> f . close ( ) <EOL> else : <EOL> f = open ( full_path , '<STR_LIT:wb>' ) <EOL> f . write ( options . diff ) <EOL> f . close ( ) <EOL> RunCommand ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , full_path ] ) <EOL> temp_file . write ( description ) <EOL> temp_file . flush ( ) <EOL> RunCommand ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , full_path , '<STR_LIT>' , <EOL> temp_file_name ] ) <EOL> finally : <EOL> temp_file . close ( ) <EOL> shutil . rmtree ( temp_dir , True ) <EOL> def GuessVCS ( options ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __pychecker__ = '<STR_LIT>' <EOL> if os . path . isdir ( '<STR_LIT>' ) : <EOL> logging . info ( \"<STR_LIT>\" ) <EOL> return SVN ( options ) <EOL> try : <EOL> out , returncode = gcl . RunShellWithReturnCode ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] ) <EOL> if returncode == <NUM_LIT:0> : <EOL> logging . info ( \"<STR_LIT>\" ) <EOL> return GIT ( options ) <EOL> except OSError , ( errno , message ) : <EOL> if errno != <NUM_LIT:2> : <EOL> raise <EOL> raise NoTryServerAccess ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def TryChange ( argv , <EOL> file_list , <EOL> swallow_exception , <EOL> prog = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> default_settings = GetTryServerSettings ( ) <EOL> transport_functions = { '<STR_LIT:http>' : _SendChangeHTTP , '<STR_LIT>' : _SendChangeSVN } <EOL> default_transport = transport_functions . get ( <EOL> default_settings . get ( '<STR_LIT>' ) ) <EOL> parser = optparse . OptionParser ( usage = USAGE , <EOL> version = __version__ , <EOL> prog = prog ) <EOL> group = optparse . OptionGroup ( parser , \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , default = getpass . getuser ( ) , <EOL> help = \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> default = os . environ . get ( '<STR_LIT>' , <EOL> os . environ . get ( '<STR_LIT>' ) ) , <EOL> help = \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , type = '<STR_LIT:int>' , <EOL> help = \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , type = '<STR_LIT:int>' , <EOL> help = \"<STR_LIT>\" ) <EOL> parser . add_option_group ( group ) <EOL> group = optparse . OptionGroup ( parser , \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , action = \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT:-c>\" , \"<STR_LIT>\" , action = \"<STR_LIT:store_true>\" , <EOL> help = \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> group . add_option ( \"<STR_LIT>\" , help = optparse . SUPPRESS_HELP ) <EOL>", "answer": "group . add_option ( \"<STR_LIT>\" , help = optparse . SUPPRESS_HELP ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from bigml . predicates import Predicates <EOL> from bigml . util import sort_fields , utf8 <EOL> class AnomalyTree ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , tree , fields ) : <EOL>", "answer": "self . fields = fields"}, {"prompt": "<s> import os <EOL> import inspect <EOL> import sys <EOL> directory = os . path . dirname ( inspect . getfile ( inspect . currentframe ( ) ) ) <EOL> sys . path . append ( directory ) <EOL> import rendering <EOL> import async <EOL> import window <EOL> import vim <EOL> import time <EOL> import string <EOL> import signal <EOL> from utils import * <EOL> class Do : <EOL> def __init__ ( self ) : <EOL> self . __process_pool = async . ProcessPool ( ) <EOL> self . __processes = ProcessCollection ( ) <EOL> self . __process_renderer = rendering . ProcessRenderer ( ) <EOL> self . __au_assigned = False <EOL> self . __last_check = time . time ( ) * <NUM_LIT:1000> <EOL> def __del__ ( self ) : <EOL> self . stop ( ) <EOL> def execute ( self , cmd , quiet = False ) : <EOL> pid = self . __process_pool . execute ( cmd ) <EOL> log ( \"<STR_LIT>\" % ( pid , cmd ) ) <EOL> process = self . __processes . add ( cmd , pid ) <EOL> self . __process_renderer . add_process ( process , quiet ) <EOL> self . __assign_autocommands ( ) <EOL> self . check ( ) <EOL> def reload_options ( self ) : <EOL> Options . reload ( ) <EOL> def toggle_command_window ( self ) : <EOL> self . __process_renderer . toggle_command_window ( ) <EOL> def mark_command_window_as_closed ( self ) : <EOL> self . __process_renderer . destroy_command_window ( ) <EOL> def mark_process_window_as_closed ( self ) : <EOL> try : <EOL> self . __process_renderer . destroy_process_window ( ) <EOL> except Exception , e : <EOL> log ( \"<STR_LIT>\" % str ( e ) ) <EOL> def show_process_from_command_window ( self ) : <EOL> lineno = vim . current . window . cursor [ <NUM_LIT:0> ] <EOL> pid = self . __process_renderer . get_pid_by_line_number ( lineno ) <EOL> process = self . __processes . get_by_pid ( pid ) <EOL> if process is not None : <EOL> self . __process_renderer . show_process ( process ) <EOL> def check ( self ) : <EOL> log ( \"<STR_LIT>\" ) <EOL> if ( <NUM_LIT:1000> * time . time ( ) ) - self . __last_check > Options . check_interval ( ) : <EOL> self . check_now ( ) <EOL> self . __last_check = time . time ( ) * <NUM_LIT:1000> <EOL> def check_now ( self ) : <EOL> log ( \"<STR_LIT>\" ) <EOL> outputs = self . __process_pool . get_outputs ( ) <EOL> changed_processes = set ( ) <EOL> for output in outputs : <EOL> if output [ <NUM_LIT:1> ] is not None : <EOL> log ( \"<STR_LIT>\" <EOL> % ( output [ <NUM_LIT:0> ] , output [ <NUM_LIT:1> ] ) ) <EOL> process = self . __processes . update ( * output ) <EOL> changed_processes . add ( process ) <EOL> for process in changed_processes : <EOL> self . __process_renderer . update_process ( process ) <EOL> self . __process_pool . cleanup ( ) <EOL> if self . __processes . all_finished ( ) : <EOL> log ( \"<STR_LIT>\" ) <EOL> self . __unassign_autocommands ( ) <EOL> else : <EOL> s = '<STR_LIT>' % Options . refresh_key ( ) <EOL> log ( s ) <EOL> vim . eval ( s ) <EOL> def enable_logger ( self , path ) : <EOL> Log . set_logger ( FileLogger ( Logger . DEBUG , path ) ) <EOL> def stop ( self ) : <EOL> self . __processes . kill_all ( ) <EOL> self . __process_pool . stop ( ) <EOL> def __assign_autocommands ( self ) : <EOL> if self . __au_assigned : <EOL> return <EOL> log ( \"<STR_LIT>\" ) <EOL> vim . command ( '<STR_LIT>' ) <EOL> self . __au_assigned = True <EOL> def __unassign_autocommands ( self ) : <EOL> log ( \"<STR_LIT>\" ) <EOL> vim . command ( '<STR_LIT>' ) <EOL> self . __au_assigned = False <EOL> class ProcessCollection : <EOL> def __init__ ( self ) : <EOL> self . __processes = { } <EOL> def add ( self , command , pid ) : <EOL> process = Process ( command , pid ) <EOL> self . __processes [ pid ] = process <EOL> return process <EOL> def get_by_pid ( self , pid ) : <EOL> return next ( ( p for p in self . __processes . values ( ) if p . get_pid ( ) == pid ) , None ) <EOL> def update ( self , pid , exit_status , stdout , stderr ) : <EOL> process = self . __processes [ pid ] <EOL> if process is not None : <EOL> if exit_status is not None : <EOL> process . mark_as_complete ( exit_status ) <EOL> if stdout or stderr : <EOL> process . output ( ) . append ( stdout , stderr ) <EOL> return process <EOL> def all_finished ( self ) : <EOL> return len ( self . get_running ( ) ) == <NUM_LIT:0> <EOL> def get_running ( self ) : <EOL> return filter ( lambda p : p . is_running ( ) , self . __processes . values ( ) ) <EOL> def kill_all ( self ) : <EOL> for process in self . get_running ( ) : <EOL> process . kill ( ) <EOL> class Process : <EOL> def __init__ ( self , command , pid ) : <EOL> self . __command = command <EOL> self . __pid = str ( pid ) <EOL> self . __start_time = time . time ( ) <EOL> self . __output = Output ( ) <EOL> self . __exit_code = None <EOL> self . __time = None <EOL> def mark_as_complete ( self , exit_code ) : <EOL> self . __exit_code = str ( exit_code ) <EOL> self . __time = round ( ( time . time ( ) - self . __start_time ) * <NUM_LIT:1000> ) <EOL> def has_finished ( self ) : <EOL> return self . __exit_code is not None <EOL> def is_running ( self ) : <EOL> return not self . has_finished ( ) <EOL> def get_pid ( self ) : <EOL> return self . __pid <EOL> def get_status ( self ) : <EOL>", "answer": "if self . __exit_code is None :"}, {"prompt": "<s> import hashlib <EOL> from django . conf import settings <EOL> from django . utils import importlib <EOL> from django . utils . datastructures import SortedDict <EOL> from django . utils . encoding import smart_str <EOL> from django . core . exceptions import ImproperlyConfigured <EOL> from django . utils . crypto import ( <EOL> pbkdf2 , constant_time_compare , get_random_string ) <EOL> from django . utils . translation import ugettext_noop as _ <EOL> UNUSABLE_PASSWORD = '<STR_LIT:!>' <EOL> HASHERS = None <EOL> PREFERRED_HASHER = None <EOL> def is_password_usable ( encoded ) : <EOL> return ( encoded is not None and encoded != UNUSABLE_PASSWORD ) <EOL> def check_password ( password , encoded , setter = None , preferred = '<STR_LIT:default>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not password or not is_password_usable ( encoded ) : <EOL> return False <EOL> preferred = get_hasher ( preferred ) <EOL> raw_password = password <EOL> password = smart_str ( password ) <EOL> encoded = smart_str ( encoded ) <EOL> if len ( encoded ) == <NUM_LIT:32> and '<STR_LIT:$>' not in encoded : <EOL> hasher = get_hasher ( '<STR_LIT>' ) <EOL> else : <EOL> algorithm = encoded . split ( '<STR_LIT:$>' , <NUM_LIT:1> ) [ <NUM_LIT:0> ] <EOL> hasher = get_hasher ( algorithm ) <EOL> must_update = hasher . algorithm != preferred . algorithm <EOL> is_correct = hasher . verify ( password , encoded ) <EOL> if setter and is_correct and must_update : <EOL> setter ( raw_password ) <EOL> return is_correct <EOL> def make_password ( password , salt = None , hasher = '<STR_LIT:default>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not password : <EOL> return UNUSABLE_PASSWORD <EOL> hasher = get_hasher ( hasher ) <EOL> password = smart_str ( password ) <EOL> if not salt : <EOL> salt = hasher . salt ( ) <EOL> salt = smart_str ( salt ) <EOL> return hasher . encode ( password , salt ) <EOL> def load_hashers ( password_hashers = None ) : <EOL> global HASHERS <EOL> global PREFERRED_HASHER <EOL> hashers = [ ] <EOL> if not password_hashers : <EOL> password_hashers = settings . PASSWORD_HASHERS <EOL> for backend in password_hashers : <EOL> try : <EOL> mod_path , cls_name = backend . rsplit ( '<STR_LIT:.>' , <NUM_LIT:1> ) <EOL> mod = importlib . import_module ( mod_path ) <EOL> hasher_cls = getattr ( mod , cls_name ) <EOL> except ( AttributeError , ImportError , ValueError ) : <EOL> raise ImproperlyConfigured ( \"<STR_LIT>\" % backend ) <EOL> hasher = hasher_cls ( ) <EOL> if not getattr ( hasher , '<STR_LIT>' ) : <EOL> raise ImproperlyConfigured ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % backend ) <EOL> hashers . append ( hasher ) <EOL> HASHERS = dict ( [ ( hasher . algorithm , hasher ) for hasher in hashers ] ) <EOL> PREFERRED_HASHER = hashers [ <NUM_LIT:0> ] <EOL> def get_hasher ( algorithm = '<STR_LIT:default>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if hasattr ( algorithm , '<STR_LIT>' ) : <EOL> return algorithm <EOL> elif algorithm == '<STR_LIT:default>' : <EOL> if PREFERRED_HASHER is None : <EOL> load_hashers ( ) <EOL> return PREFERRED_HASHER <EOL> else : <EOL> if HASHERS is None : <EOL> load_hashers ( ) <EOL> if algorithm not in HASHERS : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % algorithm ) <EOL> return HASHERS [ algorithm ] <EOL> def mask_hash ( hash , show = <NUM_LIT:6> , char = \"<STR_LIT:*>\" ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> masked = hash [ : show ] <EOL> masked += char * len ( hash [ show : ] ) <EOL> return masked <EOL> class BasePasswordHasher ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> algorithm = None <EOL> library = None <EOL> def _load_library ( self ) : <EOL> if self . library is not None : <EOL> if isinstance ( self . library , ( tuple , list ) ) : <EOL> name , mod_path = self . library <EOL> else : <EOL> name = mod_path = self . library <EOL> try : <EOL> module = importlib . import_module ( mod_path ) <EOL> except ImportError : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % name ) <EOL> return module <EOL> raise ValueError ( \"<STR_LIT>\" % <EOL> self . __class__ ) <EOL> def salt ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return get_random_string ( ) <EOL> def verify ( self , password , encoded ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL> def encode ( self , password , salt ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL>", "answer": "def safe_summary ( self , encoded ) :"}, {"prompt": "<s> import binascii <EOL> import gevent <EOL> import StringIO <EOL> import struct <EOL> import traceback <EOL> import zipfile <EOL> from gevent import socket <EOL> from gevent . hub import sleep <EOL> from pysteamkit . crypto import CryptoUtil <EOL> from pysteamkit . protobuf import steammessages_base_pb2 , steammessages_clientserver_pb2 <EOL> from pysteamkit . steamid import SteamID <EOL> from pysteamkit . steam_base import EMsg , EUniverse , EResult <EOL> from pysteamkit . steam3 import msg_base <EOL> from pysteamkit . util import Util <EOL> class ProtocolError ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class SocketException ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class NetEncryption ( ) : <EOL> def __init__ ( self , key ) : <EOL> self . key = key <EOL> def process_incoming ( self , data ) : <EOL> return CryptoUtil . symmetric_decrypt ( data , self . key ) <EOL> def process_outgoing ( self , data ) : <EOL> return CryptoUtil . symmetric_encrypt ( data , self . key ) <EOL> class Connection ( object ) : <EOL> def __init__ ( self , client ) : <EOL> self . client = client <EOL> self . connected = False <EOL> self . user_abort = False <EOL> self . netfilter = None <EOL> self . heartbeat = None <EOL> self . session_id = None <EOL> self . steamid = None <EOL> self . client . register_message ( EMsg . ChannelEncryptResult , msg_base . Message , msg_base . MsgHdr , msg_base . ChannelEncryptResult ) <EOL> def cleanup ( self ) : <EOL> if not self . connected : <EOL> return <EOL> if self . heartbeat : <EOL> self . heartbeat . kill ( ) <EOL> self . connected = False <EOL> self . netfilter = None <EOL>", "answer": "self . session_id = None"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . . phonemetadata import NumberFormat , PhoneNumberDesc , PhoneMetadata <EOL>", "answer": "PHONE_METADATA_SE = PhoneMetadata ( id = '<STR_LIT>' , country_code = None , international_prefix = None ,"}, {"prompt": "<s> SIMPLE_VALUE = True <EOL>", "answer": "CONFIGURED_VALUE = '<STR_LIT>' "}, {"prompt": "<s> import awscli . clidriver <EOL> import sys <EOL> import logging <EOL> import copy <EOL> LOG = logging . getLogger ( __name__ ) <EOL> class Completer ( object ) : <EOL> def __init__ ( self , driver = None ) : <EOL> if driver is not None : <EOL> self . driver = driver <EOL> else : <EOL> self . driver = awscli . clidriver . create_clidriver ( ) <EOL> self . main_help = self . driver . create_help_command ( ) <EOL> self . main_options = self . _get_documented_completions ( <EOL> self . main_help . arg_table ) <EOL> def complete ( self , cmdline , point = None ) : <EOL> if point is None : <EOL> point = len ( cmdline ) <EOL> args = cmdline [ <NUM_LIT:0> : point ] . split ( ) <EOL> current_arg = args [ - <NUM_LIT:1> ] <EOL> cmd_args = [ w for w in args if not w . startswith ( '<STR_LIT:->' ) ] <EOL> opts = [ w for w in args if w . startswith ( '<STR_LIT:->' ) ] <EOL> cmd_name , cmd = self . _get_command ( self . main_help , cmd_args ) <EOL> subcmd_name , subcmd = self . _get_command ( cmd , cmd_args ) <EOL> if cmd_name is None : <EOL> return self . _complete_provider ( current_arg , opts ) <EOL> elif subcmd_name is None : <EOL> return self . _complete_command ( cmd_name , cmd , current_arg , opts ) <EOL> return self . _complete_subcommand ( subcmd_name , subcmd , current_arg , opts ) <EOL> def _complete_command ( self , command_name , command_help , current_arg , opts ) : <EOL> if current_arg == command_name : <EOL> if command_help : <EOL> return self . _get_documented_completions ( <EOL> command_help . command_table ) <EOL> elif current_arg . startswith ( '<STR_LIT:->' ) : <EOL> return self . _find_possible_options ( current_arg , opts ) <EOL> elif command_help is not None : <EOL> return self . _get_documented_completions ( <EOL> command_help . command_table , current_arg ) <EOL> return [ ] <EOL> def _complete_subcommand ( self , subcmd_name , subcmd_help , current_arg , opts ) : <EOL> if current_arg != subcmd_name and current_arg . startswith ( '<STR_LIT:->' ) : <EOL> return self . _find_possible_options ( current_arg , opts , subcmd_help ) <EOL> return [ ] <EOL> def _complete_option ( self , option_name ) : <EOL> if option_name == '<STR_LIT>' : <EOL> return [ ] <EOL>", "answer": "if option_name == '<STR_LIT>' :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> revision = '<STR_LIT>' <EOL> down_revision = '<STR_LIT>' <EOL>", "answer": "from alembic import op"}, {"prompt": "<s> from . import view <EOL>", "answer": "from . comp import CardsCounter , Column "}, {"prompt": "<s> '''<STR_LIT>''' <EOL> TEST_APPS = [ <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> import sys <EOL> import logging <EOL> from website . app import init_app <EOL> from website . models import User <EOL> from scripts import utils as script_utils <EOL> from modularodm import Q <EOL> from bson . son import SON <EOL> from framework . mongo import database as db <EOL> from framework . transactions . context import TokuTransaction <EOL> logger = logging . getLogger ( __name__ ) <EOL> pipeline = [ <EOL> { \"<STR_LIT>\" : \"<STR_LIT>\" } , <EOL> { \"<STR_LIT>\" : { \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } } } , <EOL> { \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT:count>\" : { \"<STR_LIT>\" : <NUM_LIT:1> } } } , <EOL> { \"<STR_LIT>\" : SON ( [ ( \"<STR_LIT:count>\" , - <NUM_LIT:1> ) , ( \"<STR_LIT>\" , - <NUM_LIT:1> ) ] ) } <EOL> ] <EOL> def get_duplicate_email ( ) : <EOL> duplicate_emails = [ ] <EOL> result = db [ '<STR_LIT:user>' ] . aggregate ( pipeline ) <EOL> for each in result [ '<STR_LIT:result>' ] : <EOL> if each [ '<STR_LIT:count>' ] > <NUM_LIT:1> : <EOL> duplicate_emails . append ( each [ '<STR_LIT>' ] ) <EOL> return duplicate_emails <EOL> def log_duplicate_acount ( dry ) : <EOL> duplicate_emails = get_duplicate_email ( ) <EOL> count = <NUM_LIT:0> <EOL> if duplicate_emails : <EOL> for email in duplicate_emails : <EOL> users = User . find ( Q ( '<STR_LIT>' , '<STR_LIT>' , email ) & Q ( '<STR_LIT>' , '<STR_LIT>' , None ) & Q ( '<STR_LIT:username>' , '<STR_LIT>' , None ) ) <EOL> for user in users : <EOL> count += <NUM_LIT:1> <EOL> logger . info ( \"<STR_LIT>\" <EOL> . format ( user . fullname , user . username , user . _id , user . emails ) ) <EOL> logger . info ( \"<STR_LIT>\" . format ( count ) ) <EOL> def main ( ) : <EOL> init_app ( routes = False ) <EOL> dry = '<STR_LIT>' in sys . argv <EOL>", "answer": "if not dry :"}, {"prompt": "<s> from twisted . internet import defer , reactor <EOL> from ooni . errors import handleAllFailures <EOL> from ooni . templates import scapyt <EOL> from ooni . utils import log <EOL> from ooni . utils . txscapy import ParasiticTraceroute <EOL> from ooni . settings import config <EOL> from scapy . all import TCPerror , IPerror <EOL> class ParasiticTracerouteTest ( scapyt . BaseScapyTest ) : <EOL> name = \"<STR_LIT>\" <EOL> description = \"<STR_LIT>\" <EOL> version = '<STR_LIT>' <EOL> samplePeriod = <NUM_LIT> <EOL> requiresTor = False <EOL> def setUp ( self ) : <EOL> self . report [ '<STR_LIT>' ] = { } <EOL> def test_parasitic_traceroute ( self ) : <EOL> self . pt = ParasiticTraceroute ( ) <EOL>", "answer": "log . debug ( \"<STR_LIT>\""}, {"prompt": "<s> import sys <EOL> import os <EOL> extensions = [ ] <EOL> templates_path = [ '<STR_LIT>' ] <EOL> source_suffix = '<STR_LIT>' <EOL> master_doc = '<STR_LIT:index>' <EOL> project = '<STR_LIT>' <EOL> copyright = '<STR_LIT>' <EOL> version = '<STR_LIT>' <EOL> release = '<STR_LIT>' <EOL> exclude_patterns = [ ] <EOL> pygments_style = '<STR_LIT>' <EOL> html_theme = '<STR_LIT:default>' <EOL> html_static_path = [ '<STR_LIT>' ] <EOL> htmlhelp_basename = '<STR_LIT>' <EOL> latex_elements = { <EOL> } <EOL> latex_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) , <EOL>", "answer": "]"}, {"prompt": "<s> from . . excel_comparsion_test import ExcelComparisonTest <EOL> from ... workbook import Workbook <EOL> class TestCompareXLSXFiles ( ExcelComparisonTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL>", "answer": "self . maxDiff = None"}, {"prompt": "<s> import json <EOL> import mock <EOL> import requests <EOL> from cinderclient . v1 import client <EOL> from cinderclient import exceptions <EOL> from cinderclient . tests . unit import utils <EOL> class AuthenticateAgainstKeystoneTests ( utils . TestCase ) : <EOL> def test_authenticate_success ( self ) : <EOL> cs = client . Client ( \"<STR_LIT:username>\" , \"<STR_LIT:password>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , service_type = '<STR_LIT>' ) <EOL> resp = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:id>\" : \"<STR_LIT>\" , <EOL> } , <EOL> \"<STR_LIT>\" : [ <EOL> { <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> ] , <EOL> } , <EOL> ] , <EOL> } , <EOL> } <EOL> auth_response = utils . TestResponse ( { <EOL> \"<STR_LIT>\" : <NUM_LIT:200> , <EOL> \"<STR_LIT:text>\" : json . dumps ( resp ) , <EOL> } ) <EOL> mock_request = mock . Mock ( return_value = ( auth_response ) ) <EOL> @ mock . patch . object ( requests , \"<STR_LIT>\" , mock_request ) <EOL> def test_auth_call ( ) : <EOL> cs . client . authenticate ( ) <EOL> headers = { <EOL> '<STR_LIT>' : cs . client . USER_AGENT , <EOL> '<STR_LIT:Content-Type>' : '<STR_LIT:application/json>' , <EOL> '<STR_LIT>' : '<STR_LIT:application/json>' , <EOL> } <EOL> body = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:username>' : cs . client . user , <EOL> '<STR_LIT:password>' : cs . client . password , <EOL> } , <EOL> '<STR_LIT>' : cs . client . projectid , <EOL> } , <EOL> } <EOL> token_url = cs . client . auth_url + \"<STR_LIT>\" <EOL> mock_request . assert_called_with ( <EOL> \"<STR_LIT:POST>\" , <EOL> token_url , <EOL> headers = headers , <EOL> data = json . dumps ( body ) , <EOL> allow_redirects = True , <EOL> ** self . TEST_REQUEST_BASE ) <EOL> endpoints = resp [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] <EOL> public_url = endpoints [ <NUM_LIT:0> ] [ \"<STR_LIT>\" ] . rstrip ( '<STR_LIT:/>' ) <EOL> self . assertEqual ( public_url , cs . client . management_url ) <EOL> token_id = resp [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT:id>\" ] <EOL> self . assertEqual ( token_id , cs . client . auth_token ) <EOL> test_auth_call ( ) <EOL> def test_authenticate_tenant_id ( self ) : <EOL> cs = client . Client ( \"<STR_LIT:username>\" , \"<STR_LIT:password>\" , <EOL> auth_url = \"<STR_LIT>\" , <EOL> tenant_id = '<STR_LIT>' , service_type = '<STR_LIT>' ) <EOL> resp = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:id>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT:description>\" : None , <EOL> \"<STR_LIT>\" : True , <EOL> \"<STR_LIT:id>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" <EOL> } <EOL> } , <EOL> \"<STR_LIT>\" : [ <EOL> { <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> ] , <EOL> } , <EOL> ] , <EOL> } , <EOL> } <EOL> auth_response = utils . TestResponse ( { <EOL> \"<STR_LIT>\" : <NUM_LIT:200> , <EOL> \"<STR_LIT:text>\" : json . dumps ( resp ) , <EOL> } ) <EOL> mock_request = mock . Mock ( return_value = ( auth_response ) ) <EOL> @ mock . patch . object ( requests , \"<STR_LIT>\" , mock_request ) <EOL> def test_auth_call ( ) : <EOL> cs . client . authenticate ( ) <EOL> headers = { <EOL> '<STR_LIT>' : cs . client . USER_AGENT , <EOL> '<STR_LIT:Content-Type>' : '<STR_LIT:application/json>' , <EOL> '<STR_LIT>' : '<STR_LIT:application/json>' , <EOL> } <EOL> body = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:username>' : cs . client . user , <EOL> '<STR_LIT:password>' : cs . client . password , <EOL> } , <EOL> '<STR_LIT>' : cs . client . tenant_id , <EOL> } , <EOL> } <EOL> token_url = cs . client . auth_url + \"<STR_LIT>\" <EOL> mock_request . assert_called_with ( <EOL> \"<STR_LIT:POST>\" , <EOL> token_url , <EOL> headers = headers , <EOL> data = json . dumps ( body ) , <EOL> allow_redirects = True , <EOL> ** self . TEST_REQUEST_BASE ) <EOL> endpoints = resp [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] <EOL> public_url = endpoints [ <NUM_LIT:0> ] [ \"<STR_LIT>\" ] . rstrip ( '<STR_LIT:/>' ) <EOL> self . assertEqual ( public_url , cs . client . management_url ) <EOL> token_id = resp [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT:id>\" ] <EOL> self . assertEqual ( token_id , cs . client . auth_token ) <EOL> tenant_id = resp [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT:id>\" ] <EOL> self . assertEqual ( tenant_id , cs . client . tenant_id ) <EOL> test_auth_call ( ) <EOL> def test_authenticate_failure ( self ) : <EOL> cs = client . Client ( \"<STR_LIT:username>\" , \"<STR_LIT:password>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ) <EOL> resp = { \"<STR_LIT>\" : { \"<STR_LIT:message>\" : \"<STR_LIT>\" , \"<STR_LIT:code>\" : \"<STR_LIT>\" } } <EOL> auth_response = utils . TestResponse ( { <EOL> \"<STR_LIT>\" : <NUM_LIT> , <EOL> \"<STR_LIT:text>\" : json . dumps ( resp ) , <EOL> } ) <EOL> mock_request = mock . Mock ( return_value = ( auth_response ) ) <EOL> @ mock . patch . object ( requests , \"<STR_LIT>\" , mock_request ) <EOL> def test_auth_call ( ) : <EOL> self . assertRaises ( exceptions . Unauthorized , cs . client . authenticate ) <EOL> test_auth_call ( ) <EOL> def test_auth_redirect ( self ) : <EOL> cs = client . Client ( \"<STR_LIT:username>\" , \"<STR_LIT:password>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , service_type = '<STR_LIT>' ) <EOL> dict_correct_response = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:id>\" : \"<STR_LIT>\" , <EOL> } , <EOL> \"<STR_LIT>\" : [ <EOL> { <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : [ <EOL> { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } , <EOL> ] , <EOL> } , <EOL> ] , <EOL> } , <EOL> } <EOL> correct_response = json . dumps ( dict_correct_response ) <EOL> dict_responses = [ <EOL>", "answer": "{ \"<STR_LIT>\" : { '<STR_LIT:location>' : '<STR_LIT>' } ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> class DownloadDecorator ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , middleware_factory ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . middleware_factory = middleware_factory <EOL> def __call__ ( self , view_func , * middleware_args , ** middleware_kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def decorated ( request , * view_args , ** view_kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> response = view_func ( request , * view_args , ** view_kwargs ) <EOL> middleware = self . middleware_factory ( * middleware_args , <EOL> ** middleware_kwargs ) <EOL> return middleware . process_response ( request , response ) <EOL>", "answer": "return decorated "}, {"prompt": "<s> import sys <EOL> import copy <EOL> sys . path . append ( '<STR_LIT:..>' ) <EOL> import time <EOL> import numpy as np <EOL> import scipy as sp <EOL> import sklearn <EOL> import xgboost <EOL> import xgboost . sklearn <EOL> import explainers <EOL> from load_datasets import * <EOL> from sklearn . metrics import accuracy_score <EOL> from sklearn import ensemble , cross_validation <EOL> import pickle <EOL> import parzen_windows <EOL> import argparse <EOL> def get_random_indices ( labels , class_ , probability ) : <EOL> nonzero = ( labels == class_ ) . nonzero ( ) [ <NUM_LIT:0> ] <EOL> if nonzero . shape [ <NUM_LIT:0> ] == <NUM_LIT:0> or probability == <NUM_LIT:0> : <EOL> return [ ] <EOL> return np . random . choice ( nonzero , int ( probability * len ( nonzero ) ) , replace = False ) <EOL> def add_corrupt_feature ( feature_name , clean_train , clean_test , dirty_train , <EOL> train_labels , test_labels , class_probs_dirty , class_probs_clean , fake_prefix = '<STR_LIT>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for class_ in set ( train_labels ) : <EOL> indices = get_random_indices ( train_labels , class_ , class_probs_clean [ class_ ] ) <EOL> for i in indices : <EOL> clean_train [ i ] += '<STR_LIT>' % ( fake_prefix , feature_name , fake_prefix ) <EOL> indices = get_random_indices ( train_labels , class_ , class_probs_dirty [ class_ ] ) <EOL> for i in indices : <EOL> dirty_train [ i ] += '<STR_LIT>' % ( fake_prefix , feature_name , fake_prefix ) <EOL> indices = get_random_indices ( test_labels , class_ , class_probs_clean [ class_ ] ) <EOL> for i in indices : <EOL> clean_test [ i ] += '<STR_LIT>' % ( fake_prefix , feature_name , fake_prefix ) <EOL> def corrupt_dataset ( independent_features , train_data , train_labels , test_data , test_labels ) : <EOL> dirty_train = copy . deepcopy ( train_data ) <EOL> clean_train = copy . deepcopy ( train_data ) <EOL> clean_test = copy . deepcopy ( test_data ) <EOL> idx = <NUM_LIT:0> <EOL> for probs , probs2 , n in independent_features : <EOL> for i in range ( n ) : <EOL> add_corrupt_feature ( '<STR_LIT>' % idx , clean_train , clean_test , dirty_train , train_labels , test_labels , probs , probs2 ) <EOL> idx += <NUM_LIT:1> <EOL> return clean_train , dirty_train , clean_test <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( description = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , type = str , required = True , help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , type = str , required = True , help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , type = int , required = True , help = '<STR_LIT>' ) <EOL>", "answer": "parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , type = int , required = True , help = '<STR_LIT>' )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "from twisted . web import distrib"}, {"prompt": "<s> import traceback <EOL> import LegacyUsers , LegacyChannels <EOL> try : <EOL>", "answer": "import LegacyBans"}, {"prompt": "<s> from django . core . exceptions import ObjectDoesNotExist , ValidationError <EOL> from django . db . models import Q , F <EOL> from mozdns . domain . models import Domain <EOL> from mozdns . mx . models import MX <EOL> from mozdns . sshfp . models import SSHFP <EOL> from mozdns . txt . models import TXT <EOL> from mozdns . srv . models import SRV <EOL> from mozdns . address_record . models import AddressRecord <EOL> from mozdns . cname . models import CNAME <EOL> from core . registration . static . models import StaticReg <EOL> from copy import deepcopy <EOL> def tablefy ( objects , views = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> matrix = [ ] <EOL> urls = [ ] <EOL> headers = [ ] <EOL> if not objects : <EOL> return ( None , None , None ) <EOL> for title , value in objects [ <NUM_LIT:0> ] . details ( ) : <EOL> headers . append ( title ) <EOL> if views : <EOL> headers . append ( \"<STR_LIT>\" ) <EOL> for obj in objects : <EOL> row = [ ] <EOL> urls . append ( obj . get_absolute_url ( ) ) <EOL> for title , value in obj . details ( ) : <EOL> row . append ( value ) <EOL> if views : <EOL> views = \"<STR_LIT>\" <EOL> if hasattr ( obj , '<STR_LIT>' ) : <EOL> for view in obj . views . all ( ) : <EOL> views += view . name + \"<STR_LIT:U+002CU+0020>\" <EOL> views = views . strip ( \"<STR_LIT:U+002CU+0020>\" ) <EOL> row . append ( views ) <EOL> matrix . append ( row ) <EOL> return ( headers , matrix , urls ) <EOL> def slim_form ( domain_pk = None , form = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return form <EOL> def get_clobbered ( domain_name ) : <EOL> classes = [ MX , AddressRecord , CNAME , TXT , SRV , StaticReg , SSHFP ] <EOL> clobber_querysets = [ ] <EOL> for Klass in classes : <EOL> objs = Klass . objects . select_for_update ( ) . filter ( fqdn = domain_name ) <EOL> if objs . exists ( ) : <EOL> clobber_querysets . append ( objs ) <EOL> return clobber_querysets <EOL> def ensure_domain ( name , purgeable = False , inherit_soa = False , force = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> domain = Domain . objects . get ( name = name ) <EOL> return domain <EOL> except ObjectDoesNotExist : <EOL> pass <EOL> parts = list ( reversed ( name . split ( '<STR_LIT:.>' ) ) ) <EOL> if not force : <EOL> domain_name = '<STR_LIT>' <EOL> leaf_domain = None <EOL> for i in range ( len ( parts ) ) : <EOL> domain_name = parts [ i ] + '<STR_LIT:.>' + domain_name <EOL> domain_name = domain_name . strip ( '<STR_LIT:.>' ) <EOL> try : <EOL> tmp_domain = Domain . objects . get ( name = domain_name ) <EOL> leaf_domain = tmp_domain <EOL> except ObjectDoesNotExist : <EOL> continue <EOL> if not leaf_domain : <EOL> raise ValidationError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> if leaf_domain . delegated : <EOL> raise ValidationError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> if not leaf_domain . soa : <EOL> raise ValidationError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> domain_name = '<STR_LIT>' <EOL> for i in range ( len ( parts ) ) : <EOL> domain_name = parts [ i ] + '<STR_LIT:.>' + domain_name <EOL> domain_name = domain_name . strip ( '<STR_LIT:.>' ) <EOL> if Domain . objects . filter ( name = domain_name ) . exists ( ) : <EOL> continue <EOL> clobber_querysets = get_clobbered ( domain_name ) <EOL> domain = Domain ( name = domain_name ) <EOL> if purgeable : <EOL> domain . purgeable = True <EOL> domain . clean ( ignore_conflicts = True ) <EOL> if ( inherit_soa and domain . master_domain and <EOL> domain . master_domain . soa is not None ) : <EOL> domain . soa = domain . master_domain . soa <EOL> domain . save ( do_full_clean = False ) <EOL> for qs in clobber_querysets : <EOL> qs . update ( domain = domain , label = '<STR_LIT>' ) <EOL> domain . clean_fields ( ) <EOL> return domain <EOL> def ensure_label_domain ( fqdn , force = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if fqdn == '<STR_LIT>' : <EOL> raise ValidationError ( \"<STR_LIT>\" ) <EOL> try : <EOL> domain = Domain . objects . get ( name = fqdn ) <EOL> if not domain . soa and not force : <EOL> raise ValidationError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> return '<STR_LIT>' , domain <EOL> except ObjectDoesNotExist : <EOL> pass <EOL> fqdn_partition = fqdn . split ( '<STR_LIT:.>' ) <EOL> if len ( fqdn_partition ) == <NUM_LIT:1> : <EOL> raise ValidationError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" . format ( fqdn ) ) <EOL> else : <EOL> label , domain_name = fqdn_partition [ <NUM_LIT:0> ] , '<STR_LIT:.>' . join ( fqdn_partition [ <NUM_LIT:1> : ] ) <EOL> domain = ensure_domain ( domain_name , purgeable = True , inherit_soa = True ) <EOL> if not domain . soa and not force : <EOL> raise ValidationError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> return label , domain <EOL> def prune_tree ( domain ) : <EOL> return prune_tree_helper ( domain , [ ] ) <EOL> def prune_tree_helper ( domain , deleted_domains ) : <EOL> if not domain : <EOL> return deleted_domains <EOL> if domain . domain_set . all ( ) . count ( ) : <EOL> return deleted_domains <EOL> if domain . has_record_set ( ) : <EOL> return deleted_domains <EOL> elif not domain . purgeable : <EOL> return deleted_domains <EOL>", "answer": "else :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import networkx as nx <EOL> from networkx . utils import * <EOL> __author__ = \"<STR_LIT:\\n>\" . join ( [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] ) <EOL> __all__ = [ '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> @ not_implemented_for ( '<STR_LIT>' ) <EOL> def katz_centrality ( G , alpha = <NUM_LIT:0.1> , beta = <NUM_LIT:1.0> , <EOL> max_iter = <NUM_LIT:1000> , tol = <NUM_LIT> , nstart = None , normalized = True ) : <EOL> r\"\"\"<STR_LIT>\"\"\" <EOL> from math import sqrt <EOL> if len ( G ) == <NUM_LIT:0> : <EOL> return { } <EOL> nnodes = G . number_of_nodes ( ) <EOL> if nstart is None : <EOL> x = dict ( [ ( n , <NUM_LIT:0> ) for n in G ] ) <EOL> else : <EOL> x = nstart <EOL> try : <EOL>", "answer": "b = dict . fromkeys ( G , float ( beta ) )"}, {"prompt": "<s> from behave . tag_matcher import ActiveTagMatcher , setup_active_tag_values <EOL> import platform <EOL> import sys <EOL> import six <EOL> python_version = \"<STR_LIT>\" % sys . version_info [ : <NUM_LIT:2> ] <EOL> active_tag_value_provider = { <EOL> \"<STR_LIT>\" : str ( six . PY2 ) . lower ( ) , <EOL> \"<STR_LIT>\" : str ( six . PY3 ) . lower ( ) , <EOL> \"<STR_LIT>\" : python_version , <EOL> \"<STR_LIT>\" : platform . python_implementation ( ) . lower ( ) , <EOL> \"<STR_LIT>\" : str ( \"<STR_LIT>\" in sys . modules ) . lower ( ) , <EOL> \"<STR_LIT>\" : sys . platform , <EOL> } <EOL> active_tag_matcher = ActiveTagMatcher ( active_tag_value_provider ) <EOL> def before_all ( context ) : <EOL> setup_active_tag_values ( active_tag_value_provider , context . config . userdata ) <EOL> setup_python_path ( ) <EOL> setup_context_with_global_params_test ( context ) <EOL> def before_feature ( context , feature ) : <EOL> if active_tag_matcher . should_exclude_with ( feature . tags ) : <EOL> feature . skip ( reason = active_tag_matcher . exclude_reason ) <EOL> def before_scenario ( context , scenario ) : <EOL> if active_tag_matcher . should_exclude_with ( scenario . effective_tags ) : <EOL>", "answer": "scenario . skip ( reason = active_tag_matcher . exclude_reason )"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . contrib import admin <EOL> from shop . admin . order import PrintOrderAdminMixin , BaseOrderAdmin <EOL> from shop . models . defaults . order import Order <EOL> from shop . admin . delivery import DeliveryOrderAdminMixin <EOL> @ admin . register ( Order ) <EOL> class OrderAdmin ( PrintOrderAdminMixin , DeliveryOrderAdminMixin , BaseOrderAdmin ) : <EOL> search_fields = BaseOrderAdmin . search_fields + ( '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' , '<STR_LIT>' , )"}, {"prompt": "<s> try : <EOL> print <NUM_LIT:1> / <NUM_LIT:0> <EOL> print \"<STR_LIT>\" <EOL> print <NUM_LIT> / <NUM_LIT:0> <EOL> except ZeroDivisionError : <EOL>", "answer": "print \"<STR_LIT>\" "}, {"prompt": "<s> import unittest <EOL> import pdfparanoia <EOL> class AmericanInstituteOfPhysicsTestCase ( unittest . TestCase ) : <EOL> def test_aip ( self ) : <EOL>", "answer": "file_handler = open ( \"<STR_LIT>\" , \"<STR_LIT:rb>\" )"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import unittest <EOL> import numpy <EOL> from GPy . inference . optimization . conjugate_gradient_descent import CGD , RUNNING <EOL> import pylab <EOL> from scipy . optimize . optimize import rosen , rosen_der <EOL> from GPy . inference . optimization . gradient_descent_update_rules import PolakRibiere <EOL> class Test ( unittest . TestCase ) : <EOL> def testMinimizeSquare ( self ) : <EOL> N = <NUM_LIT:100> <EOL> A = numpy . random . rand ( N ) * numpy . eye ( N ) <EOL> b = numpy . random . rand ( N ) * <NUM_LIT:0> <EOL> f = lambda x : numpy . dot ( x . T . dot ( A ) , x ) - numpy . dot ( x . T , b ) <EOL> df = lambda x : numpy . dot ( A , x ) - b <EOL> opt = CGD ( ) <EOL> restarts = <NUM_LIT:10> <EOL> for _ in range ( restarts ) : <EOL> try : <EOL> x0 = numpy . random . randn ( N ) * <NUM_LIT:10> <EOL> res = opt . opt ( f , df , x0 , messages = <NUM_LIT:0> , maxiter = <NUM_LIT:1000> , gtol = <NUM_LIT> ) <EOL> assert numpy . allclose ( res [ <NUM_LIT:0> ] , <NUM_LIT:0> , atol = <NUM_LIT> ) <EOL> break <EOL> except AssertionError : <EOL> import pdb ; pdb . set_trace ( ) <EOL> pass <EOL> else : <EOL> raise AssertionError ( \"<STR_LIT>\" . format ( restarts ) ) <EOL> def testRosen ( self ) : <EOL> N = <NUM_LIT:20> <EOL> f = rosen <EOL> df = rosen_der <EOL> opt = CGD ( ) <EOL> restarts = <NUM_LIT:10> <EOL> for _ in range ( restarts ) : <EOL> try : <EOL> x0 = ( numpy . random . randn ( N ) * <NUM_LIT> ) + numpy . ones ( N ) <EOL> res = opt . opt ( f , df , x0 , messages = <NUM_LIT:0> , <EOL> maxiter = <NUM_LIT> , gtol = <NUM_LIT> ) <EOL> assert numpy . allclose ( res [ <NUM_LIT:0> ] , <NUM_LIT:1> , atol = <NUM_LIT> ) <EOL> break <EOL> except : <EOL> pass <EOL> else : <EOL> raise AssertionError ( \"<STR_LIT>\" . format ( restarts ) ) <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL> N = <NUM_LIT:2> <EOL> A = numpy . random . rand ( N ) * numpy . eye ( N ) <EOL> b = numpy . random . rand ( N ) * <NUM_LIT:0> <EOL> f = lambda x : numpy . dot ( x . T . dot ( A ) , x ) - numpy . dot ( x . T , b ) <EOL> df = lambda x : numpy . dot ( A , x ) - b <EOL> x0 = ( numpy . random . randn ( N ) * <NUM_LIT> ) + numpy . ones ( N ) <EOL> print x0 <EOL> opt = CGD ( ) <EOL> pylab . ion ( ) <EOL> fig = pylab . figure ( \"<STR_LIT>\" ) <EOL> if fig . axes : <EOL> ax = fig . axes [ <NUM_LIT:0> ] <EOL> ax . cla ( ) <EOL> else : <EOL> ax = fig . add_subplot ( <NUM_LIT> , projection = '<STR_LIT>' ) <EOL> interpolation = <NUM_LIT> <EOL> x , y = numpy . linspace ( - <NUM_LIT:1> , <NUM_LIT:1> , interpolation ) [ : , None ] , numpy . linspace ( - <NUM_LIT:1> , <NUM_LIT:1> , interpolation ) [ : , None ] <EOL> X , Y = numpy . meshgrid ( x , y ) <EOL> fXY = numpy . array ( [ f ( numpy . array ( [ x , y ] ) ) for x , y in zip ( X . flatten ( ) , Y . flatten ( ) ) ] ) . reshape ( interpolation , interpolation ) <EOL> ax . plot_wireframe ( X , Y , fXY ) <EOL> xopts = [ x0 . copy ( ) ] <EOL> optplts , = ax . plot3D ( [ x0 [ <NUM_LIT:0> ] ] , [ x0 [ <NUM_LIT:1> ] ] , zs = f ( x0 ) , marker = '<STR_LIT>' , color = '<STR_LIT:r>' ) <EOL> raw_input ( \"<STR_LIT>\" ) <EOL> res = [ <NUM_LIT:0> ] <EOL> def callback ( * r ) : <EOL> xopts . append ( r [ <NUM_LIT:0> ] . copy ( ) ) <EOL> optplts . _verts3d = [ numpy . array ( xopts ) [ : , <NUM_LIT:0> ] , numpy . array ( xopts ) [ : , <NUM_LIT:1> ] , [ f ( xs ) for xs in xopts ] ] <EOL> fig . canvas . draw ( ) <EOL>", "answer": "if r [ - <NUM_LIT:1> ] != RUNNING :"}, {"prompt": "<s> people = <NUM_LIT:30> <EOL> cars = <NUM_LIT> <EOL> trucks = <NUM_LIT:15> <EOL>", "answer": "if cars > people :"}, {"prompt": "<s> __author__ = \"<STR_LIT>\" <EOL> __email__ = \"<STR_LIT>\" <EOL> __description__ = \"<STR_LIT>\" <EOL> import sys <EOL> import os <EOL> import hashlib <EOL> import time <EOL> import progress_bar , system_operations , metadata <EOL> from constants import BACKUP_DIR , OLD_VERSIONS_DIR , CONTEND_DIR <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def do_moving ( workfolder , checkoutfolder ) : <EOL> files = system_operations . create_list_of_files ( checkoutfolder ) <EOL> pb = progress_bar . ProgressBar ( \"<STR_LIT>\" + checkoutfolder + \"<STR_LIT>\" ) <EOL> system_operations . moving_dir ( workfolder + \"<STR_LIT:/>\" + BACKUP_DIR , BACKUP_DIR ) <EOL> system_operations . removing_dir_tree ( workfolder ) <EOL> system_operations . creating_dir_tree ( workfolder ) <EOL> system_operations . moving_dir ( BACKUP_DIR , workfolder ) <EOL> for i , file in enumerate ( files ) : <EOL> pb . calculateAndUpdate ( i + <NUM_LIT:1> , len ( files ) ) <EOL> backup_file = checkoutfolder + '<STR_LIT:/>' + file <EOL> system_operations . copying_file ( backup_file , workfolder ) <EOL> time . sleep ( <NUM_LIT> ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def move_deprecate_folders ( dest , co_folder ) : <EOL> folders = system_operations . create_list_of_folders ( dest ) <EOL> try : <EOL> folders . remove ( OLD_VERSIONS_DIR ) <EOL> except : <EOL> pass <EOL> folders = [ str ( f ) for f in map ( int , folders ) if f > int ( co_folder ) ] <EOL> folder_id = <NUM_LIT:0> <EOL> if folders : <EOL> folder_id = hashlib . sha1 ( ) <EOL> folder_id . update ( str ( time . time ( ) ) ) <EOL> folder_id = folder_id . hexdigest ( ) [ : <NUM_LIT:15> ] <EOL> deprecated_folder = dest + '<STR_LIT:/>' + OLD_VERSIONS_DIR + \"<STR_LIT:/>\" + folder_id <EOL> system_operations . creating_dir_tree ( deprecated_folder ) <EOL> for folder in folders : <EOL> source_folder = dest + \"<STR_LIT:/>\" + folder <EOL> dest_folder = deprecated_folder + '<STR_LIT:/>' + folder <EOL> system_operations . moving_dir ( source_folder , dest_folder ) <EOL> return folder_id <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def get_snapshot ( source , argument ) : <EOL> if not os . path . exists ( source ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> sys . exit ( <NUM_LIT:0> ) <EOL> if argument == '<STR_LIT>' or argument == '<STR_LIT:l>' : <EOL> folders = system_operations . create_list_of_folders ( source ) <EOL> folders = map ( int , folders ) <EOL> return source + '<STR_LIT:/>' + str ( max ( folders ) ) <EOL> path = source + '<STR_LIT:/>' + argument <EOL> try : <EOL> assert ( int ( argument ) > <NUM_LIT:0> ) <EOL> except : <EOL> print ( \"<STR_LIT>\" ) <EOL> sys . exit ( <NUM_LIT:0> ) <EOL> try : <EOL> assert ( os . path . exists ( path ) ) <EOL> except : <EOL> print ( \"<STR_LIT>\" % argument ) <EOL> sys . exit ( <NUM_LIT:0> ) <EOL> return path <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def main ( dest , source , co_folder ) : <EOL> path = get_snapshot ( dest , co_folder ) <EOL> folder_id = move_deprecate_folders ( dest , co_folder ) <EOL> if folder_id : <EOL> metadata . update_header_checkout ( dest , co_folder , folder_id ) <EOL> do_moving ( source , path ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( \"<STR_LIT>\" ) <EOL>", "answer": "main ( CONTEND_DIR , BACKUP_DIR , argument = '<STR_LIT:2>' ) "}, {"prompt": "<s> TARGETS = [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> PACKAGE = { <EOL> '<STR_LIT:title>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> def setup ( targets ) : <EOL> '''<STR_LIT>''' <EOL> util . setup ( targets ) <EOL> def translate ( ) : <EOL> '''<STR_LIT>''' <EOL> util . translate ( ) <EOL>", "answer": "def install ( package ) :"}, {"prompt": "<s> from ceph_deploy . util import paths <EOL> from ceph_deploy import conf <EOL>", "answer": "from ceph_deploy . lib import remoto"}, {"prompt": "<s> import sys <EOL> import time <EOL> import unittest2 as unittest <EOL> from pyspider . libs import utils <EOL> class TestFetcher ( unittest . TestCase ) : <EOL> def test_readonlydict ( self ) : <EOL> data = dict ( a = '<STR_LIT:a>' , b = <NUM_LIT> ) <EOL> data [ '<STR_LIT:c>' ] = self <EOL> data = utils . ReadOnlyDict ( data ) <EOL> with self . assertRaises ( Exception ) : <EOL> data [ '<STR_LIT:d>' ] = <NUM_LIT:9> <EOL> def test_getitem ( self ) : <EOL> l = [ <NUM_LIT:1> , <NUM_LIT:2> ] <EOL> self . assertEqual ( utils . getitem ( l , <NUM_LIT:0> ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( utils . getitem ( l , <NUM_LIT:1> ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( utils . getitem ( l , <NUM_LIT:3> ) , None ) <EOL> self . assertEqual ( utils . getitem ( l , <NUM_LIT:3> , <NUM_LIT:9> ) , <NUM_LIT:9> ) <EOL> self . assertEqual ( utils . getitem ( l , '<STR_LIT:key>' ) , None ) <EOL> self . assertEqual ( utils . getitem ( l , '<STR_LIT:key>' , <NUM_LIT:8> ) , <NUM_LIT:8> ) <EOL> data = dict ( a = '<STR_LIT:a>' , b = <NUM_LIT> ) <EOL> self . assertEqual ( utils . getitem ( data , '<STR_LIT:a>' ) , '<STR_LIT:a>' ) <EOL> self . assertEqual ( utils . getitem ( data , '<STR_LIT:b>' ) , <NUM_LIT> ) <EOL> self . assertEqual ( utils . getitem ( data , '<STR_LIT:c>' ) , None ) <EOL> self . assertEqual ( utils . getitem ( data , '<STR_LIT:c>' , <NUM_LIT:9> ) , <NUM_LIT:9> ) <EOL> def test_format_data ( self ) : <EOL> now = time . time ( ) <EOL> self . assertEqual ( utils . format_date ( now - <NUM_LIT:30> ) , '<STR_LIT>' ) <EOL> self . assertEqual ( utils . format_date ( now - <NUM_LIT> ) , '<STR_LIT>' ) <EOL> self . assertEqual ( utils . format_date ( now - <NUM_LIT:2> * <NUM_LIT> ) , '<STR_LIT>' ) <EOL> self . assertEqual ( utils . format_date ( now - <NUM_LIT:30> * <NUM_LIT> ) , '<STR_LIT>' ) <EOL> self . assertEqual ( utils . format_date ( now - <NUM_LIT> * <NUM_LIT> ) , '<STR_LIT>' ) <EOL> self . assertEqual ( utils . format_date ( <NUM_LIT> ) , '<STR_LIT>' ) <EOL> self . assertEqual ( utils . format_date ( now - <NUM_LIT:12> * <NUM_LIT> * <NUM_LIT> ) , '<STR_LIT>' ) <EOL>", "answer": "self . assertRegex ( utils . format_date ( now - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) , r'<STR_LIT>' )"}, {"prompt": "<s> __author__ = \"<STR_LIT>\" <EOL> __doc__ = \"\"\"<STR_LIT>\"\"\" <EOL> import ConfigParser <EOL> import errno <EOL> import grp <EOL> import logging <EOL> import optparse <EOL> import os <EOL> import pwd <EOL> import signal <EOL> import sys <EOL> import time <EOL> class Daemon ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> default_conf = '<STR_LIT>' <EOL> section = '<STR_LIT>' <EOL> def setup_root ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setup_user ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def run ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def main ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . parse_options ( ) <EOL> action = self . options . action <EOL> self . read_basic_config ( ) <EOL> if action == '<STR_LIT:start>' : <EOL> self . start ( ) <EOL> elif action == '<STR_LIT>' : <EOL> self . stop ( ) <EOL> else : <EOL> raise ValueError ( action ) <EOL> def parse_options ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> p = optparse . OptionParser ( ) <EOL> p . add_option ( '<STR_LIT>' , dest = '<STR_LIT:action>' , <EOL> action = '<STR_LIT>' , const = '<STR_LIT:start>' , default = '<STR_LIT:start>' , <EOL>", "answer": "help = '<STR_LIT>' )"}, {"prompt": "<s> import novaclient . exceptions <EOL> class ServiceCatalog ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , resource_dict ) : <EOL> self . catalog = resource_dict <EOL> def get_token ( self ) : <EOL> return self . catalog [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] <EOL> def get_tenant_id ( self ) : <EOL> return self . catalog [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] <EOL> def url_for ( self , attr = None , filter_value = None , <EOL> service_type = None , endpoint_type = '<STR_LIT>' , <EOL>", "answer": "service_name = None , volume_service_name = None ) :"}, {"prompt": "<s> from django . conf . urls import patterns , url <EOL> from simplepage . views import SimplePageListView , SimplePageDetailView <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL> url ( r'<STR_LIT>' , SimplePageListView . as_view ( ) , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , SimplePageDetailView . as_view ( ) , name = '<STR_LIT>' ) , <EOL>", "answer": ") "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> revision = '<STR_LIT>' <EOL> down_revision = '<STR_LIT>' <EOL> from alembic import op <EOL> import sqlalchemy as sa <EOL> def upgrade ( ) : <EOL> op . add_column ( '<STR_LIT>' , sa . Column ( '<STR_LIT>' , sa . Boolean ( ) , nullable = True ) ) <EOL> def downgrade ( ) : <EOL>", "answer": "op . drop_column ( '<STR_LIT>' , '<STR_LIT>' ) "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL>", "answer": "QUERY_TERMS = {"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from __future__ import division <EOL> from __future__ import print_function <EOL> CONDUIT_REFRESH = \"<STR_LIT>\" <EOL> GIT_SNOOP = \"<STR_LIT>\" <EOL> FETCH_PRUNE = '<STR_LIT>' <EOL> CONDUIT_CONNECT = '<STR_LIT>' <EOL>", "answer": "PUSH_DELETE_REVIEW = '<STR_LIT>'"}, {"prompt": "<s> import sys <EOL> class Step ( object ) : <EOL> '''<STR_LIT>''' <EOL> name = '<STR_LIT>' <EOL> def __init__ ( self , message , * args ) : <EOL> self . _message = message <EOL> self . _args = args <EOL> self . _context = sys . _getframe ( <NUM_LIT:1> ) <EOL> self . _set_step_attrs ( self . _context . f_locals ) <EOL> self . _steps = self . _context . f_locals [ '<STR_LIT>' % self . __class__ . name ] <EOL> self . _steps . append ( ( None , self . _message , self . _args ) ) <EOL> def _set_step_attrs ( self , local_attrs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> attr_name = '<STR_LIT>' % self . name <EOL> if not attr_name in local_attrs : <EOL> local_attrs [ attr_name ] = [ ] <EOL> def __call__ ( self , method = None ) : <EOL> del self . _steps [ - <NUM_LIT:1> ] <EOL> self . _steps . append ( ( method , self . _message , self . _args ) ) <EOL> return method <EOL>", "answer": "class Given ( Step ) :"}, {"prompt": "<s> import json <EOL> import sys <EOL> from pprint import pformat <EOL> import requests <EOL> from requests . adapters import HTTPAdapter <EOL> from requests . packages import urllib3 <EOL> from httpie import sessions <EOL> from httpie import __version__ <EOL> from httpie . compat import str <EOL> from httpie . input import SSL_VERSION_ARG_MAPPING <EOL> from httpie . plugins import plugin_manager <EOL> from httpie . utils import repr_dict_nice <EOL> try : <EOL> urllib3 . disable_warnings ( ) <EOL> except AttributeError : <EOL> pass <EOL> FORM = '<STR_LIT>' <EOL> JSON = '<STR_LIT:application/json>' <EOL> DEFAULT_UA = '<STR_LIT>' % __version__ <EOL> class HTTPieHTTPAdapter ( HTTPAdapter ) : <EOL> def __init__ ( self , ssl_version = None , ** kwargs ) : <EOL> self . _ssl_version = ssl_version <EOL> super ( HTTPieHTTPAdapter , self ) . __init__ ( ** kwargs ) <EOL> def init_poolmanager ( self , * args , ** kwargs ) : <EOL> kwargs [ '<STR_LIT>' ] = self . _ssl_version <EOL> super ( HTTPieHTTPAdapter , self ) . init_poolmanager ( * args , ** kwargs ) <EOL> def get_requests_session ( ssl_version ) : <EOL> requests_session = requests . Session ( ) <EOL> requests_session . mount ( <EOL> '<STR_LIT>' , <EOL> HTTPieHTTPAdapter ( ssl_version = ssl_version ) <EOL> ) <EOL> for cls in plugin_manager . get_transport_plugins ( ) : <EOL> transport_plugin = cls ( ) <EOL> requests_session . mount ( prefix = transport_plugin . prefix , <EOL> adapter = transport_plugin . get_adapter ( ) ) <EOL> return requests_session <EOL> def get_response ( args , config_dir ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ssl_version = None <EOL> if args . ssl_version : <EOL> ssl_version = SSL_VERSION_ARG_MAPPING [ args . ssl_version ] <EOL> requests_session = get_requests_session ( ssl_version ) <EOL> requests_session . max_redirects = args . max_redirects <EOL> if not args . session and not args . session_read_only : <EOL> kwargs = get_requests_kwargs ( args ) <EOL> if args . debug : <EOL>", "answer": "dump_request ( kwargs )"}, {"prompt": "<s> import os <EOL> import sys <EOL> import signal <EOL> import optparse <EOL> try : <EOL> import whisper <EOL> except ImportError : <EOL> raise SystemExit ( '<STR_LIT>' ) <EOL> try : <EOL> signal . signal ( signal . SIGPIPE , signal . SIG_DFL ) <EOL> except AttributeError : <EOL> pass <EOL> option_parser = optparse . OptionParser ( <EOL> usage = '<STR_LIT>' % '<STR_LIT:|>' . join ( whisper . aggregationMethods ) ) <EOL> ( options , args ) = option_parser . parse_args ( ) <EOL> if len ( args ) < <NUM_LIT:2> : <EOL> option_parser . print_help ( ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> path = args [ <NUM_LIT:0> ] <EOL>", "answer": "aggregationMethod = args [ <NUM_LIT:1> ]"}, {"prompt": "<s> CHECKOUT_BUTTON_SIZES = { <EOL>", "answer": "\"<STR_LIT>\" : ( <NUM_LIT> , <NUM_LIT> ) ,"}, {"prompt": "<s> __VERSION__ = \"<STR_LIT>\" <EOL> import urllib , urllib2 , base64 , hmac <EOL> from hashlib import sha1 <EOL> from xml . dom . minidom import Document <EOL> try : <EOL> from google . appengine . api import urlfetch <EOL> APPENGINE = True <EOL> except ImportError : <EOL> APPENGINE = False <EOL> try : <EOL> import json <EOL> except ImportError : <EOL> import simplejson as json <EOL> class PlivoException ( Exception ) : pass <EOL> class HTTPErrorProcessor ( urllib2 . HTTPErrorProcessor ) : <EOL> def https_response ( self , request , response ) : <EOL> code , msg , hdrs = response . code , response . msg , response . info ( ) <EOL> if code >= <NUM_LIT> : <EOL> response = self . parent . error ( <EOL> '<STR_LIT:http>' , request , response , code , msg , hdrs ) <EOL> return response <EOL> class HTTPErrorAppEngine ( Exception ) : pass <EOL> class PlivoUrlRequest ( urllib2 . Request ) : <EOL> def get_method ( self ) : <EOL> if getattr ( self , '<STR_LIT>' , None ) : <EOL> return self . http_method <EOL> return urllib2 . Request . get_method ( self ) <EOL> class REST ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , url , auth_id = '<STR_LIT>' , auth_token = '<STR_LIT>' , api_version = __VERSION__ ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . url = url <EOL> self . auth_id = auth_id <EOL> self . auth_token = auth_token <EOL> self . opener = None <EOL> self . api_version = api_version <EOL> def _build_get_uri ( self , uri , params ) : <EOL> if params : <EOL> if uri . find ( '<STR_LIT:?>' ) > <NUM_LIT:0> : <EOL> if uri [ - <NUM_LIT:1> ] != '<STR_LIT:&>' : <EOL> uri += '<STR_LIT:&>' <EOL> uri = uri + urllib . urlencode ( params ) <EOL> else : <EOL> uri = uri + '<STR_LIT:?>' + urllib . urlencode ( params ) <EOL> return uri <EOL> def _urllib2_fetch ( self , uri , params , method = None ) : <EOL> if self . opener == None : <EOL> self . opener = urllib2 . build_opener ( HTTPErrorProcessor ) <EOL> urllib2 . install_opener ( self . opener ) <EOL> if method and method == '<STR_LIT:GET>' : <EOL> uri = self . _build_get_uri ( uri , params ) <EOL> req = PlivoUrlRequest ( uri ) <EOL> else : <EOL> req = PlivoUrlRequest ( uri , urllib . urlencode ( params ) ) <EOL> if method and ( method == '<STR_LIT>' or method == '<STR_LIT>' ) : <EOL> req . http_method = method <EOL> authstring = base64 . encodestring ( '<STR_LIT>' % ( self . auth_id , self . auth_token ) ) <EOL> authstring = authstring . replace ( '<STR_LIT:\\n>' , '<STR_LIT>' ) <EOL> req . add_header ( \"<STR_LIT>\" , \"<STR_LIT>\" % authstring ) <EOL> response = urllib2 . urlopen ( req ) <EOL> return response . read ( ) <EOL> def _appengine_fetch ( self , uri , params , method ) : <EOL> if method == '<STR_LIT:GET>' : <EOL> uri = self . _build_get_uri ( uri , params ) <EOL> try : <EOL> httpmethod = getattr ( urlfetch , method ) <EOL> except AttributeError : <EOL> raise NotImplementedError ( <EOL> \"<STR_LIT>\" % method ) <EOL> authstring = base64 . encodestring ( '<STR_LIT>' % ( self . auth_id , self . auth_token ) ) <EOL> authstring = authstring . replace ( '<STR_LIT:\\n>' , '<STR_LIT>' ) <EOL> r = urlfetch . fetch ( url = uri , payload = urllib . urlencode ( params ) , <EOL> method = httpmethod , <EOL> headers = { '<STR_LIT:Content-Type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' % authstring } ) <EOL> if r . status_code >= <NUM_LIT> : <EOL> raise HTTPErrorAppEngine ( \"<STR_LIT>\" % ( r . status_code , r . content ) ) <EOL> return r . content <EOL> def request ( self , path , method = None , data = { } ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not path : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> if method and method not in [ '<STR_LIT:GET>' , '<STR_LIT:POST>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> raise NotImplementedError ( <EOL> '<STR_LIT>' % method ) <EOL> if path [ <NUM_LIT:0> ] == '<STR_LIT:/>' : <EOL> uri = self . url + path <EOL> else : <EOL> uri = self . url + '<STR_LIT:/>' + path <EOL> if APPENGINE : <EOL> return json . loads ( self . _appengine_fetch ( uri , data , method ) ) <EOL> return json . loads ( self . _urllib2_fetch ( uri , data , method ) ) <EOL> def reload_config ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def reload_cache_config ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def call ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def bulk_call ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def group_call ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def transfer_call ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def hangup_all_calls ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method ) <EOL> def hangup_call ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def schedule_hangup ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def cancel_scheduled_hangup ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def record_start ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def record_stop ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def conference_mute ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def play ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def play_stop ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def schedule_play ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def cancel_scheduled_play ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def sound_touch ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def sound_touch_stop ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def send_digits ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def conference_unmute ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def conference_kick ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def conference_hangup ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def conference_deaf ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def conference_undeaf ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def conference_record_start ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def conference_record_stop ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def conference_play ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def conference_speak ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def conference_list ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> def conference_list_members ( self , call_params ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = '<STR_LIT:/>' + self . api_version + '<STR_LIT>' <EOL> method = '<STR_LIT:POST>' <EOL> return self . request ( path , method , call_params ) <EOL> class Element ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> VALID_ATTRS = ( ) <EOL> def __init__ ( self , ** kwargs ) : <EOL> self . name = self . __class__ . __name__ <EOL> self . body = None <EOL> self . nestables = ( ) <EOL> self . elements = [ ] <EOL> self . attrs = { } <EOL> for k , v in kwargs . items ( ) : <EOL> if k == \"<STR_LIT>\" : <EOL> k = \"<STR_LIT>\" <EOL> self . _is_valid_attribute ( k ) <EOL> v = Element . bool2txt ( v ) <EOL> if v is not None : <EOL> self . attrs [ k ] = unicode ( v ) <EOL> def _is_valid_attribute ( self , attr ) : <EOL> if not attr in self . VALID_ATTRS : <EOL> raise PlivoException ( \"<STR_LIT>\" % ( attr , self . name ) ) <EOL> @ staticmethod <EOL> def bool2txt ( var ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if var is True : <EOL> return '<STR_LIT:true>' <EOL> elif var is False : <EOL> return '<STR_LIT:false>' <EOL> return var <EOL> def __repr__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> doc = Document ( ) <EOL> return self . _xml ( doc ) . toxml ( ) <EOL> def _xml ( self , root ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> element = root . createElement ( self . name ) <EOL> keys = self . attrs . keys ( ) <EOL> keys . sort ( ) <EOL> for a in keys : <EOL> element . setAttribute ( a , self . attrs [ a ] ) <EOL> if self . body : <EOL> text = root . createTextNode ( self . body ) <EOL> element . appendChild ( text ) <EOL> for c in self . elements : <EOL> element . appendChild ( c . _xml ( root ) ) <EOL> return element <EOL> @ staticmethod <EOL> def check_post_get_method ( method = None ) : <EOL> if not method in ( '<STR_LIT:GET>' , '<STR_LIT:POST>' ) : <EOL> raise PlivoException ( \"<STR_LIT>\" ) <EOL> def append ( self , element ) : <EOL> if not self . nestables : <EOL> raise PlivoException ( \"<STR_LIT>\" % self . name ) <EOL> if not element . name in self . nestables : <EOL> raise PlivoException ( \"<STR_LIT>\" % ( element . name , self . name ) ) <EOL> self . elements . append ( element ) <EOL> return element <EOL> def asUrl ( self ) : <EOL> return urllib . quote ( str ( self ) ) <EOL> def addSpeak ( self , text , ** kwargs ) : <EOL> return self . append ( Speak ( text , ** kwargs ) ) <EOL> def addPlay ( self , url , ** kwargs ) : <EOL> return self . append ( Play ( url , ** kwargs ) ) <EOL> def addWait ( self , ** kwargs ) : <EOL> return self . append ( Wait ( ** kwargs ) ) <EOL> def addRedirect ( self , url = None , ** kwargs ) : <EOL> return self . append ( Redirect ( url , ** kwargs ) ) <EOL> def addNotify ( self , url = None , ** kwargs ) : <EOL> return self . append ( Notify ( url , ** kwargs ) ) <EOL> def addSIPTransfer ( self , url = None , ** kwargs ) : <EOL> return self . append ( SIPTransfer ( url , ** kwargs ) ) <EOL> def addHangup ( self , ** kwargs ) : <EOL> return self . append ( Hangup ( ** kwargs ) ) <EOL> def addGetDigits ( self , ** kwargs ) : <EOL> return self . append ( GetDigits ( ** kwargs ) ) <EOL> def addGetSpeech ( self , ** kwargs ) : <EOL> return self . append ( GetSpeech ( ** kwargs ) ) <EOL> def addNumber ( self , number , ** kwargs ) : <EOL> return self . append ( Number ( number , ** kwargs ) ) <EOL> def addDial ( self , ** kwargs ) : <EOL> return self . append ( Dial ( ** kwargs ) ) <EOL> def addRecord ( self , ** kwargs ) : <EOL> return self . append ( Record ( ** kwargs ) ) <EOL> def addConference ( self , name , ** kwargs ) : <EOL> return self . append ( Conference ( name , ** kwargs ) ) <EOL> def addPreAnswer ( self , ** kwargs ) : <EOL> return self . append ( PreAnswer ( ** kwargs ) ) <EOL> class Response ( Element ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> VALID_ATTRS = ( ) <EOL> def __init__ ( self ) : <EOL> Element . __init__ ( self ) <EOL> self . nestables = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> class Speak ( Element ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "VALID_ATTRS = ( '<STR_LIT>' , '<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import unittest <EOL> import sys <EOL> from StringIO import StringIO <EOL> from fms . utils import CSVDELIMITERS <EOL> from fms . utils . parsers import YamlParamsParser , XmlParamsParser <EOL> from fms . utils . exceptions import MissingParameter <EOL> class YamlParserTests ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . fixturesdir = \"<STR_LIT>\" <EOL> def testExperimentNameDefaultValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT:name>' ] , '<STR_LIT>' % <EOL> self . fixturesdir ) <EOL> def testExperimentNameValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT:name>' ] , '<STR_LIT>' ) <EOL> def testUniqueByAgentDefaultValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertTrue ( params [ '<STR_LIT>' ] ) <EOL> def testCsvDelimiterDefaultValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT>' ] , '<STR_LIT:;>' ) <EOL> def testRandomseedDefaultValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT>' ] , None ) <EOL> def testRandomSeedValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT>' ] , <NUM_LIT> ) <EOL> def testOutputfileDefaultValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> def testOuputfileValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' % self . fixturesdir ) <EOL> def testOrdersLogFileDefaultValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT>' ] , None ) <EOL> def testOrderLogFileValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' % self . fixturesdir ) <EOL> def testWorldMandatory ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> self . assertRaises ( MissingParameter , YamlParamsParser , <EOL> ymlparamsfile ) <EOL> def testWorldClassValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT>' ] [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> def testOneEngineMandatory ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> self . assertRaises ( MissingParameter , YamlParamsParser , <EOL> ymlparamsfile ) <EOL> def testEngineClassValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' ) <EOL> def testDaysDefaultValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , <NUM_LIT:1> ) <EOL> def testDaysValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , <NUM_LIT:2> ) <EOL> def testClearBooksAtEODDefaultValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertTrue ( params [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] ) <EOL> def testClearBooksAtEODValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertFalse ( params [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] ) <EOL> def testDaylengthDefaultValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , <NUM_LIT:1> ) <EOL> def testDaylengthValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> params = YamlParamsParser ( ymlparamsfile ) <EOL> self . assertEqual ( params [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT>' ] , <NUM_LIT:10> ) <EOL> def testMarketMandatory ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL> self . assertRaises ( MissingParameter , YamlParamsParser , <EOL> ymlparamsfile ) <EOL> def testMarketClassValue ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ymlparamsfile = '<STR_LIT>' % self . fixturesdir <EOL>", "answer": "params = YamlParamsParser ( ymlparamsfile )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> from __future__ import print_function <EOL> from __future__ import division <EOL> from __future__ import unicode_literals <EOL> import os <EOL> import threading <EOL> import subprocess <EOL> import re <EOL> import time <EOL> from . import base <EOL> from . import arduino_info <EOL> from . import arduino_target_params <EOL> from . import arduino_project <EOL> from . import arduino_src <EOL>", "answer": "class Compiler ( object ) :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> import copy <EOL> import math <EOL> import re <EOL> import time <EOL> import types <EOL> try : <EOL> from BaseHTTPServer import BaseHTTPRequestHandler <EOL> except ImportError : <EOL> unicode = str <EOL> from functools import wraps <EOL> from threading import Lock <EOL> _METRIC_NAME_RE = re . compile ( r'<STR_LIT>' ) <EOL> _METRIC_LABEL_NAME_RE = re . compile ( r'<STR_LIT>' ) <EOL> _RESERVED_METRIC_LABEL_NAME_RE = re . compile ( r'<STR_LIT>' ) <EOL> _INF = float ( \"<STR_LIT>\" ) <EOL> _MINUS_INF = float ( \"<STR_LIT>\" ) <EOL> class CollectorRegistry ( object ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self ) : <EOL> self . _collectors = set ( ) <EOL> self . _lock = Lock ( ) <EOL> def register ( self , collector ) : <EOL> '''<STR_LIT>''' <EOL> with self . _lock : <EOL> self . _collectors . add ( collector ) <EOL> def unregister ( self , collector ) : <EOL> '''<STR_LIT>''' <EOL> with self . _lock : <EOL> self . _collectors . remove ( collector ) <EOL> def collect ( self ) : <EOL> '''<STR_LIT>''' <EOL> collectors = None <EOL> with self . _lock : <EOL> collectors = copy . copy ( self . _collectors ) <EOL> for collector in collectors : <EOL> for metric in collector . collect ( ) : <EOL> yield metric <EOL> def get_sample_value ( self , name , labels = None ) : <EOL> '''<STR_LIT>''' <EOL> if labels is None : <EOL> labels = { } <EOL> for metric in self . collect ( ) : <EOL> for n , l , value in metric . samples : <EOL> if n == name and l == labels : <EOL> return value <EOL> return None <EOL> REGISTRY = CollectorRegistry ( ) <EOL> '''<STR_LIT>''' <EOL> _METRIC_TYPES = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> class Metric ( object ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , name , documentation , typ ) : <EOL> self . name = name <EOL> self . documentation = documentation <EOL> if typ not in _METRIC_TYPES : <EOL> raise ValueError ( '<STR_LIT>' + typ ) <EOL> self . type = typ <EOL> self . samples = [ ] <EOL> def add_sample ( self , name , labels , value ) : <EOL> '''<STR_LIT>''' <EOL> self . samples . append ( ( name , labels , value ) ) <EOL> def __eq__ ( self , other ) : <EOL> return ( isinstance ( other , Metric ) <EOL> and self . name == other . name <EOL> and self . documentation == other . documentation <EOL> and self . type == other . type <EOL> and self . samples == other . samples ) <EOL> class CounterMetricFamily ( Metric ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , name , documentation , value = None , labels = None ) : <EOL> Metric . __init__ ( self , name , documentation , '<STR_LIT>' ) <EOL> if labels is not None and value is not None : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> if labels is None : <EOL> labels = [ ] <EOL> self . _labelnames = labels <EOL> if value is not None : <EOL> self . add_metric ( [ ] , value ) <EOL> def add_metric ( self , labels , value ) : <EOL> '''<STR_LIT>''' <EOL> self . samples . append ( ( self . name , dict ( zip ( self . _labelnames , labels ) ) , value ) ) <EOL> class GaugeMetricFamily ( Metric ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , name , documentation , value = None , labels = None ) : <EOL> Metric . __init__ ( self , name , documentation , '<STR_LIT>' ) <EOL> if labels is not None and value is not None : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> if labels is None : <EOL> labels = [ ] <EOL> self . _labelnames = labels <EOL> if value is not None : <EOL> self . add_metric ( [ ] , value ) <EOL> def add_metric ( self , labels , value ) : <EOL> '''<STR_LIT>''' <EOL> self . samples . append ( ( self . name , dict ( zip ( self . _labelnames , labels ) ) , value ) ) <EOL> class SummaryMetricFamily ( Metric ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , name , documentation , count_value = None , sum_value = None , labels = None ) : <EOL> Metric . __init__ ( self , name , documentation , '<STR_LIT>' ) <EOL> if ( sum_value is None ) != ( count_value is None ) : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> if labels is not None and count_value is not None : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> if labels is None : <EOL> labels = [ ] <EOL> self . _labelnames = labels <EOL> if count_value is not None : <EOL> self . add_metric ( [ ] , count_value , sum_value ) <EOL> def add_metric ( self , labels , count_value , sum_value ) : <EOL> '''<STR_LIT>''' <EOL> self . samples . append ( ( self . name + '<STR_LIT>' , dict ( zip ( self . _labelnames , labels ) ) , count_value ) ) <EOL> self . samples . append ( ( self . name + '<STR_LIT>' , dict ( zip ( self . _labelnames , labels ) ) , sum_value ) ) <EOL> class HistogramMetricFamily ( Metric ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , name , documentation , buckets = None , sum_value = None , labels = None ) : <EOL> Metric . __init__ ( self , name , documentation , '<STR_LIT>' ) <EOL> if ( sum_value is None ) != ( buckets is None ) : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> if labels is not None and buckets is not None : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> if labels is None : <EOL> labels = [ ] <EOL> self . _labelnames = labels <EOL> if buckets is not None : <EOL> self . add_metric ( [ ] , buckets , sum_value ) <EOL> def add_metric ( self , labels , buckets , sum_value ) : <EOL> '''<STR_LIT>''' <EOL> for bucket , value in buckets : <EOL> self . samples . append ( ( self . name + '<STR_LIT>' , dict ( list ( zip ( self . _labelnames , labels ) ) + [ ( '<STR_LIT>' , bucket ) ] ) , value ) ) <EOL> self . samples . append ( ( self . name + '<STR_LIT>' , dict ( zip ( self . _labelnames , labels ) ) , buckets [ - <NUM_LIT:1> ] [ <NUM_LIT:1> ] ) ) <EOL> self . samples . append ( ( self . name + '<STR_LIT>' , dict ( zip ( self . _labelnames , labels ) ) , sum_value ) ) <EOL> class _MutexValue ( object ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , name , labelnames , labelvalues ) : <EOL> self . _value = <NUM_LIT:0.0> <EOL> self . _lock = Lock ( ) <EOL> def inc ( self , amount ) : <EOL> with self . _lock : <EOL> self . _value += amount <EOL> def set ( self , value ) : <EOL> with self . _lock : <EOL> self . _value = value <EOL> def get ( self ) : <EOL> with self . _lock : <EOL> return self . _value <EOL> _ValueClass = _MutexValue <EOL> class _LabelWrapper ( object ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , wrappedClass , name , labelnames , ** kwargs ) : <EOL> self . _wrappedClass = wrappedClass <EOL> self . _type = wrappedClass . _type <EOL> self . _name = name <EOL> self . _labelnames = labelnames <EOL> self . _kwargs = kwargs <EOL> self . _lock = Lock ( ) <EOL> self . _metrics = { } <EOL> for l in labelnames : <EOL> if l . startswith ( '<STR_LIT>' ) : <EOL> raise ValueError ( '<STR_LIT>' + l ) <EOL> def labels ( self , * labelvalues ) : <EOL> '''<STR_LIT>''' <EOL> if len ( labelvalues ) == <NUM_LIT:1> and type ( labelvalues [ <NUM_LIT:0> ] ) == dict : <EOL> if sorted ( labelvalues [ <NUM_LIT:0> ] . keys ( ) ) != sorted ( self . _labelnames ) : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> labelvalues = tuple ( [ unicode ( labelvalues [ <NUM_LIT:0> ] [ l ] ) for l in self . _labelnames ] ) <EOL> else : <EOL> if len ( labelvalues ) != len ( self . _labelnames ) : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> labelvalues = tuple ( [ unicode ( l ) for l in labelvalues ] ) <EOL> with self . _lock : <EOL> if labelvalues not in self . _metrics : <EOL> self . _metrics [ labelvalues ] = self . _wrappedClass ( self . _name , self . _labelnames , labelvalues , ** self . _kwargs ) <EOL> return self . _metrics [ labelvalues ] <EOL> def remove ( self , * labelvalues ) : <EOL> '''<STR_LIT>''' <EOL> if len ( labelvalues ) != len ( self . _labelnames ) : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> labelvalues = tuple ( [ unicode ( l ) for l in labelvalues ] ) <EOL> with self . _lock : <EOL> del self . _metrics [ labelvalues ] <EOL> def _samples ( self ) : <EOL> with self . _lock : <EOL> metrics = self . _metrics . copy ( ) <EOL> for labels , metric in metrics . items ( ) : <EOL> series_labels = list ( dict ( zip ( self . _labelnames , labels ) ) . items ( ) ) <EOL> for suffix , sample_labels , value in metric . _samples ( ) : <EOL> yield ( suffix , dict ( series_labels + list ( sample_labels . items ( ) ) ) , value ) <EOL> def _MetricWrapper ( cls ) : <EOL> '''<STR_LIT>''' <EOL> def init ( name , documentation , labelnames = ( ) , namespace = '<STR_LIT>' , subsystem = '<STR_LIT>' , registry = REGISTRY , ** kwargs ) : <EOL> full_name = '<STR_LIT>' <EOL> if namespace : <EOL> full_name += namespace + '<STR_LIT:_>' <EOL> if subsystem : <EOL> full_name += subsystem + '<STR_LIT:_>' <EOL> full_name += name <EOL> if labelnames : <EOL> labelnames = tuple ( labelnames ) <EOL> for l in labelnames : <EOL> if not _METRIC_LABEL_NAME_RE . match ( l ) : <EOL> raise ValueError ( '<STR_LIT>' + l ) <EOL> if _RESERVED_METRIC_LABEL_NAME_RE . match ( l ) : <EOL> raise ValueError ( '<STR_LIT>' + l ) <EOL> if l in cls . _reserved_labelnames : <EOL> raise ValueError ( '<STR_LIT>' + l ) <EOL> collector = _LabelWrapper ( cls , name , labelnames , ** kwargs ) <EOL> else : <EOL> collector = cls ( name , labelnames , ( ) , ** kwargs ) <EOL> if not _METRIC_NAME_RE . match ( full_name ) : <EOL> raise ValueError ( '<STR_LIT>' + full_name ) <EOL> def collect ( ) : <EOL> metric = Metric ( full_name , documentation , cls . _type ) <EOL> for suffix , labels , value in collector . _samples ( ) : <EOL> metric . add_sample ( full_name + suffix , labels , value ) <EOL> return [ metric ] <EOL> collector . collect = collect <EOL> if registry : <EOL> registry . register ( collector ) <EOL> return collector <EOL> return init <EOL> @ _MetricWrapper <EOL> class Counter ( object ) : <EOL> '''<STR_LIT>''' <EOL> _type = '<STR_LIT>' <EOL> _reserved_labelnames = [ ] <EOL> def __init__ ( self , name , labelnames , labelvalues ) : <EOL> self . _value = _ValueClass ( name , labelnames , labelvalues ) <EOL> def inc ( self , amount = <NUM_LIT:1> ) : <EOL> '''<STR_LIT>''' <EOL> if amount < <NUM_LIT:0> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL>", "answer": "self . _value . inc ( amount )"}, {"prompt": "<s> import itertools <EOL> import sys <EOL> import unittest <EOL> def _gen_case ( base , module , i , param ) : <EOL> cls_name = '<STR_LIT>' % ( base . __name__ , i ) <EOL> def __str__ ( self ) : <EOL>", "answer": "name = base . __str__ ( self )"}, {"prompt": "<s> from __future__ import print_function <EOL> import json <EOL> import sys <EOL> import re <EOL> import contextlib <EOL> import random <EOL> import string <EOL> import httpretty <EOL> import pytest <EOL> import uritemplate <EOL> import restnavigator . halnav as HN <EOL> from restnavigator . exc import HALNavigatorError , UnexpectedlyNotJSON <EOL> @ pytest . fixture ( ) <EOL> def random_string ( ) : <EOL> def rs ( ) : <EOL> while True : <EOL> yield '<STR_LIT>' . join ( random . sample ( string . ascii_letters , <NUM_LIT:6> ) ) <EOL> return rs ( ) <EOL> @ contextlib . contextmanager <EOL> def httprettify ( ) : <EOL> '''<STR_LIT>''' <EOL> httpretty . HTTPretty . reset ( ) <EOL> httpretty . HTTPretty . enable ( ) <EOL> try : <EOL> yield httpretty . HTTPretty <EOL> finally : <EOL> httpretty . HTTPretty . disable ( ) <EOL> def register_hal ( uri = '<STR_LIT>' , <EOL> links = None , <EOL> state = None , <EOL> title = None , <EOL> method = '<STR_LIT:GET>' , <EOL> headers = None , <EOL> status = <NUM_LIT:200> , <EOL> ) : <EOL> '''<STR_LIT>''' <EOL> def body_callback ( _meth , req_uri , req_headers ) : <EOL> '''<STR_LIT>''' <EOL> _links = links . copy ( ) if links is not None else { } <EOL> _state = state . copy ( ) if state is not None else { } <EOL> if headers is not None : <EOL> resp_headers = headers . copy ( ) <EOL> else : <EOL> resp_headers = { } <EOL> if req_headers is not None : <EOL> resp_headers . update ( req_headers ) <EOL> resp_headers . update ( { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> _links . update ( { '<STR_LIT>' : { '<STR_LIT>' : req_uri } } ) <EOL> if title is not None : <EOL> _links [ '<STR_LIT>' ] [ '<STR_LIT:title>' ] = title <EOL> _state . update ( { '<STR_LIT>' : _links } ) <EOL> return status , resp_headers , json . dumps ( _state ) <EOL> httpretty . HTTPretty . register_uri ( method = method , <EOL> body = body_callback , <EOL> content_type = '<STR_LIT>' , <EOL> uri = uri ) <EOL> def test_HALNavigator__creation ( ) : <EOL> N = HN . Navigator . hal ( '<STR_LIT>' ) <EOL> assert type ( N ) == HN . HALNavigator <EOL> assert repr ( N ) == \"<STR_LIT>\" <EOL> @ pytest . mark . parametrize ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , False ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , False ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , True ) , <EOL> ] ) <EOL> def test_HALNavigator__eq__ ( name1 , uri1 , name2 , uri2 , equal ) : <EOL> N1 = HN . Navigator . hal ( uri1 , apiname = name1 ) <EOL> N2 = HN . Navigator . hal ( uri2 , apiname = name2 ) <EOL> if equal : <EOL> assert N1 == N2 <EOL> assert N2 == N1 <EOL> else : <EOL> assert N1 != N2 <EOL> assert N2 != N1 <EOL> def test_HALNavigator__eq__nonnav ( ) : <EOL> N = HN . Navigator . hal ( '<STR_LIT>' ) <EOL> assert N != '<STR_LIT>' <EOL> assert '<STR_LIT>' != N <EOL> def test_HALNAvigator__repr ( ) : <EOL>", "answer": "with httprettify ( ) :"}, {"prompt": "<s> from south . utils import datetime_utils as datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . delete_column ( u'<STR_LIT>' , '<STR_LIT>' ) <EOL> db . delete_column ( u'<STR_LIT>' , '<STR_LIT>' ) <EOL> db . delete_column ( u'<STR_LIT>' , '<STR_LIT>' ) <EOL> def backwards ( self , orm ) : <EOL> db . add_column ( u'<STR_LIT>' , '<STR_LIT>' , <EOL> self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT:100> , null = True , blank = True ) , <EOL> keep_default = False ) <EOL> db . add_column ( u'<STR_LIT>' , '<STR_LIT>' , <EOL> self . gf ( '<STR_LIT>' ) ( to = orm [ '<STR_LIT>' ] , null = True , blank = True ) , <EOL> keep_default = False ) <EOL> db . add_column ( u'<STR_LIT>' , '<STR_LIT>' , <EOL> self . gf ( '<STR_LIT>' ) ( default = <NUM_LIT:4> , blank = True ) , <EOL> keep_default = False ) <EOL> models = { <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : u\"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : u\"<STR_LIT>\" } ) , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:to>' : u\"<STR_LIT>\" } ) , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:password>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:related_name>' : \"<STR_LIT>\" , '<STR_LIT:blank>' : '<STR_LIT:True>' , '<STR_LIT:to>' : u\"<STR_LIT>\" } ) , <EOL> '<STR_LIT:username>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' , '<STR_LIT>' : \"<STR_LIT>\" } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) <EOL> } , <EOL> u'<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { } ) , <EOL> '<STR_LIT:description>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT:file>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL>", "answer": "u'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import collections <EOL> from bagpipe . exabgp . structure . address import AFI , SAFI <EOL> from bagpipe . exabgp . structure . asn import AS_TRANS <EOL> from bagpipe . exabgp . message . update . attribute import AttributeID <EOL> from bagpipe . exabgp . message . update . attribute . origin import Origin <EOL> from bagpipe . exabgp . message . update . attribute . aspath import ASPath , AS4Path <EOL> from bagpipe . exabgp . message . update . attribute . localpref import LocalPreference <EOL> class MultiAttributes ( list ) : <EOL> def __init__ ( self , attribute ) : <EOL> list . __init__ ( self ) <EOL> self . ID = attribute . ID <EOL> self . FLAG = attribute . FLAG <EOL> self . MULTIPLE = True <EOL> self . append ( attribute ) <EOL> def pack ( self ) : <EOL> r = [ ] <EOL> for attribute in self : <EOL> r . append ( attribute . pack ( ) ) <EOL> return '<STR_LIT>' . join ( r ) <EOL> def __len__ ( self ) : <EOL> return len ( self . pack ( ) ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT:U+0020>' . join ( str ( _ ) for _ in self ) <EOL> def __repr__ ( self ) : <EOL> return str ( self ) <EOL> class Attributes ( dict ) : <EOL> autocomplete = True <EOL> def __init__ ( self ) : <EOL> self . _str = '<STR_LIT>' <EOL> def has ( self , k ) : <EOL> return self . has_key ( k ) <EOL> def add ( self , attribute ) : <EOL> self . _str = '<STR_LIT>' <EOL> if self . has ( attribute . ID ) : <EOL> if attribute . MULTIPLE : <EOL> self [ attribute . ID ] . append ( attribute ) <EOL> return True <EOL> return False <EOL> else : <EOL> if attribute . MULTIPLE : <EOL> self [ attribute . ID ] = MultiAttributes ( attribute ) <EOL> else : <EOL> self [ attribute . ID ] = attribute <EOL> return True <EOL> def remove ( self , attrid ) : <EOL> self . pop ( attrid ) <EOL> def _as_path ( self , asn4 , asp ) : <EOL> message = '<STR_LIT>' <EOL> if not asn4 : <EOL> has_asn4 = False <EOL> aspath = ASPath ( False , asp . asptype ) <EOL> as4path = AS4Path ( asp . asptype ) <EOL> for segment in asp . aspsegment : <EOL> if segment . asn4 ( ) : <EOL> has_asn4 = True <EOL> aspath . add ( AS_TRANS ) <EOL> as4path . add ( segment ) <EOL> else : <EOL> aspath . add ( segment ) <EOL> as4path . add ( segment ) <EOL> message += aspath . pack ( ) <EOL> if has_asn4 : <EOL> message += as4path . pack ( ) <EOL> else : <EOL> message += ASPath ( True , asp . asptype , asp . aspsegment ) . pack ( ) <EOL> return message <EOL>", "answer": "def bgp_announce ( self , asn4 , local_asn , peer_asn ) :"}, {"prompt": "<s> import sublime , sublime_plugin <EOL>", "answer": "_TRANSITION_CURSOR_SCOPE_TYPE = '<STR_LIT>'"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function , division <EOL> from sympy import Symbol , Tuple , Mul , sympify , default_sort_key <EOL> from sympy . utilities import numbered_symbols <EOL> from sympy . core . compatibility import reduce <EOL> from sympy . physics . quantum . gate import Gate <EOL> __all__ = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> def kmp_table ( word ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pos = <NUM_LIT:2> <EOL> cnd = <NUM_LIT:0> <EOL> table = list ( ) <EOL> table . append ( - <NUM_LIT:1> ) <EOL> table . append ( <NUM_LIT:0> ) <EOL> while pos < len ( word ) : <EOL> if word [ pos - <NUM_LIT:1> ] == word [ cnd ] : <EOL> cnd = cnd + <NUM_LIT:1> <EOL> table . append ( cnd ) <EOL> pos = pos + <NUM_LIT:1> <EOL> elif cnd > <NUM_LIT:0> : <EOL> cnd = table [ cnd ] <EOL> else : <EOL> table . append ( <NUM_LIT:0> ) <EOL> pos = pos + <NUM_LIT:1> <EOL> return table <EOL> def find_subcircuit ( circuit , subcircuit , start = <NUM_LIT:0> , end = <NUM_LIT:0> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( circuit , Mul ) : <EOL> circuit = circuit . args <EOL> if isinstance ( subcircuit , Mul ) : <EOL> subcircuit = subcircuit . args <EOL> if len ( subcircuit ) == <NUM_LIT:0> or len ( subcircuit ) > len ( circuit ) : <EOL> return - <NUM_LIT:1> <EOL> if end < <NUM_LIT:1> : <EOL> end = len ( circuit ) <EOL> pos = start <EOL> index = <NUM_LIT:0> <EOL> table = kmp_table ( subcircuit ) <EOL> while ( pos + index ) < end : <EOL> if subcircuit [ index ] == circuit [ pos + index ] : <EOL> index = index + <NUM_LIT:1> <EOL> else : <EOL> pos = pos + index - table [ index ] <EOL> index = table [ index ] if table [ index ] > - <NUM_LIT:1> else <NUM_LIT:0> <EOL> if index == len ( subcircuit ) : <EOL> return pos <EOL> return - <NUM_LIT:1> <EOL> def replace_subcircuit ( circuit , subcircuit , replace = None , pos = <NUM_LIT:0> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if pos < <NUM_LIT:0> : <EOL> pos = <NUM_LIT:0> <EOL> if isinstance ( circuit , Mul ) : <EOL> circuit = circuit . args <EOL> if isinstance ( subcircuit , Mul ) : <EOL> subcircuit = subcircuit . args <EOL> if isinstance ( replace , Mul ) : <EOL> replace = replace . args <EOL> elif replace is None : <EOL> replace = ( ) <EOL> loc = find_subcircuit ( circuit , subcircuit , start = pos ) <EOL> if loc > - <NUM_LIT:1> : <EOL> left = circuit [ <NUM_LIT:0> : loc ] <EOL> right = circuit [ loc + len ( subcircuit ) : len ( circuit ) ] <EOL> circuit = left + replace + right <EOL> return circuit <EOL>", "answer": "def _sympify_qubit_map ( mapping ) :"}, {"prompt": "<s> for x in y . keys ( ) : <EOL>", "answer": "pass "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import datetime <EOL> import decimal <EOL> from django . conf import settings <EOL> from django . contrib . auth . models import AnonymousUser <EOL> from django . contrib . auth import get_user_model <EOL> from django . core . exceptions import ImproperlyConfigured <EOL> from django . test import TestCase <EOL> from django . test . utils import override_settings <EOL> from django . utils import timezone <EOL> from djstripe . models import convert_tstamp , Customer , CurrentSubscription <EOL> from djstripe . utils import subscriber_has_active_subscription , get_supported_currency_choices <EOL> from unittest . case import SkipTest <EOL> from unittest2 import TestCase as AssertWarnsEnabledTestCase <EOL> from mock import patch <EOL> from stripe import api_key <EOL> from tests . apps . testapp . models import Organization <EOL> class TestDeprecationWarning ( AssertWarnsEnabledTestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . user = get_user_model ( ) . objects . create_user ( username = \"<STR_LIT>\" , <EOL> email = \"<STR_LIT>\" ) <EOL> self . customer = Customer . objects . create ( <EOL> subscriber = self . user , <EOL> stripe_id = \"<STR_LIT>\" , <EOL> card_fingerprint = \"<STR_LIT>\" , <EOL> card_last_4 = \"<STR_LIT>\" , <EOL> card_kind = \"<STR_LIT>\" <EOL> ) <EOL> def test_deprecation ( self ) : <EOL> with self . assertWarns ( DeprecationWarning ) : <EOL> from djstripe . utils import user_has_active_subscription <EOL> user_has_active_subscription ( self . user ) <EOL> class TestTimestampConversion ( TestCase ) : <EOL> def test_conversion_without_field_name ( self ) : <EOL> stamp = convert_tstamp ( <NUM_LIT> ) <EOL> self . assertEquals ( <EOL> stamp , <EOL> datetime . datetime ( <NUM_LIT> , <NUM_LIT:4> , <NUM_LIT:10> , <NUM_LIT:4> , <NUM_LIT:16> , <NUM_LIT> , tzinfo = timezone . utc ) <EOL> ) <EOL> def test_conversion_with_field_name ( self ) : <EOL> stamp = convert_tstamp ( { \"<STR_LIT>\" : <NUM_LIT> } , \"<STR_LIT>\" ) <EOL> self . assertEquals ( <EOL> stamp , <EOL> datetime . datetime ( <NUM_LIT> , <NUM_LIT:4> , <NUM_LIT:10> , <NUM_LIT:4> , <NUM_LIT:16> , <NUM_LIT> , tzinfo = timezone . utc ) <EOL> ) <EOL> def test_conversion_with_invalid_field_name ( self ) : <EOL> stamp = convert_tstamp ( { \"<STR_LIT>\" : <NUM_LIT> } , \"<STR_LIT:foo>\" ) <EOL> self . assertEquals ( <EOL> stamp , <EOL> None <EOL> ) <EOL> @ override_settings ( USE_TZ = False ) <EOL> def test_conversion_without_field_name_no_tz ( self ) : <EOL> if settings . DJSTRIPE_TESTS_SKIP_UTC : <EOL> raise SkipTest ( \"<STR_LIT>\" ) <EOL> stamp = convert_tstamp ( <NUM_LIT> ) <EOL> self . assertEquals ( <EOL> stamp , <EOL> datetime . datetime ( <NUM_LIT> , <NUM_LIT:4> , <NUM_LIT:10> , <NUM_LIT:4> , <NUM_LIT:16> , <NUM_LIT> ) , <EOL> \"<STR_LIT>\" <EOL> ) <EOL> @ override_settings ( USE_TZ = False ) <EOL> def test_conversion_with_field_name_no_tz ( self ) : <EOL> if settings . DJSTRIPE_TESTS_SKIP_UTC : <EOL> raise SkipTest ( \"<STR_LIT>\" ) <EOL> stamp = convert_tstamp ( { \"<STR_LIT>\" : <NUM_LIT> } , \"<STR_LIT>\" ) <EOL> self . assertEquals ( <EOL> stamp , <EOL>", "answer": "datetime . datetime ( <NUM_LIT> , <NUM_LIT:4> , <NUM_LIT:10> , <NUM_LIT:4> , <NUM_LIT:16> , <NUM_LIT> ) ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> __copyright__ = '<STR_LIT>' <EOL> __license__ = '<STR_LIT>' <EOL> import sys , json <EOL> dbfile , topurl = sys . argv [ <NUM_LIT:1> : <NUM_LIT:3> ] <EOL> from datagit . db import load_db , save_db <EOL> db = load_db ( dbfile , allow_unsupported = True ) <EOL> assert ( db [ '<STR_LIT:version>' ] == '<STR_LIT>' ) <EOL> db_incoming = db . pop ( '<STR_LIT>' ) <EOL> db_public_incoming = db . pop ( '<STR_LIT>' ) <EOL> for k , v in db_incoming . iteritems ( ) : <EOL> v [ '<STR_LIT:url>' ] = \"<STR_LIT>\" % ( topurl , k ) <EOL>", "answer": "db_new = { '<STR_LIT>' : db_incoming ,"}, {"prompt": "<s> import sys <EOL> import django <EOL> from django . conf import settings , global_settings as default_settings <EOL> from django . core . management import execute_from_command_line <EOL>", "answer": "from os import path"}, {"prompt": "<s> import floppyforms as forms <EOL> from django . conf import settings <EOL> class FileManagerWidget ( forms . TextInput ) : <EOL>", "answer": "template_name = '<STR_LIT>'"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import functools <EOL> import collections <EOL> def iter_args ( function ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ functools . wraps ( function ) <EOL>", "answer": "def wrapper ( * args , ** kwargs ) :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Building ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL>", "answer": "result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "<s> import types <EOL> import yaml <EOL> from pseudo . pseudo_tree import Node <EOL> def load_input ( filename ) : <EOL> try : <EOL> with open ( filename ) as f : <EOL> intermediate_code = f . read ( ) <EOL> except ( OSError , IOError ) as e : <EOL> print ( \"<STR_LIT>\" % filename ) <EOL> exit ( <NUM_LIT:1> ) <EOL> return intermediate_code <EOL> def as_tree ( intermediate_code ) : <EOL> intermediate_code = yaml . load ( intermediate_code ) <EOL> return convert_to_syntax_tree ( intermediate_code ) <EOL> def convert_to_syntax_tree ( tree ) : <EOL> if isinstance ( tree , dict ) and '<STR_LIT:type>' in tree : <EOL> return Node ( tree [ '<STR_LIT:type>' ] , ** { k : convert_to_syntax_tree ( v ) for k , v in tree . items ( ) if k != '<STR_LIT:type>' } ) <EOL>", "answer": "elif isinstance ( tree , dict ) :"}, {"prompt": "<s> import datetime <EOL> import unittest2 as unittest <EOL> import iso8601 <EOL> import jsonpath_rw <EOL> import mock <EOL> import six <EOL> from stackdistiller import distiller <EOL> class TestCondenser ( object ) : <EOL> def __init__ ( self ) : <EOL> self . event_type = None <EOL> self . message_id = None <EOL> self . when = None <EOL> self . traits = [ ] <EOL> def add_trait ( self , name , trait_type , value ) : <EOL> self . traits . append ( distiller . Trait ( name , trait_type , value ) ) <EOL> def add_envelope_info ( self , event_type , message_id , when ) : <EOL> self . event_type = event_type <EOL> self . message_id = message_id <EOL> self . when = when <EOL> def get_event ( self ) : <EOL> return self <EOL> class DistillerTestBase ( unittest . TestCase ) : <EOL> def _create_test_notification ( self , event_type , message_id , ** kw ) : <EOL> return dict ( <EOL> event_type = event_type , <EOL> message_id = message_id , <EOL> priority = \"<STR_LIT>\" , <EOL> publisher_id = \"<STR_LIT>\" , <EOL> timestamp = \"<STR_LIT>\" , <EOL> payload = kw , <EOL> ) <EOL> def assertIsValidEvent ( self , event , notification ) : <EOL> self . assertIsNot ( <EOL> None , event , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % str ( notification ) ) <EOL> def assertIsNotValidEvent ( self , event , notification ) : <EOL> self . assertIs ( <EOL> None , event , <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % str ( notification ) ) <EOL> def assertHasTrait ( self , event , name , value = None , trait_type = None ) : <EOL> traits = [ trait for trait in event . traits if trait . name == name ] <EOL> self . assertTrue ( <EOL> len ( traits ) > <NUM_LIT:0> , <EOL> \"<STR_LIT>\" % ( name , event ) ) <EOL> trait = traits [ <NUM_LIT:0> ] <EOL> if value is not None : <EOL> self . assertEqual ( value , trait . value ) <EOL> if trait_type is not None : <EOL> self . assertEqual ( trait_type , trait . trait_type ) <EOL> if trait_type == distiller . Datatype . int : <EOL> self . assertIsInstance ( trait . value , int ) <EOL> elif trait_type == distiller . Datatype . float : <EOL> self . assertIsInstance ( trait . value , float ) <EOL> elif trait_type == distiller . Datatype . datetime : <EOL> self . assertIsInstance ( trait . value , datetime . datetime ) <EOL> elif trait_type == distiller . Datatype . text : <EOL> self . assertIsInstance ( trait . value , six . string_types ) <EOL> def assertDoesNotHaveTrait ( self , event , name ) : <EOL> traits = [ trait for trait in event . traits if trait . name == name ] <EOL> self . assertEqual ( <EOL> len ( traits ) , <NUM_LIT:0> , <EOL> \"<STR_LIT>\" % ( name , event ) ) <EOL> def assertHasDefaultTraits ( self , event ) : <EOL> text = distiller . Datatype . text <EOL> self . assertHasTrait ( event , '<STR_LIT>' , trait_type = text ) <EOL> def _cmp_tree ( self , this , other ) : <EOL> if hasattr ( this , '<STR_LIT:right>' ) and hasattr ( other , '<STR_LIT:right>' ) : <EOL> return ( self . _cmp_tree ( this . right , other . right ) and <EOL> self . _cmp_tree ( this . left , other . left ) ) <EOL> if not hasattr ( this , '<STR_LIT:right>' ) and not hasattr ( other , '<STR_LIT:right>' ) : <EOL> return this == other <EOL> return False <EOL> def assertPathsEqual ( self , path1 , path2 ) : <EOL> self . assertTrue ( self . _cmp_tree ( path1 , path2 ) , <EOL> '<STR_LIT>' % ( path1 , path2 ) ) <EOL> class TestTraitDefinition ( DistillerTestBase ) : <EOL> def setUp ( self ) : <EOL> super ( TestTraitDefinition , self ) . setUp ( ) <EOL> self . n1 = self . _create_test_notification ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> instance_uuid = \"<STR_LIT>\" , <EOL> instance_id = \"<STR_LIT>\" , <EOL> instance_uuid2 = None , <EOL> instance_id2 = None , <EOL> host = '<STR_LIT>' , <EOL> bogus_date = '<STR_LIT>' , <EOL> image_meta = dict ( <EOL> disk_gb = '<STR_LIT>' , <EOL> thing = '<STR_LIT>' ) , <EOL> foobar = <NUM_LIT:50> ) <EOL> self . test_plugin_class = mock . MagicMock ( name = '<STR_LIT>' ) <EOL> self . test_plugin = self . test_plugin_class ( ) <EOL> self . test_plugin . trait_value . return_value = '<STR_LIT>' <EOL> self . test_plugin_class . reset_mock ( ) <EOL> self . nothing_plugin_class = mock . MagicMock ( name = '<STR_LIT>' ) <EOL> self . nothing_plugin = self . nothing_plugin_class ( ) <EOL> self . nothing_plugin . trait_value . return_value = None <EOL> self . nothing_plugin_class . reset_mock ( ) <EOL> self . fake_plugin_map = dict ( test = self . test_plugin_class , <EOL> nothing = self . nothing_plugin_class ) <EOL> def test_bad_field_definition ( self ) : <EOL> self . assertRaises ( distiller . EventDefinitionException , <EOL> distiller . TraitDefinition , <EOL> '<STR_LIT>' , <EOL> \"<STR_LIT:foo>\" , <EOL> self . fake_plugin_map ) <EOL> def test_to_trait_with_plugin ( self ) : <EOL> cfg = dict ( type = '<STR_LIT:text>' , <EOL> fields = [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> plugin = dict ( name = '<STR_LIT:test>' ) ) <EOL> tdef = distiller . TraitDefinition ( '<STR_LIT>' , cfg , <EOL> self . fake_plugin_map ) <EOL> tname , trait_type , value = tdef . to_trait ( self . n1 ) <EOL> self . assertEqual ( '<STR_LIT>' , tname ) <EOL> self . assertEqual ( distiller . Datatype . text , trait_type ) <EOL> self . assertEqual ( '<STR_LIT>' , value ) <EOL> self . test_plugin_class . assert_called_once_with ( ) <EOL> self . test_plugin . trait_value . assert_called_once_with ( [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) ] ) <EOL> def test_to_trait_null_match_with_plugin ( self ) : <EOL> cfg = dict ( type = '<STR_LIT:text>' , <EOL>", "answer": "fields = [ '<STR_LIT>' , '<STR_LIT>' ] ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import grp <EOL> import os <EOL> import subprocess <EOL> import stat <EOL> class Error ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class RunExternalScriptError ( Error ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class ScriptNotFoundError ( RunExternalScriptError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class VerifyFilePermissionsError ( Error ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class InsecureFilePermissionsError ( VerifyFilePermissionsError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def verifyFileOnlyWritableByMunkiAndRoot ( file_path ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> file_stat = os . stat ( file_path ) <EOL> except OSError , err : <EOL> raise VerifyFilePermissionsError ( <EOL> '<STR_LIT>' % ( file_path , str ( err ) ) ) <EOL> try : <EOL> admin_gid = grp . getgrnam ( '<STR_LIT>' ) . gr_gid <EOL> wheel_gid = grp . getgrnam ( '<STR_LIT>' ) . gr_gid <EOL> user_gid = os . getegid ( ) <EOL> if os . geteuid ( ) != file_stat . st_uid : <EOL> raise InsecureFilePermissionsError ( <EOL> '<STR_LIT>' ) <EOL> elif file_stat . st_gid not in [ admin_gid , wheel_gid , user_gid ] : <EOL> raise InsecureFilePermissionsError ( <EOL> '<STR_LIT>' ) <EOL> elif file_stat . st_mode & stat . S_IWOTH != <NUM_LIT:0> : <EOL> raise InsecureFilePermissionsError ( '<STR_LIT>' ) <EOL> except InsecureFilePermissionsError , err : <EOL> raise InsecureFilePermissionsError ( <EOL> '<STR_LIT>' % ( file_path , err . args [ <NUM_LIT:0> ] ) ) <EOL> def runExternalScript ( script , allow_insecure = False , script_args = ( ) ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not os . path . exists ( script ) : <EOL> raise ScriptNotFoundError ( '<STR_LIT>' % script ) <EOL> if not allow_insecure : <EOL> try : <EOL> verifyFileOnlyWritableByMunkiAndRoot ( script ) <EOL> except VerifyFilePermissionsError , err : <EOL> msg = ( '<STR_LIT>' <EOL> '<STR_LIT>' % ( script , str ( err ) ) ) <EOL> raise RunExternalScriptError ( msg ) <EOL> if os . access ( script , os . X_OK ) : <EOL> cmd = [ script ] <EOL> if script_args : <EOL> cmd . extend ( script_args ) <EOL> proc = None <EOL> try : <EOL> proc = subprocess . Popen ( cmd , shell = False , <EOL> stdin = subprocess . PIPE , <EOL> stdout = subprocess . PIPE , <EOL> stderr = subprocess . PIPE ) <EOL> except ( OSError , IOError ) , err : <EOL> raise RunExternalScriptError ( <EOL> '<STR_LIT>' % ( unicode ( err ) , script ) ) <EOL> if proc : <EOL> ( stdout , stderr ) = proc . communicate ( ) <EOL> return proc . returncode , stdout . decode ( '<STR_LIT>' , '<STR_LIT:replace>' ) , stderr . decode ( '<STR_LIT>' , '<STR_LIT:replace>' ) <EOL> else : <EOL> raise RunExternalScriptError ( '<STR_LIT>' % script ) <EOL> def getPIDforProcessName ( processname ) : <EOL> '''<STR_LIT>''' <EOL> cmd = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> try : <EOL> proc = subprocess . Popen ( cmd , shell = False , bufsize = - <NUM_LIT:1> , <EOL> stdin = subprocess . PIPE , stdout = subprocess . PIPE , <EOL> stderr = subprocess . STDOUT ) <EOL> except OSError : <EOL>", "answer": "return <NUM_LIT:0>"}, {"prompt": "<s> from bepasty . storage . filesystem import Data <EOL> def test ( tmpdir ) : <EOL> p = tmpdir . join ( '<STR_LIT>' ) <EOL>", "answer": "d = Data ( p . open ( '<STR_LIT>' ) )"}, {"prompt": "<s> import datetime <EOL> from django . contrib . sites . managers import CurrentSiteManager <EOL> from lithium . conf import settings <EOL> class CurrentSitePostManager ( CurrentSiteManager ) : <EOL> def all ( self , allow_private = False ) : <EOL> queryset = self . get_query_set ( ) <EOL> if allow_private : <EOL> return queryset . all ( ) <EOL> else : <EOL> return queryset . filter ( is_public = True ) <EOL> def disallow_future ( self ) : <EOL>", "answer": "return self . all ( ) . filter ( pub_date__lte = datetime . datetime . now ( ) ) "}, {"prompt": "<s> from decimal import Decimal <EOL> import random <EOL> import datetime <EOL> from django . core . exceptions import ObjectDoesNotExist <EOL> from dimagi . utils . dates import add_months_to_date <EOL> from corehq . apps . sms . models import INCOMING , OUTGOING <EOL> from corehq . apps . smsbillables . models import ( <EOL> SmsBillable , <EOL> SmsGatewayFee , <EOL> SmsGatewayFeeCriteria , <EOL> SmsUsageFee , <EOL> SmsUsageFeeCriteria , <EOL> ) <EOL> from corehq . apps . accounting import generator , tasks , utils <EOL> from corehq . apps . accounting . models import ( <EOL> SMALL_INVOICE_THRESHOLD , <EOL> BillingAccount , <EOL> BillingRecord , <EOL> CreditAdjustment , <EOL> CreditLine , <EOL> DefaultProductPlan , <EOL> FeatureType , <EOL> Invoice , <EOL> LineItem , <EOL> SoftwarePlanEdition , <EOL> SoftwareProductType , <EOL> Subscriber , <EOL> Subscription , <EOL> SubscriptionAdjustment , <EOL> SubscriptionType , <EOL> ) <EOL> from corehq . apps . accounting . tests . base_tests import BaseAccountingTest <EOL> class BaseInvoiceTestCase ( BaseAccountingTest ) : <EOL> min_subscription_length = <NUM_LIT:3> <EOL> def setUp ( self ) : <EOL> super ( BaseInvoiceTestCase , self ) . setUp ( ) <EOL> self . billing_contact = generator . arbitrary_web_user ( ) <EOL> self . dimagi_user = generator . arbitrary_web_user ( is_dimagi = True ) <EOL> self . currency = generator . init_default_currency ( ) <EOL> self . account = generator . billing_account ( <EOL> self . dimagi_user , self . billing_contact ) <EOL> self . domain = generator . arbitrary_domain ( ) <EOL> self . subscription_length = <NUM_LIT:15> <EOL> subscription_start_date = datetime . date ( <NUM_LIT> , <NUM_LIT:2> , <NUM_LIT> ) <EOL> subscription_end_date = add_months_to_date ( subscription_start_date , self . subscription_length ) <EOL> self . subscription = generator . generate_domain_subscription ( <EOL> self . account , <EOL> self . domain , <EOL> date_start = subscription_start_date , <EOL> date_end = subscription_end_date , <EOL> ) <EOL> self . community_plan = DefaultProductPlan . objects . get ( <EOL> product_type = SoftwareProductType . COMMCARE , <EOL> edition = SoftwarePlanEdition . COMMUNITY <EOL> ) . plan . get_version ( ) <EOL> def tearDown ( self ) : <EOL> CreditAdjustment . objects . all ( ) . delete ( ) <EOL> CreditLine . objects . all ( ) . delete ( ) <EOL> BillingRecord . objects . all ( ) . delete ( ) <EOL> LineItem . objects . all ( ) . delete ( ) <EOL> SubscriptionAdjustment . objects . all ( ) . delete ( ) <EOL> Invoice . objects . all ( ) . delete ( ) <EOL> generator . delete_all_subscriptions ( ) <EOL> generator . delete_all_accounts ( ) <EOL> self . billing_contact . delete ( ) <EOL> self . dimagi_user . delete ( ) <EOL> self . domain . delete ( ) <EOL> super ( BaseInvoiceTestCase , self ) . tearDown ( ) <EOL> class TestInvoice ( BaseInvoiceTestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def test_no_invoice_before_start ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> tasks . generate_invoices ( self . subscription . date_start ) <EOL> self . assertEqual ( self . subscription . invoice_set . count ( ) , <NUM_LIT:0> ) <EOL> def test_subscription_invoice ( self ) : <EOL> invoice_date = utils . months_from_date ( self . subscription . date_start , random . randint ( <NUM_LIT:2> , self . subscription_length ) ) <EOL> tasks . generate_invoices ( invoice_date ) <EOL> self . assertEqual ( self . subscription . invoice_set . count ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( self . subscription . subscriber . domain , self . domain . name ) <EOL> invoice = self . subscription . invoice_set . latest ( '<STR_LIT>' ) <EOL> num_product_line_items = invoice . lineitem_set . get_products ( ) . count ( ) <EOL> self . assertEqual ( num_product_line_items , <NUM_LIT:1> ) <EOL> num_feature_line_items = invoice . lineitem_set . get_features ( ) . count ( ) <EOL> self . assertEqual ( num_feature_line_items , self . subscription . plan_version . feature_rates . count ( ) ) <EOL> self . assertEqual ( invoice . subscription , self . subscription ) <EOL> self . assertGreater ( invoice . balance , Decimal ( '<STR_LIT>' ) ) <EOL> def test_no_invoice_after_end ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> invoice_date = utils . months_from_date ( self . subscription . date_end , <NUM_LIT:2> ) <EOL> tasks . generate_invoices ( invoice_date ) <EOL> self . assertEqual ( self . subscription . invoice_set . count ( ) , <NUM_LIT:0> ) <EOL> def test_community_no_charges_no_invoice ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> domain = generator . arbitrary_domain ( ) <EOL> tasks . generate_invoices ( ) <EOL> self . assertRaises ( ObjectDoesNotExist , <EOL> lambda : Invoice . objects . get ( subscription__subscriber__domain = domain . name ) ) <EOL> domain . delete ( ) <EOL> def test_community_invoice ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> domain = generator . arbitrary_domain ( ) <EOL> generator . create_excess_community_users ( domain ) <EOL> account = BillingAccount . get_or_create_account_by_domain ( <EOL> domain , created_by = self . dimagi_user ) [ <NUM_LIT:0> ] <EOL> billing_contact = generator . arbitrary_contact_info ( account , self . dimagi_user ) <EOL> billing_contact . save ( ) <EOL> account . date_confirmed_extra_charges = datetime . date . today ( ) <EOL> account . save ( ) <EOL> tasks . generate_invoices ( ) <EOL> subscriber = Subscriber . objects . get ( domain = domain . name ) <EOL> invoices = Invoice . objects . filter ( subscription__subscriber = subscriber ) <EOL> self . assertEqual ( invoices . count ( ) , <NUM_LIT:1> ) <EOL> invoice = invoices . get ( ) <EOL> self . assertEqual ( invoice . subscription . subscriber . domain , domain . name ) <EOL> self . assertEqual ( invoice . subscription . date_start , invoice . date_start ) <EOL> self . assertEqual ( <EOL> invoice . subscription . date_end - datetime . timedelta ( days = <NUM_LIT:1> ) , <EOL> invoice . date_end <EOL> ) <EOL> domain . delete ( ) <EOL> def test_date_due_not_set_small_invoice ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Subscription . objects . all ( ) . delete ( ) <EOL> plan = DefaultProductPlan . objects . get ( <EOL> edition = SoftwarePlanEdition . STANDARD , <EOL> product_type = SoftwareProductType . COMMCARE , <EOL> is_trial = False <EOL> ) . plan . get_version ( ) <EOL> subscription_length = <NUM_LIT:5> <EOL> subscription_start_date = datetime . date ( <NUM_LIT> , <NUM_LIT:2> , <NUM_LIT> ) <EOL> subscription_end_date = add_months_to_date ( subscription_start_date , subscription_length ) <EOL> subscription = generator . generate_domain_subscription ( <EOL> self . account , <EOL> self . domain , <EOL> date_start = subscription_start_date , <EOL> date_end = subscription_end_date , <EOL> plan_version = plan , <EOL> ) <EOL> invoice_date_small = utils . months_from_date ( subscription . date_start , <NUM_LIT:1> ) <EOL> tasks . generate_invoices ( invoice_date_small ) <EOL> small_invoice = subscription . invoice_set . first ( ) <EOL> self . assertTrue ( small_invoice . balance <= SMALL_INVOICE_THRESHOLD ) <EOL> self . assertIsNone ( small_invoice . date_due ) <EOL> def test_date_due_set_large_invoice ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> Subscription . objects . all ( ) . delete ( ) <EOL> plan = DefaultProductPlan . objects . get ( <EOL> edition = SoftwarePlanEdition . ADVANCED , <EOL> product_type = SoftwareProductType . COMMCARE , <EOL> is_trial = False <EOL> ) . plan . get_version ( ) <EOL> subscription_length = <NUM_LIT:5> <EOL> subscription_start_date = datetime . date ( <NUM_LIT> , <NUM_LIT:2> , <NUM_LIT> ) <EOL> subscription_end_date = add_months_to_date ( subscription_start_date , subscription_length ) <EOL> subscription = generator . generate_domain_subscription ( <EOL> self . account , <EOL> self . domain , <EOL> date_start = subscription_start_date , <EOL> date_end = subscription_end_date , <EOL> plan_version = plan <EOL>", "answer": ")"}, {"prompt": "<s> import functools <EOL> from stravalib import model <EOL> from stravalib . client import BatchedResultsIterator <EOL>", "answer": "from stravalib . tests . functional import FunctionalTestBase"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import cPickle <EOL> import os , sys , argparse <EOL> import array <EOL> from collections import deque , defaultdict <EOL> from common import read_features <EOL> class Scanner ( object ) : <EOL> alphabet = map ( chr , range ( <NUM_LIT:1> << <NUM_LIT:8> ) ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ classmethod <EOL> def from_file ( cls , path ) : <EOL> with open ( path ) as f : <EOL> tk_nextmove , tk_output , feats = cPickle . load ( f ) <EOL> if isinstance ( feats , dict ) : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> tk_output_f = dict ( ( k , [ feats [ i ] for i in v ] ) for k , v in tk_output . iteritems ( ) ) <EOL> scanner = cls . __new__ ( cls ) <EOL> scanner . __setstate__ ( ( tk_nextmove , tk_output_f ) ) <EOL> return scanner <EOL> def __init__ ( self , keywords ) : <EOL> self . build ( keywords ) <EOL> def __call__ ( self , value ) : <EOL> return self . search ( value ) <EOL> def build ( self , keywords ) : <EOL> goto = dict ( ) <EOL> fail = dict ( ) <EOL> output = defaultdict ( set ) <EOL> newstate = <NUM_LIT:0> <EOL> for a in keywords : <EOL> state = <NUM_LIT:0> <EOL> j = <NUM_LIT:0> <EOL> while ( j < len ( a ) ) and ( state , a [ j ] ) in goto : <EOL> state = goto [ ( state , a [ j ] ) ] <EOL> j += <NUM_LIT:1> <EOL> for p in range ( j , len ( a ) ) : <EOL> newstate += <NUM_LIT:1> <EOL> goto [ ( state , a [ p ] ) ] = newstate <EOL> state = newstate <EOL> output [ state ] . add ( a ) <EOL> for a in self . alphabet : <EOL> if ( <NUM_LIT:0> , a ) not in goto : <EOL> goto [ ( <NUM_LIT:0> , a ) ] = <NUM_LIT:0> <EOL> queue = deque ( ) <EOL> for a in self . alphabet : <EOL> if goto [ ( <NUM_LIT:0> , a ) ] != <NUM_LIT:0> : <EOL> s = goto [ ( <NUM_LIT:0> , a ) ] <EOL> queue . append ( s ) <EOL> fail [ s ] = <NUM_LIT:0> <EOL> while queue : <EOL> r = queue . popleft ( ) <EOL> for a in self . alphabet : <EOL> if ( r , a ) in goto : <EOL> s = goto [ ( r , a ) ] <EOL> queue . append ( s ) <EOL> state = fail [ r ] <EOL> while ( state , a ) not in goto : <EOL> state = fail [ state ] <EOL> fail [ s ] = goto [ ( state , a ) ] <EOL> if output [ fail [ s ] ] : <EOL> output [ s ] . update ( output [ fail [ s ] ] ) <EOL> self . nextmove = { } <EOL> for a in self . alphabet : <EOL> self . nextmove [ ( <NUM_LIT:0> , a ) ] = goto [ ( <NUM_LIT:0> , a ) ] <EOL> if goto [ ( <NUM_LIT:0> , a ) ] != <NUM_LIT:0> : <EOL> queue . append ( goto [ ( <NUM_LIT:0> , a ) ] ) <EOL> while queue : <EOL> r = queue . popleft ( ) <EOL> for a in self . alphabet : <EOL> if ( r , a ) in goto : <EOL> s = goto [ ( r , a ) ] <EOL> queue . append ( s ) <EOL> self . nextmove [ ( r , a ) ] = s <EOL> else : <EOL> self . nextmove [ ( r , a ) ] = self . nextmove [ ( fail [ r ] , a ) ] <EOL> self . output = dict ( ( k , tuple ( output [ k ] ) ) for k in output ) <EOL> def generate_nm_arr ( typecode ) : <EOL> def nextstate_iter ( ) : <EOL> for state in xrange ( newstate + <NUM_LIT:1> ) : <EOL> for letter in self . alphabet : <EOL> yield self . nextmove [ ( state , letter ) ] <EOL> return array . array ( typecode , nextstate_iter ( ) ) <EOL> try : <EOL> self . nm_arr = generate_nm_arr ( '<STR_LIT:H>' ) <EOL> except OverflowError : <EOL> self . nm_arr = generate_nm_arr ( '<STR_LIT:L>' ) <EOL> def __getstate__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return ( self . nm_arr , self . output ) <EOL> def __setstate__ ( self , value ) : <EOL> nm_array , output = value <EOL> self . nm_arr = nm_array <EOL> self . output = output <EOL> self . nextmove = { } <EOL> for i , next_state in enumerate ( nm_array ) : <EOL> state = i / <NUM_LIT> <EOL> letter = chr ( i % <NUM_LIT> ) <EOL> self . nextmove [ ( state , letter ) ] = next_state <EOL> def search ( self , string ) : <EOL> state = <NUM_LIT:0> <EOL> for letter in map ( ord , string ) : <EOL> state = self . nm_arr [ ( state << <NUM_LIT:8> ) + letter ] <EOL> for key in self . output . get ( state , [ ] ) : <EOL> yield key <EOL> def build_scanner ( features ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> feat_index = index ( features ) <EOL> print \"<STR_LIT>\" <EOL> scanner = Scanner ( features ) <EOL> tk_nextmove , raw_output = scanner . __getstate__ ( ) <EOL> tk_output = { } <EOL>", "answer": "for k , v in raw_output . items ( ) :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL> import allauth . socialaccount . fields <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AlterField ( <EOL>", "answer": "model_name = '<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> class CommandException ( Exception ) : <EOL> pass <EOL> class MetadataException ( CommandException ) : <EOL> pass <EOL>", "answer": "class RunException ( CommandException ) :"}, {"prompt": "<s> from ctypes import c_uint , byref <EOL> from django . contrib . gis . geos . error import GEOSIndexError <EOL> from django . contrib . gis . geos . geometry import GEOSGeometry <EOL> from django . contrib . gis . geos . libgeos import get_pointer_arr , GEOM_PTR <EOL> from django . contrib . gis . geos . linestring import LinearRing <EOL> from django . contrib . gis . geos import prototypes as capi <EOL> class Polygon ( GEOSGeometry ) : <EOL> _minlength = <NUM_LIT:1> <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not args : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> ext_ring = args [ <NUM_LIT:0> ] <EOL> init_holes = args [ <NUM_LIT:1> : ] <EOL> n_holes = len ( init_holes ) <EOL> if n_holes == <NUM_LIT:1> and isinstance ( init_holes [ <NUM_LIT:0> ] , ( tuple , list ) ) : <EOL> if len ( init_holes [ <NUM_LIT:0> ] ) == <NUM_LIT:0> : <EOL> init_holes = ( ) <EOL> n_holes = <NUM_LIT:0> <EOL> elif isinstance ( init_holes [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] , LinearRing ) : <EOL> init_holes = init_holes [ <NUM_LIT:0> ] <EOL> n_holes = len ( init_holes ) <EOL> polygon = self . _create_polygon ( n_holes + <NUM_LIT:1> , ( ext_ring , ) + init_holes ) <EOL> super ( Polygon , self ) . __init__ ( polygon , ** kwargs ) <EOL> def __iter__ ( self ) : <EOL> \"<STR_LIT>\" <EOL>", "answer": "for i in xrange ( len ( self ) ) :"}, {"prompt": "<s> from sys import argv <EOL> import yaml <EOL> import os <EOL> DEFAULT_ARCH = \"<STR_LIT>\" <EOL> def save ( name , data ) : <EOL> filename = \"<STR_LIT>\" % ( hiera_dir , name ) <EOL> if os . path . isfile ( filename ) : <EOL> os . rename ( filename , \"<STR_LIT>\" % filename ) <EOL> yaml . dump ( data , open ( filename , \"<STR_LIT:w>\" ) , default_flow_style = False ) <EOL> print \"<STR_LIT>\" % ( filename , <EOL> \"<STR_LIT>\" % filename ) <EOL> def load ( name ) : <EOL>", "answer": "filename = \"<STR_LIT>\" % ( hiera_dir , name )"}, {"prompt": "<s> from unittest import mock <EOL> from sockjs . transports import jsonp <EOL> from test_base import BaseSockjsTestCase <EOL> class JSONPollingTransportTests ( BaseSockjsTestCase ) : <EOL> TRANSPORT_CLASS = jsonp . JSONPolling <EOL> def test_streaming_send ( self ) : <EOL> trans = self . make_transport ( ) <EOL> trans . callback = '<STR_LIT>' <EOL> resp = trans . response = mock . Mock ( ) <EOL> stop = trans . send ( '<STR_LIT>' ) <EOL> resp . write . assert_called_with ( b'<STR_LIT>' ) <EOL> self . assertTrue ( stop ) <EOL> def test_process ( self ) : <EOL> transp = self . make_transport ( query_params = { '<STR_LIT:c>' : '<STR_LIT>' } ) <EOL> transp . handle_session = self . make_fut ( <NUM_LIT:1> ) <EOL> resp = self . loop . run_until_complete ( transp . process ( ) ) <EOL> self . assertTrue ( transp . handle_session . called ) <EOL> self . assertEqual ( resp . status , <NUM_LIT:200> ) <EOL> def test_process_no_callback ( self ) : <EOL> transp = self . make_transport ( ) <EOL> resp = self . loop . run_until_complete ( transp . process ( ) ) <EOL> self . assertTrue ( transp . session . _remote_closed . called ) <EOL> self . assertEqual ( resp . status , <NUM_LIT> ) <EOL> def test_process_bad_callback ( self ) : <EOL> transp = self . make_transport ( query_params = { '<STR_LIT:c>' : '<STR_LIT>' } ) <EOL> resp = self . loop . run_until_complete ( transp . process ( ) ) <EOL> self . assertTrue ( transp . session . _remote_closed . called ) <EOL> self . assertEqual ( resp . status , <NUM_LIT> ) <EOL> def test_process_not_supported ( self ) : <EOL> transp = self . make_transport ( method = '<STR_LIT>' ) <EOL> resp = self . loop . run_until_complete ( transp . process ( ) ) <EOL> self . assertEqual ( resp . status , <NUM_LIT> ) <EOL> def test_process_bad_encoding ( self ) : <EOL> transp = self . make_transport ( method = '<STR_LIT:POST>' ) <EOL> transp . request . read = self . make_fut ( b'<STR_LIT:test>' ) <EOL> transp . request . content_type <EOL> transp . request . _content_type = '<STR_LIT>' <EOL> resp = self . loop . run_until_complete ( transp . process ( ) ) <EOL> self . assertEqual ( resp . status , <NUM_LIT> ) <EOL> def test_process_no_payload ( self ) : <EOL> transp = self . make_transport ( method = '<STR_LIT:POST>' ) <EOL> transp . request . read = self . make_fut ( b'<STR_LIT>' ) <EOL> transp . request . content_type <EOL> transp . request . _content_type = '<STR_LIT>' <EOL> resp = self . loop . run_until_complete ( transp . process ( ) ) <EOL> self . assertEqual ( resp . status , <NUM_LIT> ) <EOL> def test_process_bad_json ( self ) : <EOL> transp = self . make_transport ( method = '<STR_LIT:POST>' ) <EOL> transp . request . read = self . make_fut ( b'<STR_LIT>' ) <EOL> resp = self . loop . run_until_complete ( transp . process ( ) ) <EOL>", "answer": "self . assertEqual ( resp . status , <NUM_LIT> )"}, {"prompt": "<s> from aws import Action , BaseARN <EOL> service_name = '<STR_LIT>' <EOL> prefix = '<STR_LIT>' <EOL> class ARN ( BaseARN ) : <EOL> def __init__ ( self , resource , region = '<STR_LIT>' , account = '<STR_LIT>' ) : <EOL> sup = super ( ARN , self ) <EOL> sup . __init__ ( service = prefix , resource = resource , region = region , <EOL> account = account ) <EOL> CancelKeyDeletion = Action ( prefix , '<STR_LIT>' ) <EOL> CreateAlias = Action ( prefix , '<STR_LIT>' ) <EOL> CreateGrant = Action ( prefix , '<STR_LIT>' ) <EOL> CreateKey = Action ( prefix , '<STR_LIT>' ) <EOL> Decrypt = Action ( prefix , '<STR_LIT>' ) <EOL> DeleteAlias = Action ( prefix , '<STR_LIT>' ) <EOL> DescribeKey = Action ( prefix , '<STR_LIT>' ) <EOL> DisableKey = Action ( prefix , '<STR_LIT>' ) <EOL> DisableKeyRotation = Action ( prefix , '<STR_LIT>' ) <EOL> EnableKey = Action ( prefix , '<STR_LIT>' ) <EOL> EnableKeyRotation = Action ( prefix , '<STR_LIT>' ) <EOL> Encrypt = Action ( prefix , '<STR_LIT>' ) <EOL> GenerateDataKey = Action ( prefix , '<STR_LIT>' ) <EOL> GenerateDataKeyWithoutPlaintext = Action ( prefix , '<STR_LIT>' ) <EOL> GenerateRandom = Action ( prefix , '<STR_LIT>' ) <EOL> GetKeyPolicy = Action ( prefix , '<STR_LIT>' ) <EOL> GetKeyRotationStatus = Action ( prefix , '<STR_LIT>' ) <EOL> ListAliases = Action ( prefix , '<STR_LIT>' ) <EOL> ListGrants = Action ( prefix , '<STR_LIT>' ) <EOL> ListKeyPolicies = Action ( prefix , '<STR_LIT>' ) <EOL> ListKeys = Action ( prefix , '<STR_LIT>' ) <EOL> ListRetirableGrants = Action ( prefix , '<STR_LIT>' ) <EOL> PutKeyPolicy = Action ( prefix , '<STR_LIT>' ) <EOL>", "answer": "ReEncrypt = Action ( prefix , '<STR_LIT>' )"}, {"prompt": "<s> from django . conf . urls import url <EOL> from django . contrib . auth . decorators import login_required as login <EOL> from . import views <EOL>", "answer": "urlpatterns = ["}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import threading <EOL> import subprocess <EOL> import sys <EOL> if sys . platform == \"<STR_LIT>\" : <EOL> player_name = \"<STR_LIT>\" <EOL> elif sys . platform == \"<STR_LIT>\" : <EOL> player_name = \"<STR_LIT>\" <EOL>", "answer": "def _play_audio_t ( path ) :"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import yaki . Engine , yaki . Store , yaki . Locale <EOL> from yaki . Utils import * <EOL> import time <EOL> from pygooglechart import ScatterChart <EOL> from pygooglechart import Axis <EOL> class HitMapWikiPlugin ( yaki . Plugins . WikiPlugin ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , registry , webapp ) : <EOL> registry . register ( '<STR_LIT>' , self , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . ac = webapp . getContext ( ) <EOL> self . i18n = yaki . Locale . i18n [ self . ac . locale ] <EOL> self . data = { } <EOL> def run ( self , serial , tag , tagname , pagename , soup , request , response ) : <EOL> width = <NUM_LIT> <EOL> height = <NUM_LIT> <EOL> buckets = self . ac . indexer . hitmap . getBuckets ( ) <EOL> self . data = { } <EOL> for t in buckets . keys ( ) : <EOL> slot = time . strftime ( \"<STR_LIT>\" , time . localtime ( int ( t ) ) ) <EOL> if slot in self . data . keys ( ) : <EOL> self . data [ slot ] = self . data [ slot ] + buckets [ t ] <EOL>", "answer": "else :"}, {"prompt": "<s> from __future__ import absolute_import <EOL> import os <EOL> import sys <EOL> from django . conf import settings <EOL> databases = { <EOL> '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT:root>' } <EOL> } <EOL> settings . configure ( <EOL> MIDDLEWARE_CLASSES = ( ) , <EOL> INSTALLED_APPS = ( '<STR_LIT:test>' , ) , <EOL> DATABASES = { '<STR_LIT:default>' : databases [ os . environ . get ( '<STR_LIT>' ) ] } <EOL> ) <EOL> sys . modules [ '<STR_LIT>' ] = type ( '<STR_LIT>' , ( object , ) , { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } ) <EOL> try : <EOL> import django <EOL> django . setup ( ) <EOL> command = '<STR_LIT>' <EOL> except AttributeError : <EOL> command = '<STR_LIT>' <EOL> from django . db import models <EOL> from django . core import management <EOL> from architect import install <EOL> for item in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> class Meta ( object ) : <EOL> app_label = '<STR_LIT:test>' <EOL> db_table = '<STR_LIT>' . format ( item ) <EOL> name = '<STR_LIT>' . format ( item . capitalize ( ) ) <EOL> partition = install ( '<STR_LIT>' , type = '<STR_LIT>' , subtype = '<STR_LIT:date>' , constraint = item , column = '<STR_LIT>' ) <EOL> locals ( ) [ name ] = partition ( type ( name , ( models . Model , ) , { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : models . CharField ( max_length = <NUM_LIT:255> ) , <EOL> '<STR_LIT>' : models . DateTimeField ( null = True ) , <EOL> '<STR_LIT:Meta>' : Meta , <EOL> } ) ) <EOL> if os . environ . get ( '<STR_LIT>' ) in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> for item in ( '<STR_LIT:2>' , '<STR_LIT:5>' ) : <EOL> class Meta ( object ) : <EOL> app_label = '<STR_LIT:test>' <EOL> db_table = '<STR_LIT>' . format ( item ) <EOL> name = '<STR_LIT>' . format ( item ) <EOL>", "answer": "partition = install ( '<STR_LIT>' , type = '<STR_LIT>' , subtype = '<STR_LIT>' , constraint = item , column = '<STR_LIT>' )"}, {"prompt": "<s> import argparse <EOL> import logging <EOL> import sys <EOL> import mock <EOL> import six <EOL> from six . moves import builtins <EOL> import testtools <EOL> from senlinclient import client as senlin_client <EOL> from senlinclient . common import exc <EOL> from senlinclient . common . i18n import _ <EOL> from senlinclient . common import sdk <EOL> from senlinclient . common import utils <EOL> from senlinclient import shell <EOL> from senlinclient . tests . unit import fakes <EOL> class HelpFormatterTest ( testtools . TestCase ) : <EOL> def test_start_section ( self ) : <EOL> fmtr = shell . HelpFormatter ( '<STR_LIT>' ) <EOL> res = fmtr . start_section ( ( '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT:30> ) ) <EOL> self . assertIsNone ( res ) <EOL> h = fmtr . _current_section . heading <EOL> self . assertEqual ( \"<STR_LIT>\" , h ) <EOL> class TestArgs ( testtools . TestCase ) : <EOL> def __init__ ( self ) : <EOL> self . auth_url = '<STR_LIT>' <EOL> self . auth_plugin = '<STR_LIT>' <EOL> self . username = '<STR_LIT>' <EOL> self . user_id = '<STR_LIT>' <EOL> self . token = '<STR_LIT>' <EOL> self . project_id = '<STR_LIT>' <EOL> self . project_name = '<STR_LIT>' <EOL> self . tenant_id = '<STR_LIT>' <EOL> self . tenant_name = '<STR_LIT>' <EOL> self . password = '<STR_LIT>' <EOL> self . user_domain_id = '<STR_LIT>' <EOL> self . user_domain_name = '<STR_LIT>' <EOL> self . project_domain_id = '<STR_LIT>' <EOL> self . project_domain_name = '<STR_LIT>' <EOL> self . domain_name = '<STR_LIT>' <EOL> self . domain_id = '<STR_LIT>' <EOL> self . verify = '<STR_LIT>' <EOL> self . user_preferences = '<STR_LIT>' <EOL> self . trust_id = '<STR_LIT>' <EOL> class ShellTest ( testtools . TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( ShellTest , self ) . setUp ( ) <EOL> def SHELL ( self , func , * args , ** kwargs ) : <EOL> orig_out = sys . stdout <EOL> sys . stdout = six . StringIO ( ) <EOL> func ( * args , ** kwargs ) <EOL> output = sys . stdout . getvalue ( ) <EOL> sys . stdout . close ( ) <EOL> sys . stdout = orig_out <EOL> return output <EOL> @ mock . patch . object ( logging , '<STR_LIT>' ) <EOL> @ mock . patch . object ( logging , '<STR_LIT>' ) <EOL> def test_setup_logging_debug ( self , x_get , x_config ) : <EOL> sh = shell . SenlinShell ( ) <EOL> sh . _setup_logging ( True ) <EOL> x_config . assert_called_once_with ( <EOL> format = \"<STR_LIT>\" , <EOL> level = logging . DEBUG ) <EOL> mock_calls = [ <EOL> mock . call ( '<STR_LIT>' ) , <EOL> mock . call ( ) . setLevel ( logging . WARNING ) , <EOL> mock . call ( '<STR_LIT>' ) , <EOL> mock . call ( ) . setLevel ( logging . WARNING ) , <EOL> ] <EOL> x_get . assert_has_calls ( mock_calls ) <EOL> @ mock . patch . object ( logging , '<STR_LIT>' ) <EOL> @ mock . patch . object ( logging , '<STR_LIT>' ) <EOL> def test_setup_logging_no_debug ( self , x_get , x_config ) : <EOL> sh = shell . SenlinShell ( ) <EOL> sh . _setup_logging ( False ) <EOL> x_config . assert_called_once_with ( <EOL> format = \"<STR_LIT>\" , <EOL> level = logging . WARNING ) <EOL> mock_calls = [ <EOL> mock . call ( '<STR_LIT>' ) , <EOL> mock . call ( ) . setLevel ( logging . WARNING ) , <EOL> mock . call ( '<STR_LIT>' ) , <EOL> mock . call ( ) . setLevel ( logging . WARNING ) , <EOL> ] <EOL> x_get . assert_has_calls ( mock_calls ) <EOL> def test_setup_verbose ( self ) : <EOL> sh = shell . SenlinShell ( ) <EOL> sh . _setup_verbose ( True ) <EOL> self . assertEqual ( <NUM_LIT:1> , exc . verbose ) <EOL> sh . _setup_verbose ( False ) <EOL> self . assertEqual ( <NUM_LIT:1> , exc . verbose ) <EOL> def test_find_actions ( self ) : <EOL> sh = shell . SenlinShell ( ) <EOL> sh . subcommands = { } <EOL> subparsers = mock . Mock ( ) <EOL> x_subparser1 = mock . Mock ( ) <EOL> x_subparser2 = mock . Mock ( ) <EOL> x_add_parser = mock . MagicMock ( side_effect = [ x_subparser1 , x_subparser2 ] ) <EOL> subparsers . add_parser = x_add_parser <EOL> sh . _find_actions ( subparsers , fakes ) <EOL> self . assertEqual ( { '<STR_LIT>' : x_subparser1 , <EOL> '<STR_LIT>' : x_subparser2 } , <EOL> sh . subcommands ) <EOL> add_calls = [ <EOL> mock . call ( '<STR_LIT>' , help = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> add_help = False , <EOL> formatter_class = shell . HelpFormatter ) , <EOL> mock . call ( '<STR_LIT>' , help = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> add_help = False , <EOL> formatter_class = shell . HelpFormatter ) , <EOL> ] <EOL> x_add_parser . assert_has_calls ( add_calls ) <EOL> calls_1 = [ <EOL> mock . call ( '<STR_LIT>' , '<STR_LIT>' , action = '<STR_LIT>' , <EOL> help = argparse . SUPPRESS ) , <EOL> mock . call ( '<STR_LIT>' , '<STR_LIT>' , metavar = '<STR_LIT>' , <EOL> help = '<STR_LIT>' ) , <EOL> mock . call ( '<STR_LIT>' , metavar = '<STR_LIT>' , <EOL> help = '<STR_LIT>' ) <EOL> ] <EOL> x_subparser1 . add_argument . assert_has_calls ( calls_1 ) <EOL> x_subparser1 . set_defaults . assert_called_once_with ( <EOL> func = fakes . do_command_bar ) <EOL> calls_2 = [ <EOL> mock . call ( '<STR_LIT>' , '<STR_LIT>' , action = '<STR_LIT>' , <EOL> help = argparse . SUPPRESS ) , <EOL> ] <EOL> x_subparser2 . add_argument . assert_has_calls ( calls_2 ) <EOL> x_subparser2 . set_defaults . assert_called_once_with ( <EOL> func = fakes . do_command_foo ) <EOL> def test_do_bash_completion ( self ) : <EOL> sh = shell . SenlinShell ( ) <EOL> sc1 = mock . Mock ( ) <EOL> sc2 = mock . Mock ( ) <EOL> sc1 . _optionals . _option_string_actions = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:C>' ) <EOL> sc2 . _optionals . _option_string_actions = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:C>' ) <EOL> sh . subcommands = { <EOL> '<STR_LIT>' : sc1 , <EOL> '<STR_LIT>' : sc2 , <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : None , <EOL> } <EOL> output = self . SHELL ( sh . do_bash_completion , None ) <EOL> output = output . split ( '<STR_LIT:\\n>' ) [ <NUM_LIT:0> ] <EOL> output_list = output . split ( '<STR_LIT:U+0020>' ) <EOL> for option in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:C>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) : <EOL> self . assertIn ( option , output_list ) <EOL> def test_do_add_profiler_args ( self ) : <EOL> sh = shell . SenlinShell ( ) <EOL> parser = mock . Mock ( ) <EOL> sh . add_profiler_args ( parser ) <EOL> self . assertEqual ( <NUM_LIT:0> , parser . add_argument . call_count ) <EOL> def test_add_bash_completion_subparser ( self ) : <EOL> sh = shell . SenlinShell ( ) <EOL> sh . subcommands = { } <EOL> x_subparser = mock . Mock ( ) <EOL> x_subparsers = mock . Mock ( ) <EOL> x_subparsers . add_parser . return_value = x_subparser <EOL> sh . _add_bash_completion_subparser ( x_subparsers ) <EOL> x_subparsers . add_parser . assert_called_once_with ( <EOL> '<STR_LIT>' , add_help = False , <EOL> formatter_class = shell . HelpFormatter ) <EOL> self . assertEqual ( { '<STR_LIT>' : x_subparser } , sh . subcommands ) <EOL> x_subparser . set_defaults . assert_called_once_with ( <EOL> func = sh . do_bash_completion ) <EOL> @ mock . patch . object ( utils , '<STR_LIT>' ) <EOL> @ mock . patch . object ( shell . SenlinShell , '<STR_LIT>' ) <EOL> @ mock . patch . object ( shell . SenlinShell , '<STR_LIT>' ) <EOL> def test_get_subcommand_parser ( self , x_add , x_find , x_import ) : <EOL> x_base = mock . Mock ( ) <EOL> x_module = mock . Mock ( ) <EOL> x_import . return_value = x_module <EOL> sh = shell . SenlinShell ( ) <EOL> res = sh . get_subcommand_parser ( x_base , '<STR_LIT>' ) <EOL> self . assertEqual ( x_base , res ) <EOL> x_base . add_subparsers . assert_called_once_with ( <EOL> metavar = '<STR_LIT>' ) <EOL> x_subparsers = x_base . add_subparsers . return_value <EOL> x_import . assert_called_once_with ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> find_calls = [ <EOL> mock . call ( x_subparsers , x_module ) , <EOL> mock . call ( x_subparsers , sh ) <EOL>", "answer": "]"}, {"prompt": "<s> from . import PushService <EOL>", "answer": "import requests"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os , shutil , sys , tempfile <EOL> from optparse import OptionParser <EOL> tmpeggs = tempfile . mkdtemp ( ) <EOL> usage = '''<STR_LIT>''' <EOL> parser = OptionParser ( usage = usage ) <EOL> parser . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , help = \"<STR_LIT>\" ) <EOL> parser . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> dest = '<STR_LIT>' , <EOL> action = \"<STR_LIT:store_true>\" , default = False , <EOL> help = ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) ) <EOL> parser . add_option ( \"<STR_LIT:-c>\" , \"<STR_LIT>\" , <EOL> help = ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) ) <EOL> parser . add_option ( \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> help = ( \"<STR_LIT>\" ) ) <EOL> options , args = parser . parse_args ( ) <EOL>", "answer": "to_reload = False"}, {"prompt": "<s> import itertools <EOL> from conary import errors <EOL> from conary . deps import deps <EOL> from conary . lib import log <EOL> from conary . repository import searchsource <EOL> from conary . repository . resolvemethod import DepResolutionByTroveList , ResolutionStack , BasicResolutionMethod , DepResolutionByLabelPath , DepResolutionMethod <EOL> class DependencySolver ( object ) : <EOL> def __init__ ( self , client , cfg , db ) : <EOL> self . client = client <EOL> self . cfg = cfg <EOL> self . db = db <EOL> def _findCriticalJobInfo ( self , jobSet , updateSettings ) : <EOL> if updateSettings is None : <EOL> return [ ] , [ ] , False <EOL> criticalJobs = updateSettings . findCriticalJobs ( jobSet ) <EOL> finalJobs = updateSettings . findFinalJobs ( jobSet ) <EOL> return criticalJobs , finalJobs , updateSettings . isCriticalOnlyUpdate ( ) <EOL> def resolveDependencies ( self , uJob , jobSet , split = False , <EOL> resolveDeps = True , useRepos = True , <EOL> resolveSource = None , keepRequired = True , <EOL> criticalUpdateInfo = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> searchSource = uJob . getSearchSource ( ) <EOL> if not isinstance ( searchSource , searchsource . AbstractSearchSource ) : <EOL> searchSource = searchsource . SearchSource ( searchSource , <EOL> self . cfg . flavor , self . db ) <EOL> if useRepos : <EOL> defaultSearchSource = self . client . getSearchSource ( ) <EOL> searchSource = searchsource . stack ( searchSource , <EOL> defaultSearchSource ) <EOL> troveSource = searchSource . getTroveSource ( ) <EOL> ineligible = set ( ) <EOL> check = self . db . getDepStateClass ( uJob . getTroveSource ( ) , <EOL> findOrdering = split , ignoreDepClasses = self . cfg . ignoreDependencies ) <EOL> ( result , cannotResolve , keepList , ineligible ) = self . checkDeps ( uJob , jobSet , troveSource , <EOL> resolveDeps = resolveDeps , <EOL> ineligible = ineligible , <EOL> keepRequired = keepRequired , <EOL> criticalUpdateInfo = criticalUpdateInfo , <EOL> check = check ) <EOL> depList = result . unsatisfiedList <EOL> if not resolveDeps : <EOL> depList = [ ] <EOL> cannotResolve = [ ] <EOL> if resolveSource is None : <EOL> resolveSource = searchSource . getResolveMethod ( ) <EOL> resolveSource . searchLeavesFirst ( ) <EOL> else : <EOL> resolveSource . setTroveSource ( troveSource ) <EOL> suggMap = { } <EOL> if not hasattr ( resolveSource , '<STR_LIT>' ) : <EOL> resolveSource . filterDependencies = lambda x : x <EOL> depList = resolveSource . filterDependencies ( depList ) <EOL> while resolveSource . prepareForResolution ( depList ) : <EOL> sugg = resolveSource . resolveDependencies ( ) <EOL> newTroves = resolveSource . filterSuggestions ( depList , sugg , suggMap ) <EOL> if not newTroves : <EOL> continue <EOL> changedJob = self . addUpdates ( newTroves , uJob , jobSet , ineligible , <EOL> keepList , troveSource , resolveSource ) <EOL> if not changedJob : <EOL> continue <EOL> ( result , cannotResolve , newKeepList , ineligible ) = self . checkDeps ( uJob , jobSet , <EOL> uJob . getTroveSource ( ) , <EOL> resolveDeps = True , <EOL> ineligible = ineligible , <EOL> keepRequired = keepRequired , <EOL> criticalUpdateInfo = criticalUpdateInfo , <EOL> check = check ) <EOL> depList = result . unsatisfiedList <EOL> keepList . extend ( newKeepList ) <EOL> depList = resolveSource . filterDependencies ( depList ) <EOL> check . done ( ) <EOL> changeSetList = result . getChangeSetList ( ) <EOL> criticalUpdates = result . getCriticalUpdates ( ) <EOL> return ( depList , suggMap , cannotResolve , changeSetList , keepList , <EOL> criticalUpdates ) <EOL> def addUpdates ( self , troves , uJob , jobSet , ineligible , keepList , <EOL> troveSource , resolveSource ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> beingRemoved = set ( ( x [ <NUM_LIT:0> ] , x [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , x [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] ) for x in <EOL> jobSet if x [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] is not None ) <EOL> beingInstalled = set ( ( x [ <NUM_LIT:0> ] , x [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , x [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] ) for x in <EOL> jobSet if x [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] is not None ) <EOL> if self . cfg . autoResolvePackages : <EOL> packageJobs = self . addPackagesForComponents ( troves , <EOL> troveSource , <EOL> beingInstalled ) <EOL> troves . update ( packageJobs ) <EOL> newJob = self . client . _updateChangeSet ( troves , uJob , <EOL> keepExisting = False , <EOL> recurse = False , <EOL> ineligible = beingRemoved , <EOL> checkPrimaryPins = True ) <EOL> assert ( not ( newJob & jobSet ) ) <EOL> newJob = resolveSource . filterResolutionsPostUpdate ( self . db , newJob , <EOL> troveSource ) <EOL> if not newJob : <EOL> return False <EOL> jobSet . update ( newJob ) <EOL> return True <EOL> def checkDeps ( self , uJob , jobSet , trvSrc , <EOL> resolveDeps , ineligible , keepRequired = True , <EOL> criticalUpdateInfo = None , check = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert ( check ) <EOL> keepList = [ ] <EOL> pathHashCache = { } <EOL> while True : <EOL> linkedJobs = self . client . _findOverlappingJobs ( jobSet , <EOL> uJob . getTroveSource ( ) , <EOL> pathHashCache = pathHashCache ) <EOL> criticalJobs , finalJobs , criticalOnly = self . _findCriticalJobInfo ( <EOL> jobSet , <EOL> criticalUpdateInfo ) <EOL> result = check . depCheck ( jobSet , <EOL> linkedJobs = linkedJobs , <EOL> criticalJobs = criticalJobs , <EOL> finalJobs = finalJobs , <EOL> criticalOnly = criticalOnly ) <EOL> cannotResolve = result . unresolveableList <EOL> if not resolveDeps or not cannotResolve : <EOL> break <EOL> changeMade = False <EOL> log . debug ( '<STR_LIT>' ) <EOL> for reqInfo , depSet , provInfo in sorted ( cannotResolve , <EOL> key = lambda x : x [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] ) : <EOL> depSet = '<STR_LIT>' . join ( str ( depSet ) . split ( '<STR_LIT:\\n>' ) ) <EOL> msg = ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> args = ( reqInfo [ <NUM_LIT:0> ] , reqInfo [ <NUM_LIT:1> ] . trailingRevision ( ) , depSet , <EOL> '<STR_LIT:U+002CU+0020>' . join ( x [ <NUM_LIT:0> ] for x in provInfo ) ) <EOL> log . debug ( msg , * args ) <EOL> if self . cfg . resolveLevel > <NUM_LIT:1> : <EOL> cannotResolve , newJobSet = self . resolveEraseByUpdating ( <EOL> trvSrc , <EOL> cannotResolve , <EOL> uJob , jobSet , <EOL> ineligible , <EOL> check ) <EOL> if newJobSet : <EOL> jobSet |= newJobSet <EOL> changeMade = True <EOL> if not changeMade and cannotResolve and keepRequired : <EOL> cannotResolve , newKeepList = self . resolveEraseByKeeping ( <EOL> trvSrc , <EOL> cannotResolve , <EOL> uJob , jobSet ) <EOL> if newKeepList : <EOL> changeMade = True <EOL> keepList += newKeepList <EOL> if not changeMade : <EOL> break <EOL> return ( result , cannotResolve , keepList , ineligible ) <EOL> def resolveEraseByUpdating ( self , trvSrc , cannotResolve , uJob , jobSet , <EOL> ineligible , check ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> oldIdx = { } <EOL> newIdx = { } <EOL> for job in jobSet : <EOL> if job [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] is not None : <EOL> oldIdx [ ( job [ <NUM_LIT:0> ] , job [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , job [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] ) ] = job <EOL> if job [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] is not None : <EOL> newIdx [ ( job [ <NUM_LIT:0> ] , job [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , job [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] ) ] = job <EOL> potentialUpdateList = [ ] <EOL> for resolveInfo in cannotResolve : <EOL> ( reqInfo , depSet , provInfoList ) = resolveInfo <EOL> if reqInfo in newIdx : <EOL> continue <EOL> found = False <EOL> for provInfo in provInfoList : <EOL> if provInfo in ineligible : <EOL> found = True <EOL> break <EOL> if found : <EOL> continue <EOL> for provInfo in provInfoList : <EOL> if provInfo not in oldIdx : <EOL> continue <EOL> job = oldIdx [ provInfo ] <EOL> if not job [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] : <EOL> continue <EOL> ineligible . add ( reqInfo ) <EOL> potentialUpdateList . append ( ( reqInfo , depSet , provInfoList ) ) <EOL> break <EOL> if not potentialUpdateList : <EOL> return cannotResolve , set ( ) <EOL> log . debug ( '<STR_LIT>' <EOL> '<STR_LIT>' , ( '<STR_LIT>' . join ( sorted ( x [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] for x in potentialUpdateList ) ) ) ) <EOL> updateJobs = [ ( x [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] , <EOL> ( None , None ) , ( None , None ) , True ) <EOL> for x in potentialUpdateList ] <EOL> try : <EOL> newJob = self . client . newUpdateJob ( closeDatabase = False ) <EOL> self . client . prepareUpdateJob ( newJob , updateJobs , <EOL> keepExisting = False , <EOL> resolveDeps = False , <EOL> split = False ) <EOL> newJobSet = newJob . getJobs ( ) <EOL> jobs = ( ( x for x in jobSet <EOL> if ( x [ <NUM_LIT:0> ] , x [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , x [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] ) not in newIdx ) <EOL> for jobSet in newJobSet ) <EOL> newJobSet = set ( itertools . chain ( * jobs ) ) <EOL> uJob . getTroveSource ( ) . merge ( newJob . getTroveSource ( ) ) <EOL> check . setTroveSource ( uJob . getTroveSource ( ) ) <EOL> newResult = check . depCheck ( jobSet | newJobSet , criticalJobs = [ ] ) <EOL> check . done ( ) <EOL> if cannotResolve != newResult . unresolveableList : <EOL> cannotResolve = newResult . unresolveableList <EOL> else : <EOL> newJobSet = set ( ) <EOL> except ( errors . ClientError , errors . TroveNotFound ) : <EOL> newJobSet = set ( ) <EOL> if newJobSet : <EOL> log . debug ( '<STR_LIT>' , len ( newJobSet ) , <EOL> '<STR_LIT>' . join ( sorted ( '<STR_LIT>' % ( x [ <NUM_LIT:0> ] , x [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] . branch ( ) . label ( ) , x [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] . trailingRevision ( ) , x [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] ) for x in newJobSet if x [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] ) ) ) <EOL> return cannotResolve , newJobSet <EOL> def resolveEraseByKeeping ( self , trvSrc , cannotResolve , uJob , jobSet ) : <EOL> oldIdx = { } <EOL> for job in jobSet : <EOL> if job [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] is not None : <EOL> oldIdx [ ( job [ <NUM_LIT:0> ] , job [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , job [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] ) ] = job <EOL> restoreSet = set ( ) <EOL> keepList = [ ] <EOL> for resolveInfo in cannotResolve [ : ] : <EOL> ( reqInfo , depSet , provInfoList ) = resolveInfo <EOL> for provInfo in provInfoList : <EOL> if provInfo not in oldIdx : continue <EOL> job = oldIdx [ provInfo ] <EOL> if job in restoreSet : <EOL> break <EOL> if ( job [ <NUM_LIT:0> ] , job [ <NUM_LIT:1> ] , ( None , None ) , False ) in uJob . getPrimaryJobs ( ) : <EOL> continue <EOL> if job [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] is None : <EOL> keepList . append ( ( job , depSet , reqInfo ) ) <EOL> cannotResolve . remove ( resolveInfo ) <EOL> restoreSet . add ( job ) <EOL> depSet = '<STR_LIT>' . join ( str ( depSet ) . split ( '<STR_LIT:\\n>' ) ) <EOL> msg = ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> args = ( reqInfo [ <NUM_LIT:0> ] , reqInfo [ <NUM_LIT:1> ] . trailingRevision ( ) , reqInfo [ <NUM_LIT:2> ] , depSet , job [ <NUM_LIT:0> ] , job [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] . trailingRevision ( ) , job [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] ) <EOL> log . debug ( msg , * args ) <EOL> break <EOL> oldTrv = self . db . getTrove ( withFiles = False , pristine = False , <EOL> * provInfo ) <EOL> newTrv = trvSrc . getTrove ( job [ <NUM_LIT:0> ] , job [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , job [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] , <EOL> withFiles = False ) <EOL> if oldTrv . compatibleWith ( newTrv ) : <EOL> restoreSet . add ( job ) <EOL> keepList . append ( ( job , depSet , reqInfo ) ) <EOL> cannotResolve . remove ( resolveInfo ) <EOL> msg = ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> args = ( reqInfo [ <NUM_LIT:0> ] , reqInfo [ <NUM_LIT:1> ] . trailingRevision ( ) , <EOL>", "answer": "reqInfo [ <NUM_LIT:2> ] , depSet ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import webapp2 <EOL> from webapp2_extras import jinja2 <EOL> class BaseHandler ( webapp2 . RequestHandler ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ webapp2 . cached_property <EOL> def jinja2 ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return jinja2 . get_jinja2 ( app = self . app ) <EOL> def render_response ( self , template , ** context ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rendered_value = self . jinja2 . render_template ( template , ** context ) <EOL>", "answer": "self . response . write ( rendered_value ) "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from timeit import timeit <EOL> import roles <EOL> setup_role = \"\"\"<STR_LIT>\"\"\" <EOL> setup_rolefactory = \"\"\"<STR_LIT>\"\"\" <EOL> setup_zope = \"\"\"<STR_LIT>\"\"\" <EOL> print '<STR_LIT>' % timeit ( '<STR_LIT>' , setup = setup_role ) <EOL> print '<STR_LIT>' % timeit ( '<STR_LIT>' , setup = setup_role ) <EOL> print '<STR_LIT>' % timeit ( '<STR_LIT>' , setup = setup_role ) <EOL> print '<STR_LIT>' % timeit ( '<STR_LIT>' , setup = setup_rolefactory ) <EOL> print '<STR_LIT>' % timeit ( '<STR_LIT>' , setup = setup_rolefactory ) <EOL> print '<STR_LIT>' % timeit ( '<STR_LIT>' , setup = setup_zope ) <EOL> def profile ( ) : <EOL> import cProfile <EOL> import pstats <EOL> from roles import RoleType <EOL> class A ( object ) : <EOL> def func ( self ) : pass <EOL> class Role ( object ) : <EOL> __metaclass__ = RoleType <EOL> def func ( self ) : pass <EOL> a = A ( ) <EOL>", "answer": "cProfile . run ( '<STR_LIT>' , '<STR_LIT>' )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import with_statement <EOL> import os , shlex <EOL> __all__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> class NetrcParseError ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , msg , filename = None , lineno = None ) : <EOL> self . filename = filename <EOL> self . lineno = lineno <EOL> self . msg = msg <EOL> Exception . __init__ ( self , msg ) <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . msg , self . filename , self . lineno ) <EOL> class netrc : <EOL> def __init__ ( self , file = None ) : <EOL> if file is None : <EOL> try : <EOL> file = os . path . join ( os . environ [ '<STR_LIT>' ] , \"<STR_LIT>\" ) <EOL> except KeyError : <EOL> raise IOError ( \"<STR_LIT>\" ) <EOL> self . hosts = { } <EOL> self . macros = { } <EOL> with open ( file ) as fp : <EOL> self . _parse ( file , fp ) <EOL> def _parse ( self , file , fp ) : <EOL> lexer = shlex . shlex ( fp ) <EOL> lexer . wordchars += r\"\"\"<STR_LIT>\"\"\" <EOL> lexer . commenters = lexer . commenters . replace ( '<STR_LIT:#>' , '<STR_LIT>' ) <EOL> while <NUM_LIT:1> : <EOL> toplevel = tt = lexer . get_token ( ) <EOL> if not tt : <EOL> break <EOL> elif tt [ <NUM_LIT:0> ] == '<STR_LIT:#>' : <EOL> fp . readline ( ) ; <EOL> continue ; <EOL> elif tt == '<STR_LIT>' : <EOL> entryname = lexer . get_token ( ) <EOL> elif tt == '<STR_LIT:default>' : <EOL> entryname = '<STR_LIT:default>' <EOL> elif tt == '<STR_LIT>' : <EOL> entryname = lexer . get_token ( ) <EOL> self . macros [ entryname ] = [ ] <EOL> lexer . whitespace = '<STR_LIT>' <EOL> while <NUM_LIT:1> : <EOL> line = lexer . instream . readline ( ) <EOL> if not line or line == '<STR_LIT>' : <EOL> lexer . whitespace = '<STR_LIT>' <EOL> break <EOL> self . macros [ entryname ] . append ( line ) <EOL> continue <EOL> else : <EOL> raise NetrcParseError ( <EOL> \"<STR_LIT>\" % tt , file , lexer . lineno ) <EOL> login = '<STR_LIT>' <EOL> account = password = None <EOL> self . hosts [ entryname ] = { } <EOL> while <NUM_LIT:1> : <EOL> tt = lexer . get_token ( ) <EOL> if ( tt == '<STR_LIT>' or tt == '<STR_LIT>' or <EOL> tt == '<STR_LIT:default>' or tt == '<STR_LIT>' ) : <EOL> if password : <EOL> self . hosts [ entryname ] = ( login , account , password ) <EOL> lexer . push_token ( tt ) <EOL> break <EOL> else : <EOL> raise NetrcParseError ( <EOL>", "answer": "\"<STR_LIT>\""}, {"prompt": "<s> import aiotest . run <EOL> import asyncio <EOL> import sys <EOL> if sys . platform == '<STR_LIT:win32>' : <EOL> from asyncio . windows_utils import socketpair <EOL> else : <EOL>", "answer": "from socket import socketpair"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from envisage . api import Plugin , ServiceOffer <EOL> from traits . api import List , Any <EOL> class EventManagerPlugin ( Plugin ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> id = '<STR_LIT>' <EOL> SERVICE_OFFERS = '<STR_LIT>' <EOL> service_offers = List ( contributes_to = SERVICE_OFFERS ) <EOL> def _service_offers_default ( self ) : <EOL>", "answer": "from encore . events . api import BaseEventManager , get_event_manager"}, {"prompt": "<s> from blocks . extensions import Timing , FinishAfter <EOL> from blocks . utils . testing import MockMainLoop <EOL> def test_timing ( ) : <EOL> main_loop = MockMainLoop ( extensions = [ Timing ( ) , <EOL>", "answer": "FinishAfter ( after_n_epochs = <NUM_LIT:2> ) ] )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import types <EOL> import string <EOL> from pyasn1 . type import error <EOL> class AbstractConstraint : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , * values ) : <EOL> self . _valueMap = { } <EOL> self . _setValues ( values ) <EOL> self . __hashedValues = None <EOL> def __call__ ( self , value , idx = None ) : <EOL> try : <EOL> self . _testValue ( value , idx ) <EOL> except error . ValueConstraintError , why : <EOL> raise error . ValueConstraintError ( '<STR_LIT>' % ( <EOL> self , why <EOL> ) ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> string . join ( map ( lambda x : str ( x ) , self . _values ) , '<STR_LIT:U+002CU+0020>' ) <EOL> ) <EOL> def __cmp__ ( self , other ) : <EOL> return self is other and <NUM_LIT:0> or cmp ( <EOL> ( self . __class__ , self . _values ) , other <EOL> ) <EOL> def __eq__ ( self , other ) : <EOL> return self is other or not cmp ( <EOL> ( self . __class__ , self . _values ) , other <EOL> ) <EOL> def __hash__ ( self ) : <EOL> if self . __hashedValues is None : <EOL> self . __hashedValues = hash ( ( self . __class__ , self . _values ) ) <EOL> return self . __hashedValues <EOL> def _setValues ( self , values ) : self . _values = values <EOL> def _testValue ( self , value , idx ) : <EOL> raise error . ValueConstraintError ( value ) <EOL> def getValueMap ( self ) : return self . _valueMap <EOL> def isSuperTypeOf ( self , otherConstraint ) : <EOL> return otherConstraint . getValueMap ( ) . has_key ( self ) or otherConstraint is self or otherConstraint == self <EOL> def isSubTypeOf ( self , otherConstraint ) : <EOL> return self . _valueMap . has_key ( otherConstraint ) or otherConstraint is self or otherConstraint == self <EOL> class SingleValueConstraint ( AbstractConstraint ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _testValue ( self , value , idx ) : <EOL> if value not in self . _values : <EOL> raise error . ValueConstraintError ( value ) <EOL> class ContainedSubtypeConstraint ( AbstractConstraint ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _testValue ( self , value , idx ) : <EOL> for c in self . _values : <EOL>", "answer": "c ( value , idx )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from Tkinter import * <EOL> import string , os <EOL> import textView <EOL> import idlever <EOL> class AboutDialog ( Toplevel ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , parent , title ) : <EOL> Toplevel . __init__ ( self , parent ) <EOL> self . configure ( borderwidth = <NUM_LIT:5> ) <EOL> self . geometry ( \"<STR_LIT>\" % ( parent . winfo_rootx ( ) + <NUM_LIT:30> , <EOL> parent . winfo_rooty ( ) + <NUM_LIT:30> ) ) <EOL> self . bg = \"<STR_LIT>\" <EOL> self . fg = \"<STR_LIT>\" <EOL> self . CreateWidgets ( ) <EOL> self . resizable ( height = FALSE , width = FALSE ) <EOL> self . title ( title ) <EOL> self . transient ( parent ) <EOL> self . grab_set ( ) <EOL> self . protocol ( \"<STR_LIT>\" , self . Ok ) <EOL> self . parent = parent <EOL> self . buttonOk . focus_set ( ) <EOL> self . bind ( '<STR_LIT>' , self . Ok ) <EOL> self . bind ( '<STR_LIT>' , self . Ok ) <EOL> self . wait_window ( ) <EOL> def CreateWidgets ( self ) : <EOL> frameMain = Frame ( self , borderwidth = <NUM_LIT:2> , relief = SUNKEN ) <EOL> frameButtons = Frame ( self ) <EOL> frameButtons . pack ( side = BOTTOM , fill = X ) <EOL> frameMain . pack ( side = TOP , expand = TRUE , fill = BOTH ) <EOL> self . buttonOk = Button ( frameButtons , text = '<STR_LIT>' , <EOL> command = self . Ok ) <EOL> self . buttonOk . pack ( padx = <NUM_LIT:5> , pady = <NUM_LIT:5> ) <EOL> frameBg = Frame ( frameMain , bg = self . bg ) <EOL> frameBg . pack ( expand = TRUE , fill = BOTH ) <EOL> labelTitle = Label ( frameBg , text = '<STR_LIT>' , fg = self . fg , bg = self . bg , <EOL> font = ( '<STR_LIT>' , <NUM_LIT> , '<STR_LIT>' ) ) <EOL> labelTitle . grid ( row = <NUM_LIT:0> , column = <NUM_LIT:0> , sticky = W , padx = <NUM_LIT:10> , pady = <NUM_LIT:10> ) <EOL> byline = \"<STR_LIT>\" + <NUM_LIT:5> * '<STR_LIT:\\n>' <EOL> labelDesc = Label ( frameBg , text = byline , justify = LEFT , <EOL> fg = self . fg , bg = self . bg ) <EOL> labelDesc . grid ( row = <NUM_LIT:2> , column = <NUM_LIT:0> , sticky = W , columnspan = <NUM_LIT:3> , padx = <NUM_LIT:10> , pady = <NUM_LIT:5> ) <EOL> labelEmail = Label ( frameBg , text = '<STR_LIT>' , <EOL> justify = LEFT , fg = self . fg , bg = self . bg ) <EOL> labelEmail . grid ( row = <NUM_LIT:6> , column = <NUM_LIT:0> , columnspan = <NUM_LIT:2> , <EOL> sticky = W , padx = <NUM_LIT:10> , pady = <NUM_LIT:0> ) <EOL> labelWWW = Label ( frameBg , text = '<STR_LIT>' , <EOL> justify = LEFT , fg = self . fg , bg = self . bg ) <EOL> labelWWW . grid ( row = <NUM_LIT:7> , column = <NUM_LIT:0> , columnspan = <NUM_LIT:2> , sticky = W , padx = <NUM_LIT:10> , pady = <NUM_LIT:0> ) <EOL> Frame ( frameBg , borderwidth = <NUM_LIT:1> , relief = SUNKEN , <EOL> height = <NUM_LIT:2> , bg = self . bg ) . grid ( row = <NUM_LIT:8> , column = <NUM_LIT:0> , sticky = EW , <EOL> columnspan = <NUM_LIT:3> , padx = <NUM_LIT:5> , pady = <NUM_LIT:5> ) <EOL> labelPythonVer = Label ( frameBg , text = '<STR_LIT>' + sys . version . split ( ) [ <NUM_LIT:0> ] , fg = self . fg , bg = self . bg ) <EOL> labelPythonVer . grid ( row = <NUM_LIT:9> , column = <NUM_LIT:0> , sticky = W , padx = <NUM_LIT:10> , pady = <NUM_LIT:0> ) <EOL> tkVer = repr ( TkVersion ) . split ( '<STR_LIT:.>' ) <EOL> tkVer [ len ( tkVer ) - <NUM_LIT:1> ] = str ( '<STR_LIT>' % ( float ( '<STR_LIT:.>' + tkVer [ len ( tkVer ) - <NUM_LIT:1> ] ) ) ) [ <NUM_LIT:2> : ] <EOL> if tkVer [ len ( tkVer ) - <NUM_LIT:1> ] == '<STR_LIT>' : <EOL> tkVer [ len ( tkVer ) - <NUM_LIT:1> ] = '<STR_LIT:0>' <EOL> tkVer = string . join ( tkVer , '<STR_LIT:.>' ) <EOL> labelTkVer = Label ( frameBg , text = '<STR_LIT>' + <EOL> tkVer , fg = self . fg , bg = self . bg ) <EOL> labelTkVer . grid ( row = <NUM_LIT:9> , column = <NUM_LIT:1> , sticky = W , padx = <NUM_LIT:2> , pady = <NUM_LIT:0> ) <EOL> py_button_f = Frame ( frameBg , bg = self . bg ) <EOL> py_button_f . grid ( row = <NUM_LIT:10> , column = <NUM_LIT:0> , columnspan = <NUM_LIT:2> , sticky = NSEW ) <EOL> buttonLicense = Button ( py_button_f , text = '<STR_LIT>' , width = <NUM_LIT:8> , <EOL> highlightbackground = self . bg , <EOL> command = self . ShowLicense ) <EOL> buttonLicense . pack ( side = LEFT , padx = <NUM_LIT:10> , pady = <NUM_LIT:10> ) <EOL> buttonCopyright = Button ( py_button_f , text = '<STR_LIT>' , width = <NUM_LIT:8> , <EOL> highlightbackground = self . bg , <EOL> command = self . ShowCopyright ) <EOL> buttonCopyright . pack ( side = LEFT , padx = <NUM_LIT:10> , pady = <NUM_LIT:10> ) <EOL> buttonCredits = Button ( py_button_f , text = '<STR_LIT>' , width = <NUM_LIT:8> , <EOL> highlightbackground = self . bg , <EOL> command = self . ShowPythonCredits ) <EOL> buttonCredits . pack ( side = LEFT , padx = <NUM_LIT:10> , pady = <NUM_LIT:10> ) <EOL> Frame ( frameBg , borderwidth = <NUM_LIT:1> , relief = SUNKEN , <EOL> height = <NUM_LIT:2> , bg = self . bg ) . grid ( row = <NUM_LIT:11> , column = <NUM_LIT:0> , sticky = EW , <EOL> columnspan = <NUM_LIT:3> , padx = <NUM_LIT:5> , pady = <NUM_LIT:5> ) <EOL> idle_v = Label ( frameBg , text = '<STR_LIT>' + idlever . IDLE_VERSION , <EOL> fg = self . fg , bg = self . bg ) <EOL> idle_v . grid ( row = <NUM_LIT:12> , column = <NUM_LIT:0> , sticky = W , padx = <NUM_LIT:10> , pady = <NUM_LIT:0> ) <EOL> idle_button_f = Frame ( frameBg , bg = self . bg ) <EOL> idle_button_f . grid ( row = <NUM_LIT> , column = <NUM_LIT:0> , columnspan = <NUM_LIT:3> , sticky = NSEW ) <EOL> idle_about_b = Button ( idle_button_f , text = '<STR_LIT>' , width = <NUM_LIT:8> , <EOL> highlightbackground = self . bg , <EOL> command = self . ShowIDLEAbout ) <EOL> idle_about_b . pack ( side = LEFT , padx = <NUM_LIT:10> , pady = <NUM_LIT:10> ) <EOL> idle_news_b = Button ( idle_button_f , text = '<STR_LIT>' , width = <NUM_LIT:8> , <EOL> highlightbackground = self . bg , <EOL> command = self . ShowIDLENEWS ) <EOL> idle_news_b . pack ( side = LEFT , padx = <NUM_LIT:10> , pady = <NUM_LIT:10> ) <EOL> idle_credits_b = Button ( idle_button_f , text = '<STR_LIT>' , width = <NUM_LIT:8> , <EOL> highlightbackground = self . bg , <EOL> command = self . ShowIDLECredits ) <EOL> idle_credits_b . pack ( side = LEFT , padx = <NUM_LIT:10> , pady = <NUM_LIT:10> ) <EOL> def ShowLicense ( self ) : <EOL> self . display_printer_text ( license , '<STR_LIT>' ) <EOL> def ShowCopyright ( self ) : <EOL> self . display_printer_text ( copyright , '<STR_LIT>' ) <EOL> def ShowPythonCredits ( self ) : <EOL> self . display_printer_text ( credits , '<STR_LIT>' ) <EOL> def ShowIDLECredits ( self ) : <EOL> self . ViewFile ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def ShowIDLEAbout ( self ) : <EOL> self . ViewFile ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def ShowIDLENEWS ( self ) : <EOL> self . ViewFile ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def display_printer_text ( self , printer , title ) : <EOL> printer . _Printer__setup ( ) <EOL> data = '<STR_LIT:\\n>' . join ( printer . _Printer__lines ) <EOL> textView . TextViewer ( self , title , None , data ) <EOL> def ViewFile ( self , viewTitle , viewFile , encoding = None ) : <EOL> fn = os . path . join ( os . path . abspath ( os . path . dirname ( __file__ ) ) , viewFile ) <EOL> if encoding : <EOL> import codecs <EOL> try : <EOL> textFile = codecs . open ( fn , '<STR_LIT:r>' ) <EOL> except IOError : <EOL> import tkMessageBox <EOL> tkMessageBox . showerror ( title = '<STR_LIT>' , <EOL> message = '<STR_LIT>' % ( fn , ) , <EOL>", "answer": "parent = self )"}, {"prompt": "<s> from __future__ import absolute_import <EOL> import os <EOL> import urlparse <EOL> from salt . ext . six . moves . urllib . parse import urlparse <EOL> from mako . lookup import TemplateCollection , TemplateLookup <EOL> import salt . fileclient <EOL> import salt . utils . url <EOL> class SaltMakoTemplateLookup ( TemplateCollection ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , opts , saltenv = '<STR_LIT>' , pillar_rend = False ) : <EOL> self . opts = opts <EOL> self . saltenv = saltenv <EOL> self . _file_client = None <EOL> self . pillar_rend = pillar_rend <EOL> self . lookup = TemplateLookup ( directories = '<STR_LIT:/>' ) <EOL> self . cache = { } <EOL> def file_client ( self ) : <EOL> '''<STR_LIT>''' <EOL> if not self . _file_client : <EOL> self . _file_client = salt . fileclient . get_file_client ( <EOL> self . opts , self . pillar_rend ) <EOL> return self . _file_client <EOL> def adjust_uri ( self , uri , filename ) : <EOL> scheme = urlparse ( uri ) . scheme <EOL>", "answer": "if scheme in ( '<STR_LIT>' , '<STR_LIT:file>' ) :"}, {"prompt": "<s> from enum import Enum <EOL> class OSType ( Enum ) : <EOL> linux = \"<STR_LIT>\" <EOL> windows = \"<STR_LIT>\" <EOL> unmapped = \"<STR_LIT>\" <EOL> class CertificateState ( Enum ) : <EOL> active = \"<STR_LIT>\" <EOL> deleting = \"<STR_LIT>\" <EOL> deletefailed = \"<STR_LIT>\" <EOL> class CertificateFormat ( Enum ) : <EOL> pfx = \"<STR_LIT>\" <EOL> cer = \"<STR_LIT>\" <EOL> unmapped = \"<STR_LIT>\" <EOL> class ComputeNodeFillType ( Enum ) : <EOL> spread = \"<STR_LIT>\" <EOL> pack = \"<STR_LIT>\" <EOL> unmapped = \"<STR_LIT>\" <EOL> class CertificateStoreLocation ( Enum ) : <EOL> currentuser = \"<STR_LIT>\" <EOL> localmachine = \"<STR_LIT>\" <EOL> unmapped = \"<STR_LIT>\" <EOL> class CertificateVisibility ( Enum ) : <EOL> starttask = \"<STR_LIT>\" <EOL> task = \"<STR_LIT>\" <EOL> remoteuser = \"<STR_LIT>\" <EOL> unmapped = \"<STR_LIT>\" <EOL> class PoolLifetimeOption ( Enum ) : <EOL> jobschedule = \"<STR_LIT>\" <EOL> job = \"<STR_LIT>\" <EOL> unmapped = \"<STR_LIT>\" <EOL> class JobScheduleState ( Enum ) : <EOL> active = \"<STR_LIT>\" <EOL> completed = \"<STR_LIT>\" <EOL> disabled = \"<STR_LIT>\" <EOL> terminating = \"<STR_LIT>\" <EOL> deleting = \"<STR_LIT>\" <EOL> class SchedulingErrorCategory ( Enum ) : <EOL> usererror = \"<STR_LIT>\" <EOL> servererror = \"<STR_LIT>\" <EOL> unmapped = \"<STR_LIT>\" <EOL> class JobState ( Enum ) : <EOL> active = \"<STR_LIT>\" <EOL> disabling = \"<STR_LIT>\" <EOL> disabled = \"<STR_LIT>\" <EOL> enabling = \"<STR_LIT>\" <EOL> terminating = \"<STR_LIT>\" <EOL> completed = \"<STR_LIT>\" <EOL> deleting = \"<STR_LIT>\" <EOL> class JobPreparationTaskState ( Enum ) : <EOL> running = \"<STR_LIT>\" <EOL> completed = \"<STR_LIT>\" <EOL> class JobReleaseTaskState ( Enum ) : <EOL> running = \"<STR_LIT>\" <EOL> completed = \"<STR_LIT>\" <EOL> class PoolState ( Enum ) : <EOL> active = \"<STR_LIT>\" <EOL> deleting = \"<STR_LIT>\" <EOL> upgrading = \"<STR_LIT>\" <EOL> class AllocationState ( Enum ) : <EOL> steady = \"<STR_LIT>\" <EOL> resizing = \"<STR_LIT>\" <EOL> stopping = \"<STR_LIT>\" <EOL> class TaskState ( Enum ) : <EOL> active = \"<STR_LIT>\" <EOL> preparing = \"<STR_LIT>\" <EOL> running = \"<STR_LIT>\" <EOL> completed = \"<STR_LIT>\" <EOL> class TaskAddStatus ( Enum ) : <EOL> success = \"<STR_LIT:success>\" <EOL> clienterror = \"<STR_LIT>\" <EOL> servererror = \"<STR_LIT>\" <EOL> unmapped = \"<STR_LIT>\" <EOL> class StartTaskState ( Enum ) : <EOL> running = \"<STR_LIT>\" <EOL> completed = \"<STR_LIT>\" <EOL> class ComputeNodeState ( Enum ) : <EOL> idle = \"<STR_LIT>\" <EOL> rebooting = \"<STR_LIT>\" <EOL> reimaging = \"<STR_LIT>\" <EOL> running = \"<STR_LIT>\" <EOL> unusable = \"<STR_LIT>\" <EOL> creating = \"<STR_LIT>\" <EOL> starting = \"<STR_LIT>\" <EOL> waitingforstarttask = \"<STR_LIT>\" <EOL> starttaskfailed = \"<STR_LIT>\" <EOL> unknown = \"<STR_LIT>\" <EOL> leavingpool = \"<STR_LIT>\" <EOL> offline = \"<STR_LIT>\" <EOL> class SchedulingState ( Enum ) : <EOL> enabled = \"<STR_LIT>\" <EOL>", "answer": "disabled = \"<STR_LIT>\""}, {"prompt": "<s> import falcon <EOL> from falcon import testing <EOL> def capture_error ( ex , req , resp , params ) : <EOL> resp . status = falcon . HTTP_723 <EOL> resp . body = '<STR_LIT>' % str ( ex ) <EOL> def handle_error_first ( ex , req , resp , params ) : <EOL> resp . status = falcon . HTTP_200 <EOL> resp . body = '<STR_LIT>' <EOL> class CustomBaseException ( Exception ) : <EOL> pass <EOL> class CustomException ( CustomBaseException ) : <EOL> @ staticmethod <EOL> def handle ( ex , req , resp , params ) : <EOL> raise falcon . HTTPError ( <EOL> falcon . HTTP_792 , <EOL> u'<STR_LIT>' , <EOL> u'<STR_LIT>' , <EOL> href = u'<STR_LIT>' , <EOL> href_text = u'<STR_LIT>' ) <EOL> class ErroredClassResource ( object ) : <EOL> def on_get ( self , req , resp ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> def on_head ( self , req , resp ) : <EOL> raise CustomBaseException ( '<STR_LIT>' ) <EOL> def on_delete ( self , req , resp ) : <EOL> raise CustomException ( '<STR_LIT>' ) <EOL> class TestErrorHandler ( testing . TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( TestErrorHandler , self ) . setUp ( ) <EOL> self . api . add_route ( '<STR_LIT:/>' , ErroredClassResource ( ) ) <EOL> def test_caught_error ( self ) : <EOL> self . api . add_error_handler ( Exception , capture_error ) <EOL> result = self . simulate_get ( ) <EOL> self . assertEqual ( result . text , '<STR_LIT>' ) <EOL> result = self . simulate_head ( ) <EOL> self . assertEqual ( result . status_code , <NUM_LIT> ) <EOL> self . assertFalse ( result . content ) <EOL> def test_uncaught_error ( self ) : <EOL> self . api . add_error_handler ( CustomException , capture_error ) <EOL> self . assertRaises ( Exception , self . simulate_get ) <EOL> def test_uncaught_error_else ( self ) : <EOL> self . assertRaises ( Exception , self . simulate_get ) <EOL> def test_converted_error ( self ) : <EOL> self . api . add_error_handler ( CustomException ) <EOL> result = self . simulate_delete ( ) <EOL>", "answer": "self . assertEqual ( result . status_code , <NUM_LIT> )"}, {"prompt": "<s> from parakeet . testing_helpers import expect , run_local_tests <EOL> def implicit_to_float ( x ) : <EOL> return x + <NUM_LIT:0.5> <EOL>", "answer": "def test_implicit_to_float ( ) :"}, {"prompt": "<s> from __future__ import absolute_import <EOL> from __future__ import division <EOL> from __future__ import print_function <EOL> from functools import partial <EOL> __all__ = [ '<STR_LIT>' ] <EOL> class MessageBoard ( object ) : <EOL> def __init__ ( self , loop ) : <EOL> super ( MessageBoard , self ) . __init__ ( ) <EOL> self . _loop = loop <EOL> self . _subscribers = { } <EOL> def _call_subscribers ( self , topic , * args , ** kwargs ) : <EOL> for ancestor_topic in topic : <EOL> if ancestor_topic in self . _subscribers : <EOL> for subscriber in self . _subscribers [ ancestor_topic ] : <EOL> subscriber ( topic , * args , ** kwargs ) <EOL> def publish ( self , topic , * args , ** kwargs ) : <EOL> self . _loop . call_soon ( partial ( self . _call_subscribers , topic , * args , <EOL> ** kwargs ) ) <EOL> def subscribe ( self , topic , subscriber ) : <EOL> if topic not in self . _subscribers : <EOL> self . _subscribers [ topic ] = [ ] <EOL> if subscriber not in self . _subscribers [ topic ] : <EOL> self . _subscribers [ topic ] . append ( subscriber ) <EOL> def unsubscribe ( self , topic , subscriber ) : <EOL> has_subscribers = topic in self . _subscribers <EOL> if has_subscribers and subscriber in self . _subscribers [ topic ] : <EOL> self . _subscribers [ topic ] . remove ( subscriber ) <EOL> if not self . _subscribers [ topic ] : <EOL>", "answer": "del self . _subscribers [ topic ] "}, {"prompt": "<s> import unittest <EOL> from spyder . core . settings import Settings <EOL> from spyder . core . dnscache import DnsCache <EOL> from spyder . core . queueassignment import HostBasedQueueAssignment <EOL> from spyder . core . queueassignment import IpBasedQueueAssignment <EOL> class HostBasedQueueAssignmentTest ( unittest . TestCase ) : <EOL> def test_host_based_assignment ( self ) : <EOL> s = Settings ( ) <EOL>", "answer": "dns = DnsCache ( s )"}, {"prompt": "<s> import os <EOL> import argparse <EOL> import subprocess <EOL> import time <EOL> parser = argparse . ArgumentParser ( ) <EOL> parser . add_argument ( '<STR_LIT>' , default = '<STR_LIT>' ) <EOL>", "answer": "parser . add_argument ( '<STR_LIT>' , default = '<STR_LIT>' )"}, {"prompt": "<s> import unittest <EOL> import threading <EOL> import weakref <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> class ContextTest ( GafferTest . TestCase ) : <EOL> def testFrameAccess ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> self . assertEqual ( c . getFrame ( ) , <NUM_LIT:1.0> ) <EOL> self . assertEqual ( c [ \"<STR_LIT>\" ] , <NUM_LIT:1.0> ) <EOL> c . setFrame ( <NUM_LIT> ) <EOL> self . assertEqual ( c . getFrame ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( c [ \"<STR_LIT>\" ] , <NUM_LIT> ) <EOL> def testChangedSignal ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> changes = [ ] <EOL> def f ( context , name ) : <EOL> self . failUnless ( context . isSame ( c ) ) <EOL> changes . append ( ( name , context [ name ] ) ) <EOL> cn = c . changedSignal ( ) . connect ( f ) <EOL> c [ \"<STR_LIT:a>\" ] = <NUM_LIT:2> <EOL> self . assertEqual ( changes , [ ( \"<STR_LIT:a>\" , <NUM_LIT:2> ) ] ) <EOL> c [ \"<STR_LIT:a>\" ] = <NUM_LIT:3> <EOL> self . assertEqual ( changes , [ ( \"<STR_LIT:a>\" , <NUM_LIT:2> ) , ( \"<STR_LIT:a>\" , <NUM_LIT:3> ) ] ) <EOL> c [ \"<STR_LIT:b>\" ] = <NUM_LIT:1> <EOL> self . assertEqual ( changes , [ ( \"<STR_LIT:a>\" , <NUM_LIT:2> ) , ( \"<STR_LIT:a>\" , <NUM_LIT:3> ) , ( \"<STR_LIT:b>\" , <NUM_LIT:1> ) ] ) <EOL> c [ \"<STR_LIT:b>\" ] = <NUM_LIT:1> <EOL> self . assertEqual ( changes , [ ( \"<STR_LIT:a>\" , <NUM_LIT:2> ) , ( \"<STR_LIT:a>\" , <NUM_LIT:3> ) , ( \"<STR_LIT:b>\" , <NUM_LIT:1> ) ] ) <EOL> def testTypes ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> c [ \"<STR_LIT:int>\" ] = <NUM_LIT:1> <EOL> self . assertEqual ( c [ \"<STR_LIT:int>\" ] , <NUM_LIT:1> ) <EOL> self . assertEqual ( c . get ( \"<STR_LIT:int>\" ) , <NUM_LIT:1> ) <EOL> c . set ( \"<STR_LIT:int>\" , <NUM_LIT:2> ) <EOL> self . assertEqual ( c [ \"<STR_LIT:int>\" ] , <NUM_LIT:2> ) <EOL> self . failUnless ( isinstance ( c [ \"<STR_LIT:int>\" ] , int ) ) <EOL> c [ \"<STR_LIT:float>\" ] = <NUM_LIT:1.0> <EOL> self . assertEqual ( c [ \"<STR_LIT:float>\" ] , <NUM_LIT:1.0> ) <EOL> self . assertEqual ( c . get ( \"<STR_LIT:float>\" ) , <NUM_LIT:1.0> ) <EOL> c . set ( \"<STR_LIT:float>\" , <NUM_LIT> ) <EOL> self . assertEqual ( c [ \"<STR_LIT:float>\" ] , <NUM_LIT> ) <EOL> self . failUnless ( isinstance ( c [ \"<STR_LIT:float>\" ] , float ) ) <EOL> c [ \"<STR_LIT:string>\" ] = \"<STR_LIT>\" <EOL> self . assertEqual ( c [ \"<STR_LIT:string>\" ] , \"<STR_LIT>\" ) <EOL> self . assertEqual ( c . get ( \"<STR_LIT:string>\" ) , \"<STR_LIT>\" ) <EOL> c . set ( \"<STR_LIT:string>\" , \"<STR_LIT>\" ) <EOL> self . assertEqual ( c [ \"<STR_LIT:string>\" ] , \"<STR_LIT>\" ) <EOL> self . failUnless ( isinstance ( c [ \"<STR_LIT:string>\" ] , basestring ) ) <EOL> def testCopying ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> c [ \"<STR_LIT:i>\" ] = <NUM_LIT:10> <EOL> c2 = Gaffer . Context ( c ) <EOL> self . assertEqual ( c2 [ \"<STR_LIT:i>\" ] , <NUM_LIT:10> ) <EOL> c [ \"<STR_LIT:i>\" ] = <NUM_LIT:1> <EOL> self . assertEqual ( c [ \"<STR_LIT:i>\" ] , <NUM_LIT:1> ) <EOL> self . assertEqual ( c2 [ \"<STR_LIT:i>\" ] , <NUM_LIT:10> ) <EOL> def testEquality ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> c2 = Gaffer . Context ( ) <EOL> self . assertEqual ( c , c2 ) <EOL> self . failIf ( c != c2 ) <EOL> c [ \"<STR_LIT>\" ] = <NUM_LIT:1> <EOL> self . assertNotEqual ( c , c2 ) <EOL> self . failIf ( c == c2 ) <EOL> def testCurrent ( self ) : <EOL> c = Gaffer . Context . current ( ) <EOL> c2 = Gaffer . Context ( ) <EOL> self . assertEqual ( c , c2 ) <EOL> c2 [ \"<STR_LIT>\" ] = <NUM_LIT:1> <EOL> with c2 : <EOL> self . failUnless ( Gaffer . Context . current ( ) . isSame ( c2 ) ) <EOL> self . assertEqual ( Gaffer . Context . current ( ) [ \"<STR_LIT>\" ] , <NUM_LIT:1> ) <EOL> self . failUnless ( Gaffer . Context . current ( ) . isSame ( c ) ) <EOL> def testCurrentIsThreadSpecific ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> self . failIf ( c . isSame ( Gaffer . Context . current ( ) ) ) <EOL> def f ( ) : <EOL> self . failIf ( c . isSame ( Gaffer . Context . current ( ) ) ) <EOL> with Gaffer . Context ( ) : <EOL> pass <EOL> with c : <EOL> self . failUnless ( c . isSame ( Gaffer . Context . current ( ) ) ) <EOL> t = threading . Thread ( target = f ) <EOL> t . start ( ) <EOL> t . join ( ) <EOL> self . failUnless ( c . isSame ( Gaffer . Context . current ( ) ) ) <EOL> self . failIf ( c . isSame ( Gaffer . Context . current ( ) ) ) <EOL> def testThreading ( self ) : <EOL> threads = [ ] <EOL> for i in range ( <NUM_LIT:0> , <NUM_LIT:1000> ) : <EOL> t = threading . Thread ( target = self . testCurrent ) <EOL> t . start ( ) <EOL> threads . append ( t ) <EOL> for t in threads : <EOL> t . join ( ) <EOL> def testSetWithObject ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> v = IECore . StringVectorData ( [ \"<STR_LIT:a>\" , \"<STR_LIT:b>\" , \"<STR_LIT:c>\" ] ) <EOL> c . set ( \"<STR_LIT:v>\" , v ) <EOL> self . assertEqual ( c . get ( \"<STR_LIT:v>\" ) , v ) <EOL> self . failIf ( c . get ( \"<STR_LIT:v>\" ) . isSame ( v ) ) <EOL> self . assertEqual ( c [ \"<STR_LIT:v>\" ] , v ) <EOL> self . failIf ( c [ \"<STR_LIT:v>\" ] . isSame ( v ) ) <EOL> def testGetWithDefault ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> self . assertRaises ( RuntimeError , c . get , \"<STR_LIT:f>\" ) <EOL> self . assertEqual ( c . get ( \"<STR_LIT:f>\" , <NUM_LIT:10> ) , <NUM_LIT:10> ) <EOL> c [ \"<STR_LIT:f>\" ] = <NUM_LIT:1.0> <EOL> self . assertEqual ( c . get ( \"<STR_LIT:f>\" ) , <NUM_LIT:1.0> ) <EOL> def testReentrancy ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> with c : <EOL> self . failUnless ( c . isSame ( Gaffer . Context . current ( ) ) ) <EOL> with c : <EOL> self . failUnless ( c . isSame ( Gaffer . Context . current ( ) ) ) <EOL> def testLifeTime ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> w = weakref . ref ( c ) <EOL> self . failUnless ( w ( ) is c ) <EOL> with c : <EOL> pass <EOL> del c <EOL> self . failUnless ( w ( ) is None ) <EOL> def testWithBlockReturnValue ( self ) : <EOL> with Gaffer . Context ( ) as c : <EOL> self . failUnless ( isinstance ( c , Gaffer . Context ) ) <EOL> self . failUnless ( c . isSame ( Gaffer . Context . current ( ) ) ) <EOL> def testSubstitute ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> c . setFrame ( <NUM_LIT:20> ) <EOL> c [ \"<STR_LIT:a>\" ] = \"<STR_LIT>\" <EOL> c [ \"<STR_LIT:b>\" ] = \"<STR_LIT>\" <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> def testSubstituteTildeInMiddle ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> def testSubstituteWithMask ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> c . setFrame ( <NUM_LIT:20> ) <EOL> c [ \"<STR_LIT:a>\" ] = \"<STR_LIT>\" <EOL> c [ \"<STR_LIT:b>\" ] = \"<STR_LIT>\" <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT>\" , c . Substitutions . AllSubstitutions & ~ c . Substitutions . TildeSubstitutions ) , \"<STR_LIT>\" ) <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT:#>\" , c . Substitutions . AllSubstitutions & ~ c . Substitutions . FrameSubstitutions ) , \"<STR_LIT:#>\" ) <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT>\" , c . Substitutions . AllSubstitutions & ~ c . Substitutions . VariableSubstitutions ) , \"<STR_LIT>\" ) <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT:\\\\>\" , c . Substitutions . AllSubstitutions & ~ c . Substitutions . EscapeSubstitutions ) , \"<STR_LIT:\\\\>\" ) <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT>\" , c . Substitutions . AllSubstitutions & ~ c . Substitutions . EscapeSubstitutions ) , \"<STR_LIT>\" ) <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT>\" , c . Substitutions . AllSubstitutions & ~ c . Substitutions . FrameSubstitutions ) , \"<STR_LIT>\" ) <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT>\" , c . Substitutions . NoSubstitutions ) , \"<STR_LIT>\" ) <EOL> def testFrameAndVariableSubstitutionsAreDifferent ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> c . setFrame ( <NUM_LIT:3> ) <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT>\" , c . Substitutions . AllSubstitutions & ~ c . Substitutions . VariableSubstitutions ) , \"<STR_LIT>\" ) <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) <EOL> self . assertEqual ( c . substitute ( \"<STR_LIT>\" , c . Substitutions . AllSubstitutions & ~ c . Substitutions . FrameSubstitutions ) , \"<STR_LIT>\" ) <EOL> def testSubstitutions ( self ) : <EOL> c = Gaffer . Context <EOL> self . assertEqual ( c . substitutions ( \"<STR_LIT:a>\" ) , c . Substitutions . NoSubstitutions ) <EOL> self . assertEqual ( c . substitutions ( \"<STR_LIT>\" ) , c . Substitutions . TildeSubstitutions ) <EOL> self . assertEqual ( c . substitutions ( \"<STR_LIT>\" ) , c . Substitutions . VariableSubstitutions ) <EOL> self . assertEqual ( c . substitutions ( \"<STR_LIT>\" ) , c . Substitutions . VariableSubstitutions ) <EOL> self . assertEqual ( c . substitutions ( \"<STR_LIT>\" ) , c . Substitutions . FrameSubstitutions ) <EOL> self . assertEqual ( c . substitutions ( \"<STR_LIT>\" ) , c . Substitutions . EscapeSubstitutions ) <EOL> self . assertEqual ( c . substitutions ( \"<STR_LIT>\" ) , c . Substitutions . VariableSubstitutions | c . Substitutions . FrameSubstitutions ) <EOL> def testHasSubstitutions ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> self . assertFalse ( c . hasSubstitutions ( \"<STR_LIT:a>\" ) ) <EOL> self . assertTrue ( c . hasSubstitutions ( \"<STR_LIT>\" ) ) <EOL> self . assertTrue ( c . hasSubstitutions ( \"<STR_LIT>\" ) ) <EOL> self . assertTrue ( c . hasSubstitutions ( \"<STR_LIT>\" ) ) <EOL> self . assertTrue ( c . hasSubstitutions ( \"<STR_LIT>\" ) ) <EOL> def testNames ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> self . assertEqual ( set ( c . names ( ) ) , set ( [ \"<STR_LIT>\" , \"<STR_LIT>\" ] ) ) <EOL> c [ \"<STR_LIT:a>\" ] = <NUM_LIT:10> <EOL> self . assertEqual ( set ( c . names ( ) ) , set ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:a>\" ] ) ) <EOL> cc = Gaffer . Context ( c ) <EOL> self . assertEqual ( set ( cc . names ( ) ) , set ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:a>\" ] ) ) <EOL> cc [ \"<STR_LIT:b>\" ] = <NUM_LIT:20> <EOL> self . assertEqual ( set ( cc . names ( ) ) , set ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:a>\" , \"<STR_LIT:b>\" ] ) ) <EOL> self . assertEqual ( set ( c . names ( ) ) , set ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT:a>\" ] ) ) <EOL> self . assertEqual ( cc . names ( ) , cc . keys ( ) ) <EOL> def testManyContexts ( self ) : <EOL> GafferTest . testManyContexts ( ) <EOL> def testGetWithAndWithoutCopying ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> c [ \"<STR_LIT:test>\" ] = IECore . IntVectorData ( [ <NUM_LIT:1> , <NUM_LIT:2> ] ) <EOL> self . assertFalse ( c [ \"<STR_LIT:test>\" ] . isSame ( c [ \"<STR_LIT:test>\" ] ) ) <EOL> c [ \"<STR_LIT:test>\" ] . append ( <NUM_LIT:10> ) <EOL> self . assertEqual ( c [ \"<STR_LIT:test>\" ] , IECore . IntVectorData ( [ <NUM_LIT:1> , <NUM_LIT:2> ] ) ) <EOL> self . assertTrue ( c . get ( \"<STR_LIT:test>\" , _copy = False ) . isSame ( c . get ( \"<STR_LIT:test>\" , _copy = False ) ) ) <EOL> c . get ( \"<STR_LIT:test>\" , _copy = False ) . append ( <NUM_LIT:10> ) <EOL> self . assertEqual ( c [ \"<STR_LIT:test>\" ] , IECore . IntVectorData ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:10> ] ) ) <EOL> def testGetWithDefaultAndCopyArgs ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> c [ \"<STR_LIT:test>\" ] = IECore . IntVectorData ( [ <NUM_LIT:1> , <NUM_LIT:2> ] ) <EOL> self . assertTrue ( c . get ( \"<STR_LIT:test>\" , <NUM_LIT:10> , _copy = False ) . isSame ( c . get ( \"<STR_LIT:test>\" , <NUM_LIT:20> , _copy = False ) ) ) <EOL> self . assertTrue ( c . get ( \"<STR_LIT:test>\" , defaultValue = <NUM_LIT:10> , _copy = False ) . isSame ( c . get ( \"<STR_LIT:test>\" , defaultValue = <NUM_LIT:20> , _copy = False ) ) ) <EOL> def testCopyWithSharedOwnership ( self ) : <EOL> c1 = Gaffer . Context ( ) <EOL> c1 [ \"<STR_LIT>\" ] = <NUM_LIT:10> <EOL> c1 [ \"<STR_LIT>\" ] = IECore . IntVectorData ( [ <NUM_LIT:10> ] ) <EOL> self . assertEqual ( c1 [ \"<STR_LIT>\" ] , <NUM_LIT:10> ) <EOL> self . assertEqual ( c1 [ \"<STR_LIT>\" ] , IECore . IntVectorData ( [ <NUM_LIT:10> ] ) ) <EOL> r = c1 . get ( \"<STR_LIT>\" , _copy = False ) . refCount ( ) <EOL> c2 = Gaffer . Context ( c1 , ownership = Gaffer . Context . Ownership . Shared ) <EOL> self . assertEqual ( c2 [ \"<STR_LIT>\" ] , <NUM_LIT:10> ) <EOL> self . assertEqual ( c2 [ \"<STR_LIT>\" ] , IECore . IntVectorData ( [ <NUM_LIT:10> ] ) ) <EOL> c1 [ \"<STR_LIT>\" ] = <NUM_LIT:20> <EOL> self . assertEqual ( c1 [ \"<STR_LIT>\" ] , <NUM_LIT:20> ) <EOL> self . assertEqual ( c2 [ \"<STR_LIT>\" ] , <NUM_LIT:20> ) <EOL> self . assertTrue ( c2 . get ( \"<STR_LIT>\" , _copy = False ) . isSame ( c1 . get ( \"<STR_LIT>\" , _copy = False ) ) ) <EOL> self . assertEqual ( c2 . get ( \"<STR_LIT>\" , _copy = False ) . refCount ( ) , r + <NUM_LIT:1> ) <EOL> del c1 <EOL> self . assertEqual ( c2 [ \"<STR_LIT>\" ] , <NUM_LIT:20> ) <EOL> self . assertEqual ( c2 [ \"<STR_LIT>\" ] , IECore . IntVectorData ( [ <NUM_LIT:10> ] ) ) <EOL> self . assertEqual ( c2 . get ( \"<STR_LIT>\" , _copy = False ) . refCount ( ) , r ) <EOL> def testCopyWithBorrowedOwnership ( self ) : <EOL> c1 = Gaffer . Context ( ) <EOL> c1 [ \"<STR_LIT>\" ] = <NUM_LIT:10> <EOL> c1 [ \"<STR_LIT>\" ] = IECore . IntVectorData ( [ <NUM_LIT:10> ] ) <EOL> self . assertEqual ( c1 [ \"<STR_LIT>\" ] , <NUM_LIT:10> ) <EOL> self . assertEqual ( c1 [ \"<STR_LIT>\" ] , IECore . IntVectorData ( [ <NUM_LIT:10> ] ) ) <EOL> r = c1 . get ( \"<STR_LIT>\" , _copy = False ) . refCount ( ) <EOL> c2 = Gaffer . Context ( c1 , ownership = Gaffer . Context . Ownership . Borrowed ) <EOL> self . assertEqual ( c2 [ \"<STR_LIT>\" ] , <NUM_LIT:10> ) <EOL> self . assertEqual ( c2 [ \"<STR_LIT>\" ] , IECore . IntVectorData ( [ <NUM_LIT:10> ] ) ) <EOL> c1 [ \"<STR_LIT>\" ] = <NUM_LIT:20> <EOL> self . assertEqual ( c1 [ \"<STR_LIT>\" ] , <NUM_LIT:20> ) <EOL> self . assertEqual ( c2 [ \"<STR_LIT>\" ] , <NUM_LIT:20> ) <EOL> self . assertTrue ( c2 . get ( \"<STR_LIT>\" , _copy = False ) . isSame ( c1 . get ( \"<STR_LIT>\" , _copy = False ) ) ) <EOL> self . assertEqual ( c2 . get ( \"<STR_LIT>\" , _copy = False ) . refCount ( ) , r ) <EOL> del c2 <EOL> self . assertEqual ( c1 [ \"<STR_LIT>\" ] , <NUM_LIT:20> ) <EOL> self . assertEqual ( c1 [ \"<STR_LIT>\" ] , IECore . IntVectorData ( [ <NUM_LIT:10> ] ) ) <EOL> def testSetOnBorrowedContextsDoesntAffectOriginal ( self ) : <EOL> c1 = Gaffer . Context ( ) <EOL> c1 [ \"<STR_LIT>\" ] = <NUM_LIT:10> <EOL> c1 [ \"<STR_LIT>\" ] = IECore . IntVectorData ( [ <NUM_LIT:10> ] ) <EOL> c2 = Gaffer . Context ( c1 , ownership = Gaffer . Context . Ownership . Borrowed ) <EOL> c2 [ \"<STR_LIT>\" ] = <NUM_LIT:20> <EOL> c2 [ \"<STR_LIT>\" ] = IECore . IntVectorData ( [ <NUM_LIT:20> ] ) <EOL> self . assertEqual ( c1 [ \"<STR_LIT>\" ] , <NUM_LIT:10> ) <EOL> self . assertEqual ( c1 [ \"<STR_LIT>\" ] , IECore . IntVectorData ( [ <NUM_LIT:10> ] ) ) <EOL> self . assertEqual ( c2 [ \"<STR_LIT>\" ] , <NUM_LIT:20> ) <EOL> self . assertEqual ( c2 [ \"<STR_LIT>\" ] , IECore . IntVectorData ( [ <NUM_LIT:20> ] ) ) <EOL> def testSetOnSharedContextsDoesntAffectOriginal ( self ) : <EOL> c1 = Gaffer . Context ( ) <EOL> c1 [ \"<STR_LIT>\" ] = <NUM_LIT:10> <EOL> c1 [ \"<STR_LIT>\" ] = IECore . IntVectorData ( [ <NUM_LIT:10> ] ) <EOL> c2 = Gaffer . Context ( c1 , ownership = Gaffer . Context . Ownership . Shared ) <EOL> c2 [ \"<STR_LIT>\" ] = <NUM_LIT:20> <EOL> c2 [ \"<STR_LIT>\" ] = IECore . IntVectorData ( [ <NUM_LIT:20> ] ) <EOL> self . assertEqual ( c1 [ \"<STR_LIT>\" ] , <NUM_LIT:10> ) <EOL> self . assertEqual ( c1 [ \"<STR_LIT>\" ] , IECore . IntVectorData ( [ <NUM_LIT:10> ] ) ) <EOL> self . assertEqual ( c2 [ \"<STR_LIT>\" ] , <NUM_LIT:20> ) <EOL> self . assertEqual ( c2 [ \"<STR_LIT>\" ] , IECore . IntVectorData ( [ <NUM_LIT:20> ] ) ) <EOL> def testSetOnSharedContextsReleasesReference ( self ) : <EOL> c1 = Gaffer . Context ( ) <EOL> c1 [ \"<STR_LIT>\" ] = IECore . IntVectorData ( [ <NUM_LIT:10> ] ) <EOL> r = c1 . get ( \"<STR_LIT>\" , _copy = False ) . refCount ( ) <EOL> c2 = Gaffer . Context ( c1 , ownership = Gaffer . Context . Ownership . Shared ) <EOL> c2 [ \"<STR_LIT>\" ] = IECore . IntVectorData ( [ <NUM_LIT:20> ] ) <EOL> self . assertEqual ( c1 . get ( \"<STR_LIT>\" , _copy = False ) . refCount ( ) , r ) <EOL> def testHash ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> hashes = [ c . hash ( ) ] <EOL> c [ \"<STR_LIT:test>\" ] = <NUM_LIT:1> <EOL> hashes . append ( c . hash ( ) ) <EOL> c [ \"<STR_LIT:test>\" ] = <NUM_LIT:2> <EOL> hashes . append ( c . hash ( ) ) <EOL> c [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> hashes . append ( c . hash ( ) ) <EOL> self . assertEqual ( len ( hashes ) , <NUM_LIT:4> ) <EOL> self . assertEqual ( len ( set ( str ( h ) for h in hashes ) ) , len ( hashes ) ) <EOL> c [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> self . assertEqual ( c . hash ( ) , hashes [ - <NUM_LIT:1> ] ) <EOL> def testChanged ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> c [ \"<STR_LIT:test>\" ] = IECore . StringVectorData ( [ \"<STR_LIT>\" ] ) <EOL> h = c . hash ( ) <EOL> cs = GafferTest . CapturingSlot ( c . changedSignal ( ) ) <EOL> d = c . get ( \"<STR_LIT:test>\" , _copy = False ) <EOL> d . append ( \"<STR_LIT>\" ) <EOL> self . assertEqual ( c . get ( \"<STR_LIT:test>\" ) , IECore . StringVectorData ( [ \"<STR_LIT>\" , \"<STR_LIT>\" ] ) ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:0> ) <EOL> c . changed ( \"<STR_LIT:test>\" ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( cs [ <NUM_LIT:0> ] , ( c , \"<STR_LIT:test>\" ) ) <EOL> self . assertNotEqual ( c . hash ( ) , h ) <EOL> def testHashIgnoresUIEntries ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> h = c . hash ( ) <EOL> c [ \"<STR_LIT>\" ] = <NUM_LIT:1> <EOL> self . assertEqual ( h , c . hash ( ) ) <EOL> def testManySubstitutions ( self ) : <EOL> GafferTest . testManySubstitutions ( ) <EOL> def testManyEnvironmentSubstitutions ( self ) : <EOL> GafferTest . testManyEnvironmentSubstitutions ( ) <EOL> def testEscapedSubstitutions ( self ) : <EOL>", "answer": "c = Gaffer . Context ( )"}, {"prompt": "<s> class param : <EOL> def __init__ ( self ) : <EOL> self . debug = <NUM_LIT:0> <EOL> self . verbose = <NUM_LIT:0> <EOL> self . mean_intensity = <NUM_LIT:1000> <EOL> self . padding = <NUM_LIT:3> <EOL> self . window_length = <NUM_LIT> <EOL> import sys <EOL> import commands <EOL> import os <EOL> import getopt <EOL> status , path_sct = commands . getstatusoutput ( '<STR_LIT>' ) <EOL> sys . path . append ( path_sct + '<STR_LIT>' ) <EOL> import sct_utils as sct <EOL> import nibabel <EOL> import numpy as np <EOL> from time import strftime <EOL> import matplotlib . pyplot as plt <EOL> from scipy . interpolate import splrep , splev <EOL> from scipy import ndimage <EOL> from msct_smooth import smoothing_window <EOL> from sct_image import Image <EOL> def main ( ) : <EOL> fname = '<STR_LIT>' <EOL> fname_centerline = '<STR_LIT>' <EOL> mean_intensity = param . mean_intensity <EOL> verbose = param . verbose <EOL> padding = param . padding <EOL> window_length = param . window_length <EOL> try : <EOL> opts , args = getopt . getopt ( sys . argv [ <NUM_LIT:1> : ] , '<STR_LIT>' ) <EOL> except getopt . GetoptError : <EOL> usage ( ) <EOL> for opt , arg in opts : <EOL> if opt == '<STR_LIT>' : <EOL> usage ( ) <EOL> elif opt in ( \"<STR_LIT>\" ) : <EOL> fname = arg <EOL> elif opt in ( \"<STR_LIT:-c>\" ) : <EOL> fname_centerline = arg <EOL> elif opt in ( \"<STR_LIT>\" ) : <EOL> window_length = int ( arg ) <EOL> elif opt in ( '<STR_LIT>' ) : <EOL> verbose = int ( arg ) <EOL> if fname == '<STR_LIT>' : <EOL> usage ( ) <EOL> print '<STR_LIT>' <EOL> sct . check_file_exist ( fname ) <EOL> print '<STR_LIT>' <EOL> print '<STR_LIT>' + fname <EOL> print '<STR_LIT>' + fname_centerline <EOL> print '<STR_LIT>' + str ( verbose ) <EOL> path_input , file_input , ext_input = sct . extract_fname ( fname ) <EOL> sct . printv ( '<STR_LIT>' , verbose ) <EOL> file = nibabel . load ( fname ) <EOL> data = file . get_data ( ) <EOL> hdr = file . get_header ( ) <EOL>", "answer": "if fname_centerline != '<STR_LIT>' :"}, {"prompt": "<s> from django . contrib import admin <EOL> from django . contrib . contenttypes . admin import GenericTabularInline <EOL> from . models import Video , Category , TaggedItem <EOL> class TaggedItemInline ( GenericTabularInline ) : <EOL> model = TaggedItem <EOL> class VideoInline ( admin . TabularInline ) : <EOL> model = Video <EOL> class VideoAdmin ( admin . ModelAdmin ) : <EOL> inlines = [ TaggedItemInline ] <EOL>", "answer": "list_display = [ \"<STR_LIT>\" , '<STR_LIT>' ]"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> import datetime <EOL> from django . contrib import auth <EOL> from django . db import models , migrations <EOL> import periods <EOL> def populate_flow ( apps , schema_editor ) : <EOL> FlowEvent = apps . get_model ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> Period = apps . get_model ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> for period in Period . objects . all ( ) : <EOL> if period . start_time : <EOL> start_time = period . start_time <EOL> else : <EOL> start_time = datetime . time ( ) <EOL> flow = FlowEvent ( user = period . user , <EOL>", "answer": "timestamp = datetime . datetime . combine ( period . start_date , start_time ) ,"}, {"prompt": "<s> from django import forms <EOL> from etc . entities import create_handle <EOL> from entity_items . models import ContentItem <EOL> from org . models import Org , OrgIssueRelationship <EOL> from issue . models import Issue <EOL> from users . models import Location <EOL> from django . contrib . admin . widgets import FilteredSelectMultiple <EOL> from django . core . exceptions import ValidationError <EOL> from utils . widgets import MultipleLocationWidget , LocationWidget <EOL> import json <EOL> class OrgForm ( forms . ModelForm ) : <EOL> class Meta : <EOL> model = Org <EOL> widgets = { <EOL> '<STR_LIT:location>' : LocationWidget ( ) , <EOL> '<STR_LIT>' : MultipleLocationWidget ( ) , <EOL> '<STR_LIT>' : forms . TextInput ( attrs = { '<STR_LIT>' : <NUM_LIT> } ) , <EOL> '<STR_LIT>' : forms . TextInput ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:email>' : forms . TextInput ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : forms . TextInput ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : forms . TextInput ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : forms . TextInput ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : forms . TextInput ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : forms . TextInput ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : forms . Textarea ( attrs = { '<STR_LIT>' : '<STR_LIT>' } ) , <EOL> } <EOL> class Media : <EOL> css = { <EOL> '<STR_LIT:all>' : [ '<STR_LIT>' , ] <EOL> } <EOL> js = [ '<STR_LIT>' , ] <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( OrgForm , self ) . __init__ ( * args , ** kwargs ) <EOL> if '<STR_LIT>' in self . fields : <EOL> self . fields [ '<STR_LIT>' ] . help_text = '<STR_LIT>' <EOL> if '<STR_LIT>' in self . fields : <EOL> self . fields [ '<STR_LIT>' ] . widget = FilteredSelectMultiple ( '<STR_LIT>' , False ) <EOL> self . fields [ '<STR_LIT>' ] . queryset = Issue . objects . order_by ( '<STR_LIT:name>' ) <EOL> self . fields [ '<STR_LIT>' ] . help_text = '<STR_LIT>' <EOL> def save ( self , commit = True ) : <EOL> instance = super ( OrgForm , self ) . save ( commit = False ) <EOL> if '<STR_LIT>' in self . fields : <EOL> old_issues = instance . issues . all ( ) <EOL> new_issues = self . cleaned_data [ '<STR_LIT>' ] <EOL> to_delete = set ( old_issues ) - set ( new_issues ) <EOL> to_create = set ( new_issues ) - set ( old_issues ) <EOL> OrgIssueRelationship . objects . filter ( org = instance , issue__in = to_delete ) . delete ( ) <EOL> for issue in to_create : <EOL> relationship = OrgIssueRelationship ( org = instance , issue = issue ) <EOL> try : <EOL> relationship . full_clean ( ) <EOL> relationship . save ( ) <EOL> except ValidationError , e : <EOL> pass <EOL> del ( self . cleaned_data [ '<STR_LIT>' ] ) <EOL> if commit : <EOL> instance . save ( ) <EOL> self . save_m2m ( ) <EOL> return instance <EOL> class ManageOrgForm ( OrgForm ) : <EOL> mission = forms . CharField ( label = \"<STR_LIT>\" , widget = forms . Textarea ) <EOL> class Meta ( OrgForm . Meta ) : <EOL> fields = [ '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:location>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ManageOrgForm , self ) . __init__ ( * args , ** kwargs ) <EOL> try : <EOL> content_item = self . instance . content . center ( ) . mission_statement ( ) <EOL> self . fields [ '<STR_LIT>' ] . initial = content_item . rich_text_body <EOL> except ContentItem . DoesNotExist : <EOL> pass <EOL> def save ( self , commit = True ) : <EOL> instance = super ( ManageOrgForm , self ) . save ( False ) <EOL> try : <EOL> content_item = instance . content . center ( ) . mission_statement ( ) <EOL> except ContentItem . DoesNotExist : <EOL>", "answer": "content_item = ContentItem ( entity = instance , section = ContentItem . ContentSection . CENTER , title = ContentItem . MISSION_STATEMENT )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import socket <EOL> from django . core . management . base import CommandError <EOL> from django_extensions . management . utils import signalcommand <EOL> from django_extensions . compat import CompatibilityBaseCommand as BaseCommand <EOL> class Command ( BaseCommand ) : <EOL> help = \"<STR_LIT>\" <EOL> def add_arguments ( self , parser ) : <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , default = None , <EOL> help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , default = None , <EOL> help = '<STR_LIT>' ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , dest = '<STR_LIT>' , default = False , <EOL> action = \"<STR_LIT:store_true>\" , <EOL> help = '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> @ signalcommand <EOL> def handle ( self , * args , ** options ) : <EOL> from django . contrib . sites . models import Site <EOL> try : <EOL> site = Site . objects . get ( pk = <NUM_LIT:1> ) <EOL> except Site . DoesNotExist : <EOL> raise CommandError ( \"<STR_LIT>\" ) <EOL> else : <EOL> name = options . get ( \"<STR_LIT>\" , None ) <EOL> domain = options . get ( \"<STR_LIT>\" , None ) <EOL> if options . get ( '<STR_LIT>' , False ) : <EOL> domain = socket . getfqdn ( ) <EOL> if not domain : <EOL> raise CommandError ( \"<STR_LIT>\" ) <EOL> if name is None : <EOL> name = domain <EOL> update_kwargs = { } <EOL> if name and name != site . name : <EOL> update_kwargs [ \"<STR_LIT:name>\" ] = name <EOL> if domain and domain != site . domain : <EOL> update_kwargs [ \"<STR_LIT>\" ] = domain <EOL> if update_kwargs : <EOL> Site . objects . filter ( pk = <NUM_LIT:1> ) . update ( ** update_kwargs ) <EOL>", "answer": "site = Site . objects . get ( pk = <NUM_LIT:1> )"}, {"prompt": "<s> from Util import Util <EOL> import mailbox <EOL> import json <EOL> from errors import * <EOL> DEFAULT_MAIL_VIEW_COUNT = <NUM_LIT:20> <EOL> MAIL_SIZE_UNLIMITED = - <NUM_LIT:1> <EOL> class Mail : <EOL> @ staticmethod <EOL> def GET ( svc , session , params , action ) : <EOL> if ( session is None ) : raise Unauthorized ( '<STR_LIT>' ) <EOL> if not session . CheckScope ( '<STR_LIT>' ) : raise NoPerm ( \"<STR_LIT>\" ) <EOL> if ( action == '<STR_LIT:list>' ) : <EOL> folder = svc . get_str ( params , '<STR_LIT>' , '<STR_LIT>' ) <EOL> start = svc . get_int ( params , '<STR_LIT:start>' , <NUM_LIT:0> ) <EOL> end = svc . get_int ( params , '<STR_LIT:end>' , <NUM_LIT:0> ) <EOL> count = svc . get_int ( params , '<STR_LIT:count>' , <NUM_LIT:0> ) <EOL> svc . writedata ( Mail . List ( session . GetUser ( ) , folder , start , count , end ) ) <EOL> elif ( action == '<STR_LIT>' ) : <EOL> folder = svc . get_str ( params , '<STR_LIT>' , '<STR_LIT>' ) <EOL> index = svc . get_int ( params , '<STR_LIT:index>' ) <EOL> start = svc . get_int ( params , '<STR_LIT:start>' , <NUM_LIT:0> ) <EOL> count = svc . get_int ( params , '<STR_LIT:count>' , <NUM_LIT:0> ) <EOL> if start < <NUM_LIT:0> or count < <NUM_LIT:0> : <EOL> raise WrongArgs ( '<STR_LIT>' ) <EOL> svc . writedata ( Mail . View ( session . GetUser ( ) , folder , index , start , count ) ) <EOL> elif ( action == '<STR_LIT>' ) : <EOL> folder = svc . get_str ( params , '<STR_LIT>' , '<STR_LIT>' ) <EOL> index = svc . get_int ( params , '<STR_LIT:index>' , <NUM_LIT:0> ) <EOL> result = { '<STR_LIT>' : Mail . CheckUnread ( session . GetUser ( ) , folder , index ) } <EOL> svc . writedata ( json . dumps ( result ) ) <EOL> elif action == '<STR_LIT>' : <EOL> folder = svc . get_str ( params , '<STR_LIT>' , '<STR_LIT>' ) <EOL> mode = svc . get_str ( params , '<STR_LIT>' , '<STR_LIT:S>' ) <EOL> index = svc . get_int ( params , '<STR_LIT:index>' ) <EOL> ( title , content ) = session . GetUser ( ) . mbox . quote_mail ( folder , mode , <EOL> index ) <EOL> result = { '<STR_LIT:title>' : title , '<STR_LIT:content>' : content } <EOL> svc . writedata ( json . dumps ( result ) ) <EOL> else : <EOL> raise WrongArgs ( '<STR_LIT>' ) <EOL> @ staticmethod <EOL> def POST ( svc , session , params , action ) : <EOL> if session is None : raise Unauthorized ( '<STR_LIT>' ) <EOL> if not session . CheckScope ( '<STR_LIT>' ) : raise NoPerm ( '<STR_LIT>' ) <EOL> if action == '<STR_LIT>' : <EOL> title = svc . get_str ( params , '<STR_LIT:title>' ) <EOL> content = svc . get_str ( params , '<STR_LIT:content>' ) <EOL> receiver_id = svc . get_str ( params , '<STR_LIT:to>' ) <EOL> signature_id = svc . get_int ( params , '<STR_LIT>' , <NUM_LIT:0> ) <EOL> save_in_sent = svc . get_bool ( params , '<STR_LIT>' , True ) <EOL> session . GetUser ( ) . SendMailTo ( receiver_id , title , content , <EOL> signature_id , session , save_in_sent ) <EOL> result = { '<STR_LIT:result>' : '<STR_LIT>' } <EOL> svc . writedata ( json . dumps ( result ) ) <EOL> else : <EOL> raise WrongArgs ( '<STR_LIT>' ) <EOL> @ staticmethod <EOL> def List ( user , folder , start , count , end ) : <EOL> mbox = mailbox . MailBox ( user . GetName ( ) ) <EOL> folder = mbox . get_folder ( folder ) <EOL> total = folder . count ( ) <EOL> start , end = Util . CheckRange ( start , end , count , DEFAULT_MAIL_VIEW_COUNT , total ) <EOL> if ( start <= end and start >= <NUM_LIT:1> and end <= total ) : <EOL> result = '<STR_LIT>' % ( start , end ) <EOL> first = True <EOL> for i in range ( start - <NUM_LIT:1> , end ) : <EOL> entry = folder . get_entry ( i ) <EOL> if entry is None : <EOL> continue <EOL> if not first : <EOL> result += '<STR_LIT>' <EOL> post = entry . GetInfo ( '<STR_LIT>' ) <EOL> post [ '<STR_LIT:id>' ] = i + <NUM_LIT:1> <EOL> result += json . dumps ( post ) <EOL> first = False <EOL> result += '<STR_LIT>' <EOL> return result <EOL> else : <EOL> raise OutOfRange ( '<STR_LIT>' ) <EOL> @ staticmethod <EOL> def View ( user , folder , index , start , count ) : <EOL>", "answer": "mbox = mailbox . MailBox ( user . GetName ( ) )"}, {"prompt": "<s> class DataDescriptor ( object ) : <EOL> def __get__ ( self , obj , type ) : <EOL> if obj != None : <EOL> return obj . a_store <EOL> else : <EOL> def f ( ) : <EOL> print '<STR_LIT>' <EOL> return <NUM_LIT:100> <EOL> return f <EOL> def __set__ ( self , obj , value ) : <EOL> obj . a_store = value <EOL> class NonDataDescriptor ( object ) : <EOL> def __get__ ( self , obj , type ) : <EOL> def f ( ) : <EOL> print '<STR_LIT>' <EOL> return <NUM_LIT:1> <EOL> return f <EOL> class C ( object ) : <EOL> dd = DataDescriptor ( ) <EOL> ndd = NonDataDescriptor ( ) <EOL> inst = C ( ) <EOL> print '<STR_LIT>' % inst . ndd ( ) <EOL> inst . dd = lambda : <NUM_LIT> <EOL> print '<STR_LIT>' % inst . dd ( ) <EOL> inst . ndd = lambda : <NUM_LIT:20> <EOL>", "answer": "print inst . ndd ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import unittest <EOL> import dumbdbm <EOL> from test import test_support <EOL> _fname = test_support . TESTFN <EOL> def _delete_files ( ) : <EOL> for ext in [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> try : <EOL> os . unlink ( _fname + ext ) <EOL> except OSError : <EOL> pass <EOL> class DumbDBMTestCase ( unittest . TestCase ) : <EOL> _dict = { '<STR_LIT:0>' : '<STR_LIT>' , <EOL> '<STR_LIT:a>' : '<STR_LIT>' , <EOL> '<STR_LIT:b>' : '<STR_LIT>' , <EOL> '<STR_LIT:c>' : '<STR_LIT>' , <EOL> '<STR_LIT:d>' : '<STR_LIT>' , <EOL> '<STR_LIT:f>' : '<STR_LIT>' , <EOL> '<STR_LIT:g>' : '<STR_LIT>' <EOL> } <EOL> def __init__ ( self , * args ) : <EOL> unittest . TestCase . __init__ ( self , * args ) <EOL> def test_dumbdbm_creation ( self ) : <EOL> f = dumbdbm . open ( _fname , '<STR_LIT:c>' ) <EOL> self . assertEqual ( f . keys ( ) , [ ] ) <EOL> for key in self . _dict : <EOL> f [ key ] = self . _dict [ key ] <EOL> self . read_helper ( f ) <EOL> f . close ( ) <EOL> def test_close_twice ( self ) : <EOL> f = dumbdbm . open ( _fname ) <EOL> f [ '<STR_LIT:a>' ] = '<STR_LIT:b>' <EOL> self . assertEqual ( f [ '<STR_LIT:a>' ] , '<STR_LIT:b>' ) <EOL> f . close ( ) <EOL> f . close ( ) <EOL> def test_dumbdbm_modification ( self ) : <EOL> self . init_db ( ) <EOL> f = dumbdbm . open ( _fname , '<STR_LIT:w>' ) <EOL> self . _dict [ '<STR_LIT:g>' ] = f [ '<STR_LIT:g>' ] = \"<STR_LIT>\" <EOL> self . read_helper ( f ) <EOL> f . close ( ) <EOL> def test_dumbdbm_read ( self ) : <EOL> self . init_db ( ) <EOL> f = dumbdbm . open ( _fname , '<STR_LIT:r>' ) <EOL> self . read_helper ( f ) <EOL> f . close ( ) <EOL> def test_dumbdbm_keys ( self ) : <EOL> self . init_db ( ) <EOL> f = dumbdbm . open ( _fname ) <EOL> keys = self . keys_helper ( f ) <EOL> f . close ( ) <EOL> def test_write_write_read ( self ) : <EOL> f = dumbdbm . open ( _fname ) <EOL> f [ '<STR_LIT:1>' ] = '<STR_LIT:hello>' <EOL> f [ '<STR_LIT:1>' ] = '<STR_LIT>' <EOL> f . close ( ) <EOL> f = dumbdbm . open ( _fname ) <EOL> self . assertEqual ( f [ '<STR_LIT:1>' ] , '<STR_LIT>' ) <EOL> f . close ( ) <EOL> def test_line_endings ( self ) : <EOL> f = dumbdbm . open ( _fname ) <EOL> f [ '<STR_LIT:1>' ] = '<STR_LIT:hello>' <EOL> f [ '<STR_LIT:2>' ] = '<STR_LIT>' <EOL> f . close ( ) <EOL> f = open ( _fname + '<STR_LIT>' ) <EOL> data = f . read ( ) <EOL> data = data . replace ( '<STR_LIT:\\n>' , '<STR_LIT:\\r\\n>' ) <EOL> f . close ( ) <EOL> f = open ( _fname + '<STR_LIT>' , '<STR_LIT:wb>' ) <EOL> f . write ( data ) <EOL> f . close ( ) <EOL> f = dumbdbm . open ( _fname ) <EOL> self . assertEqual ( f [ '<STR_LIT:1>' ] , '<STR_LIT:hello>' ) <EOL> self . assertEqual ( f [ '<STR_LIT:2>' ] , '<STR_LIT>' ) <EOL> f . close ( ) <EOL> def read_helper ( self , f ) : <EOL> keys = self . keys_helper ( f ) <EOL> for key in self . _dict : <EOL> self . assertEqual ( self . _dict [ key ] , f [ key ] ) <EOL> def init_db ( self ) : <EOL> f = dumbdbm . open ( _fname , '<STR_LIT:w>' ) <EOL> for k in self . _dict : <EOL> f [ k ] = self . _dict [ k ] <EOL> f . close ( ) <EOL> def keys_helper ( self , f ) : <EOL> keys = f . keys ( ) <EOL> keys . sort ( ) <EOL> dkeys = self . _dict . keys ( ) <EOL> dkeys . sort ( ) <EOL> self . assertEqual ( keys , dkeys ) <EOL> return keys <EOL> def test_random ( self ) : <EOL> import random <EOL> d = { } <EOL> for dummy in range ( <NUM_LIT:5> ) : <EOL> f = dumbdbm . open ( _fname ) <EOL> for dummy in range ( <NUM_LIT:100> ) : <EOL> k = random . choice ( '<STR_LIT>' ) <EOL> if random . random ( ) < <NUM_LIT> : <EOL> if k in d : <EOL> del d [ k ] <EOL> del f [ k ] <EOL>", "answer": "else :"}, {"prompt": "<s> from . compat import callable , cmp , reduce , threading , py3k , py33 , py2k , jython , pypy , cpython , win32 , pickle , dottedgetter , parse_qsl , namedtuple , next , reraise , raise_from_cause , text_type , safe_kwarg , string_types , int_types , binary_type , nested , quote_plus , with_metaclass , print_ , itertools_filterfalse , u , ue , b , unquote_plus , unquote , b64decode , b64encode , byte_buffer , itertools_filter , iterbytes , StringIO , inspect_getargspec , zip_longest <EOL> from . _collections import KeyedTuple , ImmutableContainer , immutabledict , Properties , OrderedProperties , ImmutableProperties , OrderedDict , OrderedSet , IdentitySet , OrderedIdentitySet , column_set , column_dict , ordered_column_set , populate_column_dict , unique_list , UniqueAppender , PopulateDict , EMPTY_SET , to_list , to_set , to_column_set , update_copy , flatten_iterator , LRUCache , ScopedRegistry , ThreadLocalRegistry , WeakSequence , coerce_generator_arg <EOL> from . langhelpers import iterate_attributes , class_hierarchy , portable_instancemethod , unbound_method_to_callable , getargspec_init , format_argspec_init , format_argspec_plus , get_func_kwargs , get_cls_kwargs , decorator , as_interface , memoized_property , memoized_instancemethod , md5_hex , group_expirable_memoized_property , dependencies , decode_slice , monkeypatch_proxied_specials , asbool , bool_or_str , coerce_kw_type , duck_type_collection , assert_arg_type , symbol , dictlike_iteritems , classproperty , set_creation_order , warn_exception , warn , NoneType , constructor_copy , methods_equivalent , chop_traceback , asint , generic_repr , counter , PluginLoader , hybridmethod , safe_reraise , get_callable_argspec , only_once <EOL>", "answer": "from . deprecations import warn_deprecated , warn_pending_deprecation , deprecated , pending_deprecation , inject_docstring_text"}, {"prompt": "<s> from msrest . paging import Paged <EOL>", "answer": "class TagDetailsPaged ( Paged ) :"}, {"prompt": "<s> from flask import Flask <EOL> from werkzeug . contrib . fixers import ProxyFix <EOL>", "answer": "from zoo import api"}, {"prompt": "<s> import argparse <EOL> import sys <EOL> import time <EOL> from . btc import encoder , decoder , error , list_to_dict , dict_to_list , client <EOL> _description = '<STR_LIT>' <EOL> def main ( ) : <EOL>", "answer": "parser = argparse . ArgumentParser ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from vyapp . complete import CompleteWindow , Option <EOL> from subprocess import Popen <EOL> import json <EOL> import requests <EOL> import sys <EOL> import atexit <EOL> from os . path import expanduser , join , exists , dirname <EOL> from os import getcwd <EOL> from shutil import copyfile <EOL> from vyapp . plugins import ENV <EOL> from vyapp . areavi import AreaVi <EOL> filename = join ( expanduser ( '<STR_LIT>' ) , '<STR_LIT>' ) <EOL> if not exists ( filename ) : copyfile ( join ( dirname ( __file__ ) , '<STR_LIT>' ) , filename ) <EOL> class Tern ( object ) : <EOL> def __init__ ( self , path ) : <EOL> self . path = path <EOL> self . child = Popen ( [ path , '<STR_LIT>' ] ) <EOL> atexit . register ( self . child . terminate ) <EOL> def parse_port ( self ) : <EOL> with open ( join ( getcwd ( ) , '<STR_LIT>' ) , '<STR_LIT:r>' ) as fd : <EOL> return int ( fd . read ( ) ) <EOL> def port ( self ) : <EOL> port = self . parse_port ( ) <EOL> def shell ( ) : <EOL> return port <EOL> self . port = shell <EOL> return port <EOL> def completions ( self , data , line , col , filename ) : <EOL> payload = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT:file>' : filename , <EOL> '<STR_LIT>' : '<STR_LIT:true>' , <EOL> '<STR_LIT>' : '<STR_LIT:true>' , <EOL> '<STR_LIT:end>' : { '<STR_LIT>' : line , '<STR_LIT>' : col } , <EOL> } , <EOL> '<STR_LIT>' : [ { \"<STR_LIT:type>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:name>\" : filename , <EOL> \"<STR_LIT:text>\" : data } ] <EOL> } <EOL> addr = '<STR_LIT>' % self . port ( ) <EOL> req = requests . post ( addr , data = json . dumps ( payload ) ) <EOL> return self . build ( req . text ) <EOL> def build ( self , data ) : <EOL> data = json . loads ( data ) <EOL> return map ( lambda ind : Option ( ** ind ) , data [ '<STR_LIT>' ] ) <EOL> class JavascriptCompleteWindow ( CompleteWindow ) : <EOL> \"\"\"<STR_LIT:U+0020>\"\"\" <EOL> def __init__ ( self , tern , area , * args , ** kwargs ) : <EOL> source = area . get ( '<STR_LIT:1.0>' , '<STR_LIT:end>' ) <EOL> line , col = area . indcur ( ) <EOL> completions = tern . completions ( source , line - <NUM_LIT:1> , col , area . filename ) <EOL>", "answer": "CompleteWindow . __init__ ( self , area , completions , * args , ** kwargs )"}, {"prompt": "<s> import sublime , sublime_plugin <EOL> try : <EOL> from . debugger import * <EOL> except : <EOL> from debugger import * <EOL> class ViewHelperCommand ( sublime_plugin . WindowCommand ) : <EOL> def __init__ ( self , window ) : <EOL> super ( ViewHelperCommand , self ) . __init__ ( window ) <EOL> def run ( self , command , ** args ) : <EOL> if command == \"<STR_LIT>\" : <EOL> sublime . set_timeout ( lambda window = self . window , args = args : ViewHelper . set_cursor ( window , ** args ) , <NUM_LIT:0> ) <EOL>", "answer": "elif command == \"<STR_LIT>\" :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from cloudcafe . networking . networks . common . config import NetworkingBaseConfig <EOL> class SubnetsConfig ( NetworkingBaseConfig ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> SECTION_NAME = '<STR_LIT>' <EOL> @ property <EOL> def starts_with_name ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> @ property <EOL>", "answer": "def v4_subnets_per_network ( self ) :"}, {"prompt": "<s> from montepython . likelihood_class import Likelihood <EOL> import numpy as np <EOL> from math import log <EOL> import os <EOL> class WiggleZ_bao ( Likelihood ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , path , data , command_line ) : <EOL>", "answer": "Likelihood . __init__ ( self , path , data , command_line )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import unittest <EOL> from dfvfs . path import compressed_stream_path_spec <EOL> from tests . path import test_lib <EOL> class CompressedStreamPathSpecTest ( test_lib . PathSpecTestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def testInitialize ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path_spec = compressed_stream_path_spec . CompressedStreamPathSpec ( <EOL> compression_method = u'<STR_LIT:test>' , parent = self . _path_spec ) <EOL> self . assertIsNotNone ( path_spec ) <EOL> with self . assertRaises ( ValueError ) : <EOL> _ = compressed_stream_path_spec . CompressedStreamPathSpec ( <EOL> compression_method = u'<STR_LIT:test>' , parent = None ) <EOL> with self . assertRaises ( ValueError ) : <EOL> _ = compressed_stream_path_spec . CompressedStreamPathSpec ( <EOL> compression_method = None , parent = self . _path_spec ) <EOL> with self . assertRaises ( ValueError ) : <EOL> _ = compressed_stream_path_spec . CompressedStreamPathSpec ( <EOL> compression_method = u'<STR_LIT:test>' , parent = self . _path_spec , bogus = u'<STR_LIT>' ) <EOL> def testComparable ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path_spec = compressed_stream_path_spec . CompressedStreamPathSpec ( <EOL> compression_method = u'<STR_LIT:test>' , parent = self . _path_spec ) <EOL> self . assertIsNotNone ( path_spec ) <EOL> expected_comparable = u'<STR_LIT:\\n>' . join ( [ <EOL> u'<STR_LIT>' , <EOL>", "answer": "u'<STR_LIT>' ,"}, {"prompt": "<s> from . base import SettingsBaseCommand <EOL> class SettingsSelectDocTypeCommand ( SettingsBaseCommand ) : <EOL> command_name = \"<STR_LIT>\" <EOL> def run ( self , index = None , doc_type = None ) : <EOL> if not doc_type : <EOL> self . show_doc_type_list_panel ( self . run ) <EOL>", "answer": "return"}, {"prompt": "<s> import csv <EOL> import io <EOL> import logging <EOL> import requests <EOL> from eatsmart . locations . base import Importer <EOL> from eatsmart . locations . durham . forms import ( EstablishmentForm , InspectionForm , <EOL> ViolationForm ) <EOL> from inspections . models import Establishment , Inspection , Violation <EOL> logger = logging . getLogger ( __name__ ) <EOL> class DurhamAPI ( object ) : <EOL> \"<STR_LIT>\" <EOL> url = \"<STR_LIT>\" <EOL> params = { '<STR_LIT:count>' : <NUM_LIT:200> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:status>' : '<STR_LIT>' } <EOL> def get ( self , * args , ** kwargs ) : <EOL> \"<STR_LIT>\" <EOL> params = self . params . copy ( ) <EOL> params . update ( kwargs ) <EOL> page = <NUM_LIT:1> <EOL> while True : <EOL> params [ '<STR_LIT>' ] = page <EOL> request = requests . get ( self . url , params = params ) <EOL> logger . info ( \"<STR_LIT>\" . format ( request . url ) ) <EOL> rows = list ( csv . DictReader ( io . StringIO ( request . text ) ) ) <EOL> if not rows : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return <EOL> for row in rows : <EOL> yield row <EOL> page += <NUM_LIT:1> <EOL> class EstablishmentImporter ( Importer ) : <EOL> \"<STR_LIT>\" <EOL> Model = Establishment <EOL> Form = EstablishmentForm <EOL> ColumnList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] <EOL> def run ( self ) : <EOL> \"<STR_LIT>\" <EOL> cols = '<STR_LIT:U+002C>' . join ( self . ColumnList ) <EOL> self . fetch ( DurhamAPI ( ) . get ( table = \"<STR_LIT>\" , est_type = <NUM_LIT:1> , <EOL> columns = cols ) ) <EOL> def get_instance ( self , data ) : <EOL> \"<STR_LIT>\" <EOL> return self . Model . objects . get ( external_id = data [ '<STR_LIT>' ] , <EOL> county = data [ '<STR_LIT>' ] ) <EOL> def map_fields ( self , api ) : <EOL> \"<STR_LIT>\" <EOL> return { '<STR_LIT>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT:name>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT:type>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT:address>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:state>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT:status>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : api [ '<STR_LIT>' ] } <EOL> class InspectionImporter ( Importer ) : <EOL> \"<STR_LIT>\" <EOL> Model = Inspection <EOL> Form = InspectionForm <EOL> ColumnList = [ '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] <EOL> def run ( self ) : <EOL> \"<STR_LIT>\" <EOL> cols = '<STR_LIT:U+002C>' . join ( self . ColumnList ) <EOL> for est in Establishment . objects . filter ( county = '<STR_LIT>' ) : <EOL> api = DurhamAPI ( ) . get ( table = \"<STR_LIT>\" , est_id = est . external_id , <EOL> columns = cols ) <EOL> self . fetch ( api , establishment = est ) <EOL> def get_instance ( self , data , establishment ) : <EOL> \"<STR_LIT>\" <EOL> return self . Model . objects . get ( external_id = data [ '<STR_LIT>' ] , <EOL> establishment = establishment ) <EOL> def map_fields ( self , api , establishment ) : <EOL> \"<STR_LIT>\" <EOL> return { '<STR_LIT>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : establishment . id , <EOL> '<STR_LIT:date>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT:type>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT:description>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : api [ '<STR_LIT>' ] } <EOL> class ViolationImporter ( Importer ) : <EOL> \"<STR_LIT>\" <EOL> Model = Violation <EOL> Form = ViolationForm <EOL> ColumnList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> def run ( self ) : <EOL> \"<STR_LIT>\" <EOL> cols = '<STR_LIT:U+002C>' . join ( self . ColumnList ) <EOL> inspections = Inspection . objects . filter ( establishment__county = '<STR_LIT>' ) <EOL> for insp in inspections . select_related ( '<STR_LIT>' ) : <EOL> api = DurhamAPI ( ) . get ( table = \"<STR_LIT>\" , <EOL> inspection_id = insp . external_id , <EOL> columns = cols ) <EOL> self . fetch ( api , inspection = insp ) <EOL> def get_instance ( self , data , inspection ) : <EOL> \"<STR_LIT>\" <EOL> return self . Model . objects . get ( external_id = data [ '<STR_LIT>' ] , <EOL> inspection = inspection ) <EOL> def map_fields ( self , api , inspection ) : <EOL> \"<STR_LIT>\" <EOL> return { '<STR_LIT>' : api [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : inspection . id , <EOL> '<STR_LIT>' : inspection . establishment . id , <EOL> '<STR_LIT:date>' : inspection . date , <EOL> '<STR_LIT:code>' : api [ '<STR_LIT>' ] , <EOL>", "answer": "'<STR_LIT:description>' : api [ '<STR_LIT>' ] ,"}, {"prompt": "<s> from django . contrib import messages <EOL> from django . core . exceptions import ( <EOL> MultipleObjectsReturned , ObjectDoesNotExist , PermissionDenied ) <EOL> from django . core . urlresolvers import reverse <EOL> from django . http import Http404 <EOL> from django . shortcuts import get_object_or_404 , redirect <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from django . views . generic import ( <EOL> CreateView , DeleteView , FormView , ListView , UpdateView , View ) <EOL> from oscar . core . loading import get_class , get_classes , get_model <EOL> from oscar . core . utils import redirect_to_referrer , safe_referrer <EOL> WishList = get_model ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> Line = get_model ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> Product = get_model ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> WishListForm , LineFormset = get_classes ( '<STR_LIT>' , <EOL> [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> PageTitleMixin = get_class ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> class WishListListView ( PageTitleMixin , ListView ) : <EOL> context_object_name = active_tab = \"<STR_LIT>\" <EOL> template_name = '<STR_LIT>' <EOL> page_title = _ ( '<STR_LIT>' ) <EOL> def get_queryset ( self ) : <EOL> return self . request . user . wishlists . all ( ) <EOL> class WishListDetailView ( PageTitleMixin , FormView ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> template_name = '<STR_LIT>' <EOL> active_tab = \"<STR_LIT>\" <EOL> form_class = LineFormset <EOL> def dispatch ( self , request , * args , ** kwargs ) : <EOL> self . object = self . get_wishlist_or_404 ( kwargs [ '<STR_LIT:key>' ] , request . user ) <EOL> return super ( WishListDetailView , self ) . dispatch ( request , * args , <EOL> ** kwargs ) <EOL> def get_wishlist_or_404 ( self , key , user ) : <EOL> wishlist = get_object_or_404 ( WishList , key = key ) <EOL> if wishlist . is_allowed_to_see ( user ) : <EOL> return wishlist <EOL> else : <EOL> raise Http404 <EOL> def get_page_title ( self ) : <EOL> return self . object . name <EOL> def get_form_kwargs ( self ) : <EOL> kwargs = super ( WishListDetailView , self ) . get_form_kwargs ( ) <EOL> kwargs [ '<STR_LIT>' ] = self . object <EOL> return kwargs <EOL> def get_context_data ( self , ** kwargs ) : <EOL> ctx = super ( WishListDetailView , self ) . get_context_data ( ** kwargs ) <EOL> ctx [ '<STR_LIT>' ] = self . object <EOL> other_wishlists = self . request . user . wishlists . exclude ( <EOL> pk = self . object . pk ) <EOL> ctx [ '<STR_LIT>' ] = other_wishlists <EOL> return ctx <EOL> def form_valid ( self , form ) : <EOL> for subform in form : <EOL> if subform . cleaned_data [ '<STR_LIT>' ] <= <NUM_LIT:0> : <EOL> subform . instance . delete ( ) <EOL> else : <EOL> subform . save ( ) <EOL> messages . success ( self . request , _ ( '<STR_LIT>' ) ) <EOL> return redirect ( '<STR_LIT>' , key = self . object . key ) <EOL> class WishListCreateView ( PageTitleMixin , CreateView ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> model = WishList <EOL> template_name = '<STR_LIT>' <EOL> active_tab = \"<STR_LIT>\" <EOL> page_title = _ ( '<STR_LIT>' ) <EOL> form_class = WishListForm <EOL> product = None <EOL> def dispatch ( self , request , * args , ** kwargs ) : <EOL> if '<STR_LIT>' in kwargs : <EOL> try : <EOL> self . product = Product . objects . get ( pk = kwargs [ '<STR_LIT>' ] ) <EOL> except ObjectDoesNotExist : <EOL> messages . error ( <EOL> request , _ ( \"<STR_LIT>\" ) ) <EOL> return redirect ( '<STR_LIT>' ) <EOL> return super ( WishListCreateView , self ) . dispatch ( <EOL> request , * args , ** kwargs ) <EOL> def get_context_data ( self , ** kwargs ) : <EOL> ctx = super ( WishListCreateView , self ) . get_context_data ( ** kwargs ) <EOL> ctx [ '<STR_LIT>' ] = self . product <EOL> return ctx <EOL> def get_form_kwargs ( self ) : <EOL> kwargs = super ( WishListCreateView , self ) . get_form_kwargs ( ) <EOL> kwargs [ '<STR_LIT:user>' ] = self . request . user <EOL> return kwargs <EOL> def form_valid ( self , form ) : <EOL> wishlist = form . save ( ) <EOL> if self . product : <EOL> wishlist . add ( self . product ) <EOL> msg = _ ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) % { '<STR_LIT:name>' : self . product . get_title ( ) } <EOL> else : <EOL> msg = _ ( \"<STR_LIT>\" ) <EOL> messages . success ( self . request , msg ) <EOL> return redirect ( wishlist . get_absolute_url ( ) ) <EOL> class WishListCreateWithProductView ( View ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def post ( self , request , * args , ** kwargs ) : <EOL> product = get_object_or_404 ( Product , pk = kwargs [ '<STR_LIT>' ] ) <EOL> wishlists = request . user . wishlists . all ( ) <EOL> if len ( wishlists ) == <NUM_LIT:0> : <EOL> wishlist = request . user . wishlists . create ( ) <EOL> else : <EOL> wishlist = wishlists [ <NUM_LIT:0> ] <EOL> wishlist . add ( product ) <EOL> messages . success ( <EOL> request , _ ( \"<STR_LIT>\" ) % { <EOL> '<STR_LIT:title>' : product . get_title ( ) } ) <EOL> return redirect_to_referrer ( request , wishlist . get_absolute_url ( ) ) <EOL> class WishListUpdateView ( PageTitleMixin , UpdateView ) : <EOL> model = WishList <EOL> template_name = '<STR_LIT>' <EOL> active_tab = \"<STR_LIT>\" <EOL> form_class = WishListForm <EOL> context_object_name = '<STR_LIT>' <EOL> def get_page_title ( self ) : <EOL> return self . object . name <EOL> def get_object ( self , queryset = None ) : <EOL> return get_object_or_404 ( WishList , owner = self . request . user , <EOL> key = self . kwargs [ '<STR_LIT:key>' ] ) <EOL> def get_form_kwargs ( self ) : <EOL> kwargs = super ( WishListUpdateView , self ) . get_form_kwargs ( ) <EOL> kwargs [ '<STR_LIT:user>' ] = self . request . user <EOL> return kwargs <EOL> def get_success_url ( self ) : <EOL> messages . success ( <EOL> self . request , _ ( \"<STR_LIT>\" ) <EOL> % self . object . name ) <EOL> return reverse ( '<STR_LIT>' ) <EOL> class WishListDeleteView ( PageTitleMixin , DeleteView ) : <EOL> model = WishList <EOL> template_name = '<STR_LIT>' <EOL> active_tab = \"<STR_LIT>\" <EOL> def get_page_title ( self ) : <EOL> return _ ( u'<STR_LIT>' ) % self . object . name <EOL> def get_object ( self , queryset = None ) : <EOL> return get_object_or_404 ( WishList , owner = self . request . user , <EOL> key = self . kwargs [ '<STR_LIT:key>' ] ) <EOL> def get_success_url ( self ) : <EOL> messages . success ( <EOL> self . request , _ ( \"<STR_LIT>\" ) <EOL> % self . object . name ) <EOL> return reverse ( '<STR_LIT>' ) <EOL> class WishListAddProduct ( View ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def dispatch ( self , request , * args , ** kwargs ) : <EOL> self . product = get_object_or_404 ( Product , pk = kwargs [ '<STR_LIT>' ] ) <EOL> self . wishlist = self . get_or_create_wishlist ( request , * args , ** kwargs ) <EOL> return super ( WishListAddProduct , self ) . dispatch ( request ) <EOL> def get_or_create_wishlist ( self , request , * args , ** kwargs ) : <EOL> if '<STR_LIT:key>' in kwargs : <EOL> wishlist = get_object_or_404 ( <EOL> WishList , key = kwargs [ '<STR_LIT:key>' ] , owner = request . user ) <EOL> else : <EOL> wishlists = request . user . wishlists . all ( ) [ : <NUM_LIT:1> ] <EOL> if not wishlists : <EOL> return request . user . wishlists . create ( ) <EOL> wishlist = wishlists [ <NUM_LIT:0> ] <EOL> if not wishlist . is_allowed_to_edit ( request . user ) : <EOL> raise PermissionDenied <EOL> return wishlist <EOL> def get ( self , request , * args , ** kwargs ) : <EOL> return self . add_product ( ) <EOL> def post ( self , request , * args , ** kwargs ) : <EOL> return self . add_product ( ) <EOL> def add_product ( self ) : <EOL> self . wishlist . add ( self . product ) <EOL> msg = _ ( \"<STR_LIT>\" ) % self . product . get_title ( ) <EOL> messages . success ( self . request , msg ) <EOL> return redirect_to_referrer ( <EOL> self . request , self . product . get_absolute_url ( ) ) <EOL> class LineMixin ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def fetch_line ( self , user , wishlist_key , line_pk = None , product_pk = None ) : <EOL> self . wishlist = WishList . _default_manager . get ( <EOL> owner = user , key = wishlist_key ) <EOL> if line_pk is not None : <EOL> self . line = self . wishlist . lines . get ( pk = line_pk ) <EOL> else : <EOL> self . line = self . wishlist . lines . get ( product_id = product_pk ) <EOL> self . product = self . line . product <EOL> class WishListRemoveProduct ( LineMixin , PageTitleMixin , DeleteView ) : <EOL> template_name = '<STR_LIT>' <EOL> active_tab = \"<STR_LIT>\" <EOL> def get_page_title ( self ) : <EOL> return _ ( u'<STR_LIT>' ) % self . object . get_title ( ) <EOL> def get_object ( self , queryset = None ) : <EOL> self . fetch_line ( <EOL> self . request . user , self . kwargs [ '<STR_LIT:key>' ] , <EOL> self . kwargs . get ( '<STR_LIT>' ) , self . kwargs . get ( '<STR_LIT>' ) ) <EOL> return self . line <EOL> def get_context_data ( self , ** kwargs ) : <EOL> ctx = super ( WishListRemoveProduct , self ) . get_context_data ( ** kwargs ) <EOL> ctx [ '<STR_LIT>' ] = self . wishlist <EOL> ctx [ '<STR_LIT>' ] = self . product <EOL> return ctx <EOL> def get_success_url ( self ) : <EOL> msg = _ ( \"<STR_LIT>\" ) % { <EOL> '<STR_LIT:title>' : self . line . get_title ( ) , <EOL> '<STR_LIT:name>' : self . wishlist . name } <EOL> messages . success ( self . request , msg ) <EOL> referrer = safe_referrer ( self . request , '<STR_LIT>' ) <EOL> if ( referrer and self . product and <EOL> self . product . get_absolute_url ( ) in referrer ) : <EOL> return referrer <EOL> else : <EOL> return reverse ( <EOL> '<STR_LIT>' , kwargs = { '<STR_LIT:key>' : self . wishlist . key } ) <EOL> class WishListMoveProductToAnotherWishList ( LineMixin , View ) : <EOL> def dispatch ( self , request , * args , ** kwargs ) : <EOL> try : <EOL> self . fetch_line ( request . user , kwargs [ '<STR_LIT:key>' ] , <EOL> line_pk = kwargs [ '<STR_LIT>' ] ) <EOL> except ( ObjectDoesNotExist , MultipleObjectsReturned ) : <EOL> raise Http404 <EOL> return super ( WishListMoveProductToAnotherWishList , self ) . dispatch ( <EOL> request , * args , ** kwargs ) <EOL> def get ( self , request , * args , ** kwargs ) : <EOL> to_wishlist = get_object_or_404 ( <EOL> WishList , owner = request . user , key = kwargs [ '<STR_LIT>' ] ) <EOL> self . line . wishlist = to_wishlist <EOL>", "answer": "self . line . save ( )"}, {"prompt": "<s> __all__ = [ <EOL> '<STR_LIT>' <EOL> ] <EOL> import base64 <EOL> import hmac <EOL> import datetime <EOL> import uuid <EOL> import copy <EOL> from libcloud . utils . py3 import httplib <EOL> from hashlib import sha1 <EOL> try : <EOL> from lxml import etree as ET <EOL> except ImportError : <EOL> from xml . etree import ElementTree as ET <EOL> from libcloud . utils . py3 import b , urlencode <EOL> from libcloud . utils . xml import findtext , findall , fixxpath <EOL> from libcloud . dns . types import Provider , RecordType <EOL> from libcloud . dns . types import ZoneDoesNotExistError , RecordDoesNotExistError <EOL> from libcloud . dns . base import DNSDriver , Zone , Record <EOL> from libcloud . common . types import LibcloudError <EOL> from libcloud . common . aws import AWSGenericResponse <EOL> from libcloud . common . base import ConnectionUserAndKey <EOL> API_VERSION = '<STR_LIT>' <EOL> API_HOST = '<STR_LIT>' <EOL> API_ROOT = '<STR_LIT>' % ( API_VERSION ) <EOL> NAMESPACE = '<STR_LIT>' % ( API_HOST , API_ROOT ) <EOL> class InvalidChangeBatch ( LibcloudError ) : <EOL> pass <EOL> class Route53DNSResponse ( AWSGenericResponse ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> namespace = NAMESPACE <EOL> xpath = '<STR_LIT>' <EOL> exceptions = { <EOL> '<STR_LIT>' : ZoneDoesNotExistError , <EOL> '<STR_LIT>' : InvalidChangeBatch , <EOL> } <EOL> class Route53Connection ( ConnectionUserAndKey ) : <EOL> host = API_HOST <EOL> responseCls = Route53DNSResponse <EOL> def pre_connect_hook ( self , params , headers ) : <EOL> time_string = datetime . datetime . utcnow ( ) . strftime ( '<STR_LIT>' ) <EOL> headers [ '<STR_LIT>' ] = time_string <EOL> tmp = [ ] <EOL> signature = self . _get_aws_auth_b64 ( self . key , time_string ) <EOL> auth = { '<STR_LIT>' : self . user_id , '<STR_LIT>' : signature , <EOL> '<STR_LIT>' : '<STR_LIT>' } <EOL> for k , v in auth . items ( ) : <EOL> tmp . append ( '<STR_LIT>' % ( k , v ) ) <EOL> headers [ '<STR_LIT>' ] = '<STR_LIT>' + '<STR_LIT:U+002C>' . join ( tmp ) <EOL> return params , headers <EOL> def _get_aws_auth_b64 ( self , secret_key , time_string ) : <EOL> b64_hmac = base64 . b64encode ( <EOL> hmac . new ( b ( secret_key ) , b ( time_string ) , digestmod = sha1 ) . digest ( ) <EOL> ) <EOL> return b64_hmac . decode ( '<STR_LIT:utf-8>' ) <EOL> class Route53DNSDriver ( DNSDriver ) : <EOL> type = Provider . ROUTE53 <EOL> name = '<STR_LIT>' <EOL> website = '<STR_LIT>' <EOL> connectionCls = Route53Connection <EOL> RECORD_TYPE_MAP = { <EOL> RecordType . A : '<STR_LIT:A>' , <EOL> RecordType . AAAA : '<STR_LIT>' , <EOL> RecordType . CNAME : '<STR_LIT>' , <EOL> RecordType . MX : '<STR_LIT>' , <EOL> RecordType . NS : '<STR_LIT>' , <EOL> RecordType . PTR : '<STR_LIT>' , <EOL> RecordType . SOA : '<STR_LIT>' , <EOL> RecordType . SPF : '<STR_LIT>' , <EOL> RecordType . SRV : '<STR_LIT>' , <EOL> RecordType . TXT : '<STR_LIT>' , <EOL> } <EOL> def iterate_zones ( self ) : <EOL> return self . _get_more ( '<STR_LIT>' ) <EOL> def iterate_records ( self , zone ) : <EOL> return self . _get_more ( '<STR_LIT>' , zone = zone ) <EOL> def get_zone ( self , zone_id ) : <EOL> self . connection . set_context ( { '<STR_LIT>' : zone_id } ) <EOL> uri = API_ROOT + '<STR_LIT>' + zone_id <EOL> data = self . connection . request ( uri ) . object <EOL> elem = findall ( element = data , xpath = '<STR_LIT>' , <EOL> namespace = NAMESPACE ) [ <NUM_LIT:0> ] <EOL> return self . _to_zone ( elem ) <EOL> def get_record ( self , zone_id , record_id ) : <EOL> zone = self . get_zone ( zone_id = zone_id ) <EOL> record_type , name = record_id . split ( '<STR_LIT::>' , <NUM_LIT:1> ) <EOL> if name : <EOL> full_name = \"<STR_LIT:.>\" . join ( ( name , zone . domain ) ) <EOL> else : <EOL> full_name = zone . domain <EOL> self . connection . set_context ( { '<STR_LIT>' : zone_id } ) <EOL> params = urlencode ( { <EOL> '<STR_LIT:name>' : full_name , <EOL> '<STR_LIT:type>' : record_type , <EOL> '<STR_LIT>' : '<STR_LIT:1>' <EOL> } ) <EOL> uri = API_ROOT + '<STR_LIT>' + zone_id + '<STR_LIT>' + params <EOL> data = self . connection . request ( uri ) . object <EOL> record = self . _to_records ( data = data , zone = zone ) [ <NUM_LIT:0> ] <EOL> record_type_num = self . _string_to_record_type ( record_type ) <EOL> if record . name != name or record . type != record_type_num : <EOL> raise RecordDoesNotExistError ( value = '<STR_LIT>' , driver = self , <EOL> record_id = record_id ) <EOL> return record <EOL> def create_zone ( self , domain , type = '<STR_LIT>' , ttl = None , extra = None ) : <EOL> zone = ET . Element ( '<STR_LIT>' , { '<STR_LIT>' : NAMESPACE } ) <EOL> ET . SubElement ( zone , '<STR_LIT:Name>' ) . text = domain <EOL> ET . SubElement ( zone , '<STR_LIT>' ) . text = str ( uuid . uuid4 ( ) ) <EOL> if extra and '<STR_LIT>' in extra : <EOL> hzg = ET . SubElement ( zone , '<STR_LIT>' ) <EOL> ET . SubElement ( hzg , '<STR_LIT>' ) . text = extra [ '<STR_LIT>' ] <EOL> uri = API_ROOT + '<STR_LIT>' <EOL> data = ET . tostring ( zone ) <EOL> rsp = self . connection . request ( uri , method = '<STR_LIT:POST>' , data = data ) . object <EOL> elem = findall ( element = rsp , xpath = '<STR_LIT>' , namespace = NAMESPACE ) [ <NUM_LIT:0> ] <EOL> return self . _to_zone ( elem = elem ) <EOL> def delete_zone ( self , zone , ex_delete_records = False ) : <EOL> self . connection . set_context ( { '<STR_LIT>' : zone . id } ) <EOL> if ex_delete_records : <EOL> self . ex_delete_all_records ( zone = zone ) <EOL> uri = API_ROOT + '<STR_LIT>' % ( zone . id ) <EOL> response = self . connection . request ( uri , method = '<STR_LIT>' ) <EOL> return response . status in [ httplib . OK ] <EOL> def create_record ( self , name , zone , type , data , extra = None ) : <EOL> extra = extra or { } <EOL> batch = [ ( '<STR_LIT>' , name , type , data , extra ) ] <EOL> self . _post_changeset ( zone , batch ) <EOL> id = '<STR_LIT::>' . join ( ( self . RECORD_TYPE_MAP [ type ] , name ) ) <EOL> return Record ( id = id , name = name , type = type , data = data , zone = zone , <EOL> driver = self , ttl = extra . get ( '<STR_LIT>' , None ) , extra = extra ) <EOL> def update_record ( self , record , name = None , type = None , data = None , <EOL> extra = None ) : <EOL> name = name or record . name <EOL> type = type or record . type <EOL> extra = extra or record . extra <EOL> if not extra : <EOL> extra = record . extra <EOL> multiple_value_record = record . extra . get ( '<STR_LIT>' , False ) <EOL> other_records = record . extra . get ( '<STR_LIT>' , [ ] ) <EOL> if multiple_value_record and other_records : <EOL> self . _update_multi_value_record ( record = record , name = name , <EOL>", "answer": "type = type , data = data ,"}, {"prompt": "<s> from __future__ import print_function , unicode_literals <EOL> import importlib <EOL> import os <EOL> import sys <EOL> from django . apps import apps <EOL> from django . db . models . fields import NOT_PROVIDED <EOL> from django . utils import datetime_safe , six , timezone <EOL> from django . utils . six . moves import input <EOL> from . loader import MigrationLoader <EOL> class MigrationQuestioner ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , defaults = None , specified_apps = None , dry_run = None ) : <EOL> self . defaults = defaults or { } <EOL> self . specified_apps = specified_apps or set ( ) <EOL> self . dry_run = dry_run <EOL> def ask_initial ( self , app_label ) : <EOL> \"<STR_LIT>\" <EOL> if app_label in self . specified_apps : <EOL> return True <EOL> try : <EOL> app_config = apps . get_app_config ( app_label ) <EOL> except LookupError : <EOL> return self . defaults . get ( \"<STR_LIT>\" , False ) <EOL> migrations_import_path = MigrationLoader ( None , load = False ) . migrations_module ( app_config . label ) <EOL> if migrations_import_path is None : <EOL> return self . defaults . get ( \"<STR_LIT>\" , False ) <EOL> try : <EOL> migrations_module = importlib . import_module ( migrations_import_path ) <EOL> except ImportError : <EOL> return self . defaults . get ( \"<STR_LIT>\" , False ) <EOL> else : <EOL> if hasattr ( migrations_module , \"<STR_LIT>\" ) : <EOL> filenames = os . listdir ( os . path . dirname ( migrations_module . __file__ ) ) <EOL> elif hasattr ( migrations_module , \"<STR_LIT>\" ) : <EOL> if len ( migrations_module . __path__ ) > <NUM_LIT:1> : <EOL> return False <EOL> filenames = os . listdir ( list ( migrations_module . __path__ ) [ <NUM_LIT:0> ] ) <EOL> return not any ( x . endswith ( \"<STR_LIT>\" ) for x in filenames if x != \"<STR_LIT>\" ) <EOL> def ask_not_null_addition ( self , field_name , model_name ) : <EOL> \"<STR_LIT>\" <EOL> return None <EOL> def ask_not_null_alteration ( self , field_name , model_name ) : <EOL> \"<STR_LIT>\" <EOL> return None <EOL> def ask_rename ( self , model_name , old_name , new_name , field_instance ) : <EOL> \"<STR_LIT>\" <EOL> return self . defaults . get ( \"<STR_LIT>\" , False ) <EOL> def ask_rename_model ( self , old_model_state , new_model_state ) : <EOL> \"<STR_LIT>\" <EOL> return self . defaults . get ( \"<STR_LIT>\" , False ) <EOL> def ask_merge ( self , app_label ) : <EOL> \"<STR_LIT>\" <EOL> return self . defaults . get ( \"<STR_LIT>\" , False ) <EOL> class InteractiveMigrationQuestioner ( MigrationQuestioner ) : <EOL> def _boolean_input ( self , question , default = None ) : <EOL> result = input ( \"<STR_LIT>\" % question ) <EOL> if not result and default is not None : <EOL> return default <EOL> while len ( result ) < <NUM_LIT:1> or result [ <NUM_LIT:0> ] . lower ( ) not in \"<STR_LIT>\" : <EOL> result = input ( \"<STR_LIT>\" ) <EOL> return result [ <NUM_LIT:0> ] . lower ( ) == \"<STR_LIT:y>\" <EOL> def _choice_input ( self , question , choices ) : <EOL> print ( question ) <EOL> for i , choice in enumerate ( choices ) : <EOL> print ( \"<STR_LIT>\" % ( i + <NUM_LIT:1> , choice ) ) <EOL> result = input ( \"<STR_LIT>\" ) <EOL> while True : <EOL> try : <EOL> value = int ( result ) <EOL> if <NUM_LIT:0> < value <= len ( choices ) : <EOL> return value <EOL> except ValueError : <EOL> pass <EOL> result = input ( \"<STR_LIT>\" ) <EOL> def _ask_default ( self ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( \"<STR_LIT>\" ) <EOL> while True : <EOL> if six . PY3 : <EOL> code = input ( \"<STR_LIT>\" ) <EOL> else : <EOL> code = input ( \"<STR_LIT>\" ) . decode ( sys . stdin . encoding ) <EOL> if not code : <EOL> print ( \"<STR_LIT>\" ) <EOL> elif code == \"<STR_LIT>\" : <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> else : <EOL> try : <EOL> return eval ( code , { } , { \"<STR_LIT>\" : datetime_safe , \"<STR_LIT>\" : timezone } ) <EOL> except ( SyntaxError , NameError ) as e : <EOL> print ( \"<STR_LIT>\" % e ) <EOL> def ask_not_null_addition ( self , field_name , model_name ) : <EOL> \"<STR_LIT>\" <EOL> if not self . dry_run : <EOL> choice = self . _choice_input ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % ( field_name , model_name ) , <EOL> [ <EOL> ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ) <EOL> if choice == <NUM_LIT:2> : <EOL> sys . exit ( <NUM_LIT:3> ) <EOL> else : <EOL> return self . _ask_default ( ) <EOL> return None <EOL> def ask_not_null_alteration ( self , field_name , model_name ) : <EOL> \"<STR_LIT>\" <EOL> if not self . dry_run : <EOL> choice = self . _choice_input ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % ( field_name , model_name ) , <EOL> [ <EOL> ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) , <EOL> ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" , <EOL> ] <EOL> ) <EOL> if choice == <NUM_LIT:2> : <EOL> return NOT_PROVIDED <EOL> elif choice == <NUM_LIT:3> : <EOL> sys . exit ( <NUM_LIT:3> ) <EOL>", "answer": "else :"}, {"prompt": "<s> from datetime import date <EOL> from django import test <EOL> from django . core . exceptions import ValidationError <EOL> from . models import * <EOL> class ArrayTestMixin ( object ) : <EOL> def test_create_get ( self ) : <EOL> o = self . model . objects . create ( arr = self . arr ) <EOL> o = self . model . objects . get ( id = o . id ) <EOL> self . assertEqual ( o . arr , self . arr ) <EOL> def test_create_lookup ( self ) : <EOL> a = self . model . objects . create ( arr = self . arr ) <EOL> b = self . model . objects . get ( arr = self . arr ) <EOL> self . assertEqual ( a . id , b . id ) <EOL>", "answer": "def test_create_save_get ( self ) :"}, {"prompt": "<s> import logging <EOL> import re <EOL> from pwnlib . log import getLogger <EOL> from pwnlib . memleak import MemLeak <EOL> from pwnlib . util . cyclic import * <EOL> from pwnlib . util . fiddling import randoms <EOL> from pwnlib . util . packing import * <EOL> log = getLogger ( __name__ ) <EOL> class FmtStr ( object ) : <EOL> def __init__ ( self , execute_fmt , offset = None , padlen = <NUM_LIT:0> , numbwritten = <NUM_LIT:0> ) : <EOL> self . execute_fmt = execute_fmt <EOL> self . offset = offset <EOL> self . padlen = padlen <EOL> self . numbwritten = numbwritten <EOL> if self . offset == None : <EOL> self . offset , self . padlen = self . find_offset ( ) <EOL> log . info ( \"<STR_LIT>\" , self . offset ) <EOL> self . writes = [ ] <EOL> self . leaker = MemLeak ( self . _leaker ) <EOL>", "answer": "def leak_stack ( self , offset , prefix = \"<STR_LIT>\" ) :"}, {"prompt": "<s> import datetime <EOL> from south . db import db <EOL> from south . v2 import DataMigration <EOL> from django . db import models <EOL> class Migration ( DataMigration ) : <EOL> def forwards ( self , orm ) : <EOL> \"<STR_LIT>\" <EOL> for disk in orm [ '<STR_LIT>' ] . objects . all ( ) : <EOL> if disk . disk_description . lower ( ) . startswith ( '<STR_LIT>' ) : <EOL> disk . disk_description = '<STR_LIT>' <EOL> disk . save ( ) <EOL> def backwards ( self , orm ) : <EOL> \"<STR_LIT>\" <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:0>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:null>' : '<STR_LIT:True>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:False>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT:2>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : \"<STR_LIT>\" , '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL>", "answer": "'<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __authors__ = \"<STR_LIT>\" \"<STR_LIT>\" <EOL> __copyright__ = \"<STR_LIT>\" <EOL> __credits__ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" ] <EOL> __license__ = \"<STR_LIT>\" <EOL> __maintainer__ = \"<STR_LIT>\" <EOL> __email__ = \"<STR_LIT>\" <EOL> import copy <EOL> import logging <EOL> import time <EOL> import warnings <EOL> import os <EOL> import numpy <EOL> from theano . compat . six . moves import xrange <EOL> import scipy <EOL> try : <EOL> from scipy import linalg <EOL> except ImportError : <EOL> warnings . warn ( \"<STR_LIT>\" ) <EOL> import theano <EOL> from theano import function , tensor <EOL> from pylearn2 . blocks import Block <EOL> from pylearn2 . linear . conv2d import Conv2D <EOL> from pylearn2 . space import Conv2DSpace , VectorSpace <EOL> from pylearn2 . expr . preprocessing import global_contrast_normalize <EOL> from pylearn2 . utils . insert_along_axis import insert_columns <EOL> from pylearn2 . utils import sharedX <EOL> from pylearn2 . utils . exc import reraise_as <EOL> from pylearn2 . utils . rng import make_np_rng <EOL> from pylearn2 . utils import contains_nan <EOL> log = logging . getLogger ( __name__ ) <EOL> convert_axes = Conv2DSpace . convert_numpy <EOL> class Preprocessor ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def apply ( self , dataset , can_fit = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( str ( type ( self ) ) + <EOL> \"<STR_LIT>\" ) <EOL> def invert ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class ExamplewisePreprocessor ( Preprocessor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def as_block ( self ) : <EOL> raise NotImplementedError ( str ( type ( self ) ) + <EOL> \"<STR_LIT>\" ) <EOL> class BlockPreprocessor ( ExamplewisePreprocessor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , block ) : <EOL> self . block = block <EOL> def apply ( self , dataset , can_fit = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert not can_fit <EOL> dataset . X = self . block . perform ( dataset . X ) <EOL> class Pipeline ( Preprocessor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , items = None ) : <EOL> self . items = items if items is not None else [ ] <EOL> def apply ( self , dataset , can_fit = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for item in self . items : <EOL> item . apply ( dataset , can_fit ) <EOL> class ExtractGridPatches ( Preprocessor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , patch_shape , patch_stride ) : <EOL> self . patch_shape = patch_shape <EOL> self . patch_stride = patch_stride <EOL> def apply ( self , dataset , can_fit = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> X = dataset . get_topological_view ( ) <EOL> num_topological_dimensions = len ( X . shape ) - <NUM_LIT:2> <EOL> if num_topological_dimensions != len ( self . patch_shape ) : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> + str ( len ( self . patch_shape ) ) <EOL> + \"<STR_LIT>\" <EOL> + \"<STR_LIT>\" + <EOL> str ( num_topological_dimensions ) + \"<STR_LIT:.>\" ) <EOL> num_patches = X . shape [ <NUM_LIT:0> ] <EOL> max_strides = [ X . shape [ <NUM_LIT:0> ] - <NUM_LIT:1> ] <EOL> for i in xrange ( num_topological_dimensions ) : <EOL> patch_width = self . patch_shape [ i ] <EOL> data_width = X . shape [ i + <NUM_LIT:1> ] <EOL> last_valid_coord = data_width - patch_width <EOL> if last_valid_coord < <NUM_LIT:0> : <EOL> raise ValueError ( '<STR_LIT>' + str ( i ) + <EOL> '<STR_LIT>' + str ( data_width ) + <EOL> '<STR_LIT>' + <EOL> str ( patch_width ) ) <EOL> stride = self . patch_stride [ i ] <EOL> if stride == <NUM_LIT:0> : <EOL> max_stride_this_axis = <NUM_LIT:0> <EOL> else : <EOL> max_stride_this_axis = last_valid_coord / stride <EOL> num_strides_this_axis = max_stride_this_axis + <NUM_LIT:1> <EOL> max_strides . append ( max_stride_this_axis ) <EOL> num_patches *= num_strides_this_axis <EOL> output_shape = [ num_patches ] <EOL> for dim in self . patch_shape : <EOL> output_shape . append ( dim ) <EOL> output_shape . append ( X . shape [ - <NUM_LIT:1> ] ) <EOL> output = numpy . zeros ( output_shape , dtype = X . dtype ) <EOL> channel_slice = slice ( <NUM_LIT:0> , X . shape [ - <NUM_LIT:1> ] ) <EOL> coords = [ <NUM_LIT:0> ] * ( num_topological_dimensions + <NUM_LIT:1> ) <EOL> keep_going = True <EOL> i = <NUM_LIT:0> <EOL> while keep_going : <EOL> args = [ coords [ <NUM_LIT:0> ] ] <EOL> for j in xrange ( num_topological_dimensions ) : <EOL> coord = coords [ j + <NUM_LIT:1> ] * self . patch_stride [ j ] <EOL> args . append ( slice ( coord , coord + self . patch_shape [ j ] ) ) <EOL> args . append ( channel_slice ) <EOL> patch = X [ args ] <EOL> output [ i , : ] = patch <EOL> i += <NUM_LIT:1> <EOL> j = <NUM_LIT:0> <EOL> keep_going = False <EOL> while not keep_going : <EOL> if coords [ - ( j + <NUM_LIT:1> ) ] < max_strides [ - ( j + <NUM_LIT:1> ) ] : <EOL> coords [ - ( j + <NUM_LIT:1> ) ] += <NUM_LIT:1> <EOL> keep_going = True <EOL> else : <EOL> coords [ - ( j + <NUM_LIT:1> ) ] = <NUM_LIT:0> <EOL> if j == num_topological_dimensions : <EOL> break <EOL> j = j + <NUM_LIT:1> <EOL> dataset . set_topological_view ( output ) <EOL> if dataset . y is not None : <EOL> dataset . y = numpy . repeat ( dataset . y , num_patches / X . shape [ <NUM_LIT:0> ] ) <EOL> class ReassembleGridPatches ( Preprocessor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , orig_shape , patch_shape ) : <EOL> self . patch_shape = patch_shape <EOL> self . orig_shape = orig_shape <EOL> def apply ( self , dataset , can_fit = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> patches = dataset . get_topological_view ( ) <EOL> num_topological_dimensions = len ( patches . shape ) - <NUM_LIT:2> <EOL> if num_topological_dimensions != len ( self . patch_shape ) : <EOL> raise ValueError ( \"<STR_LIT>\" + <EOL> str ( len ( self . patch_shape ) ) + <EOL> \"<STR_LIT>\" + <EOL> \"<STR_LIT>\" + <EOL> str ( num_topological_dimensions ) + \"<STR_LIT:.>\" ) <EOL> num_patches = patches . shape [ <NUM_LIT:0> ] <EOL> num_examples = num_patches <EOL> for im_dim , patch_dim in zip ( self . orig_shape , self . patch_shape ) : <EOL> if im_dim % patch_dim != <NUM_LIT:0> : <EOL> raise Exception ( '<STR_LIT>' + <EOL> str ( self . patch_shape ) + '<STR_LIT>' + <EOL> '<STR_LIT>' + str ( self . orig_shape ) ) <EOL> patches_this_dim = im_dim / patch_dim <EOL> if num_examples % patches_this_dim != <NUM_LIT:0> : <EOL> raise Exception ( '<STR_LIT>' + str ( num_patches ) + <EOL> '<STR_LIT>' + str ( self . patch_shape ) + <EOL> '<STR_LIT>' + str ( self . orig_shape ) <EOL> ) <EOL> num_examples /= patches_this_dim <EOL> reassembled_shape = [ num_examples ] <EOL> for dim in self . orig_shape : <EOL> reassembled_shape . append ( dim ) <EOL> reassembled_shape . append ( patches . shape [ - <NUM_LIT:1> ] ) <EOL> reassembled = numpy . zeros ( reassembled_shape , dtype = patches . dtype ) <EOL> channel_slice = slice ( <NUM_LIT:0> , patches . shape [ - <NUM_LIT:1> ] ) <EOL> coords = [ <NUM_LIT:0> ] * ( num_topological_dimensions + <NUM_LIT:1> ) <EOL> max_strides = [ num_examples - <NUM_LIT:1> ] <EOL> for dim , pd in zip ( self . orig_shape , self . patch_shape ) : <EOL> assert dim % pd == <NUM_LIT:0> <EOL> max_strides . append ( dim / pd - <NUM_LIT:1> ) <EOL> keep_going = True <EOL> i = <NUM_LIT:0> <EOL> while keep_going : <EOL> args = [ coords [ <NUM_LIT:0> ] ] <EOL> for j in xrange ( num_topological_dimensions ) : <EOL> coord = coords [ j + <NUM_LIT:1> ] <EOL> args . append ( slice ( coord * self . patch_shape [ j ] , <EOL> ( coord + <NUM_LIT:1> ) * self . patch_shape [ j ] ) ) <EOL> next_shape_coord = reassembled . shape [ j + <NUM_LIT:1> ] <EOL> assert ( coord + <NUM_LIT:1> ) * self . patch_shape [ j ] <= next_shape_coord <EOL> args . append ( channel_slice ) <EOL> try : <EOL> patch = patches [ i , : ] <EOL> except IndexError : <EOL> reraise_as ( IndexError ( '<STR_LIT>' + str ( i ) + <EOL> '<STR_LIT>' + <EOL> str ( patches . shape ) ) ) <EOL> reassembled [ args ] = patch <EOL> i += <NUM_LIT:1> <EOL> j = <NUM_LIT:0> <EOL> keep_going = False <EOL> while not keep_going : <EOL> if coords [ - ( j + <NUM_LIT:1> ) ] < max_strides [ - ( j + <NUM_LIT:1> ) ] : <EOL> coords [ - ( j + <NUM_LIT:1> ) ] += <NUM_LIT:1> <EOL> keep_going = True <EOL> else : <EOL> coords [ - ( j + <NUM_LIT:1> ) ] = <NUM_LIT:0> <EOL> if j == num_topological_dimensions : <EOL> break <EOL> j = j + <NUM_LIT:1> <EOL> dataset . set_topological_view ( reassembled ) <EOL> if dataset . y is not None : <EOL> dataset . y = dataset . y [ : : patches . shape [ <NUM_LIT:0> ] / reassembled_shape [ <NUM_LIT:0> ] ] <EOL> class ExtractPatches ( Preprocessor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , patch_shape , num_patches , rng = None ) : <EOL> self . patch_shape = patch_shape <EOL> self . num_patches = num_patches <EOL> self . start_rng = make_np_rng ( copy . copy ( rng ) , <EOL> [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] , <EOL> which_method = \"<STR_LIT>\" ) <EOL> def apply ( self , dataset , can_fit = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rng = copy . copy ( self . start_rng ) <EOL> X = dataset . get_topological_view ( ) <EOL> num_topological_dimensions = len ( X . shape ) - <NUM_LIT:2> <EOL> if num_topological_dimensions != len ( self . patch_shape ) : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> + str ( len ( self . patch_shape ) ) <EOL> + \"<STR_LIT>\" <EOL> + \"<STR_LIT>\" <EOL> + str ( num_topological_dimensions ) + \"<STR_LIT:.>\" ) <EOL> output_shape = [ self . num_patches ] <EOL> for dim in self . patch_shape : <EOL> output_shape . append ( dim ) <EOL> output_shape . append ( X . shape [ - <NUM_LIT:1> ] ) <EOL> output = numpy . zeros ( output_shape , dtype = X . dtype ) <EOL> channel_slice = slice ( <NUM_LIT:0> , X . shape [ - <NUM_LIT:1> ] ) <EOL> for i in xrange ( self . num_patches ) : <EOL> args = [ ] <EOL> args . append ( rng . randint ( X . shape [ <NUM_LIT:0> ] ) ) <EOL> for j in xrange ( num_topological_dimensions ) : <EOL> max_coord = X . shape [ j + <NUM_LIT:1> ] - self . patch_shape [ j ] <EOL> coord = rng . randint ( max_coord + <NUM_LIT:1> ) <EOL> args . append ( slice ( coord , coord + self . patch_shape [ j ] ) ) <EOL> args . append ( channel_slice ) <EOL> output [ i , : ] = X [ args ] <EOL> dataset . set_topological_view ( output ) <EOL> dataset . y = None <EOL> class ExamplewiseUnitNormBlock ( Block ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , input_space = None ) : <EOL> super ( ExamplewiseUnitNormBlock , self ) . __init__ ( ) <EOL> self . input_space = input_space <EOL> def __call__ ( self , batch ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . input_space : <EOL> self . input_space . validate ( batch ) <EOL> squared_batch = batch ** <NUM_LIT:2> <EOL> squared_norm = squared_batch . sum ( axis = <NUM_LIT:1> ) <EOL> norm = tensor . sqrt ( squared_norm ) <EOL> return batch / norm <EOL> def set_input_space ( self , space ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . input_space = space <EOL> def get_input_space ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . input_space is not None : <EOL> return self . input_space <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % <EOL> str ( self ) ) <EOL> def get_output_space ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . get_input_space ( ) <EOL> class MakeUnitNorm ( ExamplewisePreprocessor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def apply ( self , dataset , can_fit = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> X = dataset . get_design_matrix ( ) <EOL> X_norm = numpy . sqrt ( numpy . sum ( X ** <NUM_LIT:2> , axis = <NUM_LIT:1> ) ) <EOL> X /= X_norm [ : , None ] <EOL> dataset . set_design_matrix ( X ) <EOL> def as_block ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return ExamplewiseUnitNormBlock ( ) <EOL> class ExamplewiseAddScaleTransform ( Block ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , add = None , multiply = None , multiply_first = False , <EOL> input_space = None ) : <EOL> self . add = numpy . asarray ( add ) <EOL> self . multiply = numpy . asarray ( multiply ) <EOL> if multiply is not None : <EOL> self . _has_zeros = numpy . any ( abs ( multiply ) < <NUM_LIT> ) <EOL> else : <EOL> self . _has_zeros = False <EOL> self . _multiply_first = multiply_first <EOL> self . input_space = input_space <EOL> def _multiply ( self , batch ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . multiply is not None : <EOL> batch *= self . multiply <EOL> return batch <EOL> def _add ( self , batch ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . add is not None : <EOL> batch += self . add <EOL> return batch <EOL> def __call__ ( self , batch ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . input_space : <EOL> self . input_space . validate ( batch ) <EOL> cur = batch <EOL> if self . _multiply_first : <EOL> batch = self . _add ( self . _multiply ( batch ) ) <EOL> else : <EOL> batch = self . _multiply ( self . _add ( batch ) ) <EOL> return batch <EOL> def inverse ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _multiply is not None and self . _has_zeros : <EOL> raise ZeroDivisionError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % <EOL> self . __class__ . __name__ ) <EOL> else : <EOL> mult_inverse = self . _multiply ** - <NUM_LIT:1.> <EOL> return self . __class__ ( add = - self . _add , multiply = mult_inverse , <EOL> multiply_first = not self . _multiply_first ) <EOL> def set_input_space ( self , space ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . input_space = space <EOL> def get_input_space ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . input_space is not None : <EOL> return self . input_space <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % <EOL> str ( self ) ) <EOL> def get_output_space ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . get_input_space ( ) <EOL> class RemoveMean ( ExamplewisePreprocessor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , axis = <NUM_LIT:0> ) : <EOL> self . _axis = axis <EOL> self . _mean = None <EOL> def apply ( self , dataset , can_fit = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> X = dataset . get_design_matrix ( ) <EOL> if can_fit : <EOL> self . _mean = X . mean ( axis = self . _axis ) <EOL> else : <EOL> if self . _mean is None : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> X -= self . _mean <EOL> dataset . set_design_matrix ( X ) <EOL> def as_block ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _mean is None : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> % self . __class__ . __name__ ) <EOL> return ExamplewiseAddScaleTransform ( add = - self . _mean ) <EOL> class Standardize ( ExamplewisePreprocessor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , global_mean = False , global_std = False , std_eps = <NUM_LIT> ) : <EOL> self . _global_mean = global_mean <EOL> self . _global_std = global_std <EOL> self . _std_eps = std_eps <EOL> self . _mean = None <EOL> self . _std = None <EOL> def apply ( self , dataset , can_fit = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> X = dataset . get_design_matrix ( ) <EOL> if can_fit : <EOL> self . _mean = X . mean ( ) if self . _global_mean else X . mean ( axis = <NUM_LIT:0> ) <EOL> self . _std = X . std ( ) if self . _global_std else X . std ( axis = <NUM_LIT:0> ) <EOL> else : <EOL> if self . _mean is None or self . _std is None : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> new = ( X - self . _mean ) / ( self . _std_eps + self . _std ) <EOL> dataset . set_design_matrix ( new ) <EOL> def as_block ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _mean is None or self . _std is None : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> % self . __class__ . __name__ ) <EOL> return ExamplewiseAddScaleTransform ( add = - self . _mean , <EOL> multiply = self . _std ** - <NUM_LIT:1> ) <EOL> class ColumnSubsetBlock ( Block ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , columns , total ) : <EOL> self . _columns = columns <EOL> self . _total = total <EOL> def __call__ ( self , batch ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if batch . ndim != <NUM_LIT:2> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return batch . dimshuffle ( <NUM_LIT:1> , <NUM_LIT:0> ) [ self . _columns ] . dimshuffle ( <NUM_LIT:1> , <NUM_LIT:0> ) <EOL> def inverse ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return ZeroColumnInsertBlock ( self . _columns , self . _total ) <EOL> def get_input_space ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return VectorSpace ( dim = self . _total ) <EOL> def get_output_space ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return VectorSpace ( dim = self . _columns ) <EOL> class ZeroColumnInsertBlock ( Block ) : <EOL> def __init__ ( self , columns , total ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _columns = columns <EOL> self . _total = total <EOL> def __call__ ( self , batch ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if batch . ndim != <NUM_LIT:2> : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return insert_columns ( batch , self . _total , self . _columns ) <EOL> def inverse ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return ColumnSubsetBlock ( self . _columns , self . _total ) <EOL> def get_input_space ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return VectorSpace ( dim = self . _columns ) <EOL> def get_output_space ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return VectorSpace ( dim = self . _total ) <EOL> class RemoveZeroColumns ( ExamplewisePreprocessor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _eps = <NUM_LIT> <EOL> def __init__ ( self ) : <EOL> self . _block = None <EOL> def apply ( self , dataset , can_fit = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> design_matrix = dataset . get_design_matrix ( ) <EOL> mean = design_matrix . mean ( axis = <NUM_LIT:0> ) <EOL> var = design_matrix . var ( axis = <NUM_LIT:0> ) <EOL> columns , = numpy . where ( ( var < self . _eps ) & ( mean < self . _eps ) ) <EOL> self . _block = ColumnSubsetBlock <EOL> def as_block ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _block is None : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> % self . __class__ . __name__ ) <EOL> return self . _block <EOL> class RemapInterval ( ExamplewisePreprocessor ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , map_from , map_to ) : <EOL> assert map_from [ <NUM_LIT:0> ] < map_from [ <NUM_LIT:1> ] and len ( map_from ) == <NUM_LIT:2> <EOL> assert map_to [ <NUM_LIT:0> ] < map_to [ <NUM_LIT:1> ] and len ( map_to ) == <NUM_LIT:2> <EOL> self . map_from = [ numpy . float ( x ) for x in map_from ] <EOL> self . map_to = [ numpy . float ( x ) for x in map_to ] <EOL> def apply ( self , dataset , can_fit = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> X = dataset . get_design_matrix ( ) <EOL> X = ( X - self . map_from [ <NUM_LIT:0> ] ) / numpy . diff ( self . map_from ) <EOL> X = X * numpy . diff ( self . map_to ) + self . map_to [ <NUM_LIT:0> ] <EOL> dataset . set_design_matrix ( X ) <EOL> class PCA_ViewConverter ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , to_pca , to_input , to_weights , orig_view_converter ) : <EOL> self . to_pca = to_pca <EOL> self . to_input = to_input <EOL> self . to_weights = to_weights <EOL> if orig_view_converter is None : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> self . orig_view_converter = orig_view_converter <EOL> def view_shape ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . orig_view_converter . shape <EOL> def design_mat_to_topo_view ( self , X ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> to_input = self . to_input ( X ) <EOL> return self . orig_view_converter . design_mat_to_topo_view ( to_input ) <EOL> def design_mat_to_weights_view ( self , X ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> to_weights = self . to_weights ( X ) <EOL> return self . orig_view_converter . design_mat_to_weights_view ( to_weights ) <EOL> def topo_view_to_design_mat ( self , V ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . to_pca ( self . orig_view_converter . topo_view_to_design_mat ( V ) ) <EOL> def get_formatted_batch ( self , batch , dspace ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( dspace , VectorSpace ) : <EOL> dspace . np_validate ( batch ) <EOL> return batch <EOL> else : <EOL> to_input = self . to_input ( batch ) <EOL> return self . orig_view_converter . get_formatted_batch ( to_input , <EOL> dspace ) <EOL> class PCA ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , num_components , whiten = False ) : <EOL> self . _num_components = num_components <EOL> self . _whiten = whiten <EOL> self . _pca = None <EOL> self . _input = tensor . matrix ( ) <EOL> self . _output = tensor . matrix ( ) <EOL> def apply ( self , dataset , can_fit = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _pca is None : <EOL> if not can_fit : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> from pylearn2 . models import pca <EOL> self . _pca = pca . CovEigPCA ( num_components = self . _num_components , <EOL> whiten = self . _whiten ) <EOL> self . _pca . train ( dataset . get_design_matrix ( ) ) <EOL> self . _transform_func = function ( [ self . _input ] , <EOL> self . _pca ( self . _input ) ) <EOL> self . _invert_func = function ( [ self . _output ] , <EOL> self . _pca . reconstruct ( self . _output ) ) <EOL> self . _convert_weights_func = function ( <EOL> [ self . _output ] , <EOL> self . _pca . reconstruct ( self . _output , add_mean = False ) <EOL> ) <EOL> orig_data = dataset . get_design_matrix ( ) <EOL> dataset . set_design_matrix ( <EOL> self . _transform_func ( dataset . get_design_matrix ( ) ) <EOL> ) <EOL> proc_data = dataset . get_design_matrix ( ) <EOL>", "answer": "orig_var = orig_data . var ( axis = <NUM_LIT:0> )"}, {"prompt": "<s> import dxpy <EOL> import argparse <EOL> import sys <EOL> parser = argparse . ArgumentParser ( description = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , help = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , dest = \"<STR_LIT>\" , default = None , help = \"<STR_LIT>\" ) <EOL> def writeFastq ( row , fh ) : <EOL> if '<STR_LIT:name>' in row : <EOL> fh . write ( \"<STR_LIT>\" . join ( [ \"<STR_LIT:@>\" , row [ '<STR_LIT:name>' ] , \"<STR_LIT:\\n>\" ] ) ) <EOL> else : <EOL> fh . write ( \"<STR_LIT>\" ) <EOL> fh . write ( row [ '<STR_LIT>' ] + \"<STR_LIT:\\n>\" ) <EOL> fh . write ( \"<STR_LIT>\" ) <EOL> fh . write ( row [ '<STR_LIT>' ] + \"<STR_LIT:\\n>\" ) <EOL> def writeFasta ( row , fh ) : <EOL> if '<STR_LIT:name>' in row : <EOL> fh . write ( \"<STR_LIT>\" . join ( [ \"<STR_LIT:>>\" , row [ '<STR_LIT:name>' ] , \"<STR_LIT:\\n>\" ] ) ) <EOL> else : <EOL> fh . write ( \"<STR_LIT>\" ) <EOL> fh . write ( row [ '<STR_LIT>' ] + \"<STR_LIT:\\n>\" ) <EOL> def main ( ** kwargs ) : <EOL> if len ( kwargs ) == <NUM_LIT:0> : <EOL> opts = parser . parse_args ( sys . argv [ <NUM_LIT:1> : ] ) <EOL> else : <EOL> opts = parser . parse_args ( kwargs ) <EOL> if opts . mappings_id == None : <EOL> parser . print_help ( ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> mappingsTable = dxpy . DXGTable ( opts . mappings_id ) <EOL> if opts . file_name != None : <EOL> fh = open ( opts . file_name , \"<STR_LIT:w>\" ) <EOL> else : <EOL> fh = sys . stdout <EOL> if '<STR_LIT>' in mappingsTable . get_col_names ( ) : <EOL> outputFastq = True <EOL> else : <EOL> outputFastq = False <EOL> for row in mappingsTable . iterate_rows ( want_dict = True ) : <EOL>", "answer": "if outputFastq :"}, {"prompt": "<s> from oslo_config import cfg <EOL> from six . moves import http_client as httplib <EOL> from webob import exc <EOL> from neutron import context <EOL> from neutron . extensions import portbindings <EOL> from neutron import manager <EOL> from neutron . tests . unit . db import test_db_base_plugin_v2 <EOL> class PortBindingsTestCase ( test_db_base_plugin_v2 . NeutronDbPluginV2TestCase ) : <EOL> VIF_TYPE = portbindings . VIF_TYPE_OTHER <EOL> VIF_DETAILS = None <EOL> def _check_response_portbindings ( self , port ) : <EOL> self . assertEqual ( port [ portbindings . VIF_TYPE ] , self . VIF_TYPE ) <EOL> if self . VIF_TYPE not in [ portbindings . VIF_TYPE_UNBOUND , <EOL> portbindings . VIF_TYPE_BINDING_FAILED ] : <EOL> if self . VIF_DETAILS is None : <EOL> expected = getattr ( self , '<STR_LIT>' , False ) <EOL> vif_details = port [ portbindings . VIF_DETAILS ] <EOL> port_filter = vif_details [ portbindings . CAP_PORT_FILTER ] <EOL> self . assertEqual ( expected , port_filter ) <EOL> return <EOL> self . assertEqual ( self . VIF_DETAILS , port [ portbindings . VIF_DETAILS ] ) <EOL> def _check_response_no_portbindings ( self , port ) : <EOL> self . assertIn ( '<STR_LIT:status>' , port ) <EOL> self . assertNotIn ( portbindings . VIF_TYPE , port ) <EOL> self . assertNotIn ( portbindings . VIF_DETAILS , port ) <EOL> def _get_non_admin_context ( self ) : <EOL> return context . Context ( user_id = None , <EOL> tenant_id = self . _tenant_id , <EOL> is_admin = False ) <EOL> def test_port_vif_details ( self ) : <EOL> with self . port ( name = '<STR_LIT:name>' ) as port : <EOL> port_id = port [ '<STR_LIT:port>' ] [ '<STR_LIT:id>' ] <EOL> self . _check_response_portbindings ( port [ '<STR_LIT:port>' ] ) <EOL> ctx = context . get_admin_context ( ) <EOL> port = self . _show ( '<STR_LIT>' , port_id , neutron_context = ctx ) [ '<STR_LIT:port>' ] <EOL> self . _check_response_portbindings ( port ) <EOL> ctx = self . _get_non_admin_context ( ) <EOL> non_admin_port = self . _show ( <EOL> '<STR_LIT>' , port_id , neutron_context = ctx ) [ '<STR_LIT:port>' ] <EOL> self . _check_response_no_portbindings ( non_admin_port ) <EOL> def test_ports_vif_details ( self ) : <EOL> plugin = manager . NeutronManager . get_plugin ( ) <EOL> cfg . CONF . set_default ( '<STR_LIT>' , True ) <EOL> with self . port ( ) , self . port ( ) : <EOL> ctx = context . get_admin_context ( ) <EOL> ports = plugin . get_ports ( ctx ) <EOL> self . assertEqual ( len ( ports ) , <NUM_LIT:2> ) <EOL> for port in ports : <EOL> self . _check_response_portbindings ( port ) <EOL> ctx = self . _get_non_admin_context ( ) <EOL> ports = self . _list ( '<STR_LIT>' , neutron_context = ctx ) [ '<STR_LIT>' ] <EOL> self . assertEqual ( len ( ports ) , <NUM_LIT:2> ) <EOL> for non_admin_port in ports : <EOL> self . _check_response_no_portbindings ( non_admin_port ) <EOL> def _check_port_binding_profile ( self , port , profile = None ) : <EOL> self . assertIn ( '<STR_LIT:id>' , port ) <EOL> def _test_create_port_binding_profile ( self , profile ) : <EOL> profile_arg = { portbindings . PROFILE : profile } <EOL> with self . port ( arg_list = ( portbindings . PROFILE , ) , <EOL> ** profile_arg ) as port : <EOL> port_id = port [ '<STR_LIT:port>' ] [ '<STR_LIT:id>' ] <EOL> self . _check_port_binding_profile ( port [ '<STR_LIT:port>' ] , profile ) <EOL> port = self . _show ( '<STR_LIT>' , port_id ) <EOL> self . _check_port_binding_profile ( port [ '<STR_LIT:port>' ] , profile ) <EOL> def test_create_port_binding_profile_none ( self ) : <EOL> self . _test_create_port_binding_profile ( None ) <EOL> def test_create_port_binding_profile_with_empty_dict ( self ) : <EOL> self . _test_create_port_binding_profile ( { } ) <EOL> def _test_update_port_binding_profile ( self , profile ) : <EOL> profile_arg = { portbindings . PROFILE : profile } <EOL> with self . port ( ) as port : <EOL> self . _check_port_binding_profile ( port [ '<STR_LIT:port>' ] ) <EOL> port_id = port [ '<STR_LIT:port>' ] [ '<STR_LIT:id>' ] <EOL> ctx = context . get_admin_context ( ) <EOL> port = self . _update ( '<STR_LIT>' , port_id , { '<STR_LIT:port>' : profile_arg } , <EOL> neutron_context = ctx ) [ '<STR_LIT:port>' ] <EOL> self . _check_port_binding_profile ( port , profile ) <EOL> port = self . _show ( '<STR_LIT>' , port_id ) [ '<STR_LIT:port>' ] <EOL> self . _check_port_binding_profile ( port , profile ) <EOL> def test_update_port_binding_profile_none ( self ) : <EOL> self . _test_update_port_binding_profile ( None ) <EOL> def test_update_port_binding_profile_with_empty_dict ( self ) : <EOL> self . _test_update_port_binding_profile ( { } ) <EOL> def test_port_create_portinfo_non_admin ( self ) : <EOL> profile_arg = { portbindings . PROFILE : { '<STR_LIT>' : '<STR_LIT>' } } <EOL> with self . network ( set_context = True , tenant_id = '<STR_LIT:test>' ) as net1 : <EOL> with self . subnet ( network = net1 ) as subnet1 : <EOL> with self . port ( subnet = subnet1 , <EOL> set_context = True , tenant_id = '<STR_LIT:test>' ) : <EOL> pass <EOL> try : <EOL> with self . port ( subnet = subnet1 , <EOL> expected_res_status = <NUM_LIT> , <EOL> arg_list = ( portbindings . PROFILE , ) , <EOL> set_context = True , tenant_id = '<STR_LIT:test>' , <EOL> ** profile_arg ) : <EOL> pass <EOL> except exc . HTTPClientError : <EOL> pass <EOL> def test_port_update_portinfo_non_admin ( self ) : <EOL> profile_arg = { portbindings . PROFILE : { '<STR_LIT>' : '<STR_LIT>' } } <EOL> with self . network ( ) as net1 : <EOL> with self . subnet ( network = net1 ) as subnet1 : <EOL> with self . port ( subnet = subnet1 ) as port : <EOL> port_id = port [ '<STR_LIT:port>' ] [ '<STR_LIT:id>' ] <EOL> ctx = self . _get_non_admin_context ( ) <EOL> port = self . _update ( '<STR_LIT>' , port_id , <EOL> { '<STR_LIT:port>' : profile_arg } , <EOL> expected_code = exc . HTTPForbidden . code , <EOL> neutron_context = ctx ) <EOL> class PortBindingsHostTestCaseMixin ( object ) : <EOL> fmt = '<STR_LIT>' <EOL> hostname = '<STR_LIT>' <EOL> def _check_response_portbindings_host ( self , port ) : <EOL> self . assertEqual ( port [ portbindings . HOST_ID ] , self . hostname ) <EOL> def _check_response_no_portbindings_host ( self , port ) : <EOL> self . assertIn ( '<STR_LIT:status>' , port ) <EOL> self . assertNotIn ( portbindings . HOST_ID , port ) <EOL> def test_port_vif_non_admin ( self ) : <EOL> with self . network ( set_context = True , <EOL> tenant_id = '<STR_LIT:test>' ) as net1 : <EOL> with self . subnet ( network = net1 ) as subnet1 : <EOL> host_arg = { portbindings . HOST_ID : self . hostname } <EOL> try : <EOL> with self . port ( subnet = subnet1 , <EOL> expected_res_status = <NUM_LIT> , <EOL> arg_list = ( portbindings . HOST_ID , ) , <EOL> set_context = True , <EOL> tenant_id = '<STR_LIT:test>' , <EOL> ** host_arg ) : <EOL> pass <EOL> except exc . HTTPClientError : <EOL> pass <EOL> def test_port_vif_host ( self ) : <EOL> host_arg = { portbindings . HOST_ID : self . hostname } <EOL> with self . port ( name = '<STR_LIT:name>' , arg_list = ( portbindings . HOST_ID , ) , <EOL> ** host_arg ) as port : <EOL> port_id = port [ '<STR_LIT:port>' ] [ '<STR_LIT:id>' ] <EOL> self . _check_response_portbindings_host ( port [ '<STR_LIT:port>' ] ) <EOL> ctx = context . get_admin_context ( ) <EOL> port = self . _show ( '<STR_LIT>' , port_id , neutron_context = ctx ) [ '<STR_LIT:port>' ] <EOL> self . _check_response_portbindings_host ( port ) <EOL> ctx = context . Context ( user_id = None , <EOL> tenant_id = self . _tenant_id , <EOL> is_admin = False ) <EOL> non_admin_port = self . _show ( <EOL> '<STR_LIT>' , port_id , neutron_context = ctx ) [ '<STR_LIT:port>' ] <EOL> self . _check_response_no_portbindings_host ( non_admin_port ) <EOL> def test_ports_vif_host ( self ) : <EOL> cfg . CONF . set_default ( '<STR_LIT>' , True ) <EOL> host_arg = { portbindings . HOST_ID : self . hostname } <EOL> with self . port ( name = '<STR_LIT>' , <EOL> arg_list = ( portbindings . HOST_ID , ) , <EOL> ** host_arg ) , self . port ( name = '<STR_LIT>' ) : <EOL> ctx = context . get_admin_context ( ) <EOL> ports = self . _list ( '<STR_LIT>' , neutron_context = ctx ) [ '<STR_LIT>' ] <EOL> self . assertEqual ( <NUM_LIT:2> , len ( ports ) ) <EOL> for port in ports : <EOL> if port [ '<STR_LIT:name>' ] == '<STR_LIT>' : <EOL> self . _check_response_portbindings_host ( port ) <EOL> else : <EOL> self . assertFalse ( port [ portbindings . HOST_ID ] ) <EOL> ctx = context . Context ( user_id = None , <EOL> tenant_id = self . _tenant_id , <EOL> is_admin = False ) <EOL> ports = self . _list ( '<STR_LIT>' , neutron_context = ctx ) [ '<STR_LIT>' ] <EOL> self . assertEqual ( <NUM_LIT:2> , len ( ports ) ) <EOL> for non_admin_port in ports : <EOL> self . _check_response_no_portbindings_host ( non_admin_port ) <EOL> def test_ports_vif_host_update ( self ) : <EOL> cfg . CONF . set_default ( '<STR_LIT>' , True ) <EOL> host_arg = { portbindings . HOST_ID : self . hostname } <EOL> with self . port ( name = '<STR_LIT>' , arg_list = ( portbindings . HOST_ID , ) , <EOL> ** host_arg ) as port1 , self . port ( name = '<STR_LIT>' ) as port2 : <EOL> data = { '<STR_LIT:port>' : { portbindings . HOST_ID : '<STR_LIT>' } } <EOL> req = self . new_update_request ( '<STR_LIT>' , data , port1 [ '<STR_LIT:port>' ] [ '<STR_LIT:id>' ] ) <EOL> req . get_response ( self . api ) <EOL> req = self . new_update_request ( '<STR_LIT>' , data , port2 [ '<STR_LIT:port>' ] [ '<STR_LIT:id>' ] ) <EOL> ctx = context . get_admin_context ( ) <EOL> req . get_response ( self . api ) <EOL> ports = self . _list ( '<STR_LIT>' , neutron_context = ctx ) [ '<STR_LIT>' ] <EOL> self . assertEqual ( <NUM_LIT:2> , len ( ports ) ) <EOL> for port in ports : <EOL> self . assertEqual ( '<STR_LIT>' , port [ portbindings . HOST_ID ] ) <EOL> def test_ports_vif_non_host_update ( self ) : <EOL> host_arg = { portbindings . HOST_ID : self . hostname } <EOL> with self . port ( name = '<STR_LIT:name>' , arg_list = ( portbindings . HOST_ID , ) , <EOL> ** host_arg ) as port : <EOL> data = { '<STR_LIT:port>' : { '<STR_LIT>' : False } } <EOL> req = self . new_update_request ( '<STR_LIT>' , data , port [ '<STR_LIT:port>' ] [ '<STR_LIT:id>' ] ) <EOL> res = self . deserialize ( self . fmt , req . get_response ( self . api ) ) <EOL> self . assertEqual ( port [ '<STR_LIT:port>' ] [ portbindings . HOST_ID ] , <EOL> res [ '<STR_LIT:port>' ] [ portbindings . HOST_ID ] ) <EOL> def test_ports_vif_non_host_update_when_host_null ( self ) : <EOL> with self . port ( ) as port : <EOL> data = { '<STR_LIT:port>' : { '<STR_LIT>' : False } } <EOL> req = self . new_update_request ( '<STR_LIT>' , data , port [ '<STR_LIT:port>' ] [ '<STR_LIT:id>' ] ) <EOL> res = self . deserialize ( self . fmt , req . get_response ( self . api ) ) <EOL> self . assertEqual ( port [ '<STR_LIT:port>' ] [ portbindings . HOST_ID ] , <EOL> res [ '<STR_LIT:port>' ] [ portbindings . HOST_ID ] ) <EOL> def test_ports_vif_host_list ( self ) : <EOL> cfg . CONF . set_default ( '<STR_LIT>' , True ) <EOL> host_arg = { portbindings . HOST_ID : self . hostname } <EOL> with self . port ( name = '<STR_LIT>' , <EOL> arg_list = ( portbindings . HOST_ID , ) , <EOL> ** host_arg ) as port1 , self . port ( name = '<STR_LIT>' ) , self . port ( name = '<STR_LIT>' , <EOL> arg_list = ( portbindings . HOST_ID , ) , <EOL> ** host_arg ) as port3 : <EOL> self . _test_list_resources ( <EOL> '<STR_LIT:port>' , ( port1 , port3 ) , <EOL> query_params = '<STR_LIT>' % ( portbindings . HOST_ID , self . hostname ) ) <EOL> class PortBindingsVnicTestCaseMixin ( object ) : <EOL> fmt = '<STR_LIT>' <EOL> vnic_type = portbindings . VNIC_NORMAL <EOL> def _check_response_portbindings_vnic_type ( self , port ) : <EOL> self . assertIn ( '<STR_LIT:status>' , port ) <EOL> self . assertEqual ( port [ portbindings . VNIC_TYPE ] , self . vnic_type ) <EOL> def test_port_vnic_type_non_admin ( self ) : <EOL> with self . network ( set_context = True , <EOL> tenant_id = '<STR_LIT:test>' ) as net1 : <EOL> with self . subnet ( network = net1 ) as subnet1 : <EOL> vnic_arg = { portbindings . VNIC_TYPE : self . vnic_type } <EOL> with self . port ( subnet = subnet1 , <EOL> expected_res_status = httplib . CREATED , <EOL> arg_list = ( portbindings . VNIC_TYPE , ) , <EOL> set_context = True , <EOL> tenant_id = '<STR_LIT:test>' , <EOL> ** vnic_arg ) as port : <EOL> self . _check_response_portbindings_vnic_type ( port [ '<STR_LIT:port>' ] ) <EOL> def test_port_vnic_type ( self ) : <EOL> vnic_arg = { portbindings . VNIC_TYPE : self . vnic_type } <EOL> with self . port ( name = '<STR_LIT:name>' , arg_list = ( portbindings . VNIC_TYPE , ) , <EOL> ** vnic_arg ) as port : <EOL> port_id = port [ '<STR_LIT:port>' ] [ '<STR_LIT:id>' ] <EOL> self . _check_response_portbindings_vnic_type ( port [ '<STR_LIT:port>' ] ) <EOL> ctx = context . get_admin_context ( ) <EOL> port = self . _show ( '<STR_LIT>' , port_id , neutron_context = ctx ) [ '<STR_LIT:port>' ] <EOL> self . _check_response_portbindings_vnic_type ( port ) <EOL> ctx = context . Context ( user_id = None , <EOL> tenant_id = self . _tenant_id , <EOL> is_admin = False ) <EOL> non_admin_port = self . _show ( <EOL>", "answer": "'<STR_LIT>' , port_id , neutron_context = ctx ) [ '<STR_LIT:port>' ]"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from ndscheduler import job <EOL> class AwesomeJob ( job . JobBase ) : <EOL> @ classmethod <EOL> def meta_info ( cls ) : <EOL> return { <EOL> '<STR_LIT>' : '<STR_LIT>' % ( cls . __module__ , cls . __name__ ) , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <EOL> { '<STR_LIT:type>' : '<STR_LIT:string>' , '<STR_LIT:description>' : '<STR_LIT>' } , <EOL> { '<STR_LIT:type>' : '<STR_LIT:string>' , '<STR_LIT:description>' : '<STR_LIT>' } <EOL> ] , <EOL>", "answer": "'<STR_LIT>' : '<STR_LIT>'"}, {"prompt": "<s> __description__ = \"<STR_LIT>\" <EOL> __config__ = { <EOL>", "answer": "\"<STR_LIT>\" : dict ("}, {"prompt": "<s> from troposphere import Base64 , Join <EOL> from troposphere import Parameter , Ref , Template <EOL> from troposphere import cloudformation , autoscaling <EOL> from troposphere . autoscaling import AutoScalingGroup , Tag <EOL> from troposphere . autoscaling import LaunchConfiguration <EOL> from troposphere . elasticloadbalancing import LoadBalancer <EOL> from troposphere . policies import UpdatePolicy , AutoScalingRollingUpdate <EOL> import troposphere . ec2 as ec2 <EOL> import troposphere . elasticloadbalancing as elb <EOL> t = Template ( ) <EOL> t . add_description ( \"\"\"<STR_LIT>\"\"\" ) <EOL> SecurityGroup = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> ) ) <EOL> DeployBucket = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> ) ) <EOL> SSLCertificateId = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> ) ) <EOL> DeployUserAccessKey = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> ) ) <EOL> KeyName = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> MinLength = \"<STR_LIT:1>\" , <EOL> AllowedPattern = \"<STR_LIT>\" , <EOL> MaxLength = \"<STR_LIT>\" , <EOL> ConstraintDescription = \"<STR_LIT>\" , <EOL> ) ) <EOL> DeployUserSecretKey = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> ) ) <EOL> LoadBalancerSecurityGroup = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> ) ) <EOL> ScaleCapacity = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Default = \"<STR_LIT:1>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> ) ) <EOL> AmiId = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> ) ) <EOL> EnvType = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> ) ) <EOL> PublicSubnet1 = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> ) ) <EOL> PublicSubnet2 = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> ) ) <EOL> VPCAvailabilityZone2 = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> MinLength = \"<STR_LIT:1>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> MaxLength = \"<STR_LIT>\" , <EOL> ) ) <EOL> VPCAvailabilityZone1 = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> MinLength = \"<STR_LIT:1>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> MaxLength = \"<STR_LIT>\" , <EOL> ) ) <EOL> RootStackName = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> ) ) <EOL> ApiSubnet2 = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> ) ) <EOL> ApiSubnet1 = t . add_parameter ( Parameter ( <EOL> \"<STR_LIT>\" , <EOL> Type = \"<STR_LIT>\" , <EOL> Description = \"<STR_LIT>\" , <EOL> ) ) <EOL> LaunchConfiguration = t . add_resource ( LaunchConfiguration ( <EOL> \"<STR_LIT>\" , <EOL> Metadata = autoscaling . Metadata ( <EOL> cloudformation . Init ( { <EOL> \"<STR_LIT>\" : cloudformation . InitConfig ( <EOL> files = cloudformation . InitFiles ( { <EOL> \"<STR_LIT>\" : cloudformation . InitFile ( <EOL> source = Join ( '<STR_LIT>' , [ <EOL> \"<STR_LIT>\" , <EOL> Ref ( DeployBucket ) , <EOL> \"<STR_LIT>\" , <EOL> Ref ( RootStackName ) , <EOL> \"<STR_LIT>\" <EOL> ] ) , <EOL> mode = \"<STR_LIT>\" , <EOL> owner = \"<STR_LIT:root>\" , <EOL> group = \"<STR_LIT:root>\" , <EOL> authentication = \"<STR_LIT>\" <EOL> ) <EOL> } ) , <EOL> services = { <EOL> \"<STR_LIT>\" : cloudformation . InitServices ( { <EOL> \"<STR_LIT>\" : cloudformation . InitService ( <EOL> enabled = True , <EOL> ensureRunning = True , <EOL> files = [ '<STR_LIT>' ] <EOL> ) <EOL> } ) <EOL> } <EOL> ) <EOL> } ) , <EOL> cloudformation . Authentication ( { <EOL> \"<STR_LIT>\" : cloudformation . AuthenticationBlock ( <EOL> type = \"<STR_LIT>\" , <EOL> accessKeyId = Ref ( DeployUserAccessKey ) , <EOL> secretKey = Ref ( DeployUserSecretKey ) <EOL> ) <EOL> } ) <EOL> ) , <EOL> UserData = Base64 ( Join ( '<STR_LIT>' , [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , Ref ( \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" , Ref ( \"<STR_LIT>\" ) , \"<STR_LIT:\\n>\" <EOL> ] ) ) , <EOL> ImageId = Ref ( AmiId ) , <EOL> KeyName = Ref ( KeyName ) , <EOL> BlockDeviceMappings = [ <EOL> ec2 . BlockDeviceMapping ( <EOL> DeviceName = \"<STR_LIT>\" , <EOL> Ebs = ec2 . EBSBlockDevice ( <EOL> VolumeSize = \"<STR_LIT>\" <EOL> ) <EOL> ) , <EOL> ] , <EOL> SecurityGroups = [ Ref ( SecurityGroup ) ] , <EOL> InstanceType = \"<STR_LIT>\" , <EOL> ) ) <EOL> LoadBalancer = t . add_resource ( LoadBalancer ( <EOL> \"<STR_LIT>\" , <EOL> ConnectionDrainingPolicy = elb . ConnectionDrainingPolicy ( <EOL> Enabled = True , <EOL> Timeout = <NUM_LIT> , <EOL> ) , <EOL> Subnets = [ Ref ( PublicSubnet1 ) , Ref ( PublicSubnet2 ) ] , <EOL> HealthCheck = elb . HealthCheck ( <EOL> Target = \"<STR_LIT>\" , <EOL> HealthyThreshold = \"<STR_LIT:5>\" , <EOL> UnhealthyThreshold = \"<STR_LIT:2>\" , <EOL> Interval = \"<STR_LIT>\" , <EOL> Timeout = \"<STR_LIT>\" , <EOL> ) , <EOL> Listeners = [ <EOL> elb . Listener ( <EOL> LoadBalancerPort = \"<STR_LIT>\" , <EOL> InstancePort = \"<STR_LIT>\" , <EOL> Protocol = \"<STR_LIT>\" , <EOL> InstanceProtocol = \"<STR_LIT>\" , <EOL> SSLCertificateId = Ref ( SSLCertificateId ) <EOL>", "answer": ") ,"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from threading import local <EOL> from django . utils . module_loading import import_string <EOL>", "answer": "class HandlerProxy ( object ) :"}, {"prompt": "<s> __revision__ = \"<STR_LIT>\" <EOL> __doc__ = \"\"\"<STR_LIT>\"\"\" <EOL> import SCons . compat <EOL> import os <EOL> import platform <EOL> from string import digits as string_digits <EOL> import SCons . Warnings <EOL> import common <EOL> debug = common . debug <EOL> import sdk <EOL> get_installed_sdks = sdk . get_installed_sdks <EOL> class VisualCException ( Exception ) : <EOL> pass <EOL> class UnsupportedVersion ( VisualCException ) : <EOL> pass <EOL> class UnsupportedArch ( VisualCException ) : <EOL> pass <EOL> class MissingConfiguration ( VisualCException ) : <EOL> pass <EOL> class NoVersionFound ( VisualCException ) : <EOL> pass <EOL> class BatchFileExecutionError ( VisualCException ) : <EOL> pass <EOL> _ARCH_TO_CANONICAL = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> _HOST_TARGET_ARCH_TO_BAT_ARCH = { <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : \"<STR_LIT>\" , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : \"<STR_LIT>\" , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : \"<STR_LIT>\" , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : \"<STR_LIT>\" , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : \"<STR_LIT>\" , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : \"<STR_LIT>\" , <EOL> ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : \"<STR_LIT>\" <EOL> } <EOL> def get_host_target ( env ) : <EOL> debug ( '<STR_LIT>' ) <EOL> host_platform = env . get ( '<STR_LIT>' ) <EOL> if not host_platform : <EOL> host_platform = platform . machine ( ) <EOL> if not host_platform : <EOL> host_platform = os . environ . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> req_target_platform = env . get ( '<STR_LIT>' ) <EOL> debug ( '<STR_LIT>' % req_target_platform ) <EOL> if req_target_platform : <EOL> target_platform = req_target_platform <EOL> else : <EOL> target_platform = host_platform <EOL> try : <EOL> host = _ARCH_TO_CANONICAL [ host_platform . lower ( ) ] <EOL> except KeyError , e : <EOL> msg = \"<STR_LIT>\" <EOL> raise ValueError ( msg % repr ( host_platform ) ) <EOL> try : <EOL> target = _ARCH_TO_CANONICAL [ target_platform . lower ( ) ] <EOL> except KeyError , e : <EOL> all_archs = str ( _ARCH_TO_CANONICAL . keys ( ) ) <EOL> raise ValueError ( \"<STR_LIT>\" % ( target_platform , all_archs ) ) <EOL> return ( host , target , req_target_platform ) <EOL> _VCVER = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> _VCVER_TO_PRODUCT_DIR = { <EOL> '<STR_LIT>' : [ <EOL> r'<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ <EOL> r'<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ <EOL> r'<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ <EOL> r'<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ <EOL> r'<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ <EOL> r'<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ <EOL> r'<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ <EOL> r'<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ <EOL> r'<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ <EOL> r'<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ <EOL> r'<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ <EOL> r'<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ <EOL> r'<STR_LIT>' ] , <EOL> '<STR_LIT>' : [ <EOL> r'<STR_LIT>' ] <EOL> } <EOL> def msvc_version_to_maj_min ( msvc_version ) : <EOL> msvc_version_numeric = '<STR_LIT>' . join ( [ x for x in msvc_version if x in string_digits + '<STR_LIT:.>' ] ) <EOL> t = msvc_version_numeric . split ( \"<STR_LIT:.>\" ) <EOL> if not len ( t ) == <NUM_LIT:2> : <EOL> raise ValueError ( \"<STR_LIT>\" % ( msvc_version , msvc_version_numeric ) ) <EOL> try : <EOL> maj = int ( t [ <NUM_LIT:0> ] ) <EOL> min = int ( t [ <NUM_LIT:1> ] ) <EOL> return maj , min <EOL> except ValueError , e : <EOL> raise ValueError ( \"<STR_LIT>\" % ( msvc_version , msvc_version_numeric ) ) <EOL> def is_host_target_supported ( host_target , msvc_version ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if host_target [ <NUM_LIT:1> ] != \"<STR_LIT>\" : <EOL> maj , min = msvc_version_to_maj_min ( msvc_version ) <EOL> if maj < <NUM_LIT:8> : <EOL> return False <EOL> return True <EOL> def find_vc_pdir ( msvc_version ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> root = '<STR_LIT>' <EOL> if common . is_win64 ( ) : <EOL> root = root + '<STR_LIT>' <EOL> try : <EOL> hkeys = _VCVER_TO_PRODUCT_DIR [ msvc_version ] <EOL> except KeyError : <EOL> debug ( \"<STR_LIT>\" % msvc_version ) <EOL> raise UnsupportedVersion ( \"<STR_LIT>\" % msvc_version ) <EOL> for key in hkeys : <EOL> key = root + key <EOL> try : <EOL> comps = common . read_reg ( key ) <EOL> except WindowsError , e : <EOL> debug ( '<STR_LIT>' % repr ( key ) ) <EOL> else : <EOL> debug ( '<STR_LIT>' % comps ) <EOL> if os . path . exists ( comps ) : <EOL> return comps <EOL> else : <EOL> debug ( '<STR_LIT>' % comps ) <EOL> raise MissingConfiguration ( \"<STR_LIT>\" % comps ) <EOL> return None <EOL> def find_batch_file ( env , msvc_version , host_arch , target_arch ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pdir = find_vc_pdir ( msvc_version ) <EOL> if pdir is None : <EOL> raise NoVersionFound ( \"<STR_LIT>\" ) <EOL> debug ( '<STR_LIT>' % pdir ) <EOL> msvc_ver_numeric = '<STR_LIT>' . join ( [ x for x in msvc_version if x in string_digits + \"<STR_LIT:.>\" ] ) <EOL> vernum = float ( msvc_ver_numeric ) <EOL> if <NUM_LIT:7> <= vernum < <NUM_LIT:8> : <EOL> pdir = os . path . join ( pdir , os . pardir , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> batfilename = os . path . join ( pdir , \"<STR_LIT>\" ) <EOL> elif vernum < <NUM_LIT:7> : <EOL> pdir = os . path . join ( pdir , \"<STR_LIT>\" ) <EOL> batfilename = os . path . join ( pdir , \"<STR_LIT>\" ) <EOL> else : <EOL> batfilename = os . path . join ( pdir , \"<STR_LIT>\" ) <EOL> if not os . path . exists ( batfilename ) : <EOL> debug ( \"<STR_LIT>\" % batfilename ) <EOL> batfilename = None <EOL> installed_sdks = get_installed_sdks ( ) <EOL> for _sdk in installed_sdks : <EOL> sdk_bat_file = _sdk . get_sdk_vc_script ( host_arch , target_arch ) <EOL> if not sdk_bat_file : <EOL> debug ( \"<STR_LIT>\" % _sdk ) <EOL> else : <EOL> sdk_bat_file_path = os . path . join ( pdir , sdk_bat_file ) <EOL> if os . path . exists ( sdk_bat_file_path ) : <EOL> debug ( '<STR_LIT>' % sdk_bat_file_path ) <EOL> return ( batfilename , sdk_bat_file_path ) <EOL> return ( batfilename , None ) <EOL> __INSTALLED_VCS_RUN = None <EOL> def cached_get_installed_vcs ( ) : <EOL> global __INSTALLED_VCS_RUN <EOL> if __INSTALLED_VCS_RUN is None : <EOL> ret = get_installed_vcs ( ) <EOL> __INSTALLED_VCS_RUN = ret <EOL> return __INSTALLED_VCS_RUN <EOL> def get_installed_vcs ( ) : <EOL> installed_versions = [ ] <EOL> for ver in _VCVER : <EOL> debug ( '<STR_LIT>' % ver ) <EOL> try : <EOL> if find_vc_pdir ( ver ) : <EOL> debug ( '<STR_LIT>' % ver ) <EOL> installed_versions . append ( ver ) <EOL> else : <EOL> debug ( '<STR_LIT>' % ver ) <EOL> except VisualCException , e : <EOL> debug ( '<STR_LIT>' % ( ver , str ( e ) ) ) <EOL> return installed_versions <EOL> def reset_installed_vcs ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __INSTALLED_VCS_RUN = None <EOL> script_env_stdout_cache = { } <EOL> def script_env ( script , args = None ) : <EOL> cache_key = ( script , args ) <EOL> stdout = script_env_stdout_cache . get ( cache_key , None ) <EOL> if stdout is None : <EOL> stdout = common . get_output ( script , args ) <EOL> script_env_stdout_cache [ cache_key ] = stdout <EOL> olines = stdout . splitlines ( ) <EOL> if olines [ <NUM_LIT:0> ] . startswith ( \"<STR_LIT>\" ) : <EOL> raise BatchFileExecutionError ( \"<STR_LIT:\\n>\" . join ( olines [ : <NUM_LIT:2> ] ) ) <EOL> return common . parse_output ( stdout ) <EOL> def get_default_version ( env ) : <EOL> debug ( '<STR_LIT>' ) <EOL> msvc_version = env . get ( '<STR_LIT>' ) <EOL> msvs_version = env . get ( '<STR_LIT>' ) <EOL> debug ( '<STR_LIT>' % ( msvc_version , msvs_version ) ) <EOL> if msvs_version and not msvc_version : <EOL> SCons . Warnings . warn ( <EOL> SCons . Warnings . DeprecatedWarning , <EOL> \"<STR_LIT>\" ) <EOL> return msvs_version <EOL> elif msvc_version and msvs_version : <EOL> if not msvc_version == msvs_version : <EOL> SCons . Warnings . warn ( <EOL> SCons . Warnings . VisualVersionMismatch , <EOL> \"<STR_LIT>\" \"<STR_LIT>\" \"<STR_LIT>\" % ( msvc_version , msvs_version ) ) <EOL> return msvs_version <EOL> if not msvc_version : <EOL> installed_vcs = cached_get_installed_vcs ( ) <EOL> debug ( '<STR_LIT>' % installed_vcs ) <EOL> if not installed_vcs : <EOL> debug ( '<STR_LIT>' ) <EOL> return None <EOL> msvc_version = installed_vcs [ <NUM_LIT:0> ] <EOL> debug ( '<STR_LIT>' % repr ( msvc_version ) ) <EOL> return msvc_version <EOL> def msvc_setup_env_once ( env ) : <EOL> try : <EOL> has_run = env [ \"<STR_LIT>\" ] <EOL> except KeyError : <EOL> has_run = False <EOL> if not has_run : <EOL> msvc_setup_env ( env ) <EOL> env [ \"<STR_LIT>\" ] = True <EOL> def msvc_find_valid_batch_script ( env , version ) : <EOL> debug ( '<STR_LIT>' ) <EOL> ( host_platform , target_platform , req_target_platform ) = get_host_target ( env ) <EOL> try_target_archs = [ target_platform ] <EOL> debug ( \"<STR_LIT>\" % ( req_target_platform , target_platform ) ) <EOL> if req_target_platform in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> try_target_archs . append ( '<STR_LIT>' ) <EOL> elif not req_target_platform and target_platform in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> try_target_archs . append ( '<STR_LIT>' ) <EOL> try_target_archs . append ( '<STR_LIT>' ) <EOL> debug ( \"<STR_LIT>\" % ( host_platform , try_target_archs ) ) <EOL> d = None <EOL> for tp in try_target_archs : <EOL> env [ '<STR_LIT>' ] = tp <EOL> debug ( \"<STR_LIT>\" % tp ) <EOL> host_target = ( host_platform , tp ) <EOL> if not is_host_target_supported ( host_target , version ) : <EOL> warn_msg = \"<STR_LIT>\" % ( host_target , version ) <EOL> SCons . Warnings . warn ( SCons . Warnings . VisualCMissingWarning , warn_msg ) <EOL> arg = _HOST_TARGET_ARCH_TO_BAT_ARCH [ host_target ] <EOL> try : <EOL> ( vc_script , sdk_script ) = find_batch_file ( env , version , host_platform , tp ) <EOL> debug ( '<STR_LIT>' % ( vc_script , sdk_script ) ) <EOL> except VisualCException , e : <EOL> msg = str ( e ) <EOL> debug ( '<STR_LIT>' % msg ) <EOL> warn_msg = \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" <EOL> warn_msg = warn_msg % ( version , cached_get_installed_vcs ( ) ) <EOL> SCons . Warnings . warn ( SCons . Warnings . VisualCMissingWarning , warn_msg ) <EOL> continue <EOL> debug ( '<STR_LIT>' % ( repr ( vc_script ) , arg ) ) <EOL> if vc_script : <EOL> try : <EOL> d = script_env ( vc_script , args = arg ) <EOL> except BatchFileExecutionError , e : <EOL> debug ( '<STR_LIT>' % ( repr ( vc_script ) , arg , e ) ) <EOL> vc_script = None <EOL> continue <EOL> if not vc_script and sdk_script : <EOL> debug ( '<STR_LIT>' % ( sdk_script ) ) <EOL> try : <EOL> d = script_env ( sdk_script ) <EOL> except BatchFileExecutionError , e : <EOL> debug ( '<STR_LIT>' % ( repr ( sdk_script ) , e ) ) <EOL> continue <EOL> elif not vc_script and not sdk_script : <EOL> debug ( '<STR_LIT>' ) <EOL> continue <EOL> debug ( \"<STR_LIT>\" % ( repr ( sdk_script ) , arg ) ) <EOL> break <EOL> if not d : <EOL> env [ '<STR_LIT>' ] = req_target_platform <EOL> return d <EOL> def msvc_setup_env ( env ) : <EOL> debug ( '<STR_LIT>' ) <EOL> version = get_default_version ( env ) <EOL> if version is None : <EOL> warn_msg = \"<STR_LIT>\" \"<STR_LIT>\" <EOL>", "answer": "SCons . Warnings . warn ( SCons . Warnings . VisualCMissingWarning , warn_msg )"}, {"prompt": "<s> from setuptools import setup <EOL> import hgvers <EOL> setup ( <EOL> name = \"<STR_LIT>\" , <EOL> version = hgvers . version , <EOL> py_modules = [ '<STR_LIT>' ] , <EOL> author = \"<STR_LIT>\" , <EOL> author_email = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> license = \"<STR_LIT>\" , <EOL> url = \"<STR_LIT>\" , <EOL> keywords = \"<STR_LIT>\" , <EOL> classifiers = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> from django . conf . urls . defaults import * <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL>", "answer": ") "}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = <NUM_LIT:11>"}, {"prompt": "<s> from datetime import datetime , timedelta <EOL> from django . contrib . auth . decorators import user_passes_test <EOL> from django . core . urlresolvers import reverse <EOL> from django . db . models import Count <EOL> from django . http import HttpResponse <EOL> from django . views . generic . simple import direct_to_template <EOL> from app . decorators import arecibo_login_required <EOL> from app . utils import render_plain , safe_int <EOL> from app . paginator import Paginator , get_page <EOL> from error . models import Error <EOL> stats = { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT:title>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:count>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : ( Error . objects . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> . order_by ( '<STR_LIT>' ) <EOL> . annotate ( Count ( '<STR_LIT>' ) ) ) , <EOL> } , <EOL> \"<STR_LIT:type>\" : { <EOL> \"<STR_LIT:title>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT:type>\" , <EOL> \"<STR_LIT:count>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : ( Error . objects . values ( '<STR_LIT:type>' , '<STR_LIT>' ) <EOL> . order_by ( '<STR_LIT>' ) <EOL> . annotate ( Count ( '<STR_LIT:type>' ) ) ) , <EOL> } , <EOL> } <EOL> def format_results ( stat , query ) : <EOL> data = { \"<STR_LIT>\" : [ ] , \"<STR_LIT>\" : { } } <EOL> for line in query : <EOL> column = line [ stat [ '<STR_LIT>' ] ] <EOL> if column == '<STR_LIT>' : <EOL> column = '<STR_LIT>' <EOL> if column not in data [ '<STR_LIT>' ] : <EOL> data [ '<STR_LIT>' ] . append ( column ) <EOL> data [ '<STR_LIT>' ] . setdefault ( line [ '<STR_LIT>' ] , [ ] ) <EOL> data [ '<STR_LIT>' ] [ line [ '<STR_LIT>' ] ] . append ( { <EOL> '<STR_LIT>' : data [ '<STR_LIT>' ] . index ( column ) + <NUM_LIT:1> , <EOL> '<STR_LIT:count>' : line [ stat [ '<STR_LIT:count>' ] ] , <EOL> } ) <EOL> data [ '<STR_LIT>' ] = [ ( k , data [ '<STR_LIT>' ] [ k ] ) for k in sorted ( data [ '<STR_LIT>' ] . iterkeys ( ) ) ] <EOL>", "answer": "return data"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import ( absolute_import , division , print_function , <EOL> unicode_literals ) <EOL> __all__ = [ \"<STR_LIT>\" ] <EOL>", "answer": "from . least_squares import LeastSquaresFilter "}, {"prompt": "<s> import unittest <EOL> from mixbox . vendor . six import u <EOL> from cybox . core import Frequency <EOL> from cybox . test import EntityTestCase <EOL> class TestFrequency ( EntityTestCase , unittest . TestCase ) : <EOL> klass = Frequency <EOL> _full_dict = { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : u ( \"<STR_LIT>\" ) , <EOL> '<STR_LIT>' : \"<STR_LIT>\" , <EOL>", "answer": "'<STR_LIT>' : \"<STR_LIT>\" ,"}, {"prompt": "<s> import os <EOL> import logging <EOL> import tempfile <EOL> from boto3 . session import Session <EOL> import botocore <EOL> from aleph . archive . archive import Archive <EOL> log = logging . getLogger ( __name__ ) <EOL> class S3Archive ( Archive ) : <EOL> def __init__ ( self , config ) : <EOL> self . local_base = tempfile . gettempdir ( ) <EOL> self . key_id = config . get ( '<STR_LIT>' ) <EOL> self . secret = config . get ( '<STR_LIT>' ) <EOL> self . region = config . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . bucket_name = config . get ( '<STR_LIT>' ) <EOL> self . session = Session ( aws_access_key_id = self . key_id , <EOL> aws_secret_access_key = self . secret , <EOL> region_name = self . region ) <EOL> self . s3 = self . session . resource ( '<STR_LIT>' ) <EOL> self . client = self . session . client ( '<STR_LIT>' ) <EOL> log . info ( \"<STR_LIT>\" , self . bucket_name ) <EOL> self . bucket = self . s3 . Bucket ( self . bucket_name ) <EOL> try : <EOL> self . bucket . load ( ) <EOL> except botocore . exceptions . ClientError as e : <EOL> error_code = int ( e . response [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> if error_code == <NUM_LIT> : <EOL> self . bucket . create ( CreateBucketConfiguration = { <EOL> '<STR_LIT>' : self . region <EOL> } ) <EOL> else : <EOL> raise <EOL> self . cors_configured = False <EOL> def archive_file ( self , filename , meta , move = False ) : <EOL> meta = self . _update_metadata ( filename , meta ) <EOL> path = self . _get_file_path ( meta ) <EOL> key = self . bucket . Object ( path ) <EOL> try : <EOL> key . e_tag <EOL> except botocore . exceptions . ClientError as e : <EOL> error_code = int ( e . response [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> if error_code == <NUM_LIT> : <EOL> self . bucket . upload_file ( filename , path ) <EOL> if move : <EOL> os . unlink ( filename ) <EOL> return meta <EOL> def _get_local_mirror ( self , meta ) : <EOL> base = self . _get_file_path ( meta ) . split ( os . path . sep ) <EOL> file_name = '<STR_LIT>' % ( base [ - <NUM_LIT:2> ] , base [ - <NUM_LIT:1> ] ) <EOL> return os . path . join ( self . local_base , file_name ) <EOL> def load_file ( self , meta ) : <EOL> path = self . _get_local_mirror ( meta ) <EOL> key = self . _get_file_path ( meta ) <EOL> self . bucket . download_file ( key , path ) <EOL> return path <EOL> def cleanup_file ( self , meta ) : <EOL> path = self . _get_local_mirror ( meta ) <EOL> if os . path . isfile ( path ) : <EOL> os . unlink ( path ) <EOL> def generate_url ( self , meta ) : <EOL> if not self . cors_configured : <EOL> self . cors_configured = True <EOL> cors = self . bucket . Cors ( ) <EOL> config = { <EOL> '<STR_LIT>' : [ <EOL> { <EOL> '<STR_LIT>' : [ '<STR_LIT:GET>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT:*>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT:*>' ] , <EOL> '<STR_LIT>' : <NUM_LIT> * <NUM_LIT> <EOL> } <EOL> ] <EOL> } <EOL> cors . put ( CORSConfiguration = config ) <EOL> params = { <EOL> '<STR_LIT>' : self . bucket_name , <EOL> '<STR_LIT>' : self . _get_file_path ( meta ) <EOL> } <EOL>", "answer": "return self . client . generate_presigned_url ( '<STR_LIT>' ,"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = <NUM_LIT:0> <EOL>", "answer": "result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "<s> import argparse <EOL> import sys <EOL> from string import hexdigits <EOL> from string import whitespace <EOL> import pwnlib . log <EOL> from pwnlib import asm <EOL> from pwnlib . context import context <EOL> pwnlib . log . install_default_handler ( ) <EOL> parser = argparse . ArgumentParser ( <EOL> description = '<STR_LIT>' <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> metavar = '<STR_LIT>' , <EOL> nargs = '<STR_LIT:*>' , <EOL> help = '<STR_LIT>' <EOL> ) <EOL> parser . add_argument ( <EOL> '<STR_LIT:-c>' , '<STR_LIT>' , <EOL> metavar = '<STR_LIT>' , <EOL> choices = context . architectures , <EOL> default = '<STR_LIT>' , <EOL> help = '<STR_LIT>' % '<STR_LIT:U+002CU+0020>' . join ( context . architectures ) <EOL> ) <EOL> def main ( ) : <EOL> args = parser . parse_args ( ) <EOL> if len ( args . hex ) > <NUM_LIT:0> : <EOL>", "answer": "dat = '<STR_LIT>' . join ( args . hex )"}, {"prompt": "<s> from __future__ import division <EOL> import binascii <EOL> import base64 <EOL> from . six import int2byte , b , PY3 , integer_types , text_type <EOL> class UnexpectedDER ( Exception ) : <EOL> pass <EOL> def encode_constructed ( tag , value ) : <EOL> return int2byte ( <NUM_LIT> + tag ) + encode_length ( len ( value ) ) + value <EOL> def encode_integer ( r ) : <EOL> assert r >= <NUM_LIT:0> <EOL> h = ( \"<STR_LIT>\" % r ) . encode ( ) <EOL> if len ( h ) % <NUM_LIT:2> : <EOL> h = b ( \"<STR_LIT:0>\" ) + h <EOL> s = binascii . unhexlify ( h ) <EOL> num = s [ <NUM_LIT:0> ] if isinstance ( s [ <NUM_LIT:0> ] , integer_types ) else ord ( s [ <NUM_LIT:0> ] ) <EOL> if num <= <NUM_LIT> : <EOL> return b ( \"<STR_LIT>\" ) + int2byte ( len ( s ) ) + s <EOL> else : <EOL> return b ( \"<STR_LIT>\" ) + int2byte ( len ( s ) + <NUM_LIT:1> ) + b ( \"<STR_LIT:\\x00>\" ) + s <EOL> def encode_bitstring ( s ) : <EOL> return b ( \"<STR_LIT>\" ) + encode_length ( len ( s ) ) + s <EOL> def encode_octet_string ( s ) : <EOL> return b ( \"<STR_LIT>\" ) + encode_length ( len ( s ) ) + s <EOL> def encode_oid ( first , second , * pieces ) : <EOL> assert first <= <NUM_LIT:2> <EOL> assert second <= <NUM_LIT> <EOL> encoded_pieces = [ int2byte ( <NUM_LIT> * first + second ) ] + [ encode_number ( p ) <EOL> for p in pieces ] <EOL> body = b ( '<STR_LIT>' ) . join ( encoded_pieces ) <EOL> return b ( '<STR_LIT>' ) + encode_length ( len ( body ) ) + body <EOL> def encode_sequence ( * encoded_pieces ) : <EOL> total_len = sum ( [ len ( p ) for p in encoded_pieces ] ) <EOL> return b ( '<STR_LIT>' ) + encode_length ( total_len ) + b ( '<STR_LIT>' ) . join ( encoded_pieces ) <EOL> def encode_number ( n ) : <EOL> b128_digits = [ ] <EOL> while n : <EOL> b128_digits . insert ( <NUM_LIT:0> , ( n & <NUM_LIT> ) | <NUM_LIT> ) <EOL> n = n >> <NUM_LIT:7> <EOL> if not b128_digits : <EOL> b128_digits . append ( <NUM_LIT:0> ) <EOL> b128_digits [ - <NUM_LIT:1> ] &= <NUM_LIT> <EOL> return b ( '<STR_LIT>' ) . join ( [ int2byte ( d ) for d in b128_digits ] ) <EOL> def remove_constructed ( string ) : <EOL> s0 = string [ <NUM_LIT:0> ] if isinstance ( string [ <NUM_LIT:0> ] , integer_types ) else ord ( string [ <NUM_LIT:0> ] ) <EOL> if ( s0 & <NUM_LIT> ) != <NUM_LIT> : <EOL> raise UnexpectedDER ( \"<STR_LIT>\" <EOL> % s0 ) <EOL> tag = s0 & <NUM_LIT> <EOL> length , llen = read_length ( string [ <NUM_LIT:1> : ] ) <EOL> body = string [ <NUM_LIT:1> + llen : <NUM_LIT:1> + llen + length ] <EOL> rest = string [ <NUM_LIT:1> + llen + length : ] <EOL> return tag , body , rest <EOL> def remove_sequence ( string ) : <EOL> if not string . startswith ( b ( \"<STR_LIT>\" ) ) : <EOL> n = string [ <NUM_LIT:0> ] if isinstance ( string [ <NUM_LIT:0> ] , integer_types ) else ord ( string [ <NUM_LIT:0> ] ) <EOL> raise UnexpectedDER ( \"<STR_LIT>\" % n ) <EOL> length , lengthlength = read_length ( string [ <NUM_LIT:1> : ] ) <EOL> endseq = <NUM_LIT:1> + lengthlength + length <EOL> return string [ <NUM_LIT:1> + lengthlength : endseq ] , string [ endseq : ] <EOL> def remove_octet_string ( string ) : <EOL> if not string . startswith ( b ( \"<STR_LIT>\" ) ) : <EOL> n = string [ <NUM_LIT:0> ] if isinstance ( string [ <NUM_LIT:0> ] , integer_types ) else ord ( string [ <NUM_LIT:0> ] ) <EOL> raise UnexpectedDER ( \"<STR_LIT>\" % n ) <EOL> length , llen = read_length ( string [ <NUM_LIT:1> : ] ) <EOL> body = string [ <NUM_LIT:1> + llen : <NUM_LIT:1> + llen + length ] <EOL> rest = string [ <NUM_LIT:1> + llen + length : ] <EOL> return body , rest <EOL> def remove_object ( string ) : <EOL> if not string . startswith ( b ( \"<STR_LIT>\" ) ) : <EOL> n = string [ <NUM_LIT:0> ] if isinstance ( string [ <NUM_LIT:0> ] , integer_types ) else ord ( string [ <NUM_LIT:0> ] ) <EOL> raise UnexpectedDER ( \"<STR_LIT>\" % n ) <EOL> length , lengthlength = read_length ( string [ <NUM_LIT:1> : ] ) <EOL> body = string [ <NUM_LIT:1> + lengthlength : <NUM_LIT:1> + lengthlength + length ] <EOL> rest = string [ <NUM_LIT:1> + lengthlength + length : ] <EOL> numbers = [ ] <EOL> while body : <EOL> n , ll = read_number ( body ) <EOL> numbers . append ( n ) <EOL> body = body [ ll : ] <EOL> n0 = numbers . pop ( <NUM_LIT:0> ) <EOL> first = n0 // <NUM_LIT> <EOL> second = n0 - ( <NUM_LIT> * first ) <EOL> numbers . insert ( <NUM_LIT:0> , first ) <EOL> numbers . insert ( <NUM_LIT:1> , second ) <EOL> return tuple ( numbers ) , rest <EOL> def remove_integer ( string ) : <EOL> if not string . startswith ( b ( \"<STR_LIT>\" ) ) : <EOL> n = string [ <NUM_LIT:0> ] if isinstance ( string [ <NUM_LIT:0> ] , integer_types ) else ord ( string [ <NUM_LIT:0> ] ) <EOL> raise UnexpectedDER ( \"<STR_LIT>\" % n ) <EOL> length , llen = read_length ( string [ <NUM_LIT:1> : ] ) <EOL> numberbytes = string [ <NUM_LIT:1> + llen : <NUM_LIT:1> + llen + length ] <EOL> rest = string [ <NUM_LIT:1> + llen + length : ] <EOL> nbytes = numberbytes [ <NUM_LIT:0> ] if isinstance ( numberbytes [ <NUM_LIT:0> ] , integer_types ) else ord ( numberbytes [ <NUM_LIT:0> ] ) <EOL> assert nbytes < <NUM_LIT> <EOL> return int ( binascii . hexlify ( numberbytes ) , <NUM_LIT:16> ) , rest <EOL> def read_number ( string ) : <EOL> number = <NUM_LIT:0> <EOL> llen = <NUM_LIT:0> <EOL> while True : <EOL> if llen > len ( string ) : <EOL> raise UnexpectedDER ( \"<STR_LIT>\" ) <EOL> number = number << <NUM_LIT:7> <EOL> d = string [ llen ] if isinstance ( string [ llen ] , integer_types ) else ord ( string [ llen ] ) <EOL> number += ( d & <NUM_LIT> ) <EOL> llen += <NUM_LIT:1> <EOL> if not d & <NUM_LIT> : <EOL> break <EOL> return number , llen <EOL> def encode_length ( l ) : <EOL> assert l >= <NUM_LIT:0> <EOL> if l < <NUM_LIT> : <EOL> return int2byte ( l ) <EOL> s = ( \"<STR_LIT>\" % l ) . encode ( ) <EOL> if len ( s ) % <NUM_LIT:2> : <EOL> s = b ( \"<STR_LIT:0>\" ) + s <EOL> s = binascii . unhexlify ( s ) <EOL> llen = len ( s ) <EOL> return int2byte ( <NUM_LIT> | llen ) + s <EOL> def read_length ( string ) : <EOL> num = string [ <NUM_LIT:0> ] if isinstance ( string [ <NUM_LIT:0> ] , integer_types ) else ord ( string [ <NUM_LIT:0> ] ) <EOL> if not ( num & <NUM_LIT> ) : <EOL> return ( num & <NUM_LIT> ) , <NUM_LIT:1> <EOL> llen = num & <NUM_LIT> <EOL> if llen > len ( string ) - <NUM_LIT:1> : <EOL> raise UnexpectedDER ( \"<STR_LIT>\" ) <EOL> return int ( binascii . hexlify ( string [ <NUM_LIT:1> : <NUM_LIT:1> + llen ] ) , <NUM_LIT:16> ) , <NUM_LIT:1> + llen <EOL> def remove_bitstring ( string ) : <EOL> num = string [ <NUM_LIT:0> ] if isinstance ( string [ <NUM_LIT:0> ] , integer_types ) else ord ( string [ <NUM_LIT:0> ] ) <EOL> if not string . startswith ( b ( \"<STR_LIT>\" ) ) : <EOL> raise UnexpectedDER ( \"<STR_LIT>\" % num ) <EOL> length , llen = read_length ( string [ <NUM_LIT:1> : ] ) <EOL> body = string [ <NUM_LIT:1> + llen : <NUM_LIT:1> + llen + length ] <EOL> rest = string [ <NUM_LIT:1> + llen + length : ] <EOL> return body , rest <EOL> def unpem ( pem ) : <EOL> if isinstance ( pem , text_type ) : <EOL> pem = pem . encode ( ) <EOL> d = b ( \"<STR_LIT>\" ) . join ( [ l . strip ( ) for l in pem . split ( b ( \"<STR_LIT:\\n>\" ) ) <EOL> if l and not l . startswith ( b ( \"<STR_LIT>\" ) ) ] ) <EOL> return base64 . b64decode ( d ) <EOL> def topem ( der , name ) : <EOL> b64 = base64 . b64encode ( der ) <EOL> lines = [ ( \"<STR_LIT>\" % name ) . encode ( ) ] <EOL> lines . extend ( [ b64 [ start : start + <NUM_LIT:64> ] + b ( \"<STR_LIT:\\n>\" ) <EOL> for start in range ( <NUM_LIT:0> , len ( b64 ) , <NUM_LIT:64> ) ] ) <EOL>", "answer": "lines . append ( ( \"<STR_LIT>\" % name ) . encode ( ) )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from django . test import TestCase <EOL> from seed . landing . models import SEEDUser as User <EOL> from seed . models import Project , Compliance , BuildingSnapshot , CanonicalBuilding <EOL> from seed . utils . buildings import get_buildings_for_user_count <EOL> from seed . utils . organizations import create_organization <EOL>", "answer": "class ProjectTestCase ( TestCase ) :"}, {"prompt": "<s> from flask import Flask , url_for <EOL> from . view_classes import BasicView , IndexView <EOL> from nose . tools import * <EOL> app = Flask ( \"<STR_LIT>\" ) <EOL> BasicView . register ( app ) <EOL> IndexView . register ( app ) <EOL> client = app . test_client ( ) <EOL> def test_index ( ) : <EOL> resp = client . get ( \"<STR_LIT>\" ) <EOL> eq_ ( b\"<STR_LIT>\" , resp . data ) <EOL> def test_get ( ) : <EOL> resp = client . get ( \"<STR_LIT>\" ) <EOL> eq_ ( b\"<STR_LIT>\" , resp . data ) <EOL> def test_put ( ) : <EOL> resp = client . put ( \"<STR_LIT>\" ) <EOL> eq_ ( b\"<STR_LIT>\" , resp . data ) <EOL> def test_patch ( ) : <EOL> resp = client . patch ( \"<STR_LIT>\" ) <EOL> eq_ ( b\"<STR_LIT>\" , resp . data ) <EOL> def test_post ( ) : <EOL> resp = client . post ( \"<STR_LIT>\" ) <EOL> eq_ ( b\"<STR_LIT>\" , resp . data ) <EOL> def test_delete ( ) : <EOL> resp = client . delete ( \"<STR_LIT>\" ) <EOL> eq_ ( b\"<STR_LIT>\" , resp . data ) <EOL> def test_custom_method ( ) : <EOL> resp = client . get ( \"<STR_LIT>\" ) <EOL> eq_ ( b\"<STR_LIT>\" , resp . data ) <EOL> def test_custom_method_with_params ( ) : <EOL> resp = client . get ( \"<STR_LIT>\" ) <EOL> eq_ ( b\"<STR_LIT>\" , resp . data ) <EOL> def test_routed_method ( ) : <EOL> resp = client . get ( \"<STR_LIT>\" ) <EOL>", "answer": "eq_ ( b\"<STR_LIT>\" , resp . data )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , division , print_function , unicode_literals <EOL> import benchexec . util as util <EOL>", "answer": "import benchexec . tools . smtlib2"}, {"prompt": "<s> import sys <EOL> import os <EOL> sys . path . insert ( <NUM_LIT:0> , \"<STR_LIT>\" ) <EOL> import fp <EOL> import pytyrant <EOL> import solr <EOL> import datetime <EOL> import csv <EOL> SLAVE_NAME = \"<STR_LIT>\" <EOL> tyrant = pytyrant . PyTyrant . open ( \"<STR_LIT:localhost>\" , <NUM_LIT> ) <EOL> now = datetime . datetime . utcnow ( ) <EOL> now = now . strftime ( \"<STR_LIT>\" ) <EOL> ITEMS_PER_FILE = <NUM_LIT> <EOL> FILENAME_TEMPLATE = \"<STR_LIT>\" <EOL> def check_for_fields ( ) : <EOL> with solr . pooled_connection ( fp . _fp_solr ) as host : <EOL> results = host . query ( \"<STR_LIT>\" , rows = <NUM_LIT:1> , score = False ) <EOL> if len ( results ) > <NUM_LIT:0> : <EOL> print >> sys . stderr , \"<STR_LIT>\" <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> results = host . query ( \"<STR_LIT>\" , rows = <NUM_LIT:1> , score = False ) <EOL> if len ( results ) > <NUM_LIT:0> : <EOL> print >> sys . stderr , \"<STR_LIT>\" <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> def dump ( start = <NUM_LIT:0> ) : <EOL> check_for_fields ( ) <EOL> try : <EOL> lastdump = tyrant [ \"<STR_LIT>\" ] <EOL> except KeyError : <EOL> lastdump = \"<STR_LIT:*>\" <EOL> filecount = <NUM_LIT:1> <EOL> itemcount = <NUM_LIT:1> <EOL> filename = FILENAME_TEMPLATE % ( SLAVE_NAME , now , filecount ) <EOL> writer = csv . writer ( open ( filename , \"<STR_LIT:w>\" ) ) <EOL> with solr . pooled_connection ( fp . _fp_solr ) as host : <EOL> items_to_dump = host . query ( \"<STR_LIT>\" % ( lastdump , now ) , rows = <NUM_LIT> , start = start ) <EOL> resultlen = len ( items_to_dump ) <EOL> while resultlen > <NUM_LIT:0> : <EOL> print \"<STR_LIT>\" % ( resultlen , items_to_dump . results . start ) <EOL> for r in items_to_dump . results : <EOL> row = [ r [ \"<STR_LIT>\" ] , <EOL> r [ \"<STR_LIT>\" ] , <EOL> tyrant [ str ( r [ \"<STR_LIT>\" ] ) ] , <EOL> r [ \"<STR_LIT>\" ] , <EOL> r . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> r . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , <EOL> r . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ] <EOL> writer . writerow ( row ) <EOL> itemcount += resultlen <EOL> if itemcount > ITEMS_PER_FILE : <EOL> filecount += <NUM_LIT:1> <EOL> filename = FILENAME_TEMPLATE % ( SLAVE_NAME , now , filecount ) <EOL> print \"<STR_LIT>\" % filename <EOL> writer = csv . writer ( open ( filename , \"<STR_LIT:w>\" ) ) <EOL> itemcount = resultlen <EOL> items_to_dump = items_to_dump . next_batch ( ) <EOL>", "answer": "resultlen = len ( items_to_dump )"}, {"prompt": "<s> from __future__ import absolute_import , division , unicode_literals <EOL> from six import text_type <EOL> from lxml import etree <EOL>", "answer": "from . . treebuilders . etree import tag_regexp"}, {"prompt": "<s> import psycopg2 <EOL> import argparse <EOL> import os <EOL> parser = argparse . ArgumentParser ( ) <EOL> parser . add_argument ( \"<STR_LIT>\" , type = int ) <EOL> parser . add_argument ( \"<STR_LIT>\" , type = int ) <EOL> arguments = parser . parse_args ( ) <EOL> os . setgid ( arguments . gid ) <EOL> os . setuid ( arguments . uid ) <EOL> import configuration <EOL> db = psycopg2 . connect ( ** configuration . database . PARAMETERS ) <EOL> cursor = db . cursor ( ) <EOL> try : <EOL> cursor . execute ( \"<STR_LIT>\" ) <EOL>", "answer": "except psycopg2 . ProgrammingError :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , serialize = False , auto_created = True , primary_key = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT:100> ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT:100> ) ) , <EOL>", "answer": "] ,"}, {"prompt": "<s> import os <EOL> import unittest <EOL> from robotide . robotapi import _Import <EOL> from resources import FakeSettings <EOL> from robotide . context import IS_WINDOWS <EOL> from robotide . namespace . resourcefactory import ResourceFactory <EOL> class _ResourceFactory ( ResourceFactory ) : <EOL> from_path = None <EOL> def _load_resource ( self , path , report_status ) : <EOL> return object ( ) <EOL> def _get_python_path ( self , name ) : <EOL> if not self . from_path : <EOL> return None <EOL> return os . path . join ( self . from_path , name ) <EOL> def _remove ( self ) : <EOL> p = self . _excludes . _exclude_file_path <EOL> if p : <EOL> os . remove ( p ) <EOL> class ResourceFactoryDirectoryIgnoreTestCase ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . _import = _Import ( None , __file__ ) <EOL> self . _context = self . _mock_context ( ) <EOL> def tearDown ( self ) : <EOL> if self . r : <EOL> self . r . _remove ( ) <EOL> def test_resourcefactory_finds_imported_resource ( self ) : <EOL> self . r = _ResourceFactory ( FakeSettings ( ) ) <EOL> self . _is_resolved ( self . r ) <EOL> def test_resourcefactory_ignores_imported_resource_from_ignore_directory ( self ) : <EOL> self . r = self . _create_factory ( os . path . dirname ( __file__ ) ) <EOL> self . assertEqual ( None , self . r . get_resource_from_import ( self . _import , self . _context ) ) <EOL> def test_resourcefactory_ignores_imported_resource_from_ignore_subdirectory ( self ) : <EOL> self . r = self . _create_factory ( os . path . split ( os . path . dirname ( __file__ ) ) [ <NUM_LIT:0> ] ) <EOL> self . assertEqual ( None , self . r . get_resource_from_import ( self . _import , self . _context ) ) <EOL> def test_resourcefactory_finds_imported_resource_when_subdirectory_ignored ( self ) : <EOL> self . r = self . _create_factory ( os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT>' ) ) <EOL> self . _is_resolved ( self . r ) <EOL> def test_resourcefactory_finds_imported_resource_when_similar_ignore_name ( self ) : <EOL> self . r = self . _create_factory ( os . path . dirname ( __file__ ) ) <EOL> imp = _Import ( None , os . path . join ( os . path . dirname ( __file__ ) + '<STR_LIT:2>' , '<STR_LIT:foo>' ) ) <EOL> self . _is_resolved ( self . r , imp ) <EOL> def test_resourcefactory_ignores_imported_resource_when_relative_import ( self ) : <EOL> self . r = self . _create_factory ( os . path . abspath ( '<STR_LIT:.>' ) ) <EOL> imp = _Import ( None , os . path . join ( '<STR_LIT:.>' , '<STR_LIT:foo>' ) ) <EOL> self . assertEqual ( None , self . r . get_resource_from_import ( imp , self . _context ) ) <EOL> def test_resourcefactory_finds_imported_resource_from_python_path ( self ) : <EOL> self . r = _ResourceFactory ( FakeSettings ( ) ) <EOL>", "answer": "self . r . from_path = os . path . dirname ( __file__ )"}, {"prompt": "<s> import logging <EOL> from flask import url_for <EOL> from jinja2 import Markup <EOL> from flask_admin import form <EOL> from quokka . core . db import db <EOL> from quokka . core . models . channel import Channel <EOL> from quokka . core . models . content import Content <EOL> from . controller import MediaController <EOL> logger = logging . getLogger ( ) <EOL> class Media ( MediaController , Content ) : <EOL> DEFAULT_CHANNEL = \"<STR_LIT>\" <EOL> path = db . StringField ( ) <EOL> embed = db . StringField ( ) <EOL> link = db . StringField ( ) <EOL> meta = { <EOL> '<STR_LIT>' : True <EOL> } <EOL> @ property <EOL> def full_path ( self ) : <EOL> return Markup ( <EOL> \"<STR_LIT>\" . format ( <EOL> full = url_for ( '<STR_LIT>' , filename = self . path ) , <EOL> path = self . path <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def get_default_channel ( cls ) : <EOL> default_channel = cls . DEFAULT_CHANNEL <EOL> try : <EOL> return Channel . objects . get ( long_slug = default_channel ) <EOL> except Exception as e : <EOL> logger . warning ( str ( e ) ) <EOL> return Channel . get_homepage ( ) <EOL> class Image ( Media ) : <EOL> DEFAULT_CHANNEL = '<STR_LIT>' <EOL> @ property <EOL> def thumb ( self ) : <EOL> return form . thumbgen_filename ( self . path ) <EOL>", "answer": "class File ( Media ) :"}, {"prompt": "<s> from south . utils import datetime_utils as datetime <EOL> from south . db import db <EOL> from south . v2 import SchemaMigration <EOL> from django . db import models <EOL> class Migration ( SchemaMigration ) : <EOL> def forwards ( self , orm ) : <EOL> db . alter_column ( '<STR_LIT>' , '<STR_LIT:url>' , self . gf ( '<STR_LIT>' ) ( ) ) <EOL> def backwards ( self , orm ) : <EOL> db . alter_column ( '<STR_LIT>' , '<STR_LIT:url>' , self . gf ( '<STR_LIT>' ) ( max_length = <NUM_LIT> ) ) <EOL> models = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT>' : '<STR_LIT:True>' , '<STR_LIT:max_length>' : '<STR_LIT>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" , '<STR_LIT>' : '<STR_LIT:False>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT>' : \"<STR_LIT>\" , '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT:100>' } ) , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:to>' : \"<STR_LIT>\" } ) , <EOL> '<STR_LIT:id>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:primary_key>' : '<STR_LIT:True>' } ) , <EOL> '<STR_LIT:name>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' } ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:Meta>' : { '<STR_LIT:object_name>' : '<STR_LIT>' } , <EOL> '<STR_LIT>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:default>' : '<STR_LIT>' } ) , <EOL>", "answer": "'<STR_LIT:email>' : ( '<STR_LIT>' , [ ] , { '<STR_LIT:max_length>' : '<STR_LIT>' , '<STR_LIT:blank>' : '<STR_LIT:True>' } ) ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> import time <EOL> from twisted . application import service <EOL> from twisted . internet import defer , protocol , task <EOL> from twisted . python import log <EOL> from vor . graphite import sanitizeMetricElement <EOL> import beanstalk <EOL> class BeanstalkFactory ( protocol . ReconnectingClientFactory ) : <EOL> protocol = beanstalk . twisted_client . Beanstalk <EOL> client = None <EOL> def buildProtocol ( self , addr ) : <EOL> p = protocol . ReconnectingClientFactory . buildProtocol ( self , addr ) <EOL> self . client = p <EOL> return p <EOL>", "answer": "class BeanstalkGraphiteService ( service . Service ) :"}, {"prompt": "<s> from __future__ import absolute_import <EOL> import base64 <EOL> import itertools <EOL> import functools <EOL> from datetime import datetime <EOL> import traceback <EOL> from PyQt5 . QtCore import QTimer <EOL> from PyQt5 . QtNetwork import ( <EOL> QNetworkAccessManager , <EOL> QNetworkProxyQuery , <EOL> QNetworkRequest , <EOL> QNetworkReply <EOL> ) <EOL> from twisted . python import log <EOL> from splash . qtutils import qurl2ascii , REQUEST_ERRORS , get_request_webframe <EOL> from splash . request_middleware import ( <EOL> AdblockMiddleware , <EOL> AllowedDomainsMiddleware , <EOL> AllowedSchemesMiddleware , <EOL> RequestLoggingMiddleware , <EOL> AdblockRulesRegistry , <EOL> ResourceTimeoutMiddleware ) <EOL> from splash . response_middleware import ContentTypeMiddleware <EOL> from splash import defaults <EOL> from splash . utils import to_bytes <EOL> from splash . cookies import SplashCookieJar <EOL> class NetworkManagerFactory ( object ) : <EOL> def __init__ ( self , filters_path = None , verbosity = None , allowed_schemes = None ) : <EOL> verbosity = defaults . VERBOSITY if verbosity is None else verbosity <EOL> self . verbosity = verbosity <EOL> self . request_middlewares = [ ] <EOL> self . response_middlewares = [ ] <EOL> self . adblock_rules = None <EOL> allowed_schemes = ( defaults . ALLOWED_SCHEMES if allowed_schemes is None <EOL> else allowed_schemes . split ( '<STR_LIT:U+002C>' ) ) <EOL> if allowed_schemes : <EOL> self . request_middlewares . append ( <EOL> AllowedSchemesMiddleware ( allowed_schemes , verbosity = verbosity ) <EOL> ) <EOL> if self . verbosity >= <NUM_LIT:2> : <EOL> self . request_middlewares . append ( RequestLoggingMiddleware ( ) ) <EOL> self . request_middlewares . append ( AllowedDomainsMiddleware ( verbosity = verbosity ) ) <EOL> self . request_middlewares . append ( ResourceTimeoutMiddleware ( ) ) <EOL> if filters_path is not None : <EOL> self . adblock_rules = AdblockRulesRegistry ( filters_path , verbosity = verbosity ) <EOL> self . request_middlewares . append ( <EOL> AdblockMiddleware ( self . adblock_rules , verbosity = verbosity ) <EOL> ) <EOL> self . response_middlewares . append ( ContentTypeMiddleware ( self . verbosity ) ) <EOL> def __call__ ( self ) : <EOL> manager = SplashQNetworkAccessManager ( <EOL> request_middlewares = self . request_middlewares , <EOL> response_middlewares = self . response_middlewares , <EOL> verbosity = self . verbosity , <EOL> ) <EOL> manager . setCache ( None ) <EOL> return manager <EOL> class ProxiedQNetworkAccessManager ( QNetworkAccessManager ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _REQUEST_ID = QNetworkRequest . User + <NUM_LIT:1> <EOL> def __init__ ( self , verbosity ) : <EOL> super ( ProxiedQNetworkAccessManager , self ) . __init__ ( ) <EOL> self . sslErrors . connect ( self . _on_ssl_errors ) <EOL> self . finished . connect ( self . _on_finished ) <EOL> self . verbosity = verbosity <EOL> self . _reply_timeout_timers = { } <EOL> self . _default_proxy = self . proxy ( ) <EOL> self . cookiejar = SplashCookieJar ( self ) <EOL> self . setCookieJar ( self . cookiejar ) <EOL> self . _request_ids = itertools . count ( ) <EOL> assert self . proxyFactory ( ) is None , \"<STR_LIT>\" <EOL> def _on_ssl_errors ( self , reply , errors ) : <EOL> reply . ignoreSslErrors ( ) <EOL> def _on_finished ( self , reply ) : <EOL> reply . deleteLater ( ) <EOL> def createRequest ( self , operation , request , outgoingData = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> start_time = datetime . utcnow ( ) <EOL> self . _clear_proxy ( ) <EOL> request , req_id = self . _wrap_request ( request ) <EOL> self . _handle_custom_headers ( request ) <EOL> self . _handle_request_cookies ( request ) <EOL> self . _run_webpage_callbacks ( request , '<STR_LIT>' , <EOL> request , operation , outgoingData ) <EOL> self . _handle_custom_proxies ( request ) <EOL> har = self . _get_har ( request ) <EOL> if har is not None : <EOL> har . store_new_request ( <EOL> req_id = req_id , <EOL> start_time = start_time , <EOL> operation = operation , <EOL> request = request , <EOL> outgoingData = outgoingData , <EOL> ) <EOL> reply = super ( ProxiedQNetworkAccessManager , self ) . createRequest ( <EOL> operation , request , outgoingData <EOL> ) <EOL> if hasattr ( request , '<STR_LIT>' ) : <EOL> timeout = request . timeout * <NUM_LIT:1000> <EOL> if timeout : <EOL> self . _set_reply_timeout ( reply , timeout ) <EOL> if har is not None : <EOL> har . store_new_reply ( req_id , reply ) <EOL> reply . error . connect ( self . _on_reply_error ) <EOL> reply . finished . connect ( self . _on_reply_finished ) <EOL> reply . metaDataChanged . connect ( self . _on_reply_headers ) <EOL> reply . downloadProgress . connect ( self . _on_reply_download_progress ) <EOL> return reply <EOL> def _set_reply_timeout ( self , reply , timeout_ms ) : <EOL> request_id = self . _get_request_id ( reply . request ( ) ) <EOL> timer = QTimer ( reply ) <EOL> timer . setSingleShot ( True ) <EOL> timer_callback = functools . partial ( self . _on_reply_timeout , <EOL> reply = reply , <EOL> timer = timer , <EOL> request_id = request_id ) <EOL> timer . timeout . connect ( timer_callback ) <EOL> self . _reply_timeout_timers [ request_id ] = timer <EOL> timer . start ( timeout_ms ) <EOL> def _on_reply_timeout ( self , reply , timer , request_id ) : <EOL> self . _reply_timeout_timers . pop ( request_id ) <EOL> self . log ( \"<STR_LIT>\" , reply , min_level = <NUM_LIT:1> ) <EOL> reply . abort ( ) <EOL> def _cancel_reply_timer ( self , reply ) : <EOL> request_id = self . _get_request_id ( reply . request ( ) ) <EOL> timer = self . _reply_timeout_timers . pop ( request_id , None ) <EOL> if timer and timer . isActive ( ) : <EOL> timer . stop ( ) <EOL> def _clear_proxy ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . setProxy ( self . _default_proxy ) <EOL> def _wrap_request ( self , request ) : <EOL> req = QNetworkRequest ( request ) <EOL> req_id = next ( self . _request_ids ) <EOL> req . setAttribute ( self . _REQUEST_ID , req_id ) <EOL> if hasattr ( request , '<STR_LIT>' ) : <EOL> req . timeout = request . timeout <EOL> return req , req_id <EOL> def _handle_custom_proxies ( self , request ) : <EOL> splash_proxy_factory = self . _get_webpage_attribute ( request , '<STR_LIT>' ) <EOL> if splash_proxy_factory : <EOL> proxy_query = QNetworkProxyQuery ( request . url ( ) ) <EOL> proxy = splash_proxy_factory . queryProxy ( proxy_query ) [ <NUM_LIT:0> ] <EOL> self . setProxy ( proxy ) <EOL> if hasattr ( request , '<STR_LIT>' ) : <EOL> self . setProxy ( request . custom_proxy ) <EOL> user , password = request . custom_proxy . user ( ) , request . custom_proxy . password ( ) <EOL> if not user and not password : <EOL> return <EOL> auth = b\"<STR_LIT>\" + base64 . b64encode ( \"<STR_LIT>\" . format ( user , password ) . encode ( \"<STR_LIT:utf-8>\" ) ) <EOL> request . setRawHeader ( b\"<STR_LIT>\" , auth ) <EOL> def _handle_custom_headers ( self , request ) : <EOL> if self . _get_webpage_attribute ( request , \"<STR_LIT>\" ) : <EOL> self . _set_webpage_attribute ( request , \"<STR_LIT>\" , False ) <EOL> return <EOL> headers = self . _get_webpage_attribute ( request , \"<STR_LIT>\" ) <EOL> if isinstance ( headers , dict ) : <EOL> headers = headers . items ( ) <EOL> for name , value in headers or [ ] : <EOL> request . setRawHeader ( to_bytes ( name ) , to_bytes ( value ) ) <EOL> def _handle_request_cookies ( self , request ) : <EOL> self . cookiejar . update_cookie_header ( request ) <EOL> def _handle_reply_cookies ( self , reply ) : <EOL> self . cookiejar . fill_from_reply ( reply ) <EOL> def _get_request_id ( self , request = None ) : <EOL> if request is None : <EOL> request = self . sender ( ) . request ( ) <EOL> return request . attribute ( self . _REQUEST_ID ) <EOL> def _get_har ( self , request = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if request is None : <EOL> request = self . sender ( ) . request ( ) <EOL> return self . _get_webpage_attribute ( request , \"<STR_LIT>\" ) <EOL> def _get_webpage_attribute ( self , request , attribute ) : <EOL> web_frame = get_request_webframe ( request ) <EOL> if web_frame : <EOL> return getattr ( web_frame . page ( ) , attribute , None ) <EOL> def _set_webpage_attribute ( self , request , attribute , value ) : <EOL> web_frame = get_request_webframe ( request ) <EOL> if web_frame : <EOL> return setattr ( web_frame . page ( ) , attribute , value ) <EOL> def _on_reply_error ( self , error_id ) : <EOL> if error_id != QNetworkReply . OperationCanceledError : <EOL> error_msg = REQUEST_ERRORS . get ( error_id , '<STR_LIT>' ) <EOL> self . log ( '<STR_LIT>' % ( error_id , error_msg ) , <EOL> self . sender ( ) , min_level = <NUM_LIT:2> ) <EOL> def _on_reply_finished ( self ) : <EOL> reply = self . sender ( ) <EOL> request = reply . request ( ) <EOL> self . _cancel_reply_timer ( reply ) <EOL> har = self . _get_har ( ) <EOL> har_entry = None <EOL> if har is not None : <EOL> req_id = self . _get_request_id ( ) <EOL> har . store_reply_finished ( req_id , reply ) <EOL> har_entry = har . get_entry ( req_id ) <EOL> self . _run_webpage_callbacks ( request , \"<STR_LIT>\" , reply , har_entry ) <EOL> self . log ( \"<STR_LIT>\" , reply ) <EOL> def _on_reply_headers ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> reply = self . sender ( ) <EOL> request = reply . request ( ) <EOL> self . _handle_reply_cookies ( reply ) <EOL> self . _run_webpage_callbacks ( request , \"<STR_LIT>\" , reply ) <EOL> har = self . _get_har ( ) <EOL> if har is not None : <EOL> har . store_reply_headers_received ( self . _get_request_id ( request ) , reply ) <EOL> self . log ( \"<STR_LIT>\" , reply , min_level = <NUM_LIT:3> ) <EOL> def _on_reply_download_progress ( self , received , total ) : <EOL> har = self . _get_har ( ) <EOL> if har is not None : <EOL> req_id = self . _get_request_id ( ) <EOL> har . store_reply_download_progress ( req_id , received , total ) <EOL> if total == - <NUM_LIT:1> : <EOL> total = '<STR_LIT:?>' <EOL> self . log ( \"<STR_LIT>\" % ( received , total ) , <EOL> self . sender ( ) , min_level = <NUM_LIT:4> ) <EOL> def _on_reply_upload_progress ( self , sent , total ) : <EOL> har = self . _get_har ( ) <EOL> if har is not None : <EOL> req_id = self . _get_request_id ( ) <EOL> har . store_request_upload_progress ( req_id , sent , total ) <EOL> if total == - <NUM_LIT:1> : <EOL> total = '<STR_LIT:?>' <EOL> self . log ( \"<STR_LIT>\" % ( sent , total ) , <EOL> self . sender ( ) , min_level = <NUM_LIT:4> ) <EOL> def _get_render_options ( self , request ) : <EOL> return self . _get_webpage_attribute ( request , '<STR_LIT>' ) <EOL> def _run_webpage_callbacks ( self , request , event_name , * args ) : <EOL> callbacks = self . _get_webpage_attribute ( request , \"<STR_LIT>\" ) <EOL> if not callbacks : <EOL> return <EOL> for cb in callbacks . get ( event_name , [ ] ) : <EOL> try : <EOL> cb ( * args ) <EOL> except : <EOL> self . log ( \"<STR_LIT>\" % event_name , min_level = <NUM_LIT:1> ) <EOL> self . log ( traceback . format_exc ( ) , min_level = <NUM_LIT:1> , format_msg = False ) <EOL> def log ( self , msg , reply = None , min_level = <NUM_LIT:2> , format_msg = True ) : <EOL> if self . verbosity < min_level : <EOL> return <EOL> if not reply : <EOL> url = '<STR_LIT>' <EOL> else : <EOL> url = qurl2ascii ( reply . url ( ) ) <EOL> if not url : <EOL> return <EOL> if format_msg : <EOL> msg = msg . format ( url = url ) <EOL> log . msg ( msg , system = '<STR_LIT>' ) <EOL> class SplashQNetworkAccessManager ( ProxiedQNetworkAccessManager ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , request_middlewares , response_middlewares , verbosity ) : <EOL> super ( SplashQNetworkAccessManager , self ) . __init__ ( verbosity = verbosity ) <EOL> self . request_middlewares = request_middlewares <EOL> self . response_middlewares = response_middlewares <EOL> def run_response_middlewares ( self ) : <EOL> reply = self . sender ( ) <EOL> reply . metaDataChanged . disconnect ( self . run_response_middlewares ) <EOL> render_options = self . _get_render_options ( reply . request ( ) ) <EOL> if render_options : <EOL> try : <EOL> for middleware in self . response_middlewares : <EOL> middleware . process ( reply , render_options ) <EOL> except : <EOL> self . log ( \"<STR_LIT>\" , min_level = <NUM_LIT:1> ) <EOL> self . log ( traceback . format_exc ( ) , min_level = <NUM_LIT:1> , format_msg = False ) <EOL> def createRequest ( self , operation , request , outgoingData = None ) : <EOL> render_options = self . _get_render_options ( request ) <EOL> if render_options : <EOL> try : <EOL> for middleware in self . request_middlewares : <EOL> request = middleware . process ( request , render_options , operation , outgoingData ) <EOL> except : <EOL> self . log ( \"<STR_LIT>\" , min_level = <NUM_LIT:1> ) <EOL> self . log ( traceback . format_exc ( ) , min_level = <NUM_LIT:1> , format_msg = False ) <EOL>", "answer": "reply = super ( SplashQNetworkAccessManager , self ) . createRequest ( operation , request , outgoingData )"}, {"prompt": "<s> from sympy import ( Symbol , Set , Union , Interval , oo , S , sympify , nan , <EOL> GreaterThan , LessThan , Max , Min , And , Or , Eq , Ge , Le , Gt , Lt , Float , <EOL> FiniteSet , Intersection , imageset , I , true , false , ProductSet , E , <EOL> sqrt , Complement , EmptySet , sin , cos , Lambda , ImageSet , pi , <EOL> Eq , Pow , Contains , Sum , rootof , SymmetricDifference , Piecewise , <EOL> Matrix , signsimp , Range ) <EOL> from mpmath import mpi <EOL> from sympy . core . compatibility import range <EOL> from sympy . utilities . pytest import raises , XFAIL <EOL> from sympy . abc import x , y , z , m , n <EOL> def test_imageset ( ) : <EOL> ints = S . Integers <EOL> raises ( TypeError , lambda : imageset ( x , ints ) ) <EOL> raises ( ValueError , lambda : imageset ( x , y , z , ints ) ) <EOL> raises ( ValueError , lambda : imageset ( Lambda ( x , cos ( x ) ) , y ) ) <EOL> assert imageset ( cos , ints ) == ImageSet ( Lambda ( x , cos ( x ) ) , ints ) <EOL> def f ( x ) : <EOL> return cos ( x ) <EOL> raises ( TypeError , lambda : imageset ( f , ints ) ) <EOL> f = lambda x : cos ( x ) <EOL> assert imageset ( f , ints ) == ImageSet ( Lambda ( x , cos ( x ) ) , ints ) <EOL> assert imageset ( x , <NUM_LIT:1> , ints ) == FiniteSet ( <NUM_LIT:1> ) <EOL> assert imageset ( x , y , ints ) == FiniteSet ( y ) <EOL> assert ( str ( imageset ( lambda y : x + y , Interval ( - <NUM_LIT:2> , <NUM_LIT:1> ) ) . lamda . expr ) <EOL> in ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> def test_interval_arguments ( ) : <EOL> assert Interval ( <NUM_LIT:0> , oo ) == Interval ( <NUM_LIT:0> , oo , False , True ) <EOL> assert Interval ( <NUM_LIT:0> , oo ) . right_open is true <EOL> assert Interval ( - oo , <NUM_LIT:0> ) == Interval ( - oo , <NUM_LIT:0> , True , False ) <EOL> assert Interval ( - oo , <NUM_LIT:0> ) . left_open is true <EOL> assert Interval ( oo , - oo ) == S . EmptySet <EOL> assert isinstance ( Interval ( <NUM_LIT:1> , <NUM_LIT:1> ) , FiniteSet ) <EOL> e = Sum ( x , ( x , <NUM_LIT:1> , <NUM_LIT:3> ) ) <EOL> assert isinstance ( Interval ( e , e ) , FiniteSet ) <EOL> assert Interval ( <NUM_LIT:1> , <NUM_LIT:0> ) == S . EmptySet <EOL> assert Interval ( <NUM_LIT:1> , <NUM_LIT:1> ) . measure == <NUM_LIT:0> <EOL> assert Interval ( <NUM_LIT:1> , <NUM_LIT:1> , False , True ) == S . EmptySet <EOL> assert Interval ( <NUM_LIT:1> , <NUM_LIT:1> , True , False ) == S . EmptySet <EOL> assert Interval ( <NUM_LIT:1> , <NUM_LIT:1> , True , True ) == S . EmptySet <EOL> assert isinstance ( Interval ( <NUM_LIT:0> , Symbol ( '<STR_LIT:a>' ) ) , Interval ) <EOL> assert Interval ( Symbol ( '<STR_LIT:a>' , real = True , positive = True ) , <NUM_LIT:0> ) == S . EmptySet <EOL> raises ( ValueError , lambda : Interval ( <NUM_LIT:0> , S . ImaginaryUnit ) ) <EOL> raises ( ValueError , lambda : Interval ( <NUM_LIT:0> , Symbol ( '<STR_LIT:z>' , real = False ) ) ) <EOL> raises ( NotImplementedError , lambda : Interval ( <NUM_LIT:0> , <NUM_LIT:1> , And ( x , y ) ) ) <EOL> raises ( NotImplementedError , lambda : Interval ( <NUM_LIT:0> , <NUM_LIT:1> , False , And ( x , y ) ) ) <EOL> raises ( NotImplementedError , lambda : Interval ( <NUM_LIT:0> , <NUM_LIT:1> , z , And ( x , y ) ) ) <EOL> def test_interval_symbolic_end_points ( ) : <EOL> a = Symbol ( '<STR_LIT:a>' , real = True ) <EOL> assert Union ( Interval ( <NUM_LIT:0> , a ) , Interval ( <NUM_LIT:0> , <NUM_LIT:3> ) ) . sup == Max ( a , <NUM_LIT:3> ) <EOL> assert Union ( Interval ( a , <NUM_LIT:0> ) , Interval ( - <NUM_LIT:3> , <NUM_LIT:0> ) ) . inf == Min ( - <NUM_LIT:3> , a ) <EOL> assert Interval ( <NUM_LIT:0> , a ) . contains ( <NUM_LIT:1> ) == LessThan ( <NUM_LIT:1> , a ) <EOL> def test_union ( ) : <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:3> , True ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:4> ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:4> ) <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) , Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) , Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:3> , False , True ) , Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> , False , True ) <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) , Interval ( <NUM_LIT:1> , <NUM_LIT:2> , False , True ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> , True ) , Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> , True ) , Interval ( <NUM_LIT:1> , <NUM_LIT:3> , True ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> , True ) <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> , True ) , Interval ( <NUM_LIT:1> , <NUM_LIT:3> , True , True ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> , True , True ) <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> , True , True ) , Interval ( <NUM_LIT:1> , <NUM_LIT:3> , True ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> , True ) <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:3> , False , True ) , Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> , False , True ) , Interval ( <NUM_LIT:2> , <NUM_LIT:3> , True ) ) != Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) , S . EmptySet ) == Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> assert Union ( S . EmptySet ) == S . EmptySet <EOL> assert Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , [ FiniteSet ( <NUM_LIT:1.0> / n ) for n in range ( <NUM_LIT:1> , <NUM_LIT:10> ) ] ) == Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> assert Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) . union ( Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) + Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) <EOL> assert Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) . union ( Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) <EOL> assert Union ( Set ( ) ) == Set ( ) <EOL> assert FiniteSet ( <NUM_LIT:1> ) + FiniteSet ( <NUM_LIT:2> ) + FiniteSet ( <NUM_LIT:3> ) == FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) <EOL> assert FiniteSet ( '<STR_LIT>' ) + FiniteSet ( '<STR_LIT>' ) == FiniteSet ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) + S . EmptySet == FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) & FiniteSet ( <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) == FiniteSet ( <NUM_LIT:2> , <NUM_LIT:3> ) <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) | FiniteSet ( <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) == FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) <EOL> x = Symbol ( \"<STR_LIT:x>\" ) <EOL> y = Symbol ( \"<STR_LIT:y>\" ) <EOL> z = Symbol ( \"<STR_LIT:z>\" ) <EOL> assert S . EmptySet | FiniteSet ( x , FiniteSet ( y , z ) ) == FiniteSet ( x , FiniteSet ( y , z ) ) <EOL> assert Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) + FiniteSet ( <NUM_LIT:2> ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) <EOL> assert Interval ( <NUM_LIT:1> , <NUM_LIT:3> , True , True ) + FiniteSet ( <NUM_LIT:3> ) == Interval ( <NUM_LIT:1> , <NUM_LIT:3> , True , False ) <EOL> X = Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) + FiniteSet ( <NUM_LIT:5> ) <EOL> Y = Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) + FiniteSet ( <NUM_LIT:3> ) <EOL> XandY = X . intersect ( Y ) <EOL> assert <NUM_LIT:2> in X and <NUM_LIT:3> in X and <NUM_LIT:3> in XandY <EOL> assert XandY . is_subset ( X ) and XandY . is_subset ( Y ) <EOL> raises ( TypeError , lambda : Union ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> assert X . is_iterable is False <EOL> assert Union ( S . EmptySet , FiniteSet ( - sqrt ( - I ) , sqrt ( - I ) ) ) == FiniteSet ( - sqrt ( - I ) , sqrt ( - I ) ) <EOL> def test_union_iter ( ) : <EOL> u = Union ( Range ( <NUM_LIT:3> ) , Range ( <NUM_LIT:5> ) , Range ( <NUM_LIT:3> ) , evaluate = False ) <EOL> assert list ( u ) == [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ] <EOL> def test_difference ( ) : <EOL> assert Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) - Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) == Interval ( <NUM_LIT:2> , <NUM_LIT:3> , True ) <EOL> assert Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) - Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) == Interval ( <NUM_LIT:1> , <NUM_LIT:2> , False , True ) <EOL> assert Interval ( <NUM_LIT:1> , <NUM_LIT:3> , True ) - Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) == Interval ( <NUM_LIT:1> , <NUM_LIT:2> , True , True ) <EOL> assert Interval ( <NUM_LIT:1> , <NUM_LIT:3> , True ) - Interval ( <NUM_LIT:2> , <NUM_LIT:3> , True ) == Interval ( <NUM_LIT:1> , <NUM_LIT:2> , True , False ) <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) - FiniteSet ( <NUM_LIT:1> ) == Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> , False , True ) , Interval ( <NUM_LIT:1> , <NUM_LIT:2> , True , False ) ) <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) - FiniteSet ( <NUM_LIT:2> ) == FiniteSet ( <NUM_LIT:1> , <NUM_LIT:3> ) <EOL> assert FiniteSet ( '<STR_LIT>' , '<STR_LIT>' ) - FiniteSet ( '<STR_LIT>' ) == FiniteSet ( '<STR_LIT>' ) <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) - Interval ( <NUM_LIT:2> , <NUM_LIT:10> , True , False ) == FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) - S . EmptySet == FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) <EOL> assert Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) , FiniteSet ( <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) ) - Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) == Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> , False , True ) , FiniteSet ( <NUM_LIT:4> ) ) <EOL> assert - <NUM_LIT:1> in S . Reals - S . Naturals <EOL> def test_Complement ( ) : <EOL> assert Complement ( Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) , Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) ) == Interval ( <NUM_LIT:2> , <NUM_LIT:3> , True ) <EOL> assert Complement ( FiniteSet ( <NUM_LIT:1> , <NUM_LIT:3> , <NUM_LIT:4> ) , FiniteSet ( <NUM_LIT:3> , <NUM_LIT:4> ) ) == FiniteSet ( <NUM_LIT:1> ) <EOL> assert Complement ( Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) , <EOL> FiniteSet ( <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) ) , Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) ) == Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> , False , True ) , FiniteSet ( <NUM_LIT:4> ) ) <EOL> assert not <NUM_LIT:3> in Complement ( Interval ( <NUM_LIT:0> , <NUM_LIT:5> ) , Interval ( <NUM_LIT:1> , <NUM_LIT:4> ) , evaluate = False ) <EOL> assert - <NUM_LIT:1> in Complement ( S . Reals , S . Naturals , evaluate = False ) <EOL> assert not <NUM_LIT:1> in Complement ( S . Reals , S . Naturals , evaluate = False ) <EOL> assert Complement ( S . Integers , S . UniversalSet ) == EmptySet ( ) <EOL> assert S . UniversalSet . complement ( S . Integers ) == EmptySet ( ) <EOL> assert ( not <NUM_LIT:0> in S . Reals . intersect ( S . Integers - FiniteSet ( <NUM_LIT:0> ) ) ) <EOL> assert S . EmptySet - S . Integers == S . EmptySet <EOL> assert ( S . Integers - FiniteSet ( <NUM_LIT:0> ) ) - FiniteSet ( <NUM_LIT:1> ) == S . Integers - FiniteSet ( <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> assert S . Reals - Union ( S . Naturals , FiniteSet ( pi ) ) == Intersection ( S . Reals - S . Naturals , S . Reals - FiniteSet ( pi ) ) <EOL> def test_complement ( ) : <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) . complement ( S . Reals ) == Union ( Interval ( - oo , <NUM_LIT:0> , True , True ) , Interval ( <NUM_LIT:1> , oo , True , True ) ) <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> , True , False ) . complement ( S . Reals ) == Union ( Interval ( - oo , <NUM_LIT:0> , True , False ) , Interval ( <NUM_LIT:1> , oo , True , True ) ) <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> , False , True ) . complement ( S . Reals ) == Union ( Interval ( - oo , <NUM_LIT:0> , True , True ) , Interval ( <NUM_LIT:1> , oo , False , True ) ) <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> , True , True ) . complement ( S . Reals ) == Union ( Interval ( - oo , <NUM_LIT:0> , True , False ) , Interval ( <NUM_LIT:1> , oo , False , True ) ) <EOL> assert S . UniversalSet . complement ( S . EmptySet ) == S . EmptySet <EOL> assert S . UniversalSet . complement ( S . Reals ) == S . EmptySet <EOL> assert S . UniversalSet . complement ( S . UniversalSet ) == S . EmptySet <EOL> assert S . EmptySet . complement ( S . Reals ) == S . Reals <EOL> assert Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) ) . complement ( S . Reals ) == Union ( Interval ( - oo , <NUM_LIT:0> , True , True ) , Interval ( <NUM_LIT:1> , <NUM_LIT:2> , True , True ) , <EOL> Interval ( <NUM_LIT:3> , oo , True , True ) ) <EOL> assert FiniteSet ( <NUM_LIT:0> ) . complement ( S . Reals ) == Union ( Interval ( - oo , <NUM_LIT:0> , True , True ) , Interval ( <NUM_LIT:0> , oo , True , True ) ) <EOL> assert ( FiniteSet ( <NUM_LIT:5> ) + Interval ( S . NegativeInfinity , <EOL> <NUM_LIT:0> ) ) . complement ( S . Reals ) == Interval ( <NUM_LIT:0> , <NUM_LIT:5> , True , True ) + Interval ( <NUM_LIT:5> , S . Infinity , True , True ) <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) . complement ( S . Reals ) == Interval ( S . NegativeInfinity , <NUM_LIT:1> , True , True ) + Interval ( <NUM_LIT:1> , <NUM_LIT:2> , True , True ) + Interval ( <NUM_LIT:2> , <NUM_LIT:3> , True , True ) + Interval ( <NUM_LIT:3> , S . Infinity , True , True ) <EOL> assert FiniteSet ( x ) . complement ( S . Reals ) == Complement ( S . Reals , FiniteSet ( x ) ) <EOL> assert FiniteSet ( <NUM_LIT:0> , x ) . complement ( S . Reals ) == Complement ( Interval ( - oo , <NUM_LIT:0> , True , True ) + <EOL> Interval ( <NUM_LIT:0> , oo , True , True ) <EOL> , FiniteSet ( x ) , evaluate = False ) <EOL> square = Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) * Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> notsquare = square . complement ( S . Reals * S . Reals ) <EOL> assert all ( pt in square for pt in [ ( <NUM_LIT:0> , <NUM_LIT:0> ) , ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:1> ) ] ) <EOL> assert not any ( <EOL> pt in notsquare for pt in [ ( <NUM_LIT:0> , <NUM_LIT:0> ) , ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:1> ) ] ) <EOL> assert not any ( pt in square for pt in [ ( - <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT:10> , <NUM_LIT:10> ) ] ) <EOL> assert all ( pt in notsquare for pt in [ ( - <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT> , <NUM_LIT> ) , ( <NUM_LIT:10> , <NUM_LIT:10> ) ] ) <EOL> def test_intersect ( ) : <EOL> x = Symbol ( '<STR_LIT:x>' ) <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) . intersect ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) . intersect ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> , True ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:2> , True ) <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> , True ) . intersect ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:2> , False , False ) <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> , True , True ) . intersect ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) ) == Interval ( <NUM_LIT:1> , <NUM_LIT:2> , False , True ) <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) . intersect ( Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) ) ) == Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:2> ) ) <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> ) . _intersect ( ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) == FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , x ) . intersect ( FiniteSet ( x ) ) == FiniteSet ( x ) <EOL> assert FiniteSet ( '<STR_LIT>' , '<STR_LIT>' ) . intersect ( FiniteSet ( '<STR_LIT>' ) ) == FiniteSet ( '<STR_LIT>' ) <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> ) . intersect ( S . EmptySet ) == S . EmptySet <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:5> ) . intersect ( FiniteSet ( <NUM_LIT:1> , <NUM_LIT:3> ) ) == FiniteSet ( <NUM_LIT:1> , <NUM_LIT:3> ) <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> , True , True ) . intersect ( FiniteSet ( <NUM_LIT:1> ) ) == S . EmptySet <EOL> assert Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) ) . intersect ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) ) == Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:2> ) ) <EOL> assert Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) ) . intersect ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) ) == Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:2> ) ) <EOL> assert Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) ) . intersect ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> , True , True ) ) == S . EmptySet <EOL> assert Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) ) . intersect ( S . EmptySet ) == S . EmptySet <EOL> assert Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:5> ) , FiniteSet ( '<STR_LIT>' ) ) . intersect ( FiniteSet ( <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> , <NUM_LIT:6> ) ) == Union ( FiniteSet ( <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> ) , Intersection ( FiniteSet ( <NUM_LIT:6> ) , Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:5> ) , FiniteSet ( '<STR_LIT>' ) ) ) ) <EOL> assert Intersection ( FiniteSet ( x ) , FiniteSet ( y ) ) == Intersection ( FiniteSet ( x ) , FiniteSet ( y ) , evaluate = False ) <EOL> assert FiniteSet ( x ) . intersect ( S . Reals ) == Intersection ( S . Reals , FiniteSet ( x ) , evaluate = False ) <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:5> ) . intersection ( FiniteSet ( <NUM_LIT:1> , <NUM_LIT:3> ) ) == FiniteSet ( <NUM_LIT:1> , <NUM_LIT:3> ) <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> , True , True ) . intersection ( FiniteSet ( <NUM_LIT:1> ) ) == S . EmptySet <EOL> assert Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) ) . intersection ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) ) == Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:2> ) ) <EOL> def test_intersection ( ) : <EOL> i = Intersection ( FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:5> ) , evaluate = False ) <EOL> assert i . is_iterable <EOL> assert set ( i ) == { S ( <NUM_LIT:2> ) , S ( <NUM_LIT:3> ) } <EOL> x = Symbol ( '<STR_LIT:x>' , real = True ) <EOL> i = Intersection ( Interval ( <NUM_LIT:0> , <NUM_LIT:3> ) , Interval ( x , <NUM_LIT:6> ) ) <EOL> assert ( <NUM_LIT:5> in i ) is False <EOL> raises ( TypeError , lambda : <NUM_LIT:2> in i ) <EOL> assert Intersection ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , S . EmptySet ) == S . EmptySet <EOL> assert Intersection ( Interval ( - oo , oo ) , Interval ( - oo , x ) ) == Interval ( - oo , x ) <EOL> line = Interval ( <NUM_LIT:0> , <NUM_LIT:5> ) <EOL> i = Intersection ( line ** <NUM_LIT:2> , line ** <NUM_LIT:3> , evaluate = False ) <EOL> assert ( <NUM_LIT:2> , <NUM_LIT:2> ) not in i <EOL> assert ( <NUM_LIT:2> , <NUM_LIT:2> , <NUM_LIT:2> ) not in i <EOL> raises ( ValueError , lambda : list ( i ) ) <EOL> assert Intersection ( Intersection ( S . Integers , S . Naturals , evaluate = False ) , <EOL> S . Reals , evaluate = False ) == Intersection ( S . Integers , S . Naturals , S . Reals , evaluate = False ) <EOL> def test_issue_9623 ( ) : <EOL> n = Symbol ( '<STR_LIT:n>' ) <EOL> a = S . Reals <EOL> b = Interval ( <NUM_LIT:0> , oo ) <EOL> c = FiniteSet ( n ) <EOL> assert Intersection ( a , b , c ) == Intersection ( b , c ) <EOL> assert Intersection ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) , Interval ( <NUM_LIT:3> , <NUM_LIT:4> ) , FiniteSet ( n ) ) == EmptySet ( ) <EOL> def test_is_disjoint ( ) : <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) . is_disjoint ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) ) == False <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) . is_disjoint ( Interval ( <NUM_LIT:3> , <NUM_LIT:4> ) ) == True <EOL> def test_ProductSet_of_single_arg_is_arg ( ) : <EOL> assert ProductSet ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) ) == Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> def test_interval_subs ( ) : <EOL> a = Symbol ( '<STR_LIT:a>' , real = True ) <EOL> assert Interval ( <NUM_LIT:0> , a ) . subs ( a , <NUM_LIT:2> ) == Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) <EOL> assert Interval ( a , <NUM_LIT:0> ) . subs ( a , <NUM_LIT:2> ) == S . EmptySet <EOL> def test_interval_to_mpi ( ) : <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) . to_mpi ( ) == mpi ( <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> , True , False ) . to_mpi ( ) == mpi ( <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> assert type ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) . to_mpi ( ) ) == type ( mpi ( <NUM_LIT:0> , <NUM_LIT:1> ) ) <EOL> def test_measure ( ) : <EOL> a = Symbol ( '<STR_LIT:a>' , real = True ) <EOL> assert Interval ( <NUM_LIT:1> , <NUM_LIT:3> ) . measure == <NUM_LIT:2> <EOL> assert Interval ( <NUM_LIT:0> , a ) . measure == a <EOL> assert Interval ( <NUM_LIT:1> , a ) . measure == a - <NUM_LIT:1> <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) , Interval ( <NUM_LIT:3> , <NUM_LIT:4> ) ) . measure == <NUM_LIT:2> <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) , Interval ( <NUM_LIT:3> , <NUM_LIT:4> ) , FiniteSet ( <NUM_LIT:5> , <NUM_LIT:6> , <NUM_LIT:7> ) ) . measure == <NUM_LIT:2> <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , oo , a , - oo , - <NUM_LIT:5> ) . measure == <NUM_LIT:0> <EOL> assert S . EmptySet . measure == <NUM_LIT:0> <EOL> square = Interval ( <NUM_LIT:0> , <NUM_LIT:10> ) * Interval ( <NUM_LIT:0> , <NUM_LIT:10> ) <EOL> offsetsquare = Interval ( <NUM_LIT:5> , <NUM_LIT:15> ) * Interval ( <NUM_LIT:5> , <NUM_LIT:15> ) <EOL> band = Interval ( - oo , oo ) * Interval ( <NUM_LIT:2> , <NUM_LIT:4> ) <EOL> assert square . measure == offsetsquare . measure == <NUM_LIT:100> <EOL> assert ( square + offsetsquare ) . measure == <NUM_LIT> <EOL> assert ( square - offsetsquare ) . measure == <NUM_LIT> <EOL> assert ( square * FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) . measure == <NUM_LIT:0> <EOL> assert ( square . intersect ( band ) ) . measure == <NUM_LIT:20> <EOL> assert ( square + band ) . measure == oo <EOL> assert ( band * FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) . measure == nan <EOL> def test_is_subset ( ) : <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) . is_subset ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) ) is True <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:3> ) . is_subset ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) ) is False <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> ) . is_subset ( FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) ) <EOL> assert FiniteSet ( <NUM_LIT:4> , <NUM_LIT:5> ) . is_subset ( FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) ) is False <EOL> assert FiniteSet ( <NUM_LIT:1> ) . is_subset ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) ) <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> ) . is_subset ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> , True , True ) ) is False <EOL> assert ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) + FiniteSet ( <NUM_LIT:3> ) ) . is_subset ( <EOL> ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> , False , True ) + FiniteSet ( <NUM_LIT:2> , <NUM_LIT:3> ) ) ) <EOL> assert Interval ( <NUM_LIT:3> , <NUM_LIT:4> ) . is_subset ( Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:5> ) ) ) is True <EOL> assert Interval ( <NUM_LIT:3> , <NUM_LIT:6> ) . is_subset ( Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:5> ) ) ) is False <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) . is_subset ( Interval ( <NUM_LIT:0> , <NUM_LIT:5> ) ) is True <EOL> assert S . EmptySet . is_subset ( FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) is True <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) . is_subset ( S . EmptySet ) is False <EOL> assert S . EmptySet . is_subset ( S . EmptySet ) is True <EOL> raises ( ValueError , lambda : S . EmptySet . is_subset ( <NUM_LIT:1> ) ) <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) . issubset ( Interval ( <NUM_LIT:0> , <NUM_LIT:5> ) ) is True <EOL> assert S . EmptySet . issubset ( FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) is True <EOL> def test_is_proper_subset ( ) : <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) . is_proper_subset ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) ) is True <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:3> ) . is_proper_subset ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) ) is False <EOL> assert S . EmptySet . is_proper_subset ( FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) is True <EOL> raises ( ValueError , lambda : Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) . is_proper_subset ( <NUM_LIT:0> ) ) <EOL> def test_is_superset ( ) : <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) . is_superset ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) ) == False <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:3> ) . is_superset ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) ) <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> ) . is_superset ( FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) ) == False <EOL> assert FiniteSet ( <NUM_LIT:4> , <NUM_LIT:5> ) . is_superset ( FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) ) == False <EOL> assert FiniteSet ( <NUM_LIT:1> ) . is_superset ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) ) == False <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> ) . is_superset ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> , True , True ) ) == False <EOL> assert ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) + FiniteSet ( <NUM_LIT:3> ) ) . is_superset ( <EOL> ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> , False , True ) + FiniteSet ( <NUM_LIT:2> , <NUM_LIT:3> ) ) ) == False <EOL> assert Interval ( <NUM_LIT:3> , <NUM_LIT:4> ) . is_superset ( Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:5> ) ) ) == False <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) . is_superset ( Interval ( <NUM_LIT:0> , <NUM_LIT:5> ) ) == False <EOL> assert S . EmptySet . is_superset ( FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) == False <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) . is_superset ( S . EmptySet ) == True <EOL> assert S . EmptySet . is_superset ( S . EmptySet ) == True <EOL> raises ( ValueError , lambda : S . EmptySet . is_superset ( <NUM_LIT:1> ) ) <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) . issuperset ( S . EmptySet ) == True <EOL> assert S . EmptySet . issuperset ( S . EmptySet ) == True <EOL> def test_is_proper_superset ( ) : <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) . is_proper_superset ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) ) is False <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:3> ) . is_proper_superset ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) ) is True <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) . is_proper_superset ( S . EmptySet ) is True <EOL> raises ( ValueError , lambda : Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) . is_proper_superset ( <NUM_LIT:0> ) ) <EOL> def test_contains ( ) : <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) . contains ( <NUM_LIT:1> ) is S . true <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) . contains ( <NUM_LIT:3> ) is S . false <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> , True , False ) . contains ( <NUM_LIT:0> ) is S . false <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> , True , False ) . contains ( <NUM_LIT:2> ) is S . true <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> , False , True ) . contains ( <NUM_LIT:0> ) is S . true <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> , False , True ) . contains ( <NUM_LIT:2> ) is S . false <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> , True , True ) . contains ( <NUM_LIT:0> ) is S . false <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:2> , True , True ) . contains ( <NUM_LIT:2> ) is S . false <EOL> assert ( Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) in Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) ) is False <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) . contains ( <NUM_LIT:2> ) is S . true <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , Symbol ( '<STR_LIT:x>' ) ) . contains ( Symbol ( '<STR_LIT:x>' ) ) is S . true <EOL> from sympy . abc import a , b <EOL> assert isinstance ( FiniteSet ( b ) . contains ( - a ) , Contains ) <EOL> assert isinstance ( FiniteSet ( b ) . contains ( a ) , Contains ) <EOL> assert isinstance ( FiniteSet ( a ) . contains ( <NUM_LIT:1> ) , Contains ) <EOL> raises ( TypeError , lambda : <NUM_LIT:1> in FiniteSet ( a ) ) <EOL> rad1 = Pow ( Pow ( <NUM_LIT:2> , S ( <NUM_LIT:1> ) / <NUM_LIT:3> ) - <NUM_LIT:1> , S ( <NUM_LIT:1> ) / <NUM_LIT:3> ) <EOL> rad2 = Pow ( S ( <NUM_LIT:1> ) / <NUM_LIT:9> , S ( <NUM_LIT:1> ) / <NUM_LIT:3> ) - Pow ( S ( <NUM_LIT:2> ) / <NUM_LIT:9> , S ( <NUM_LIT:1> ) / <NUM_LIT:3> ) + Pow ( S ( <NUM_LIT:4> ) / <NUM_LIT:9> , S ( <NUM_LIT:1> ) / <NUM_LIT:3> ) <EOL> s1 = FiniteSet ( rad1 ) <EOL> s2 = FiniteSet ( rad2 ) <EOL> assert s1 - s2 == S . EmptySet <EOL> items = [ <NUM_LIT:1> , <NUM_LIT:2> , S . Infinity , S ( '<STR_LIT>' ) , - <NUM_LIT> ] <EOL> fset = FiniteSet ( * items ) <EOL> assert all ( item in fset for item in items ) <EOL> assert all ( fset . contains ( item ) is S . true for item in items ) <EOL> assert Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:5> ) ) . contains ( <NUM_LIT:3> ) is S . true <EOL> assert Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , Interval ( <NUM_LIT:2> , <NUM_LIT:5> ) ) . contains ( <NUM_LIT:6> ) is S . false <EOL> assert Union ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , FiniteSet ( <NUM_LIT:2> , <NUM_LIT:5> ) ) . contains ( <NUM_LIT:3> ) is S . false <EOL> assert S . EmptySet . contains ( <NUM_LIT:1> ) is S . false <EOL> assert FiniteSet ( rootof ( x ** <NUM_LIT:3> + x - <NUM_LIT:1> , <NUM_LIT:0> ) ) . contains ( S . Infinity ) is S . false <EOL> assert rootof ( x ** <NUM_LIT:5> + x ** <NUM_LIT:3> + <NUM_LIT:1> , <NUM_LIT:0> ) in S . Reals <EOL> assert not rootof ( x ** <NUM_LIT:5> + x ** <NUM_LIT:3> + <NUM_LIT:1> , <NUM_LIT:1> ) in S . Reals <EOL> assert Union ( Interval ( <NUM_LIT:1> , <NUM_LIT:2> ) , Interval ( <NUM_LIT:3> , <NUM_LIT:4> ) ) . contains ( x ) == Or ( And ( x <= <NUM_LIT:2> , x >= <NUM_LIT:1> ) , And ( x <= <NUM_LIT:4> , x >= <NUM_LIT:3> ) ) <EOL> assert Intersection ( Interval ( <NUM_LIT:1> , x ) , Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) ) . contains ( y ) == And ( y <= <NUM_LIT:3> , y <= x , y >= <NUM_LIT:1> , y >= <NUM_LIT:2> ) <EOL> def test_interval_symbolic ( ) : <EOL> x = Symbol ( '<STR_LIT:x>' ) <EOL> e = Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> assert e . contains ( x ) == And ( <NUM_LIT:0> <= x , x <= <NUM_LIT:1> ) <EOL> raises ( TypeError , lambda : x in e ) <EOL> e = Interval ( <NUM_LIT:0> , <NUM_LIT:1> , True , True ) <EOL> assert e . contains ( x ) == And ( <NUM_LIT:0> < x , x < <NUM_LIT:1> ) <EOL> def test_union_contains ( ) : <EOL> x = Symbol ( '<STR_LIT:x>' ) <EOL> i1 = Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> i2 = Interval ( <NUM_LIT:2> , <NUM_LIT:3> ) <EOL> i3 = Union ( i1 , i2 ) <EOL> raises ( TypeError , lambda : x in i3 ) <EOL> e = i3 . contains ( x ) <EOL> assert e == Or ( And ( <NUM_LIT:0> <= x , x <= <NUM_LIT:1> ) , And ( <NUM_LIT:2> <= x , x <= <NUM_LIT:3> ) ) <EOL> assert e . subs ( x , - <NUM_LIT:0.5> ) is false <EOL> assert e . subs ( x , <NUM_LIT:0.5> ) is true <EOL> assert e . subs ( x , <NUM_LIT> ) is false <EOL> assert e . subs ( x , <NUM_LIT> ) is true <EOL> assert e . subs ( x , <NUM_LIT> ) is false <EOL> U = Interval ( <NUM_LIT:0> , <NUM_LIT:2> , True , True ) + Interval ( <NUM_LIT:10> , oo ) + FiniteSet ( - <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:5> , <NUM_LIT:6> ) <EOL> assert all ( el not in U for el in [ <NUM_LIT:0> , <NUM_LIT:4> , - oo ] ) <EOL> assert all ( el in U for el in [ <NUM_LIT:2> , <NUM_LIT:5> , <NUM_LIT:10> ] ) <EOL> def test_is_number ( ) : <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) . is_number is False <EOL> assert Set ( ) . is_number is False <EOL> def test_Interval_is_left_unbounded ( ) : <EOL> assert Interval ( <NUM_LIT:3> , <NUM_LIT:4> ) . is_left_unbounded is False <EOL> assert Interval ( - oo , <NUM_LIT:3> ) . is_left_unbounded is True <EOL> assert Interval ( Float ( \"<STR_LIT>\" ) , <NUM_LIT:3> ) . is_left_unbounded is True <EOL> def test_Interval_is_right_unbounded ( ) : <EOL> assert Interval ( <NUM_LIT:3> , <NUM_LIT:4> ) . is_right_unbounded is False <EOL> assert Interval ( <NUM_LIT:3> , oo ) . is_right_unbounded is True <EOL> assert Interval ( <NUM_LIT:3> , Float ( \"<STR_LIT>\" ) ) . is_right_unbounded is True <EOL> def test_Interval_as_relational ( ) : <EOL> x = Symbol ( '<STR_LIT:x>' ) <EOL> assert Interval ( - <NUM_LIT:1> , <NUM_LIT:2> , False , False ) . as_relational ( x ) == And ( Le ( - <NUM_LIT:1> , x ) , Le ( x , <NUM_LIT:2> ) ) <EOL> assert Interval ( - <NUM_LIT:1> , <NUM_LIT:2> , True , False ) . as_relational ( x ) == And ( Lt ( - <NUM_LIT:1> , x ) , Le ( x , <NUM_LIT:2> ) ) <EOL> assert Interval ( - <NUM_LIT:1> , <NUM_LIT:2> , False , True ) . as_relational ( x ) == And ( Le ( - <NUM_LIT:1> , x ) , Lt ( x , <NUM_LIT:2> ) ) <EOL> assert Interval ( - <NUM_LIT:1> , <NUM_LIT:2> , True , True ) . as_relational ( x ) == And ( Lt ( - <NUM_LIT:1> , x ) , Lt ( x , <NUM_LIT:2> ) ) <EOL> assert Interval ( - oo , <NUM_LIT:2> , right_open = False ) . as_relational ( x ) == And ( Lt ( - oo , x ) , Le ( x , <NUM_LIT:2> ) ) <EOL> assert Interval ( - oo , <NUM_LIT:2> , right_open = True ) . as_relational ( x ) == And ( Lt ( - oo , x ) , Lt ( x , <NUM_LIT:2> ) ) <EOL> assert Interval ( - <NUM_LIT:2> , oo , left_open = False ) . as_relational ( x ) == And ( Le ( - <NUM_LIT:2> , x ) , Lt ( x , oo ) ) <EOL> assert Interval ( - <NUM_LIT:2> , oo , left_open = True ) . as_relational ( x ) == And ( Lt ( - <NUM_LIT:2> , x ) , Lt ( x , oo ) ) <EOL> assert Interval ( - oo , oo ) . as_relational ( x ) == And ( Lt ( - oo , x ) , Lt ( x , oo ) ) <EOL> x = Symbol ( '<STR_LIT:x>' , real = True ) <EOL> y = Symbol ( '<STR_LIT:y>' , real = True ) <EOL> assert Interval ( x , y ) . as_relational ( x ) == ( x <= y ) <EOL> assert Interval ( y , x ) . as_relational ( x ) == ( y <= x ) <EOL> def test_Finite_as_relational ( ) : <EOL> x = Symbol ( '<STR_LIT:x>' ) <EOL> y = Symbol ( '<STR_LIT:y>' ) <EOL> assert FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> ) . as_relational ( x ) == Or ( Eq ( x , <NUM_LIT:1> ) , Eq ( x , <NUM_LIT:2> ) ) <EOL> assert FiniteSet ( y , - <NUM_LIT:5> ) . as_relational ( x ) == Or ( Eq ( x , y ) , Eq ( x , - <NUM_LIT:5> ) ) <EOL> def test_Union_as_relational ( ) : <EOL> x = Symbol ( '<STR_LIT:x>' ) <EOL> assert ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) + FiniteSet ( <NUM_LIT:2> ) ) . as_relational ( x ) == Or ( And ( Le ( <NUM_LIT:0> , x ) , Le ( x , <NUM_LIT:1> ) ) , Eq ( x , <NUM_LIT:2> ) ) <EOL> assert ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> , True , True ) + FiniteSet ( <NUM_LIT:1> ) ) . as_relational ( x ) == And ( Lt ( <NUM_LIT:0> , x ) , Le ( x , <NUM_LIT:1> ) ) <EOL> def test_Intersection_as_relational ( ) : <EOL> x = Symbol ( '<STR_LIT:x>' ) <EOL> assert ( Intersection ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) , FiniteSet ( <NUM_LIT:2> ) , <EOL> evaluate = False ) . as_relational ( x ) <EOL> == And ( And ( Le ( <NUM_LIT:0> , x ) , Le ( x , <NUM_LIT:1> ) ) , Eq ( x , <NUM_LIT:2> ) ) ) <EOL> def test_EmptySet ( ) : <EOL> assert S . EmptySet . as_relational ( Symbol ( '<STR_LIT:x>' ) ) is S . false <EOL> assert S . EmptySet . intersect ( S . UniversalSet ) == S . EmptySet <EOL> assert S . EmptySet . boundary == S . EmptySet <EOL> def test_finite_basic ( ) : <EOL> x = Symbol ( '<STR_LIT:x>' ) <EOL> A = FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) <EOL> B = FiniteSet ( <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> ) <EOL> AorB = Union ( A , B ) <EOL> AandB = A . intersect ( B ) <EOL> assert A . is_subset ( AorB ) and B . is_subset ( AorB ) <EOL> assert AandB . is_subset ( A ) <EOL> assert AandB == FiniteSet ( <NUM_LIT:3> ) <EOL> assert A . inf == <NUM_LIT:1> and A . sup == <NUM_LIT:3> <EOL> assert AorB . inf == <NUM_LIT:1> and AorB . sup == <NUM_LIT:5> <EOL> assert FiniteSet ( x , <NUM_LIT:1> , <NUM_LIT:5> ) . sup == Max ( x , <NUM_LIT:5> ) <EOL> assert FiniteSet ( x , <NUM_LIT:1> , <NUM_LIT:5> ) . inf == Min ( x , <NUM_LIT:1> ) <EOL> assert FiniteSet ( S . EmptySet ) != S . EmptySet <EOL> assert FiniteSet ( FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) != FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) <EOL> assert FiniteSet ( ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) != FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) <EOL> s = FiniteSet ( ( <NUM_LIT:1> , <NUM_LIT:2> ) , Float , A , - <NUM_LIT:5> , x , '<STR_LIT>' , x ** <NUM_LIT:2> , Interval ) <EOL> assert ( A > B ) is False <EOL> assert ( A >= B ) is False <EOL> assert ( A < B ) is False <EOL> assert ( A <= B ) is False <EOL> assert AorB > A and AorB > B <EOL> assert AorB >= A and AorB >= B <EOL> assert A >= A and A <= A <EOL> assert A >= AandB and B >= AandB <EOL> assert A > AandB and B > AandB <EOL> def test_powerset ( ) : <EOL> A = FiniteSet ( ) <EOL> pset = A . powerset ( ) <EOL> assert len ( pset ) == <NUM_LIT:1> <EOL> assert pset == FiniteSet ( S . EmptySet ) <EOL> A = FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> pset = A . powerset ( ) <EOL> assert len ( pset ) == <NUM_LIT:2> ** len ( A ) <EOL> assert pset == FiniteSet ( FiniteSet ( ) , FiniteSet ( <NUM_LIT:1> ) , <EOL> FiniteSet ( <NUM_LIT:2> ) , A ) <EOL> I = Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> raises ( NotImplementedError , I . powerset ) <EOL> def test_product_basic ( ) : <EOL> H , T = '<STR_LIT:H>' , '<STR_LIT:T>' <EOL> unit_line = Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> d6 = FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> , <NUM_LIT:6> ) <EOL> d4 = FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) <EOL> coin = FiniteSet ( H , T ) <EOL> square = unit_line * unit_line <EOL> assert ( <NUM_LIT:0> , <NUM_LIT:0> ) in square <EOL> assert <NUM_LIT:0> not in square <EOL> assert ( H , T ) in coin ** <NUM_LIT:2> <EOL> assert ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) in square * unit_line <EOL> assert ( H , <NUM_LIT:3> , <NUM_LIT:3> ) in coin * d6 * d6 <EOL> HH , TT = sympify ( H ) , sympify ( T ) <EOL> assert set ( coin ** <NUM_LIT:2> ) == set ( ( ( HH , HH ) , ( HH , TT ) , ( TT , HH ) , ( TT , TT ) ) ) <EOL> assert ( d4 * d4 ) . is_subset ( d6 * d6 ) <EOL> assert square . complement ( Interval ( - oo , oo ) * Interval ( - oo , oo ) ) == Union ( <EOL> ( Interval ( - oo , <NUM_LIT:0> , True , True ) + <EOL> Interval ( <NUM_LIT:1> , oo , True , True ) ) * Interval ( - oo , oo ) , <EOL> Interval ( - oo , oo ) * ( Interval ( - oo , <NUM_LIT:0> , True , True ) + <EOL> Interval ( <NUM_LIT:1> , oo , True , True ) ) ) <EOL> assert ( Interval ( - <NUM_LIT:5> , <NUM_LIT:5> ) ** <NUM_LIT:3> ) . is_subset ( Interval ( - <NUM_LIT:10> , <NUM_LIT:10> ) ** <NUM_LIT:3> ) <EOL> assert not ( Interval ( - <NUM_LIT:10> , <NUM_LIT:10> ) ** <NUM_LIT:3> ) . is_subset ( Interval ( - <NUM_LIT:5> , <NUM_LIT:5> ) ** <NUM_LIT:3> ) <EOL> assert not ( Interval ( - <NUM_LIT:5> , <NUM_LIT:5> ) ** <NUM_LIT:2> ) . is_subset ( Interval ( - <NUM_LIT:10> , <NUM_LIT:10> ) ** <NUM_LIT:3> ) <EOL> assert ( Interval ( <NUM_LIT> , <NUM_LIT> ) * FiniteSet ( <NUM_LIT> ) ) . is_subset ( square ) <EOL> assert len ( coin * coin * coin ) == <NUM_LIT:8> <EOL> assert len ( S . EmptySet * S . EmptySet ) == <NUM_LIT:0> <EOL> assert len ( S . EmptySet * coin ) == <NUM_LIT:0> <EOL> raises ( TypeError , lambda : len ( coin * Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) ) ) <EOL> def test_real ( ) : <EOL> x = Symbol ( '<STR_LIT:x>' , real = True , finite = True ) <EOL> I = Interval ( <NUM_LIT:0> , <NUM_LIT:5> ) <EOL> J = Interval ( <NUM_LIT:10> , <NUM_LIT:20> ) <EOL> A = FiniteSet ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:30> , x , S . Pi ) <EOL> B = FiniteSet ( - <NUM_LIT:4> , <NUM_LIT:0> ) <EOL> C = FiniteSet ( <NUM_LIT:100> ) <EOL> D = FiniteSet ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> assert all ( s . is_subset ( S . Reals ) for s in [ I , J , A , B , C ] ) <EOL> assert not D . is_subset ( S . Reals ) <EOL> assert all ( ( a + b ) . is_subset ( S . Reals ) for a in [ I , J , A , B , C ] for b in [ I , J , A , B , C ] ) <EOL> assert not any ( ( a + D ) . is_subset ( S . Reals ) for a in [ I , J , A , B , C , D ] ) <EOL> assert not ( I + A + D ) . is_subset ( S . Reals ) <EOL> def test_supinf ( ) : <EOL> x = Symbol ( '<STR_LIT:x>' , real = True ) <EOL> y = Symbol ( '<STR_LIT:y>' , real = True ) <EOL> assert ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) + FiniteSet ( <NUM_LIT:2> ) ) . sup == <NUM_LIT:2> <EOL> assert ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) + FiniteSet ( <NUM_LIT:2> ) ) . inf == <NUM_LIT:0> <EOL> assert ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) + FiniteSet ( x ) ) . sup == Max ( <NUM_LIT:1> , x ) <EOL> assert ( Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) + FiniteSet ( x ) ) . inf == Min ( <NUM_LIT:0> , x ) <EOL> assert FiniteSet ( <NUM_LIT:5> , <NUM_LIT:1> , x ) . sup == Max ( <NUM_LIT:5> , x ) <EOL> assert FiniteSet ( <NUM_LIT:5> , <NUM_LIT:1> , x ) . inf == Min ( <NUM_LIT:1> , x ) <EOL> assert FiniteSet ( <NUM_LIT:5> , <NUM_LIT:1> , x , y ) . sup == Max ( <NUM_LIT:5> , x , y ) <EOL> assert FiniteSet ( <NUM_LIT:5> , <NUM_LIT:1> , x , y ) . inf == Min ( <NUM_LIT:1> , x , y ) <EOL> assert FiniteSet ( <NUM_LIT:5> , <NUM_LIT:1> , x , y , S . Infinity , S . NegativeInfinity ) . sup == S . Infinity <EOL> assert FiniteSet ( <NUM_LIT:5> , <NUM_LIT:1> , x , y , S . Infinity , S . NegativeInfinity ) . inf == S . NegativeInfinity <EOL> assert FiniteSet ( '<STR_LIT>' , '<STR_LIT>' ) . sup == Max ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def test_universalset ( ) : <EOL> U = S . UniversalSet <EOL> x = Symbol ( '<STR_LIT:x>' ) <EOL> assert U . as_relational ( x ) is S . true <EOL> assert U . union ( Interval ( <NUM_LIT:2> , <NUM_LIT:4> ) ) == U <EOL> assert U . intersect ( Interval ( <NUM_LIT:2> , <NUM_LIT:4> ) ) == Interval ( <NUM_LIT:2> , <NUM_LIT:4> ) <EOL> assert U . measure == S . Infinity <EOL> assert U . boundary == S . EmptySet <EOL> assert U . contains ( <NUM_LIT:0> ) is S . true <EOL> def test_Union_of_ProductSets_shares ( ) : <EOL> line = Interval ( <NUM_LIT:0> , <NUM_LIT:2> ) <EOL> points = FiniteSet ( <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> assert Union ( line * line , line * points ) == line * line <EOL> def test_Interval_free_symbols ( ) : <EOL> assert Interval ( <NUM_LIT:0> , <NUM_LIT:1> ) . free_symbols == set ( ) <EOL> x = Symbol ( '<STR_LIT:x>' , real = True ) <EOL> assert Interval ( <NUM_LIT:0> , x ) . free_symbols == { x } <EOL>", "answer": "def test_image_interval ( ) :"}, {"prompt": "<s> import os <EOL> import shutil <EOL> import sys <EOL> import argparse <EOL> import time <EOL> import re <EOL> import random <EOL> from decimal import Decimal <EOL> from operator import itemgetter <EOL> from PIL import Image , ImageDraw , ImageFont <EOL> sys . path . append ( os . environ . get ( '<STR_LIT>' ) ) <EOL> CAFFE_HOME = os . environ . get ( \"<STR_LIT>\" ) <EOL> sys . path . append ( CAFFE_HOME ) <EOL> os . environ [ '<STR_LIT>' ] = '<STR_LIT:1>' <EOL> from selective_search import * <EOL> import features <EOL> from skimage . transform import resize <EOL> import caffe <EOL> import numpy as np <EOL> import simplejson as json <EOL> def parse_command_line ( ) : <EOL> parser = argparse . ArgumentParser ( <EOL> description = \"\"\"<STR_LIT>\"\"\" ) <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" <EOL> ) <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> default = ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT:3> ) <EOL> ) <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> type = int , <EOL> help = \"<STR_LIT>\" , <EOL> default = <NUM_LIT:16> <EOL> ) <EOL> parser . add_argument ( <EOL> \"<STR_LIT:-c>\" , <EOL> \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" <EOL> ) <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" <EOL> ) <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" <EOL> ) <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> default = \"<STR_LIT>\" <EOL> ) <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> type = int , <EOL> default = <NUM_LIT:3> <EOL> ) <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> type = float , <EOL> default = <NUM_LIT> <EOL> ) <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> action = \"<STR_LIT:store_true>\" , <EOL> default = True <EOL> ) <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> help = \"<STR_LIT>\" , <EOL> type = int , <EOL> default = <NUM_LIT:100> <EOL> ) <EOL> parser . add_argument ( <EOL> \"<STR_LIT>\" , <EOL> help = \"\"\"<STR_LIT>\"\"\" , <EOL> type = int , <EOL> default = None <EOL> ) <EOL> args = parser . parse_args ( ) <EOL> if os . environ . get ( \"<STR_LIT>\" ) == None : <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( \"<STR_LIT>\" ) <EOL> exit ( <NUM_LIT:1> ) <EOL> if os . environ . get ( \"<STR_LIT>\" ) == None : <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( \"<STR_LIT>\" ) <EOL> exit ( <NUM_LIT:1> ) <EOL> return args <EOL> def gen_regions ( image , dims , pad , ks ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print \"<STR_LIT>\" <EOL> assert ( len ( dims ) == <NUM_LIT:3> ) <EOL> regions = selective_search ( image , ks = [ ks ] , feature_masks = [ features . SimilarityMask ( <EOL> size = <NUM_LIT:1> , <EOL> color = <NUM_LIT:1> , <EOL> texture = <NUM_LIT:1> , <EOL> fill = <NUM_LIT:1> , <EOL> ) ] ) <EOL> crops = [ ] <EOL> for conf , ( y0 , x0 , y1 , x1 ) in regions : <EOL> if x0 - pad >= <NUM_LIT:0> : <EOL> x0 = x0 - pad <EOL> if y0 - pad >= <NUM_LIT:0> : <EOL> y0 = y0 - pad <EOL> if x1 + pad <= dims [ <NUM_LIT:0> ] : <EOL> x1 = x1 + pad <EOL> if y1 + pad <= dims [ <NUM_LIT:0> ] : <EOL> y1 = y1 + pad <EOL> region = image [ y0 : y1 , x0 : x1 , : ] <EOL> candidate = resize ( region , dims ) <EOL> crops . append ( ( conf , candidate , region , ( x0 , y0 , x1 , y1 ) ) ) <EOL> print \"<STR_LIT>\" . format ( len ( crops ) ) <EOL> return crops <EOL> def get_region_filename ( idx ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return \"<STR_LIT>\" % idx <EOL> def dump_regions ( crops ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> shutil . rmtree ( \"<STR_LIT>\" , ignore_errors = True ) <EOL> os . makedirs ( \"<STR_LIT>\" ) <EOL> for idx , img in enumerate ( crops ) : <EOL> fname = get_region_filename ( idx ) <EOL> skimage . io . imsave ( fname , img [ <NUM_LIT:2> ] ) <EOL> print \"<STR_LIT>\" <EOL> def classify ( images , config , weights ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print ( \"<STR_LIT>\" % len ( images ) ) <EOL> assert ( os . path . isfile ( config ) and os . path . isfile ( weights ) ) <EOL> channel_swap = [ <NUM_LIT:2> , <NUM_LIT:1> , <NUM_LIT:0> ] <EOL> classifier = caffe . Classifier ( config , <EOL> weights , <EOL> raw_scale = <NUM_LIT:255> , <EOL> channel_swap = channel_swap , <EOL> ) <EOL> return classifier . predict ( images , oversample = False ) <EOL> def load_classes ( class_file ) : <EOL> classes = { } <EOL> if os . path . isfile ( class_file ) : <EOL> f = open ( class_file , '<STR_LIT:r>' ) <EOL> for line in f : <EOL> key = int ( line . split ( \"<STR_LIT:U+0020>\" ) [ <NUM_LIT:0> ] ) <EOL> value = line . split ( \"<STR_LIT:U+0020>\" , <NUM_LIT:1> ) [ <NUM_LIT:1> ] . strip ( '<STR_LIT:\\n>' ) <EOL> classes [ key ] = value <EOL> return classes <EOL> def sort_predictions ( classes , predictions , bboxes ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> results = [ ] <EOL> for idx , pred in enumerate ( predictions ) : <EOL>", "answer": "results . append ( {"}, {"prompt": "<s> import urllib2 <EOL> import sys <EOL> import cv2 . cv as cv <EOL> import numpy <EOL> def srgb2lin ( x ) : <EOL> a = <NUM_LIT> <EOL> return numpy . where ( x <= <NUM_LIT> , <EOL> x * ( <NUM_LIT:1.0> / <NUM_LIT> ) , <EOL> numpy . power ( ( x + a ) * ( <NUM_LIT:1.0> / ( <NUM_LIT:1> + a ) ) , <NUM_LIT> ) ) <EOL> def lin2srgb ( x ) : <EOL> a = <NUM_LIT> <EOL> return numpy . where ( x <= <NUM_LIT> , <EOL> x * <NUM_LIT> , <EOL> ( <NUM_LIT:1> + a ) * numpy . power ( x , <NUM_LIT:1> / <NUM_LIT> ) - a ) <EOL> if __name__ == \"<STR_LIT:__main__>\" : <EOL> if len ( sys . argv ) > <NUM_LIT:1> : <EOL> img0 = cv . LoadImageM ( sys . argv [ <NUM_LIT:1> ] , cv . CV_LOAD_IMAGE_COLOR ) <EOL> else : <EOL> url = '<STR_LIT>' <EOL> filedata = urllib2 . urlopen ( url ) . read ( ) <EOL> imagefiledata = cv . CreateMatHeader ( <NUM_LIT:1> , len ( filedata ) , cv . CV_8UC1 ) <EOL> cv . SetData ( imagefiledata , filedata , len ( filedata ) ) <EOL> img0 = cv . DecodeImageM ( imagefiledata , cv . CV_LOAD_IMAGE_COLOR ) <EOL> cv . NamedWindow ( \"<STR_LIT>\" , <NUM_LIT:1> ) <EOL> cv . ShowImage ( \"<STR_LIT>\" , img0 ) <EOL> n = numpy . asarray ( img0 ) / <NUM_LIT> <EOL>", "answer": "cv . NamedWindow ( \"<STR_LIT>\" )"}, {"prompt": "<s> from __future__ import division , print_function , unicode_literals <EOL> event_loop = None <EOL>", "answer": "class EventLoop ( object ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from googleads import dfp <EOL> ORDER_ID = '<STR_LIT>' <EOL> def main ( client , order_id ) : <EOL> line_item_service = client . GetService ( '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> values = [ { <EOL> '<STR_LIT:key>' : '<STR_LIT>' , <EOL> '<STR_LIT:value>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:value>' : '<STR_LIT>' <EOL> } <EOL> } , { <EOL> '<STR_LIT:key>' : '<STR_LIT>' , <EOL> '<STR_LIT:value>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:value>' : order_id <EOL> } <EOL> } ] <EOL> query = '<STR_LIT>' <EOL> statement = dfp . FilterStatement ( query , values , <NUM_LIT> ) <EOL> response = line_item_service . getLineItemsByStatement ( <EOL> statement . ToStatement ( ) ) <EOL>", "answer": "if '<STR_LIT>' in response :"}, {"prompt": "<s> import gevent <EOL> import subprocess <EOL> from ajenti . api import plugin <EOL> from ajenti . plugins . dashboard . api import ConfigurableWidget <EOL> from ajenti . users import PermissionProvider , restrict <EOL> from ajenti . ui import on <EOL> @ plugin <EOL> class ScriptWidget ( ConfigurableWidget ) : <EOL> name = _ ( '<STR_LIT>' ) <EOL> icon = '<STR_LIT>' <EOL> def on_prepare ( self ) : <EOL> self . append ( self . ui . inflate ( '<STR_LIT>' ) ) <EOL> def on_start ( self ) : <EOL> self . command = self . config [ '<STR_LIT>' ] <EOL> if not self . command : <EOL> return <EOL> self . find ( '<STR_LIT:name>' ) . text = self . config [ '<STR_LIT:title>' ] <EOL> def create_config ( self ) : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT:title>' : '<STR_LIT>' , '<STR_LIT>' : False } <EOL> def on_config_start ( self ) : <EOL> self . dialog . find ( '<STR_LIT>' ) . value = self . config [ '<STR_LIT>' ] <EOL> self . dialog . find ( '<STR_LIT:title>' ) . value = self . config [ '<STR_LIT:title>' ] <EOL> self . dialog . find ( '<STR_LIT>' ) . value = self . config [ '<STR_LIT>' ] <EOL> @ on ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def on_edit ( self ) : <EOL> self . begin_configuration ( ) <EOL> def on_config_save ( self ) : <EOL> self . config [ '<STR_LIT>' ] = self . dialog . find ( '<STR_LIT>' ) . value <EOL> self . config [ '<STR_LIT:title>' ] = self . dialog . find ( '<STR_LIT:title>' ) . value <EOL> self . config [ '<STR_LIT>' ] = self . dialog . find ( '<STR_LIT>' ) . value <EOL> @ on ( '<STR_LIT:start>' , '<STR_LIT>' ) <EOL> @ restrict ( '<STR_LIT>' ) <EOL>", "answer": "def on_s_start ( self ) :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Tangible ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import functools <EOL> import operator <EOL> from staticconf import errors <EOL> import six <EOL> class UndefToken ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __repr__ ( self ) : <EOL>", "answer": "return \"<STR_LIT>\""}, {"prompt": "<s> import dedupe <EOL>", "answer": "import unittest"}, {"prompt": "<s> __version__ = '<STR_LIT>' <EOL>", "answer": "__author__ = '<STR_LIT>' "}, {"prompt": "<s> import os , sys , json , distutils . core , shutil , glob , zipfile <EOL> from subprocess import call <EOL> config = json . loads ( open ( os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT>' ) ) . read ( ) ) <EOL> sourcesdir = config [ '<STR_LIT>' ] <EOL> buildir = os . path . join ( sourcesdir , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def copyext ( targetdir , extension ) : <EOL> files = glob . iglob ( os . path . join ( targetdir , '<STR_LIT>' + extension ) ) <EOL> for file in files : <EOL> if os . path . isfile ( file ) : <EOL> shutil . copy2 ( file , buildir ) <EOL> def zipdir ( path , zip ) : <EOL> for root , dirs , files in os . walk ( path ) : <EOL> for file in files : <EOL> filepath = os . path . join ( root , file ) <EOL> zip . write ( filepath , os . path . basename ( filepath ) ) <EOL> def main ( argv ) : <EOL> shutil . rmtree ( buildir , ignore_errors = True ) <EOL> os . makedirs ( buildir ) <EOL> for repo in config [ '<STR_LIT>' ] : <EOL> print '<STR_LIT>' , repo [ '<STR_LIT:name>' ] <EOL> targetdir = os . path . join ( sourcesdir , repo [ '<STR_LIT:name>' ] , '<STR_LIT:target>' ) <EOL> copyext ( targetdir , '<STR_LIT>' ) <EOL> copyext ( targetdir , '<STR_LIT>' ) <EOL>", "answer": "copyext ( os . path . join ( targetdir , '<STR_LIT>' , '<STR_LIT>' ) , '<STR_LIT>' )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os . path as op <EOL> import logging <EOL> import time <EOL> from pbtools . pbtranscript . PBTranscriptOptions import add_sge_arguments , add_fofn_arguments <EOL> from pbtools . pbtranscript . Utils import realpath , mkdir , real_upath , ln <EOL> from pbtools . pbtranscript . ice . IceFiles import IceFiles <EOL> from pbtools . pbtranscript . ice . IceUtils import combine_nfl_pickles <EOL> class IceAllPartials ( IceFiles ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> desc = \"<STR_LIT>\" + \"<STR_LIT>\" <EOL> prog = \"<STR_LIT>\" <EOL> def __init__ ( self , root_dir , fasta_filenames , ref_fasta , <EOL> out_pickle , sge_opts , sa_file = None , ccs_fofn = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . prog_name = \"<STR_LIT>\" <EOL> IceFiles . __init__ ( self , prog_name = self . prog_name , root_dir = root_dir ) <EOL> self . add_log ( \"<STR_LIT>\" . format ( ccs_fofn ) , level = logging . INFO ) <EOL> self . fasta_filenames , self . ref_fasta , self . ccs_fofn , self . sa_file = self . _validate_inputs ( fasta_filenames = fasta_filenames , <EOL> ref_fasta = ref_fasta , <EOL> ccs_fofn = ccs_fofn , <EOL> sa_file = sa_file ) <EOL> self . out_pickle = out_pickle <EOL> self . sge_opts = sge_opts <EOL> self . add_log ( \"<STR_LIT>\" + self . nfl_dir ) <EOL> mkdir ( self . nfl_dir ) <EOL> self . add_log ( \"<STR_LIT>\" + <EOL> \"<STR_LIT:U+002CU+0020>\" . join ( self . fasta_filenames ) ) <EOL> self . add_log ( \"<STR_LIT>\" + <EOL> \"<STR_LIT:U+002CU+0020>\" . join ( self . pickle_filenames ) ) <EOL> self . add_log ( \"<STR_LIT>\" + self . out_pickle ) <EOL> def _validate_inputs ( self , fasta_filenames , ref_fasta , ccs_fofn , sa_file ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for f in fasta_filenames : <EOL> if not op . exists ( f ) : <EOL> raise IOError ( \"<STR_LIT>\" . format ( f = f ) ) <EOL> if ref_fasta is None or not op . exists ( ref_fasta ) : <EOL> raise IOError ( \"<STR_LIT>\" . format ( r = ref_fasta ) ) <EOL> if ccs_fofn is not None and not op . exists ( ccs_fofn ) : <EOL> raise IOError ( \"<STR_LIT>\" . format ( <EOL> ccs_fofn = ccs_fofn ) ) <EOL> if sa_file is not None and not op . exists ( sa_file ) : <EOL> raise IOError ( \"<STR_LIT>\" . format ( s = sa_file ) ) <EOL> return ( [ realpath ( f ) for f in fasta_filenames ] , <EOL> realpath ( ref_fasta ) , <EOL> realpath ( ccs_fofn ) , <EOL> realpath ( sa_file ) if sa_file is not None else None ) <EOL> def cmd_str ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _cmd_str ( fasta_filenames = self . fasta_filenames , <EOL> ref_fasta = self . ref_fasta , <EOL> out_pickle = self . out_pickle , <EOL> root_dir = self . root_dir , <EOL> ccs_fofn = self . ccs_fofn , <EOL> sa_file = self . sa_file , <EOL> sge_opts = self . sge_opts ) <EOL> def _cmd_str ( self , fasta_filenames , ref_fasta , out_pickle , <EOL> root_dir , ccs_fofn , sa_file , sge_opts ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cmd = self . prog + \"<STR_LIT>\" . format ( fns = \"<STR_LIT:U+002C>\" . join ( fasta_filenames ) ) + \"<STR_LIT>\" . format ( ref = ref_fasta ) + \"<STR_LIT>\" . format ( out = out_pickle ) <EOL> if root_dir is not None : <EOL> cmd += \"<STR_LIT>\" . format ( d = root_dir ) <EOL> if ccs_fofn is not None : <EOL> cmd += \"<STR_LIT>\" . format ( f = ccs_fofn ) <EOL> if sa_file is not None : <EOL> cmd += \"<STR_LIT>\" . format ( sa = sa_file ) <EOL> cmd += sge_opts . cmd_str ( show_blasr_nproc = True ) <EOL> return cmd <EOL> @ property <EOL> def pickle_filenames ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return [ op . join ( self . nfl_dir , op . basename ( f ) + \"<STR_LIT>\" ) <EOL> for f in self . fasta_filenames ] <EOL> @ property <EOL> def done_filenames ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return [ op . join ( self . nfl_dir , op . basename ( f ) + \"<STR_LIT>\" ) <EOL> for f in self . pickle_filenames ] <EOL> @ property <EOL> def script_filenames ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return [ op . join ( self . script_dir , op . basename ( f ) + \"<STR_LIT>\" ) <EOL> for f in self . fasta_filenames ] <EOL> def createPickles ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . add_log ( \"<STR_LIT>\" ) <EOL> self . add_log ( \"<STR_LIT>\" , level = logging . INFO ) <EOL> for idx , fa in enumerate ( self . fasta_filenames ) : <EOL> cmd = \"<STR_LIT>\" . format ( i = real_upath ( fa ) ) + \"<STR_LIT>\" . format ( r = real_upath ( self . ref_fasta ) ) + \"<STR_LIT>\" . format ( o = real_upath ( self . pickle_filenames [ idx ] ) ) + \"<STR_LIT>\" . format ( n = <NUM_LIT:4> ) + \"<STR_LIT>\" . format ( d = real_upath ( self . done_filenames [ idx ] ) ) <EOL> if self . ccs_fofn is not None : <EOL> cmd += \"<STR_LIT>\" . format ( f = real_upath ( self . ccs_fofn ) ) <EOL> if self . sa_file is not None : <EOL> cmd += \"<STR_LIT>\" . format ( sa = real_upath ( self . sa_file ) ) <EOL> self . add_log ( \"<STR_LIT>\" . <EOL> format ( fsh = self . script_filenames [ idx ] ) ) <EOL> self . add_log ( \"<STR_LIT>\" . format ( cmd ) ) <EOL> with open ( self . script_filenames [ idx ] , '<STR_LIT:w>' ) as fsh : <EOL> fsh . write ( cmd + \"<STR_LIT:\\n>\" ) <EOL> partial_log_fn = op . join ( self . log_dir , <EOL> '<STR_LIT>' . format ( idx = idx ) ) <EOL> elog = partial_log_fn + \"<STR_LIT>\" <EOL> olog = partial_log_fn + \"<STR_LIT>\" <EOL> jid = \"<STR_LIT>\" . format ( <EOL> unique_id = self . sge_opts . unique_id , <EOL> name = op . basename ( fa ) ) <EOL> qsub_cmd = \"<STR_LIT>\" <EOL> if self . sge_opts . sge_queue is not None : <EOL> qsub_cmd += \"<STR_LIT>\" + self . sge_opts . sge_queue <EOL> qsub_cmd += \"<STR_LIT>\" . format ( env = self . sge_opts . sge_env_name , n = <NUM_LIT:4> ) + \"<STR_LIT>\" + \"<STR_LIT>\" . format ( elog = real_upath ( elog ) ) + \"<STR_LIT>\" . format ( olog = real_upath ( olog ) ) + \"<STR_LIT>\" . format ( jid = jid ) + \"<STR_LIT>\" . format ( sh = real_upath ( self . script_filenames [ idx ] ) ) <EOL> self . add_log ( \"<STR_LIT>\" . format ( f = fa ) ) <EOL> if self . sge_opts . use_sge is True : <EOL> self . qsub_cmd_and_log ( qsub_cmd ) <EOL> else : <EOL> cmd += \"<STR_LIT>\" . format ( olog = real_upath ( olog ) , <EOL> elog = real_upath ( elog ) ) <EOL> self . run_cmd_and_log ( cmd = cmd , olog = olog , elog = elog ) <EOL> def waitForPickles ( self , pickle_filenames , done_filenames ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . add_log ( \"<STR_LIT>\" . <EOL> format ( ps = \"<STR_LIT:U+002CU+0020>\" . join ( pickle_filenames ) ) , <EOL> level = logging . INFO ) <EOL> stop = False <EOL> sleep_time = <NUM_LIT:10> <EOL> while stop is not True : <EOL> stop = all ( op . exists ( p ) for p in pickle_filenames ) and all ( op . exists ( d ) for d in done_filenames ) <EOL> sleep_time = min ( <NUM_LIT> , sleep_time + <NUM_LIT:10> ) <EOL> time . sleep ( sleep_time ) <EOL> self . add_log ( \"<STR_LIT>\" . <EOL> format ( ps = \"<STR_LIT:U+002CU+0020>\" . join ( [ p for p in pickle_filenames <EOL> if op . exists ( p ) ] ) ) ) <EOL> def combinePickles ( self , pickle_filenames , out_pickle ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> combine_nfl_pickles ( pickle_filenames , out_pickle ) <EOL> def run ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . createPickles ( ) <EOL> self . waitForPickles ( pickle_filenames = self . pickle_filenames , <EOL> done_filenames = self . done_filenames ) <EOL> self . combinePickles ( pickle_filenames = self . pickle_filenames , <EOL> out_pickle = self . nfl_all_pickle_fn ) <EOL> ln ( self . nfl_all_pickle_fn , self . out_pickle ) <EOL> self . close_log ( ) <EOL> def add_ice_all_partials_arguments ( parser ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import re <EOL> import os <EOL> import tempfile <EOL> import string <EOL> __all__ = [ \"<STR_LIT>\" ] <EOL> FILEIN_FILEOUT = '<STR_LIT>' <EOL> STDIN_FILEOUT = '<STR_LIT>' <EOL> FILEIN_STDOUT = '<STR_LIT>' <EOL> STDIN_STDOUT = '<STR_LIT>' <EOL> SOURCE = '<STR_LIT>' <EOL> SINK = '<STR_LIT>' <EOL> stepkinds = [ FILEIN_FILEOUT , STDIN_FILEOUT , FILEIN_STDOUT , STDIN_STDOUT , SOURCE , SINK ] <EOL> class Template : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . debugging = <NUM_LIT:0> <EOL> self . reset ( ) <EOL> def __repr__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return '<STR_LIT>' % ( self . steps , ) <EOL> def reset ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . steps = [ ] <EOL> def clone ( self ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from functools import partial <EOL> from sklearn_pmml import pmml <EOL> from sklearn_pmml . convert . features import Feature , FeatureType <EOL> from pyxb . utils . domutils import BindingDOMSupport as bds <EOL> import numpy as np <EOL> estimator_to_converter = { } <EOL> def find_converter ( estimator ) : <EOL> return estimator_to_converter . get ( estimator . __class__ , None ) <EOL> def pmml_row ( ** columns ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> r = pmml . row ( ) <EOL> for name , value in columns . items ( ) : <EOL> el = bds ( ) . createChildElement ( name ) <EOL> bds ( ) . appendTextChild ( value , el ) <EOL> r . append ( el ) <EOL> return r <EOL> class DerivedFeatureTransformations ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> TRANSFORMATION = '<STR_LIT>' <EOL> FUNCTION = '<STR_LIT>' <EOL> @ staticmethod <EOL> def field_in_list ( field , values ) : <EOL> mv = pmml . MapValues ( outputColumn = '<STR_LIT>' , defaultValue = <NUM_LIT:0> ) <EOL> mv . append ( pmml . FieldColumnPair ( field = field , column = '<STR_LIT:input>' ) ) <EOL> it = pmml . InlineTable ( ) <EOL> for v in values : <EOL> it . append ( pmml_row ( input = v , output = <NUM_LIT:1> ) ) <EOL> mv . append ( it ) <EOL> return { <EOL> DerivedFeatureTransformations . TRANSFORMATION : mv , <EOL> DerivedFeatureTransformations . FUNCTION : lambda df : reduce ( np . logical_or , [ df [ field ] == _ for _ in values ] ) <EOL> } <EOL> @ staticmethod <EOL> def field_not_in_list ( field , values ) : <EOL> mv = pmml . MapValues ( outputColumn = '<STR_LIT>' , defaultValue = <NUM_LIT:1> ) <EOL> mv . append ( pmml . FieldColumnPair ( field = field , column = '<STR_LIT:input>' ) ) <EOL> it = pmml . InlineTable ( ) <EOL> for v in values : <EOL> it . append ( pmml_row ( input = v , output = <NUM_LIT:0> ) ) <EOL> mv . append ( it ) <EOL> return { <EOL> DerivedFeatureTransformations . TRANSFORMATION : mv , <EOL> DerivedFeatureTransformations . FUNCTION : lambda df : reduce ( np . logical_and , [ df [ field ] != _ for _ in values ] ) <EOL> } <EOL> @ staticmethod <EOL> def map_values ( field , value_map , default_value ) : <EOL> mv = pmml . MapValues ( outputColumn = '<STR_LIT>' , default_value = default_value ) <EOL> mv . append ( pmml . FieldColumnPair ( field = field , column = '<STR_LIT:input>' ) ) <EOL> it = pmml . InlineTable ( ) <EOL> for k , v in value_map . items ( ) : <EOL> it . append ( pmml_row ( input = k , output = v ) ) <EOL> mv . append ( it ) <EOL> return { <EOL> DerivedFeatureTransformations . TRANSFORMATION : mv , <EOL> DerivedFeatureTransformations . FUNCTION : <EOL> lambda df : np . vectorize ( partial ( value_map . get , default_value ) ) ( df [ field ] ) <EOL> } <EOL> @ staticmethod <EOL> def arithmetics ( tree ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def basic_function ( func_name , args ) : <EOL> expr = pmml . Apply ( function = func_name ) <EOL> for a in args : <EOL> expr . append ( a ) <EOL> return expr <EOL> def mod_function ( args ) : <EOL> expr = pmml . Apply ( function = '<STR_LIT:->' ) <EOL> expr . append ( args [ <NUM_LIT:0> ] ) <EOL> mul = pmml . Apply ( function = '<STR_LIT:*>' ) <EOL> mul . append ( args [ <NUM_LIT:1> ] ) <EOL> floor = pmml . Apply ( function = '<STR_LIT>' ) <EOL> mul . append ( floor ) <EOL> div = pmml . Apply ( function = '<STR_LIT:/>' ) <EOL> floor . append ( div ) <EOL> div . append ( args [ <NUM_LIT:0> ] ) <EOL> div . append ( args [ <NUM_LIT:1> ] ) <EOL> return expr <EOL> def greedy_evaluation ( node ) : <EOL> if isinstance ( node , str ) : <EOL> return ( lambda df : df [ node ] ) , pmml . FieldRef ( field = node ) <EOL> elif isinstance ( node , ( tuple , list ) ) : <EOL> args = map ( greedy_evaluation , node [ <NUM_LIT:1> : ] ) <EOL> functions = { <EOL>", "answer": "'<STR_LIT:*>' : lambda df : np . multiply ( * [ _ [ <NUM_LIT:0> ] ( df ) for _ in args ] ) ,"}, {"prompt": "<s> try : <EOL> import pyPdf <EOL> except ImportError : <EOL> pass <EOL>", "answer": "def merge_pdfs ( pdfs , output_name ) :"}, {"prompt": "<s> from __future__ import print_function , unicode_literals <EOL> import copy <EOL> from sys import stdout <EOL> from math import sqrt <EOL> try : <EOL> import numpy <EOL> except ImportError : <EOL> pass <EOL> from nltk . cluster . api import ClusterI <EOL> from nltk . compat import python_2_unicode_compatible <EOL> class VectorSpaceClusterer ( ClusterI ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , normalise = False , svd_dimensions = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _Tt = None <EOL> self . _should_normalise = normalise <EOL> self . _svd_dimensions = svd_dimensions <EOL> def cluster ( self , vectors , assign_clusters = False , trace = False ) : <EOL> assert len ( vectors ) > <NUM_LIT:0> <EOL> if self . _should_normalise : <EOL> vectors = list ( map ( self . _normalise , vectors ) ) <EOL> if self . _svd_dimensions and self . _svd_dimensions < len ( vectors [ <NUM_LIT:0> ] ) : <EOL> [ u , d , vt ] = numpy . linalg . svd ( numpy . transpose ( numpy . array ( vectors ) ) ) <EOL> S = d [ : self . _svd_dimensions ] * numpy . identity ( self . _svd_dimensions , numpy . float64 ) <EOL> T = u [ : , : self . _svd_dimensions ] <EOL> Dt = vt [ : self . _svd_dimensions , : ] <EOL> vectors = numpy . transpose ( numpy . dot ( S , Dt ) ) <EOL> self . _Tt = numpy . transpose ( T ) <EOL> self . cluster_vectorspace ( vectors , trace ) <EOL> if assign_clusters : <EOL> return [ self . classify ( vector ) for vector in vectors ] <EOL> def cluster_vectorspace ( self , vectors , trace ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL> def classify ( self , vector ) : <EOL> if self . _should_normalise : <EOL> vector = self . _normalise ( vector ) <EOL> if self . _Tt is not None : <EOL> vector = numpy . dot ( self . _Tt , vector ) <EOL> cluster = self . classify_vectorspace ( vector ) <EOL> return self . cluster_name ( cluster ) <EOL> def classify_vectorspace ( self , vector ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError ( ) <EOL> def likelihood ( self , vector , label ) : <EOL> if self . _should_normalise : <EOL> vector = self . _normalise ( vector ) <EOL> if self . _Tt is not None : <EOL> vector = numpy . dot ( self . _Tt , vector ) <EOL> return self . likelihood_vectorspace ( vector , label ) <EOL> def likelihood_vectorspace ( self , vector , cluster ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> predicted = self . classify_vectorspace ( vector ) <EOL> return ( <NUM_LIT:1.0> if cluster == predicted else <NUM_LIT:0.0> ) <EOL> def vector ( self , vector ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _should_normalise : <EOL> vector = self . _normalise ( vector ) <EOL> if self . _Tt is not None : <EOL> vector = numpy . dot ( self . _Tt , vector ) <EOL> return vector <EOL> def _normalise ( self , vector ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return vector / sqrt ( numpy . dot ( vector , vector ) ) <EOL> def euclidean_distance ( u , v ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> diff = u - v <EOL> return sqrt ( numpy . dot ( diff , diff ) ) <EOL> def cosine_distance ( u , v ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return <NUM_LIT:1> - ( numpy . dot ( u , v ) / ( sqrt ( numpy . dot ( u , u ) ) * sqrt ( numpy . dot ( v , v ) ) ) ) <EOL> class _DendrogramNode ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , value , * children ) : <EOL> self . _value = value <EOL> self . _children = children <EOL> def leaves ( self , values = True ) : <EOL> if self . _children : <EOL> leaves = [ ] <EOL> for child in self . _children : <EOL> leaves . extend ( child . leaves ( values ) ) <EOL> return leaves <EOL> elif values : <EOL> return [ self . _value ] <EOL> else : <EOL> return [ self ] <EOL> def groups ( self , n ) : <EOL> queue = [ ( self . _value , self ) ] <EOL> while len ( queue ) < n : <EOL> priority , node = queue . pop ( ) <EOL> if not node . _children : <EOL> queue . push ( ( priority , node ) ) <EOL> break <EOL> for child in node . _children : <EOL> if child . _children : <EOL> queue . append ( ( child . _value , child ) ) <EOL> else : <EOL> queue . append ( ( <NUM_LIT:0> , child ) ) <EOL> queue . sort ( ) <EOL> groups = [ ] <EOL> for priority , node in queue : <EOL> groups . append ( node . leaves ( ) ) <EOL> return groups <EOL> @ python_2_unicode_compatible <EOL> class Dendrogram ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , items = [ ] ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _items = [ _DendrogramNode ( item ) for item in items ] <EOL> self . _original_items = copy . copy ( self . _items ) <EOL> self . _merge = <NUM_LIT:1> <EOL> def merge ( self , * indices ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> assert len ( indices ) >= <NUM_LIT:2> <EOL> node = _DendrogramNode ( self . _merge , * [ self . _items [ i ] for i in indices ] ) <EOL> self . _merge += <NUM_LIT:1> <EOL> self . _items [ indices [ <NUM_LIT:0> ] ] = node <EOL> for i in indices [ <NUM_LIT:1> : ] : <EOL> del self . _items [ i ] <EOL>", "answer": "def groups ( self , n ) :"}, {"prompt": "<s> try : <EOL> from configparser import ConfigParser <EOL> from configparser import NoSectionError <EOL> except ImportError : <EOL> from ConfigParser import ConfigParser <EOL>", "answer": "from ConfigParser import NoSectionError "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from webob . util . dictmixin import DictMixin <EOL> class EnvironHeaders ( DictMixin ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , environ ) : <EOL> self . environ = environ <EOL> def _trans_name ( self , name ) : <EOL> key = '<STR_LIT>' + name . replace ( '<STR_LIT:->' , '<STR_LIT:_>' ) . upper ( ) <EOL> if key == '<STR_LIT>' : <EOL> key = '<STR_LIT>' <EOL> elif key == '<STR_LIT>' : <EOL> key = '<STR_LIT>' <EOL>", "answer": "return key"}, {"prompt": "<s> import mock <EOL> import unittest <EOL> import uuid <EOL> import json <EOL> from hpOneView . common import make_server_dict <EOL> from hpOneView . common import make_ServerProfileTemplateV1 <EOL> from hpOneView . common import uri <EOL> from hpOneView . connection import * <EOL> from hpOneView . servers import * <EOL> from hpOneView . activity import * <EOL> class ServersTest ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> super ( ServersTest , self ) . setUp ( ) <EOL> self . host = '<STR_LIT>' <EOL> self . connection = connection ( self . host ) <EOL> self . servers = servers ( self . connection ) <EOL> self . activity = activity ( self . connection ) <EOL> @ mock . patch . object ( connection , '<STR_LIT>' ) <EOL> def test_get_connections ( self , mock_get ) : <EOL> filter = '<STR_LIT>' <EOL> self . servers . get_connections ( filter = filter ) <EOL> mock_get . assert_called_once_with ( uri [ '<STR_LIT>' ] + filter ) <EOL> @ mock . patch . object ( connection , '<STR_LIT>' ) <EOL> def test_get_connection ( self , mock_get ) : <EOL> settings_test = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> self . servers . get_connection ( settings_test ) <EOL> mock_get . assert_called_once_with ( settings_test [ '<STR_LIT>' ] ) <EOL> @ mock . patch . object ( connection , '<STR_LIT>' ) <EOL> def test_get_utilization ( self , mock_get ) : <EOL> settings_test = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> self . servers . get_utilization ( settings_test ) <EOL> mock_get . assert_called_once_with ( settings_test [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> @ mock . patch . object ( connection , '<STR_LIT>' ) <EOL> def test_get_bios ( self , mock_get ) : <EOL> settings_test = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> self . servers . get_bios ( settings_test ) <EOL> mock_get . assert_called_once_with ( settings_test [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> @ mock . patch . object ( connection , '<STR_LIT>' ) <EOL> def test_get_envconf ( self , mock_get ) : <EOL> settings_test = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> self . servers . get_env_conf ( settings_test ) <EOL> mock_get . assert_called_once_with ( settings_test [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> @ mock . patch . object ( connection , '<STR_LIT>' ) <EOL> def test_get_ilo ( self , mock_get ) : <EOL> settings_test = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> self . servers . get_ilo_sso_url ( settings_test ) <EOL> mock_get . assert_called_once_with ( settings_test [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> @ mock . patch . object ( connection , '<STR_LIT>' ) <EOL> def test_get_server_schema ( self , mock_get ) : <EOL> self . servers . get_server_schema ( ) <EOL> mock_get . assert_called_once_with ( uri [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> @ mock . patch . object ( connection , '<STR_LIT>' ) <EOL> def test_get_java_remote ( self , mock_get ) : <EOL> settings_test = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> self . servers . get_java_remote_console_url ( settings_test ) <EOL> mock_get . assert_called_once_with ( settings_test [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> @ mock . patch . object ( connection , '<STR_LIT>' ) <EOL> def test_get_remote_console ( self , mock_get ) : <EOL> settings_test = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> self . servers . get_remote_console_url ( settings_test ) <EOL> mock_get . assert_called_once_with ( settings_test [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> @ mock . patch . object ( connection , '<STR_LIT>' ) <EOL> @ mock . patch . object ( activity , '<STR_LIT>' ) <EOL> def test_create_server_profile_template ( self , mock_wait4task , mock_post ) : <EOL> name = '<STR_LIT>' <EOL> description = '<STR_LIT:description>' <EOL> sht = '<STR_LIT>' <EOL> eg = '<STR_LIT>' <EOL> affinity = '<STR_LIT>' <EOL> hide_flex = False <EOL> fw_settings = make_FirmwareSettingsV3 ( '<STR_LIT>' , '<STR_LIT>' , True , False ) <EOL> spt = make_ServerProfileTemplateV1 ( name , description , None , sht , eg , affinity , hide_flex , None , fw_settings ) <EOL> task = self . build_spt_add_task_resource ( ) <EOL> mock_post . return_value = [ task , None ] <EOL> self . servers . create_server_profile_template ( name , description , None , sht , eg , affinity , hide_flex , None , fw_settings ) <EOL> mock_post . assert_called_once_with ( uri [ '<STR_LIT>' ] , spt ) <EOL> @ mock . patch . object ( connection , '<STR_LIT>' ) <EOL> @ mock . patch . object ( activity , '<STR_LIT>' ) <EOL> def test_create_server_profile_template_with_connections ( self , mock_wait4task , mock_post ) : <EOL> name = '<STR_LIT>' <EOL> description = '<STR_LIT:description>' <EOL> sht = '<STR_LIT>' <EOL> eg = '<STR_LIT>' <EOL> affinity = '<STR_LIT>' <EOL> hide_flex = True <EOL> fw_settings = make_FirmwareSettingsV3 ( '<STR_LIT>' , '<STR_LIT>' , True , False ) <EOL> connections = make_ProfileConnectionV4 ( <NUM_LIT:1> , \"<STR_LIT>\" , '<STR_LIT>' , True , None , '<STR_LIT>' , None , None , '<STR_LIT>' , '<STR_LIT>' , None , None , None ) <EOL> spt = make_ServerProfileTemplateV1 ( name , description , None , sht , eg , affinity , hide_flex , connections , fw_settings ) <EOL> task = self . build_spt_add_task_resource ( ) <EOL> mock_post . return_value = [ task , None ] <EOL> self . servers . create_server_profile_template ( name , description , None , sht , eg , affinity , hide_flex , connections , fw_settings ) <EOL> mock_post . assert_called_once_with ( uri [ '<STR_LIT>' ] , spt ) <EOL> @ mock . patch . object ( connection , '<STR_LIT>' ) <EOL> @ mock . patch . object ( activity , '<STR_LIT>' ) <EOL> def test_add_server ( self , mock_wait4task , mock_post ) : <EOL> server = make_server_dict ( '<STR_LIT>' , '<STR_LIT:username>' , '<STR_LIT:password>' , False , '<STR_LIT>' ) <EOL> task = self . build_server_add_task_resource ( ) <EOL> mock_post . return_value = [ task , None ] <EOL> mock_wait4task ( task ) . return_value = task <EOL> self . servers . add_server ( server ) <EOL> mock_post . assert_called_once_with ( uri [ '<STR_LIT>' ] , server ) <EOL> def build_server_add_task_resource ( self ) : <EOL> task = { <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL> '<STR_LIT>' : <NUM_LIT:100> , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ ] , <EOL> '<STR_LIT>' : None , <EOL> '<STR_LIT>' : <NUM_LIT:20> , <EOL> '<STR_LIT>' : <NUM_LIT:100> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : [ ] , <EOL> '<STR_LIT>' : <NUM_LIT:20> , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> return json . dumps ( task ) <EOL> def build_spt_add_task_resource ( self ) : <EOL> task = { <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:data>' : None , <EOL>", "answer": "'<STR_LIT>' : <NUM_LIT:100> ,"}, {"prompt": "<s> import hashlib <EOL> import urllib <EOL> from collections import defaultdict <EOL> from datetime import datetime <EOL> from babel . dates import format_date <EOL> from babel . dates import format_datetime <EOL> from babel . dates import format_time <EOL> from babel . numbers import format_currency <EOL> from pyramid . decorator import reify <EOL> from pyramid . i18n import get_locale_name <EOL> from pyramid . interfaces import ILocation <EOL> from pyramid . location import inside <EOL> from pyramid . location import lineage <EOL> from pyramid . renderers import get_renderer <EOL> from pyramid . renderers import render <EOL> from pyramid . settings import asbool <EOL> from sqlalchemy import and_ <EOL> from sqlalchemy import not_ <EOL> from sqlalchemy import or_ <EOL> from zope . deprecation import deprecated <EOL> from kotti import DBSession <EOL> from kotti import get_settings <EOL> from kotti . events import objectevent_listeners <EOL> from kotti . interfaces import INavigationRoot <EOL> from kotti . resources import Content <EOL> from kotti . resources import Document <EOL> from kotti . resources import get_root <EOL> from kotti . resources import Tag <EOL> from kotti . resources import TagsToContents <EOL> from kotti . sanitizers import sanitize <EOL> from kotti . security import view_permitted <EOL> from kotti . util import render_view <EOL> from kotti . util import TemplateStructure <EOL> from kotti . views . site_setup import CONTROL_PANEL_LINKS <EOL> from kotti . views . slots import slot_events <EOL> class SettingHasValuePredicate ( object ) : <EOL> def __init__ ( self , val , config ) : <EOL> self . name , self . value = val <EOL> if not isinstance ( self . value , bool ) : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> def text ( self ) : <EOL> return u'<STR_LIT>' . format ( <EOL> self . name , self . value ) <EOL> phash = text <EOL> def __call__ ( self , context , request ) : <EOL> return asbool ( request . registry . settings [ self . name ] ) == self . value <EOL> class RootOnlyPredicate ( object ) : <EOL> def __init__ ( self , val , config ) : <EOL> self . val = val <EOL> def text ( self ) : <EOL> return u'<STR_LIT>' . format ( self . val ) <EOL> phash = text <EOL> def __call__ ( self , context , request ) : <EOL> return ( context is request . root ) == self . val <EOL> def template_api ( context , request , ** kwargs ) : <EOL> return get_settings ( ) [ '<STR_LIT>' ] [ <NUM_LIT:0> ] ( <EOL> context , request , ** kwargs ) <EOL> def add_renderer_globals ( event ) : <EOL>", "answer": "if event . get ( '<STR_LIT>' ) != '<STR_LIT>' :"}, {"prompt": "<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from functools import reduce <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> if sys . version_info . major == <NUM_LIT:3> : <EOL> basestring = str <EOL> import re <EOL> from numpy . core import umath <EOL> from pycopia . physics import numberdict <EOL> class PhysicalQuantity ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _NUMBER_RE = re . compile ( r'<STR_LIT>' ) <EOL> def __init__ ( self , value , unit = None , space = \"<STR_LIT:U+0020>\" ) : <EOL> self . _space = space <EOL> if unit is not None : <EOL> self . value = float ( value ) <EOL> self . unit = _findUnit ( unit ) <EOL> else : <EOL> if isinstance ( value , basestring ) : <EOL> match = PhysicalQuantity . _NUMBER_RE . match ( value ) <EOL> if match is None : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> self . value = float ( match . group ( <NUM_LIT:1> ) ) <EOL> self . _space = match . group ( <NUM_LIT:2> ) <EOL> self . unit = _findUnit ( match . group ( <NUM_LIT:3> ) ) <EOL> elif isinstance ( value , PhysicalQuantity ) : <EOL> self . value = value . value <EOL> self . unit = value . unit <EOL> self . _space = value . _space <EOL> elif isinstance ( value , tuple ) : <EOL> self . value = float ( value [ <NUM_LIT:0> ] ) <EOL> self . unit = _findUnit ( value [ <NUM_LIT:1> ] ) <EOL> try : <EOL> self . _space = value [ <NUM_LIT:2> ] <EOL> except IndexError : <EOL> pass <EOL> else : <EOL> raise ValueError ( \"<STR_LIT>\" . format ( value ) ) <EOL> def __str__ ( self ) : <EOL> return \"<STR_LIT>\" . format ( str ( self . value ) , self . _space , self . unit . name ( ) ) <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . __class__ . __name__ , self . value , self . unit . name ( ) , self . _space ) <EOL> def nospace ( self ) : <EOL> self . _space = \"<STR_LIT>\" <EOL> def usespace ( self , space = \"<STR_LIT:U+0020>\" ) : <EOL> self . _space = space <EOL> def __float__ ( self ) : <EOL> return self . value <EOL> def _sum ( self , other , sign1 , sign2 ) : <EOL> if not isPhysicalQuantity ( other ) : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> new_value = sign1 * self . value + sign2 * other . value * other . unit . conversionFactorTo ( self . unit ) <EOL> return self . __class__ ( new_value , self . unit , self . _space ) <EOL> def __add__ ( self , other ) : <EOL> return self . _sum ( other , <NUM_LIT:1> , <NUM_LIT:1> ) <EOL> __radd__ = __add__ <EOL> def __sub__ ( self , other ) : <EOL> return self . _sum ( other , <NUM_LIT:1> , - <NUM_LIT:1> ) <EOL> def __rsub__ ( self , other ) : <EOL> return self . _sum ( other , - <NUM_LIT:1> , <NUM_LIT:1> ) <EOL> def __eq__ ( self , other ) : <EOL> return self . value == other . value * other . unit . conversionFactorTo ( self . unit ) <EOL> def __ne__ ( self , other ) : <EOL> return self . value != other . value * other . unit . conversionFactorTo ( self . unit ) <EOL> def __lt__ ( self , other ) : <EOL> return self . value < other . value * other . unit . conversionFactorTo ( self . unit ) <EOL> def __le__ ( self , other ) : <EOL> return self . value <= other . value * other . unit . conversionFactorTo ( self . unit ) <EOL> def __gt__ ( self , other ) : <EOL> return self . value > other . value * other . unit . conversionFactorTo ( self . unit ) <EOL> def __ge__ ( self , other ) : <EOL> return self . value >= other . value * other . unit . conversionFactorTo ( self . unit ) <EOL> def __mul__ ( self , other ) : <EOL> if not isPhysicalQuantity ( other ) : <EOL> return self . __class__ ( self . value * other , self . unit , self . _space ) <EOL> value = self . value * other . value <EOL> unit = self . unit * other . unit <EOL> if unit . isDimensionless ( ) : <EOL> return value * unit . factor <EOL> else : <EOL> return self . __class__ ( value , unit , self . _space ) <EOL> __rmul__ = __mul__ <EOL> def __truediv__ ( self , other ) : <EOL> if not isPhysicalQuantity ( other ) : <EOL> return self . __class__ ( self . value / other , self . unit , self . _space ) <EOL> value = self . value / other . value <EOL> unit = self . unit / other . unit <EOL> if unit . isDimensionless ( ) : <EOL> return value * unit . factor <EOL> else : <EOL> return self . __class__ ( value , unit , self . _space ) <EOL> __div__ = __truediv__ <EOL> def __rtruediv__ ( self , other ) : <EOL> if not isPhysicalQuantity ( other ) : <EOL> return self . __class__ ( float ( other ) / self . value , pow ( self . unit , - <NUM_LIT:1> ) , self . _space ) <EOL> value = other . value / self . value <EOL> unit = other . unit / self . unit <EOL> if unit . isDimensionless ( ) : <EOL> return value * unit . factor <EOL> else : <EOL> return self . __class__ ( value , unit , self . _space ) <EOL> __rdiv__ = __rtruediv__ <EOL> def __pow__ ( self , other ) : <EOL> if isPhysicalQuantity ( other ) : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> return self . __class__ ( pow ( self . value , other ) , pow ( self . unit , other ) , self . _space ) <EOL> def __rpow__ ( self , other ) : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> def __abs__ ( self ) : <EOL> return self . __class__ ( abs ( self . value ) , self . unit , self . _space ) <EOL> def __pos__ ( self ) : <EOL> return self <EOL> def __neg__ ( self ) : <EOL> return self . __class__ ( - self . value , self . unit , self . _space ) <EOL> def __nonzero__ ( self ) : <EOL> return self . value != <NUM_LIT:0> <EOL> __bool__ = __nonzero__ <EOL> def convertToUnit ( self , unit ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> unit = _findUnit ( unit ) <EOL> self . value = _convertValue ( self . value , self . unit , unit ) <EOL> self . unit = unit <EOL> def inUnitsOf ( self , * units ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> units = list ( map ( _findUnit , units ) ) <EOL> if len ( units ) == <NUM_LIT:1> : <EOL> unit = units [ <NUM_LIT:0> ] <EOL> value = _convertValue ( self . value , self . unit , unit ) <EOL> return self . __class__ ( value , unit , self . _space ) <EOL> else : <EOL> units . sort ( ) <EOL> result = [ ] <EOL> value = self . value <EOL> unit = self . unit <EOL> for i in range ( len ( units ) - <NUM_LIT:1> , - <NUM_LIT:1> , - <NUM_LIT:1> ) : <EOL> value = value * unit . conversionFactorTo ( units [ i ] ) <EOL> if i == <NUM_LIT:0> : <EOL> rounded = value <EOL> else : <EOL> rounded = _round ( value ) <EOL> result . append ( self . __class__ ( rounded , units [ i ] ) ) <EOL> value = value - rounded <EOL> unit = units [ i ] <EOL> return tuple ( result ) <EOL> def inBaseUnits ( self ) : <EOL> new_value = self . value * self . unit . factor <EOL> num = '<STR_LIT>' <EOL> denom = '<STR_LIT>' <EOL> for i in range ( <NUM_LIT:9> ) : <EOL> unit = _base_names [ i ] <EOL> power = self . unit . powers [ i ] <EOL> if power < <NUM_LIT:0> : <EOL> denom = denom + '<STR_LIT:/>' + unit <EOL> if power < - <NUM_LIT:1> : <EOL> denom = denom + '<STR_LIT>' + str ( - power ) <EOL> elif power > <NUM_LIT:0> : <EOL> num = num + '<STR_LIT:*>' + unit <EOL> if power > <NUM_LIT:1> : <EOL> num = num + '<STR_LIT>' + str ( power ) <EOL> if len ( num ) == <NUM_LIT:0> : <EOL> num = '<STR_LIT:1>' <EOL> else : <EOL> num = num [ <NUM_LIT:1> : ] <EOL> return self . __class__ ( new_value , num + denom , self . _space ) <EOL> def isCompatible ( self , unit ) : <EOL> unit = _findUnit ( unit ) <EOL> return self . unit . isCompatible ( unit ) <EOL> def sqrt ( self ) : <EOL> return pow ( self , <NUM_LIT:0.5> ) <EOL> def sin ( self ) : <EOL> if self . unit . isAngle ( ) : <EOL> return umath . sin ( self . value * self . unit . conversionFactorTo ( _unit_table [ '<STR_LIT>' ] ) ) <EOL> else : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> def cos ( self ) : <EOL> if self . unit . isAngle ( ) : <EOL> return umath . cos ( self . value * self . unit . conversionFactorTo ( _unit_table [ '<STR_LIT>' ] ) ) <EOL> else : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> def tan ( self ) : <EOL> if self . unit . isAngle ( ) : <EOL> return umath . tan ( self . value * self . unit . conversionFactorTo ( _unit_table [ '<STR_LIT>' ] ) ) <EOL> else : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> class PhysicalUnit ( object ) : <EOL> def __init__ ( self , names , factor , powers , offset = <NUM_LIT:0> ) : <EOL> if isinstance ( names , basestring ) : <EOL> self . names = numberdict . NumberDict ( default = <NUM_LIT:0> ) <EOL> self . names [ names ] = <NUM_LIT:1> <EOL> else : <EOL> self . names = names <EOL> self . factor = float ( factor ) <EOL> self . offset = offset <EOL> self . powers = powers <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' + self . name ( ) + '<STR_LIT:>>' <EOL> def _check ( self , other ) : <EOL> if self . powers != other . powers : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> def __eq__ ( self , other ) : <EOL> self . _check ( other ) <EOL> return self . factor == other . factor <EOL> def __ne__ ( self , other ) : <EOL> self . _check ( other ) <EOL> return self . factor != other . factor <EOL> def __lt__ ( self , other ) : <EOL> self . _check ( other ) <EOL> return self . factor < other . factor <EOL> def __le__ ( self , other ) : <EOL> self . _check ( other ) <EOL> return self . factor <= other . factor <EOL> def __gt__ ( self , other ) : <EOL> self . _check ( other ) <EOL> return self . factor > other . factor <EOL> def __ge__ ( self , other ) : <EOL> self . _check ( other ) <EOL> return self . factor >= other . factor <EOL> def __mul__ ( self , other ) : <EOL> if self . offset != <NUM_LIT:0> or ( isPhysicalUnit ( other ) and other . offset != <NUM_LIT:0> ) : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> if isPhysicalUnit ( other ) : <EOL> return PhysicalUnit ( self . names + other . names , <EOL> self . factor * other . factor , list ( map ( lambda a , b : a + b , self . powers , other . powers ) ) ) <EOL> else : <EOL> return PhysicalUnit ( self . names + { str ( other ) : <NUM_LIT:1> } , <EOL> self . factor * other , <EOL> self . powers , <EOL> self . offset * other ) <EOL> __rmul__ = __mul__ <EOL> def __truediv__ ( self , other ) : <EOL> if self . offset != <NUM_LIT:0> or ( isPhysicalUnit ( other ) and other . offset != <NUM_LIT:0> ) : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> if isPhysicalUnit ( other ) : <EOL> return PhysicalUnit ( self . names - other . names , <EOL> self . factor / other . factor , list ( map ( lambda a , b : a - b , self . powers , other . powers ) ) ) <EOL> else : <EOL> return PhysicalUnit ( self . names + numberdict . NumberDict ( { str ( other ) : - <NUM_LIT:1> } , default = <NUM_LIT:0> ) , <EOL> self . factor / float ( other ) , self . powers ) <EOL> __div__ = __truediv__ <EOL> def __rtruediv__ ( self , other ) : <EOL> if self . offset != <NUM_LIT:0> or ( isPhysicalUnit ( other ) and other . offset != <NUM_LIT:0> ) : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> if isPhysicalUnit ( other ) : <EOL> return PhysicalUnit ( other . names - self . names , <EOL> other . factor / self . factor , list ( map ( lambda a , b : a - b , other . powers , self . powers ) ) ) <EOL> else : <EOL> return PhysicalUnit ( { str ( other ) : <NUM_LIT:1.> } - self . names , <EOL> float ( other ) / self . factor , [ - x for x in self . powers ] ) <EOL> __rdiv__ = __rtruediv__ <EOL> def __pow__ ( self , other ) : <EOL> if self . offset != <NUM_LIT:0> : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> if type ( other ) is int : <EOL> return PhysicalUnit ( other * self . names , pow ( self . factor , other ) , <EOL> [ x * other for x in self . powers ] ) <EOL> if type ( other ) is float : <EOL> inv_exp = <NUM_LIT:1.> / other <EOL> rounded = int ( umath . floor ( inv_exp + <NUM_LIT:0.5> ) ) <EOL> if abs ( inv_exp - rounded ) < <NUM_LIT> : <EOL> if reduce ( lambda a , b : a and b , map ( lambda x , e = rounded : x % e == <NUM_LIT:0> , self . powers ) ) : <EOL> f = pow ( self . factor , other ) <EOL> p = [ x / rounded for x in self . powers ] <EOL> if reduce ( lambda a , b : a and b , map ( lambda x , e = rounded : x % e == <NUM_LIT:0> , self . names . values ( ) ) ) : <EOL> names = self . names / rounded <EOL> else : <EOL> names = numberdict . NumberDict ( default = <NUM_LIT:0> ) <EOL> if f != <NUM_LIT:1.> : <EOL> names [ str ( f ) ] = <NUM_LIT:1> <EOL> for i in range ( len ( p ) ) : <EOL> names [ _base_names [ i ] ] = p [ i ] <EOL> return PhysicalUnit ( names , f , p ) <EOL> else : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> def conversionFactorTo ( self , other ) : <EOL> if self . powers != other . powers : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> if self . offset != other . offset and self . factor != other . factor : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % ( self . name ( ) , other . name ( ) ) ) <EOL> return self . factor / other . factor <EOL> def conversionTupleTo ( self , other ) : <EOL> if self . powers != other . powers : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> factor = self . factor / other . factor <EOL> offset = self . offset - ( other . offset * other . factor / self . factor ) <EOL> return ( factor , offset ) <EOL> def isCompatible ( self , other ) : <EOL> return self . powers == other . powers <EOL> def isDimensionless ( self ) : <EOL> return not reduce ( lambda a , b : a or b , self . powers ) <EOL> def isAngle ( self ) : <EOL> return self . powers [ <NUM_LIT:7> ] == <NUM_LIT:1> and reduce ( lambda a , b : a + b , self . powers ) == <NUM_LIT:1> <EOL> def setName ( self , name ) : <EOL> self . names = numberdict . NumberDict ( default = <NUM_LIT:0> ) <EOL> self . names [ name ] = <NUM_LIT:1> <EOL> def name ( self ) : <EOL> num = '<STR_LIT>' <EOL> denom = '<STR_LIT>' <EOL> for unit in self . names . keys ( ) : <EOL> power = self . names [ unit ] <EOL> if power < <NUM_LIT:0> : <EOL> denom = denom + '<STR_LIT:/>' + unit <EOL> if power < - <NUM_LIT:1> : <EOL> denom = denom + '<STR_LIT>' + str ( - power ) <EOL> elif power > <NUM_LIT:0> : <EOL> num = num + '<STR_LIT:*>' + unit <EOL> if power > <NUM_LIT:1> : <EOL> num = num + '<STR_LIT>' + str ( power ) <EOL> if len ( num ) == <NUM_LIT:0> : <EOL> num = '<STR_LIT:1>' <EOL> else : <EOL> num = num [ <NUM_LIT:1> : ] <EOL> return num + denom <EOL> def isPhysicalUnit ( x ) : <EOL> return isinstance ( x , PhysicalUnit ) <EOL> def isPhysicalQuantity ( x ) : <EOL> \"<STR_LIT>\" <EOL> return isinstance ( x , PhysicalQuantity ) <EOL> def _findUnit ( unit ) : <EOL> if isinstance ( unit , basestring ) : <EOL> unit = eval ( unit , _unit_table ) <EOL> for cruft in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> try : <EOL> del _unit_table [ cruft ] <EOL> except KeyError : <EOL> pass <EOL> if not isPhysicalUnit ( unit ) : <EOL> raise TypeError ( str ( unit ) + '<STR_LIT>' ) <EOL> return unit <EOL> def _round ( x ) : <EOL> if umath . greater ( x , <NUM_LIT:0.> ) : <EOL> return umath . floor ( x ) <EOL> else : <EOL> return umath . ceil ( x ) <EOL> def _convertValue ( value , src_unit , target_unit ) : <EOL> ( factor , offset ) = src_unit . conversionTupleTo ( target_unit ) <EOL> return ( value + offset ) * factor <EOL> _base_names = [ '<STR_LIT:m>' , '<STR_LIT>' , '<STR_LIT:s>' , '<STR_LIT:A>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> _base_units = [ <EOL> ( '<STR_LIT:m>' , PhysicalUnit ( '<STR_LIT:m>' , <NUM_LIT:1.> , [ <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] ) ) , <EOL> ( '<STR_LIT:g>' , PhysicalUnit ( '<STR_LIT:g>' , <NUM_LIT> , [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] ) ) , <EOL> ( '<STR_LIT:s>' , PhysicalUnit ( '<STR_LIT:s>' , <NUM_LIT:1.> , [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] ) ) , <EOL> ( '<STR_LIT:A>' , PhysicalUnit ( '<STR_LIT:A>' , <NUM_LIT:1.> , [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] ) ) , <EOL> ( '<STR_LIT>' , PhysicalUnit ( '<STR_LIT>' , <NUM_LIT:1.> , [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] ) ) , <EOL> ( '<STR_LIT>' , PhysicalUnit ( '<STR_LIT>' , <NUM_LIT:1.> , [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] ) ) , <EOL> ( '<STR_LIT>' , PhysicalUnit ( '<STR_LIT>' , <NUM_LIT:1.> , [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> ] ) ) , <EOL> ( '<STR_LIT>' , PhysicalUnit ( '<STR_LIT>' , <NUM_LIT:1.> , [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ] ) ) , <EOL> ( '<STR_LIT>' , PhysicalUnit ( '<STR_LIT>' , <NUM_LIT:1.> , [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> ] ) ) , <EOL> ] <EOL> _prefixes = [ <EOL> ( '<STR_LIT:Y>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:E>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:P>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:T>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:M>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:k>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:h>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:d>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:c>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:m>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:u>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:n>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:p>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:f>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:a>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:z>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT:y>' , <NUM_LIT> ) , <EOL> ] <EOL> _unit_table = { } <EOL> for unit in _base_units : <EOL> _unit_table [ unit [ <NUM_LIT:0> ] ] = unit [ <NUM_LIT:1> ] <EOL> def _addUnit ( name , unit ) : <EOL> if name in _unit_table : <EOL> raise KeyError ( '<STR_LIT>' + name + '<STR_LIT>' ) <EOL> if isinstance ( unit , basestring ) : <EOL> unit = eval ( unit , _unit_table ) <EOL> for cruft in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> try : del _unit_table [ cruft ] <EOL> except : pass <EOL> unit . setName ( name ) <EOL> _unit_table [ name ] = unit <EOL> def _addPrefixed ( unit ) : <EOL> for prefix in _prefixes : <EOL> name = prefix [ <NUM_LIT:0> ] + unit <EOL> _addUnit ( name , prefix [ <NUM_LIT:1> ] * _unit_table [ unit ] ) <EOL> _unit_table [ '<STR_LIT>' ] = PhysicalUnit ( '<STR_LIT>' , <NUM_LIT:1.> , [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT:N>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT:C>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT:F>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT:S>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT:T>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT:H>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> del _unit_table [ '<STR_LIT>' ] <EOL> for unit in list ( _unit_table . keys ( ) ) : <EOL> _addPrefixed ( unit ) <EOL> _unit_table [ '<STR_LIT>' ] = umath . pi <EOL> _addUnit ( '<STR_LIT:c>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT:e>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT:k>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT:h>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT:d>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT:l>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addPrefixed ( '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> _addUnit ( '<STR_LIT>' , '<STR_LIT>' ) <EOL>", "answer": "_addUnit ( '<STR_LIT>' , '<STR_LIT>' )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "__author__ = '<STR_LIT>'"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os . path <EOL> import sys <EOL> from math import isnan <EOL> def assertRaisesError ( test_case_instance , code , err_type , err_msg ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> eval ( code ) <EOL> except err_type , err : <EOL> test_case_instance . assertEqual ( str ( err ) , err_msg ) <EOL> else : <EOL> test_case_instance . fail ( \"<STR_LIT>\" % err_type ) <EOL> def assert_raises ( test_case , code , globals , locals , exception , msg , <EOL> use_exec = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> if use_exec : <EOL> exec code in globals , locals <EOL> else : <EOL> eval ( code , globals , locals ) <EOL> except exception as exc : <EOL> test_case . assertEqual ( str ( exc ) [ : len ( msg ) ] , msg ) <EOL> else : <EOL> test_case . fail ( '<STR_LIT>' % exception ) <EOL> def assert_rel_error ( test_case , actual , desired , tolerance ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> actual [ <NUM_LIT:0> ] <EOL> except ( TypeError , IndexError ) : <EOL> if isnan ( actual ) and not isnan ( desired ) : <EOL> test_case . fail ( '<STR_LIT>' <EOL> % ( desired , tolerance ) ) <EOL> if desired != <NUM_LIT:0> : <EOL> error = ( actual - desired ) / desired <EOL> else : <EOL> error = actual <EOL> if abs ( error ) > tolerance : <EOL> test_case . fail ( '<STR_LIT>' <EOL> % ( actual , desired , error , tolerance ) ) <EOL>", "answer": "else :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import getpass <EOL> from twisted . python import failure <EOL> from twisted . internet import defer <EOL> from twisted . internet . endpoints import clientFromString <EOL> from twisted . conch . ssh . connection import SSHConnection <EOL> from carnifex . inductor import ProcessInductor <EOL> from carnifex . ssh . client import SSHClientFactory <EOL> from carnifex . ssh . command import SSHCommand <EOL> from carnifex . ssh . userauth import AutomaticUserAuthClient <EOL> from carnifex . ssh . process import connectProcess <EOL> class UnknownHostKey ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> class AllHostKeys ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __contains__ ( self , key ) : <EOL> return True <EOL> allHostKeys = AllHostKeys ( ) <EOL> class SSHProcessInductor ( ProcessInductor ) : <EOL> _sep = '<STR_LIT:;>' <EOL> _cd = '<STR_LIT>' <EOL> _defaultUser = None <EOL> knownHosts = allHostKeys <EOL> def __init__ ( self , reactor , host , port , timeout = <NUM_LIT:30> , bindAddress = None , <EOL> precursor = None , credentials = None ) : <EOL> self . _connections = { } <EOL> self . reactor = reactor <EOL> description = '<STR_LIT>' % ( host , port , timeout ) <EOL> if bindAddress : <EOL> description += '<STR_LIT>' % bindAddress <EOL> self . endpoint = clientFromString ( reactor , description ) <EOL> self . precursor = precursor <EOL> self . credentials = credentials or { } <EOL> def setCredentials ( self , uid , password = None , privateKey = None , publicKey = None ) : <EOL> user = self . _getUser ( uid ) <EOL> credentials = self . credentials . setdefault ( user , { } ) <EOL> credentials [ '<STR_LIT:password>' ] = password <EOL> credentials [ '<STR_LIT>' ] = privateKey <EOL> credentials [ '<STR_LIT>' ] = publicKey <EOL> def addKnownHost ( self , hostKey , fingerprint ) : <EOL> if self . knownHosts == allHostKeys : <EOL> self . knownHosts = { } <EOL> self . knownHosts [ fingerprint ] = hostKey <EOL> def execute ( self , processProtocol , command , env = { } , <EOL> path = None , uid = None , gid = None , usePTY = <NUM_LIT:0> , childFDs = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> sshCommand = ( command if isinstance ( command , SSHCommand ) <EOL> else SSHCommand ( command , self . precursor , path ) ) <EOL> commandLine = sshCommand . getCommandLine ( ) <EOL> connectionDeferred = self . getConnection ( uid ) <EOL> connectionDeferred . addCallback ( connectProcess , processProtocol , <EOL> commandLine , env , usePTY , childFDs ) <EOL> return connectionDeferred <EOL> def getConnection ( self , uid = None ) : <EOL> user = self . _getUser ( uid ) <EOL> connection = self . _connections . get ( user , None ) <EOL> if connection : <EOL> return defer . succeed ( connection ) <EOL> self . _connections [ user ] = failure . Failure ( Exception ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % user ) ) <EOL> return self . startConnection ( user ) <EOL> def startConnection ( self , user ) : <EOL> serviceStartedDeferred = defer . Deferred ( ) <EOL> connectionService = SSHConnection ( ) <EOL> def serviceStarted ( ) : <EOL> self . _connections [ user ] = connectionService <EOL> serviceStartedDeferred . callback ( connectionService ) <EOL> connectionService . serviceStarted = serviceStarted <EOL> connectionLostDeferred = defer . Deferred ( ) <EOL> userAuthObject = self . _getUserAuthObject ( user , connectionService ) <EOL> sshClientFactory = SSHClientFactory ( connectionLostDeferred , <EOL> self . _verifyHostKey , userAuthObject ) <EOL> def connectionEnded ( reason ) : <EOL> self . _connections [ user ] = None <EOL> serviceStartedDeferred . called or serviceStartedDeferred . errback ( reason ) <EOL> connectionLostDeferred . addBoth ( connectionEnded ) <EOL> connectionMadeDeferred = self . endpoint . connect ( sshClientFactory ) <EOL> connectionMadeDeferred . addErrback ( connectionEnded ) <EOL> return serviceStartedDeferred <EOL> def disconnectAll ( self ) : <EOL> for connection in self . _connections . values ( ) : <EOL> if hasattr ( connection , '<STR_LIT>' ) : <EOL>", "answer": "connection . transport . loseConnection ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> from datetime import datetime <EOL> from docopt import docopt <EOL> from pprint import pformat <EOL> from sklearn . grid_search import GridSearchCV <EOL> from . interfaces import annotate <EOL> from . util import apply_kwargs <EOL> from . util import args_from_config <EOL> from . util import initialize_config <EOL> from . util import logger <EOL> from . util import PluggableDecorator <EOL> from . util import timer <EOL> @ PluggableDecorator ( '<STR_LIT>' ) <EOL> @ args_from_config <EOL> def fit ( dataset_loader_train , model , model_persister , persist = True , <EOL> activate = True , dataset_loader_test = None , evaluate = False , <EOL> persist_if_better_than = None ) : <EOL> if persist_if_better_than is not None : <EOL> evaluate = True <EOL> if dataset_loader_test is None : <EOL> raise ValueError ( <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> ) <EOL> with timer ( logger . info , \"<STR_LIT>\" ) : <EOL> X , y = dataset_loader_train ( ) <EOL> with timer ( logger . info , \"<STR_LIT>\" ) : <EOL> model . fit ( X , y ) <EOL> if evaluate : <EOL> with timer ( logger . debug , \"<STR_LIT>\" ) : <EOL>", "answer": "score_train = model . score ( X , y )"}, {"prompt": "<s> from atom . api import ( <EOL> Bool , Int , Unicode , Enum , List , Typed , ForwardTyped , observe , set_default <EOL> ) <EOL>", "answer": "from enaml . core . declarative import d_"}, {"prompt": "<s> from oslo_serialization import jsonutils <EOL> from neutronclient . _i18n import _ <EOL> from neutronclient . common import exceptions <EOL> from neutronclient . common import utils <EOL> from neutronclient . neutron import v2_0 as neutronv20 <EOL> from neutronclient . neutron . v2_0 . vpn import utils as vpn_utils <EOL> def _format_peer_cidrs ( ipsec_site_connection ) : <EOL> try : <EOL> return '<STR_LIT:\\n>' . join ( [ jsonutils . dumps ( cidrs ) for cidrs in <EOL> ipsec_site_connection [ '<STR_LIT>' ] ] ) <EOL> except ( TypeError , KeyError ) : <EOL> return '<STR_LIT>' <EOL> class ListIPsecSiteConnection ( neutronv20 . ListCommand ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> resource = '<STR_LIT>' <EOL> _formatters = { '<STR_LIT>' : _format_peer_cidrs } <EOL> list_columns = [ <EOL> '<STR_LIT:id>' , '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:status>' ] <EOL> pagination_support = True <EOL> sorting_support = True <EOL> class ShowIPsecSiteConnection ( neutronv20 . ShowCommand ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> resource = '<STR_LIT>' <EOL> help_resource = '<STR_LIT>' <EOL> class IPsecSiteConnectionMixin ( object ) : <EOL> def add_known_arguments ( self , parser ) : <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL> metavar = \"<STR_LIT>\" , <EOL> type = utils . str2dict_type ( <EOL> optional_keys = [ '<STR_LIT:action>' , '<STR_LIT>' , '<STR_LIT>' ] ) , <EOL> help = vpn_utils . dpd_help ( \"<STR_LIT>\" ) ) <EOL> parser . add_argument ( <EOL> '<STR_LIT>' , <EOL>", "answer": "help = _ ( '<STR_LIT>'"}, {"prompt": "<s> import unittest <EOL> class TestCase ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> pass <EOL> def assertGreaterEqual ( self , first , second , msg = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if first >= second : <EOL> pass <EOL> else : <EOL>", "answer": "self . fail ( msg = msg ) "}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Tangible ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import time <EOL> import datetime <EOL> from ConfigParser import RawConfigParser <EOL> from ovs . dal . hybrids . vpool import VPool <EOL> from ovs . extensions . generic . remote import Remote <EOL> from ovs . extensions . generic . sshclient import SSHClient <EOL> from ovs . extensions . os . os import OSManager <EOL> from ovs . extensions . services . service import ServiceManager <EOL> from ovs . log . logHandler import LogHandler <EOL> logger = LogHandler . get ( '<STR_LIT>' , name = '<STR_LIT>' ) <EOL> class OpenStackManagement ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , cinder_client ) : <EOL> self . client = SSHClient ( '<STR_LIT:127.0.0.1>' , username = '<STR_LIT:root>' ) <EOL> self . cinder_client = cinder_client <EOL> self . _NOVA_CONF = '<STR_LIT>' <EOL> self . _CINDER_CONF = '<STR_LIT>' <EOL> self . _is_openstack = ServiceManager . has_service ( OSManager . get_openstack_cinder_service_name ( ) , self . client ) <EOL> self . _nova_installed = self . client . file_exists ( self . _NOVA_CONF ) <EOL> self . _cinder_installed = self . client . file_exists ( self . _CINDER_CONF ) <EOL> self . _driver_location = OSManager . get_openstack_package_base_path ( ) <EOL> self . _openstack_users = OSManager . get_openstack_users ( ) <EOL> self . _devstack_driver = '<STR_LIT>' <EOL> try : <EOL> self . _is_devstack = '<STR_LIT>' in str ( self . client . run ( '<STR_LIT>' ) ) <EOL> except SystemExit : <EOL> self . _is_devstack = False <EOL> except Exception : <EOL> self . _is_devstack = False <EOL> try : <EOL> from cinder import version <EOL> version_string = version . version_string ( ) <EOL> if version_string . startswith ( '<STR_LIT>' ) : <EOL> self . _stack_version = '<STR_LIT>' <EOL> elif version_string . startswith ( '<STR_LIT>' ) : <EOL> self . _stack_version = '<STR_LIT>' <EOL> elif version_string . startswith ( '<STR_LIT>' ) or version_string . startswith ( '<STR_LIT>' ) : <EOL> self . _stack_version = '<STR_LIT>' <EOL> elif version_string . startswith ( '<STR_LIT>' ) : <EOL> self . _stack_version = '<STR_LIT>' <EOL> elif version_string . startswith ( '<STR_LIT>' ) : <EOL> self . _stack_version = '<STR_LIT>' <EOL> else : <EOL> raise ValueError ( '<STR_LIT>' . format ( version_string ) ) <EOL> except Exception as ex : <EOL> raise ValueError ( '<STR_LIT>' . format ( ex ) ) <EOL> def is_host_configured ( self , ip ) : <EOL> if ( self . _is_devstack is False and self . _is_openstack is False ) or self . _cinder_installed is False or self . _nova_installed is False : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> return False <EOL> if self . _is_devstack is True : <EOL> if not self . client . file_exists ( filename = self . _devstack_driver ) : <EOL> logger . info ( '<STR_LIT>' . format ( self . _devstack_driver ) ) <EOL> return False <EOL> else : <EOL> if not self . client . file_exists ( filename = '<STR_LIT>' . format ( self . _driver_location ) ) : <EOL> logger . info ( '<STR_LIT>' . format ( self . _driver_location ) ) <EOL> return False <EOL> ovs_id = self . client . run ( '<STR_LIT>' ) <EOL> if not ovs_id : <EOL> logger . info ( '<STR_LIT>' ) <EOL> return False <EOL> users = [ '<STR_LIT>' , '<STR_LIT>' ] if self . _is_devstack is True else self . _openstack_users <EOL> for user in users : <EOL> if '<STR_LIT>' . format ( ovs_id ) not in self . client . run ( '<STR_LIT>' . format ( user ) ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> return False <EOL> nova_base_path = self . _get_base_path ( '<STR_LIT>' ) <EOL> cinder_base_path = self . _get_base_path ( '<STR_LIT>' ) <EOL> if self . _stack_version in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> try : <EOL> import os_brick <EOL> cinder_brick_initiator_file = \"<STR_LIT>\" . format ( os . path . dirname ( os_brick . __file__ ) ) <EOL> except ImportError : <EOL> cinder_brick_initiator_file = '<STR_LIT>' <EOL> if self . _is_devstack is True : <EOL> nova_volume_file = '<STR_LIT>' . format ( nova_base_path ) <EOL> else : <EOL> nova_volume_file = '<STR_LIT>' . format ( self . _driver_location ) <EOL> else : <EOL> if self . _is_devstack is True : <EOL> nova_volume_file = '<STR_LIT>' . format ( nova_base_path ) <EOL> else : <EOL> nova_volume_file = '<STR_LIT>' . format ( self . _driver_location ) <EOL> cinder_brick_initiator_file = '<STR_LIT>' . format ( cinder_base_path ) <EOL> if self . _is_devstack is True : <EOL> nova_driver_file = '<STR_LIT>' . format ( nova_base_path ) <EOL> else : <EOL> nova_driver_file = '<STR_LIT>' . format ( self . _driver_location ) <EOL> file_contents = self . client . file_read ( nova_volume_file ) <EOL> if '<STR_LIT>' not in file_contents : <EOL> logger . info ( '<STR_LIT>' . format ( nova_volume_file ) ) <EOL> return False <EOL> if self . _stack_version in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> check_line = '<STR_LIT>' <EOL> else : <EOL> check_line = '<STR_LIT>' <EOL> file_contents = self . client . file_read ( nova_driver_file ) <EOL> if check_line not in file_contents : <EOL> logger . info ( '<STR_LIT>' . format ( nova_driver_file ) ) <EOL> return False <EOL> if os . path . exists ( cinder_brick_initiator_file ) : <EOL> file_contents = self . client . file_read ( cinder_brick_initiator_file ) <EOL> if self . _stack_version in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if '<STR_LIT>' not in file_contents : <EOL> logger . info ( '<STR_LIT>' . format ( cinder_brick_initiator_file ) ) <EOL> return False <EOL> else : <EOL> if '<STR_LIT>' not in file_contents : <EOL> logger . info ( '<STR_LIT>' . format ( cinder_brick_initiator_file ) ) <EOL> return False <EOL> nova_messaging_driver = '<STR_LIT>' if self . _stack_version == '<STR_LIT>' else '<STR_LIT>' <EOL> cinder_messaging_driver = '<STR_LIT>' if self . _stack_version == '<STR_LIT>' else '<STR_LIT>' <EOL> host_configured = True <EOL>", "answer": "with Remote ( ip , [ RawConfigParser ] , '<STR_LIT:root>' ) as remote :"}, {"prompt": "<s> __author__ = '<STR_LIT>' <EOL> import json <EOL> from threading import Thread , Condition <EOL> from urllib2 import Request , urlopen , URLError <EOL> from datetime import datetime , timedelta <EOL> class BtcPrice ( Thread ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ staticmethod <EOL> def instance ( ) : <EOL> return BtcPrice . __instance <EOL> def __init__ ( self ) : <EOL> Thread . __init__ ( self , name = \"<STR_LIT>\" ) <EOL> self . prices = { } <EOL> self . condition = Condition ( ) <EOL> self . keepRunning = True <EOL> self . loadPriorities = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] <EOL> BtcPrice . __instance = self <EOL> def closethread ( self ) : <EOL> self . condition . acquire ( ) <EOL> self . keepRunning = False <EOL> self . condition . notify ( ) <EOL> self . condition . release ( ) <EOL> def get ( self , currency , refresh_rates = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if refresh_rates : <EOL> self . loadPrices ( ) <EOL> self . condition . acquire ( ) <EOL> try : <EOL> last = self . prices [ currency ] <EOL> except Exception : <EOL> last = <NUM_LIT:0> <EOL> finally : <EOL> self . condition . release ( ) <EOL>", "answer": "return last"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from math import sqrt <EOL> import numpy as np <EOL> from numpy import atleast_2d as array2d <EOL> from scipy import linalg <EOL> from scipy . optimize import minimize <EOL> from scipy . spatial . distance import squareform <EOL> from openmdao . main . interfaces import implements , IMultiFiSurrogate , ISurrogate <EOL> from openmdao . main . uncertain_distributions import NormalDistribution <EOL> from openmdao . main . api import Container <EOL> import logging <EOL> _logger = logging . getLogger ( ) <EOL> MACHINE_EPSILON = np . finfo ( np . double ) . eps <EOL> NUGGET = <NUM_LIT> * MACHINE_EPSILON <EOL> INITIAL_RANGE_DEFAULT = <NUM_LIT> <EOL> TOLERANCE_DEFAULT = <NUM_LIT> <EOL> THETA0_DEFAULT = <NUM_LIT:0.5> <EOL> THETAL_DEFAULT = <NUM_LIT> <EOL> THETAU_DEFAULT = <NUM_LIT:50> <EOL> if hasattr ( linalg , '<STR_LIT>' ) : <EOL> solve_triangular = linalg . solve_triangular <EOL> else : <EOL> def solve_triangular ( x , y , lower = True ) : <EOL> return linalg . solve ( x , y ) <EOL> def constant_regression ( x ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> x = np . asarray ( x , dtype = np . float ) <EOL> n_eval = x . shape [ <NUM_LIT:0> ] <EOL> f = np . ones ( [ n_eval , <NUM_LIT:1> ] ) <EOL> return f <EOL> def linear_regression ( x ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> x = np . asarray ( x , dtype = np . float ) <EOL> n_eval = x . shape [ <NUM_LIT:0> ] <EOL> f = np . hstack ( [ np . ones ( [ n_eval , <NUM_LIT:1> ] ) , x ] ) <EOL> return f <EOL> def squared_exponential_correlation ( theta , d ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> theta = np . asarray ( theta , dtype = np . float ) <EOL> d = np . asarray ( d , dtype = np . float ) <EOL> if d . ndim > <NUM_LIT:1> : <EOL> n_features = d . shape [ <NUM_LIT:1> ] <EOL> else : <EOL> n_features = <NUM_LIT:1> <EOL> if theta . size == <NUM_LIT:1> : <EOL> return np . exp ( - theta [ <NUM_LIT:0> ] * np . sum ( d ** <NUM_LIT:2> , axis = <NUM_LIT:1> ) ) <EOL> elif theta . size != n_features : <EOL> raise ValueError ( \"<STR_LIT>\" % n_features ) <EOL> else : <EOL> return np . exp ( - np . sum ( theta . reshape ( <NUM_LIT:1> , n_features ) * d ** <NUM_LIT:2> , axis = <NUM_LIT:1> ) ) <EOL> def l1_cross_distances ( X , Y = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if Y is None : <EOL> X = array2d ( X ) <EOL> n_samples , n_features = X . shape <EOL> n_nonzero_cross_dist = n_samples * ( n_samples - <NUM_LIT:1> ) / <NUM_LIT:2> <EOL> D = np . zeros ( ( n_nonzero_cross_dist , n_features ) ) <EOL> ll_1 = <NUM_LIT:0> <EOL> for k in range ( n_samples - <NUM_LIT:1> ) : <EOL> ll_0 = ll_1 <EOL> ll_1 = ll_0 + n_samples - k - <NUM_LIT:1> <EOL> D [ ll_0 : ll_1 ] = np . abs ( X [ k ] - X [ ( k + <NUM_LIT:1> ) : ] ) <EOL> return D <EOL> else : <EOL> X = array2d ( X ) <EOL> Y = array2d ( Y ) <EOL> n_samples_X , n_features_X = X . shape <EOL> n_samples_Y , n_features_Y = Y . shape <EOL> if n_features_X != n_features_Y : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> n_features = n_features_X <EOL> n_nonzero_cross_dist = n_samples_X * n_samples_Y <EOL> D = np . zeros ( ( n_nonzero_cross_dist , n_features ) ) <EOL> ll_1 = <NUM_LIT:0> <EOL> for k in range ( n_samples_X ) : <EOL> ll_0 = ll_1 <EOL> ll_1 = ll_0 + n_samples_Y <EOL> D [ ll_0 : ll_1 ] = np . abs ( X [ k ] - Y ) <EOL> return D <EOL> class MultiFiCoKriging ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _regression_types = { <EOL> '<STR_LIT>' : constant_regression , <EOL> '<STR_LIT>' : linear_regression } <EOL> def __init__ ( self , regr = '<STR_LIT>' , rho_regr = '<STR_LIT>' , <EOL> theta = None , theta0 = None , thetaL = None , thetaU = None ) : <EOL> self . corr = squared_exponential_correlation <EOL> self . regr = regr <EOL> self . rho_regr = rho_regr <EOL> self . theta = theta <EOL> self . theta0 = theta0 <EOL> self . thetaL = thetaL <EOL> self . thetaU = thetaU <EOL> self . _nfev = <NUM_LIT:0> <EOL> def _build_R ( self , lvl , theta ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> D = self . D [ lvl ] <EOL> n_samples = self . n_samples [ lvl ] <EOL> R = np . eye ( n_samples ) * ( <NUM_LIT:1.> + NUGGET ) <EOL> corr = squareform ( self . corr ( theta , D ) ) <EOL> R = R + corr <EOL> return R <EOL> def fit ( self , X , y , <EOL> initial_range = INITIAL_RANGE_DEFAULT , tol = TOLERANCE_DEFAULT ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _check_list_structure ( X , y ) <EOL> self . _check_params ( ) <EOL> X = self . X <EOL> y = self . y <EOL> nlevel = self . nlevel <EOL> n_samples = self . n_samples <EOL> self . beta = nlevel * [ <NUM_LIT:0> ] <EOL> self . beta_rho = nlevel * [ None ] <EOL> self . beta_regr = nlevel * [ None ] <EOL> self . C = nlevel * [ <NUM_LIT:0> ] <EOL> self . D = nlevel * [ <NUM_LIT:0> ] <EOL> self . F = nlevel * [ <NUM_LIT:0> ] <EOL> self . p = nlevel * [ <NUM_LIT:0> ] <EOL> self . q = nlevel * [ <NUM_LIT:0> ] <EOL> self . G = nlevel * [ <NUM_LIT:0> ] <EOL> self . sigma2 = nlevel * [ <NUM_LIT:0> ] <EOL> self . _R_adj = nlevel * [ None ] <EOL> y_best = y [ nlevel - <NUM_LIT:1> ] <EOL> for i in range ( nlevel - <NUM_LIT:1> ) [ : : - <NUM_LIT:1> ] : <EOL> y_best = np . concatenate ( ( y [ i ] [ : - n_samples [ i + <NUM_LIT:1> ] ] , y_best ) ) <EOL> self . y_best = y_best <EOL> self . y_mean = np . zeros ( <NUM_LIT:1> ) <EOL> self . y_std = np . ones ( <NUM_LIT:1> ) <EOL> self . X_mean = np . zeros ( <NUM_LIT:1> ) <EOL> self . X_std = np . ones ( <NUM_LIT:1> ) <EOL> for lvl in range ( nlevel ) : <EOL> self . D [ lvl ] = l1_cross_distances ( X [ lvl ] ) <EOL> if ( np . min ( np . sum ( self . D [ lvl ] , axis = <NUM_LIT:1> ) ) == <NUM_LIT:0.> ) : <EOL> raise Exception ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> self . F [ lvl ] = self . regr ( X [ lvl ] ) <EOL> self . p [ lvl ] = self . F [ lvl ] . shape [ <NUM_LIT:1> ] <EOL> if lvl > <NUM_LIT:0> : <EOL> F_rho = self . rho_regr ( X [ lvl ] ) <EOL> self . q [ lvl ] = F_rho . shape [ <NUM_LIT:1> ] <EOL> self . F [ lvl ] = np . hstack ( ( F_rho * np . dot ( ( self . y [ lvl - <NUM_LIT:1> ] ) [ - n_samples [ lvl ] : ] , <EOL> np . ones ( ( <NUM_LIT:1> , self . q [ lvl ] ) ) ) , self . F [ lvl ] ) ) <EOL> else : <EOL> self . q [ lvl ] = <NUM_LIT:0> <EOL> n_samples_F_i = self . F [ lvl ] . shape [ <NUM_LIT:0> ] <EOL> if n_samples_F_i != n_samples [ lvl ] : <EOL> raise Exception ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> if int ( self . p [ lvl ] + self . q [ lvl ] ) >= n_samples_F_i : <EOL> raise Exception ( ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> % ( n_samples [ i ] , self . p [ lvl ] + self . q [ lvl ] ) ) <EOL> self . X = X <EOL> self . y = y <EOL> self . rlf_value = np . zeros ( nlevel ) <EOL> for lvl in range ( nlevel ) : <EOL> if self . theta [ lvl ] is None : <EOL> sol = self . _max_rlf ( lvl = lvl , initial_range = initial_range , tol = tol ) <EOL> self . theta [ lvl ] = sol [ '<STR_LIT>' ] <EOL> self . rlf_value [ lvl ] = sol [ '<STR_LIT>' ] <EOL> if np . isinf ( self . rlf_value [ lvl ] ) : <EOL> raise Exception ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> else : <EOL> self . rlf_value [ lvl ] = self . rlf ( lvl = lvl ) <EOL> if np . isinf ( self . rlf_value [ lvl ] ) : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> return <EOL> def rlf ( self , lvl , theta = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if theta is None : <EOL> theta = self . theta [ lvl ] <EOL> rlf_value = <NUM_LIT> <EOL> n_samples = self . n_samples [ lvl ] <EOL> y = self . y [ lvl ] <EOL> F = self . F [ lvl ] <EOL> p = self . p [ lvl ] <EOL> q = self . q [ lvl ] <EOL> R = self . _build_R ( lvl , theta ) <EOL> try : <EOL> C = linalg . cholesky ( R , lower = True ) <EOL> except linalg . LinAlgError : <EOL> _logger . warning ( ( '<STR_LIT>' % lvl ) + <EOL> '<STR_LIT>' + str ( theta ) ) <EOL> return rlf_value <EOL> Ft = solve_triangular ( C , F , lower = True ) <EOL> Yt = solve_triangular ( C , y , lower = True ) <EOL> try : <EOL> Q , G = linalg . qr ( Ft , econ = True ) <EOL> except : <EOL> Q , G = linalg . qr ( Ft , mode = '<STR_LIT>' ) <EOL> pass <EOL> beta = solve_triangular ( G , np . dot ( Q . T , Yt ) ) <EOL> err = Yt - np . dot ( Ft , beta ) <EOL> err2 = np . dot ( err . T , err ) [ <NUM_LIT:0> , <NUM_LIT:0> ] <EOL> self . _err = err <EOL> sigma2 = err2 / ( n_samples - p - q ) <EOL> detR = ( ( np . diag ( C ) ) ** ( <NUM_LIT> / n_samples ) ) . prod ( ) <EOL> rlf_value = ( n_samples - p - q ) * np . log10 ( sigma2 ) + n_samples * np . log10 ( detR ) <EOL> self . beta_rho [ lvl ] = beta [ : q ] <EOL> self . beta_regr [ lvl ] = beta [ q : ] <EOL> self . beta [ lvl ] = beta <EOL> self . sigma2 [ lvl ] = sigma2 <EOL> self . C [ lvl ] = C <EOL> self . G [ lvl ] = G <EOL> return rlf_value <EOL> def _max_rlf ( self , lvl , initial_range , tol ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import codecs <EOL> class Codec ( codecs . Codec ) : <EOL> encode = staticmethod ( codecs . utf_7_encode ) <EOL> decode = staticmethod ( codecs . utf_7_decode ) <EOL> class IncrementalEncoder ( codecs . IncrementalEncoder ) : <EOL> def encode ( self , input , final = False ) : <EOL> return codecs . utf_7_encode ( input , self . errors ) [ <NUM_LIT:0> ] <EOL> class IncrementalDecoder ( codecs . BufferedIncrementalDecoder ) : <EOL> def _buffer_decode ( self , input , errors , final ) : <EOL> return codecs . utf_7_decode ( input , self . errors ) <EOL> class StreamWriter ( Codec , codecs . StreamWriter ) : <EOL> pass <EOL> class StreamReader ( Codec , codecs . StreamReader ) : <EOL> pass <EOL> def getregentry ( ) : <EOL> return codecs . CodecInfo ( <EOL> name = '<STR_LIT>' , <EOL> encode = Codec . encode , <EOL>", "answer": "decode = Codec . decode ,"}, {"prompt": "<s> from datetime import datetime , timedelta <EOL> import operator <EOL> from itertools import product , starmap <EOL> from numpy import nan , inf <EOL> import numpy as np <EOL> import pandas as pd <EOL> from pandas import ( Index , Series , DataFrame , isnull , bdate_range , <EOL> NaT , date_range , timedelta_range , <EOL> _np_version_under1p8 ) <EOL> from pandas . tseries . index import Timestamp <EOL> from pandas . tseries . tdi import Timedelta <EOL> import pandas . core . nanops as nanops <EOL> from pandas . compat import range , zip <EOL> from pandas import compat <EOL> from pandas . util . testing import assert_series_equal , assert_almost_equal <EOL> import pandas . util . testing as tm <EOL> from . common import TestData <EOL> class TestSeriesOperators ( TestData , tm . TestCase ) : <EOL> _multiprocess_can_split_ = True <EOL> def test_comparisons ( self ) : <EOL> left = np . random . randn ( <NUM_LIT:10> ) <EOL> right = np . random . randn ( <NUM_LIT:10> ) <EOL> left [ : <NUM_LIT:3> ] = np . nan <EOL> result = nanops . nangt ( left , right ) <EOL> expected = ( left > right ) . astype ( '<STR_LIT:O>' ) <EOL> expected [ : <NUM_LIT:3> ] = np . nan <EOL> assert_almost_equal ( result , expected ) <EOL> s = Series ( [ '<STR_LIT:a>' , '<STR_LIT:b>' , '<STR_LIT:c>' ] ) <EOL> s2 = Series ( [ False , True , False ] ) <EOL> s == s2 <EOL> s2 == s <EOL> def test_op_method ( self ) : <EOL> def check ( series , other , check_reverse = False ) : <EOL> simple_ops = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> if not compat . PY3 : <EOL> simple_ops . append ( '<STR_LIT>' ) <EOL> for opname in simple_ops : <EOL> op = getattr ( Series , opname ) <EOL> if op == '<STR_LIT>' : <EOL> alt = operator . truediv <EOL> else : <EOL> alt = getattr ( operator , opname ) <EOL> result = op ( series , other ) <EOL> expected = alt ( series , other ) <EOL> tm . assert_almost_equal ( result , expected ) <EOL> if check_reverse : <EOL> rop = getattr ( Series , \"<STR_LIT:r>\" + opname ) <EOL> result = rop ( series , other ) <EOL> expected = alt ( other , series ) <EOL> tm . assert_almost_equal ( result , expected ) <EOL> check ( self . ts , self . ts * <NUM_LIT:2> ) <EOL> check ( self . ts , self . ts [ : : <NUM_LIT:2> ] ) <EOL> check ( self . ts , <NUM_LIT:5> , check_reverse = True ) <EOL> check ( tm . makeFloatSeries ( ) , tm . makeFloatSeries ( ) , check_reverse = True ) <EOL> def test_neg ( self ) : <EOL> assert_series_equal ( - self . series , - <NUM_LIT:1> * self . series ) <EOL> def test_invert ( self ) : <EOL> assert_series_equal ( - ( self . series < <NUM_LIT:0> ) , ~ ( self . series < <NUM_LIT:0> ) ) <EOL> def test_div ( self ) : <EOL> p = DataFrame ( { '<STR_LIT>' : [ <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> , <NUM_LIT:8> ] , '<STR_LIT>' : [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:3> ] } ) <EOL> result = p [ '<STR_LIT>' ] / p [ '<STR_LIT>' ] <EOL> expected = Series ( p [ '<STR_LIT>' ] . values . astype ( float ) / p [ '<STR_LIT>' ] . values , <EOL> dtype = '<STR_LIT>' ) <EOL> expected . iloc [ <NUM_LIT:0> : <NUM_LIT:3> ] = np . inf <EOL> assert_series_equal ( result , expected ) <EOL> result = p [ '<STR_LIT>' ] / <NUM_LIT:0> <EOL> expected = Series ( np . inf , index = p . index , name = '<STR_LIT>' ) <EOL> assert_series_equal ( result , expected ) <EOL> p = p . astype ( '<STR_LIT>' ) <EOL> result = p [ '<STR_LIT>' ] / p [ '<STR_LIT>' ] <EOL> expected = Series ( p [ '<STR_LIT>' ] . values / p [ '<STR_LIT>' ] . values ) <EOL> assert_series_equal ( result , expected ) <EOL> p = DataFrame ( { '<STR_LIT>' : [ <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:5> , <NUM_LIT:8> ] , '<STR_LIT>' : [ <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:1> ] } ) <EOL> result = p [ '<STR_LIT>' ] / p [ '<STR_LIT>' ] <EOL> assert_series_equal ( result , p [ '<STR_LIT>' ] . astype ( '<STR_LIT>' ) , <EOL> check_names = False ) <EOL> self . assertTrue ( result . name is None ) <EOL> self . assertFalse ( np . array_equal ( result , p [ '<STR_LIT>' ] / p [ '<STR_LIT>' ] ) ) <EOL> s = Series ( [ np . nan , <NUM_LIT:1.> , - <NUM_LIT:1.> ] ) <EOL> result = s / <NUM_LIT:0> <EOL> expected = Series ( [ np . nan , np . inf , - np . inf ] ) <EOL> assert_series_equal ( result , expected ) <EOL> p = DataFrame ( { '<STR_LIT>' : ( <NUM_LIT:1> , <NUM_LIT:0> ) , '<STR_LIT>' : ( - <NUM_LIT> , - <NUM_LIT> ) } ) <EOL> expected = Series ( [ - <NUM_LIT> , - np . inf ] ) <EOL> result = p [ '<STR_LIT>' ] . div ( p [ '<STR_LIT>' ] ) <EOL> assert_series_equal ( result , expected , check_names = False ) <EOL> result = p [ '<STR_LIT>' ] / p [ '<STR_LIT>' ] <EOL> assert_series_equal ( result , expected ) <EOL> s = Series ( [ - <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> ] ) <EOL> result = <NUM_LIT:0> / s <EOL> expected = Series ( [ <NUM_LIT:0.0> , nan , <NUM_LIT:0.0> ] ) <EOL> assert_series_equal ( result , expected ) <EOL> result = s / <NUM_LIT:0> <EOL> expected = Series ( [ - inf , nan , inf ] ) <EOL> assert_series_equal ( result , expected ) <EOL> result = s // <NUM_LIT:0> <EOL> expected = Series ( [ - inf , nan , inf ] ) <EOL> assert_series_equal ( result , expected ) <EOL> def test_operators ( self ) : <EOL> def _check_op ( series , other , op , pos_only = False , <EOL> check_dtype = True ) : <EOL> left = np . abs ( series ) if pos_only else series <EOL> right = np . abs ( other ) if pos_only else other <EOL>", "answer": "cython_or_numpy = op ( left , right )"}, {"prompt": "<s> from distutils . core import setup <EOL> setup ( name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL>", "answer": "url = '<STR_LIT>' ,"}, {"prompt": "<s> import sys <EOL> import config <EOL> def ErrorIgnore ( fn , * args , ** kwargs ) : <EOL> def wrapped ( * args , ** kwargs ) : <EOL> try : <EOL> result = fn ( * args , ** kwargs ) <EOL> return result <EOL> except : <EOL> print '<STR_LIT>' <EOL> return None <EOL> return wrapped <EOL> @ ErrorIgnore <EOL> def print_line ( msg , oneLine = False ) : <EOL> if oneLine : <EOL> sys . stdout . write ( '<STR_LIT:U+0020>' * <NUM_LIT> + '<STR_LIT:\\r>' ) <EOL> sys . stdout . flush ( ) <EOL> else : <EOL> sys . stdout . write ( '<STR_LIT:\\n>' ) <EOL> sys . stdout . write ( msg ) <EOL>", "answer": "sys . stdout . flush ( ) "}, {"prompt": "<s> import json <EOL> import logging <EOL> import requests <EOL> from . import reader <EOL> LOG = logging . getLogger ( __name__ ) <EOL> def delete_metric ( conn , metric ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> delete_url = conn . delete_metric_url + str ( metric ) <EOL> r = requests . delete ( delete_url ) <EOL> if r . status_code != <NUM_LIT> : <EOL> LOG . exception ( '<STR_LIT>' ) % ( <EOL> metric , r . status_code ) <EOL> raise <EOL> def delete_metrics ( conn , metric_names_list ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for metric in metric_names_list : <EOL> delete_metric ( conn , metric ) <EOL> def delete_datapoints ( conn , metric_names_list , start_time , <EOL> end_time = None , tags = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "query = reader . _query_absolute ( start = start_time , end = end_time )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function <EOL> import re <EOL> from . import ( <EOL> make_error_format , <EOL> match_pattern , <EOL> ) <EOL> def match_file_location ( line ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return match_pattern ( <EOL> r'<STR_LIT>' , <EOL> line , <EOL> ) <EOL> def match_code_pattern ( line ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return re . compile ( r\"<STR_LIT>\" ) . match ( line ) is not None <EOL> def parse_traceback ( lines ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> file_location = None <EOL> result = [ ] <EOL> for line in lines : <EOL> result . append ( line ) <EOL> location = match_file_location ( line ) <EOL> if location : <EOL> file_location = location <EOL> continue <EOL> elif match_code_pattern ( line ) : <EOL> continue <EOL> else : <EOL> if file_location : <EOL> result . append ( <EOL> make_error_format ( <EOL>", "answer": "file_location [ '<STR_LIT>' ] ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . cryptomath import * <EOL> from . rsakey import * <EOL> from . python_rsakey import Python_RSAKey <EOL> def password_callback ( v , prompt1 = '<STR_LIT>' , <EOL> prompt2 = '<STR_LIT>' ) : <EOL> from getpass import getpass <EOL> while <NUM_LIT:1> : <EOL> try : <EOL> p1 = getpass ( prompt1 ) <EOL> if v : <EOL> p2 = getpass ( prompt2 ) <EOL> if p1 == p2 : <EOL> break <EOL> else : <EOL> break <EOL>", "answer": "except KeyboardInterrupt :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import time <EOL>", "answer": "from ovs . dal . dataobject import DataObject"}, {"prompt": "<s> import tornado . web <EOL> import time <EOL> from base import BaseHandler <EOL> from util . common import feed_number <EOL> class HomeHandler ( BaseHandler ) : <EOL> def get ( self ) : <EOL> if self . current_user : <EOL> template_values = { } <EOL> template_values [ '<STR_LIT>' ] = self . uag . get_all_activities ( self . db , <NUM_LIT:0> , False ) <EOL> template_values [ '<STR_LIT>' ] = feed_number <EOL> template_values [ '<STR_LIT>' ] = <NUM_LIT:1> <EOL> if template_values [ '<STR_LIT>' ] >= self . uag . count_all_activity ( ) : <EOL> template_values [ '<STR_LIT>' ] = <NUM_LIT:0> <EOL> template_values [ '<STR_LIT>' ] = self . uag . count_all_activity ( ) <EOL> self . render ( \"<STR_LIT>\" , template_values = template_values ) <EOL> else : <EOL> self . render ( \"<STR_LIT>\" ) <EOL> class MyhomeHandler ( BaseHandler ) : <EOL> def get ( self ) : <EOL> if self . current_user : <EOL> template_values = { } <EOL> template_values [ '<STR_LIT>' ] = self . uag . get_my_activities ( self . db , self . current_user . id , <NUM_LIT:0> ) <EOL> template_values [ '<STR_LIT>' ] = feed_number <EOL> template_values [ '<STR_LIT>' ] = <NUM_LIT:1> <EOL> if template_values [ '<STR_LIT>' ] >= self . uag . count_my_activity ( self . current_user . id ) : <EOL> template_values [ '<STR_LIT>' ] = <NUM_LIT:0> <EOL> self . render ( \"<STR_LIT>\" , template_values = template_values ) <EOL> else : <EOL> self . render ( \"<STR_LIT>\" ) <EOL> class HomepollHandler ( BaseHandler ) : <EOL> @ tornado . web . asynchronous <EOL> def post ( self ) : <EOL> self . get_data ( callback = self . to_finish ) <EOL> def get_data ( self , callback ) : <EOL> if self . request . connection . stream . closed ( ) : <EOL> return <EOL> template_values = { } <EOL> lastitem = self . get_argument ( \"<STR_LIT>\" , None ) <EOL> lastitem = int ( lastitem ) <EOL> newcount = self . uag . count_all_activity ( ) <EOL> if lastitem < newcount : <EOL> new_activities = self . uag . get_all_activities ( self . db , lastitem , newcount - lastitem ) <EOL> new_activities = filter ( lambda activity : activity [ - <NUM_LIT:2> ] != '<STR_LIT:status>' and activity [ - <NUM_LIT:6> ] != self . current_user . id , new_activities ) <EOL> template_values [ '<STR_LIT>' ] = new_activities <EOL> template_values [ '<STR_LIT>' ] = <NUM_LIT:0> <EOL> template_values [ '<STR_LIT>' ] = newcount <EOL> elif lastitem > newcount : <EOL> template_values [ '<STR_LIT>' ] = { } <EOL> template_values [ '<STR_LIT>' ] = <NUM_LIT:0> <EOL> template_values [ '<STR_LIT>' ] = newcount <EOL>", "answer": "callback ( template_values )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import re <EOL> from inspect import cleandoc <EOL> from itertools import chain <EOL> import textwrap <EOL> from jedi . _compatibility import ( Python3Method , encoding , is_py3 , utf8_repr , <EOL> literal_eval , use_metaclass , unicode ) <EOL> from jedi import cache <EOL> def is_node ( node , * symbol_names ) : <EOL> try : <EOL> type = node . type <EOL> except AttributeError : <EOL> return False <EOL> else : <EOL> return type in symbol_names <EOL> class PositionModifier ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> self . line = <NUM_LIT:0> <EOL> zero_position_modifier = PositionModifier ( ) <EOL> class DocstringMixin ( object ) : <EOL> __slots__ = ( ) <EOL> @ property <EOL> def raw_doc ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( self , Module ) : <EOL> node = self . children [ <NUM_LIT:0> ] <EOL> elif isinstance ( self , ClassOrFunc ) : <EOL> node = self . children [ self . children . index ( '<STR_LIT::>' ) + <NUM_LIT:1> ] <EOL> if is_node ( node , '<STR_LIT>' ) : <EOL> node = node . children [ <NUM_LIT:2> ] <EOL> else : <EOL> simple_stmt = self . parent <EOL> c = simple_stmt . parent . children <EOL> index = c . index ( simple_stmt ) <EOL> if not index : <EOL> return '<STR_LIT>' <EOL> node = c [ index - <NUM_LIT:1> ] <EOL> if is_node ( node , '<STR_LIT>' ) : <EOL> node = node . children [ <NUM_LIT:0> ] <EOL> if node . type == '<STR_LIT:string>' : <EOL> cleaned = cleandoc ( literal_eval ( node . value ) ) <EOL> if is_py3 or isinstance ( cleaned , unicode ) : <EOL> return cleaned <EOL> else : <EOL> return unicode ( cleaned , '<STR_LIT>' , '<STR_LIT:replace>' ) <EOL> return '<STR_LIT>' <EOL> class Base ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __slots__ = ( ) <EOL> def isinstance ( self , * cls ) : <EOL> return isinstance ( self , cls ) <EOL> @ Python3Method <EOL> def get_parent_until ( self , classes = ( ) , reverse = False , <EOL> include_current = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if type ( classes ) not in ( tuple , list ) : <EOL> classes = ( classes , ) <EOL> scope = self if include_current else self . parent <EOL> while scope . parent is not None : <EOL> if classes and reverse != scope . isinstance ( * classes ) : <EOL> break <EOL> scope = scope . parent <EOL> return scope <EOL> def get_parent_scope ( self , include_flows = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> scope = self . parent <EOL> while scope is not None : <EOL> if include_flows and isinstance ( scope , Flow ) : <EOL> return scope <EOL> if scope . is_scope ( ) : <EOL> break <EOL> scope = scope . parent <EOL> return scope <EOL> def is_scope ( self ) : <EOL> return False <EOL> class Leaf ( Base ) : <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT:value>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , position_modifier , value , start_pos , prefix = '<STR_LIT>' ) : <EOL> self . position_modifier = position_modifier <EOL> self . value = value <EOL> self . _start_pos = start_pos <EOL> self . prefix = prefix <EOL> self . parent = None <EOL> @ property <EOL> def start_pos ( self ) : <EOL> return self . _start_pos [ <NUM_LIT:0> ] + self . position_modifier . line , self . _start_pos [ <NUM_LIT:1> ] <EOL> @ start_pos . setter <EOL> def start_pos ( self , value ) : <EOL> self . _start_pos = value [ <NUM_LIT:0> ] - self . position_modifier . line , value [ <NUM_LIT:1> ] <EOL> @ property <EOL> def end_pos ( self ) : <EOL> return ( self . _start_pos [ <NUM_LIT:0> ] + self . position_modifier . line , <EOL> self . _start_pos [ <NUM_LIT:1> ] + len ( self . value ) ) <EOL> def move ( self , line_offset , column_offset ) : <EOL> self . _start_pos = ( self . _start_pos [ <NUM_LIT:0> ] + line_offset , <EOL> self . _start_pos [ <NUM_LIT:1> ] + column_offset ) <EOL> def get_previous ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> node = self <EOL> while True : <EOL> c = node . parent . children <EOL> i = c . index ( self ) <EOL> if i == <NUM_LIT:0> : <EOL> node = node . parent <EOL> if node . parent is None : <EOL> raise IndexError ( '<STR_LIT>' ) <EOL> else : <EOL> node = c [ i - <NUM_LIT:1> ] <EOL> break <EOL> while True : <EOL> try : <EOL> node = node . children [ - <NUM_LIT:1> ] <EOL> except AttributeError : <EOL> return node <EOL> def get_code ( self ) : <EOL> return self . prefix + self . value <EOL> def next_sibling ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for i , child in enumerate ( self . parent . children ) : <EOL> if child is self : <EOL> try : <EOL> return self . parent . children [ i + <NUM_LIT:1> ] <EOL> except IndexError : <EOL> return None <EOL> def prev_sibling ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for i , child in enumerate ( self . parent . children ) : <EOL> if child is self : <EOL> if i == <NUM_LIT:0> : <EOL> return None <EOL> return self . parent . children [ i - <NUM_LIT:1> ] <EOL> @ utf8_repr <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( type ( self ) . __name__ , self . value ) <EOL> class LeafWithNewLines ( Leaf ) : <EOL> __slots__ = ( ) <EOL> @ property <EOL> def end_pos ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> end_pos_line , end_pos_col = self . start_pos <EOL> lines = self . value . split ( '<STR_LIT:\\n>' ) <EOL> end_pos_line += len ( lines ) - <NUM_LIT:1> <EOL> if self . start_pos [ <NUM_LIT:0> ] == end_pos_line : <EOL> end_pos_col += len ( lines [ - <NUM_LIT:1> ] ) <EOL> else : <EOL> end_pos_col = len ( lines [ - <NUM_LIT:1> ] ) <EOL> return end_pos_line , end_pos_col <EOL> @ utf8_repr <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( type ( self ) . __name__ , self . value ) <EOL> class Whitespace ( LeafWithNewLines ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __slots__ = ( ) <EOL> type = '<STR_LIT>' <EOL> class Name ( Leaf ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> type = '<STR_LIT:name>' <EOL> __slots__ = ( ) <EOL> def __str__ ( self ) : <EOL> return self . value <EOL> def __unicode__ ( self ) : <EOL> return self . value <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( type ( self ) . __name__ , self . value , <EOL> self . start_pos [ <NUM_LIT:0> ] , self . start_pos [ <NUM_LIT:1> ] ) <EOL> def get_definition ( self ) : <EOL> scope = self <EOL> while scope . parent is not None : <EOL> parent = scope . parent <EOL> if scope . isinstance ( Node , Name ) and parent . type != '<STR_LIT>' : <EOL> if scope . type == '<STR_LIT>' : <EOL> try : <EOL> if isinstance ( scope . children [ <NUM_LIT:1> ] , CompFor ) : <EOL> return scope . children [ <NUM_LIT:1> ] <EOL> except IndexError : <EOL> pass <EOL> scope = parent <EOL> else : <EOL> break <EOL> return scope <EOL> def is_definition ( self ) : <EOL> stmt = self . get_definition ( ) <EOL> if stmt . type in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> return self == stmt . name <EOL> elif stmt . type == '<STR_LIT>' : <EOL> return self . start_pos < stmt . children [ <NUM_LIT:2> ] . start_pos <EOL> elif stmt . type == '<STR_LIT>' : <EOL> return self . prev_sibling ( ) == '<STR_LIT>' <EOL> else : <EOL> return stmt . type in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ) and self in stmt . get_defined_names ( ) <EOL> def assignment_indexes ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> indexes = [ ] <EOL> node = self . parent <EOL> compare = self <EOL> while node is not None : <EOL> if is_node ( node , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> for i , child in enumerate ( node . children ) : <EOL> if child == compare : <EOL> indexes . insert ( <NUM_LIT:0> , int ( i / <NUM_LIT:2> ) ) <EOL> break <EOL> else : <EOL> raise LookupError ( \"<STR_LIT>\" ) <EOL> elif isinstance ( node , ( ExprStmt , CompFor ) ) : <EOL> break <EOL> compare = node <EOL> node = node . parent <EOL> return indexes <EOL> class Literal ( LeafWithNewLines ) : <EOL> __slots__ = ( ) <EOL> def eval ( self ) : <EOL> return literal_eval ( self . value ) <EOL> class Number ( Literal ) : <EOL> type = '<STR_LIT>' <EOL> __slots__ = ( ) <EOL> class String ( Literal ) : <EOL> type = '<STR_LIT:string>' <EOL> __slots__ = ( ) <EOL> class Operator ( Leaf ) : <EOL> type = '<STR_LIT>' <EOL> __slots__ = ( ) <EOL> def __str__ ( self ) : <EOL> return self . value <EOL> def __eq__ ( self , other ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( other , Operator ) : <EOL> return self is other <EOL> else : <EOL> return self . value == other <EOL> def __ne__ ( self , other ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . value != other <EOL> def __hash__ ( self ) : <EOL> return hash ( self . value ) <EOL> class Keyword ( Leaf ) : <EOL> type = '<STR_LIT>' <EOL> __slots__ = ( ) <EOL> def __eq__ ( self , other ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( other , Keyword ) : <EOL> return self is other <EOL> return self . value == other <EOL> def __ne__ ( self , other ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return not self . __eq__ ( other ) <EOL> def __hash__ ( self ) : <EOL> return hash ( self . value ) <EOL> class BaseNode ( Base ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> type = None <EOL> def __init__ ( self , children ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for c in children : <EOL> c . parent = self <EOL> self . children = children <EOL> self . parent = None <EOL> def move ( self , line_offset , column_offset ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for c in self . children : <EOL> c . move ( line_offset , column_offset ) <EOL> @ property <EOL> def start_pos ( self ) : <EOL> return self . children [ <NUM_LIT:0> ] . start_pos <EOL> @ property <EOL> def end_pos ( self ) : <EOL> return self . children [ - <NUM_LIT:1> ] . end_pos <EOL> def get_code ( self ) : <EOL> return \"<STR_LIT>\" . join ( c . get_code ( ) for c in self . children ) <EOL> @ Python3Method <EOL> def name_for_position ( self , position ) : <EOL> for c in self . children : <EOL> if isinstance ( c , Leaf ) : <EOL> if isinstance ( c , Name ) and c . start_pos <= position <= c . end_pos : <EOL> return c <EOL> else : <EOL> result = c . name_for_position ( position ) <EOL> if result is not None : <EOL> return result <EOL> return None <EOL> @ Python3Method <EOL> def get_statement_for_position ( self , pos ) : <EOL> for c in self . children : <EOL> if c . start_pos <= pos <= c . end_pos : <EOL> if c . type not in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) and not isinstance ( c , ( Flow , ClassOrFunc ) ) : <EOL> return c <EOL> else : <EOL> try : <EOL> return c . get_statement_for_position ( pos ) <EOL> except AttributeError : <EOL> pass <EOL> return None <EOL> def first_leaf ( self ) : <EOL> try : <EOL> return self . children [ <NUM_LIT:0> ] . first_leaf ( ) <EOL> except AttributeError : <EOL> return self . children [ <NUM_LIT:0> ] <EOL> @ utf8_repr <EOL> def __repr__ ( self ) : <EOL> code = self . get_code ( ) . replace ( '<STR_LIT:\\n>' , '<STR_LIT:U+0020>' ) <EOL> if not is_py3 : <EOL> code = code . encode ( encoding , '<STR_LIT:replace>' ) <EOL> return \"<STR_LIT>\" % ( type ( self ) . __name__ , code , self . start_pos [ <NUM_LIT:0> ] , self . start_pos [ <NUM_LIT:1> ] ) <EOL> class Node ( BaseNode ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __slots__ = ( '<STR_LIT:type>' , ) <EOL> def __init__ ( self , type , children ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( Node , self ) . __init__ ( children ) <EOL> self . type = type <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % ( self . __class__ . __name__ , self . type , self . children ) <EOL> class IsScopeMeta ( type ) : <EOL> def __instancecheck__ ( self , other ) : <EOL> return other . is_scope ( ) <EOL> class IsScope ( use_metaclass ( IsScopeMeta ) ) : <EOL> pass <EOL> class Scope ( BaseNode , DocstringMixin ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __slots__ = ( '<STR_LIT>' , ) <EOL> def __init__ ( self , children ) : <EOL> super ( Scope , self ) . __init__ ( children ) <EOL> @ property <EOL> def returns ( self ) : <EOL> return self . _search_in_scope ( ReturnStmt ) <EOL> @ property <EOL> def subscopes ( self ) : <EOL> return self . _search_in_scope ( Scope ) <EOL> @ property <EOL> def flows ( self ) : <EOL> return self . _search_in_scope ( Flow ) <EOL> @ property <EOL> def imports ( self ) : <EOL> return self . _search_in_scope ( Import ) <EOL> @ Python3Method <EOL> def _search_in_scope ( self , typ ) : <EOL> def scan ( children ) : <EOL> elements = [ ] <EOL> for element in children : <EOL> if isinstance ( element , typ ) : <EOL> elements . append ( element ) <EOL> if is_node ( element , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) or isinstance ( element , Flow ) : <EOL> elements += scan ( element . children ) <EOL> return elements <EOL> return scan ( self . children ) <EOL> @ property <EOL> def statements ( self ) : <EOL> return self . _search_in_scope ( ( ExprStmt , KeywordStatement ) ) <EOL> def is_scope ( self ) : <EOL> return True <EOL> def __repr__ ( self ) : <EOL> try : <EOL> name = self . path <EOL> except AttributeError : <EOL> try : <EOL> name = self . name <EOL> except AttributeError : <EOL> name = self . command <EOL> return \"<STR_LIT>\" % ( type ( self ) . __name__ , name , <EOL> self . start_pos [ <NUM_LIT:0> ] , self . end_pos [ <NUM_LIT:0> ] ) <EOL> def walk ( self ) : <EOL> yield self <EOL> for s in self . subscopes : <EOL> for scope in s . walk ( ) : <EOL> yield scope <EOL> for r in self . statements : <EOL> while isinstance ( r , Flow ) : <EOL> for scope in r . walk ( ) : <EOL> yield scope <EOL> r = r . next <EOL> class Module ( Scope ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __slots__ = ( '<STR_LIT:path>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> type = '<STR_LIT>' <EOL> def __init__ ( self , children ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( Module , self ) . __init__ ( children ) <EOL> self . path = None <EOL> @ property <EOL> @ cache . underscore_memoization <EOL> def name ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . path is None : <EOL> string = '<STR_LIT>' <EOL> else : <EOL> sep = ( re . escape ( os . path . sep ) , ) * <NUM_LIT:2> <EOL> r = re . search ( r'<STR_LIT>' % sep , self . path ) <EOL> string = re . sub ( '<STR_LIT>' , '<STR_LIT>' , r . group ( <NUM_LIT:1> ) ) <EOL> p = ( <NUM_LIT:1> , <NUM_LIT:0> ) <EOL> name = Name ( zero_position_modifier , string , p ) <EOL> name . parent = self <EOL> return name <EOL> @ property <EOL> def has_explicit_absolute_import ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for imp in self . imports : <EOL> if imp . type == '<STR_LIT>' and imp . level == <NUM_LIT:0> : <EOL> for path in imp . paths ( ) : <EOL> if [ str ( name ) for name in path ] == [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> return True <EOL> return False <EOL> class Decorator ( BaseNode ) : <EOL> type = '<STR_LIT>' <EOL> __slots__ = ( ) <EOL> class ClassOrFunc ( Scope ) : <EOL> __slots__ = ( ) <EOL> @ property <EOL> def name ( self ) : <EOL> return self . children [ <NUM_LIT:1> ] <EOL> def get_decorators ( self ) : <EOL> decorated = self . parent <EOL> if is_node ( decorated , '<STR_LIT>' ) : <EOL> if is_node ( decorated . children [ <NUM_LIT:0> ] , '<STR_LIT>' ) : <EOL> return decorated . children [ <NUM_LIT:0> ] . children <EOL>", "answer": "else :"}, {"prompt": "<s> import netaddr <EOL> from oslo_config import cfg <EOL> from oslo_log import log as logging <EOL> import sqlalchemy as sa <EOL> from sqlalchemy import orm <EOL> from neutron . _i18n import _ <EOL> from neutron . common import utils <EOL> from neutron . db import db_base_plugin_v2 <EOL> from neutron . db import l3_db <EOL> from neutron . db import model_base <EOL> from neutron . db import models_v2 <EOL> from neutron . extensions import extraroute <EOL> from neutron . extensions import l3 <EOL> LOG = logging . getLogger ( __name__ ) <EOL> extra_route_opts = [ <EOL> cfg . IntOpt ( '<STR_LIT>' , default = <NUM_LIT:30> , <EOL> help = _ ( \"<STR_LIT>\" ) ) , <EOL> ] <EOL> cfg . CONF . register_opts ( extra_route_opts ) <EOL> class RouterRoute ( model_base . BASEV2 , models_v2 . Route ) : <EOL> router_id = sa . Column ( sa . String ( <NUM_LIT> ) , <EOL> sa . ForeignKey ( '<STR_LIT>' , <EOL> ondelete = \"<STR_LIT>\" ) , <EOL> primary_key = True ) <EOL> router = orm . relationship ( l3_db . Router , <EOL> backref = orm . backref ( \"<STR_LIT>\" , <EOL> lazy = '<STR_LIT>' , <EOL> cascade = '<STR_LIT>' ) ) <EOL> class ExtraRoute_dbonly_mixin ( l3_db . L3_NAT_dbonly_mixin ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _extend_router_dict_extraroute ( self , router_res , router_db ) : <EOL> router_res [ '<STR_LIT>' ] = ( ExtraRoute_dbonly_mixin . <EOL> _make_extra_route_list ( <EOL> router_db [ '<STR_LIT>' ] <EOL> ) ) <EOL> db_base_plugin_v2 . NeutronDbPluginV2 . register_dict_extend_funcs ( <EOL> l3 . ROUTERS , [ '<STR_LIT>' ] ) <EOL> def update_router ( self , context , id , router ) : <EOL> r = router [ '<STR_LIT>' ] <EOL> with context . session . begin ( subtransactions = True ) : <EOL> router_db = self . _get_router ( context , id ) <EOL> if '<STR_LIT>' in r : <EOL> self . _update_extra_routes ( context , router_db , r [ '<STR_LIT>' ] ) <EOL> routes = self . _get_extra_routes_by_router_id ( context , id ) <EOL> router_updated = super ( ExtraRoute_dbonly_mixin , self ) . update_router ( <EOL> context , id , router ) <EOL> router_updated [ '<STR_LIT>' ] = routes <EOL> return router_updated <EOL> def _get_subnets_by_cidr ( self , context , cidr ) : <EOL> query_subnets = context . session . query ( models_v2 . Subnet ) <EOL> return query_subnets . filter_by ( cidr = cidr ) . all ( ) <EOL> def _validate_routes_nexthop ( self , cidrs , ips , routes , nexthop ) : <EOL> if not netaddr . all_matching_cidrs ( nexthop , cidrs ) : <EOL> raise extraroute . InvalidRoutes ( <EOL> routes = routes , <EOL> reason = _ ( '<STR_LIT>' ) ) <EOL> if nexthop in ips : <EOL> raise extraroute . InvalidRoutes ( <EOL> routes = routes , <EOL> reason = _ ( '<STR_LIT>' ) ) <EOL> def _validate_routes ( self , context , <EOL> router_id , routes ) : <EOL> if len ( routes ) > cfg . CONF . max_routes : <EOL> raise extraroute . RoutesExhausted ( <EOL> router_id = router_id , <EOL> quota = cfg . CONF . max_routes ) <EOL> context = context . elevated ( ) <EOL> filters = { '<STR_LIT>' : [ router_id ] } <EOL> ports = self . _core_plugin . get_ports ( context , filters ) <EOL> cidrs = [ ] <EOL> ips = [ ] <EOL> for port in ports : <EOL> for ip in port [ '<STR_LIT>' ] : <EOL> cidrs . append ( self . _core_plugin . get_subnet ( <EOL> context , ip [ '<STR_LIT>' ] ) [ '<STR_LIT>' ] ) <EOL> ips . append ( ip [ '<STR_LIT>' ] ) <EOL> for route in routes : <EOL> self . _validate_routes_nexthop ( <EOL> cidrs , ips , routes , route [ '<STR_LIT>' ] ) <EOL> def _update_extra_routes ( self , context , router , routes ) : <EOL> self . _validate_routes ( context , router [ '<STR_LIT:id>' ] , <EOL> routes ) <EOL> old_routes , routes_dict = self . _get_extra_routes_dict_by_router_id ( <EOL> context , router [ '<STR_LIT:id>' ] ) <EOL> added , removed = utils . diff_list_of_dict ( old_routes , <EOL> routes ) <EOL> LOG . debug ( '<STR_LIT>' , added ) <EOL> for route in added : <EOL> router_routes = RouterRoute ( <EOL> router_id = router [ '<STR_LIT:id>' ] , <EOL> destination = route [ '<STR_LIT>' ] , <EOL> nexthop = route [ '<STR_LIT>' ] ) <EOL> context . session . add ( router_routes ) <EOL> LOG . debug ( '<STR_LIT>' , removed ) <EOL> for route in removed : <EOL> context . session . delete ( <EOL> routes_dict [ ( route [ '<STR_LIT>' ] , route [ '<STR_LIT>' ] ) ] ) <EOL> @ staticmethod <EOL> def _make_extra_route_list ( extra_routes ) : <EOL> return [ { '<STR_LIT>' : route [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : route [ '<STR_LIT>' ] } <EOL> for route in extra_routes ] <EOL> def _get_extra_routes_by_router_id ( self , context , id ) : <EOL> query = context . session . query ( RouterRoute ) <EOL> query = query . filter_by ( router_id = id ) <EOL> return self . _make_extra_route_list ( query ) <EOL> def _get_extra_routes_dict_by_router_id ( self , context , id ) : <EOL> query = context . session . query ( RouterRoute ) <EOL> query = query . filter_by ( router_id = id ) <EOL> routes = [ ] <EOL> routes_dict = { } <EOL>", "answer": "for route in query :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "ENABLE_CAPTCHA = True "}, {"prompt": "<s> import argparse <EOL> import sys <EOL> import os <EOL> import re <EOL> import json <EOL> from IPython . core . debugger import Tracer <EOL> def main ( config , args ) : <EOL> description = \"<STR_LIT>\" <EOL> m = re . match ( r'<STR_LIT>' , __name__ ) <EOL> controller_name = m . groups ( ) [ <NUM_LIT:0> ] <EOL> del sys . argv [ <NUM_LIT:1> ] <EOL> parser = argparse . ArgumentParser ( prog = \"<STR_LIT>\" % ( sys . argv [ <NUM_LIT:0> ] , controller_name ) , description = description ) <EOL> parser . add_argument ( \"<STR_LIT:url>\" , type = str , help = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT:user>\" , type = str , help = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , type = str , help = \"<STR_LIT>\" ) <EOL> args = vars ( parser . parse_args ( ) ) <EOL> try : <EOL>", "answer": "path = os . environ [ '<STR_LIT>' ] + \"<STR_LIT>\""}, {"prompt": "<s> from django import template <EOL> from django . template . defaultfilters import stringfilter <EOL> from currencies . models import Currency <EOL> from currencies . utils import calculate_price <EOL>", "answer": "register = template . Library ( )"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Intangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL>", "answer": "result . attribute_template_id = - <NUM_LIT:1>"}, {"prompt": "<s> from rest_framework import status <EOL> from rest_framework . authentication import BasicAuthentication <EOL> from rest_framework . permissions import IsAuthenticated , AllowAny <EOL> from rest_framework . response import Response <EOL> from rest_framework . settings import api_settings <EOL> from rest_framework . views import APIView <EOL> from knox . auth import TokenAuthentication <EOL> from knox . models import AuthToken <EOL> from knox . settings import knox_settings <EOL> UserSerializer = knox_settings . USER_SERIALIZER <EOL> class LoginView ( APIView ) : <EOL> authentication_classes = api_settings . DEFAULT_AUTHENTICATION_CLASSES <EOL> permission_classes = ( IsAuthenticated , ) <EOL> def post ( self , request , format = None ) : <EOL> token = AuthToken . objects . create ( request . user ) <EOL> return Response ( { <EOL> \"<STR_LIT:user>\" : UserSerializer ( request . user ) . data , <EOL> \"<STR_LIT>\" : token , <EOL> } ) <EOL> class LogoutView ( APIView ) : <EOL> authentication_classes = ( TokenAuthentication , ) <EOL> permission_classes = ( IsAuthenticated , ) <EOL>", "answer": "def post ( self , request , format = None ) :"}, {"prompt": "<s> from __future__ import ( absolute_import , division , generators , nested_scopes , print_function , <EOL> unicode_literals , with_statement ) <EOL> from abc import abstractmethod <EOL> from pants . util . meta import AbstractClass <EOL> from pants . util . objects import datatype <EOL> class Spec ( AbstractClass ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> @ abstractmethod <EOL> def to_spec_string ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class SingleAddress ( datatype ( '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT:name>' ] ) , Spec ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def to_spec_string ( self ) :"}, {"prompt": "<s> from sahara import exceptions as exc <EOL> from sahara . i18n import _ <EOL> from sahara . plugins . ambari import common as p_common <EOL> from sahara . plugins import exceptions as pex <EOL> from sahara . plugins import utils as plugin_utils <EOL> from sahara . service . edp import hdfs_helper <EOL> from sahara . service . edp . oozie import engine as oozie_engine <EOL> from sahara . service . edp . spark import engine as spark_engine <EOL> def _get_lib_location ( instance , lib_name ) : <EOL> with instance . remote ( ) as r : <EOL> code , jar_path = r . execute_command ( <EOL> ( '<STR_LIT>' <EOL> '<STR_LIT>' . format ( lib_name = lib_name ) ) , <EOL> run_as_root = True ) <EOL> return jar_path . rstrip ( ) <EOL> def _get_hadoop_openstack_jar_location ( instance ) : <EOL> return _get_lib_location ( instance , \"<STR_LIT>\" ) <EOL> def _get_jackson_core ( instance ) : <EOL> return _get_lib_location ( instance , \"<STR_LIT>\" ) <EOL> class EDPOozieEngine ( oozie_engine . OozieJobEngine ) : <EOL> def get_hdfs_user ( self ) : <EOL> return \"<STR_LIT>\" <EOL> def create_hdfs_dir ( self , remote , dir_name ) : <EOL> hdfs_helper . create_dir_hadoop2 ( remote , dir_name , self . get_hdfs_user ( ) ) <EOL> def get_oozie_server_uri ( self , cluster ) : <EOL> oozie = plugin_utils . get_instance ( cluster , p_common . OOZIE_SERVER ) <EOL> return \"<STR_LIT>\" % oozie . management_ip <EOL> def get_name_node_uri ( self , cluster ) : <EOL> namenodes = plugin_utils . get_instances ( cluster , p_common . NAMENODE ) <EOL> if len ( namenodes ) == <NUM_LIT:1> : <EOL> return \"<STR_LIT>\" % namenodes [ <NUM_LIT:0> ] . fqdn ( ) <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> def get_resource_manager_uri ( self , cluster ) : <EOL> resourcemanagers = plugin_utils . get_instances ( cluster , <EOL> p_common . RESOURCEMANAGER ) <EOL> return \"<STR_LIT>\" % resourcemanagers [ <NUM_LIT:0> ] . fqdn ( ) <EOL> def get_oozie_server ( self , cluster ) : <EOL> return plugin_utils . get_instance ( cluster , p_common . OOZIE_SERVER ) <EOL> def validate_job_execution ( self , cluster , job , data ) : <EOL> oozie_count = plugin_utils . get_instances_count ( cluster , <EOL> p_common . OOZIE_SERVER ) <EOL> if oozie_count != <NUM_LIT:1> : <EOL> raise pex . InvalidComponentCountException ( <EOL> p_common . OOZIE_SERVER , \"<STR_LIT:1>\" , oozie_count ) <EOL> super ( EDPOozieEngine , self ) . validate_job_execution ( cluster , job , data ) <EOL> @ staticmethod <EOL> def get_possible_job_config ( job_type ) : <EOL> return { \"<STR_LIT>\" : [ ] } <EOL> class EDPSparkEngine ( spark_engine . SparkJobEngine ) : <EOL> edp_base_version = \"<STR_LIT>\" <EOL> def __init__ ( self , cluster ) : <EOL> super ( EDPSparkEngine , self ) . __init__ ( cluster ) <EOL> self . master = plugin_utils . get_instance ( <EOL> cluster , p_common . SPARK_JOBHISTORYSERVER ) <EOL> self . plugin_params [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> self . plugin_params [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> self . plugin_params [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> self . plugin_params [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> @ staticmethod <EOL> def edp_supported ( version ) : <EOL> return version >= EDPSparkEngine . edp_base_version <EOL> def run_job ( self , job_execution ) : <EOL> driver_classpath = [ <EOL> _get_hadoop_openstack_jar_location ( self . master ) , <EOL> _get_jackson_core ( self . master ) ] <EOL> self . plugin_params [ '<STR_LIT>' ] = \"<STR_LIT::>\" . join ( driver_classpath ) <EOL> self . plugin_params [ '<STR_LIT>' ] = driver_classpath <EOL> return super ( EDPSparkEngine , self ) . run_job ( job_execution ) <EOL> def validate_job_execution ( self , cluster , job , data ) : <EOL> if not self . edp_supported ( cluster . hadoop_version ) : <EOL> raise exc . InvalidDataException ( <EOL> _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) . format ( <EOL> base = EDPSparkEngine . edp_base_version , type = job . type ) ) <EOL> spark_nodes_count = plugin_utils . get_instances_count ( <EOL> cluster , p_common . SPARK_JOBHISTORYSERVER ) <EOL> if spark_nodes_count != <NUM_LIT:1> : <EOL> raise pex . InvalidComponentCountException ( <EOL> p_common . SPARK_JOBHISTORYSERVER , '<STR_LIT:1>' , spark_nodes_count ) <EOL>", "answer": "super ( EDPSparkEngine , self ) . validate_job_execution ("}, {"prompt": "<s> from django . shortcuts import render_to_response , redirect <EOL> from django . contrib . admin . views . decorators import staff_member_required <EOL> from farmer . models import Task <EOL> from farmer . settings import NUMBER_OF_TASK_PER_PAGE <EOL> def run_task ( request , inventory , cmd ) : <EOL> task = Task ( ) <EOL> task . inventory = inventory <EOL> task . cmd = cmd <EOL> task . farmer = request . user . username <EOL> task . run ( ) <EOL> @ staff_member_required <EOL> def home ( request ) : <EOL> if request . method == '<STR_LIT:POST>' : <EOL> inventory = request . POST . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> cmd = request . POST . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if '<STR_LIT>' in [ inventory . strip ( ) , cmd . strip ( ) ] : <EOL> return redirect ( '<STR_LIT:/>' ) <EOL> run_task ( request , inventory , cmd ) <EOL> return redirect ( '<STR_LIT:/>' ) <EOL>", "answer": "else :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import ConfigParser <EOL> import io <EOL> import time <EOL> from perfkitbenchmarker import regex_util <EOL> from perfkitbenchmarker import sample <EOL> from perfkitbenchmarker import vm_util <EOL> FIO_DIR = '<STR_LIT>' % vm_util . VM_TMP_DIR <EOL> GIT_REPO = '<STR_LIT>' <EOL> GIT_TAG = '<STR_LIT>' <EOL> FIO_PATH = FIO_DIR + '<STR_LIT>' <EOL> FIO_CMD_PREFIX = '<STR_LIT>' % FIO_PATH <EOL> SECTION_REGEX = r'<STR_LIT>' <EOL> PARAMETER_REGEX = r'<STR_LIT>' <EOL> GLOBAL = '<STR_LIT>' <EOL> CMD_SECTION_REGEX = r'<STR_LIT>' <EOL> JOB_SECTION_REPL_REGEX = r'<STR_LIT>' <EOL> CMD_PARAMETER_REGEX = r'<STR_LIT>' <EOL> CMD_PARAMETER_REPL_REGEX = r'<STR_LIT>' <EOL> CMD_STONEWALL_PARAMETER = '<STR_LIT>' <EOL> JOB_STONEWALL_PARAMETER = '<STR_LIT>' <EOL> def _Install ( vm ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm . Install ( '<STR_LIT>' ) <EOL> vm . RemoteCommand ( '<STR_LIT>' . format ( GIT_REPO , FIO_DIR ) ) <EOL> vm . RemoteCommand ( '<STR_LIT>' . format ( FIO_DIR , GIT_TAG ) ) <EOL> vm . RemoteCommand ( '<STR_LIT>' . format ( FIO_DIR ) ) <EOL> def YumInstall ( vm ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm . InstallPackages ( '<STR_LIT>' ) <EOL> _Install ( vm ) <EOL> def AptInstall ( vm ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm . InstallPackages ( '<STR_LIT>' ) <EOL> _Install ( vm ) <EOL> def ParseJobFile ( job_file ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> config = ConfigParser . RawConfigParser ( allow_no_value = True ) <EOL> config . readfp ( io . BytesIO ( job_file ) ) <EOL> global_metadata = { } <EOL> if GLOBAL in config . sections ( ) : <EOL> global_metadata = dict ( config . items ( GLOBAL ) ) <EOL> section_metadata = { } <EOL> for section in config . sections ( ) : <EOL> if section != GLOBAL : <EOL> metadata = { } <EOL> metadata . update ( dict ( config . items ( section ) ) ) <EOL> metadata . update ( global_metadata ) <EOL> if JOB_STONEWALL_PARAMETER in metadata : <EOL> del metadata [ JOB_STONEWALL_PARAMETER ] <EOL> section_metadata [ section ] = metadata <EOL> return section_metadata <EOL> def FioParametersToJob ( fio_parameters ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fio_parameters = fio_parameters . replace ( '<STR_LIT:U+0020>' , '<STR_LIT:\\n>' ) <EOL> fio_parameters = regex_util . Substitute ( <EOL> CMD_SECTION_REGEX , JOB_SECTION_REPL_REGEX , fio_parameters ) <EOL> fio_parameters = '<STR_LIT>' % ( GLOBAL , fio_parameters ) <EOL> fio_parameters = regex_util . Substitute ( <EOL> CMD_PARAMETER_REGEX , CMD_PARAMETER_REPL_REGEX , fio_parameters ) <EOL> return fio_parameters . replace ( CMD_STONEWALL_PARAMETER , <EOL> JOB_STONEWALL_PARAMETER ) <EOL> def ParseResults ( job_file , fio_json_result , base_metadata = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> samples = [ ] <EOL> timestamp = time . time ( ) <EOL> parameter_metadata = ParseJobFile ( job_file ) <EOL> io_modes = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> for job in fio_json_result [ '<STR_LIT>' ] : <EOL> job_name = job [ '<STR_LIT>' ] <EOL> for mode in io_modes : <EOL> if job [ mode ] [ '<STR_LIT>' ] : <EOL> metric_name = '<STR_LIT>' % ( job_name , mode ) <EOL> parameters = parameter_metadata [ job_name ] <EOL> if base_metadata : <EOL> parameters . update ( base_metadata ) <EOL> parameters [ '<STR_LIT>' ] = job_name <EOL> bw_metadata = { <EOL> '<STR_LIT>' : job [ mode ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : job [ mode ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : job [ mode ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : job [ mode ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : job [ mode ] [ '<STR_LIT>' ] } <EOL> bw_metadata . update ( parameters ) <EOL> samples . append ( <EOL> sample . Sample ( '<STR_LIT>' % metric_name , <EOL> job [ mode ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' , bw_metadata ) ) <EOL> clat_section = job [ mode ] [ '<STR_LIT>' ] <EOL> percentiles = clat_section [ '<STR_LIT>' ] <EOL> lat_statistics = [ <EOL> ( '<STR_LIT>' , clat_section [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , clat_section [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , clat_section [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , clat_section [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , percentiles [ '<STR_LIT>' ] ) ] <EOL> lat_metadata = parameters . copy ( ) <EOL> for name , val in lat_statistics : <EOL>", "answer": "lat_metadata [ name ] = val"}, {"prompt": "<s> import time <EOL> import logging <EOL> from django . conf import settings <EOL> from django . contrib . sessions . backends . base import SessionBase , CreateError <EOL> from django . core . exceptions import SuspiciousOperation <EOL> from boto . dynamodb import connect_to_region <EOL> from boto . dynamodb . exceptions import DynamoDBKeyNotFoundError <EOL> TABLE_NAME = getattr ( <EOL> settings , '<STR_LIT>' , '<STR_LIT>' ) <EOL> HASH_ATTRIB_NAME = getattr ( <EOL> settings , '<STR_LIT>' , '<STR_LIT>' ) <EOL> ALWAYS_CONSISTENT = getattr ( <EOL> settings , '<STR_LIT>' , True ) <EOL> AWS_ACCESS_KEY_ID = getattr ( <EOL> settings , '<STR_LIT>' , False ) <EOL> if not AWS_ACCESS_KEY_ID : <EOL> AWS_ACCESS_KEY_ID = getattr ( <EOL> settings , '<STR_LIT>' ) <EOL> AWS_SECRET_ACCESS_KEY = getattr ( <EOL> settings , '<STR_LIT>' , False ) <EOL> if not AWS_SECRET_ACCESS_KEY : <EOL> AWS_SECRET_ACCESS_KEY = getattr ( settings , '<STR_LIT>' ) <EOL> AWS_REGION_NAME = getattr ( settings , '<STR_LIT>' , False ) <EOL> if not AWS_REGION_NAME : <EOL> AWS_REGION_NAME = getattr ( settings , '<STR_LIT>' , '<STR_LIT>' ) <EOL> _DYNAMODB_CONN = None <EOL> logger = logging . getLogger ( __name__ ) <EOL> def dynamodb_connection_factory ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> global _DYNAMODB_CONN <EOL> if not _DYNAMODB_CONN : <EOL> logger . debug ( \"<STR_LIT>\" ) <EOL> _DYNAMODB_CONN = connect_to_region ( <EOL> AWS_REGION_NAME , <EOL> aws_access_key_id = AWS_ACCESS_KEY_ID , <EOL> aws_secret_access_key = AWS_SECRET_ACCESS_KEY <EOL> ) <EOL> return _DYNAMODB_CONN <EOL> class SessionStore ( SessionBase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , session_key = None ) : <EOL> super ( SessionStore , self ) . __init__ ( session_key ) <EOL> self . table = dynamodb_connection_factory ( ) . get_table ( TABLE_NAME ) <EOL> def load ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> item = self . table . get_item ( <EOL> self . session_key , consistent_read = ALWAYS_CONSISTENT ) <EOL> except ( DynamoDBKeyNotFoundError , SuspiciousOperation ) : <EOL> self . create ( ) <EOL> return { } <EOL> session_data = item [ '<STR_LIT:data>' ] <EOL> return self . decode ( session_data ) <EOL> def exists ( self , session_key ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "key_already_exists = self . table . has_item ("}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> import copy <EOL> import datetime <EOL> import zlib <EOL> from google . appengine . api import datastore_errors <EOL> from google . appengine . api import datastore_types <EOL> from google . appengine . api import users <EOL> from google . appengine . datastore import datastore_query <EOL> from google . appengine . datastore import datastore_rpc <EOL> from google . appengine . datastore import entity_pb <EOL> from . import utils <EOL> from . import key as key_module <EOL> Key = key_module . Key <EOL> _MAX_LONG = key_module . _MAX_LONG <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> ] <EOL> BlobKey = datastore_types . BlobKey <EOL> GeoPt = datastore_types . GeoPt <EOL> Rollback = datastore_errors . Rollback <EOL> class KindError ( datastore_errors . BadValueError ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class ComputedPropertyError ( datastore_errors . Error ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class ModelAdapter ( datastore_rpc . AbstractAdapter ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , default_model = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . default_model = default_model <EOL> self . want_pbs = <NUM_LIT:0> <EOL> def __enter__ ( self ) : <EOL> self . want_pbs += <NUM_LIT:1> <EOL> def __exit__ ( self , * unused_args ) : <EOL> self . want_pbs -= <NUM_LIT:1> <EOL> def pb_to_key ( self , pb ) : <EOL> return Key ( reference = pb ) <EOL> def key_to_pb ( self , key ) : <EOL> return key . reference ( ) <EOL> def pb_to_entity ( self , pb ) : <EOL> key = None <EOL> kind = None <EOL> if pb . has_key ( ) : <EOL> key = Key ( reference = pb . key ( ) ) <EOL> kind = key . kind ( ) <EOL> modelclass = Model . _kind_map . get ( kind , self . default_model ) <EOL> if modelclass is None : <EOL> raise KindError ( \"<STR_LIT>\" % kind ) <EOL> entity = modelclass . _from_pb ( pb , key = key , set_key = False ) <EOL> if self . want_pbs : <EOL> entity . _orig_pb = pb <EOL> return entity <EOL> def entity_to_pb ( self , ent ) : <EOL> pb = ent . _to_pb ( ) <EOL> return pb <EOL> def make_connection ( config = None , default_model = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return datastore_rpc . Connection ( <EOL> adapter = ModelAdapter ( default_model ) , <EOL> config = config ) <EOL> class ModelAttribute ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _fix_up ( self , cls , code_name ) : <EOL> pass <EOL> class Property ( ModelAttribute ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _code_name = None <EOL> _name = None <EOL> _indexed = True <EOL> _repeated = False <EOL> _required = False <EOL> _default = None <EOL> _choices = None <EOL> _validator = None <EOL> _attributes = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] <EOL> _positional = <NUM_LIT:1> <EOL> @ datastore_rpc . _positional ( <NUM_LIT:1> + _positional ) <EOL> def __init__ ( self , name = None , indexed = None , repeated = None , <EOL> required = None , default = None , choices = None , validator = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if name is not None : <EOL> if isinstance ( name , unicode ) : <EOL> name = name . encode ( '<STR_LIT:utf-8>' ) <EOL> if '<STR_LIT:.>' in name : <EOL> raise ValueError ( '<STR_LIT>' % name ) <EOL> self . _name = name <EOL> if indexed is not None : <EOL> self . _indexed = indexed <EOL> if repeated is not None : <EOL> self . _repeated = repeated <EOL> if required is not None : <EOL> self . _required = required <EOL> if default is not None : <EOL> self . _default = default <EOL> if ( bool ( self . _repeated ) + <EOL> bool ( self . _required ) + <EOL> ( self . _default is not None ) ) > <NUM_LIT:1> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> if choices is not None : <EOL> if not isinstance ( choices , ( list , tuple , set , frozenset ) ) : <EOL> raise TypeError ( '<STR_LIT>' % <EOL> choices ) <EOL> self . _choices = frozenset ( choices ) <EOL> if validator is not None : <EOL> if not hasattr ( validator , '<STR_LIT>' ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> % validator ) <EOL> self . _validator = validator <EOL> def __repr__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> args = [ ] <EOL> cls = self . __class__ <EOL> for i , attr in enumerate ( self . _attributes ) : <EOL> val = getattr ( self , attr ) <EOL> if val is not getattr ( cls , attr ) : <EOL> if isinstance ( val , type ) : <EOL> s = val . __name__ <EOL> else : <EOL> s = repr ( val ) <EOL> if i >= cls . _positional : <EOL> if attr . startswith ( '<STR_LIT:_>' ) : <EOL> attr = attr [ <NUM_LIT:1> : ] <EOL> s = '<STR_LIT>' % ( attr , s ) <EOL> args . append ( s ) <EOL> s = '<STR_LIT>' % ( self . __class__ . __name__ , '<STR_LIT:U+002CU+0020>' . join ( args ) ) <EOL> return s <EOL> def _datastore_type ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return value <EOL> def _comparison ( self , op , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . _indexed : <EOL> raise datastore_errors . BadFilterError ( <EOL> '<STR_LIT>' % self . _name ) <EOL> from . query import FilterNode <EOL> if value is not None : <EOL> value = self . _do_validate ( value ) <EOL> value = self . _datastore_type ( value ) <EOL> return FilterNode ( self . _name , op , value ) <EOL> def __eq__ ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _comparison ( '<STR_LIT:=>' , value ) <EOL> def __ne__ ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _comparison ( '<STR_LIT>' , value ) <EOL> def __lt__ ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _comparison ( '<STR_LIT:<>' , value ) <EOL> def __le__ ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _comparison ( '<STR_LIT>' , value ) <EOL> def __gt__ ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _comparison ( '<STR_LIT:>>' , value ) <EOL> def __ge__ ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _comparison ( '<STR_LIT>' , value ) <EOL> def _IN ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . _indexed : <EOL> raise datastore_errors . BadFilterError ( <EOL> '<STR_LIT>' % self . _name ) <EOL> from . query import FilterNode <EOL> if not isinstance ( value , ( list , tuple , set , frozenset ) ) : <EOL> raise datastore_errors . BadArgumentError ( <EOL> '<STR_LIT>' % ( value , ) ) <EOL> values = [ ] <EOL> for val in value : <EOL> if val is not None : <EOL> val = self . _do_validate ( val ) <EOL> val = self . _datastore_type ( val ) <EOL> values . append ( val ) <EOL> return FilterNode ( self . _name , '<STR_LIT>' , values ) <EOL> IN = _IN <EOL> def __neg__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return datastore_query . PropertyOrder ( <EOL> self . _name , datastore_query . PropertyOrder . DESCENDING ) <EOL> def __pos__ ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return datastore_query . PropertyOrder ( self . _name ) <EOL> def _validate ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return value <EOL> def _do_validate ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> value = self . _validate ( value ) <EOL> if self . _validator is not None : <EOL> value = self . _validator ( self , value ) <EOL> if self . _choices is not None : <EOL> if value not in self . _choices : <EOL> raise datastore_errors . BadValueError ( <EOL> '<STR_LIT>' % <EOL> ( value , self . _name ) ) <EOL> return value <EOL> def _fix_up ( self , cls , code_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _code_name = code_name <EOL> if self . _name is None : <EOL> self . _name = code_name <EOL> def _store_value ( self , entity , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> entity . _values [ self . _name ] = value <EOL> def _set_value ( self , entity , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _repeated : <EOL> if not isinstance ( value , ( list , tuple ) ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( value , ) ) <EOL> value = [ self . _do_validate ( v ) for v in value ] <EOL> else : <EOL> if value is not None : <EOL> value = self . _do_validate ( value ) <EOL> self . _store_value ( entity , value ) <EOL> def _has_value ( self , entity , unused_rest = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _name in entity . _values <EOL> def _retrieve_value ( self , entity ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return entity . _values . get ( self . _name , self . _default ) <EOL> def _get_value ( self , entity ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> value = self . _retrieve_value ( entity ) <EOL> if value is None and self . _repeated : <EOL> value = [ ] <EOL> self . _store_value ( entity , value ) <EOL> return value <EOL> def _delete_value ( self , entity ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _name in entity . _values : <EOL> del entity . _values [ self . _name ] <EOL> def _is_initialized ( self , entity ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return not self . _required or ( self . _has_value ( entity ) and <EOL> self . _get_value ( entity ) is not None ) <EOL> def __get__ ( self , entity , unused_cls = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if entity is None : <EOL> return self <EOL> return self . _get_value ( entity ) <EOL> def __set__ ( self , entity , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _set_value ( entity , value ) <EOL> def __delete__ ( self , entity ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _delete_value ( entity ) <EOL> def _serialize ( self , entity , pb , prefix = '<STR_LIT>' , parent_repeated = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> value = self . _retrieve_value ( entity ) <EOL> if not self . _repeated : <EOL> value = [ value ] <EOL> elif value is None : <EOL> value = [ ] <EOL> elif not isinstance ( value , list ) : <EOL> raise TypeError ( '<STR_LIT>' % <EOL> ( self . _name , value ) ) <EOL> for val in value : <EOL> if self . _repeated : <EOL> val = self . _do_validate ( val ) <EOL> if self . _indexed : <EOL> p = pb . add_property ( ) <EOL> else : <EOL> p = pb . add_raw_property ( ) <EOL> p . set_name ( prefix + self . _name ) <EOL> p . set_multiple ( self . _repeated or parent_repeated ) <EOL> v = p . mutable_value ( ) <EOL> if val is not None : <EOL> self . _db_set_value ( v , p , val ) <EOL> def _deserialize ( self , entity , p , unused_depth = <NUM_LIT:1> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> v = p . value ( ) <EOL> val = self . _db_get_value ( v , p ) <EOL> if self . _repeated : <EOL> if self . _has_value ( entity ) : <EOL> value = self . _retrieve_value ( entity ) <EOL> if not isinstance ( value , list ) : <EOL> value = [ value ] <EOL> value . append ( val ) <EOL> else : <EOL> value = [ val ] <EOL> else : <EOL> value = val <EOL> self . _store_value ( entity , value ) <EOL> def _prepare_for_put ( self , entity ) : <EOL> pass <EOL> def _validate_key ( value , entity = None ) : <EOL> if not isinstance ( value , Key ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % value ) <EOL> if entity and entity . __class__ not in ( Model , Expando ) : <EOL> if value . kind ( ) != entity . _get_kind ( ) : <EOL> raise KindError ( '<STR_LIT>' % <EOL> ( entity . _get_kind ( ) , value . kind ( ) ) ) <EOL> return value <EOL> class ModelKey ( Property ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> super ( ModelKey , self ) . __init__ ( ) <EOL> self . _name = '<STR_LIT>' <EOL> def _datastore_type ( self , value ) : <EOL> return datastore_types . Key ( value . urlsafe ( ) ) <EOL> def _comparison ( self , op , value ) : <EOL> if value is not None : <EOL> return super ( ModelKey , self ) . _comparison ( op , value ) <EOL> raise datastore_errors . BadValueError ( <EOL> \"<STR_LIT>\" ) <EOL> def _validate ( self , value ) : <EOL> return _validate_key ( value ) <EOL> def _set_value ( self , entity , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if value is not None : <EOL> value = _validate_key ( value , entity = entity ) <EOL> value = entity . _validate_key ( value ) <EOL> entity . _entity_key = value <EOL> def _get_value ( self , entity ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return entity . _entity_key <EOL> def _delete_value ( self , entity ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> entity . _entity_key = None <EOL> class BooleanProperty ( Property ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _validate ( self , value ) : <EOL> if not isinstance ( value , bool ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( value , ) ) <EOL> return value <EOL> def _db_set_value ( self , v , unused_p , value ) : <EOL> if not isinstance ( value , bool ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % ( self . _name , value ) ) <EOL> v . set_booleanvalue ( value ) <EOL> def _db_get_value ( self , v , unused_p ) : <EOL> if not v . has_booleanvalue ( ) : <EOL> return None <EOL> return bool ( v . booleanvalue ( ) ) <EOL> class IntegerProperty ( Property ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _validate ( self , value ) : <EOL> if not isinstance ( value , ( int , long ) ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( value , ) ) <EOL> return int ( value ) <EOL> def _db_set_value ( self , v , unused_p , value ) : <EOL> if not isinstance ( value , ( bool , int , long ) ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % ( self . _name , value ) ) <EOL> v . set_int64value ( value ) <EOL> def _db_get_value ( self , v , unused_p ) : <EOL> if not v . has_int64value ( ) : <EOL> return None <EOL> return int ( v . int64value ( ) ) <EOL> class FloatProperty ( Property ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _validate ( self , value ) : <EOL> if not isinstance ( value , ( int , long , float ) ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( value , ) ) <EOL> return float ( value ) <EOL> def _db_set_value ( self , v , unused_p , value ) : <EOL> if not isinstance ( value , ( bool , int , long , float ) ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % ( self . _name , value ) ) <EOL> v . set_doublevalue ( float ( value ) ) <EOL> def _db_get_value ( self , v , unused_p ) : <EOL> if not v . has_doublevalue ( ) : <EOL> return None <EOL> return v . doublevalue ( ) <EOL> class StringProperty ( Property ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _validate ( self , value ) : <EOL> if not isinstance ( value , basestring ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( value , ) ) <EOL> return value <EOL> def _db_set_value ( self , v , p , value ) : <EOL> if not isinstance ( value , basestring ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % ( self . _name , value ) ) <EOL> if isinstance ( value , unicode ) : <EOL> value = value . encode ( '<STR_LIT:utf-8>' ) <EOL> v . set_stringvalue ( value ) <EOL> if not self . _indexed : <EOL> p . set_meaning ( entity_pb . Property . TEXT ) <EOL> def _db_get_value ( self , v , unused_p ) : <EOL> if not v . has_stringvalue ( ) : <EOL> return None <EOL> raw = v . stringvalue ( ) <EOL> try : <EOL> value = raw . decode ( '<STR_LIT:utf-8>' ) <EOL> return value <EOL> except UnicodeDecodeError : <EOL> return raw <EOL> _MEANING_URI_COMPRESSED = '<STR_LIT>' <EOL> class _CompressedValue ( str ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % super ( _CompressedValue , self ) . __repr__ ( ) <EOL> class CompressedPropertyMixin ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _db_set_value ( self , v , p , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _indexed : <EOL> p . set_meaning ( entity_pb . Property . BYTESTRING ) <EOL> else : <EOL> p . set_meaning ( entity_pb . Property . BLOB ) <EOL> self . _db_set_compressed_value ( v , p , value ) <EOL> def _db_set_compressed_value ( self , v , p , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . _compressed : <EOL> p . set_meaning_uri ( _MEANING_URI_COMPRESSED ) <EOL> if not isinstance ( value , _CompressedValue ) : <EOL> value = zlib . compress ( self . _serialize_value ( value ) ) <EOL> else : <EOL> value = self . _serialize_value ( value ) <EOL> if not isinstance ( value , str ) : <EOL> raise RuntimeError ( '<STR_LIT>' % <EOL> ( self . _name , value ) ) <EOL> v . set_stringvalue ( value ) <EOL> def _db_get_value ( self , v , p ) : <EOL> if not v . has_stringvalue ( ) : <EOL> return None <EOL> if p . meaning_uri ( ) == _MEANING_URI_COMPRESSED : <EOL> return _CompressedValue ( v . stringvalue ( ) ) <EOL> return self . _deserialize_value ( v . stringvalue ( ) ) <EOL> def _get_value ( self , entity ) : <EOL> value = super ( CompressedPropertyMixin , self ) . _get_value ( entity ) <EOL> if self . _repeated : <EOL> if value and isinstance ( value [ <NUM_LIT:0> ] , _CompressedValue ) : <EOL> for i in xrange ( len ( value ) ) : <EOL> value [ i ] = self . _deserialize_value ( zlib . decompress ( value [ i ] ) ) <EOL> elif isinstance ( value , _CompressedValue ) : <EOL> value = self . _deserialize_value ( zlib . decompress ( value ) ) <EOL> self . _store_value ( entity , value ) <EOL> return value <EOL> def _serialize_value ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return value <EOL> def _deserialize_value ( self , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return value <EOL> class TextProperty ( CompressedPropertyMixin , StringProperty ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _indexed = False <EOL> _compressed = False <EOL> _attributes = StringProperty . _attributes + [ '<STR_LIT>' ] <EOL> _positional = <NUM_LIT:1> <EOL> @ datastore_rpc . _positional ( <NUM_LIT:1> + _positional ) <EOL> def __init__ ( self , compressed = False , ** kwds ) : <EOL> super ( TextProperty , self ) . __init__ ( ** kwds ) <EOL> if self . _indexed : <EOL> raise NotImplementedError ( '<STR_LIT>' % <EOL> self . _name ) <EOL> self . _compressed = compressed <EOL> def _validate ( self , value ) : <EOL> if self . _compressed and isinstance ( value , _CompressedValue ) : <EOL> return value <EOL> return super ( TextProperty , self ) . _validate ( value ) <EOL> def _db_set_value ( self , v , p , value ) : <EOL> if self . _compressed : <EOL> p . set_meaning ( entity_pb . Property . BLOB ) <EOL> else : <EOL> p . set_meaning ( entity_pb . Property . TEXT ) <EOL> self . _db_set_compressed_value ( v , p , value ) <EOL> def _serialize_value ( self , value ) : <EOL> if not isinstance ( value , basestring ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % ( self . _name , value ) ) <EOL> if isinstance ( value , unicode ) : <EOL> return value . encode ( '<STR_LIT:utf-8>' ) <EOL> return value <EOL> def _deserialize_value ( self , value ) : <EOL> try : <EOL> return value . decode ( '<STR_LIT:utf-8>' ) <EOL> except UnicodeDecodeError : <EOL> return value <EOL> class BlobProperty ( CompressedPropertyMixin , Property ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _indexed = False <EOL> _compressed = False <EOL> _attributes = Property . _attributes + [ '<STR_LIT>' ] <EOL> _positional = <NUM_LIT:2> <EOL> @ datastore_rpc . _positional ( <NUM_LIT:1> + _positional ) <EOL> def __init__ ( self , name = None , compressed = False , ** kwds ) : <EOL> super ( BlobProperty , self ) . __init__ ( name = name , ** kwds ) <EOL> self . _compressed = compressed <EOL> if compressed and self . _indexed : <EOL> raise NotImplementedError ( '<STR_LIT>' <EOL> '<STR_LIT>' % self . _name ) <EOL> def _validate ( self , value ) : <EOL> if self . _compressed and isinstance ( value , _CompressedValue ) : <EOL> return value <EOL> if not isinstance ( value , str ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( value , ) ) <EOL> return value <EOL> def _datastore_type ( self , value ) : <EOL> if not self . _indexed : <EOL> raise RuntimeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % self . _name ) <EOL> return datastore_types . ByteString ( value ) <EOL> class GeoPtProperty ( Property ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _validate ( self , value ) : <EOL> if not isinstance ( value , GeoPt ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( value , ) ) <EOL> return value <EOL> def _db_set_value ( self , v , unused_p , value ) : <EOL> if not isinstance ( value , GeoPt ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % ( self . _name , value ) ) <EOL> pv = v . mutable_pointvalue ( ) <EOL> pv . set_x ( value . lat ) <EOL> pv . set_y ( value . lon ) <EOL> def _db_get_value ( self , v , unused_p ) : <EOL> if not v . has_pointvalue ( ) : <EOL> return None <EOL> pv = v . pointvalue ( ) <EOL> return GeoPt ( pv . x ( ) , pv . y ( ) ) <EOL> def _unpack_user ( v ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> uv = v . uservalue ( ) <EOL> email = unicode ( uv . email ( ) . decode ( '<STR_LIT:utf-8>' ) ) <EOL> auth_domain = unicode ( uv . auth_domain ( ) . decode ( '<STR_LIT:utf-8>' ) ) <EOL> obfuscated_gaiaid = uv . obfuscated_gaiaid ( ) . decode ( '<STR_LIT:utf-8>' ) <EOL> obfuscated_gaiaid = unicode ( obfuscated_gaiaid ) <EOL> federated_identity = None <EOL> if uv . has_federated_identity ( ) : <EOL> federated_identity = unicode ( <EOL> uv . federated_identity ( ) . decode ( '<STR_LIT:utf-8>' ) ) <EOL> value = users . User ( email = email , <EOL> _auth_domain = auth_domain , <EOL> _user_id = obfuscated_gaiaid , <EOL> federated_identity = federated_identity ) <EOL> return value <EOL> class UserProperty ( Property ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _validate ( self , value ) : <EOL> if not isinstance ( value , users . User ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( value , ) ) <EOL> return value <EOL> def _db_set_value ( self , v , p , value ) : <EOL> datastore_types . PackUser ( p . name ( ) , value , v ) <EOL> def _db_get_value ( self , v , unused_p ) : <EOL> if not v . has_uservalue ( ) : <EOL> return None <EOL> return _unpack_user ( v ) <EOL> class KeyProperty ( Property ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _datastore_type ( self , value ) : <EOL> return datastore_types . Key ( value . urlsafe ( ) ) <EOL> def _validate ( self , value ) : <EOL> if not isinstance ( value , Key ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % ( value , ) ) <EOL> if not value . id ( ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( value , ) ) <EOL> return value <EOL> def _db_set_value ( self , v , unused_p , value ) : <EOL> if not isinstance ( value , Key ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % ( self . _name , value ) ) <EOL> ref = value . reference ( ) <EOL> rv = v . mutable_referencevalue ( ) <EOL> rv . set_app ( ref . app ( ) ) <EOL> if ref . has_name_space ( ) : <EOL> rv . set_name_space ( ref . name_space ( ) ) <EOL> for elem in ref . path ( ) . element_list ( ) : <EOL> rv . add_pathelement ( ) . CopyFrom ( elem ) <EOL> def _db_get_value ( self , v , unused_p ) : <EOL> if not v . has_referencevalue ( ) : <EOL> return None <EOL> ref = entity_pb . Reference ( ) <EOL> rv = v . referencevalue ( ) <EOL> if rv . has_app ( ) : <EOL> ref . set_app ( rv . app ( ) ) <EOL> if rv . has_name_space ( ) : <EOL> ref . set_name_space ( rv . name_space ( ) ) <EOL> path = ref . mutable_path ( ) <EOL> for elem in rv . pathelement_list ( ) : <EOL> path . add_element ( ) . CopyFrom ( elem ) <EOL> return Key ( reference = ref ) <EOL> class BlobKeyProperty ( Property ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _validate ( self , value ) : <EOL> if not isinstance ( value , datastore_types . BlobKey ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( value , ) ) <EOL> return value <EOL> def _db_set_value ( self , v , p , value ) : <EOL> if not isinstance ( value , datastore_types . BlobKey ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % ( self . _name , value ) ) <EOL> p . set_meaning ( entity_pb . Property . BLOBKEY ) <EOL> v . set_stringvalue ( str ( value ) ) <EOL> def _db_get_value ( self , v , unused_p ) : <EOL> if not v . has_stringvalue ( ) : <EOL> return None <EOL> return datastore_types . BlobKey ( v . stringvalue ( ) ) <EOL> _EPOCH = datetime . datetime . utcfromtimestamp ( <NUM_LIT:0> ) <EOL> class DateTimeProperty ( Property ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _attributes = Property . _attributes + [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> _auto_now = False <EOL> _auto_now_add = False <EOL> @ datastore_rpc . _positional ( <NUM_LIT:1> + Property . _positional ) <EOL> def __init__ ( self , name = None , auto_now = False , auto_now_add = False , ** kwds ) : <EOL> super ( DateTimeProperty , self ) . __init__ ( name = name , ** kwds ) <EOL> if self . _repeated : <EOL> if auto_now : <EOL> raise ValueError ( '<STR_LIT>' <EOL> '<STR_LIT>' % self . _name ) <EOL> elif auto_now_add : <EOL> raise ValueError ( '<STR_LIT>' <EOL> '<STR_LIT>' % self . _name ) <EOL> self . _auto_now = auto_now <EOL> self . _auto_now_add = auto_now_add <EOL> def _validate ( self , value ) : <EOL> if not isinstance ( value , datetime . datetime ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( value , ) ) <EOL> return value <EOL> def _now ( self ) : <EOL> return datetime . datetime . now ( ) <EOL> def _prepare_for_put ( self , entity ) : <EOL> if ( self . _auto_now or <EOL> ( self . _auto_now_add and self . _retrieve_value ( entity ) is None ) ) : <EOL> value = self . _now ( ) <EOL> self . _store_value ( entity , value ) <EOL> def _db_set_value ( self , v , p , value ) : <EOL> if not isinstance ( value , datetime . datetime ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % ( self . _name , value ) ) <EOL> if value . tzinfo is not None : <EOL> raise NotImplementedError ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' % self . _name ) <EOL> dt = value - _EPOCH <EOL> ival = dt . microseconds + <NUM_LIT> * ( dt . seconds + <NUM_LIT> * <NUM_LIT> * dt . days ) <EOL> v . set_int64value ( ival ) <EOL> p . set_meaning ( entity_pb . Property . GD_WHEN ) <EOL> def _db_get_value ( self , v , unused_p ) : <EOL> if not v . has_int64value ( ) : <EOL> return None <EOL> ival = v . int64value ( ) <EOL> return _EPOCH + datetime . timedelta ( microseconds = ival ) <EOL> def _date_to_datetime ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( value , datetime . date ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % value ) <EOL> return datetime . datetime ( value . year , value . month , value . day ) <EOL> def _time_to_datetime ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not isinstance ( value , datetime . time ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % value ) <EOL> return datetime . datetime ( <NUM_LIT> , <NUM_LIT:1> , <NUM_LIT:1> , <EOL> value . hour , value . minute , value . second , <EOL> value . microsecond ) <EOL> class DateProperty ( DateTimeProperty ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _datastore_type ( self , value ) : <EOL> return _date_to_datetime ( value ) <EOL> def _validate ( self , value ) : <EOL> if ( not isinstance ( value , datetime . date ) or <EOL> isinstance ( value , datetime . datetime ) ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( value , ) ) <EOL> return value <EOL> def _now ( self ) : <EOL> return datetime . date . today ( ) <EOL> def _db_set_value ( self , v , p , value ) : <EOL> value = _date_to_datetime ( value ) <EOL> super ( DateProperty , self ) . _db_set_value ( v , p , value ) <EOL> def _db_get_value ( self , v , p ) : <EOL> value = super ( DateProperty , self ) . _db_get_value ( v , p ) <EOL> if value is not None : <EOL> value = value . date ( ) <EOL> return value <EOL> class TimeProperty ( DateTimeProperty ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _datastore_type ( self , value ) : <EOL> return _time_to_datetime ( value ) <EOL> def _validate ( self , value ) : <EOL> if not isinstance ( value , datetime . time ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( value , ) ) <EOL> return value <EOL> def _now ( self ) : <EOL> return datetime . datetime . now ( ) . time ( ) <EOL> def _db_set_value ( self , v , p , value ) : <EOL> value = _time_to_datetime ( value ) <EOL> super ( TimeProperty , self ) . _db_set_value ( v , p , value ) <EOL> def _db_get_value ( self , v , p ) : <EOL> value = super ( TimeProperty , self ) . _db_get_value ( v , p ) <EOL> if value is not None : <EOL> value = value . time ( ) <EOL> return value <EOL> class StructuredProperty ( Property ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _modelclass = None <EOL> _attributes = [ '<STR_LIT>' ] + Property . _attributes <EOL> _positional = <NUM_LIT:2> <EOL> @ datastore_rpc . _positional ( <NUM_LIT:1> + _positional ) <EOL> def __init__ ( self , modelclass , name = None , ** kwds ) : <EOL> super ( StructuredProperty , self ) . __init__ ( name = name , ** kwds ) <EOL> if self . _repeated : <EOL> if modelclass . _has_repeated : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % self . _name ) <EOL> self . _modelclass = modelclass <EOL> def _fix_up ( self , cls , code_name ) : <EOL> super ( StructuredProperty , self ) . _fix_up ( cls , code_name ) <EOL> self . _fix_up_nested_properties ( ) <EOL> def _fix_up_nested_properties ( self ) : <EOL> for prop in self . _modelclass . _properties . itervalues ( ) : <EOL> prop_copy = copy . copy ( prop ) <EOL> prop_copy . _name = self . _name + '<STR_LIT:.>' + prop . _name <EOL> if isinstance ( prop_copy , StructuredProperty ) : <EOL> if prop_copy . _modelclass is not self . _modelclass : <EOL> prop_copy . _fix_up_nested_properties ( ) <EOL> setattr ( self , prop . _code_name , prop_copy ) <EOL> def _comparison ( self , op , value ) : <EOL> if op != '<STR_LIT:=>' : <EOL> raise datastore_errors . BadFilterError ( <EOL> '<STR_LIT>' ) <EOL> if not self . _indexed : <EOL> raise datastore_errors . BadFilterError ( <EOL> '<STR_LIT>' % self . _name ) <EOL> from . query import ConjunctionNode , PostFilterNode <EOL> from . query import RepeatedStructuredPropertyPredicate <EOL> value = self . _do_validate ( value ) <EOL> filters = [ ] <EOL> match_keys = [ ] <EOL> for prop in self . _modelclass . _properties . itervalues ( ) : <EOL> val = prop . _retrieve_value ( value ) <EOL> if val is not None : <EOL> altprop = getattr ( self , prop . _code_name ) <EOL> filt = altprop . _comparison ( op , val ) <EOL> filters . append ( filt ) <EOL> match_keys . append ( altprop . _name ) <EOL> if not filters : <EOL> raise datastore_errors . BadFilterError ( <EOL> '<STR_LIT>' ) <EOL> if len ( filters ) == <NUM_LIT:1> : <EOL> return filters [ <NUM_LIT:0> ] <EOL> if self . _repeated : <EOL> pb = value . _to_pb ( allow_partial = True ) <EOL> pred = RepeatedStructuredPropertyPredicate ( match_keys , pb , <EOL> self . _name + '<STR_LIT:.>' ) <EOL> filters . append ( PostFilterNode ( pred ) ) <EOL> return ConjunctionNode ( * filters ) <EOL> def _IN ( self , value ) : <EOL> if not isinstance ( value , ( list , tuple , set , frozenset ) ) : <EOL> raise datastore_errors . BadArgumentError ( <EOL> '<STR_LIT>' % ( value , ) ) <EOL> from . query import DisjunctionNode , FalseNode <EOL> filters = [ self . _comparison ( '<STR_LIT:=>' , val ) for val in value ] <EOL> if not filters : <EOL> return FalseNode ( ) <EOL> else : <EOL> return DisjunctionNode ( * filters ) <EOL> IN = _IN <EOL> def _validate ( self , value ) : <EOL> if not isinstance ( value , self . _modelclass ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( self . _modelclass . __name__ , value ) ) <EOL> return value <EOL> def _has_value ( self , entity , rest = None ) : <EOL> ok = super ( StructuredProperty , self ) . _has_value ( entity ) <EOL> if ok and rest : <EOL> subent = self . _get_value ( entity ) <EOL> if subent is None : <EOL> raise RuntimeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % self . _name ) <EOL> subprop = subent . _properties . get ( rest [ <NUM_LIT:0> ] ) <EOL> if subprop is None : <EOL> ok = False <EOL> else : <EOL> ok = subprop . _has_value ( subent , rest [ <NUM_LIT:1> : ] ) <EOL> return ok <EOL> def _serialize ( self , entity , pb , prefix = '<STR_LIT>' , parent_repeated = False ) : <EOL> value = self . _retrieve_value ( entity ) <EOL> if value is None : <EOL> return <EOL> cls = self . _modelclass <EOL> if self . _repeated : <EOL> if not isinstance ( value , list ) : <EOL> raise RuntimeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % ( self . _name , value ) ) <EOL> values = value <EOL> else : <EOL> if not isinstance ( value , cls ) : <EOL> raise RuntimeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % <EOL> ( self . _name , cls . __name__ , value ) ) <EOL> values = [ value ] <EOL> for value in values : <EOL> for unused_name , prop in sorted ( value . _properties . iteritems ( ) ) : <EOL> prop . _serialize ( value , pb , prefix + self . _name + '<STR_LIT:.>' , <EOL> self . _repeated or parent_repeated ) <EOL> def _deserialize ( self , entity , p , depth = <NUM_LIT:1> ) : <EOL> if not self . _repeated : <EOL> subentity = self . _retrieve_value ( entity ) <EOL> if subentity is None : <EOL> subentity = self . _modelclass ( ) <EOL> self . _store_value ( entity , subentity ) <EOL> cls = self . _modelclass <EOL> if not isinstance ( subentity , cls ) : <EOL> raise RuntimeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % <EOL> ( self . _name , cls . __name__ , subentity ) ) <EOL> prop = subentity . _get_property_for ( p , depth = depth ) <EOL> prop . _deserialize ( subentity , p , depth + <NUM_LIT:1> ) <EOL> return <EOL> name = p . name ( ) <EOL> parts = name . split ( '<STR_LIT:.>' ) <EOL> if len ( parts ) <= depth : <EOL> raise RuntimeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % <EOL> ( self . _name , depth , parts ) ) <EOL> next = parts [ depth ] <EOL> rest = parts [ depth + <NUM_LIT:1> : ] <EOL> prop = self . _modelclass . _properties . get ( next ) <EOL> if prop is None : <EOL> raise RuntimeError ( '<STR_LIT>' <EOL> % ( next , self . _name ) ) <EOL> values = self . _retrieve_value ( entity ) <EOL> if values is None : <EOL> values = [ ] <EOL> elif not isinstance ( values , list ) : <EOL> values = [ values ] <EOL> self . _store_value ( entity , values ) <EOL> for sub in values : <EOL> if not isinstance ( sub , self . _modelclass ) : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> if not prop . _has_value ( sub , rest ) : <EOL> subentity = sub <EOL> break <EOL> else : <EOL> subentity = self . _modelclass ( ) <EOL> values . append ( subentity ) <EOL> prop . _deserialize ( subentity , p , depth + <NUM_LIT:1> ) <EOL> def _prepare_for_put ( self , entity ) : <EOL> value = self . _get_value ( entity ) <EOL> if value : <EOL> if self . _repeated : <EOL> for subent in value : <EOL> subent . _prepare_for_put ( ) <EOL> else : <EOL> value . _prepare_for_put ( ) <EOL> class LocalStructuredProperty ( BlobProperty ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _indexed = False <EOL> _modelclass = None <EOL> _attributes = [ '<STR_LIT>' ] + BlobProperty . _attributes <EOL> _positional = <NUM_LIT:2> <EOL> @ datastore_rpc . _positional ( <NUM_LIT:1> + _positional ) <EOL> def __init__ ( self , modelclass , name = None , compressed = False , ** kwds ) : <EOL> super ( LocalStructuredProperty , self ) . __init__ ( name = name , <EOL> compressed = compressed , <EOL> ** kwds ) <EOL> if self . _indexed : <EOL> raise NotImplementedError ( '<STR_LIT>' % <EOL> self . _name ) <EOL> self . _modelclass = modelclass <EOL> def _validate ( self , value ) : <EOL> if self . _compressed and isinstance ( value , _CompressedValue ) : <EOL> return value <EOL> if not isinstance ( value , self . _modelclass ) : <EOL> raise datastore_errors . BadValueError ( '<STR_LIT>' % <EOL> ( self . _modelclass . __name__ , value ) ) <EOL> return value <EOL> def _serialize_value ( self , value ) : <EOL> pb = value . _to_pb ( set_key = False ) <EOL> return pb . SerializePartialToString ( ) <EOL> def _deserialize_value ( self , value ) : <EOL> pb = entity_pb . EntityProto ( ) <EOL> pb . MergePartialFromString ( value ) <EOL> return self . _modelclass . _from_pb ( pb , set_key = False ) <EOL> def _prepare_for_put ( self , entity ) : <EOL> value = self . _get_value ( entity ) <EOL> if value : <EOL> if self . _repeated : <EOL> for subent in value : <EOL> subent . _prepare_for_put ( ) <EOL> else : <EOL> value . _prepare_for_put ( ) <EOL> class GenericProperty ( Property ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _db_get_value ( self , v , p ) : <EOL> if v . has_stringvalue ( ) : <EOL> sval = v . stringvalue ( ) <EOL> if p . meaning ( ) not in ( entity_pb . Property . BLOB , <EOL> entity_pb . Property . BYTESTRING ) : <EOL> try : <EOL> sval . decode ( '<STR_LIT:ascii>' ) <EOL> except UnicodeDecodeError : <EOL> try : <EOL> sval = unicode ( sval . decode ( '<STR_LIT:utf-8>' ) ) <EOL> except UnicodeDecodeError : <EOL> pass <EOL> return sval <EOL>", "answer": "elif v . has_int64value ( ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . server import DAPLinkServer <EOL> from . client import DAPLinkClient <EOL> from . client import READ_NOW , READ_START , READ_END <EOL> from . daplink import AP_REG , DP_REG <EOL> from . errors import TransferError , CommandError <EOL>", "answer": "DAPLink = DAPLinkClient"}, {"prompt": "<s> from . client import Client <EOL>", "answer": "from . mock import Mock"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import requests <EOL> import os <EOL> from lxml import html <EOL> import yaml <EOL> from clf . constants import URL <EOL>", "answer": "from clf . exceptions import RequestsException , OSException , DuplicateException"}, {"prompt": "<s> import shutil <EOL> import os . path <EOL> import requests <EOL> from cStringIO import StringIO <EOL> from urlparse import urljoin <EOL> from httmock import urlmatch , HTTMock <EOL> from django . contrib . auth import authenticate <EOL> from django . core . files . storage import get_storage_class <EOL> from django . core . files . uploadedfile import UploadedFile <EOL> from django . core . urlresolvers import reverse <EOL> from django . test import RequestFactory <EOL> from django_digest . test import Client as DigestClient <EOL> from onadata . apps . main . models import MetaData <EOL> from onadata . apps . main . tests . test_base import TestBase <EOL> from onadata . apps . main . views import profile , download_media_data <EOL> from onadata . apps . logger . models import Instance , XForm <EOL> from onadata . apps . logger . views import formList , download_xform , xformsManifest <EOL> from onadata . libs . utils . briefcase_client import BriefcaseClient <EOL> storage = get_storage_class ( ) ( ) <EOL> @ urlmatch ( netloc = r'<STR_LIT>' ) <EOL> def form_list_xml ( url , request , ** kwargs ) : <EOL> response = requests . Response ( ) <EOL> factory = RequestFactory ( ) <EOL> req = factory . get ( url . path ) <EOL> req . user = authenticate ( username = '<STR_LIT>' , password = '<STR_LIT>' ) <EOL> req . user . profile . require_auth = False <EOL> req . user . profile . save ( ) <EOL> id_string = '<STR_LIT>' <EOL> if url . path . endswith ( '<STR_LIT>' ) : <EOL> res = formList ( req , username = '<STR_LIT>' ) <EOL> elif url . path . endswith ( '<STR_LIT>' ) : <EOL> res = download_xform ( req , username = '<STR_LIT>' , id_string = id_string ) <EOL> elif url . path . find ( '<STR_LIT>' ) > - <NUM_LIT:1> : <EOL> res = xformsManifest ( req , username = '<STR_LIT>' , id_string = id_string ) <EOL> elif url . path . find ( '<STR_LIT>' ) > - <NUM_LIT:1> : <EOL> data_id = url . path [ url . path . rfind ( '<STR_LIT:/>' ) + <NUM_LIT:1> : ] <EOL> res = download_media_data ( <EOL> req , username = '<STR_LIT>' , id_string = id_string , data_id = data_id ) <EOL> response . _content = get_streaming_content ( res ) <EOL> else : <EOL> res = formList ( req , username = '<STR_LIT>' ) <EOL> response . status_code = <NUM_LIT:200> <EOL> if not response . _content : <EOL> response . _content = res . content <EOL> return response <EOL> def get_streaming_content ( res ) : <EOL> tmp = StringIO ( ) <EOL> for chunk in res . streaming_content : <EOL> tmp . write ( chunk ) <EOL> content = tmp . getvalue ( ) <EOL> tmp . close ( ) <EOL> return content <EOL> @ urlmatch ( netloc = r'<STR_LIT>' ) <EOL> def instances_xml ( url , request , ** kwargs ) : <EOL> response = requests . Response ( ) <EOL> client = DigestClient ( ) <EOL> client . set_authorization ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> res = client . get ( '<STR_LIT>' % ( url . path , url . query ) ) <EOL> if res . status_code == <NUM_LIT> : <EOL> res = client . get ( res [ '<STR_LIT>' ] ) <EOL> response . encoding = res . get ( '<STR_LIT>' ) <EOL> response . _content = get_streaming_content ( res ) <EOL> else : <EOL> response . _content = res . content <EOL> response . status_code = <NUM_LIT:200> <EOL> return response <EOL> class TestBriefcaseClient ( TestBase ) : <EOL> def setUp ( self ) : <EOL> TestBase . setUp ( self ) <EOL> self . _publish_transportation_form ( ) <EOL> self . _submit_transport_instance_w_attachment ( ) <EOL> src = os . path . join ( self . this_directory , \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> uf = UploadedFile ( file = open ( src ) , content_type = '<STR_LIT>' ) <EOL> count = MetaData . objects . count ( ) <EOL> MetaData . media_upload ( self . xform , uf ) <EOL> self . assertEqual ( MetaData . objects . count ( ) , count + <NUM_LIT:1> ) <EOL> url = urljoin ( <EOL> self . base_url , <EOL> reverse ( profile , kwargs = { '<STR_LIT:username>' : self . user . username } ) <EOL> ) <EOL> self . _logout ( ) <EOL> self . _create_user_and_login ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . bc = BriefcaseClient ( <EOL> username = '<STR_LIT>' , password = '<STR_LIT>' , <EOL> url = url , <EOL> user = self . user <EOL> ) <EOL> def test_download_xform_xml ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with HTTMock ( form_list_xml ) : <EOL> self . bc . download_xforms ( ) <EOL> forms_folder_path = os . path . join ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , self . xform . id_string ) <EOL> self . assertTrue ( storage . exists ( forms_folder_path ) ) <EOL> forms_path = os . path . join ( forms_folder_path , <EOL> '<STR_LIT>' % self . xform . id_string ) <EOL> self . assertTrue ( storage . exists ( forms_path ) ) <EOL> form_media_path = os . path . join ( forms_folder_path , '<STR_LIT>' ) <EOL> self . assertTrue ( storage . exists ( form_media_path ) ) <EOL> media_path = os . path . join ( form_media_path , '<STR_LIT>' ) <EOL> self . assertTrue ( storage . exists ( media_path ) ) <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> with HTTMock ( instances_xml ) : <EOL> self . bc . download_instances ( self . xform . id_string ) <EOL> instance_folder_path = os . path . join ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , self . xform . id_string , '<STR_LIT>' ) <EOL> self . assertTrue ( storage . exists ( instance_folder_path ) ) <EOL> instance = Instance . objects . all ( ) [ <NUM_LIT:0> ] <EOL> instance_path = os . path . join ( <EOL> instance_folder_path , '<STR_LIT>' % instance . uuid , '<STR_LIT>' ) <EOL> self . assertTrue ( storage . exists ( instance_path ) ) <EOL> media_file = \"<STR_LIT>\" <EOL> media_path = os . path . join ( <EOL> instance_folder_path , '<STR_LIT>' % instance . uuid , media_file ) <EOL> self . assertTrue ( storage . exists ( media_path ) ) <EOL> def test_push ( self ) : <EOL> with HTTMock ( form_list_xml ) : <EOL> self . bc . download_xforms ( ) <EOL> with HTTMock ( instances_xml ) : <EOL> self . bc . download_instances ( self . xform . id_string ) <EOL> XForm . objects . all ( ) . delete ( ) <EOL> xforms = XForm . objects . filter ( <EOL>", "answer": "user = self . user , id_string = self . xform . id_string )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> revision = '<STR_LIT>' <EOL> down_revision = '<STR_LIT>' <EOL> from alembic import op <EOL>", "answer": "def upgrade ( ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from cafe . engine . http . client import AutoMarshallingHTTPClient <EOL> from cloudcafe . bare_metal . drivers . models . responses import Driver , Drivers <EOL> class DriversClient ( AutoMarshallingHTTPClient ) : <EOL> def __init__ ( <EOL> self , url , auth_token , serialize_format = None , <EOL> deserialize_format = None ) : <EOL> super ( DriversClient , self ) . __init__ ( <EOL> serialize_format , deserialize_format ) <EOL> self . url = url <EOL> self . auth_token = auth_token <EOL> self . default_headers [ '<STR_LIT>' ] = auth_token <EOL> self . default_headers [ '<STR_LIT:Content-Type>' ] = '<STR_LIT>' . format ( <EOL> self . serialize_format ) <EOL> self . default_headers [ '<STR_LIT>' ] = '<STR_LIT>' . format ( <EOL> self . deserialize_format ) <EOL> def list_drivers ( self , requestslib_kwargs = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url = '<STR_LIT>' . format ( base_url = self . url ) <EOL> resp = self . get ( url , response_entity_type = Drivers , <EOL> requestslib_kwargs = requestslib_kwargs ) <EOL> return resp <EOL> def get_driver ( self , name , requestslib_kwargs = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url = '<STR_LIT>' . format ( <EOL> base_url = self . url , uuid = name ) <EOL> resp = self . get ( url , response_entity_type = Driver , <EOL>", "answer": "requestslib_kwargs = requestslib_kwargs )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import fnmatch <EOL> import locale <EOL> import os <EOL> import sys <EOL> import contextlib <EOL> import json <EOL> import shlex <EOL> import shutil <EOL> import subprocess <EOL> import tempfile <EOL> CONF_FILE = '<STR_LIT>' <EOL> @ contextlib . contextmanager <EOL> def pushd ( directory ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> prevdir = os . getcwd ( ) <EOL> os . chdir ( directory ) <EOL> try : <EOL> yield prevdir <EOL> finally : <EOL> os . chdir ( prevdir ) <EOL> def check_output ( cmd ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> encoding = locale . getdefaultlocale ( ) [ <NUM_LIT:1> ] or '<STR_LIT:utf-8>' <EOL> if hasattr ( subprocess , '<STR_LIT>' ) : <EOL> output = subprocess . check_output ( cmd ) <EOL> else : <EOL> proc = subprocess . Popen ( cmd , stdout = subprocess . PIPE , <EOL> stderr = subprocess . STDOUT ) <EOL> output = proc . communicate ( ) [ <NUM_LIT:0> ] <EOL> if proc . returncode != <NUM_LIT:0> : <EOL> raise subprocess . CalledProcessError ( proc . returncode , cmd , <EOL> output ) <EOL> return output . decode ( encoding ) <EOL> def run_checks ( hooks_all , hooks_modified , modified , path ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> retcode = <NUM_LIT:0> <EOL> for command in hooks_all : <EOL> if not isinstance ( command , list ) : <EOL> command = shlex . split ( command ) <EOL> retcode |= subprocess . call ( command , env = { '<STR_LIT>' : path } ) <EOL> for pattern , command in hooks_modified : <EOL> if not isinstance ( command , list ) : <EOL> command = shlex . split ( command ) <EOL> for filename in modified : <EOL> if not fnmatch . fnmatch ( filename , pattern ) : <EOL> continue <EOL> printed_filename = False <EOL> proc = subprocess . Popen ( command + [ filename ] , <EOL> env = { '<STR_LIT>' : path } , <EOL> stdout = subprocess . PIPE , <EOL> stderr = subprocess . STDOUT ) <EOL> output = proc . communicate ( ) [ <NUM_LIT:0> ] <EOL> if proc . returncode != <NUM_LIT:0> : <EOL> if not printed_filename : <EOL> print ( filename ) <EOL> print ( '<STR_LIT:=>' * len ( filename ) ) <EOL> printed_filename = True <EOL> print ( command [ <NUM_LIT:0> ] ) <EOL> print ( '<STR_LIT:->' * len ( command [ <NUM_LIT:0> ] ) ) <EOL> print ( output ) <EOL> retcode |= proc . returncode <EOL> return retcode <EOL> def load_conf ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if os . path . exists ( CONF_FILE ) : <EOL> with open ( CONF_FILE , '<STR_LIT:r>' ) as infile : <EOL> return json . load ( infile ) <EOL> else : <EOL> return { } <EOL> def copy_index ( tmpdir ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> subprocess . check_call ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' <EOL> % tmpdir ] ) <EOL> output = check_output ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:status>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ] ) <EOL> for line in output . splitlines ( ) : <EOL> ref , path , _ = line . split ( ) <EOL> ref = ref . strip ( '<STR_LIT:+>' ) <EOL> with pushd ( path ) : <EOL> archive = subprocess . Popen ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ref ] , <EOL> stdout = subprocess . PIPE ) <EOL> untar_cmd = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' % ( tmpdir , path ) ] <EOL> untar = subprocess . Popen ( untar_cmd , stdin = archive . stdout , <EOL> stdout = subprocess . PIPE , <EOL> stderr = subprocess . STDOUT ) <EOL> out = untar . communicate ( ) [ <NUM_LIT:0> ] <EOL> if untar . returncode != <NUM_LIT:0> : <EOL> raise subprocess . CalledProcessError ( untar . returncode , <EOL> untar_cmd , out ) <EOL> def precommit ( exit = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> tmpdir = tempfile . mkdtemp ( ) <EOL> try : <EOL> copy_index ( tmpdir ) <EOL> modified = check_output ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ] ) <EOL> modified = [ name . strip ( ) for name in modified . splitlines ( ) ] <EOL>", "answer": "path = os . environ [ '<STR_LIT>' ]"}, {"prompt": "<s> from __future__ import absolute_import <EOL> import copy <EOL> from collections import namedtuple <EOL> from datetime import datetime , date <EOL> import uuid <EOL> from functools import partial <EOL> from xml . etree import ElementTree <EOL> from casexml . apps . case . util import post_case_blocks <EOL> from dimagi . utils . parsing import json_format_datetime <EOL> from casexml . apps . case . xml import V1 , NS_VERSION_MAP , V2 <EOL> from casexml . apps . case . const import DEFAULT_CASE_INDEX_IDENTIFIERS , CASE_INDEX_CHILD <EOL> IndexAttrs = namedtuple ( '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> ChildIndexAttrs = partial ( IndexAttrs , relationship = '<STR_LIT>' ) <EOL> class CaseBlock ( dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> undefined = object ( ) <EOL> def __init__ ( self , <EOL> case_id , <EOL> date_modified = None , <EOL> user_id = undefined , <EOL> owner_id = undefined , <EOL>", "answer": "external_id = undefined ,"}, {"prompt": "<s> import codecs <EOL> import sys <EOL> import traceback <EOL> from seleniumbase . config import settings <EOL> def log_screenshot ( test_logpath , driver ) : <EOL> screenshot_name = settings . SCREENSHOT_NAME <EOL> screenshot_path = \"<STR_LIT>\" % ( test_logpath , screenshot_name ) <EOL> driver . get_screenshot_as_file ( screenshot_path ) <EOL> def log_test_failure_data ( test_logpath , driver , browser ) : <EOL> basic_info_name = settings . BASIC_INFO_NAME <EOL> basic_file_path = \"<STR_LIT>\" % ( test_logpath , basic_info_name ) <EOL> log_file = codecs . open ( basic_file_path , \"<STR_LIT>\" , \"<STR_LIT:utf-8>\" ) <EOL>", "answer": "last_page = get_last_page ( driver )"}, {"prompt": "<s> from selenium . webdriver . remote . webelement import WebElement <EOL> import saunter . exceptions <EOL> class WebElement ( WebElement ) : <EOL> def __init__ ( self , element ) : <EOL> self . __dict__ . update ( element . __dict__ ) <EOL> def find_element_by_locator ( self , locator ) : <EOL> locator_type = locator [ : locator . find ( \"<STR_LIT:=>\" ) ] <EOL> if locator_type == \"<STR_LIT>\" : <EOL> raise saunter . exceptions . InvalidLocatorString ( locator ) <EOL> locator_value = locator [ locator . find ( \"<STR_LIT:=>\" ) + <NUM_LIT:1> : ] <EOL> if locator_type == '<STR_LIT:class>' : <EOL> return WebElement ( self . find_element_by_class_name ( locator_value ) ) <EOL> elif locator_type == '<STR_LIT>' : <EOL> return WebElement ( self . find_element_by_css_selector ( locator_value ) ) <EOL> elif locator_type == '<STR_LIT:id>' : <EOL> return WebElement ( self . find_element_by_id ( locator_value ) ) <EOL> elif locator_type == '<STR_LIT>' : <EOL> return WebElement ( self . find_element_by_link_text ( locator_value ) ) <EOL> elif locator_type == '<STR_LIT:name>' : <EOL>", "answer": "return WebElement ( self . find_element_by_name ( locator_value ) )"}, {"prompt": "<s> from setuptools import setup <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> url = '<STR_LIT>' , <EOL> summary = '<STR_LIT>' , <EOL> license = '<STR_LIT>' , <EOL> packages = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL>", "answer": "'<STR_LIT>' ,"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import migrations , models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AlterField ( <EOL>", "answer": "model_name = '<STR_LIT>' ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from googleads import dfp <EOL> def main ( client ) : <EOL> custom_targeting_service = client . GetService ( <EOL> '<STR_LIT>' , version = '<STR_LIT>' ) <EOL>", "answer": "keys = ["}, {"prompt": "<s> from __future__ import unicode_literals <EOL> from django . db import models , migrations <EOL> import taggit . managers <EOL> import aldryn_categories . fields <EOL> import aldryn_newsblog . models <EOL> import filer . fields . image <EOL> from django . conf import settings <EOL> import sortedm2m . fields <EOL> import django . utils . timezone <EOL> import djangocms_text_ckeditor . fields <EOL> import cms . models . fields <EOL> import app_data . fields <EOL> import aldryn_apphooks_config . fields <EOL> import django . core . validators <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> migrations . swappable_dependency ( settings . AUTH_USER_MODEL ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , serialize = False , auto_created = True , primary_key = True ) ) , <EOL> ( '<STR_LIT>' , models . DateTimeField ( default = django . utils . timezone . now , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . BooleanField ( default = True , db_index = True , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . BooleanField ( default = False , db_index = True , verbose_name = '<STR_LIT>' ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] , <EOL> } , <EOL> bases = ( models . Model , ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , serialize = False , auto_created = True , primary_key = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT:15> , verbose_name = '<STR_LIT>' , db_index = True ) ) , <EOL> ( '<STR_LIT:title>' , models . CharField ( max_length = <NUM_LIT> , verbose_name = '<STR_LIT:title>' ) ) , <EOL> ( '<STR_LIT>' , models . SlugField ( help_text = '<STR_LIT>' , max_length = <NUM_LIT:255> , verbose_name = '<STR_LIT>' , blank = True ) ) , <EOL> ( '<STR_LIT>' , djangocms_text_ckeditor . fields . HTMLField ( default = '<STR_LIT>' , help_text = '<STR_LIT>' , verbose_name = '<STR_LIT>' , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( default = '<STR_LIT>' , max_length = <NUM_LIT:255> , verbose_name = '<STR_LIT>' , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . TextField ( default = '<STR_LIT>' , verbose_name = '<STR_LIT>' , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . TextField ( default = '<STR_LIT>' , verbose_name = '<STR_LIT>' , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . TextField ( editable = False , blank = True ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( related_name = '<STR_LIT>' , editable = False , to = '<STR_LIT>' , null = True ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : ( ) , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> bases = ( models . Model , ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT>' , models . OneToOneField ( parent_link = True , related_name = '<STR_LIT:+>' , primary_key = True , serialize = False , to = '<STR_LIT>' ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> bases = ( aldryn_newsblog . models . PluginEditModeMixin , '<STR_LIT>' ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT>' , models . OneToOneField ( parent_link = True , related_name = '<STR_LIT:+>' , primary_key = True , serialize = False , to = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . PositiveIntegerField ( default = <NUM_LIT:10> , help_text = '<STR_LIT>' , verbose_name = '<STR_LIT>' , validators = [ django . core . validators . MinValueValidator ( <NUM_LIT:1> ) ] ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> bases = ( '<STR_LIT>' , ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT>' , models . OneToOneField ( parent_link = True , related_name = '<STR_LIT:+>' , primary_key = True , serialize = False , to = '<STR_LIT>' ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> bases = ( aldryn_newsblog . models . PluginEditModeMixin , '<STR_LIT>' ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT>' , models . OneToOneField ( parent_link = True , related_name = '<STR_LIT:+>' , primary_key = True , serialize = False , to = '<STR_LIT>' ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> bases = ( aldryn_newsblog . models . PluginEditModeMixin , '<STR_LIT>' ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , serialize = False , auto_created = True , primary_key = True ) ) , <EOL> ( '<STR_LIT:type>' , models . CharField ( max_length = <NUM_LIT:100> , verbose_name = '<STR_LIT:type>' ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( default = None , unique = True , max_length = <NUM_LIT:100> , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , app_data . fields . AppDataField ( default = dict , editable = False ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( default = '<STR_LIT>' , help_text = '<STR_LIT>' , max_length = <NUM_LIT:8> , verbose_name = '<STR_LIT>' , choices = [ ( '<STR_LIT:s>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) ] ) ) , <EOL> ( '<STR_LIT>' , models . SmallIntegerField ( default = <NUM_LIT> , help_text = '<STR_LIT>' , verbose_name = '<STR_LIT>' , choices = [ ( <NUM_LIT:200> , '<STR_LIT>' ) , ( <NUM_LIT> , '<STR_LIT>' ) , ( <NUM_LIT> , '<STR_LIT>' ) , ( <NUM_LIT> , '<STR_LIT>' ) ] ) ) , <EOL> ( '<STR_LIT>' , models . PositiveIntegerField ( default = <NUM_LIT:5> , help_text = '<STR_LIT>' , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . BooleanField ( default = True , help_text = '<STR_LIT>' , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . BooleanField ( default = True , help_text = '<STR_LIT>' , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , cms . models . fields . PlaceholderField ( related_name = '<STR_LIT>' , slotname = '<STR_LIT>' , editable = False , to = '<STR_LIT>' , null = True ) ) , <EOL> ( '<STR_LIT>' , cms . models . fields . PlaceholderField ( related_name = '<STR_LIT>' , slotname = '<STR_LIT>' , editable = False , to = '<STR_LIT>' , null = True ) ) , <EOL> ( '<STR_LIT>' , cms . models . fields . PlaceholderField ( related_name = '<STR_LIT>' , slotname = '<STR_LIT>' , editable = False , to = '<STR_LIT>' , null = True ) ) , <EOL> ( '<STR_LIT>' , cms . models . fields . PlaceholderField ( related_name = '<STR_LIT>' , slotname = '<STR_LIT>' , editable = False , to = '<STR_LIT>' , null = True ) ) , <EOL> ( '<STR_LIT>' , cms . models . fields . PlaceholderField ( related_name = '<STR_LIT>' , slotname = '<STR_LIT>' , editable = False , to = '<STR_LIT>' , null = True ) ) , <EOL> ( '<STR_LIT>' , cms . models . fields . PlaceholderField ( related_name = '<STR_LIT>' , slotname = '<STR_LIT>' , editable = False , to = '<STR_LIT>' , null = True ) ) , <EOL> ( '<STR_LIT>' , cms . models . fields . PlaceholderField ( related_name = '<STR_LIT>' , slotname = '<STR_LIT>' , editable = False , to = '<STR_LIT>' , null = True ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> bases = ( models . Model , ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT:id>' , models . AutoField ( verbose_name = '<STR_LIT>' , serialize = False , auto_created = True , primary_key = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT:15> , verbose_name = '<STR_LIT>' , db_index = True ) ) , <EOL> ( '<STR_LIT>' , models . CharField ( max_length = <NUM_LIT> , verbose_name = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( related_name = '<STR_LIT>' , editable = False , to = '<STR_LIT>' , null = True ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : ( ) , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } , <EOL> bases = ( models . Model , ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT>' , models . OneToOneField ( parent_link = True , related_name = '<STR_LIT:+>' , primary_key = True , serialize = False , to = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . PositiveIntegerField ( default = <NUM_LIT:1> , help_text = '<STR_LIT>' , validators = [ django . core . validators . MinValueValidator ( <NUM_LIT:1> ) ] ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( to = '<STR_LIT>' ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> bases = ( aldryn_newsblog . models . PluginEditModeMixin , '<STR_LIT>' ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT>' , models . OneToOneField ( parent_link = True , related_name = '<STR_LIT:+>' , primary_key = True , serialize = False , to = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . IntegerField ( default = <NUM_LIT:5> , help_text = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( to = '<STR_LIT>' ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> bases = ( aldryn_newsblog . models . PluginEditModeMixin , '<STR_LIT>' ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT>' , models . OneToOneField ( parent_link = True , related_name = '<STR_LIT:+>' , primary_key = True , serialize = False , to = '<STR_LIT>' ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> bases = ( aldryn_newsblog . models . PluginEditModeMixin , '<STR_LIT>' ) , <EOL> ) , <EOL> migrations . CreateModel ( <EOL> name = '<STR_LIT>' , <EOL> fields = [ <EOL> ( '<STR_LIT>' , models . OneToOneField ( parent_link = True , related_name = '<STR_LIT:+>' , primary_key = True , serialize = False , to = '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , models . ForeignKey ( to = '<STR_LIT>' ) ) , <EOL> ] , <EOL> options = { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> bases = ( aldryn_newsblog . models . PluginEditModeMixin , '<STR_LIT>' ) , <EOL> ) , <EOL> migrations . AlterUniqueTogether ( <EOL> name = '<STR_LIT>' , <EOL> unique_together = set ( [ ( '<STR_LIT>' , '<STR_LIT>' ) ] ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field = models . ForeignKey ( to = '<STR_LIT>' ) , <EOL> preserve_default = True , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field = models . ForeignKey ( to = '<STR_LIT>' ) , <EOL> preserve_default = True , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field = models . ForeignKey ( to = '<STR_LIT>' ) , <EOL> preserve_default = True , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field = models . ForeignKey ( to = '<STR_LIT>' ) , <EOL> preserve_default = True , <EOL> ) , <EOL> migrations . AlterUniqueTogether ( <EOL> name = '<STR_LIT>' , <EOL> unique_together = set ( [ ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) ] ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field = aldryn_apphooks_config . fields . AppHookConfigField ( verbose_name = '<STR_LIT>' , to = '<STR_LIT>' , help_text = '<STR_LIT>' ) , <EOL> preserve_default = True , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field = models . ForeignKey ( verbose_name = '<STR_LIT>' , blank = True , to = '<STR_LIT>' , null = True ) , <EOL> preserve_default = True , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = '<STR_LIT>' , <EOL> name = '<STR_LIT>' , <EOL> field = aldryn_categories . fields . CategoryManyToManyField ( to = '<STR_LIT>' , verbose_name = '<STR_LIT>' , blank = True ) , <EOL> preserve_default = True , <EOL>", "answer": ") ,"}, {"prompt": "<s> PNC = '<STR_LIT>' <EOL> DELIVERY = '<STR_LIT>' <EOL> REGISTRATION = '<STR_LIT>' <EOL> EBF = '<STR_LIT>' <EOL>", "answer": "CF = '<STR_LIT>'"}, {"prompt": "<s> __author__ = '<STR_LIT>' <EOL> import httplib <EOL> import logging <EOL> import sys <EOL> import urllib2 <EOL> import hashlib <EOL> from base64 import b64encode <EOL> from oauth import oauth <EOL> import simplejson <EOL> try : <EOL> from google . appengine . api import urlfetch <EOL> except : <EOL> pass <EOL> logging . basicConfig ( level = logging . DEBUG ) <EOL> VERBOSE = <NUM_LIT:0> <EOL> def get_default_urlfetch ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if sys . modules . has_key ( '<STR_LIT>' ) : <EOL> return AppEngineUrlFetch ( ) <EOL> return UrlFetch ( ) <EOL> def log_request ( request ) : <EOL> logging . debug ( '<STR_LIT>' % <EOL> ( request . get_method ( ) , <EOL> request . get_url ( ) , <EOL> str ( request . get_headers ( ) ) , <EOL> request . get_post_body ( ) ) ) <EOL> def log_response ( response ) : <EOL> logging . debug ( '<STR_LIT>' % ( response . status , <EOL> response . content . decode ( '<STR_LIT:utf-8>' ) ) ) <EOL> class UrlFetch ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def fetch ( self , request ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> log_request ( request ) <EOL> method = request . get_method ( ) <EOL> headers = request . get_headers ( ) <EOL> if VERBOSE > <NUM_LIT:0> : <EOL> logging . info ( \"<STR_LIT>\" , request . get_url ( ) ) <EOL> req = urllib2 . Request ( request . get_url ( ) , <EOL> data = request . get_post_body ( ) , <EOL> headers = headers ) <EOL> try : <EOL> f = urllib2 . urlopen ( req ) <EOL> result = f . read ( ) <EOL> response = Response ( httplib . OK , result ) <EOL> except urllib2 . URLError , e : <EOL> response = Response ( e . code , e . read ( ) ) <EOL> log_response ( response ) <EOL> return response <EOL> class AppEngineUrlFetch ( UrlFetch ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def fetch ( self , request ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> log_request ( request ) <EOL> method = request . get_method ( ) <EOL> url = request . get_url ( ) <EOL> body = request . get_post_body ( ) <EOL> headers = request . get_headers ( ) <EOL> result = urlfetch . fetch ( <EOL> method = method , <EOL> url = url , <EOL> payload = body , <EOL> headers = headers ) <EOL> response = Response ( result . status_code , result . content ) <EOL> log_response ( response ) <EOL> return response <EOL> class Request ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , url , method = '<STR_LIT:GET>' , signed_params = None , post_body = None ) : <EOL> self . post_body = post_body or None <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . use_body_as_signing_parameter = False <EOL> params = signed_params or { } <EOL> params [ '<STR_LIT>' ] = method <EOL> self . oauth_request = oauth . OAuthRequest . from_request ( method , url , <EOL> parameters = params ) <EOL> assert self . oauth_request <EOL> def add_security_token ( self , security_token , parameter_name = \"<STR_LIT>\" ) : <EOL> self . oauth_request . set_parameter ( parameter_name , security_token ) <EOL> self . security_token_parameter = parameter_name <EOL> def get_security_token ( self ) : <EOL> if hasattr ( self , \"<STR_LIT>\" ) : <EOL> return self . oauth_request . get_parameter ( self . security_token_parameter ) <EOL> def set_body_as_signing_parameter ( self , use_body ) : <EOL> self . use_body_as_signing_parameter = use_body <EOL> def sign_request ( self , consumer , signature_method ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> params = { <EOL> '<STR_LIT>' : consumer . key , <EOL> '<STR_LIT>' : oauth . generate_timestamp ( ) , <EOL> '<STR_LIT>' : oauth . generate_nonce ( ) , <EOL> '<STR_LIT>' : oauth . OAuthRequest . version , <EOL> } <EOL> if self . use_body_as_signing_parameter : <EOL> params [ self . get_post_body ( ) ] = \"<STR_LIT>\" <EOL> else : <EOL> if self . post_body : <EOL> if VERBOSE > <NUM_LIT:0> : <EOL> logging . info ( \"<STR_LIT>\" % str ( self . post_body ) ) <EOL> body_hash = b64encode ( hashlib . sha1 ( self . get_post_body ( ) ) . digest ( ) ) <EOL> params [ '<STR_LIT>' ] = body_hash <EOL> if self . get_security_token ( ) : <EOL> self . set_parameter ( \"<STR_LIT>\" , None ) <EOL> self . set_parameters ( params ) <EOL> if VERBOSE > <NUM_LIT:0> : <EOL> key , raw = signature_method . build_signature_base_string ( <EOL> self . oauth_request , consumer , None ) <EOL> logging . info ( \"<STR_LIT>\" % key ) <EOL> logging . info ( \"<STR_LIT>\" % raw ) <EOL> self . oauth_request . sign_request ( signature_method , consumer , None ) <EOL>", "answer": "def set_parameter ( self , name , value ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import urllib <EOL> import urllib2 <EOL> import imp <EOL> import subprocess <EOL> import StringIO <EOL> import time <EOL> import logging . handlers <EOL> import boto <EOL> import tempfile <EOL> import smtplib <EOL> import datetime <EOL> from email . MIMEMultipart import MIMEMultipart <EOL> from email . MIMEBase import MIMEBase <EOL> from email . MIMEText import MIMEText <EOL> from email . Utils import formatdate <EOL> from email import Encoders <EOL> import gzip <EOL> try : <EOL> import hashlib <EOL> _hashfn = hashlib . sha512 <EOL> except ImportError : <EOL> import md5 <EOL> _hashfn = md5 . md5 <EOL> qsa_of_interest = [ '<STR_LIT>' , '<STR_LIT:location>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> def canonical_string ( method , path , headers , expires = None , <EOL> provider = None ) : <EOL> if not provider : <EOL> provider = boto . provider . get_default ( ) <EOL>", "answer": "interesting_headers = { }"}, {"prompt": "<s> from __future__ import division , print_function , unicode_literals <EOL> import sys <EOL>", "answer": "import os"}, {"prompt": "<s> NAME = '<STR_LIT>' <EOL> def is_waf ( self ) : <EOL> detected = False <EOL> if self . matchcookie ( '<STR_LIT>' ) and self . matchcookie ( '<STR_LIT>' ) : <EOL> return True <EOL>", "answer": "elif self . matchheader ( ( '<STR_LIT>' , '<STR_LIT>' ) ) and self . matchcookie ( '<STR_LIT>' ) :"}, {"prompt": "<s> import objc , os , re <EOL> import cIO <EOL> for cls in [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : <EOL> globals ( ) [ cls ] = objc . lookUpClass ( cls ) <EOL> class ExportSession ( object ) : <EOL> def __init__ ( self ) : <EOL> self . running = True <EOL> self . cancelled = False <EOL> self . added = <NUM_LIT:0> <EOL> self . written = <NUM_LIT:0> <EOL> self . total = <NUM_LIT:0> <EOL> self . _complete = None <EOL> self . _progress = None <EOL> self . _status = None <EOL> self . writer = None <EOL> def begin ( self , frames = None , pages = None ) : <EOL> from plotdevice . gui import set_timeout <EOL> self . total = frames if frames is not None else pages <EOL> self . poll = set_timeout ( self , \"<STR_LIT>\" , <NUM_LIT:0.1> , repeat = True ) <EOL> def update_ ( self , note ) : <EOL> self . written = self . writer . framesWritten ( ) <EOL> if self . _progress : <EOL> goal = self . added if self . cancelled else self . total <EOL> self . _progress ( self . written , goal , self . cancelled ) <EOL> if self . writer . doneWriting ( ) : <EOL> self . shutdown ( ) <EOL> def next ( self ) : <EOL> if self . cancelled or self . added == self . total : <EOL> return None <EOL> return self . added + <NUM_LIT:1> <EOL> def cancel ( self ) : <EOL> if self . cancelled : <EOL> return <EOL> self . cancelled = True <EOL> if self . _status : <EOL> self . _status ( '<STR_LIT>' ) <EOL> def done ( self ) : <EOL> if self . writer : <EOL> self . writer . closeFile ( ) <EOL> def shutdown ( self ) : <EOL> self . running = False <EOL> self . _progress = None <EOL> if self . _status : <EOL> self . _status ( '<STR_LIT>' ) <EOL> self . _status = None <EOL> if self . poll : <EOL> self . poll . invalidate ( ) <EOL> self . poll = None <EOL> if self . _complete : <EOL> self . _complete ( ) <EOL> self . _complete = None <EOL> self . writer = None <EOL> def on ( self , ** handlers ) : <EOL> for event , cb in handlers . items ( ) : <EOL> setattr ( self , '<STR_LIT:_>' + event , cb ) <EOL> if '<STR_LIT>' in handlers and not self . running : <EOL> self . shutdown ( ) <EOL> re_padded = re . compile ( r'<STR_LIT>' ) <EOL> class ImageExportSession ( ExportSession ) : <EOL> def __init__ ( self , fname , format = '<STR_LIT>' , first = <NUM_LIT:1> , last = None , single = False , ** rest ) : <EOL> super ( ImageExportSession , self ) . __init__ ( ) <EOL> self . single_file = single or first == last <EOL> if last is not None : <EOL>", "answer": "self . begin ( pages = last - first + <NUM_LIT:1> )"}, {"prompt": "<s> from uuid import uuid4 <EOL> from sqlalchemy import Column , String , Integer <EOL> from sqlalchemy . schema import UniqueConstraint <EOL> from changes . config import db <EOL> from changes . db . types . guid import GUID <EOL> from changes . db . utils import model_repr <EOL> class ItemStat ( db . Model ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> __tablename__ = '<STR_LIT>' <EOL> __table_args__ = ( <EOL> UniqueConstraint ( '<STR_LIT>' , '<STR_LIT:name>' , name = '<STR_LIT>' ) , <EOL> ) <EOL>", "answer": "id = Column ( GUID , primary_key = True , default = uuid4 )"}, {"prompt": "<s> from django . test import SimpleTestCase <EOL> from . . utils import setup <EOL> class SafeseqTests ( SimpleTestCase ) : <EOL> @ setup ( { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> def test_safeseq01 ( self ) : <EOL> output = self . engine . render_to_string ( '<STR_LIT>' , { '<STR_LIT:a>' : [ '<STR_LIT:&>' , '<STR_LIT:<>' ] } ) <EOL> self . assertEqual ( output , '<STR_LIT>' ) <EOL> @ setup ( { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> def test_safeseq02 ( self ) : <EOL>", "answer": "output = self . engine . render_to_string ( '<STR_LIT>' , { '<STR_LIT:a>' : [ '<STR_LIT:&>' , '<STR_LIT:<>' ] } )"}, {"prompt": "<s> import logging <EOL>", "answer": "import paho . mqtt . client as mqtt"}, {"prompt": "<s> import sublime , sublime_plugin <EOL> import os <EOL> import threading <EOL> import queue <EOL> import asyncore <EOL> import socket <EOL> from itertools import chain <EOL> import re <EOL> settings = sublime . load_settings ( \"<STR_LIT>\" ) <EOL> TCP_IP = '<STR_LIT:127.0.0.1>' <EOL> TCP_PORT = <NUM_LIT> <EOL> BUFFER_SIZE = <NUM_LIT> <EOL> BASEDIR = settings . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> STEP_ON_CONNECT = settings . get ( \"<STR_LIT>\" , False ) <EOL> class SubDebugHandler ( asyncore . dispatcher ) : <EOL> def __init__ ( self , socket , handler_id ) : <EOL> asyncore . dispatcher . __init__ ( self , socket ) <EOL> self . handler_id = handler_id <EOL> msg_queue . put ( b\"<STR_LIT>\" if STEP_ON_CONNECT else b\"<STR_LIT>\" ) <EOL> for view_name , row in state_handler . breakpoints ( ) : <EOL> msg_queue . put ( \"<STR_LIT>\" . format ( view_name , row ) . encode ( '<STR_LIT>' ) ) <EOL> def handle_read ( self ) : <EOL> data = self . recv ( BUFFER_SIZE ) <EOL> if data : <EOL> print ( self . handler_id , \"<STR_LIT>\" , data ) <EOL> split = data . split ( ) <EOL> if split [ <NUM_LIT:0> ] in message_parsers : <EOL> message_parsers [ split [ <NUM_LIT:0> ] ] ( split ) <EOL> def handle_write ( self ) : <EOL> if not msg_queue . empty ( ) : <EOL> msg = msg_queue . get ( ) <EOL> print ( \"<STR_LIT>\" , msg ) <EOL> self . send ( msg ) <EOL> def handle_error ( self ) : <EOL> raise <EOL> class SubDebugServer ( asyncore . dispatcher ) : <EOL> def __init__ ( self , host , port ) : <EOL> asyncore . dispatcher . __init__ ( self ) <EOL> self . handler_id = <NUM_LIT:0> <EOL> self . create_socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> self . set_reuse_addr ( ) <EOL> self . bind ( ( host , port ) ) <EOL> self . listen ( <NUM_LIT:1> ) <EOL> print ( \"<STR_LIT>\" , host , \"<STR_LIT::>\" , port ) <EOL> def handle_accept ( self ) : <EOL> pair = self . accept ( ) <EOL> if pair is not None : <EOL> ( conn_sock , client_address ) = pair <EOL> print ( \"<STR_LIT>\" , client_address ) <EOL> SubDebugHandler ( conn_sock , + + self . handler_id ) <EOL> def handle_close ( self ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> self . close ( ) <EOL> def handle_error ( self ) : <EOL> self . close ( ) <EOL> class RunCommand ( sublime_plugin . WindowCommand ) : <EOL> def run ( self ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> msg_queue . put ( b\"<STR_LIT>\" ) <EOL> state_handler . remove_line_marker ( ) <EOL> class StepCommand ( sublime_plugin . WindowCommand ) : <EOL> def run ( self ) : <EOL> print ( \"<STR_LIT>\" ) <EOL> msg_queue . put ( b\"<STR_LIT>\" ) <EOL> class ToggleBreakpointCommand ( sublime_plugin . TextCommand ) : <EOL> def run ( self , edit ) : <EOL> view_name = simplify_path ( self . view . file_name ( ) ) <EOL> row , _ = self . view . rowcol ( self . view . sel ( ) [ <NUM_LIT:0> ] . begin ( ) ) <EOL> print ( \"<STR_LIT>\" , view_name , row ) <EOL> state_handler . toggle_breakpoint ( view_name , row + <NUM_LIT:1> ) <EOL> class SetBasedirCommand ( sublime_plugin . WindowCommand ) : <EOL> def run ( self ) : <EOL> def choose_other ( path ) : <EOL> global BASEDIR <EOL> BASEDIR = path . replace ( '<STR_LIT:\\\\>' , '<STR_LIT:/>' ) <EOL> if ( BASEDIR [ - <NUM_LIT:1> ] != \"<STR_LIT:/>\" ) : <EOL> BASEDIR += \"<STR_LIT:/>\" <EOL> print ( \"<STR_LIT>\" , BASEDIR ) <EOL> def selected_folder ( index ) : <EOL> global BASEDIR <EOL> if index != - <NUM_LIT:1> : <EOL> if ( index == len ( folders ) - <NUM_LIT:1> ) : <EOL> sublime . active_window ( ) . show_input_panel ( \"<STR_LIT>\" , BASEDIR , choose_other , None , None ) <EOL>", "answer": "else :"}]