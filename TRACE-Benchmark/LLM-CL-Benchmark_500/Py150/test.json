[{"prompt": "<s> from django . conf . urls . defaults import * <EOL> from django . conf import settings <EOL> from django . contrib import admin <EOL> admin . autodiscover ( ) <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL> ( r'<STR_LIT>' , include ( '<STR_LIT>' ) ) , <EOL> ( r'<STR_LIT>' , include ( admin . site . urls ) ) , <EOL> ( r'<STR_LIT>' , include ( '<STR_LIT>' ) ) , <EOL> ( r'<STR_LIT>' , include ( '<STR_LIT>' ) ) , <EOL> ) <EOL> if settings . DEBUG : <EOL> urlpatterns += patterns ( '<STR_LIT>' , <EOL> ( r'<STR_LIT>' % settings . MEDIA_URL . strip ( '<STR_LIT:/>' ) , '<STR_LIT>' , <EOL> { '<STR_LIT>' : settings . MEDIA_ROOT } ) <EOL>", "answer": ") "}, {"prompt": "<s> from __future__ import unicode_literals <EOL> import frappe <EOL> from frappe import _ <EOL> import frappe . sessions <EOL> from frappe . utils import cstr <EOL> import mimetypes , json <EOL> from werkzeug . wrappers import Response <EOL> from werkzeug . routing import Map , Rule , NotFound <EOL> from frappe . website . context import get_context <EOL> from frappe . website . utils import get_home_page , can_cache , delete_page_cache <EOL> from frappe . website . router import clear_sitemap <EOL> from frappe . translate import guess_language <EOL> class PageNotFoundError ( Exception ) : pass <EOL> def render ( path , http_status_code = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = resolve_path ( path . strip ( \"<STR_LIT>\" ) ) <EOL> try : <EOL> data = render_page_by_language ( path ) <EOL> except frappe . DoesNotExistError , e : <EOL> doctype , name = get_doctype_from_path ( path ) <EOL> if doctype and name : <EOL> path = \"<STR_LIT>\" <EOL> frappe . local . form_dict . doctype = doctype <EOL> frappe . local . form_dict . name = name <EOL> elif doctype : <EOL> path = \"<STR_LIT:list>\" <EOL> frappe . local . form_dict . doctype = doctype <EOL> else : <EOL> path = \"<STR_LIT>\" <EOL> http_status_code = e . http_status_code <EOL> try : <EOL> data = render_page ( path ) <EOL> except frappe . PermissionError , e : <EOL> data , http_status_code = render_403 ( e , path ) <EOL> except frappe . PermissionError , e : <EOL> data , http_status_code = render_403 ( e , path ) <EOL> except frappe . Redirect , e : <EOL> return build_response ( path , \"<STR_LIT>\" , <NUM_LIT> , { <EOL> \"<STR_LIT>\" : frappe . flags . redirect_location , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } ) <EOL> except Exception : <EOL> path = \"<STR_LIT:error>\" <EOL> data = render_page ( path ) <EOL> http_status_code = <NUM_LIT> <EOL> data = add_csrf_token ( data ) <EOL>", "answer": "return build_response ( path , data , http_status_code or <NUM_LIT:200> )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from ctypes import wintypes , WINFUNCTYPE <EOL> import signal <EOL> import ctypes <EOL> import mmap <EOL> import sys <EOL> HandlerRoutine = WINFUNCTYPE ( wintypes . BOOL , wintypes . DWORD ) <EOL> def _ctrl_handler ( sig ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "if sig == signal . CTRL_C_EVENT :"}, {"prompt": "<s> from django . conf . urls import patterns , include , url <EOL> from . web . views import * <EOL> from django_sse . redisqueue import RedisQueueView <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL> url ( r'<STR_LIT>' , Home1 . as_view ( ) , name = '<STR_LIT>' ) , <EOL> url ( r'<STR_LIT>' , Home2 . as_view ( ) , name = '<STR_LIT>' ) , <EOL>", "answer": "url ( r'<STR_LIT>' , MySseEvents . as_view ( ) , name = '<STR_LIT>' ) ,"}, {"prompt": "<s> from tempfile import NamedTemporaryFile <EOL> import openpyxl <EOL> class JSONReaderError ( Exception ) : <EOL> pass <EOL> class HeaderValueError ( Exception ) : <EOL> pass <EOL> class IteratorJSONReader ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , rows ) : <EOL> self . _rows = iter ( rows ) <EOL> try : <EOL> self . headers = list ( self . _rows . next ( ) ) <EOL> except StopIteration : <EOL> self . headers = [ ] <EOL> self . fieldnames = self . get_fieldnames ( ) <EOL> def row_to_json ( self , row ) : <EOL> obj = { } <EOL> for value , header in zip ( row , self . headers ) : <EOL> self . set_field_value ( obj , header , value ) <EOL> return obj <EOL> def __iter__ ( self ) : <EOL> try : <EOL> for row in self . _rows : <EOL> yield self . row_to_json ( row ) <EOL> finally : <EOL> del self . _rows <EOL> def get_fieldnames ( self ) : <EOL> obj = { } <EOL> for field , value in zip ( self . headers , [ '<STR_LIT>' ] * len ( self . headers ) ) : <EOL> if not isinstance ( field , basestring ) : <EOL> raise HeaderValueError ( u'<STR_LIT>' % field ) <EOL> self . set_field_value ( obj , field , value ) <EOL> return obj . keys ( ) <EOL> @ classmethod <EOL> def set_field_value ( cls , obj , field , value ) : <EOL> if isinstance ( value , basestring ) : <EOL> value = value . strip ( ) <EOL> try : <EOL> field , subfield = field . split ( '<STR_LIT::>' ) <EOL> except Exception : <EOL> pass <EOL> else : <EOL> field = field . strip ( ) <EOL> if field not in obj : <EOL> obj [ field ] = { } <EOL> cls . set_field_value ( obj [ field ] , subfield , value ) <EOL> return <EOL> try : <EOL> field , _ = field . split ( ) <EOL> except Exception : <EOL> pass <EOL> else : <EOL> dud = { } <EOL> cls . set_field_value ( dud , field , value ) <EOL> ( field , value ) , = dud . items ( ) <EOL> if field not in obj : <EOL> obj [ field ] = [ ] <EOL> elif not isinstance ( obj [ field ] , list ) : <EOL> obj [ field ] = [ obj [ field ] ] <EOL> if value not in ( None , '<STR_LIT>' ) : <EOL> obj [ field ] . append ( value ) <EOL> return <EOL> try : <EOL> field , nothing = field . split ( '<STR_LIT:?>' ) <EOL> assert ( nothing . strip ( ) == '<STR_LIT>' ) <EOL> except Exception : <EOL> pass <EOL> else : <EOL> try : <EOL> value = { <EOL> '<STR_LIT:yes>' : True , <EOL> '<STR_LIT:true>' : True , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT:false>' : False , <EOL> '<STR_LIT>' : False , <EOL> None : False , <EOL> } [ value . lower ( ) if hasattr ( value , '<STR_LIT>' ) else value ] <EOL> except KeyError : <EOL> raise JSONReaderError ( <EOL> '<STR_LIT>' % ( <EOL> field , value ) <EOL> ) <EOL> field = field . strip ( ) <EOL> if field in obj : <EOL> raise JSONReaderError ( <EOL> '<STR_LIT>' % field <EOL> ) <EOL> obj [ field ] = value <EOL> class WorksheetNotFound ( Exception ) : <EOL> def __init__ ( self , title ) : <EOL> self . title = title <EOL> super ( WorksheetNotFound , self ) . __init__ ( ) <EOL> class WorksheetJSONReader ( IteratorJSONReader ) : <EOL> def __init__ ( self , worksheet , title = None ) : <EOL> width = <NUM_LIT:0> <EOL> self . title = title <EOL> self . worksheet = worksheet <EOL> try : <EOL> header_row = self . worksheet . iter_rows ( ) . next ( ) <EOL> except StopIteration : <EOL> header_row = [ ] <EOL> for cell in header_row : <EOL> if cell . value is None : <EOL> break <EOL> else : <EOL> width += <NUM_LIT:1> <EOL> self . worksheet . calculate_dimension ( force = True ) <EOL> def iterator ( ) : <EOL> def _convert_float ( value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( value , float ) and int ( value ) == value : <EOL> return int ( value ) <EOL> else : <EOL> return value or '<STR_LIT>' <EOL> for row in self . worksheet . iter_rows ( ) : <EOL> cell_values = [ <EOL> _convert_float ( cell . value ) <EOL> for cell in row [ : width ] <EOL> ] <EOL> if not any ( cell_values ) : <EOL> break <EOL> yield cell_values <EOL> super ( WorksheetJSONReader , self ) . __init__ ( iterator ( ) ) <EOL> class WorkbookJSONReader ( object ) : <EOL> def __init__ ( self , f ) : <EOL> if isinstance ( f , basestring ) : <EOL> filename = f <EOL> elif not isinstance ( f , file ) : <EOL> tmp = NamedTemporaryFile ( mode = '<STR_LIT:wb>' , suffix = '<STR_LIT>' , delete = False ) <EOL> filename = tmp . name <EOL> tmp . write ( f . read ( ) ) <EOL> tmp . close ( ) <EOL> else : <EOL> filename = f <EOL> self . wb = openpyxl . load_workbook ( filename , use_iterators = True ) <EOL> self . worksheets_by_title = { } <EOL> self . worksheets = [ ] <EOL> for worksheet in self . wb . worksheets : <EOL> ws = WorksheetJSONReader ( worksheet , title = worksheet . title ) <EOL> self . worksheets_by_title [ worksheet . title ] = ws <EOL> self . worksheets . append ( ws ) <EOL> def get_worksheet ( self , title = None , index = None ) : <EOL> if title is not None and index is not None : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> if title : <EOL> try : <EOL> return self . worksheets_by_title [ title ] <EOL> except KeyError : <EOL> raise WorksheetNotFound ( title = title ) <EOL> elif index : <EOL> try : <EOL> return self . worksheets [ index ] <EOL> except IndexError : <EOL> raise WorksheetNotFound ( title = index ) <EOL> else : <EOL> try : <EOL> return self . worksheets [ <NUM_LIT:0> ] <EOL> except IndexError : <EOL> raise WorksheetNotFound ( title = <NUM_LIT:0> ) <EOL> def work_book_headers_as_tuples ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> all_sheet_headers = [ ] <EOL>", "answer": "for sheet in self . worksheets :"}, {"prompt": "<s> from rb . promise import Promise <EOL> def test_resolved_promise ( ) : <EOL> p = Promise . resolved ( <NUM_LIT> ) <EOL> assert p . is_resolved <EOL> assert not p . is_pending <EOL> assert not p . is_rejected <EOL> assert p . value == <NUM_LIT> <EOL> def test_rejected_promise ( ) : <EOL> err = RuntimeError ( '<STR_LIT>' ) <EOL> p = Promise . rejected ( err ) <EOL> assert not p . is_resolved <EOL> assert not p . is_pending <EOL> assert p . is_rejected <EOL> assert p . reason == err <EOL> def test_success_callbacks ( ) : <EOL> results = [ ] <EOL> p = Promise ( ) <EOL> assert p . is_pending <EOL> p . done ( results . append ) <EOL> assert results == [ ] <EOL> p . resolve ( <NUM_LIT> ) <EOL> assert results == [ <NUM_LIT> ] <EOL> p = Promise . resolved ( <NUM_LIT> ) <EOL> p . done ( results . append ) <EOL> assert results == [ <NUM_LIT> , <NUM_LIT> ] <EOL> def test_failure_callbacks ( ) : <EOL> results = [ ] <EOL> p = Promise ( ) <EOL> assert p . is_pending <EOL> p . done ( on_failure = results . append ) <EOL> assert results == [ ] <EOL> p . reject ( <NUM_LIT> ) <EOL> assert results == [ <NUM_LIT> ] <EOL> p = Promise . rejected ( <NUM_LIT> ) <EOL> p . done ( on_failure = results . append ) <EOL> assert results == [ <NUM_LIT> , <NUM_LIT> ] <EOL> def test_promise_then ( ) : <EOL> p = Promise . resolved ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] ) <EOL> def on_success ( value ) : <EOL> return value + [ <NUM_LIT:4> ] <EOL> p2 = p . then ( success = on_success ) <EOL> assert p2 . value == [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ] <EOL> def test_promise_all ( ) : <EOL> p = Promise . all ( [ ] ) <EOL> assert p . is_resolved <EOL> assert p . value == [ ] <EOL> p = Promise . all ( { } ) <EOL> assert p . is_resolved <EOL> assert p . value == { } <EOL> p = Promise . all ( [ <EOL> Promise . resolved ( <NUM_LIT:1> ) , <EOL> Promise . resolved ( <NUM_LIT:2> ) , <EOL> Promise . resolved ( <NUM_LIT:3> ) , <EOL> ] ) <EOL> assert p . is_resolved <EOL> assert p . value == [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] <EOL> p = Promise . all ( { <EOL> '<STR_LIT>' : Promise . resolved ( <NUM_LIT:1> ) , <EOL> '<STR_LIT>' : Promise . resolved ( <NUM_LIT:2> ) , <EOL> '<STR_LIT>' : Promise . resolved ( <NUM_LIT:3> ) , <EOL> } ) <EOL> assert p . is_resolved <EOL> assert p . value == { '<STR_LIT>' : <NUM_LIT:1> , '<STR_LIT>' : <NUM_LIT:2> , '<STR_LIT>' : <NUM_LIT:3> } <EOL> p = Promise . all ( [ <EOL> Promise . resolved ( <NUM_LIT:1> ) , <EOL> Promise . rejected ( <NUM_LIT:2> ) , <EOL> Promise . resolved ( <NUM_LIT:3> ) , <EOL> ] ) <EOL> assert p . is_rejected <EOL> assert p . reason == <NUM_LIT:2> <EOL> def test_auto_coercion ( ) : <EOL> p = Promise . all ( [ <NUM_LIT:1> , <NUM_LIT:2> , Promise . resolved ( <NUM_LIT:3> ) ] ) <EOL> assert p . is_resolved <EOL>", "answer": "assert p . value == [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ]"}, {"prompt": "<s> from . . excel_comparsion_test import ExcelComparisonTest <EOL> from ... workbook import Workbook <EOL> class TestCompareXLSXFiles ( ExcelComparisonTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . maxDiff = None <EOL> filename = '<STR_LIT>' <EOL> test_dir = '<STR_LIT>' <EOL> self . got_filename = test_dir + '<STR_LIT>' + filename <EOL> self . exp_filename = test_dir + '<STR_LIT>' + filename <EOL>", "answer": "self . ignore_files = [ ]"}, {"prompt": "<s> from swgpy . object import * <EOL>", "answer": "def create ( kernel ) :"}, {"prompt": "<s> def ch ( filee ) : <EOL> shellcode = r\"<STR_LIT>\" <EOL> shellcode += filee <EOL> shellcode += r\"<STR_LIT>\" <EOL>", "answer": "return shellcode"}, {"prompt": "<s> from django . apps import AppConfig <EOL>", "answer": "class MturkConfig ( AppConfig ) :"}, {"prompt": "<s> import logging <EOL> import time <EOL> import itsdangerous <EOL> from flask import current_app , request , abort , g <EOL> from flask_debugtoolbar import module <EOL> from flask_debugtoolbar . panels import DebugPanel <EOL> from flask_debugtoolbar . utils import format_sql <EOL> from peewee import SqliteDatabase <EOL> peewee = logging . getLogger ( '<STR_LIT>' ) <EOL> def query_signer ( ) : <EOL> return itsdangerous . URLSafeSerializer ( current_app . config [ '<STR_LIT>' ] , salt = '<STR_LIT>' ) <EOL> def load_query ( data ) : <EOL> try : <EOL> return query_signer ( ) . loads ( request . args [ '<STR_LIT>' ] ) <EOL> except ( itsdangerous . BadSignature , TypeError ) : <EOL> abort ( <NUM_LIT> ) <EOL> def dump_query ( query , params ) : <EOL> try : <EOL> return query_signer ( ) . dumps ( ( query , params ) ) <EOL> except TypeError : <EOL> return None <EOL> class AmountHandler ( logging . Handler ) : <EOL> def __init__ ( self , * args ) : <EOL> super ( AmountHandler , self ) . __init__ ( * args ) <EOL> self . records = [ ] <EOL> def emit ( self , record ) : <EOL> self . records . append ( ( time . time ( ) - self . time , record ) ) <EOL> self . time = time . time ( ) <EOL> @ property <EOL> def amount ( self ) : <EOL> return len ( self . records ) <EOL> class PeeweeDebugPanel ( DebugPanel ) : <EOL> name = '<STR_LIT>' <EOL> has_content = True <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . handler = AmountHandler ( ) <EOL> peewee . setLevel ( '<STR_LIT>' ) <EOL> peewee . handlers = [ ] <EOL> peewee . addHandler ( self . handler ) <EOL> super ( PeeweeDebugPanel , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def has_content ( self ) : <EOL> return bool ( self . handler . amount ) <EOL> def url ( self ) : <EOL> return '<STR_LIT>' <EOL> def title ( self ) : <EOL> return '<STR_LIT>' <EOL> def nav_title ( self ) : <EOL> return '<STR_LIT>' % self . handler . amount <EOL> def process_request ( self , request ) : <EOL> self . handler . time = time . time ( ) <EOL> def content ( self ) : <EOL> data = [ ] <EOL> for duration , record in self . handler . records : <EOL> sql , params = record . msg <EOL> data . append ( { <EOL> '<STR_LIT>' : dump_query ( sql , params ) , <EOL> '<STR_LIT>' : sql , <EOL> '<STR_LIT>' : duration , <EOL> } ) <EOL> return self . render ( '<STR_LIT>' , { '<STR_LIT>' : data } ) <EOL> @ module . route ( '<STR_LIT>' , methods = [ '<STR_LIT:GET>' , '<STR_LIT:POST>' ] ) <EOL> @ module . route ( '<STR_LIT>' , methods = [ '<STR_LIT:GET>' , '<STR_LIT:POST>' ] , defaults = dict ( explain = True ) ) <EOL> def sql_select ( explain = False ) : <EOL> statement , params = load_query ( request . args [ '<STR_LIT>' ] ) <EOL> database = current_app . extensions . get ( '<STR_LIT>' ) . database . obj <EOL> if explain : <EOL> if isinstance ( database , SqliteDatabase ) : <EOL> statement = '<STR_LIT>' % statement <EOL> else : <EOL> statement = '<STR_LIT>' % statement <EOL> result = database . execute_sql ( statement , params ) <EOL> headers = [ ] <EOL> data = list ( result . fetchall ( ) ) <EOL> if data : <EOL> headers = [ '<STR_LIT>' for _ in range ( len ( data [ <NUM_LIT:0> ] ) ) ] <EOL> return g . debug_toolbar . render ( '<STR_LIT>' , { <EOL> '<STR_LIT:result>' : data , <EOL> '<STR_LIT>' : headers , <EOL> '<STR_LIT>' : format_sql ( statement , params ) , <EOL>", "answer": "'<STR_LIT>' : float ( request . args [ '<STR_LIT>' ] ) ,"}, {"prompt": "<s> from less import LessException <EOL> from less . settings import LESS_EXECUTABLE , LESS_ROOT , LESS_OUTPUT_DIR , LESS_OPTIONS <EOL> from django . conf import settings <EOL> import logging <EOL> import urlparse <EOL> import re <EOL> import os <EOL> import subprocess <EOL> logger = logging . getLogger ( \"<STR_LIT>\" ) <EOL> STATIC_URL = getattr ( settings , \"<STR_LIT>\" , getattr ( settings , \"<STR_LIT>\" ) ) <EOL> class URLConverter ( object ) : <EOL> URL_PATTERN = re . compile ( r'<STR_LIT>' ) <EOL> def __init__ ( self , content , source_path ) : <EOL> self . content = content <EOL> self . source_dir = os . path . dirname ( source_path ) <EOL> if not self . source_dir . endswith ( '<STR_LIT:/>' ) : <EOL> self . source_dir = self . source_dir + '<STR_LIT:/>' <EOL> def convert_url ( self , matchobj ) : <EOL> url = matchobj . group ( <NUM_LIT:1> ) <EOL> url = url . strip ( '<STR_LIT>' ) <EOL> if url . startswith ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:/>' , '<STR_LIT>' ) ) : <EOL> return \"<STR_LIT>\" % url <EOL> return \"<STR_LIT>\" % urlparse . urljoin ( self . source_dir , url ) <EOL> def convert ( self ) : <EOL> return self . URL_PATTERN . sub ( self . convert_url , self . content ) <EOL> def compile_less ( input , output , less_path ) : <EOL> less_root = os . path . join ( LESS_ROOT , LESS_OUTPUT_DIR ) <EOL> if not os . path . exists ( less_root ) : <EOL> os . makedirs ( less_root ) <EOL> args = [ LESS_EXECUTABLE ] + LESS_OPTIONS + [ input ] <EOL> popen_kwargs = dict ( <EOL> stdout = subprocess . PIPE , <EOL> stderr = subprocess . PIPE , <EOL> ) <EOL> if os . name == \"<STR_LIT>\" : <EOL> popen_kwargs [ \"<STR_LIT>\" ] = True <EOL> p = subprocess . Popen ( args , ** popen_kwargs ) <EOL> out , errors = p . communicate ( ) <EOL> if errors : <EOL> logger . error ( errors ) <EOL> raise LessException ( errors ) <EOL> output_directory = os . path . dirname ( output ) <EOL>", "answer": "if not os . path . exists ( output_directory ) :"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import cv2 <EOL> import numpy as np <EOL> import sys <EOL> print __doc__ <EOL> try : <EOL> fn = sys . argv [ <NUM_LIT:1> ] <EOL> except : <EOL> fn = \"<STR_LIT>\" <EOL> src = cv2 . imread ( fn , <NUM_LIT:1> ) <EOL> img = cv2 . cvtColor ( src , cv2 . COLOR_BGR2GRAY ) <EOL>", "answer": "img = cv2 . medianBlur ( img , <NUM_LIT:5> )"}, {"prompt": "<s> from . . excel_comparsion_test import ExcelComparisonTest <EOL> from ... workbook import Workbook <EOL> class TestCompareXLSXFiles ( ExcelComparisonTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . maxDiff = None <EOL> filename = '<STR_LIT>' <EOL> test_dir = '<STR_LIT>' <EOL> self . got_filename = test_dir + '<STR_LIT>' + filename <EOL> self . exp_filename = test_dir + '<STR_LIT>' + filename <EOL> self . ignore_files = [ ] <EOL> self . ignore_elements = { } <EOL> def test_create_file ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> workbook = Workbook ( self . got_filename ) <EOL> workbook . default_url_format = None <EOL> worksheet1 = workbook . add_worksheet ( ) <EOL> worksheet2 = workbook . add_worksheet ( ) <EOL> worksheet1 . write_url ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> worksheet1 . write_url ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> worksheet1 . write_url ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> worksheet1 . write_url ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> worksheet1 . write_url ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> worksheet2 . write_url ( '<STR_LIT>' , '<STR_LIT>' ) <EOL>", "answer": "worksheet2 . write_url ( '<STR_LIT>' , '<STR_LIT>' )"}, {"prompt": "<s> from eemeter . weather import GSODWeatherSource <EOL> from eemeter . weather import TMY3WeatherSource <EOL> class Project ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , location , consumption = [ ] , baseline_period = None , <EOL> reporting_period = None , other_periods = [ ] , weather_source = None , <EOL> weather_normal_source = None ) : <EOL> self . location = location <EOL> self . baseline_period = baseline_period <EOL> self . reporting_period = reporting_period <EOL> self . other_periods = other_periods <EOL> if not type ( consumption ) == list : <EOL> self . consumption = [ consumption ] <EOL> else : <EOL>", "answer": "self . consumption = consumption"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import <EOL> import weakref <EOL> import operator <EOL> from . compat import threading , itertools_filterfalse <EOL> from . import py2k <EOL> import types <EOL> EMPTY_SET = frozenset ( ) <EOL> class KeyedTuple ( tuple ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __new__ ( cls , vals , labels = None ) : <EOL> t = tuple . __new__ ( cls , vals ) <EOL> t . _labels = [ ] <EOL> if labels : <EOL> t . __dict__ . update ( zip ( labels , vals ) ) <EOL> t . _labels = labels <EOL> return t <EOL> def keys ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return [ l for l in self . _labels if l is not None ] <EOL> @ property <EOL> def _fields ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return tuple ( self . keys ( ) ) <EOL> def _asdict ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return dict ( ( key , self . __dict__ [ key ] ) for key in self . keys ( ) ) <EOL> class ImmutableContainer ( object ) : <EOL> def _immutable ( self , * arg , ** kw ) : <EOL> raise TypeError ( \"<STR_LIT>\" % self . __class__ . __name__ ) <EOL> __delitem__ = __setitem__ = __setattr__ = _immutable <EOL> class immutabledict ( ImmutableContainer , dict ) : <EOL> clear = pop = popitem = setdefault = update = ImmutableContainer . _immutable <EOL> def __new__ ( cls , * args ) : <EOL> new = dict . __new__ ( cls ) <EOL> dict . __init__ ( new , * args ) <EOL> return new <EOL> def __init__ ( self , * args ) : <EOL> pass <EOL> def __reduce__ ( self ) : <EOL> return immutabledict , ( dict ( self ) , ) <EOL> def union ( self , d ) : <EOL> if not self : <EOL> return immutabledict ( d ) <EOL> else : <EOL> d2 = immutabledict ( self ) <EOL> dict . update ( d2 , d ) <EOL> return d2 <EOL> def __repr__ ( self ) : <EOL> return \"<STR_LIT>\" % dict . __repr__ ( self ) <EOL> class Properties ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , data ) : <EOL> self . __dict__ [ '<STR_LIT>' ] = data <EOL> def __len__ ( self ) : <EOL> return len ( self . _data ) <EOL> def __iter__ ( self ) : <EOL> return iter ( list ( self . _data . values ( ) ) ) <EOL> def __add__ ( self , other ) : <EOL> return list ( self ) + list ( other ) <EOL> def __setitem__ ( self , key , object ) : <EOL> self . _data [ key ] = object <EOL> def __getitem__ ( self , key ) : <EOL> return self . _data [ key ] <EOL> def __delitem__ ( self , key ) : <EOL> del self . _data [ key ] <EOL> def __setattr__ ( self , key , object ) : <EOL> self . _data [ key ] = object <EOL> def __getstate__ ( self ) : <EOL> return { '<STR_LIT>' : self . __dict__ [ '<STR_LIT>' ] } <EOL> def __setstate__ ( self , state ) : <EOL> self . __dict__ [ '<STR_LIT>' ] = state [ '<STR_LIT>' ] <EOL> def __getattr__ ( self , key ) : <EOL> try : <EOL> return self . _data [ key ] <EOL> except KeyError : <EOL> raise AttributeError ( key ) <EOL> def __contains__ ( self , key ) : <EOL> return key in self . _data <EOL> def as_immutable ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return ImmutableProperties ( self . _data ) <EOL> def update ( self , value ) : <EOL> self . _data . update ( value ) <EOL> def get ( self , key , default = None ) : <EOL> if key in self : <EOL> return self [ key ] <EOL> else : <EOL> return default <EOL> def keys ( self ) : <EOL> return list ( self . _data ) <EOL> def values ( self ) : <EOL> return list ( self . _data . values ( ) ) <EOL> def items ( self ) : <EOL> return list ( self . _data . items ( ) ) <EOL> def has_key ( self , key ) : <EOL> return key in self . _data <EOL> def clear ( self ) : <EOL> self . _data . clear ( ) <EOL> class OrderedProperties ( Properties ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self ) : <EOL> Properties . __init__ ( self , OrderedDict ( ) ) <EOL> class ImmutableProperties ( ImmutableContainer , Properties ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> class OrderedDict ( dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , ____sequence = None , ** kwargs ) : <EOL> self . _list = [ ] <EOL> if ____sequence is None : <EOL> if kwargs : <EOL> self . update ( ** kwargs ) <EOL> else : <EOL> self . update ( ____sequence , ** kwargs ) <EOL> def clear ( self ) : <EOL> self . _list = [ ] <EOL> dict . clear ( self ) <EOL> def copy ( self ) : <EOL> return self . __copy__ ( ) <EOL> def __copy__ ( self ) : <EOL> return OrderedDict ( self ) <EOL> def sort ( self , * arg , ** kw ) : <EOL> self . _list . sort ( * arg , ** kw ) <EOL> def update ( self , ____sequence = None , ** kwargs ) : <EOL> if ____sequence is not None : <EOL> if hasattr ( ____sequence , '<STR_LIT>' ) : <EOL> for key in ____sequence . keys ( ) : <EOL> self . __setitem__ ( key , ____sequence [ key ] ) <EOL> else : <EOL> for key , value in ____sequence : <EOL> self [ key ] = value <EOL> if kwargs : <EOL> self . update ( kwargs ) <EOL> def setdefault ( self , key , value ) : <EOL> if key not in self : <EOL> self . __setitem__ ( key , value ) <EOL> return value <EOL> else : <EOL> return self . __getitem__ ( key ) <EOL> def __iter__ ( self ) : <EOL> return iter ( self . _list ) <EOL> def keys ( self ) : <EOL> return list ( self ) <EOL> def values ( self ) : <EOL> return [ self [ key ] for key in self . _list ] <EOL> def items ( self ) : <EOL> return [ ( key , self [ key ] ) for key in self . _list ] <EOL> if py2k : <EOL> def itervalues ( self ) : <EOL> return iter ( self . values ( ) ) <EOL> def iterkeys ( self ) : <EOL> return iter ( self ) <EOL> def iteritems ( self ) : <EOL> return iter ( self . items ( ) ) <EOL> def __setitem__ ( self , key , object ) : <EOL> if key not in self : <EOL> try : <EOL> self . _list . append ( key ) <EOL> except AttributeError : <EOL> self . _list = [ key ] <EOL> dict . __setitem__ ( self , key , object ) <EOL> def __delitem__ ( self , key ) : <EOL> dict . __delitem__ ( self , key ) <EOL> self . _list . remove ( key ) <EOL> def pop ( self , key , * default ) : <EOL> present = key in self <EOL> value = dict . pop ( self , key , * default ) <EOL> if present : <EOL> self . _list . remove ( key ) <EOL> return value <EOL> def popitem ( self ) : <EOL> item = dict . popitem ( self ) <EOL> self . _list . remove ( item [ <NUM_LIT:0> ] ) <EOL> return item <EOL> class OrderedSet ( set ) : <EOL> def __init__ ( self , d = None ) : <EOL> set . __init__ ( self ) <EOL> self . _list = [ ] <EOL> if d is not None : <EOL> self . update ( d ) <EOL> def add ( self , element ) : <EOL> if element not in self : <EOL> self . _list . append ( element ) <EOL> set . add ( self , element ) <EOL> def remove ( self , element ) : <EOL> set . remove ( self , element ) <EOL> self . _list . remove ( element ) <EOL> def insert ( self , pos , element ) : <EOL> if element not in self : <EOL> self . _list . insert ( pos , element ) <EOL> set . add ( self , element ) <EOL> def discard ( self , element ) : <EOL> if element in self : <EOL> self . _list . remove ( element ) <EOL> set . remove ( self , element ) <EOL> def clear ( self ) : <EOL> set . clear ( self ) <EOL> self . _list = [ ] <EOL> def __getitem__ ( self , key ) : <EOL> return self . _list [ key ] <EOL> def __iter__ ( self ) : <EOL> return iter ( self . _list ) <EOL> def __add__ ( self , other ) : <EOL> return self . union ( other ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ , self . _list ) <EOL> __str__ = __repr__ <EOL> def update ( self , iterable ) : <EOL> for e in iterable : <EOL> if e not in self : <EOL> self . _list . append ( e ) <EOL> set . add ( self , e ) <EOL> return self <EOL> __ior__ = update <EOL> def union ( self , other ) : <EOL> result = self . __class__ ( self ) <EOL> result . update ( other ) <EOL> return result <EOL> __or__ = union <EOL> def intersection ( self , other ) : <EOL> other = set ( other ) <EOL> return self . __class__ ( a for a in self if a in other ) <EOL> __and__ = intersection <EOL> def symmetric_difference ( self , other ) : <EOL> other = set ( other ) <EOL> result = self . __class__ ( a for a in self if a not in other ) <EOL> result . update ( a for a in other if a not in self ) <EOL> return result <EOL> __xor__ = symmetric_difference <EOL> def difference ( self , other ) : <EOL> other = set ( other ) <EOL> return self . __class__ ( a for a in self if a not in other ) <EOL> __sub__ = difference <EOL> def intersection_update ( self , other ) : <EOL> other = set ( other ) <EOL> set . intersection_update ( self , other ) <EOL> self . _list = [ a for a in self . _list if a in other ] <EOL>", "answer": "return self"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import nmrglue . fileio . pipe as pipe <EOL> import nmrglue . process . pipe_proc as p <EOL> d , a = pipe . read ( \"<STR_LIT>\" ) <EOL> d , a = p . em ( d , a , lb = <NUM_LIT> , c = <NUM_LIT:0.5> , start = <NUM_LIT:100> , size = <NUM_LIT> , one = True ) <EOL> pipe . write ( \"<STR_LIT>\" , d , a , overwrite = True ) <EOL>", "answer": "d , a = pipe . read ( \"<STR_LIT>\" )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from p4p2p . dht import constants <EOL> import unittest <EOL> class TestConstants ( unittest . TestCase ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def test_ALPHA ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . assertIsInstance ( constants . ALPHA , int , <EOL> \"<STR_LIT>\" ) <EOL> def test_K ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . assertIsInstance ( constants . K , int , <EOL> \"<STR_LIT>\" ) <EOL> self . assertEqual ( <NUM_LIT:0> , constants . K % <NUM_LIT:2> ) <EOL> def test_LOOKUP_TIMEOUT ( self ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Creature ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import cmd <EOL> import sys <EOL> import os <EOL> import bot . client . ctrl_client as ctrl_client_mod <EOL> import bot . client . sub_client as sub_client_mod <EOL> class CLI ( cmd . Cmd ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> prompt = \"<STR_LIT>\" <EOL> def __init__ ( self , ctrl_addr , sub_addr ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cmd . Cmd . __init__ ( self ) <EOL> try : <EOL> self . ctrl_client = ctrl_client_mod . CtrlClient ( ctrl_addr ) <EOL> except Exception , e : <EOL> print \"<STR_LIT>\" . format ( ctrl_addr , e ) <EOL> sys . exit ( - <NUM_LIT:1> ) <EOL> try : <EOL> self . sub_client = sub_client_mod . SubClient ( sub_addr ) <EOL> except Exception , e : <EOL> print \"<STR_LIT>\" . format ( sub_addr , e ) <EOL> sys . exit ( - <NUM_LIT:1> ) <EOL> def default ( self , raw_args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> obj_name , _ , rest = raw_args . partition ( \"<STR_LIT:U+0020>\" ) <EOL> if obj_name in self . ctrl_client . objects : <EOL> method_name , _ , params = rest . partition ( \"<STR_LIT:U+0020>\" ) <EOL> if method_name in self . ctrl_client . objects [ obj_name ] : <EOL> try : <EOL> param_dict = { } <EOL> for param in params . split ( ) : <EOL> key , value = param . split ( \"<STR_LIT::>\" ) <EOL> try : <EOL> if \"<STR_LIT:.>\" in value : <EOL> value = float ( value ) <EOL> else : <EOL> value = int ( value ) <EOL> except ValueError : <EOL> if value == \"<STR_LIT:True>\" : <EOL> value = True <EOL> elif value == \"<STR_LIT:False>\" : <EOL> value = False <EOL> elif value . startswith ( \"<STR_LIT:'>\" ) and value . endswith ( \"<STR_LIT:'>\" ) : <EOL> value = value [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> param_dict [ key ] = value <EOL> except IndexError : <EOL> print \"<STR_LIT>\" <EOL> return <EOL> except ValueError : <EOL> print \"<STR_LIT>\" <EOL> return <EOL> result = self . ctrl_client . call ( <EOL> obj_name , method_name , param_dict ) <EOL> print \"<STR_LIT>\" , result <EOL> else : <EOL> print \"<STR_LIT>\" , method_name <EOL> else : <EOL> print \"<STR_LIT>\" , obj_name <EOL> def completenames ( self , text , * ignored ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> cmd_match_names = cmd . Cmd . completenames ( self , text , * ignored ) <EOL> obj_names = self . ctrl_client . objects . keys ( ) <EOL> api_match_names = [ x for x in obj_names if x . startswith ( text ) ] <EOL> return cmd_match_names + api_match_names <EOL> def completedefault ( self , text , line , begidx , endidx ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> obj , _ , rest = line . partition ( \"<STR_LIT:U+0020>\" ) <EOL> if obj in self . ctrl_client . objects : <EOL> method , _ , params = rest . strip ( ) . partition ( \"<STR_LIT:U+0020>\" ) <EOL> if method == text : <EOL> method_names = self . ctrl_client . objects [ obj ] <EOL> match_names = [ x for x in method_names if x . startswith ( text ) ] <EOL> return match_names <EOL> def do_list ( self , raw_args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print <EOL> print \"<STR_LIT>\" <EOL> print <EOL> for obj_name , methods in sorted ( self . ctrl_client . objects . items ( ) ) : <EOL> print \"<STR_LIT>\" . format ( obj_name ) <EOL> for method in methods : <EOL> print \"<STR_LIT>\" . format ( method ) <EOL> print <EOL> def help_list ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print \"<STR_LIT:list>\" <EOL> print \"<STR_LIT>\" <EOL> def do_ping ( self , raw_args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> reply_time = self . ctrl_client . ping ( ) <EOL> print \"<STR_LIT>\" . format ( reply_time ) <EOL> def help_ping ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print \"<STR_LIT>\" <EOL> print \"<STR_LIT>\" <EOL> def do_sub_add ( self , raw_args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> topic = raw_args . split ( ) [ <NUM_LIT:0> ] <EOL> except ( ValueError , IndexError ) : <EOL> print \"<STR_LIT>\" <EOL> return <EOL> self . sub_client . add_topic ( topic ) <EOL> def help_sub_add ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print \"<STR_LIT>\" <EOL> print \"<STR_LIT>\" <EOL> def do_sub_del ( self , raw_args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> topic = raw_args . split ( ) [ <NUM_LIT:0> ] <EOL> except ( ValueError , IndexError ) : <EOL> print \"<STR_LIT>\" <EOL> return <EOL> self . sub_client . del_topic ( topic ) <EOL> def help_sub_del ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print \"<STR_LIT>\" <EOL> print \"<STR_LIT>\" <EOL> def do_sub ( self , raw_args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . sub_client . print_msgs ( ) <EOL> def help_sub ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print \"<STR_LIT>\" <EOL> print \"<STR_LIT>\" <EOL> def do_stop ( self , raw_args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . ctrl_client . stop_full ( ) <EOL> def help_stop ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print \"<STR_LIT>\" <EOL> print \"<STR_LIT>\" <EOL> def do_kill ( self , raw_args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . ctrl_client . exit_server ( ) <EOL> def help_kill ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> print \"<STR_LIT>\" <EOL>", "answer": "print \"<STR_LIT>\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import glob <EOL> import imp <EOL> import os . path <EOL> class Plugin ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> capability = [ ] <EOL> @ classmethod <EOL> def is_capable ( cls , requested_capability ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for c in requested_capability : <EOL> if c not in cls . capability : <EOL> return False <EOL> return True <EOL> def get_plugin ( cls , requested_capability = None ) : <EOL>", "answer": "if not requested_capability :"}, {"prompt": "<s> import functools <EOL> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> class PresetsPlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , plug , parenting = None ) : <EOL> self . __menuButton = GafferUI . MenuButton ( \"<STR_LIT>\" , menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __menuDefinition ) ) ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , self . __menuButton , plug , parenting = parenting ) <EOL> self . __plugMetadataChangedConnection = Gaffer . Metadata . plugValueChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __plugMetadataChanged ) ) <EOL> self . _addPopupMenu ( self . __menuButton ) <EOL> self . _updateFromPlug ( ) <EOL>", "answer": "def _updateFromPlug ( self ) :"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import requests <EOL> import json <EOL> import datetime <EOL> import dateutil . parser <EOL> import urllib <EOL> import os <EOL> import pytz <EOL> from Empire . cloudservices . github import GithubOrg , GithubRepo , GithubCommit <EOL> from repos . base import RepoSource , RepoCommit , RepoPatch <EOL> from repos . diffparser import DiffParser <EOL> import logging <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> owner = '<STR_LIT>' <EOL> repo = '<STR_LIT>' <EOL> class GithubSource ( RepoSource ) : <EOL> def __init__ ( self , creds = None , host = '<STR_LIT>' , owner = '<STR_LIT>' , repo = '<STR_LIT>' ) : <EOL> self . _last_date = None <EOL> self . _last_identifier = None <EOL> self . _no_more_requests_until = None <EOL> github_org = GithubOrg ( host , owner , creds ) <EOL> self . _github_repo = GithubRepo ( github_org , repo ) <EOL> def processSinceIdentifier ( self , identifier , commit_started_callback , patch_callback , commit_finished_callback , path = None ) : <EOL> since_datetime = datetime . datetime . utcnow ( ) <EOL>", "answer": "since_datetime = since_datetime . replace ( tzinfo = pytz . UTC , hour = <NUM_LIT:0> , minute = <NUM_LIT:0> , second = <NUM_LIT:0> )"}, {"prompt": "<s> class HttpException ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def __init__ ( self , msg , res ) :"}, {"prompt": "<s> import pytest <EOL> from comport . content . models import ChartBlock <EOL> from comport . department . models import Extractor <EOL> from . factories import DepartmentFactory <EOL> import uuid <EOL> @ pytest . mark . usefixtures ( '<STR_LIT>' ) <EOL> class TestExtractors : <EOL> def test_extractors_from_department_and_password ( self ) : <EOL> department = DepartmentFactory ( ) <EOL> department . save ( ) <EOL> password = str ( uuid . uuid4 ( ) ) <EOL> extractor , envs = Extractor . from_department_and_password ( department = department , password = password ) <EOL> assert department == extractor . departments [ <NUM_LIT:0> ] <EOL> assert extractor . check_password ( password ) is True <EOL> assert password in envs <EOL> def test_get_extractor_from_department ( self ) : <EOL> department = DepartmentFactory ( ) <EOL> department . save ( ) <EOL> assert ( \"<STR_LIT:U+0020>\" in department . name ) is True <EOL> password = str ( uuid . uuid4 ( ) ) <EOL> extractor , envs = Extractor . from_department_and_password ( department = department , password = password ) <EOL> extractor . save ( ) <EOL> assert department . get_extractor ( ) == extractor <EOL> assert ( \"<STR_LIT:U+0020>\" in extractor . username ) is False <EOL> def test_regen_extractor_envs ( self ) : <EOL> department = DepartmentFactory ( ) <EOL> department . save ( ) <EOL> password = str ( uuid . uuid4 ( ) ) <EOL> extractor , envs = Extractor . from_department_and_password ( department = department , password = password ) <EOL> extractor . save ( ) <EOL> new_password = str ( uuid . uuid4 ( ) ) <EOL> extractor . set_password ( new_password ) <EOL> assert extractor . check_password ( new_password ) is True <EOL> assert new_password in extractor . generate_envs ( new_password ) <EOL> def test_get_extractor_from_department_without_extractor ( self ) : <EOL> department = DepartmentFactory ( ) <EOL> department . save ( ) <EOL> assert department . get_extractor ( ) == None <EOL> def test_get_complaint_blocks ( self ) : <EOL> '''<STR_LIT>''' <EOL> department = DepartmentFactory ( ) <EOL> department . save ( ) <EOL> complaint_intro = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_bm = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_bya = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_byat = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_bdis = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_bpre = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_od = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_bde = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> complaint_bof = ChartBlock ( title = \"<STR_LIT>\" , dataset = \"<STR_LIT>\" , slug = \"<STR_LIT>\" ) <EOL> department . chart_blocks . append ( complaint_intro ) <EOL> department . chart_blocks . append ( complaint_bm ) <EOL> department . chart_blocks . append ( complaint_bya ) <EOL> department . chart_blocks . append ( complaint_byat ) <EOL> department . chart_blocks . append ( complaint_bdis ) <EOL> department . chart_blocks . append ( complaint_bpre ) <EOL> department . chart_blocks . append ( complaint_od ) <EOL> department . chart_blocks . append ( complaint_bde ) <EOL> department . chart_blocks . append ( complaint_bof ) <EOL> department . save ( ) <EOL> complaint_blocks = department . get_complaint_blocks ( ) <EOL> assert complaint_blocks [ '<STR_LIT>' ] == complaint_intro <EOL> assert complaint_blocks [ '<STR_LIT>' ] == complaint_bm <EOL> assert complaint_blocks [ '<STR_LIT>' ] [ <NUM_LIT:0> ] == complaint_bya <EOL> assert complaint_blocks [ '<STR_LIT>' ] [ <NUM_LIT:1> ] == complaint_byat <EOL> assert complaint_blocks [ '<STR_LIT>' ] [ <NUM_LIT:2> ] == complaint_bdis <EOL> assert complaint_blocks [ '<STR_LIT>' ] [ <NUM_LIT:3> ] == complaint_bpre <EOL> assert complaint_blocks [ '<STR_LIT>' ] [ <NUM_LIT:4> ] == complaint_od <EOL> assert complaint_blocks [ '<STR_LIT>' ] [ <NUM_LIT:5> ] == complaint_bde <EOL> assert complaint_blocks [ '<STR_LIT>' ] [ <NUM_LIT:6> ] == complaint_bof <EOL> def test_get_uof_blocks ( self ) : <EOL> '''<STR_LIT>''' <EOL> department = DepartmentFactory ( ) <EOL>", "answer": "department . save ( )"}, {"prompt": "<s> from bokeh . charts import Scatter , output_file , show <EOL> from bokeh . sampledata . autompg import autompg as df <EOL> p = Scatter ( df , x = '<STR_LIT>' , y = '<STR_LIT>' , color = '<STR_LIT>' , <EOL> title = \"<STR_LIT>\" , legend = \"<STR_LIT>\" , <EOL> xlabel = \"<STR_LIT>\" , ylabel = \"<STR_LIT>\" ) <EOL> output_file ( \"<STR_LIT>\" ) <EOL>", "answer": "show ( p ) "}, {"prompt": "<s> from setuptools import setup <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> packages = [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> url = '<STR_LIT>' , <EOL> license = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL>", "answer": "long_description = open ( '<STR_LIT>' ) . read ( ) ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from passlib . context import CryptContext <EOL> from flask import Blueprint , current_app , url_for <EOL> from flask_login import LoginManager , UserMixin as LoginUserMixin , make_secure_token <EOL> from flask_user . db_adapters import DBAdapter <EOL> from . db_adapters import SQLAlchemyAdapter <EOL> from . import emails <EOL> from . import forms <EOL> from . import passwords <EOL> from . import settings <EOL> from . import tokens <EOL> from . import translations <EOL> from . import views <EOL> from . import signals <EOL> from . translations import get_translations <EOL> from flask_login import current_user <EOL> from . decorators import * <EOL> from . signals import * <EOL> __version__ = '<STR_LIT>' <EOL> def _call_or_get ( function_or_property ) : <EOL> return function_or_property ( ) if callable ( function_or_property ) else function_or_property <EOL> def _flask_user_context_processor ( ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return dict ( <EOL> user_manager = current_app . user_manager , <EOL> call_or_get = _call_or_get ) <EOL> class UserManager ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def __init__ ( self , db_adapter = None , app = None , ** kwargs ) :"}, {"prompt": "<s> from __future__ import unicode_literals <EOL> import imp <EOL> import importlib <EOL> import inspect <EOL> from django . conf import settings <EOL> def get_module ( app , modname ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> app_path = importlib . import_module ( app ) . __path__ <EOL> except AttributeError : <EOL>", "answer": "return"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = <NUM_LIT:9> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> __revision__ = \"<STR_LIT>\" <EOL> from Crypto . PublicKey import pubkey <EOL> from Crypto . Util import number <EOL> def generate_py ( bits , randfunc , progress_func = None , e = <NUM_LIT> ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> obj = RSAobj ( ) <EOL> obj . e = long ( e ) <EOL> if progress_func : <EOL>", "answer": "progress_func ( '<STR_LIT>' )"}, {"prompt": "<s> import re <EOL> import logging <EOL> from functools import wraps <EOL> from inspect import getargspec <EOL> from flask . wrappers import Response <EOL> from flask import current_app , request , jsonify <EOL> from flask_jsonrpc . site import jsonrpc_site <EOL> from flask_jsonrpc . _compat import ( b , u , text_type , string_types , <EOL> OrderedDict , NativeStringIO ) <EOL> from flask_jsonrpc . types import ( Object , Number , Boolean , String , Array , <EOL> Nil , Any , Type ) <EOL> from flask_jsonrpc . helpers import ( make_response , jsonify_status_code , <EOL> extract_raw_data_request , authenticate ) <EOL> from flask_jsonrpc . exceptions import ( Error , ParseError , InvalidRequestError , <EOL> MethodNotFoundError , InvalidParamsError , <EOL> ServerError , RequestPostError , <EOL> InvalidCredentialsError , OtherError ) <EOL> default_site = jsonrpc_site <EOL> KWARG_RE = re . compile ( <EOL> r'<STR_LIT>' ) <EOL> SIG_RE = re . compile ( <EOL> r'<STR_LIT>' <EOL> r'<STR_LIT>' ) <EOL> class JSONRPCTypeCheckingUnavailable ( Exception ) : <EOL> pass <EOL> def _type_checking_available ( sig = '<STR_LIT>' , validate = False ) : <EOL> if not hasattr ( type , '<STR_LIT>' ) and validate : <EOL> raise JSONRPCTypeCheckingUnavailable ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' . format ( sig ) ) <EOL> def _validate_arg ( value , expected ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if type ( value ) == expected : <EOL> return True <EOL> return False <EOL> def _eval_arg_type ( arg_type , T = Any , arg = None , sig = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> T = eval ( arg_type ) <EOL> except Exception as e : <EOL> raise ValueError ( '<STR_LIT>' . format ( arg_type , arg , sig , text_type ( e ) ) ) <EOL> else : <EOL> if type ( T ) not in ( type , Type ) : <EOL> raise TypeError ( '<STR_LIT>' . format ( repr ( T ) , arg , sig ) ) <EOL> return T <EOL> def _parse_sig ( sig , arg_names , validate = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> d = SIG_RE . match ( sig ) <EOL> if not d : <EOL> raise ValueError ( '<STR_LIT>' . format ( sig ) ) <EOL> d = d . groupdict ( ) <EOL> ret = [ ( n , Any ) for n in arg_names ] <EOL> if text_type ( '<STR_LIT>' ) in d and type ( d [ '<STR_LIT>' ] ) in string_types and d [ '<STR_LIT>' ] . strip ( ) : <EOL> for i , arg in enumerate ( d [ '<STR_LIT>' ] . strip ( ) . split ( '<STR_LIT:U+002C>' ) ) : <EOL> _type_checking_available ( sig , validate ) <EOL> if text_type ( '<STR_LIT:=>' ) in arg : <EOL> if not type ( ret ) is OrderedDict : <EOL> ret = OrderedDict ( ret ) <EOL> dk = KWARG_RE . match ( arg ) <EOL> if not dk : <EOL> raise ValueError ( '<STR_LIT>' . format ( arg , sig ) ) <EOL> dk = dk . groupdict ( ) <EOL> if not sum ( [ ( k in dk and type ( dk [ k ] ) in string_types and bool ( dk [ k ] . strip ( ) ) ) <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> raise ValueError ( '<STR_LIT>' . format ( arg , sig ) ) <EOL> ret [ dk [ '<STR_LIT>' ] ] = _eval_arg_type ( dk [ '<STR_LIT>' ] , None , arg , sig ) <EOL> else : <EOL> if type ( ret ) is OrderedDict : <EOL> raise ValueError ( '<STR_LIT>' <EOL> '<STR_LIT>' . format ( sig ) ) <EOL> if len ( ret ) < i + <NUM_LIT:1> : <EOL> ret . append ( ( text_type ( i ) , _eval_arg_type ( arg , None , arg , sig ) ) ) <EOL> else : <EOL>", "answer": "ret [ i ] = ( ret [ i ] [ <NUM_LIT:0> ] , _eval_arg_type ( arg , None , arg , sig ) )"}, {"prompt": "<s> from Crypto . Cipher import AES <EOL> from django . conf import settings <EOL> from django . http import HttpResponse <EOL> from django . core . urlresolvers import reverse <EOL> from django . shortcuts import render <EOL> from . utils import get_client_key , get_userscript_code , get_decode_key <EOL> from . forms import DecodeForm <EOL> class TestException ( Exception ) : <EOL> pass <EOL> def userscript ( request ) : <EOL> response = HttpResponse ( <EOL> get_userscript_code ( request ) , <EOL> mimetype = '<STR_LIT>' <EOL> ) <EOL> response [ '<STR_LIT>' ] = '<STR_LIT>' % get_client_key ( ) <EOL> return response <EOL>", "answer": "def test ( _request ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import uuid <EOL> from googleads import dfp <EOL> HIERARCHY_LEVEL_ONE_KEY_ID = '<STR_LIT>' <EOL> HIERARCHY_LEVEL_TWO_KEY_ID = '<STR_LIT>' <EOL> def main ( client , hierarchy_level_one_key_id , hierarchy_level_two_key_id ) : <EOL> content_metadata_key_hierarchy_service = client . GetService ( <EOL> '<STR_LIT>' , version = '<STR_LIT>' ) <EOL> hierarchy_level_1 = { <EOL> '<STR_LIT>' : hierarchy_level_one_key_id , <EOL>", "answer": "'<STR_LIT>' : '<STR_LIT:1>'"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from xml . etree import ElementTree <EOL> import subprocess <EOL> import os <EOL> import glob <EOL> import re <EOL> import time <EOL> import libvirt <EOL> from ovs . extensions . generic . sshclient import SSHClient <EOL> from ovs . extensions . generic . system import System <EOL> from ovs . log . logHandler import LogHandler <EOL> logger = LogHandler . get ( '<STR_LIT>' , name = '<STR_LIT>' ) <EOL> ROOT_PATH = '<STR_LIT>' <EOL> RUN_PATH = '<STR_LIT>' <EOL> def _recurse ( treeitem ) : <EOL> result = { } <EOL> for key , item in treeitem . items ( ) : <EOL> result [ key ] = item <EOL> for child in treeitem . getchildren ( ) : <EOL> result [ child . tag ] = _recurse ( child ) <EOL> for key , item in child . items ( ) : <EOL> result [ child . tag ] [ key ] = item <EOL> result [ child . tag ] [ '<STR_LIT>' ] = child . text <EOL> return result <EOL> def authenticated ( function ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def new_function ( self , * args , ** kwargs ) : <EOL> self . __doc__ = function . __doc__ <EOL> try : <EOL> if self . _conn is None : <EOL> self . _connect ( ) <EOL> return function ( self , * args , ** kwargs ) <EOL> finally : <EOL> try : <EOL> self . _disconnect ( ) <EOL> except : <EOL> pass <EOL> return new_function <EOL> class Sdk ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , host = '<STR_LIT:127.0.0.1>' , login = '<STR_LIT:root>' ) : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> self . states = { libvirt . VIR_DOMAIN_NOSTATE : '<STR_LIT>' , <EOL> libvirt . VIR_DOMAIN_RUNNING : '<STR_LIT>' , <EOL> libvirt . VIR_DOMAIN_BLOCKED : '<STR_LIT>' , <EOL> libvirt . VIR_DOMAIN_PAUSED : '<STR_LIT>' , <EOL> libvirt . VIR_DOMAIN_SHUTDOWN : '<STR_LIT>' , <EOL> libvirt . VIR_DOMAIN_SHUTOFF : '<STR_LIT>' , <EOL> libvirt . VIR_DOMAIN_CRASHED : '<STR_LIT>' } <EOL> self . libvirt = libvirt <EOL> self . host = host <EOL> self . login = login <EOL> self . _conn = None <EOL> self . ssh_client = SSHClient ( self . host , username = '<STR_LIT:root>' ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def _connect ( self , attempt = <NUM_LIT:0> ) : <EOL> if self . _conn : <EOL> self . _disconnect ( ) <EOL> logger . debug ( '<STR_LIT>' , self . host , self . login , os . getgid ( ) , os . getuid ( ) ) <EOL> try : <EOL> if self . host . lower ( ) in [ '<STR_LIT:localhost>' , '<STR_LIT:127.0.0.1>' ] : <EOL> self . host = '<STR_LIT:127.0.0.1>' <EOL> self . _conn = self . libvirt . open ( '<STR_LIT>' ) <EOL> else : <EOL> self . _conn = self . libvirt . open ( '<STR_LIT>' . format ( self . login , self . host ) ) <EOL> except self . libvirt . libvirtError as le : <EOL> logger . error ( '<STR_LIT>' , str ( le ) , le . get_error_code ( ) ) <EOL> if attempt < <NUM_LIT:5> : <EOL> time . sleep ( <NUM_LIT:1> ) <EOL> self . _connect ( attempt + <NUM_LIT:1> ) <EOL> else : <EOL> raise <EOL> return True <EOL> def _disconnect ( self ) : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if self . _conn : <EOL> try : <EOL> self . _conn . close ( ) <EOL> except self . libvirt . libvirtError as le : <EOL> logger . error ( '<STR_LIT>' , str ( le ) , le . get_error_code ( ) ) <EOL> self . _conn = None <EOL> return True <EOL> @ authenticated <EOL> def test_connection ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _ = self <EOL> return True <EOL> @ staticmethod <EOL> def _get_disks ( vm_object ) : <EOL> tree = ElementTree . fromstring ( vm_object . XMLDesc ( <NUM_LIT:0> ) ) <EOL> return [ _recurse ( item ) for item in tree . findall ( '<STR_LIT>' ) ] <EOL> @ staticmethod <EOL> def _get_nics ( vm_object ) : <EOL> tree = ElementTree . fromstring ( vm_object . XMLDesc ( <NUM_LIT:0> ) ) <EOL> return [ _recurse ( item ) for item in tree . findall ( '<STR_LIT>' ) ] <EOL> @ staticmethod <EOL> def _get_nova_name ( vm_object ) : <EOL> tree = ElementTree . fromstring ( vm_object . XMLDesc ( <NUM_LIT:0> ) ) <EOL> metadata = tree . findall ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> nova_instance_namespace_tag = metadata . getchildren ( ) [ <NUM_LIT:0> ] . tag <EOL> nova_instance_namespace = nova_instance_namespace_tag [ nova_instance_namespace_tag . find ( '<STR_LIT:{>' ) + <NUM_LIT:1> : nova_instance_namespace_tag . find ( '<STR_LIT:}>' ) ] <EOL> instance = metadata . findall ( '<STR_LIT>' % nova_instance_namespace ) [ <NUM_LIT:0> ] <EOL> name = instance . findall ( '<STR_LIT>' % nova_instance_namespace ) [ <NUM_LIT:0> ] <EOL> return name . text <EOL> @ staticmethod <EOL> def _get_ram ( vm_object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> tree = ElementTree . fromstring ( vm_object . XMLDesc ( <NUM_LIT:0> ) ) <EOL> mem = tree . findall ( '<STR_LIT>' ) [ <NUM_LIT:0> ] <EOL> unit = mem . items ( ) [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] <EOL> value = mem . text <EOL> if unit == '<STR_LIT>' : <EOL> return int ( value ) <EOL> elif unit == '<STR_LIT>' : <EOL> return int ( value ) / <NUM_LIT> <EOL> elif unit == '<STR_LIT>' : <EOL> return int ( value ) * <NUM_LIT> <EOL> @ staticmethod <EOL> def _get_disk_size ( filename ) : <EOL> cmd = [ '<STR_LIT>' , '<STR_LIT:info>' , filename ] <EOL> try : <EOL> out = subprocess . check_output ( '<STR_LIT:U+0020>' . join ( cmd ) , <EOL> stderr = subprocess . STDOUT , <EOL> shell = True ) <EOL> except subprocess . CalledProcessError as cpe : <EOL> return cpe . output . strip ( ) <EOL> out = out . split ( '<STR_LIT:\\n>' ) <EOL> for line in out : <EOL> if line . startswith ( '<STR_LIT>' ) : <EOL> size = line . split ( '<STR_LIT>' ) [ <NUM_LIT:1> ] . split ( '<STR_LIT:U+0020>' ) [ <NUM_LIT:0> ] <EOL> return size <EOL> return <NUM_LIT:0> <EOL> def _get_vm_pid ( self , vm_object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . get_power_state ( vm_object . name ( ) ) == '<STR_LIT>' : <EOL> pid_path = '<STR_LIT>' . format ( RUN_PATH , vm_object . name ( ) ) <EOL> try : <EOL> with open ( pid_path , '<STR_LIT:r>' ) as pid_file : <EOL> pid = pid_file . read ( ) <EOL> return int ( pid ) <EOL> except IOError : <EOL> return '<STR_LIT>' <EOL> return '<STR_LIT>' <EOL> @ authenticated <EOL> def make_agnostic_config ( self , vm_object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> storage_ip = '<STR_LIT:127.0.0.1>' <EOL> regex = '<STR_LIT>' <EOL> config = { '<STR_LIT>' : [ ] } <EOL> mountpoints = [ ] <EOL> order = <NUM_LIT:0> <EOL> for disk in Sdk . _get_disks ( vm_object ) : <EOL> if disk [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> continue <EOL> if '<STR_LIT:file>' in disk [ '<STR_LIT:source>' ] : <EOL> backingfilename = disk [ '<STR_LIT:source>' ] [ '<STR_LIT:file>' ] <EOL> elif '<STR_LIT>' in disk [ '<STR_LIT:source>' ] : <EOL> backingfilename = disk [ '<STR_LIT:source>' ] [ '<STR_LIT>' ] <EOL> else : <EOL> continue <EOL> match = re . search ( regex , backingfilename ) <EOL> if match is None : <EOL> continue <EOL> mountpoint = '<STR_LIT>' . format ( match . group ( <NUM_LIT:1> ) ) <EOL> filename = backingfilename . replace ( mountpoint , '<STR_LIT>' ) . strip ( '<STR_LIT:/>' ) <EOL> diskname = filename . split ( '<STR_LIT:/>' ) [ - <NUM_LIT:1> ] . split ( '<STR_LIT:.>' ) [ <NUM_LIT:0> ] <EOL> config [ '<STR_LIT>' ] . append ( { '<STR_LIT:filename>' : filename , <EOL> '<STR_LIT>' : filename , <EOL> '<STR_LIT>' : mountpoint , <EOL> '<STR_LIT:name>' : diskname , <EOL> '<STR_LIT>' : order } ) <EOL> order += <NUM_LIT:1> <EOL> mountpoints . append ( mountpoint ) <EOL> if self . ssh_client is None : <EOL> self . ssh_client = SSHClient ( self . host , username = '<STR_LIT:root>' ) <EOL> vm_filename = self . ssh_client . run ( \"<STR_LIT>\" . format ( vm_object . UUIDString ( ) , ROOT_PATH ) ) <EOL> vm_filename = vm_filename . strip ( ) . split ( '<STR_LIT:/>' ) [ - <NUM_LIT:1> ] <EOL> vm_location = System . get_my_machine_id ( self . ssh_client ) <EOL> vm_datastore = None <EOL> possible_datastores = self . ssh_client . run ( \"<STR_LIT>\" . format ( vm_filename ) ) . split ( '<STR_LIT:\\n>' ) <EOL> for datastore in possible_datastores : <EOL> if '<STR_LIT>' . format ( vm_location , vm_filename ) in datastore . strip ( ) : <EOL> for mountpoint in mountpoints : <EOL> if mountpoint in datastore . strip ( ) : <EOL> vm_datastore = mountpoint <EOL> try : <EOL> config [ '<STR_LIT:name>' ] = self . _get_nova_name ( vm_object ) <EOL> except Exception as ex : <EOL> logger . debug ( '<STR_LIT>' . format ( ex ) ) <EOL> config [ '<STR_LIT:name>' ] = vm_object . name ( ) <EOL> config [ '<STR_LIT:id>' ] = str ( vm_object . UUIDString ( ) ) <EOL> config [ '<STR_LIT>' ] = { '<STR_LIT:filename>' : '<STR_LIT>' . format ( vm_location , vm_filename ) , <EOL> '<STR_LIT>' : vm_datastore } <EOL> config [ '<STR_LIT>' ] = dict ( ( mountpoint , '<STR_LIT>' . format ( storage_ip , mountpoint ) ) for mountpoint in mountpoints ) <EOL> return config <EOL> @ authenticated <EOL> def get_power_state ( self , vmid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm = self . get_vm_object ( vmid ) <EOL> state = vm . info ( ) [ <NUM_LIT:0> ] <EOL> return self . states . get ( state , '<STR_LIT>' ) <EOL> @ authenticated <EOL> def get_vm_object ( self , vmid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> func = '<STR_LIT>' <EOL> try : <EOL> import uuid <EOL> uuid . UUID ( vmid ) <EOL> except ValueError : <EOL> func = '<STR_LIT>' <EOL> try : <EOL> return getattr ( self . _conn , func ) ( vmid ) <EOL> except self . libvirt . libvirtError as le : <EOL> logger . error ( str ( le ) ) <EOL> try : <EOL> self . _connect ( ) <EOL> return getattr ( self . _conn , func ) ( vmid ) <EOL> except self . libvirt . libvirtError as le : <EOL> logger . error ( str ( le ) ) <EOL> raise RuntimeError ( '<STR_LIT>' . format ( vmid ) ) <EOL> def get_vm_object_by_filename ( self , filename ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vmid = filename . split ( '<STR_LIT:/>' ) [ - <NUM_LIT:1> ] . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> return self . get_vm_object ( vmid ) <EOL> @ authenticated <EOL> def get_vms ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _conn . listAllDomains ( ) <EOL> def shutdown ( self , vmid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm_object = self . get_vm_object ( vmid ) <EOL> vm_object . shutdown ( ) <EOL> return self . get_power_state ( vmid ) <EOL> @ authenticated <EOL> def delete_vm ( self , vmid , devicename , disks_info ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . ssh_client is None : <EOL> self . ssh_client = SSHClient ( self . host , username = '<STR_LIT:root>' ) <EOL> vm_object = None <EOL> try : <EOL> vm_object = self . get_vm_object ( vmid ) <EOL> except Exception as ex : <EOL> logger . error ( '<STR_LIT>' . format ( ex ) ) <EOL> found_files = self . find_devicename ( devicename ) <EOL> if found_files is not None : <EOL> for found_file in found_files : <EOL> self . ssh_client . file_delete ( found_file ) <EOL> logger . info ( '<STR_LIT>' . format ( found_file ) ) <EOL> if vm_object : <EOL> found_file = '<STR_LIT>' <EOL> for disk in self . _get_disks ( vm_object ) : <EOL> if disk [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> continue <EOL> if '<STR_LIT:file>' in disk [ '<STR_LIT:source>' ] : <EOL> found_file = disk [ '<STR_LIT:source>' ] [ '<STR_LIT:file>' ] <EOL> elif '<STR_LIT>' in disk [ '<STR_LIT:source>' ] : <EOL> found_file = disk [ '<STR_LIT:source>' ] [ '<STR_LIT>' ] <EOL> if found_file and os . path . exists ( found_file ) and os . path . isfile ( found_file ) : <EOL> self . ssh_client . file_delete ( found_file ) <EOL> logger . info ( '<STR_LIT>' . format ( found_file ) ) <EOL> vm_object . undefine ( ) <EOL> elif disks_info : <EOL> for path , devicename in disks_info : <EOL> found_file = '<STR_LIT>' . format ( path , devicename ) <EOL> if os . path . exists ( found_file ) and os . path . isfile ( found_file ) : <EOL> self . ssh_client . file_delete ( found_file ) <EOL> logger . info ( '<STR_LIT>' . format ( found_file ) ) <EOL> return True <EOL> def power_on ( self , vmid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm_object = self . get_vm_object ( vmid ) <EOL> vm_object . create ( ) <EOL> return self . get_power_state ( vmid ) <EOL> def find_devicename ( self , devicename ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> _ = self <EOL> file_matcher = '<STR_LIT>' . format ( devicename ) <EOL> matches = [ ] <EOL> for found_file in glob . glob ( file_matcher ) : <EOL> if os . path . exists ( found_file ) and os . path . isfile ( found_file ) : <EOL> matches . append ( found_file ) <EOL> return matches if matches else None <EOL> def is_datastore_available ( self , mountpoint ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . ssh_client is None : <EOL> self . ssh_client = SSHClient ( self . host , username = '<STR_LIT:root>' ) <EOL> return self . ssh_client . run ( \"<STR_LIT>\" . format ( mountpoint ) ) == '<STR_LIT:yes>' <EOL> @ authenticated <EOL> def clone_vm ( self , vmid , name , disks , mountpoint ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> source_vm = self . get_vm_object ( vmid ) <EOL> return self . create_vm_from_template ( name , source_vm , disks , mountpoint ) <EOL> def create_volume ( self , location , size ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . ssh_client . file_exists ( location ) : <EOL> raise RuntimeError ( '<STR_LIT>' % location ) <EOL> command = '<STR_LIT>' . format ( size , location ) <EOL> output = self . ssh_client . run ( command ) <EOL> if not self . ssh_client . file_exists ( location ) : <EOL> raise RuntimeError ( '<STR_LIT>' % ( location , output ) ) <EOL> logger . info ( '<STR_LIT>' . format ( command , output ) ) <EOL> def delete_volume ( self , location ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . ssh_client . file_exists ( location ) : <EOL> logger . error ( '<STR_LIT>' % location ) <EOL> return <EOL> command = '<STR_LIT>' . format ( location ) <EOL> output = self . ssh_client . run ( command ) <EOL> logger . info ( '<STR_LIT>' . format ( command , output ) ) <EOL> if self . ssh_client . file_exists ( location ) : <EOL> raise RuntimeError ( '<STR_LIT>' % ( location , output ) ) <EOL> def extend_volume ( self , location , size ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not self . ssh_client . file_exists ( location ) : <EOL>", "answer": "raise RuntimeError ( '<STR_LIT>' % location )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , unicode_literals <EOL> import warnings <EOL> from django . core . exceptions import ValidationError , NON_FIELD_ERRORS , FieldError <EOL> from django . forms . fields import Field , ChoiceField <EOL> from django . forms . forms import BaseForm , get_declared_fields <EOL> from django . forms . formsets import BaseFormSet , formset_factory <EOL> from django . forms . util import ErrorList <EOL> from django . forms . widgets import ( SelectMultiple , HiddenInput , <EOL> MultipleHiddenInput , media_property , CheckboxSelectMultiple ) <EOL> from django . utils . encoding import smart_text , force_text <EOL> from django . utils . datastructures import SortedDict <EOL> from django . utils import six <EOL> from django . utils . text import get_text_list , capfirst <EOL> from django . utils . translation import ugettext_lazy as _ , ugettext , string_concat <EOL> __all__ = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ) <EOL> ALL_FIELDS = '<STR_LIT>' <EOL> def construct_instance ( form , instance , fields = None , exclude = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from django . db import models <EOL> opts = instance . _meta <EOL> cleaned_data = form . cleaned_data <EOL> file_field_list = [ ] <EOL> for f in opts . fields : <EOL> if not f . editable or isinstance ( f , models . AutoField ) or not f . name in cleaned_data : <EOL> continue <EOL> if fields is not None and f . name not in fields : <EOL> continue <EOL> if exclude and f . name in exclude : <EOL> continue <EOL> if isinstance ( f , models . FileField ) : <EOL> file_field_list . append ( f ) <EOL> else : <EOL> f . save_form_data ( instance , cleaned_data [ f . name ] ) <EOL> for f in file_field_list : <EOL> f . save_form_data ( instance , cleaned_data [ f . name ] ) <EOL> return instance <EOL> def save_instance ( form , instance , fields = None , fail_message = '<STR_LIT>' , <EOL> commit = True , exclude = None , construct = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if construct : <EOL> instance = construct_instance ( form , instance , fields , exclude ) <EOL> opts = instance . _meta <EOL> if form . errors : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % ( opts . object_name , fail_message ) ) <EOL> def save_m2m ( ) : <EOL> cleaned_data = form . cleaned_data <EOL> for f in opts . many_to_many + opts . virtual_fields : <EOL> if not hasattr ( f , '<STR_LIT>' ) : <EOL> continue <EOL> if fields and f . name not in fields : <EOL> continue <EOL> if exclude and f . name in exclude : <EOL> continue <EOL> if f . name in cleaned_data : <EOL> f . save_form_data ( instance , cleaned_data [ f . name ] ) <EOL> if commit : <EOL> instance . save ( ) <EOL> save_m2m ( ) <EOL> else : <EOL> form . save_m2m = save_m2m <EOL> return instance <EOL> def model_to_dict ( instance , fields = None , exclude = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from django . db . models . fields . related import ManyToManyField <EOL> opts = instance . _meta <EOL> data = { } <EOL> for f in opts . concrete_fields + opts . virtual_fields + opts . many_to_many : <EOL> if not getattr ( f , '<STR_LIT>' , False ) : <EOL> continue <EOL> if fields and not f . name in fields : <EOL> continue <EOL> if exclude and f . name in exclude : <EOL> continue <EOL> if isinstance ( f , ManyToManyField ) : <EOL> if instance . pk is None : <EOL> data [ f . name ] = [ ] <EOL> else : <EOL> data [ f . name ] = list ( f . value_from_object ( instance ) . values_list ( '<STR_LIT>' , flat = True ) ) <EOL> else : <EOL> data [ f . name ] = f . value_from_object ( instance ) <EOL> return data <EOL> def fields_for_model ( model , fields = None , exclude = None , widgets = None , <EOL> formfield_callback = None , localized_fields = None , <EOL> labels = None , help_texts = None , error_messages = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> field_list = [ ] <EOL> ignored = [ ] <EOL> opts = model . _meta <EOL> from django . db . models . fields import Field as ModelField <EOL> sortable_virtual_fields = [ f for f in opts . virtual_fields <EOL> if isinstance ( f , ModelField ) ] <EOL> for f in sorted ( opts . concrete_fields + sortable_virtual_fields + opts . many_to_many ) : <EOL> if not getattr ( f , '<STR_LIT>' , False ) : <EOL> continue <EOL> if fields is not None and not f . name in fields : <EOL> continue <EOL> if exclude and f . name in exclude : <EOL> continue <EOL> kwargs = { } <EOL> if widgets and f . name in widgets : <EOL> kwargs [ '<STR_LIT>' ] = widgets [ f . name ] <EOL> if localized_fields == ALL_FIELDS or ( localized_fields and f . name in localized_fields ) : <EOL> kwargs [ '<STR_LIT>' ] = True <EOL> if labels and f . name in labels : <EOL> kwargs [ '<STR_LIT:label>' ] = labels [ f . name ] <EOL> if help_texts and f . name in help_texts : <EOL> kwargs [ '<STR_LIT>' ] = help_texts [ f . name ] <EOL> if error_messages and f . name in error_messages : <EOL> kwargs [ '<STR_LIT>' ] = error_messages [ f . name ] <EOL> if formfield_callback is None : <EOL> formfield = f . formfield ( ** kwargs ) <EOL> elif not callable ( formfield_callback ) : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> else : <EOL> formfield = formfield_callback ( f , ** kwargs ) <EOL> if formfield : <EOL> field_list . append ( ( f . name , formfield ) ) <EOL> else : <EOL> ignored . append ( f . name ) <EOL> field_dict = SortedDict ( field_list ) <EOL> if fields : <EOL> field_dict = SortedDict ( <EOL> [ ( f , field_dict . get ( f ) ) for f in fields <EOL> if ( ( not exclude ) or ( exclude and f not in exclude ) ) and ( f not in ignored ) ] <EOL> ) <EOL> return field_dict <EOL> class ModelFormOptions ( object ) : <EOL> def __init__ ( self , options = None ) : <EOL> self . model = getattr ( options , '<STR_LIT>' , None ) <EOL> self . fields = getattr ( options , '<STR_LIT>' , None ) <EOL> self . exclude = getattr ( options , '<STR_LIT>' , None ) <EOL> self . widgets = getattr ( options , '<STR_LIT>' , None ) <EOL> self . localized_fields = getattr ( options , '<STR_LIT>' , None ) <EOL> self . labels = getattr ( options , '<STR_LIT>' , None ) <EOL> self . help_texts = getattr ( options , '<STR_LIT>' , None ) <EOL> self . error_messages = getattr ( options , '<STR_LIT>' , None ) <EOL> class ModelFormMetaclass ( type ) : <EOL> def __new__ ( cls , name , bases , attrs ) : <EOL> formfield_callback = attrs . pop ( '<STR_LIT>' , None ) <EOL> try : <EOL> parents = [ b for b in bases if issubclass ( b , ModelForm ) ] <EOL> except NameError : <EOL> parents = None <EOL> declared_fields = get_declared_fields ( bases , attrs , False ) <EOL> new_class = super ( ModelFormMetaclass , cls ) . __new__ ( cls , name , bases , <EOL> attrs ) <EOL> if not parents : <EOL> return new_class <EOL> if '<STR_LIT>' not in attrs : <EOL> new_class . media = media_property ( new_class ) <EOL> opts = new_class . _meta = ModelFormOptions ( getattr ( new_class , '<STR_LIT:Meta>' , None ) ) <EOL> for opt in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : <EOL> value = getattr ( opts , opt ) <EOL> if isinstance ( value , six . string_types ) and value != ALL_FIELDS : <EOL> msg = ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % { <EOL> '<STR_LIT>' : new_class . __name__ , <EOL> '<STR_LIT>' : opt , <EOL> '<STR_LIT:value>' : value , <EOL> } ) <EOL> raise TypeError ( msg ) <EOL> if opts . model : <EOL> if opts . fields is None and opts . exclude is None : <EOL> warnings . warn ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" % name , <EOL> PendingDeprecationWarning , stacklevel = <NUM_LIT:2> ) <EOL> if opts . fields == ALL_FIELDS : <EOL> opts . fields = None <EOL> fields = fields_for_model ( opts . model , opts . fields , opts . exclude , <EOL> opts . widgets , formfield_callback , <EOL> opts . localized_fields , opts . labels , <EOL> opts . help_texts , opts . error_messages ) <EOL> none_model_fields = [ k for k , v in six . iteritems ( fields ) if not v ] <EOL> missing_fields = set ( none_model_fields ) - set ( declared_fields . keys ( ) ) <EOL> if missing_fields : <EOL> message = '<STR_LIT>' <EOL> message = message % ( '<STR_LIT:U+002CU+0020>' . join ( missing_fields ) , <EOL> opts . model . __name__ ) <EOL> raise FieldError ( message ) <EOL> fields . update ( declared_fields ) <EOL> else : <EOL> fields = declared_fields <EOL> new_class . declared_fields = declared_fields <EOL> new_class . base_fields = fields <EOL> return new_class <EOL> class BaseModelForm ( BaseForm ) : <EOL> def __init__ ( self , data = None , files = None , auto_id = '<STR_LIT>' , prefix = None , <EOL> initial = None , error_class = ErrorList , label_suffix = None , <EOL> empty_permitted = False , instance = None ) : <EOL> opts = self . _meta <EOL> if opts . model is None : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> if instance is None : <EOL> self . instance = opts . model ( ) <EOL> object_data = { } <EOL> else : <EOL> self . instance = instance <EOL> object_data = model_to_dict ( instance , opts . fields , opts . exclude ) <EOL> if initial is not None : <EOL> object_data . update ( initial ) <EOL> self . _validate_unique = False <EOL> super ( BaseModelForm , self ) . __init__ ( data , files , auto_id , prefix , object_data , <EOL> error_class , label_suffix , empty_permitted ) <EOL> def _update_errors ( self , errors ) : <EOL> for field , messages in errors . error_dict . items ( ) : <EOL> if field not in self . fields : <EOL> continue <EOL> field = self . fields [ field ] <EOL> for message in messages : <EOL> if isinstance ( message , ValidationError ) : <EOL> if message . code in field . error_messages : <EOL> message . message = field . error_messages [ message . code ] <EOL> message_dict = errors . message_dict <EOL> for k , v in message_dict . items ( ) : <EOL> if k != NON_FIELD_ERRORS : <EOL> self . _errors . setdefault ( k , self . error_class ( ) ) . extend ( v ) <EOL> if k in self . cleaned_data : <EOL> del self . cleaned_data [ k ] <EOL> if NON_FIELD_ERRORS in message_dict : <EOL> messages = message_dict [ NON_FIELD_ERRORS ] <EOL> self . _errors . setdefault ( NON_FIELD_ERRORS , self . error_class ( ) ) . extend ( messages ) <EOL> def _get_validation_exclusions ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> exclude = [ ] <EOL> for f in self . instance . _meta . fields : <EOL> field = f . name <EOL> if field not in self . fields : <EOL> exclude . append ( f . name ) <EOL> elif self . _meta . fields and field not in self . _meta . fields : <EOL> exclude . append ( f . name ) <EOL> elif self . _meta . exclude and field in self . _meta . exclude : <EOL> exclude . append ( f . name ) <EOL> elif field in self . _errors . keys ( ) : <EOL> exclude . append ( f . name ) <EOL> else : <EOL> form_field = self . fields [ field ] <EOL> field_value = self . cleaned_data . get ( field , None ) <EOL> if not f . blank and not form_field . required and field_value in form_field . empty_values : <EOL> exclude . append ( f . name ) <EOL> return exclude <EOL> def clean ( self ) : <EOL> self . _validate_unique = True <EOL> return self . cleaned_data <EOL> def _post_clean ( self ) : <EOL> opts = self . _meta <EOL> self . instance = construct_instance ( self , self . instance , opts . fields , opts . exclude ) <EOL> exclude = self . _get_validation_exclusions ( ) <EOL> for f_name , field in self . fields . items ( ) : <EOL> if isinstance ( field , InlineForeignKeyField ) : <EOL> exclude . append ( f_name ) <EOL> try : <EOL> self . instance . full_clean ( exclude = exclude , <EOL> validate_unique = False ) <EOL> except ValidationError as e : <EOL> self . _update_errors ( e ) <EOL> if self . _validate_unique : <EOL> self . validate_unique ( ) <EOL> def validate_unique ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> exclude = self . _get_validation_exclusions ( ) <EOL> try : <EOL> self . instance . validate_unique ( exclude = exclude ) <EOL> except ValidationError as e : <EOL> self . _update_errors ( e ) <EOL> def save ( self , commit = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if self . instance . pk is None : <EOL> fail_message = '<STR_LIT>' <EOL> else : <EOL> fail_message = '<STR_LIT>' <EOL> return save_instance ( self , self . instance , self . _meta . fields , <EOL> fail_message , commit , self . _meta . exclude , <EOL> construct = False ) <EOL> save . alters_data = True <EOL> class ModelForm ( six . with_metaclass ( ModelFormMetaclass , BaseModelForm ) ) : <EOL> pass <EOL> def modelform_factory ( model , form = ModelForm , fields = None , exclude = None , <EOL> formfield_callback = None , widgets = None , localized_fields = None , <EOL> labels = None , help_texts = None , error_messages = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> attrs = { '<STR_LIT>' : model } <EOL> if fields is not None : <EOL> attrs [ '<STR_LIT>' ] = fields <EOL> if exclude is not None : <EOL> attrs [ '<STR_LIT>' ] = exclude <EOL> if widgets is not None : <EOL> attrs [ '<STR_LIT>' ] = widgets <EOL> if localized_fields is not None : <EOL> attrs [ '<STR_LIT>' ] = localized_fields <EOL> if labels is not None : <EOL> attrs [ '<STR_LIT>' ] = labels <EOL> if help_texts is not None : <EOL> attrs [ '<STR_LIT>' ] = help_texts <EOL> if error_messages is not None : <EOL> attrs [ '<STR_LIT>' ] = error_messages <EOL> parent = ( object , ) <EOL> if hasattr ( form , '<STR_LIT:Meta>' ) : <EOL> parent = ( form . Meta , object ) <EOL> Meta = type ( str ( '<STR_LIT:Meta>' ) , parent , attrs ) <EOL> class_name = model . __name__ + str ( '<STR_LIT>' ) <EOL> form_class_attrs = { <EOL> '<STR_LIT:Meta>' : Meta , <EOL> '<STR_LIT>' : formfield_callback <EOL> } <EOL> if ( getattr ( Meta , '<STR_LIT>' , None ) is None and <EOL> getattr ( Meta , '<STR_LIT>' , None ) is None ) : <EOL> warnings . warn ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> PendingDeprecationWarning , stacklevel = <NUM_LIT:2> ) <EOL> return type ( form ) ( class_name , ( form , ) , form_class_attrs ) <EOL> class BaseModelFormSet ( BaseFormSet ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> model = None <EOL> def __init__ ( self , data = None , files = None , auto_id = '<STR_LIT>' , prefix = None , <EOL> queryset = None , ** kwargs ) : <EOL> self . queryset = queryset <EOL> self . initial_extra = kwargs . pop ( '<STR_LIT>' , None ) <EOL> defaults = { '<STR_LIT:data>' : data , '<STR_LIT>' : files , '<STR_LIT>' : auto_id , '<STR_LIT>' : prefix } <EOL> defaults . update ( kwargs ) <EOL> super ( BaseModelFormSet , self ) . __init__ ( ** defaults ) <EOL> def initial_form_count ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not ( self . data or self . files ) : <EOL> return len ( self . get_queryset ( ) ) <EOL> return super ( BaseModelFormSet , self ) . initial_form_count ( ) <EOL> def _existing_object ( self , pk ) : <EOL> if not hasattr ( self , '<STR_LIT>' ) : <EOL> self . _object_dict = dict ( [ ( o . pk , o ) for o in self . get_queryset ( ) ] ) <EOL> return self . _object_dict . get ( pk ) <EOL> def _construct_form ( self , i , ** kwargs ) : <EOL> if self . is_bound and i < self . initial_form_count ( ) : <EOL> from django . db import connections <EOL> pk_key = \"<STR_LIT>\" % ( self . add_prefix ( i ) , self . model . _meta . pk . name ) <EOL> pk = self . data [ pk_key ] <EOL> pk_field = self . model . _meta . pk <EOL> pk = pk_field . get_db_prep_lookup ( '<STR_LIT>' , pk , <EOL> connection = connections [ self . get_queryset ( ) . db ] ) <EOL> if isinstance ( pk , list ) : <EOL> pk = pk [ <NUM_LIT:0> ] <EOL> kwargs [ '<STR_LIT>' ] = self . _existing_object ( pk ) <EOL> if i < self . initial_form_count ( ) and not kwargs . get ( '<STR_LIT>' ) : <EOL> kwargs [ '<STR_LIT>' ] = self . get_queryset ( ) [ i ] <EOL> if i >= self . initial_form_count ( ) and self . initial_extra : <EOL> try : <EOL> kwargs [ '<STR_LIT>' ] = self . initial_extra [ i - self . initial_form_count ( ) ] <EOL> except IndexError : <EOL> pass <EOL> return super ( BaseModelFormSet , self ) . _construct_form ( i , ** kwargs ) <EOL> def get_queryset ( self ) : <EOL> if not hasattr ( self , '<STR_LIT>' ) : <EOL> if self . queryset is not None : <EOL> qs = self . queryset <EOL> else : <EOL> qs = self . model . _default_manager . get_queryset ( ) <EOL> if not qs . ordered : <EOL> qs = qs . order_by ( self . model . _meta . pk . name ) <EOL> self . _queryset = qs <EOL> return self . _queryset <EOL> def save_new ( self , form , commit = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return form . save ( commit = commit ) <EOL> def save_existing ( self , form , instance , commit = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return form . save ( commit = commit ) <EOL> def save ( self , commit = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not commit : <EOL> self . saved_forms = [ ] <EOL> def save_m2m ( ) : <EOL> for form in self . saved_forms : <EOL> form . save_m2m ( ) <EOL> self . save_m2m = save_m2m <EOL> return self . save_existing_objects ( commit ) + self . save_new_objects ( commit ) <EOL> save . alters_data = True <EOL> def clean ( self ) : <EOL> self . validate_unique ( ) <EOL> def validate_unique ( self ) : <EOL> all_unique_checks = set ( ) <EOL> all_date_checks = set ( ) <EOL> forms_to_delete = self . deleted_forms <EOL> valid_forms = [ form for form in self . forms if form . is_valid ( ) and form not in forms_to_delete ] <EOL> for form in valid_forms : <EOL> exclude = form . _get_validation_exclusions ( ) <EOL> unique_checks , date_checks = form . instance . _get_unique_checks ( exclude = exclude ) <EOL> all_unique_checks = all_unique_checks . union ( set ( unique_checks ) ) <EOL> all_date_checks = all_date_checks . union ( set ( date_checks ) ) <EOL> errors = [ ] <EOL> for uclass , unique_check in all_unique_checks : <EOL> seen_data = set ( ) <EOL> for form in valid_forms : <EOL> row_data = tuple ( [ form . cleaned_data [ field ] for field in unique_check if field in form . cleaned_data ] ) <EOL> if row_data and not None in row_data : <EOL> if row_data in seen_data : <EOL> errors . append ( self . get_unique_error_message ( unique_check ) ) <EOL> form . _errors [ NON_FIELD_ERRORS ] = self . error_class ( [ self . get_form_error ( ) ] ) <EOL> for field in unique_check : <EOL> if field in form . cleaned_data : <EOL> del form . cleaned_data [ field ] <EOL> seen_data . add ( row_data ) <EOL> for date_check in all_date_checks : <EOL> seen_data = set ( ) <EOL> uclass , lookup , field , unique_for = date_check <EOL> for form in valid_forms : <EOL> if ( form . cleaned_data and form . cleaned_data [ field ] is not None <EOL> and form . cleaned_data [ unique_for ] is not None ) : <EOL> if lookup == '<STR_LIT:date>' : <EOL> date = form . cleaned_data [ unique_for ] <EOL> date_data = ( date . year , date . month , date . day ) <EOL> else : <EOL> date_data = ( getattr ( form . cleaned_data [ unique_for ] , lookup ) , ) <EOL> data = ( form . cleaned_data [ field ] , ) + date_data <EOL> if data in seen_data : <EOL> errors . append ( self . get_date_error_message ( date_check ) ) <EOL> form . _errors [ NON_FIELD_ERRORS ] = self . error_class ( [ self . get_form_error ( ) ] ) <EOL> del form . cleaned_data [ field ] <EOL> seen_data . add ( data ) <EOL> if errors : <EOL> raise ValidationError ( errors ) <EOL> def get_unique_error_message ( self , unique_check ) : <EOL> if len ( unique_check ) == <NUM_LIT:1> : <EOL> return ugettext ( \"<STR_LIT>\" ) % { <EOL> \"<STR_LIT>\" : unique_check [ <NUM_LIT:0> ] , <EOL> } <EOL> else : <EOL> return ugettext ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) % { <EOL> \"<STR_LIT>\" : get_text_list ( unique_check , six . text_type ( _ ( \"<STR_LIT>\" ) ) ) , <EOL> } <EOL> def get_date_error_message ( self , date_check ) : <EOL> return ugettext ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) % { <EOL> '<STR_LIT>' : date_check [ <NUM_LIT:2> ] , <EOL> '<STR_LIT>' : date_check [ <NUM_LIT:3> ] , <EOL> '<STR_LIT>' : six . text_type ( date_check [ <NUM_LIT:1> ] ) , <EOL> } <EOL> def get_form_error ( self ) : <EOL> return ugettext ( \"<STR_LIT>\" ) <EOL> def save_existing_objects ( self , commit = True ) : <EOL> self . changed_objects = [ ] <EOL> self . deleted_objects = [ ] <EOL> if not self . initial_forms : <EOL> return [ ] <EOL> saved_instances = [ ] <EOL> forms_to_delete = self . deleted_forms <EOL> for form in self . initial_forms : <EOL> pk_name = self . _pk_field . name <EOL> raw_pk_value = form . _raw_value ( pk_name ) <EOL> pk_value = form . fields [ pk_name ] . clean ( raw_pk_value ) <EOL> pk_value = getattr ( pk_value , '<STR_LIT>' , pk_value ) <EOL> obj = self . _existing_object ( pk_value ) <EOL> if form in forms_to_delete : <EOL> self . deleted_objects . append ( obj ) <EOL> obj . delete ( ) <EOL> continue <EOL> if form . has_changed ( ) : <EOL> self . changed_objects . append ( ( obj , form . changed_data ) ) <EOL> saved_instances . append ( self . save_existing ( form , obj , commit = commit ) ) <EOL> if not commit : <EOL> self . saved_forms . append ( form ) <EOL> return saved_instances <EOL> def save_new_objects ( self , commit = True ) : <EOL> self . new_objects = [ ] <EOL> for form in self . extra_forms : <EOL> if not form . has_changed ( ) : <EOL> continue <EOL> if self . can_delete and self . _should_delete_form ( form ) : <EOL> continue <EOL> self . new_objects . append ( self . save_new ( form , commit = commit ) ) <EOL> if not commit : <EOL> self . saved_forms . append ( form ) <EOL> return self . new_objects <EOL> def add_fields ( self , form , index ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from django . db . models import AutoField , OneToOneField , ForeignKey <EOL> self . _pk_field = pk = self . model . _meta . pk <EOL> def pk_is_not_editable ( pk ) : <EOL> return ( ( not pk . editable ) or ( pk . auto_created or isinstance ( pk , AutoField ) ) <EOL> or ( pk . rel and pk . rel . parent_link and pk_is_not_editable ( pk . rel . to . _meta . pk ) ) ) <EOL> if pk_is_not_editable ( pk ) or pk . name not in form . fields : <EOL> if form . is_bound : <EOL> pk_value = form . instance . pk <EOL> else : <EOL> try : <EOL> if index is not None : <EOL> pk_value = self . get_queryset ( ) [ index ] . pk <EOL> else : <EOL> pk_value = None <EOL> except IndexError : <EOL> pk_value = None <EOL> if isinstance ( pk , OneToOneField ) or isinstance ( pk , ForeignKey ) : <EOL> qs = pk . rel . to . _default_manager . get_queryset ( ) <EOL> else : <EOL> qs = self . model . _default_manager . get_queryset ( ) <EOL> qs = qs . using ( form . instance . _state . db ) <EOL> if form . _meta . widgets : <EOL> widget = form . _meta . widgets . get ( self . _pk_field . name , HiddenInput ) <EOL> else : <EOL> widget = HiddenInput <EOL> form . fields [ self . _pk_field . name ] = ModelChoiceField ( qs , initial = pk_value , required = False , widget = widget ) <EOL> super ( BaseModelFormSet , self ) . add_fields ( form , index ) <EOL> def modelformset_factory ( model , form = ModelForm , formfield_callback = None , <EOL> formset = BaseModelFormSet , extra = <NUM_LIT:1> , can_delete = False , <EOL> can_order = False , max_num = None , fields = None , exclude = None , <EOL> widgets = None , validate_max = False , localized_fields = None , <EOL> labels = None , help_texts = None , error_messages = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> meta = getattr ( form , '<STR_LIT:Meta>' , None ) <EOL> if meta is None : <EOL> meta = type ( str ( '<STR_LIT:Meta>' ) , ( object , ) , { } ) <EOL> if ( getattr ( meta , '<STR_LIT>' , fields ) is None and <EOL> getattr ( meta , '<STR_LIT>' , exclude ) is None ) : <EOL> warnings . warn ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> PendingDeprecationWarning , stacklevel = <NUM_LIT:2> ) <EOL> form = modelform_factory ( model , form = form , fields = fields , exclude = exclude , <EOL> formfield_callback = formfield_callback , <EOL> widgets = widgets , localized_fields = localized_fields , <EOL> labels = labels , help_texts = help_texts , error_messages = error_messages ) <EOL> FormSet = formset_factory ( form , formset , extra = extra , max_num = max_num , <EOL> can_order = can_order , can_delete = can_delete , <EOL> validate_max = validate_max ) <EOL> FormSet . model = model <EOL> return FormSet <EOL> class BaseInlineFormSet ( BaseModelFormSet ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , data = None , files = None , instance = None , <EOL> save_as_new = False , prefix = None , queryset = None , ** kwargs ) : <EOL> if instance is None : <EOL> self . instance = self . fk . rel . to ( ) <EOL> else : <EOL> self . instance = instance <EOL> self . save_as_new = save_as_new <EOL> if queryset is None : <EOL> queryset = self . model . _default_manager <EOL> if self . instance . pk is not None : <EOL> qs = queryset . filter ( ** { self . fk . name : self . instance } ) <EOL> else : <EOL> qs = queryset . none ( ) <EOL> super ( BaseInlineFormSet , self ) . __init__ ( data , files , prefix = prefix , <EOL> queryset = qs , ** kwargs ) <EOL> def initial_form_count ( self ) : <EOL> if self . save_as_new : <EOL> return <NUM_LIT:0> <EOL> return super ( BaseInlineFormSet , self ) . initial_form_count ( ) <EOL> def _construct_form ( self , i , ** kwargs ) : <EOL> form = super ( BaseInlineFormSet , self ) . _construct_form ( i , ** kwargs ) <EOL> if self . save_as_new : <EOL> form . data [ form . add_prefix ( self . _pk_field . name ) ] = None <EOL> form . data [ form . add_prefix ( self . fk . name ) ] = None <EOL> fk_value = self . instance . pk <EOL> if self . fk . rel . field_name != self . fk . rel . to . _meta . pk . name : <EOL> fk_value = getattr ( self . instance , self . fk . rel . field_name ) <EOL> fk_value = getattr ( fk_value , '<STR_LIT>' , fk_value ) <EOL> setattr ( form . instance , self . fk . get_attname ( ) , fk_value ) <EOL> return form <EOL> @ classmethod <EOL> def get_default_prefix ( cls ) : <EOL> from django . db . models . fields . related import RelatedObject <EOL> return RelatedObject ( cls . fk . rel . to , cls . model , cls . fk ) . get_accessor_name ( ) . replace ( '<STR_LIT:+>' , '<STR_LIT>' ) <EOL> def save_new ( self , form , commit = True ) : <EOL> obj = form . save ( commit = False ) <EOL> pk_value = getattr ( self . instance , self . fk . rel . field_name ) <EOL> setattr ( obj , self . fk . get_attname ( ) , getattr ( pk_value , '<STR_LIT>' , pk_value ) ) <EOL> if commit : <EOL> obj . save ( ) <EOL> if commit and hasattr ( form , '<STR_LIT>' ) : <EOL> form . save_m2m ( ) <EOL> return obj <EOL> def add_fields ( self , form , index ) : <EOL> super ( BaseInlineFormSet , self ) . add_fields ( form , index ) <EOL> if self . _pk_field == self . fk : <EOL> name = self . _pk_field . name <EOL> kwargs = { '<STR_LIT>' : True } <EOL> else : <EOL> name = self . fk . name <EOL> kwargs = { <EOL> '<STR_LIT:label>' : getattr ( form . fields . get ( name ) , '<STR_LIT:label>' , capfirst ( self . fk . verbose_name ) ) <EOL> } <EOL> if self . fk . rel . field_name != self . fk . rel . to . _meta . pk . name : <EOL> kwargs [ '<STR_LIT>' ] = self . fk . rel . field_name <EOL> form . fields [ name ] = InlineForeignKeyField ( self . instance , ** kwargs ) <EOL> if form . _meta . fields : <EOL> if isinstance ( form . _meta . fields , tuple ) : <EOL> form . _meta . fields = list ( form . _meta . fields ) <EOL> form . _meta . fields . append ( self . fk . name ) <EOL> def get_unique_error_message ( self , unique_check ) : <EOL> unique_check = [ field for field in unique_check if field != self . fk . name ] <EOL> return super ( BaseInlineFormSet , self ) . get_unique_error_message ( unique_check ) <EOL> def _get_foreign_key ( parent_model , model , fk_name = None , can_fail = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from django . db . models import ForeignKey <EOL> opts = model . _meta <EOL> if fk_name : <EOL> fks_to_parent = [ f for f in opts . fields if f . name == fk_name ] <EOL> if len ( fks_to_parent ) == <NUM_LIT:1> : <EOL> fk = fks_to_parent [ <NUM_LIT:0> ] <EOL> if not isinstance ( fk , ForeignKey ) or ( fk . rel . to != parent_model and <EOL> fk . rel . to not in parent_model . _meta . get_parent_list ( ) ) : <EOL> raise Exception ( \"<STR_LIT>\" % ( fk_name , parent_model ) ) <EOL> elif len ( fks_to_parent ) == <NUM_LIT:0> : <EOL> raise Exception ( \"<STR_LIT>\" % ( model , fk_name ) ) <EOL> else : <EOL> fks_to_parent = [ <EOL> f for f in opts . fields <EOL> if isinstance ( f , ForeignKey ) <EOL> and ( f . rel . to == parent_model <EOL> or f . rel . to in parent_model . _meta . get_parent_list ( ) ) <EOL> ] <EOL> if len ( fks_to_parent ) == <NUM_LIT:1> : <EOL> fk = fks_to_parent [ <NUM_LIT:0> ] <EOL> elif len ( fks_to_parent ) == <NUM_LIT:0> : <EOL> if can_fail : <EOL> return <EOL> raise Exception ( \"<STR_LIT>\" % ( model , parent_model ) ) <EOL> else : <EOL> raise Exception ( \"<STR_LIT>\" % ( model , parent_model ) ) <EOL> return fk <EOL>", "answer": "def inlineformset_factory ( parent_model , model , form = ModelForm ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from math import log10 , floor <EOL> import string <EOL> import wx <EOL> class EmbeddedPylab ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "def __init__ ( self , canvas ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import unittest <EOL> import unicodedata <EOL> import _testcapi <EOL> from test import support <EOL> from http . client import HTTPException <EOL> from test . test_normalization import check_version <EOL> class UnicodeNamesTest ( unittest . TestCase ) : <EOL> def checkletter ( self , name , code ) : <EOL> res = eval ( r'<STR_LIT>' % name ) <EOL> self . assertEqual ( res , code ) <EOL> return res <EOL> def test_general ( self ) : <EOL> chars = [ <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" <EOL> ] <EOL> string = \"<STR_LIT>\" <EOL> self . assertEqual ( <EOL> \"<STR_LIT>\" . join ( [ self . checkletter ( * args ) for args in zip ( chars , string ) ] ) , <EOL> string <EOL> ) <EOL> def test_ascii_letters ( self ) : <EOL> for char in \"<STR_LIT>\" . join ( map ( chr , range ( ord ( \"<STR_LIT:a>\" ) , ord ( \"<STR_LIT:z>\" ) ) ) ) : <EOL> name = \"<STR_LIT>\" % char . upper ( ) <EOL> code = unicodedata . lookup ( name ) <EOL> self . assertEqual ( unicodedata . name ( code ) , name ) <EOL> def test_hangul_syllables ( self ) : <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . assertRaises ( ValueError , unicodedata . name , \"<STR_LIT>\" ) <EOL> def test_cjk_unified_ideographs ( self ) : <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def test_bmp_characters ( self ) : <EOL> for code in range ( <NUM_LIT> ) : <EOL> char = chr ( code ) <EOL> name = unicodedata . name ( char , None ) <EOL> if name is not None : <EOL> self . assertEqual ( unicodedata . lookup ( name ) , char ) <EOL> def test_misc_symbols ( self ) : <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> self . checkletter ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def test_aliases ( self ) : <EOL> aliases = [ <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) <EOL> ] <EOL> for alias , codepoint in aliases : <EOL> self . checkletter ( alias , chr ( codepoint ) ) <EOL> name = unicodedata . name ( chr ( codepoint ) ) <EOL> self . assertNotEqual ( name , alias ) <EOL> self . assertEqual ( unicodedata . lookup ( alias ) , <EOL> unicodedata . lookup ( name ) ) <EOL> with self . assertRaises ( KeyError ) : <EOL> unicodedata . ucd_3_2_0 . lookup ( alias ) <EOL> def test_aliases_names_in_pua_range ( self ) : <EOL> for cp in range ( <NUM_LIT> , <NUM_LIT> ) : <EOL> with self . assertRaises ( ValueError ) as cm : <EOL> unicodedata . name ( chr ( cp ) ) <EOL> self . assertEqual ( str ( cm . exception ) , '<STR_LIT>' ) <EOL> def test_named_sequences_names_in_pua_range ( self ) : <EOL> for cp in range ( <NUM_LIT> , <NUM_LIT> ) : <EOL> with self . assertRaises ( ValueError ) as cm : <EOL> unicodedata . name ( chr ( cp ) ) <EOL> self . assertEqual ( str ( cm . exception ) , '<STR_LIT>' ) <EOL> def test_named_sequences_sample ( self ) : <EOL> sequences = [ <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> for seqname , codepoints in sequences : <EOL> self . assertEqual ( unicodedata . lookup ( seqname ) , codepoints ) <EOL> with self . assertRaises ( SyntaxError ) : <EOL> self . checkletter ( seqname , None ) <EOL> with self . assertRaises ( KeyError ) : <EOL> unicodedata . ucd_3_2_0 . lookup ( seqname ) <EOL> def test_named_sequences_full ( self ) : <EOL> url = ( \"<STR_LIT>\" % <EOL> unicodedata . unidata_version ) <EOL> try : <EOL> testdata = support . open_urlresource ( url , encoding = \"<STR_LIT:utf-8>\" , <EOL> check = check_version ) <EOL> except ( IOError , HTTPException ) : <EOL> self . skipTest ( \"<STR_LIT>\" + url ) <EOL> self . addCleanup ( testdata . close ) <EOL> for line in testdata : <EOL> line = line . strip ( ) <EOL> if not line or line . startswith ( '<STR_LIT:#>' ) : <EOL> continue <EOL> seqname , codepoints = line . split ( '<STR_LIT:;>' ) <EOL> codepoints = '<STR_LIT>' . join ( chr ( int ( cp , <NUM_LIT:16> ) ) for cp in codepoints . split ( ) ) <EOL> self . assertEqual ( unicodedata . lookup ( seqname ) , codepoints ) <EOL> with self . assertRaises ( SyntaxError ) : <EOL> self . checkletter ( seqname , None ) <EOL> with self . assertRaises ( KeyError ) : <EOL> unicodedata . ucd_3_2_0 . lookup ( seqname ) <EOL> def test_errors ( self ) : <EOL> self . assertRaises ( TypeError , unicodedata . name ) <EOL> self . assertRaises ( TypeError , unicodedata . name , '<STR_LIT>' ) <EOL> self . assertRaises ( TypeError , unicodedata . lookup ) <EOL> self . assertRaises ( KeyError , unicodedata . lookup , '<STR_LIT>' ) <EOL> def test_strict_error_handling ( self ) : <EOL> self . assertRaises ( <EOL> UnicodeError , <EOL> str , b\"<STR_LIT>\" , '<STR_LIT>' , '<STR_LIT:strict>' <EOL> ) <EOL> self . assertRaises ( <EOL> UnicodeError , <EOL> str , bytes ( \"<STR_LIT>\" % ( \"<STR_LIT:x>\" * <NUM_LIT> ) , \"<STR_LIT:ascii>\" ) , '<STR_LIT>' , '<STR_LIT:strict>' <EOL> ) <EOL> self . assertRaises ( <EOL> UnicodeError , <EOL> str , b\"<STR_LIT>\" , '<STR_LIT>' , '<STR_LIT:strict>' <EOL>", "answer": ")"}, {"prompt": "<s> try : <EOL> from south . db import db <EOL>", "answer": "from django . db . models . signals import post_syncdb"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import httpretty <EOL> from six . moves import cStringIO <EOL> from six . moves . urllib import parse as urlparse <EOL> from bravado . client import SwaggerClient <EOL> from tests . functional . conftest import register_spec , API_DOCS_URL , register_get <EOL> def test_form_params_in_request ( httprettified , swagger_dict ) : <EOL> param1_spec = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" <EOL> } <EOL> param2_spec = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:type>\" : \"<STR_LIT:string>\" <EOL> } <EOL> path_spec = swagger_dict [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> path_spec [ '<STR_LIT>' ] = path_spec . pop ( '<STR_LIT>' ) <EOL> path_spec [ '<STR_LIT>' ] [ '<STR_LIT>' ] = [ param1_spec , param2_spec ] <EOL> register_spec ( swagger_dict ) <EOL> httpretty . register_uri ( httpretty . POST , \"<STR_LIT>\" ) <EOL> resource = SwaggerClient . from_url ( API_DOCS_URL ) . api_test <EOL> resource . testHTTP ( param_id = <NUM_LIT> , param_name = '<STR_LIT:foo>' ) . result ( ) <EOL> content_type = httpretty . last_request ( ) . headers [ '<STR_LIT>' ] <EOL> assert '<STR_LIT>' == content_type <EOL> body = urlparse . parse_qs ( httpretty . last_request ( ) . body ) <EOL> assert { b'<STR_LIT>' : [ b'<STR_LIT:foo>' ] , b'<STR_LIT>' : [ b'<STR_LIT>' ] } == body <EOL> def test_file_upload_in_request ( httprettified , swagger_dict ) : <EOL> param1_spec = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:type>\" : \"<STR_LIT>\" <EOL> } <EOL> param2_spec = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:type>\" : \"<STR_LIT:file>\" <EOL> } <EOL> path_spec = swagger_dict [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> path_spec [ '<STR_LIT>' ] = path_spec . pop ( '<STR_LIT>' ) <EOL> path_spec [ '<STR_LIT>' ] [ '<STR_LIT>' ] = [ param1_spec , param2_spec ] <EOL> path_spec [ '<STR_LIT>' ] [ '<STR_LIT>' ] = [ '<STR_LIT>' ] <EOL> register_spec ( swagger_dict ) <EOL> httpretty . register_uri ( httpretty . POST , \"<STR_LIT>\" ) <EOL> resource = SwaggerClient . from_url ( API_DOCS_URL ) . api_test <EOL> resource . testHTTP ( param_id = <NUM_LIT> , file_name = cStringIO ( '<STR_LIT>' ) ) . result ( ) <EOL> content_type = httpretty . last_request ( ) . headers [ '<STR_LIT>' ] <EOL> assert content_type . startswith ( '<STR_LIT>' ) <EOL> assert b\"<STR_LIT>\" in httpretty . last_request ( ) . body <EOL> assert b\"<STR_LIT>\" in httpretty . last_request ( ) . body <EOL> def test_parameter_in_path_of_request ( httprettified , swagger_dict ) : <EOL> path_param_spec = { <EOL> \"<STR_LIT>\" : \"<STR_LIT:path>\" , <EOL> \"<STR_LIT:name>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT:type>\" : \"<STR_LIT:string>\" <EOL> } <EOL> paths_spec = swagger_dict [ '<STR_LIT>' ] <EOL> paths_spec [ '<STR_LIT>' ] = paths_spec . pop ( '<STR_LIT>' ) <EOL> paths_spec [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] . append ( <EOL> path_param_spec ) <EOL> register_spec ( swagger_dict ) <EOL> register_get ( '<STR_LIT>' ) <EOL> resource = SwaggerClient . from_url ( API_DOCS_URL ) . api_test <EOL> assert resource . testHTTP ( test_param = \"<STR_LIT:foo>\" , param_id = \"<STR_LIT>\" ) . result ( ) is None <EOL> def test_default_value_not_in_request ( httprettified , swagger_dict ) : <EOL> swagger_dict [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:default>' ] = '<STR_LIT:X>' <EOL> register_spec ( swagger_dict ) <EOL> register_get ( \"<STR_LIT>\" ) <EOL> resource = SwaggerClient . from_url ( API_DOCS_URL ) . api_test <EOL> resource . testHTTP ( ) . result ( ) <EOL> assert '<STR_LIT>' not in httpretty . last_request ( ) . querystring <EOL> def test_array_with_collection_format_in_path_of_request ( <EOL> httprettified , swagger_dict ) : <EOL> path_param_spec = { <EOL> '<STR_LIT>' : '<STR_LIT:path>' , <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT:type>' : '<STR_LIT>' <EOL>", "answer": "} ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import absolute_import , unicode_literals <EOL> import functools <EOL> import logging <EOL>", "answer": "from . errors import TemporarilyUnavailableError , ServerError"}, {"prompt": "<s> from flask_appbuilder . security . views import UserDBModelView <EOL> from flask_babelpkg import lazy_gettext <EOL> class MyUserDBModelView ( UserDBModelView ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> show_fieldsets = [ <EOL> ( lazy_gettext ( '<STR_LIT>' ) , <EOL> { '<STR_LIT>' : [ '<STR_LIT:username>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] } ) , <EOL> ( lazy_gettext ( '<STR_LIT>' ) , <EOL> { '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:email>' ] , '<STR_LIT>' : True } ) , <EOL> ( lazy_gettext ( '<STR_LIT>' ) , <EOL> { '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , '<STR_LIT>' : False } ) , <EOL> ] <EOL> user_show_fieldsets = [ <EOL> ( lazy_gettext ( '<STR_LIT>' ) , <EOL> { '<STR_LIT>' : [ '<STR_LIT:username>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] } ) , <EOL> ( lazy_gettext ( '<STR_LIT>' ) , <EOL> { '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:email>' ] , '<STR_LIT>' : True } ) , <EOL> ] <EOL> add_columns = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:username>' , '<STR_LIT>' , '<STR_LIT:email>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:password>' , '<STR_LIT>' ] <EOL>", "answer": "list_columns = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:username>' , '<STR_LIT:email>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ]"}, {"prompt": "<s> import json <EOL> import requests <EOL> from httpretty import HTTPretty <EOL> from social . p3 import urlencode <EOL> from social . tests . backends . oauth import OAuth1Test <EOL> class YahooOAuth1Test ( OAuth1Test ) : <EOL> backend_path = '<STR_LIT>' <EOL> user_data_url = '<STR_LIT>' '<STR_LIT>' <EOL> expected_username = '<STR_LIT>' <EOL> access_token_body = json . dumps ( { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } ) <EOL> request_token_body = urlencode ( { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT:true>' <EOL> } ) <EOL> guid_body = json . dumps ( { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:value>' : '<STR_LIT>' <EOL> } <EOL> } ) <EOL> user_data_body = json . dumps ( { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:image>' : { <EOL> '<STR_LIT:width>' : <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> '<STR_LIT>' , <EOL> '<STR_LIT:size>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> <EOL> } , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : False , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : <NUM_LIT:1> , <EOL> '<STR_LIT>' : True , <EOL>", "answer": "'<STR_LIT:type>' : '<STR_LIT>' ,"}, {"prompt": "<s> from setuptools import setup <EOL> setup ( name = \"<STR_LIT>\" , <EOL> license = \"<STR_LIT>\" , <EOL> version = \"<STR_LIT>\" , <EOL> description = \"<STR_LIT>\" , <EOL> maintainer = \"<STR_LIT>\" , <EOL> author = \"<STR_LIT>\" , <EOL> author_email = \"<STR_LIT>\" , <EOL> url = \"<STR_LIT>\" , <EOL> keywords = \"<STR_LIT>\" , <EOL> classifiers = [ \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" , <EOL> ] , <EOL> py_modules = [ '<STR_LIT>' ] , <EOL> entry_points = { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' <EOL> ] <EOL> } , <EOL>", "answer": ") "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . cryptomath import * <EOL> from . aes import * <EOL> if m2cryptoLoaded : <EOL> def new ( key , mode , IV ) : <EOL> return OpenSSL_AES ( key , mode , IV ) <EOL> class OpenSSL_AES ( AES ) : <EOL> def __init__ ( self , key , mode , IV ) : <EOL> AES . __init__ ( self , key , mode , IV , \"<STR_LIT>\" ) <EOL> self . key = key <EOL> self . IV = IV <EOL> def _createContext ( self , encrypt ) : <EOL> context = m2 . cipher_ctx_new ( ) <EOL> if len ( self . key ) == <NUM_LIT:16> : <EOL> cipherType = m2 . aes_128_cbc ( ) <EOL> if len ( self . key ) == <NUM_LIT> : <EOL> cipherType = m2 . aes_192_cbc ( ) <EOL> if len ( self . key ) == <NUM_LIT:32> : <EOL> cipherType = m2 . aes_256_cbc ( ) <EOL> m2 . cipher_init ( context , cipherType , self . key , self . IV , encrypt ) <EOL> return context <EOL> def encrypt ( self , plaintext ) : <EOL> AES . encrypt ( self , plaintext ) <EOL> context = self . _createContext ( <NUM_LIT:1> ) <EOL> ciphertext = m2 . cipher_update ( context , plaintext ) <EOL> m2 . cipher_ctx_free ( context ) <EOL> self . IV = ciphertext [ - self . block_size : ] <EOL> return bytearray ( ciphertext ) <EOL> def decrypt ( self , ciphertext ) : <EOL>", "answer": "AES . decrypt ( self , ciphertext )"}, {"prompt": "<s> from pyface . qt import QtGui , QtCore <EOL> from traits . api import Float , Any , Str , Trait <EOL> from traitsui . editors . api import RangeEditor <EOL> from traitsui . qt4 . editor import Editor <EOL> from traitsui . qt4 . extra . range_slider import RangeSlider <EOL> class _BoundsEditor ( Editor ) : <EOL> evaluate = Any <EOL> min = Any <EOL> max = Any <EOL> low = Any <EOL> high = Any <EOL> format = Str <EOL> def init ( self , parent ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> factory = self . factory <EOL> if not factory . low_name : <EOL> self . low = factory . low <EOL> if not factory . high_name : <EOL> self . high = factory . high <EOL> self . max = factory . max <EOL> self . min = factory . min <EOL> self . format = factory . format <EOL> self . evaluate = factory . evaluate <EOL> self . sync_value ( factory . evaluate_name , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . sync_value ( factory . low_name , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . sync_value ( factory . high_name , '<STR_LIT>' , '<STR_LIT>' ) <EOL> self . control = QtGui . QWidget ( ) <EOL> panel = QtGui . QHBoxLayout ( self . control ) <EOL> panel . setContentsMargins ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> self . _label_lo = QtGui . QLineEdit ( self . format % self . low ) <EOL> QtCore . QObject . connect ( self . _label_lo , QtCore . SIGNAL ( '<STR_LIT>' ) , <EOL> self . update_low_on_enter ) <EOL> panel . addWidget ( self . _label_lo ) <EOL> sh = self . _label_lo . sizeHint ( ) <EOL> sh . setWidth ( sh . width ( ) / <NUM_LIT:2> ) <EOL> self . _label_lo . setMaximumSize ( sh ) <EOL> self . control . slider = slider = RangeSlider ( QtCore . Qt . Horizontal ) <EOL> slider . setTracking ( factory . auto_set ) <EOL> slider . setMinimum ( <NUM_LIT:0> ) <EOL> slider . setMaximum ( <NUM_LIT> ) <EOL> slider . setPageStep ( <NUM_LIT:1000> ) <EOL> slider . setSingleStep ( <NUM_LIT:100> ) <EOL> slider . setLow ( self . _convert_to_slider ( self . low ) ) <EOL> slider . setHigh ( self . _convert_to_slider ( self . high ) ) <EOL> QtCore . QObject . connect ( slider , QtCore . SIGNAL ( '<STR_LIT>' ) , <EOL> self . update_object_on_scroll ) <EOL> panel . addWidget ( slider ) <EOL> self . _label_hi = QtGui . QLineEdit ( self . format % self . high ) <EOL> QtCore . QObject . connect ( self . _label_hi , QtCore . SIGNAL ( '<STR_LIT>' ) , <EOL> self . update_high_on_enter ) <EOL> panel . addWidget ( self . _label_hi ) <EOL> sh = self . _label_hi . sizeHint ( ) <EOL> sh . setWidth ( sh . width ( ) / <NUM_LIT:2> ) <EOL> self . _label_hi . setMaximumSize ( sh ) <EOL> self . set_tooltip ( slider ) <EOL> self . set_tooltip ( self . _label_lo ) <EOL> self . set_tooltip ( self . _label_hi ) <EOL> def update_low_on_enter ( self ) : <EOL> try : <EOL> try : <EOL> low = eval ( unicode ( self . _label_lo . text ( ) ) . strip ( ) ) <EOL> if self . evaluate is not None : <EOL> low = self . evaluate ( low ) <EOL> except Exception as ex : <EOL> low = self . low <EOL> self . _label_lo . setText ( self . format % self . low ) <EOL> if not self . factory . is_float : <EOL> low = int ( low ) <EOL> if low > self . high : <EOL> low = self . high - self . _step_size ( ) <EOL> self . _label_lo . setText ( self . format % low ) <EOL> self . control . slider . setLow ( self . _convert_to_slider ( low ) ) <EOL> self . low = low <EOL> except : <EOL> pass <EOL> def update_high_on_enter ( self ) : <EOL> try : <EOL> try : <EOL> high = eval ( unicode ( self . _label_hi . text ( ) ) . strip ( ) ) <EOL> if self . evaluate is not None : <EOL> high = self . evaluate ( high ) <EOL> except : <EOL> high = self . high <EOL> self . _label_hi . setText ( self . format % self . high ) <EOL> if not self . factory . is_float : <EOL> high = int ( high ) <EOL> if high < self . low : <EOL> high = self . low + self . _step_size ( ) <EOL> self . _label_hi . setText ( self . format % high ) <EOL> self . control . slider . setHigh ( self . _convert_to_slider ( high ) ) <EOL> self . high = high <EOL> except : <EOL> pass <EOL> def update_object_on_scroll ( self , pos ) : <EOL> low = self . _convert_from_slider ( self . control . slider . low ( ) ) <EOL> high = self . _convert_from_slider ( self . control . slider . high ( ) ) <EOL> if self . factory . is_float : <EOL> self . low = low <EOL> self . high = high <EOL> else : <EOL> self . low = int ( low ) <EOL> self . high = int ( high ) <EOL> self . control . slider . setLow ( self . _convert_to_slider ( low ) ) <EOL> self . control . slider . setHigh ( self . _convert_to_slider ( high ) ) <EOL> def update_editor ( self ) : <EOL> return <EOL> def _check_max_and_min ( self ) : <EOL> if self . max is None : <EOL> self . max = self . high <EOL> if self . min is None : <EOL> self . min = self . low <EOL> def _step_size ( self ) : <EOL> slider_delta = self . control . slider . maximum ( ) - self . control . slider . minimum ( ) <EOL> range_delta = self . max - self . min <EOL> return float ( range_delta ) / slider_delta <EOL> def _convert_from_slider ( self , slider_val ) : <EOL> self . _check_max_and_min ( ) <EOL> return self . min + slider_val * self . _step_size ( ) <EOL> def _convert_to_slider ( self , value ) : <EOL> self . _check_max_and_min ( ) <EOL> return self . control . slider . minimum ( ) + ( value - self . min ) / self . _step_size ( ) <EOL> def _low_changed ( self , low ) : <EOL> if self . control is None : <EOL> return <EOL> if self . _label_lo is not None : <EOL> self . _label_lo . setText ( self . format % low ) <EOL> self . control . slider . setLow ( self . _convert_to_slider ( low ) ) <EOL> def _high_changed ( self , high ) : <EOL> if self . control is None : <EOL> return <EOL>", "answer": "if self . _label_hi is not None :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function , division <EOL> import sys <EOL> import os <EOL> import fnmatch <EOL> import re <EOL> EXCLUSIONS = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> re_defs = re . compile ( \"<STR_LIT>\" , re . MULTILINE ) <EOL> re_pins = re . compile ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , <EOL> re . MULTILINE ) <EOL> re_refn = re . compile ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , re . MULTILINE ) <EOL> re_name = re . compile ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , re . MULTILINE ) <EOL> re_fp = re . compile ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , re . MULTILINE ) <EOL> re_ds = re . compile ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , re . MULTILINE ) <EOL> re_oc = re . compile ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" , re . MULTILINE ) <EOL> re_poly = re . compile ( \"<STR_LIT>\" , re . MULTILINE ) <EOL> def checkdefs ( contents , libf , errs ) : <EOL> n_defs = re_defs . findall ( contents ) <EOL> if len ( n_defs ) > <NUM_LIT:1> : <EOL> errs . append ( \"<STR_LIT>\" ) <EOL> elif len ( n_defs ) == <NUM_LIT:0> : <EOL> errs . append ( \"<STR_LIT>\" ) <EOL> partname = n_defs [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] <EOL> designator = n_defs [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] <EOL> libname = os . path . split ( libf ) [ - <NUM_LIT:1> ] . split ( \"<STR_LIT:.>\" ) [ <NUM_LIT:0> ] <EOL> if partname . lower ( ) != libname : <EOL> errs . append ( \"<STR_LIT>\" <EOL> . format ( partname , libname ) ) <EOL> return partname , designator <EOL> def checkpins ( contents , designator , errs ) : <EOL> pins = re_pins . findall ( contents ) <EOL> nums = [ ] <EOL> for name , num , x , y , length , numsize , namesize in pins : <EOL> if int ( x ) % <NUM_LIT:100> != <NUM_LIT:0> or int ( y ) % <NUM_LIT:100> != <NUM_LIT:0> : <EOL> errs . append ( \"<STR_LIT>\" . format ( name ) ) <EOL> if designator in ( \"<STR_LIT>\" , \"<STR_LIT>\" ) and int ( length ) not in ( <NUM_LIT:100> , <NUM_LIT> ) : <EOL> errs . append ( \"<STR_LIT>\" <EOL> . format ( name ) ) <EOL> if int ( namesize ) != <NUM_LIT:50> or ( int ( numsize ) != <NUM_LIT:50> and num . isdigit ( ) ) : <EOL> errs . append ( \"<STR_LIT>\" . format ( name ) ) <EOL> if num . isdigit ( ) : <EOL> nums . append ( int ( num ) ) <EOL> if nums : <EOL> expected = set ( range ( min ( nums ) , max ( nums ) + <NUM_LIT:1> ) ) <EOL> if set ( nums ) != expected : <EOL> missing = [ str ( x ) for x in set ( expected ) - set ( nums ) ] <EOL> errs . append ( \"<STR_LIT>\" . format ( \"<STR_LIT:U+002CU+0020>\" . join ( missing ) ) ) <EOL> duplicates = set ( [ str ( x ) for x in nums if nums . count ( x ) > <NUM_LIT:1> ] ) <EOL> if duplicates : <EOL> errs . append ( \"<STR_LIT>\" . format ( \"<STR_LIT:U+002CU+0020>\" . join ( duplicates ) ) ) <EOL> def checkboxes ( contents , designator , errs ) : <EOL> if designator == \"<STR_LIT>\" : <EOL> boxes = re_poly . findall ( contents ) <EOL>", "answer": "if \"<STR_LIT:f>\" not in boxes :"}, {"prompt": "<s> import sys <EOL> _ver = sys . version_info <EOL> is_py2 = ( _ver [ <NUM_LIT:0> ] == <NUM_LIT:2> ) <EOL> is_py3 = ( _ver [ <NUM_LIT:0> ] == <NUM_LIT:3> ) <EOL> if is_py2 : <EOL> from urllib import ( quote , unquote , quote_plus , unquote_plus , urlencode , <EOL> getproxies , proxy_bypass ) <EOL> from urlparse import urlparse , urlunparse , urljoin , urlsplit , urldefrag <EOL> from urllib2 import parse_http_list <EOL> import cookielib <EOL> from Cookie import Morsel <EOL> from StringIO import StringIO <EOL> from httplib import IncompleteRead <EOL> builtin_str = str <EOL> bytes = str <EOL> str = unicode <EOL> basestring = basestring <EOL> numeric_types = ( int , long , float ) <EOL> elif is_py3 : <EOL> from urllib . parse import ( urlparse , urlunparse , urljoin , urlsplit , <EOL> urlencode , quote , unquote , quote_plus , <EOL> unquote_plus , urldefrag ) <EOL> from urllib . request import parse_http_list , getproxies , proxy_bypass <EOL> from http import cookiejar as cookielib <EOL> from http . cookies import Morsel <EOL> from io import StringIO <EOL> from http . client import IncompleteRead <EOL>", "answer": "builtin_str = str"}, {"prompt": "<s> import ceilometerclient . exc as ceilometer_exceptions <EOL> from cinderclient import exceptions as cinder_exceptions <EOL> import glanceclient . exc as glance_exceptions <EOL> from keystoneclient import exceptions as keystone_exceptions <EOL> from neutronclient . common import exceptions as neutron_exceptions <EOL> from novaclient import exceptions as nova_exceptions <EOL> import six <EOL> from swiftclient import client as swift_exceptions <EOL> from openstack_dashboard . test . test_data import utils <EOL> def create_stubbed_exception ( cls , status_code = <NUM_LIT> ) : <EOL> msg = \"<STR_LIT>\" <EOL> def fake_init_exception ( self , code = None , message = None , ** kwargs ) : <EOL> if code is not None : <EOL> if hasattr ( self , '<STR_LIT>' ) : <EOL> self . http_status = code <EOL> else : <EOL> self . code = code <EOL> self . message = message or self . __class__ . message <EOL> try : <EOL> self . message = self . message % kwargs <EOL> except Exception : <EOL> pass <EOL> def fake_str ( self ) : <EOL> return str ( self . message ) <EOL> def fake_unicode ( self ) : <EOL> return six . text_type ( self . message ) <EOL> cls . __init__ = fake_init_exception <EOL> cls . __str__ = fake_str <EOL> cls . __unicode__ = fake_unicode <EOL> cls . silence_logging = True <EOL> return cls ( status_code , msg ) <EOL>", "answer": "def data ( TEST ) :"}, {"prompt": "<s> from __future__ import absolute_import , division , print_function <EOL> INCLUDES = \"\"\"<STR_LIT>\"\"\" <EOL> TYPES = \"\"\"<STR_LIT>\"\"\" <EOL> FUNCTIONS = \"\"\"<STR_LIT>\"\"\" <EOL> MACROS = \"\"\"<STR_LIT>\"\"\" <EOL>", "answer": "CUSTOMIZATIONS = \"\"\"<STR_LIT>\"\"\" "}, {"prompt": "<s> from PyQt4 import QtGui , QtCore <EOL> from PyQt4 . QtCore import Qt <EOL> import re <EOL> class Find ( QtGui . QDialog ) : <EOL> def __init__ ( self , parent = None ) : <EOL> QtGui . QDialog . __init__ ( self , parent ) <EOL> self . parent = parent <EOL> self . lastStart = <NUM_LIT:0> <EOL> self . initUI ( ) <EOL> def initUI ( self ) : <EOL> findButton = QtGui . QPushButton ( \"<STR_LIT>\" , self ) <EOL>", "answer": "findButton . clicked . connect ( self . find )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import os <EOL> import sys <EOL> import errno <EOL> import shutil <EOL> import tempfile <EOL> import unittest <EOL> import logging <EOL> from ganeti import utils <EOL> import testutils <EOL> tempfile . TMP_MAX = <NUM_LIT:3> <EOL> class TestResetTempfileModule ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . tmpdir = tempfile . mkdtemp ( ) <EOL> def tearDown ( self ) : <EOL> shutil . rmtree ( self . tmpdir ) <EOL> def testNoReset ( self ) : <EOL> if ( ( sys . hexversion >= <NUM_LIT> and sys . hexversion < <NUM_LIT> ) or <EOL> sys . hexversion >= <NUM_LIT> ) : <EOL> return <EOL> if ( hasattr ( tempfile . _RandomNameSequence , \"<STR_LIT>\" ) and <EOL> type ( tempfile . _RandomNameSequence . rng ) == property ) : <EOL> return <EOL> self . _Test ( False ) <EOL> def testReset ( self ) : <EOL> self . _Test ( True ) <EOL> def _Test ( self , reset ) : <EOL> self . failIf ( tempfile . TMP_MAX > <NUM_LIT:10> ) <EOL> ( fd , _ ) = tempfile . mkstemp ( dir = self . tmpdir , prefix = \"<STR_LIT>\" , suffix = \"<STR_LIT>\" ) <EOL> os . close ( fd ) <EOL> ( notify_read , notify_write ) = os . pipe ( ) <EOL> pid = os . fork ( ) <EOL> if pid == <NUM_LIT:0> : <EOL> try : <EOL> try : <EOL> if reset : <EOL> utils . ResetTempfileModule ( ) <EOL> os . close ( notify_write ) <EOL> os . read ( notify_read , <NUM_LIT:1> ) <EOL> try : <EOL> ( _ , path ) = tempfile . mkstemp ( dir = self . tmpdir , <EOL> prefix = \"<STR_LIT>\" , suffix = \"<STR_LIT>\" ) <EOL> except EnvironmentError , err : <EOL> if err . errno == errno . EEXIST : <EOL> os . _exit ( <NUM_LIT:2> ) <EOL> raise <EOL> logging . debug ( \"<STR_LIT>\" , path ) <EOL> os . _exit ( <NUM_LIT:0> ) <EOL> except Exception : <EOL> logging . exception ( \"<STR_LIT>\" ) <EOL> finally : <EOL> os . _exit ( <NUM_LIT:1> ) <EOL>", "answer": "os . close ( notify_read )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from . . helpers import to_python <EOL> from pprint import pprint <EOL> import sys <EOL> if sys . version_info > ( <NUM_LIT:3> , <NUM_LIT:0> ) : <EOL> from urllib . parse import quote <EOL> else : <EOL> from urllib import quote <EOL> class BaseResource ( object ) : <EOL> _strs = [ ] <EOL> _ints = [ ] <EOL> _dates = [ ] <EOL> _bools = [ ] <EOL> _dicts = [ ] <EOL> _map = { } <EOL> _arrays = { } <EOL> _pks = [ ] <EOL>", "answer": "order_by = '<STR_LIT:id>'"}, {"prompt": "<s> r\"\"\"<STR_LIT>\"\"\" <EOL> __version__ = '<STR_LIT>' <EOL> __all__ = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> ] <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import warnings <EOL> warnings . warn ( '<STR_LIT>' , DeprecationWarning ) <EOL> from simplejson . decoder import JSONDecoder <EOL> from simplejson . encoder import JSONEncoder <EOL> else : <EOL> from decoder import JSONDecoder <EOL> from encoder import JSONEncoder <EOL> _default_encoder = JSONEncoder ( <EOL> skipkeys = False , <EOL> ensure_ascii = True , <EOL> check_circular = True , <EOL> allow_nan = True , <EOL> indent = None , <EOL> separators = None , <EOL> encoding = '<STR_LIT:utf-8>' , <EOL> default = None , <EOL> ) <EOL> def dump ( obj , fp , skipkeys = False , ensure_ascii = True , check_circular = True , <EOL> allow_nan = True , cls = None , indent = None , separators = None , <EOL> encoding = '<STR_LIT:utf-8>' , default = None , ** kw ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ( skipkeys is False and ensure_ascii is True and <EOL> check_circular is True and allow_nan is True and <EOL> cls is None and indent is None and separators is None and <EOL> encoding == '<STR_LIT:utf-8>' and default is None and not kw ) : <EOL> iterable = _default_encoder . iterencode ( obj ) <EOL> else : <EOL> if cls is None : <EOL> cls = JSONEncoder <EOL> iterable = cls ( skipkeys = skipkeys , ensure_ascii = ensure_ascii , <EOL> check_circular = check_circular , allow_nan = allow_nan , indent = indent , <EOL> separators = separators , encoding = encoding , <EOL> default = default , ** kw ) . iterencode ( obj ) <EOL> for chunk in iterable : <EOL> fp . write ( chunk ) <EOL> def dumps ( obj , skipkeys = False , ensure_ascii = True , check_circular = True , <EOL> allow_nan = True , cls = None , indent = None , separators = None , <EOL> encoding = '<STR_LIT:utf-8>' , default = None , ** kw ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if ( skipkeys is False and ensure_ascii is True and <EOL> check_circular is True and allow_nan is True and <EOL> cls is None and indent is None and separators is None and <EOL> encoding == '<STR_LIT:utf-8>' and default is None and not kw ) : <EOL> return _default_encoder . encode ( obj ) <EOL> if cls is None : <EOL> cls = JSONEncoder <EOL> return cls ( <EOL> skipkeys = skipkeys , ensure_ascii = ensure_ascii , <EOL> check_circular = check_circular , allow_nan = allow_nan , indent = indent , <EOL> separators = separators , encoding = encoding , default = default , <EOL> ** kw ) . encode ( obj ) <EOL> _default_decoder = JSONDecoder ( encoding = None , object_hook = None ) <EOL> def load ( fp , encoding = None , cls = None , object_hook = None , parse_float = None , <EOL>", "answer": "parse_int = None , parse_constant = None , ** kw ) :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import unittest <EOL> import logging <EOL> from thespian . actors import ActorSystem <EOL>", "answer": "def simpleActorTestLogging ( ) :"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Intangible ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> import struct <EOL> import ctypes <EOL> import os <EOL> import windows <EOL> import windows . utils as utils <EOL> from . native_exec import simple_x86 as x86 <EOL> from . native_exec import simple_x64 as x64 <EOL> from windows . native_exec . nativeutils import GetProcAddress64 , GetProcAddress32 <EOL> from windows . dbgprint import dbgprint <EOL> def perform_manual_getproc_loadlib_32 ( target , dll_name ) : <EOL> dll = \"<STR_LIT>\" . encode ( \"<STR_LIT>\" ) <EOL> api = \"<STR_LIT>\" <EOL> dll_to_load = dll_name + \"<STR_LIT:\\x00>\" <EOL> RemoteManualLoadLibray = x86 . MultipleInstr ( ) <EOL> code = RemoteManualLoadLibray <EOL> code += x86 . Mov ( \"<STR_LIT>\" , x86 . mem ( \"<STR_LIT>\" ) ) <EOL> code += x86 . Push ( x86 . mem ( \"<STR_LIT>\" ) ) <EOL> code += x86 . Push ( x86 . mem ( \"<STR_LIT>\" ) ) <EOL> code += x86 . Call ( \"<STR_LIT>\" ) <EOL> code += x86 . Push ( x86 . mem ( \"<STR_LIT>\" ) ) <EOL> code += x86 . Call ( \"<STR_LIT>\" ) <EOL> code += x86 . Pop ( \"<STR_LIT>\" ) <EOL> code += x86 . Pop ( \"<STR_LIT>\" ) <EOL> code += x86 . Ret ( ) <EOL> RemoteManualLoadLibray += GetProcAddress32 <EOL> with target . allocated_memory ( <NUM_LIT> ) as addr : <EOL> addr2 = addr + len ( dll ) <EOL> addr3 = addr2 + len ( api ) <EOL> addr4 = addr3 + len ( dll_to_load ) <EOL> target . write_memory ( addr , dll ) <EOL> target . write_memory ( addr2 , api ) <EOL> target . write_memory ( addr3 , dll_to_load ) <EOL> target . write_qword ( addr4 , addr ) <EOL> target . write_qword ( addr4 + <NUM_LIT:4> , addr2 ) <EOL> target . write_qword ( addr4 + <NUM_LIT> , addr3 ) <EOL> t = target . execute ( RemoteManualLoadLibray . get_code ( ) , addr4 ) <EOL> t . wait ( ) <EOL> return True <EOL> def perform_manual_getproc_loadlib_64 ( target , dll_name ) : <EOL> dll = \"<STR_LIT>\" . encode ( \"<STR_LIT>\" ) <EOL> api = \"<STR_LIT>\" <EOL> dll_to_load = dll_name + \"<STR_LIT:\\x00>\" <EOL> RemoteManualLoadLibray = x64 . MultipleInstr ( ) <EOL> code = RemoteManualLoadLibray <EOL> code += x64 . Mov ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> code += x64 . Mov ( \"<STR_LIT>\" , x64 . mem ( \"<STR_LIT>\" ) ) <EOL> code += x64 . Mov ( \"<STR_LIT>\" , x64 . mem ( \"<STR_LIT>\" ) ) <EOL> code += x64 . Call ( \"<STR_LIT>\" ) <EOL> code += x64 . Mov ( \"<STR_LIT>\" , x64 . mem ( \"<STR_LIT>\" ) ) <EOL> code += x64 . Push ( \"<STR_LIT>\" ) <EOL> code += x64 . Push ( \"<STR_LIT>\" ) <EOL> code += x64 . Push ( \"<STR_LIT>\" ) <EOL> code += x64 . Call ( \"<STR_LIT>\" ) <EOL> code += x64 . Pop ( \"<STR_LIT>\" ) <EOL> code += x64 . Pop ( \"<STR_LIT>\" ) <EOL> code += x64 . Pop ( \"<STR_LIT>\" ) <EOL> code += x64 . Ret ( ) <EOL> RemoteManualLoadLibray += GetProcAddress64 <EOL> with target . allocated_memory ( <NUM_LIT> ) as addr : <EOL> addr2 = addr + len ( dll ) <EOL> addr3 = addr2 + len ( api ) <EOL> addr4 = addr3 + len ( dll_to_load ) <EOL> target . write_memory ( addr , dll ) <EOL> target . write_memory ( addr2 , api ) <EOL> target . write_memory ( addr3 , dll_to_load ) <EOL> target . write_qword ( addr4 , addr ) <EOL> target . write_qword ( addr4 + <NUM_LIT:8> , addr2 ) <EOL> target . write_qword ( addr4 + <NUM_LIT> , addr3 ) <EOL> t = target . execute ( RemoteManualLoadLibray . get_code ( ) , addr4 ) <EOL> t . wait ( ) <EOL> return True <EOL> def load_dll_in_remote_process ( target , dll_name ) : <EOL> rpeb = target . peb <EOL> if rpeb . Ldr : <EOL> modules = rpeb . modules <EOL> if any ( mod . name == dll_name for mod in modules ) : <EOL> dbgprint ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return True <EOL> k32 = [ mod for mod in modules if mod . name . lower ( ) == \"<STR_LIT>\" ] <EOL> if k32 : <EOL> k32 = k32 [ <NUM_LIT:0> ] <EOL> try : <EOL> load_libraryA = k32 . pe . exports [ \"<STR_LIT>\" ] <EOL> except KeyError : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> with target . allocated_memory ( <NUM_LIT> ) as addr : <EOL> target . write_memory ( addr , dll_name + \"<STR_LIT:\\x00>\" ) <EOL> t = target . create_thread ( load_libraryA , addr ) <EOL> t . wait ( ) <EOL> dbgprint ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> return True <EOL> if target . bitness == <NUM_LIT:32> : <EOL> return perform_manual_getproc_loadlib_32 ( target , dll_name ) <EOL> return perform_manual_getproc_loadlib_64 ( target , dll_name ) <EOL> python_function_32_bits = { } <EOL> def generate_python_exec_shellcode_32 ( target , PYCODE_ADDR , PyDll ) : <EOL> if not python_function_32_bits : <EOL> pymodule = [ mod for mod in target . peb . modules if mod . name == PyDll ] [ <NUM_LIT:0> ] <EOL> Py_exports = pymodule . pe . exports <EOL> python_function_32_bits [ \"<STR_LIT>\" ] = Py_exports [ \"<STR_LIT>\" ] <EOL> python_function_32_bits [ \"<STR_LIT>\" ] = Py_exports [ \"<STR_LIT>\" ] <EOL> python_function_32_bits [ \"<STR_LIT>\" ] = Py_exports [ \"<STR_LIT>\" ] <EOL> python_function_32_bits [ \"<STR_LIT>\" ] = Py_exports [ \"<STR_LIT>\" ] <EOL> python_function_32_bits [ \"<STR_LIT>\" ] = Py_exports [ \"<STR_LIT>\" ] <EOL> python_function_32_bits [ \"<STR_LIT>\" ] = Py_exports [ \"<STR_LIT>\" ] <EOL> python_function_32_bits [ \"<STR_LIT>\" ] = Py_exports [ \"<STR_LIT>\" ] <EOL> Py_exports = python_function_32_bits <EOL> PyEval_InitThreads = Py_exports [ \"<STR_LIT>\" ] <EOL> Py_IsInitialized = Py_exports [ \"<STR_LIT>\" ] <EOL> PyGILState_Release = Py_exports [ \"<STR_LIT>\" ] <EOL> PyGILState_Ensure = Py_exports [ \"<STR_LIT>\" ] <EOL> PyEval_SaveThread = Py_exports [ \"<STR_LIT>\" ] <EOL> Py_Initialize = Py_exports [ \"<STR_LIT>\" ] <EOL> PyRun_SimpleString = Py_exports [ \"<STR_LIT>\" ] <EOL> code = x86 . MultipleInstr ( ) <EOL> code += x86 . Mov ( '<STR_LIT>' , Py_IsInitialized ) <EOL> code += x86 . Call ( '<STR_LIT>' ) <EOL> code += x86 . Mov ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> code += x86 . Cmp ( \"<STR_LIT>\" , <NUM_LIT:0> ) <EOL> code += x86 . Jnz ( \"<STR_LIT>\" ) <EOL> code += x86 . Mov ( '<STR_LIT>' , PyEval_InitThreads ) <EOL> code += x86 . Call ( '<STR_LIT>' ) <EOL>", "answer": "code += x86 . Mov ( '<STR_LIT>' , Py_Initialize )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import base64 <EOL> import json <EOL> import M2Crypto <EOL> import os <EOL> import pickle <EOL> import random <EOL> import subprocess <EOL> import sys <EOL> import time <EOL> import uuid <EOL> from nova import context as nova_context <EOL> from nova import db <EOL> from nova import exception <EOL> from nova import flags <EOL> from nova import ipv6 <EOL> from nova import log as logging <EOL> from nova import utils <EOL> from nova . compute import power_state <EOL> from nova . virt import driver <EOL> from nova . virt . xenapi . network_utils import NetworkHelper <EOL> from nova . virt . xenapi . vm_utils import VMHelper <EOL> from nova . virt . xenapi . vm_utils import ImageType <EOL> XenAPI = None <EOL> LOG = logging . getLogger ( \"<STR_LIT>\" ) <EOL> FLAGS = flags . FLAGS <EOL> flags . DEFINE_integer ( '<STR_LIT>' , <NUM_LIT> , <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> flags . DEFINE_string ( '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> def cmp_version ( a , b ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> a = a . split ( '<STR_LIT:.>' ) <EOL> b = b . split ( '<STR_LIT:.>' ) <EOL> for va , vb in zip ( a , b ) : <EOL> ret = int ( va ) - int ( vb ) <EOL> if ret : <EOL> return ret <EOL> return len ( a ) - len ( b ) <EOL> class VMOps ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , session ) : <EOL> self . XenAPI = session . get_imported_xenapi ( ) <EOL> self . _session = session <EOL> self . poll_rescue_last_ran = None <EOL> VMHelper . XenAPI = self . XenAPI <EOL> self . vif_driver = utils . import_object ( FLAGS . xenapi_vif_driver ) <EOL> def list_instances ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm_refs = [ ] <EOL> for vm_ref in self . _session . get_xenapi ( ) . VM . get_all ( ) : <EOL> vm_rec = self . _session . get_xenapi ( ) . VM . get_record ( vm_ref ) <EOL> if not vm_rec [ \"<STR_LIT>\" ] and not vm_rec [ \"<STR_LIT>\" ] : <EOL> vm_refs . append ( vm_rec [ \"<STR_LIT>\" ] ) <EOL> return vm_refs <EOL> def list_instances_detail ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> instance_infos = [ ] <EOL> for vm_ref in self . _session . get_xenapi ( ) . VM . get_all ( ) : <EOL> vm_rec = self . _session . get_xenapi ( ) . VM . get_record ( vm_ref ) <EOL> if not vm_rec [ \"<STR_LIT>\" ] and not vm_rec [ \"<STR_LIT>\" ] : <EOL> name = vm_rec [ \"<STR_LIT>\" ] <EOL> openstack_format = VMHelper . compile_info ( vm_rec ) <EOL> state = openstack_format [ '<STR_LIT:state>' ] <EOL> instance_info = driver . InstanceInfo ( name , state ) <EOL> instance_infos . append ( instance_info ) <EOL> return instance_infos <EOL> def revert_migration ( self , instance ) : <EOL> vm_ref = VMHelper . lookup ( self . _session , instance . name ) <EOL> self . _start ( instance , vm_ref ) <EOL> def finish_migration ( self , context , instance , disk_info , network_info , <EOL> resize_instance ) : <EOL> vdi_uuid = self . link_disks ( instance , disk_info [ '<STR_LIT>' ] , <EOL> disk_info [ '<STR_LIT>' ] ) <EOL> vm_ref = self . _create_vm ( context , instance , <EOL> [ dict ( vdi_type = '<STR_LIT>' , vdi_uuid = vdi_uuid ) ] , <EOL> network_info ) <EOL> if resize_instance : <EOL> self . resize_instance ( instance , vdi_uuid ) <EOL> self . _start ( instance , vm_ref = vm_ref ) <EOL> def _start ( self , instance , vm_ref = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not vm_ref : <EOL> vm_ref = VMHelper . lookup ( self . _session , instance . name ) <EOL> if vm_ref is None : <EOL> raise Exception ( _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) % instance . id ) <EOL> LOG . debug ( _ ( \"<STR_LIT>\" ) , instance . name ) <EOL> self . _session . call_xenapi ( '<STR_LIT>' , vm_ref , False , False ) <EOL> def _create_disks ( self , context , instance ) : <EOL> disk_image_type = VMHelper . determine_disk_image_type ( instance , context ) <EOL> vdis = VMHelper . fetch_image ( context , self . _session , <EOL> instance , instance . image_ref , <EOL> instance . user_id , instance . project_id , <EOL> disk_image_type ) <EOL> for vdi in vdis : <EOL> if vdi [ \"<STR_LIT>\" ] == \"<STR_LIT>\" : <EOL> self . resize_instance ( instance , vdi [ \"<STR_LIT>\" ] ) <EOL> return vdis <EOL> def spawn ( self , context , instance , network_info ) : <EOL> vdis = None <EOL> try : <EOL> vdis = self . _create_disks ( context , instance ) <EOL> vm_ref = self . _create_vm ( context , instance , vdis , network_info ) <EOL> self . _spawn ( instance , vm_ref ) <EOL> except ( self . XenAPI . Failure , OSError , IOError ) as spawn_error : <EOL> LOG . exception ( _ ( \"<STR_LIT>\" ) , <EOL> instance . id , exc_info = sys . exc_info ( ) ) <EOL> LOG . debug ( _ ( '<STR_LIT>' ) , <EOL> instance . id ) <EOL> self . _handle_spawn_error ( vdis , spawn_error ) <EOL> raise spawn_error <EOL> def spawn_rescue ( self , context , instance , network_info ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . spawn ( context , instance , network_info ) <EOL> def _create_vm ( self , context , instance , vdis , network_info ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> instance_name = instance . name <EOL> vm_ref = VMHelper . lookup ( self . _session , instance_name ) <EOL> if vm_ref is not None : <EOL> raise exception . InstanceExists ( name = instance_name ) <EOL> if not VMHelper . ensure_free_mem ( self . _session , instance ) : <EOL> raise exception . InsufficientFreeMemory ( uuid = instance . uuid ) <EOL> disk_image_type = VMHelper . determine_disk_image_type ( instance , context ) <EOL> kernel = None <EOL> ramdisk = None <EOL> try : <EOL> if instance . kernel_id : <EOL> kernel = VMHelper . fetch_image ( context , self . _session , <EOL> instance , instance . kernel_id , instance . user_id , <EOL> instance . project_id , ImageType . KERNEL ) [ <NUM_LIT:0> ] <EOL> if instance . ramdisk_id : <EOL> ramdisk = VMHelper . fetch_image ( context , self . _session , <EOL> instance , instance . ramdisk_id , instance . user_id , <EOL> instance . project_id , ImageType . RAMDISK ) [ <NUM_LIT:0> ] <EOL> first_vdi_ref = None <EOL> for vdi in vdis : <EOL> if vdi . get ( '<STR_LIT>' ) != '<STR_LIT>' : <EOL> first_vdi_ref = self . _session . call_xenapi ( <EOL> '<STR_LIT>' , vdi [ '<STR_LIT>' ] ) <EOL> vm_mode = instance . vm_mode and instance . vm_mode . lower ( ) <EOL> if vm_mode == '<STR_LIT>' : <EOL> use_pv_kernel = True <EOL> elif vm_mode in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> use_pv_kernel = False <EOL> vm_mode = '<STR_LIT>' <EOL> else : <EOL> use_pv_kernel = VMHelper . determine_is_pv ( self . _session , <EOL> instance . id , first_vdi_ref , disk_image_type , <EOL> instance . os_type ) <EOL> vm_mode = use_pv_kernel and '<STR_LIT>' or '<STR_LIT>' <EOL> if instance . vm_mode != vm_mode : <EOL> db . instance_update ( nova_context . get_admin_context ( ) , <EOL> instance [ '<STR_LIT:id>' ] , { '<STR_LIT>' : vm_mode } ) <EOL> vm_ref = VMHelper . create_vm ( self . _session , instance , <EOL> kernel and kernel . get ( '<STR_LIT:file>' , None ) or None , <EOL> ramdisk and ramdisk . get ( '<STR_LIT:file>' , None ) or None , <EOL> use_pv_kernel ) <EOL> except ( self . XenAPI . Failure , OSError , IOError ) as vm_create_error : <EOL> LOG . exception ( _ ( \"<STR_LIT>\" + <EOL> \"<STR_LIT>\" ) , <EOL> instance . id , exc_info = sys . exc_info ( ) ) <EOL> last_arg = None <EOL> resources = [ ] <EOL> if vm_create_error . args : <EOL> last_arg = vm_create_error . args [ - <NUM_LIT:1> ] <EOL> if isinstance ( last_arg , list ) : <EOL> resources = last_arg <EOL> else : <EOL> vm_create_error . args = vm_create_error . args + ( resources , ) <EOL> if kernel : <EOL> resources . append ( kernel ) <EOL> if ramdisk : <EOL> resources . append ( ramdisk ) <EOL> raise vm_create_error <EOL> self . _attach_disks ( instance , disk_image_type , vm_ref , first_vdi_ref , <EOL> vdis ) <EOL> if FLAGS . flat_injected : <EOL> VMHelper . preconfigure_instance ( self . _session , instance , <EOL> first_vdi_ref , network_info ) <EOL> self . create_vifs ( vm_ref , instance , network_info ) <EOL> self . inject_network_info ( instance , network_info , vm_ref ) <EOL> self . inject_hostname ( instance , vm_ref , instance [ '<STR_LIT>' ] ) <EOL> return vm_ref <EOL> def _attach_disks ( self , instance , disk_image_type , vm_ref , first_vdi_ref , <EOL> vdis ) : <EOL> userdevice = <NUM_LIT:0> <EOL> if disk_image_type == ImageType . DISK_ISO : <EOL> LOG . debug ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> cd_vdi_ref = first_vdi_ref <EOL> first_vdi_ref = VMHelper . fetch_blank_disk ( session = self . _session , <EOL> instance_type_id = instance . instance_type_id ) <EOL> VMHelper . create_vbd ( session = self . _session , vm_ref = vm_ref , <EOL> vdi_ref = first_vdi_ref , userdevice = userdevice , bootable = False ) <EOL> userdevice = <NUM_LIT:2> <EOL> VMHelper . create_cd_vbd ( session = self . _session , vm_ref = vm_ref , <EOL> vdi_ref = cd_vdi_ref , userdevice = userdevice , bootable = True ) <EOL> userdevice += <NUM_LIT:1> <EOL> else : <EOL> VMHelper . create_vbd ( session = self . _session , vm_ref = vm_ref , <EOL> vdi_ref = first_vdi_ref , userdevice = userdevice , bootable = True ) <EOL> userdevice = <NUM_LIT:2> <EOL> for vdi in vdis [ <NUM_LIT:1> : ] : <EOL> vdi_ref = self . _session . call_xenapi ( '<STR_LIT>' , <EOL> vdi [ '<STR_LIT>' ] ) <EOL> VMHelper . create_vbd ( session = self . _session , vm_ref = vm_ref , <EOL> vdi_ref = vdi_ref , userdevice = userdevice , <EOL> bootable = False ) <EOL> userdevice += <NUM_LIT:1> <EOL> def _spawn ( self , instance , vm_ref ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> LOG . debug ( _ ( '<STR_LIT>' ) , vm_ref ) <EOL> self . _start ( instance , vm_ref ) <EOL> instance_name = instance . name <EOL> LOG . info ( _ ( '<STR_LIT>' ) <EOL> % locals ( ) ) <EOL> ctx = nova_context . get_admin_context ( ) <EOL> agent_build = db . agent_build_get_by_triple ( ctx , '<STR_LIT>' , <EOL> instance . os_type , instance . architecture ) <EOL> if agent_build : <EOL> LOG . info ( _ ( '<STR_LIT>' + '<STR_LIT>' ) % agent_build ) <EOL> else : <EOL> LOG . info ( _ ( '<STR_LIT>' + '<STR_LIT>' ) % { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : instance . os_type , <EOL> '<STR_LIT>' : instance . architecture } ) <EOL> def _check_agent_version ( ) : <EOL> LOG . debug ( _ ( \"<STR_LIT>\" ) ) <EOL> if instance . os_type == '<STR_LIT>' : <EOL> version = self . get_agent_version ( instance , <EOL> timeout = FLAGS . windows_version_timeout ) <EOL> else : <EOL> version = self . get_agent_version ( instance ) <EOL> if not version : <EOL> return <EOL> LOG . info ( _ ( '<STR_LIT>' ) % version ) <EOL> if not agent_build : <EOL> return <EOL> if cmp_version ( version , agent_build [ '<STR_LIT:version>' ] ) < <NUM_LIT:0> : <EOL> LOG . info ( _ ( '<STR_LIT>' ) % agent_build [ '<STR_LIT:version>' ] ) <EOL> self . agent_update ( instance , agent_build [ '<STR_LIT:url>' ] , <EOL> agent_build [ '<STR_LIT>' ] ) <EOL> def _inject_files ( ) : <EOL> injected_files = instance . injected_files <EOL> if injected_files : <EOL> if isinstance ( injected_files , basestring ) : <EOL> try : <EOL> injected_files = json . loads ( injected_files ) <EOL> except ValueError : <EOL> LOG . exception ( <EOL> _ ( \"<STR_LIT>\" ) <EOL> % injected_files ) <EOL> injected_files = [ ] <EOL> for path , contents in instance . injected_files : <EOL> LOG . debug ( _ ( \"<STR_LIT>\" ) % path ) <EOL> self . inject_file ( instance , path , contents ) <EOL> def _set_admin_password ( ) : <EOL> admin_password = instance . admin_pass <EOL> if admin_password : <EOL> LOG . debug ( _ ( \"<STR_LIT>\" ) ) <EOL> self . set_admin_password ( instance , admin_password ) <EOL> def _reset_network ( ) : <EOL> LOG . debug ( _ ( \"<STR_LIT>\" ) ) <EOL> self . reset_network ( instance , vm_ref ) <EOL> timer = utils . LoopingCall ( f = None ) <EOL> def _wait_for_boot ( ) : <EOL> try : <EOL> state = self . get_info ( instance_name ) [ '<STR_LIT:state>' ] <EOL> if state == power_state . RUNNING : <EOL> LOG . debug ( _ ( '<STR_LIT>' ) , instance_name ) <EOL> timer . stop ( ) <EOL> _check_agent_version ( ) <EOL> _inject_files ( ) <EOL> _set_admin_password ( ) <EOL> _reset_network ( ) <EOL> return True <EOL> except Exception , exc : <EOL> LOG . warn ( exc ) <EOL> LOG . exception ( _ ( '<STR_LIT>' ) , instance_name ) <EOL> timer . stop ( ) <EOL> return False <EOL> timer . f = _wait_for_boot <EOL> return timer . start ( interval = <NUM_LIT:0.5> , now = True ) <EOL> def _handle_spawn_error ( self , vdis , spawn_error ) : <EOL> resources = [ ] <EOL> if spawn_error . args : <EOL> last_arg = spawn_error . args [ - <NUM_LIT:1> ] <EOL> resources = last_arg <EOL> if vdis : <EOL> for vdi in vdis : <EOL> resources . append ( dict ( vdi_type = vdi [ '<STR_LIT>' ] , <EOL> vdi_uuid = vdi [ '<STR_LIT>' ] , <EOL> file = None ) ) <EOL> LOG . debug ( _ ( \"<STR_LIT>\" ) , resources ) <EOL> kernel_file = None <EOL> ramdisk_file = None <EOL> for item in resources : <EOL> vdi_type = item [ '<STR_LIT>' ] <EOL> vdi_to_remove = item [ '<STR_LIT>' ] <EOL> if vdi_to_remove : <EOL> try : <EOL> vdi_ref = self . _session . call_xenapi ( '<STR_LIT>' , <EOL> vdi_to_remove ) <EOL> LOG . debug ( _ ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) , locals ( ) ) <EOL> VMHelper . destroy_vdi ( self . _session , vdi_ref ) <EOL> except self . XenAPI . Failure : <EOL> LOG . debug ( _ ( \"<STR_LIT>\" ) , vdi_to_remove ) <EOL> if item [ '<STR_LIT:file>' ] : <EOL> if vdi_type == ImageType . KERNEL_STR : <EOL> kernel_file = item [ '<STR_LIT:file>' ] <EOL> elif vdi_type == ImageType . RAMDISK_STR : <EOL> ramdisk_file = item [ '<STR_LIT:file>' ] <EOL> if kernel_file or ramdisk_file : <EOL> LOG . debug ( _ ( \"<STR_LIT>\" ) ) <EOL> self . _destroy_kernel_ramdisk_plugin_call ( kernel_file , <EOL> ramdisk_file ) <EOL> def _get_vm_opaque_ref ( self , instance_or_vm ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( instance_or_vm , basestring ) : <EOL> obj = None <EOL> try : <EOL> obj = self . _session . get_xenapi ( ) . VM . get_uuid ( instance_or_vm ) <EOL> return instance_or_vm <EOL> except self . XenAPI . Failure : <EOL> instance_name = instance_or_vm <EOL> elif isinstance ( instance_or_vm , ( int , long ) ) : <EOL> ctx = nova_context . get_admin_context ( ) <EOL> instance_obj = db . instance_get ( ctx , instance_or_vm ) <EOL> instance_name = instance_obj . name <EOL> else : <EOL> instance_name = instance_or_vm . name <EOL> vm_ref = VMHelper . lookup ( self . _session , instance_name ) <EOL> if vm_ref is None : <EOL> raise exception . NotFound ( _ ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) % instance_or_vm ) <EOL> return vm_ref <EOL> def _acquire_bootlock ( self , vm ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _session . call_xenapi ( <EOL> \"<STR_LIT>\" , <EOL> vm , <EOL> { \"<STR_LIT:start>\" : \"<STR_LIT>\" } ) <EOL> def _release_bootlock ( self , vm ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _session . call_xenapi ( <EOL> \"<STR_LIT>\" , <EOL> vm , <EOL> \"<STR_LIT:start>\" ) <EOL> def snapshot ( self , context , instance , image_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> template_vm_ref = None <EOL> try : <EOL> template_vm_ref , template_vdi_uuids = self . _get_snapshot ( instance ) <EOL> VMHelper . upload_image ( context , <EOL> self . _session , instance , template_vdi_uuids , image_id ) <EOL> finally : <EOL> if template_vm_ref : <EOL> self . _destroy ( instance , template_vm_ref , <EOL> shutdown = False , destroy_kernel_ramdisk = False ) <EOL> logging . debug ( _ ( \"<STR_LIT>\" ) , instance ) <EOL> def _get_snapshot ( self , instance ) : <EOL> logging . debug ( _ ( \"<STR_LIT>\" ) , instance ) <EOL> vm_ref = VMHelper . lookup ( self . _session , instance . name ) <EOL> label = \"<STR_LIT>\" % instance . name <EOL> try : <EOL> template_vm_ref , template_vdi_uuids = VMHelper . create_snapshot ( <EOL> self . _session , instance . id , vm_ref , label ) <EOL> return template_vm_ref , template_vdi_uuids <EOL> except self . XenAPI . Failure , exc : <EOL> logging . error ( _ ( \"<STR_LIT>\" ) <EOL> % locals ( ) ) <EOL> return <EOL> def migrate_disk_and_power_off ( self , instance , dest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm_ref = VMHelper . lookup ( self . _session , instance . name ) <EOL> base_copy_uuid = cow_uuid = None <EOL> template_vdi_uuids = template_vm_ref = None <EOL> try : <EOL> template_vm_ref , template_vdi_uuids = self . _get_snapshot ( instance ) <EOL> base_copy_uuid = template_vdi_uuids [ '<STR_LIT:image>' ] <EOL> vdi_ref , vm_vdi_rec = VMHelper . get_vdi_for_vm_safely ( self . _session , vm_ref ) <EOL> cow_uuid = vm_vdi_rec [ '<STR_LIT>' ] <EOL> params = { '<STR_LIT:host>' : dest , <EOL> '<STR_LIT>' : base_copy_uuid , <EOL> '<STR_LIT>' : instance . id , <EOL> '<STR_LIT>' : VMHelper . get_sr_path ( self . _session ) } <EOL> task = self . _session . async_call_plugin ( '<STR_LIT>' , '<STR_LIT>' , <EOL> { '<STR_LIT>' : pickle . dumps ( params ) } ) <EOL> self . _session . wait_for_task ( task , instance . id ) <EOL> self . _shutdown ( instance , vm_ref , hard = False ) <EOL> params = { '<STR_LIT:host>' : dest , <EOL> '<STR_LIT>' : cow_uuid , <EOL> '<STR_LIT>' : instance . id , <EOL> '<STR_LIT>' : VMHelper . get_sr_path ( self . _session ) , } <EOL> task = self . _session . async_call_plugin ( '<STR_LIT>' , '<STR_LIT>' , <EOL> { '<STR_LIT>' : pickle . dumps ( params ) } ) <EOL> self . _session . wait_for_task ( task , instance . id ) <EOL> finally : <EOL> if template_vm_ref : <EOL> self . _destroy ( instance , template_vm_ref , <EOL> shutdown = False , destroy_kernel_ramdisk = False ) <EOL> return { '<STR_LIT>' : base_copy_uuid , '<STR_LIT>' : cow_uuid } <EOL> def link_disks ( self , instance , base_copy_uuid , cow_uuid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> new_base_copy_uuid = str ( uuid . uuid4 ( ) ) <EOL> new_cow_uuid = str ( uuid . uuid4 ( ) ) <EOL> params = { '<STR_LIT>' : instance . id , <EOL> '<STR_LIT>' : base_copy_uuid , <EOL> '<STR_LIT>' : cow_uuid , <EOL> '<STR_LIT>' : new_base_copy_uuid , <EOL> '<STR_LIT>' : new_cow_uuid , <EOL> '<STR_LIT>' : VMHelper . get_sr_path ( self . _session ) , } <EOL> task = self . _session . async_call_plugin ( '<STR_LIT>' , <EOL> '<STR_LIT>' , { '<STR_LIT>' : pickle . dumps ( params ) } ) <EOL> self . _session . wait_for_task ( task , instance . id ) <EOL> VMHelper . scan_default_sr ( self . _session ) <EOL> return new_cow_uuid <EOL> def resize_instance ( self , instance , vdi_uuid ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> new_disk_size = instance . local_gb * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> <EOL> if new_disk_size > <NUM_LIT:0> : <EOL> instance_name = instance . name <EOL> instance_local_gb = instance . local_gb <EOL> LOG . debug ( _ ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) % locals ( ) ) <EOL> vdi_ref = self . _session . call_xenapi ( '<STR_LIT>' , vdi_uuid ) <EOL> self . _session . call_xenapi ( '<STR_LIT>' , vdi_ref , <EOL> str ( new_disk_size ) ) <EOL> LOG . debug ( _ ( \"<STR_LIT>\" ) % ( instance . name ) ) <EOL> def reboot ( self , instance ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm_ref = self . _get_vm_opaque_ref ( instance ) <EOL> task = self . _session . call_xenapi ( '<STR_LIT>' , vm_ref ) <EOL> self . _session . wait_for_task ( task , instance . id ) <EOL> def get_agent_version ( self , instance , timeout = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def _call ( ) : <EOL> transaction_id = str ( uuid . uuid4 ( ) ) <EOL> args = { '<STR_LIT:id>' : transaction_id } <EOL> resp = self . _make_agent_call ( '<STR_LIT:version>' , instance , '<STR_LIT>' , args ) <EOL> if resp [ '<STR_LIT>' ] != '<STR_LIT:0>' : <EOL> LOG . error ( _ ( '<STR_LIT>' ) % <EOL> locals ( ) ) <EOL> return None <EOL> return resp [ '<STR_LIT:message>' ] . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if timeout : <EOL> vm_ref = self . _get_vm_opaque_ref ( instance ) <EOL> vm_rec = self . _session . get_xenapi ( ) . VM . get_record ( vm_ref ) <EOL> domid = vm_rec [ '<STR_LIT>' ] <EOL> expiration = time . time ( ) + timeout <EOL> while time . time ( ) < expiration : <EOL> ret = _call ( ) <EOL> if ret : <EOL> return ret <EOL> vm_rec = self . _session . get_xenapi ( ) . VM . get_record ( vm_ref ) <EOL> if vm_rec [ '<STR_LIT>' ] != domid : <EOL> LOG . info ( _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) % { <EOL> '<STR_LIT>' : domid , <EOL> '<STR_LIT>' : vm_rec [ '<STR_LIT>' ] } ) <EOL> domid = vm_rec [ '<STR_LIT>' ] <EOL> else : <EOL> return _call ( ) <EOL> def agent_update ( self , instance , url , md5sum ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> transaction_id = str ( uuid . uuid4 ( ) ) <EOL> args = { '<STR_LIT:id>' : transaction_id , '<STR_LIT:url>' : url , '<STR_LIT>' : md5sum } <EOL> resp = self . _make_agent_call ( '<STR_LIT>' , instance , '<STR_LIT>' , args ) <EOL> if resp [ '<STR_LIT>' ] != '<STR_LIT:0>' : <EOL> LOG . error ( _ ( '<STR_LIT>' ) % locals ( ) ) <EOL> return None <EOL> return resp [ '<STR_LIT:message>' ] <EOL> def set_admin_password ( self , instance , new_pass ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> key_init_transaction_id = str ( uuid . uuid4 ( ) ) <EOL> dh = SimpleDH ( ) <EOL> key_init_args = { '<STR_LIT:id>' : key_init_transaction_id , <EOL> '<STR_LIT>' : str ( dh . get_public ( ) ) } <EOL> resp = self . _make_agent_call ( '<STR_LIT>' , instance , '<STR_LIT>' , key_init_args ) <EOL> if resp [ '<STR_LIT>' ] != '<STR_LIT>' : <EOL> LOG . error ( _ ( '<STR_LIT>' ) % locals ( ) ) <EOL> return None <EOL> agent_pub = int ( resp [ '<STR_LIT:message>' ] . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> dh . compute_shared ( agent_pub ) <EOL> enc_pass = dh . encrypt ( new_pass + '<STR_LIT:\\n>' ) <EOL> password_transaction_id = str ( uuid . uuid4 ( ) ) <EOL> password_args = { '<STR_LIT:id>' : password_transaction_id , '<STR_LIT>' : enc_pass } <EOL> resp = self . _make_agent_call ( '<STR_LIT:password>' , instance , '<STR_LIT>' , password_args ) <EOL> if resp [ '<STR_LIT>' ] != '<STR_LIT:0>' : <EOL> LOG . error ( _ ( '<STR_LIT>' ) % locals ( ) ) <EOL> return None <EOL> return resp [ '<STR_LIT:message>' ] <EOL> def inject_file ( self , instance , path , contents ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> b64_path = base64 . b64encode ( path ) <EOL> b64_contents = base64 . b64encode ( contents ) <EOL> transaction_id = str ( uuid . uuid4 ( ) ) <EOL> args = { '<STR_LIT:id>' : transaction_id , '<STR_LIT>' : b64_path , <EOL> '<STR_LIT>' : b64_contents } <EOL> resp = self . _make_agent_call ( '<STR_LIT>' , instance , '<STR_LIT>' , args ) <EOL> if resp [ '<STR_LIT>' ] != '<STR_LIT:0>' : <EOL> LOG . error ( _ ( '<STR_LIT>' ) % locals ( ) ) <EOL> return None <EOL> return resp [ '<STR_LIT:message>' ] <EOL> def _shutdown ( self , instance , vm_ref , hard = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> state = self . get_info ( instance [ '<STR_LIT:name>' ] ) [ '<STR_LIT:state>' ] <EOL> if state == power_state . SHUTDOWN : <EOL> instance_name = instance . name <EOL> LOG . warn ( _ ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) % locals ( ) ) <EOL> return <EOL> instance_id = instance . id <EOL> LOG . debug ( _ ( \"<STR_LIT>\" ) <EOL> % locals ( ) ) <EOL> try : <EOL> task = None <EOL> if hard : <EOL> task = self . _session . call_xenapi ( \"<STR_LIT>\" , <EOL> vm_ref ) <EOL> else : <EOL> task = self . _session . call_xenapi ( \"<STR_LIT>\" , <EOL> vm_ref ) <EOL> self . _session . wait_for_task ( task , instance . id ) <EOL> except self . XenAPI . Failure , exc : <EOL> LOG . exception ( exc ) <EOL> def _find_rescue_vbd_ref ( self , vm_ref , rescue_vm_ref ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vbd_ref = self . _session . get_xenapi ( ) . VM . get_VBDs ( vm_ref ) [ <NUM_LIT:1> ] <EOL> vdi_ref = self . _session . get_xenapi ( ) . VBD . get_record ( vbd_ref ) [ \"<STR_LIT>\" ] <EOL> return VMHelper . create_vbd ( self . _session , rescue_vm_ref , vdi_ref , <NUM_LIT:1> , <EOL> False ) <EOL> def _shutdown_rescue ( self , rescue_vm_ref ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _session . call_xenapi ( \"<STR_LIT>\" , rescue_vm_ref ) <EOL> def _destroy_vdis ( self , instance , vm_ref ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> instance_id = instance . id <EOL> LOG . debug ( _ ( \"<STR_LIT>\" ) <EOL> % locals ( ) ) <EOL> vdi_refs = VMHelper . lookup_vm_vdis ( self . _session , vm_ref ) <EOL> if not vdi_refs : <EOL> return <EOL> for vdi_ref in vdi_refs : <EOL> try : <EOL> task = self . _session . call_xenapi ( '<STR_LIT>' , vdi_ref ) <EOL> self . _session . wait_for_task ( task , instance . id ) <EOL> except self . XenAPI . Failure , exc : <EOL> LOG . exception ( exc ) <EOL> def _destroy_rescue_vdis ( self , rescue_vm_ref ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vdi_refs = VMHelper . lookup_vm_vdis ( self . _session , rescue_vm_ref ) <EOL> for vdi_ref in vdi_refs : <EOL> try : <EOL> self . _session . call_xenapi ( \"<STR_LIT>\" , vdi_ref ) <EOL> except self . XenAPI . Failure : <EOL> continue <EOL> def _destroy_rescue_vbds ( self , rescue_vm_ref ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vbd_refs = self . _session . get_xenapi ( ) . VM . get_VBDs ( rescue_vm_ref ) <EOL> for vbd_ref in vbd_refs : <EOL> vbd_rec = self . _session . get_xenapi ( ) . VBD . get_record ( vbd_ref ) <EOL> if vbd_rec . get ( \"<STR_LIT>\" , None ) == \"<STR_LIT:1>\" : <EOL> VMHelper . unplug_vbd ( self . _session , vbd_ref ) <EOL> VMHelper . destroy_vbd ( self . _session , vbd_ref ) <EOL> def _destroy_kernel_ramdisk_plugin_call ( self , kernel , ramdisk ) : <EOL> args = { } <EOL> if kernel : <EOL> args [ '<STR_LIT>' ] = kernel <EOL> if ramdisk : <EOL> args [ '<STR_LIT>' ] = ramdisk <EOL> task = self . _session . async_call_plugin ( <EOL> '<STR_LIT>' , '<STR_LIT>' , args ) <EOL> self . _session . wait_for_task ( task ) <EOL> def _destroy_kernel_ramdisk ( self , instance , vm_ref ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> instance_id = instance . id <EOL> if not instance . kernel_id and not instance . ramdisk_id : <EOL> LOG . debug ( _ ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) % locals ( ) ) <EOL> return <EOL> if not ( instance . kernel_id and instance . ramdisk_id ) : <EOL> raise exception . InstanceUnacceptable ( instance_id = instance_id , <EOL> reason = _ ( \"<STR_LIT>\" ) ) <EOL> ( kernel , ramdisk ) = VMHelper . lookup_kernel_ramdisk ( self . _session , <EOL> vm_ref ) <EOL> self . _destroy_kernel_ramdisk_plugin_call ( kernel , ramdisk ) <EOL> LOG . debug ( _ ( \"<STR_LIT>\" ) ) <EOL> def _destroy_vm ( self , instance , vm_ref ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> instance_id = instance . id <EOL> try : <EOL> task = self . _session . call_xenapi ( '<STR_LIT>' , vm_ref ) <EOL> self . _session . wait_for_task ( task , instance_id ) <EOL> except self . XenAPI . Failure , exc : <EOL> LOG . exception ( exc ) <EOL> LOG . debug ( _ ( \"<STR_LIT>\" ) % locals ( ) ) <EOL> def _destroy_rescue_instance ( self , rescue_vm_ref ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _destroy_rescue_vbds ( rescue_vm_ref ) <EOL> self . _shutdown_rescue ( rescue_vm_ref ) <EOL> self . _destroy_rescue_vdis ( rescue_vm_ref ) <EOL> self . _session . call_xenapi ( \"<STR_LIT>\" , rescue_vm_ref ) <EOL> def destroy ( self , instance , network_info ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> instance_id = instance . id <EOL> LOG . info ( _ ( \"<STR_LIT>\" ) % locals ( ) ) <EOL> vm_ref = VMHelper . lookup ( self . _session , instance . name ) <EOL> return self . _destroy ( instance , vm_ref , network_info , shutdown = True ) <EOL> def _destroy ( self , instance , vm_ref , network_info = None , shutdown = True , <EOL> destroy_kernel_ramdisk = True ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if vm_ref is None : <EOL> LOG . warning ( _ ( \"<STR_LIT>\" ) ) <EOL> return <EOL> if shutdown : <EOL> self . _shutdown ( instance , vm_ref ) <EOL> self . _destroy_vdis ( instance , vm_ref ) <EOL> if destroy_kernel_ramdisk : <EOL> self . _destroy_kernel_ramdisk ( instance , vm_ref ) <EOL> self . _destroy_vm ( instance , vm_ref ) <EOL> if network_info : <EOL> for ( network , mapping ) in network_info : <EOL> self . vif_driver . unplug ( instance , network , mapping ) <EOL> def _wait_with_callback ( self , instance_id , task , callback ) : <EOL> ret = None <EOL> try : <EOL> ret = self . _session . wait_for_task ( task , instance_id ) <EOL> except self . XenAPI . Failure , exc : <EOL> LOG . exception ( exc ) <EOL> callback ( ret ) <EOL> def pause ( self , instance , callback ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm_ref = self . _get_vm_opaque_ref ( instance ) <EOL> task = self . _session . call_xenapi ( '<STR_LIT>' , vm_ref ) <EOL> self . _wait_with_callback ( instance . id , task , callback ) <EOL> def unpause ( self , instance , callback ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm_ref = self . _get_vm_opaque_ref ( instance ) <EOL> task = self . _session . call_xenapi ( '<STR_LIT>' , vm_ref ) <EOL> self . _wait_with_callback ( instance . id , task , callback ) <EOL> def suspend ( self , instance , callback ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm_ref = self . _get_vm_opaque_ref ( instance ) <EOL> task = self . _session . call_xenapi ( '<STR_LIT>' , vm_ref ) <EOL> self . _wait_with_callback ( instance . id , task , callback ) <EOL> def resume ( self , instance , callback ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm_ref = self . _get_vm_opaque_ref ( instance ) <EOL> task = self . _session . call_xenapi ( '<STR_LIT>' , vm_ref , False , <EOL> True ) <EOL> self . _wait_with_callback ( instance . id , task , callback ) <EOL> def rescue ( self , context , instance , _callback , network_info ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rescue_vm_ref = VMHelper . lookup ( self . _session , <EOL> \"<STR_LIT>\" % instance . name ) <EOL> if rescue_vm_ref : <EOL> raise RuntimeError ( _ ( <EOL> \"<STR_LIT>\" % instance . name ) ) <EOL> vm_ref = VMHelper . lookup ( self . _session , instance . name ) <EOL> self . _shutdown ( instance , vm_ref ) <EOL> self . _acquire_bootlock ( vm_ref ) <EOL> instance . _rescue = True <EOL> self . spawn_rescue ( context , instance , network_info ) <EOL> rescue_vm_ref = VMHelper . lookup ( self . _session , instance . name ) <EOL> rescue_vbd_ref = self . _find_rescue_vbd_ref ( vm_ref , rescue_vm_ref ) <EOL> self . _session . call_xenapi ( \"<STR_LIT>\" , rescue_vbd_ref ) <EOL> def unrescue ( self , instance , _callback ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> rescue_vm_ref = VMHelper . lookup ( self . _session , <EOL> \"<STR_LIT>\" % instance . name ) <EOL> if not rescue_vm_ref : <EOL> raise exception . InstanceNotInRescueMode ( instance_id = instance . id ) <EOL> original_vm_ref = VMHelper . lookup ( self . _session , instance . name ) <EOL> instance . _rescue = False <EOL> self . _destroy_rescue_instance ( rescue_vm_ref ) <EOL> self . _release_bootlock ( original_vm_ref ) <EOL> self . _start ( instance , original_vm_ref ) <EOL> def poll_rescued_instances ( self , timeout ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> last_ran = self . poll_rescue_last_ran <EOL> if not last_ran : <EOL> self . poll_rescue_last_ran = utils . utcnow ( ) <EOL> return <EOL> if not utils . is_older_than ( last_ran , timeout ) : <EOL> return <EOL> self . poll_rescue_last_ran = utils . utcnow ( ) <EOL> rescue_vms = [ ] <EOL> for instance in self . list_instances ( ) : <EOL> if instance . endswith ( \"<STR_LIT>\" ) : <EOL> rescue_vms . append ( dict ( name = instance , <EOL> vm_ref = VMHelper . lookup ( self . _session , <EOL> instance ) ) ) <EOL> for vm in rescue_vms : <EOL> rescue_vm_ref = vm [ \"<STR_LIT>\" ] <EOL> self . _destroy_rescue_instance ( rescue_vm_ref ) <EOL> original_name = vm [ \"<STR_LIT:name>\" ] . split ( \"<STR_LIT>\" , <NUM_LIT:1> ) [ <NUM_LIT:0> ] <EOL> original_vm_ref = VMHelper . lookup ( self . _session , original_name ) <EOL> self . _release_bootlock ( original_vm_ref ) <EOL> self . _session . call_xenapi ( \"<STR_LIT>\" , original_vm_ref , False , <EOL> False ) <EOL> def get_info ( self , instance ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm_ref = self . _get_vm_opaque_ref ( instance ) <EOL> vm_rec = self . _session . get_xenapi ( ) . VM . get_record ( vm_ref ) <EOL> return VMHelper . compile_info ( vm_rec ) <EOL> def get_diagnostics ( self , instance ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> vm_ref = self . _get_vm_opaque_ref ( instance ) <EOL> vm_rec = self . _session . get_xenapi ( ) . VM . get_record ( vm_ref ) <EOL> return VMHelper . compile_diagnostics ( self . _session , vm_rec ) <EOL> def get_console_output ( self , instance ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return '<STR_LIT>' <EOL> def get_ajax_console ( self , instance ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return '<STR_LIT>' <EOL> def host_power_action ( self , host , action ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> args = { \"<STR_LIT:action>\" : json . dumps ( action ) } <EOL> methods = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> json_resp = self . _call_xenhost ( methods [ action ] , args ) <EOL> resp = json . loads ( json_resp ) <EOL> return resp [ \"<STR_LIT>\" ] <EOL> def set_host_enabled ( self , host , enabled ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> args = { \"<STR_LIT>\" : json . dumps ( enabled ) } <EOL> xenapi_resp = self . _call_xenhost ( \"<STR_LIT>\" , args ) <EOL> try : <EOL> resp = json . loads ( xenapi_resp ) <EOL> except TypeError as e : <EOL> return xenapi_resp . details [ - <NUM_LIT:1> ] <EOL> return resp [ \"<STR_LIT:status>\" ] <EOL> def _call_xenhost ( self , method , arg_dict ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> task_id = random . randint ( - <NUM_LIT> , - <NUM_LIT> ) <EOL> try : <EOL> task = self . _session . async_call_plugin ( \"<STR_LIT>\" , method , <EOL> args = arg_dict ) <EOL> ret = self . _session . wait_for_task ( task , task_id ) <EOL> except self . XenAPI . Failure as e : <EOL> ret = e <EOL> LOG . error ( _ ( \"<STR_LIT>\" ) <EOL> % locals ( ) ) <EOL> return ret <EOL> def inject_network_info ( self , instance , network_info , vm_ref = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if vm_ref : <EOL> self . _session . get_xenapi ( ) . VM . get_record ( vm_ref ) <EOL> else : <EOL> vm_ref = VMHelper . lookup ( self . _session , instance . name ) <EOL> logging . debug ( _ ( \"<STR_LIT>\" ) , vm_ref ) <EOL> for ( network , info ) in network_info : <EOL> location = '<STR_LIT>' % info [ '<STR_LIT>' ] . replace ( '<STR_LIT::>' , '<STR_LIT>' ) <EOL> self . write_to_param_xenstore ( vm_ref , { location : info } ) <EOL> try : <EOL> self . _make_plugin_call ( '<STR_LIT>' , '<STR_LIT>' , instance , <EOL> location , { '<STR_LIT:value>' : json . dumps ( info ) } , <EOL> vm_ref ) <EOL> except KeyError : <EOL> pass <EOL> def create_vifs ( self , vm_ref , instance , network_info ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> logging . debug ( _ ( \"<STR_LIT>\" ) , vm_ref ) <EOL> self . _session . get_xenapi ( ) . VM . get_record ( vm_ref ) <EOL> for device , ( network , info ) in enumerate ( network_info ) : <EOL> vif_rec = self . vif_driver . plug ( self . _session , <EOL> vm_ref , instance , device , network , info ) <EOL> network_ref = vif_rec [ '<STR_LIT>' ] <EOL> LOG . debug ( _ ( '<STR_LIT>' '<STR_LIT>' ) % locals ( ) ) <EOL> vif_ref = self . _session . call_xenapi ( '<STR_LIT>' , vif_rec ) <EOL> LOG . debug ( _ ( '<STR_LIT>' <EOL> '<STR_LIT>' ) % locals ( ) ) <EOL> def plug_vifs ( self , instance , network_info ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for ( network , mapping ) in network_info : <EOL> self . vif_driver . plug ( self . _session , instance , network , mapping ) <EOL> def reset_network ( self , instance , vm_ref = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not vm_ref : <EOL> vm_ref = VMHelper . lookup ( self . _session , instance . name ) <EOL> args = { '<STR_LIT:id>' : str ( uuid . uuid4 ( ) ) } <EOL> resp = self . _make_plugin_call ( '<STR_LIT>' , '<STR_LIT>' , instance , '<STR_LIT>' , <EOL> args , vm_ref ) <EOL> def inject_hostname ( self , instance , vm_ref , hostname ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if instance . os_type == \"<STR_LIT>\" : <EOL> hostname = hostname [ : <NUM_LIT:15> ] <EOL> logging . debug ( _ ( \"<STR_LIT>\" ) , vm_ref ) <EOL> self . _session . call_xenapi_request ( \"<STR_LIT>\" , <EOL> ( vm_ref , \"<STR_LIT>\" , hostname ) ) <EOL> def list_from_xenstore ( self , vm , path ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> ret = self . _make_xenstore_call ( '<STR_LIT>' , vm , path ) <EOL> return json . loads ( ret ) <EOL> def read_from_xenstore ( self , vm , path ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> ret = self . _make_xenstore_call ( '<STR_LIT>' , vm , path , <EOL> { '<STR_LIT>' : '<STR_LIT:True>' } ) <EOL> except self . XenAPI . Failure : <EOL> return None <EOL> ret = json . loads ( ret ) <EOL> if ret == \"<STR_LIT:None>\" : <EOL> return None <EOL> return ret <EOL> def write_to_xenstore ( self , vm , path , value ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _make_xenstore_call ( '<STR_LIT>' , vm , path , <EOL>", "answer": "{ '<STR_LIT:value>' : json . dumps ( value ) } )"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = <NUM_LIT:9> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> SSO_ATTRIBUTE_MAP = { } <EOL> SSO_LOGIN_URL = '<STR_LIT>' <EOL>", "answer": "SSO_LOGIN_ENDPOINT = '<STR_LIT>' "}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Static ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> from foam . sfa . rspecs . elements . element import Element <EOL> from foam . sfa . rspecs . elements . sliver import Sliver <EOL> from foam . sfa . rspecs . elements . versions . pgv2DiskImage import PGv2DiskImage <EOL> from foam . sfa . rspecs . elements . versions . plosv1FWRule import PLOSv1FWRule <EOL> class OcfOfSlivers : <EOL> @ staticmethod <EOL> def add_slivers ( xml , slivers ) : <EOL> if not slivers : <EOL> return <EOL> if not isinstance ( slivers , list ) : <EOL> slivers = [ slivers ] <EOL> for sliver in slivers : <EOL> sliver_elem = xml . add_element ( '<STR_LIT>' ) <EOL> if sliver . get ( '<STR_LIT:type>' ) : <EOL> sliver_elem . set ( '<STR_LIT:name>' , sliver [ '<STR_LIT:type>' ] ) <EOL> attrs = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> for attr in attrs : <EOL> if sliver . get ( attr ) : <EOL> sliver_elem . set ( attr , sliver [ attr ] ) <EOL> images = sliver . get ( '<STR_LIT>' ) <EOL> if images and isinstance ( images , list ) : <EOL> PGv2DiskImage . add_images ( sliver_elem , images ) <EOL> fw_rules = sliver . get ( '<STR_LIT>' ) <EOL> if fw_rules and isinstance ( fw_rules , list ) : <EOL> PLOSv1FWRule . add_rules ( sliver_elem , fw_rules ) <EOL> PGv2SliverType . add_sliver_attributes ( sliver_elem , sliver . get ( '<STR_LIT>' , [ ] ) ) <EOL> @ staticmethod <EOL> def add_sliver_attributes ( xml , attributes ) : <EOL> if attributes : <EOL> for attribute in attributes : <EOL> if attribute [ '<STR_LIT:name>' ] == '<STR_LIT>' : <EOL> xml . add_element ( '<STR_LIT>' % xml . namespaces [ '<STR_LIT>' ] , name = attribute [ '<STR_LIT:value>' ] ) <EOL> elif attribute [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> attrib_elem = xml . add_element ( '<STR_LIT>' % self . namespaces [ '<STR_LIT>' ] ) <EOL> attrib_dict = eval ( tag [ '<STR_LIT:value>' ] ) <EOL> for ( key , value ) in attrib_dict . items ( ) : <EOL>", "answer": "attrib_elem . set ( key , value )"}, {"prompt": "<s> __author__ = '<STR_LIT>' <EOL> import argparse <EOL> import msgpack <EOL> import os <EOL> from interface . services . icontainer_agent import IContainerAgent , ContainerAgentClient <EOL> from pyon . net . messaging import make_node <EOL> from pyon . core . bootstrap import CFG , bootstrap_pyon <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( description = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , help = \"<STR_LIT>\" ) <EOL> parser . add_argument ( \"<STR_LIT>\" , help = \"<STR_LIT>\" , choices = IContainerAgent . names ( ) ) <EOL> parser . add_argument ( \"<STR_LIT>\" , metavar = \"<STR_LIT>\" , nargs = \"<STR_LIT:*>\" , help = \"<STR_LIT>\" ) <EOL> opts = parser . parse_args ( ) <EOL> pidfile = opts . pidfile <EOL> if not pidfile : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> parms = { } <EOL> with open ( pidfile , '<STR_LIT:r>' ) as pf : <EOL> parms = msgpack . loads ( pf . read ( ) ) <EOL> assert parms , \"<STR_LIT>\" <EOL> bootstrap_pyon ( ) <EOL> node , ioloop = make_node ( parms [ '<STR_LIT>' ] ) <EOL> node . setup_interceptors ( CFG . interceptor ) <EOL> cc = ContainerAgentClient ( node = node , to_name = ( parms [ '<STR_LIT>' ] , parms [ '<STR_LIT>' ] ) ) <EOL> methdefs = [ x [ <NUM_LIT:1> ] for x in IContainerAgent . namesAndDescriptions ( ) if x [ <NUM_LIT:0> ] == opts . command ] <EOL> assert len ( methdefs ) == <NUM_LIT:1> <EOL> arg_names = methdefs [ <NUM_LIT:0> ] . positional <EOL> msg_args = dict ( zip ( arg_names , opts . commandargs ) ) <EOL> retval = cc . request ( msg_args , op = opts . command ) <EOL>", "answer": "if opts . command == \"<STR_LIT:status>\" :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from api import Wink <EOL> from auth import auth <EOL> from persist import ConfigFile <EOL> def login ( base_url = \"<STR_LIT>\" , config_file = \"<STR_LIT>\" ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> auth_info = dict ( <EOL> base_url = base_url , <EOL>", "answer": ")"}, {"prompt": "<s> import dateutil . parser , datetime <EOL> from bson . objectid import ObjectId <EOL> from gluon . custom_import import track_changes <EOL> from oauth import OAuth2 <EOL> from oauth . storage import web2pyStorage as storage <EOL> from oauth . exceptions import * <EOL> track_changes ( True ) <EOL> CODES = { '<STR_LIT>' : <NUM_LIT:200> } <EOL> MESSAGES = { '<STR_LIT>' : '<STR_LIT:success>' } <EOL> def validate_access_token ( f ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> from oauth . storage import web2pyStorage as storage <EOL> storage = storage ( ) <EOL> storage . connect ( ) <EOL> oauth = OAuth2 ( storage ) <EOL> response . headers [ '<STR_LIT:Content-Type>' ] = json_headers ( ) <EOL> response . view = json_service ( ) <EOL> header = request . env [ '<STR_LIT>' ] <EOL> token = oauth . validate_access_params ( request . get_vars , request . post_vars , <EOL> header ) <EOL> return f <EOL> def parse_to_date ( default , arg ) : <EOL> try : <EOL> if default : <EOL> return dateutil . parser . parse ( default ) if not arg else dateutil . parser . parse ( arg ) <EOL> else : <EOL> return None if not arg else dateutil . parser . parse ( arg ) <EOL> except ValueError : <EOL> return default <EOL> def json_service ( ) : <EOL> return '<STR_LIT>' <EOL> def json_headers ( ) : <EOL> return '<STR_LIT>' <EOL>", "answer": "def encode_model ( obj , recursive = False ) :"}, {"prompt": "<s> import numpy as np <EOL> import scipy as sp <EOL> from dml . SVM import SVMC <EOL> X = [ <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT:15> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT:8> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT:10> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> ] , <EOL>", "answer": "[ <NUM_LIT> , <NUM_LIT> ] ,"}, {"prompt": "<s> from collections import deque <EOL> import logging <EOL> import time <EOL> from twisted . internet import protocol <EOL> from twisted . internet import defer , reactor <EOL> from twisted . python import failure <EOL> from twimp import amf0 <EOL> from twimp import chunks <EOL> from twimp . error import ProtocolContractError , UnexpectedStatusError <EOL> from twimp . error import CommandResultError <EOL> from twimp . error import CallResultError , CallAbortedException <EOL> from twimp . proto import DispatchProtocol , DispatchFactory <EOL> from twimp . utils import ms_time_wrapped <EOL> LOG_CATEGORY = '<STR_LIT>' <EOL> import twimp . log <EOL> log = twimp . log . get_logger ( LOG_CATEGORY ) <EOL> class CancellableCallQueue ( object ) : <EOL> def __init__ ( self , reactor = reactor ) : <EOL> self . reactor = reactor <EOL> self . pending = { } <EOL> self . _next_key = <NUM_LIT:0> <EOL> def callLater ( self , delay , f , * args , ** kw ) : <EOL> call_key , self . _next_key = self . _next_key , self . _next_key + <NUM_LIT:1> <EOL> clid = self . reactor . callLater ( delay , self . _call_wrapper , call_key , f , <EOL> args , kw ) <EOL> self . pending [ call_key ] = clid <EOL> return call_key , clid <EOL> def cancel ( self , ( call_key , clid ) ) : <EOL> self . pending . pop ( call_key , None ) <EOL> return clid . cancel ( ) <EOL> def _call_wrapper ( self , call_key , f , args , kw ) : <EOL> del self . pending [ call_key ] <EOL> f ( * args , ** kw ) <EOL> def cancel_all ( self ) : <EOL> remaining = self . pending . copy ( ) <EOL> self . pending . clear ( ) <EOL> for key , clid in remaining . iteritems ( ) : <EOL> if clid . active ( ) : <EOL> clid . cancel ( ) <EOL> class DeferredTracker ( object ) : <EOL> init_trans_id = <NUM_LIT:1> <EOL> def __init__ ( self ) : <EOL> self . _pending = { } <EOL> self . _next_trans_id = { } <EOL> def next_trans ( self , key ) : <EOL> trans_id = self . _next_trans_id . setdefault ( key , self . init_trans_id ) <EOL> r , trans_id = trans_id , trans_id + <NUM_LIT:1> <EOL> self . _next_trans_id [ key ] = trans_id <EOL> return r <EOL> def push_deferred ( self , key , trans_id , d ) : <EOL> if key not in self . _pending : <EOL> self . _pending [ key ] = { } <EOL> key_queue = self . _pending [ key ] <EOL> key_queue [ trans_id ] = d <EOL> def pop_deferred ( self , key , trans_id ) : <EOL> d = None <EOL> key_queue = self . _pending . get ( key , None ) <EOL> if key_queue : <EOL> d = key_queue . pop ( trans_id , None ) <EOL> return d <EOL> def iter_all ( self ) : <EOL> return ( ( key , d ) <EOL> for ( key , key_queue ) in self . _pending . iteritems ( ) <EOL> for d in key_queue . itervalues ( ) ) <EOL> def clear ( self ) : <EOL> self . _pending = { } <EOL> def reset ( self ) : <EOL> self . _next_trans_id = { } <EOL> class StatusEventTracker ( object ) : <EOL> def __init__ ( self ) : <EOL> self . _event_callbacks = { } <EOL> def add ( self , key , code , d ) : <EOL> q = self . _event_callbacks . get ( key , None ) <EOL> if q is None : <EOL> q = self . _event_callbacks [ key ] = deque ( ) <EOL> q . append ( ( code , d ) ) <EOL> def pop ( self , key ) : <EOL> code , d = None , None <EOL> q = self . _event_callbacks . get ( key , None ) <EOL> if q : <EOL> code , d = q . popleft ( ) <EOL> return code , d <EOL> def pop_all ( self ) : <EOL> ret = ( ( code , d ) <EOL> for q in self . _event_callbacks . itervalues ( ) <EOL> for ( code , d ) in q ) <EOL> self . _event_callbacks = { } <EOL> return ret <EOL> def wait ( self , key , code ) : <EOL> d = defer . Deferred ( ) <EOL> self . add ( key , code , d ) <EOL> return d <EOL> def cancel_all ( self , reason = None ) : <EOL> waiting = self . pop_all ( ) <EOL> if reason : <EOL> for _code , d in waiting : <EOL> d . errback ( reason ) <EOL> def dispatch ( self , key , info , miss_h = None ) : <EOL> code , d = self . pop ( key ) <EOL> if not d : <EOL> if miss_h : <EOL> miss_h ( ) <EOL> else : <EOL> try : <EOL> evt_code = info . code <EOL> except AttributeError , e : <EOL> d . errback ( ProtocolContractError ( e ) ) <EOL> else : <EOL> if code is None or evt_code == code : <EOL> d . callback ( info ) <EOL> else : <EOL> d . errback ( UnexpectedStatusError ( info ) ) <EOL> class CommandDispatchProtocol ( DispatchProtocol ) : <EOL> def __init__ ( self ) : <EOL> DispatchProtocol . __init__ ( self ) <EOL> self . _cc_queue = CancellableCallQueue ( ) <EOL> self . _call_tracker = DeferredTracker ( ) <EOL> def doCommand ( self , ts , ms_id , args ) : <EOL> cmd = args [ <NUM_LIT:0> ] <EOL> handler_m = getattr ( self , '<STR_LIT>' % ( cmd , ) , None ) <EOL> if handler_m is None : <EOL> self . _cc_queue . callLater ( <NUM_LIT:0> , self . unknownCommandType , cmd , ts , <EOL> ms_id , args [ <NUM_LIT:1> : ] ) <EOL> else : <EOL> self . _cc_queue . callLater ( <NUM_LIT:0> , self . _handler_wrapper , handler_m , <EOL> ts , ms_id , args [ <NUM_LIT:1> : ] ) <EOL> def _handler_wrapper ( self , handler , ts , ms_id , args ) : <EOL> handler ( ts , ms_id , * args ) <EOL> def command__result ( self , ts , ms_id , trans_id , * args ) : <EOL> d = self . _call_tracker . pop_deferred ( ms_id , trans_id ) <EOL> if d : <EOL> d . callback ( args ) <EOL> else : <EOL> self . unexpectedCallResult ( ts , ms_id , trans_id , args ) <EOL> def command__error ( self , ts , ms_id , trans_id , * args ) : <EOL> d = self . _call_tracker . pop_deferred ( ms_id , trans_id ) <EOL> if d : <EOL> d . errback ( failure . Failure ( CommandResultError ( * args ) ) ) <EOL> else : <EOL> self . unexpectedCallError ( ts , ms_id , trans_id , args ) <EOL> def unknownCommandType ( self , cmd , ts , msid , args ) : <EOL> raise NotImplementedError ( '<STR_LIT>' % ( cmd , <EOL> ( ts , msid , args ) ) ) <EOL> def unexpectedCallResult ( self , ts , ms_id , trans_id , args ) : <EOL> log . warning ( '<STR_LIT>' , <EOL> ts , ms_id , trans_id , args ) <EOL> def unexpectedCallError ( self , ts , ms_id , trans_id , args ) : <EOL> log . warning ( '<STR_LIT>' , <EOL> ts , ms_id , trans_id , args ) <EOL> def connectionLost ( self , reason = protocol . connectionDone ) : <EOL> self . _cc_queue . cancel_all ( ) <EOL> pending_calls = list ( self . _call_tracker . iter_all ( ) ) <EOL> self . _call_tracker . clear ( ) <EOL> for ms_id , d in pending_calls : <EOL> d . errback ( reason ) <EOL> DispatchProtocol . connectionLost ( self , reason ) <EOL> def encode_amf ( self , * args ) : <EOL> return amf0 . encode ( * args ) <EOL> def _send_command ( self , ts , ms_id , body , track_id ) : <EOL> d = None <EOL> if track_id : <EOL> d = defer . Deferred ( ) <EOL> self . _call_tracker . push_deferred ( ms_id , track_id , d ) <EOL> self . muxer . sendMessage ( <NUM_LIT:0> , chunks . MSG_COMMAND , ms_id , body ) <EOL> return d <EOL> def _sendRemote ( self , ms_id , cmd , args , kwargs , track ) : <EOL> trans_id = <NUM_LIT:0> <EOL> if track : <EOL> trans_id = self . _call_tracker . next_trans ( ms_id ) <EOL> encoded_args = self . encode_amf ( cmd , trans_id , * args ) <EOL> return self . _send_command ( <NUM_LIT:0> , ms_id , encoded_args , trans_id ) <EOL> def callRemote ( self , ms_id , cmd , * args , ** kw ) : <EOL> return self . _sendRemote ( ms_id , cmd , args , kw , True ) <EOL> def signalRemote ( self , ms_id , cmd , * args , ** kw ) : <EOL> return self . _sendRemote ( ms_id , cmd , args , kw , False ) <EOL> class CommandDispatchFactory ( DispatchFactory ) : <EOL> protocol = CommandDispatchProtocol <EOL> class EventDispatchProtocol ( CommandDispatchProtocol ) : <EOL> def __init__ ( self ) : <EOL> CommandDispatchProtocol . __init__ ( self ) <EOL> self . _events = StatusEventTracker ( ) <EOL> def _onStatus_ev_key ( self , ms_id ) : <EOL> return ( None , ms_id ) <EOL> def waitStatus ( self , ms_id , code ) : <EOL> return self . _events . wait ( self . _onStatus_ev_key ( ms_id ) , code ) <EOL> def command_onStatus ( self , ts , ms_id , _trans_id , _none , info ) : <EOL> def miss_handler ( ) : <EOL> self . unhandledOnStatus ( ts , ms_id , info ) <EOL> self . _events . dispatch ( self . _onStatus_ev_key ( ms_id ) , info , <EOL> miss_h = miss_handler ) <EOL> def unhandledOnStatus ( self , ts , ms_id , info ) : <EOL> log . warning ( '<STR_LIT>' , <EOL> ts , ms_id , info ) <EOL> def connectionLost ( self , reason = protocol . connectionDone ) : <EOL> self . _events . cancel_all ( reason = reason ) <EOL> CommandDispatchProtocol . connectionLost ( self , reason ) <EOL> class EventDispatchFactory ( CommandDispatchFactory ) : <EOL> protocol = EventDispatchProtocol <EOL> class CallDispatchProtocol ( EventDispatchProtocol ) : <EOL> def __init__ ( self ) : <EOL> EventDispatchProtocol . __init__ ( self ) <EOL> def session_time ( self ) : <EOL> return time . time ( ) - self . session_init_time <EOL> def unknownCommandType ( self , cmd , ts , ms_id , args ) : <EOL> trans_id = args [ <NUM_LIT:0> ] <EOL> handler_m = getattr ( self , '<STR_LIT>' % ( cmd , ) , None ) <EOL> if handler_m is None : <EOL>", "answer": "d = defer . maybeDeferred ( self . unknownRemoteCall , cmd , ts , ms_id ,"}, {"prompt": "<s> import sublime <EOL> import sublime_plugin <EOL> import os <EOL> from threading import Thread <EOL> from . import sublimelint <EOL> from . lint import persist <EOL> from . lint . edit import Edit <EOL> def error_command ( f ) : <EOL> def run ( self , edit , ** kwargs ) : <EOL> vid = self . view . id ( ) <EOL> if vid in persist . errors and persist . errors [ vid ] : <EOL> f ( self , self . view , persist . errors [ vid ] , ** kwargs ) <EOL> return run <EOL> def select_line ( view , line ) : <EOL> sel = view . sel ( ) <EOL> point = view . text_point ( line , <NUM_LIT:0> ) <EOL> sel . clear ( ) <EOL> sel . add ( view . line ( point ) ) <EOL> class sublimelint_next_error ( sublime_plugin . TextCommand ) : <EOL> @ error_command <EOL> def run ( self , view , errors , direction = <NUM_LIT:1> ) : <EOL> self . view . run_command ( '<STR_LIT>' ) <EOL> sel = view . sel ( ) <EOL> if len ( sel ) == <NUM_LIT:0> : <EOL> sel . add ( ( <NUM_LIT:0> , <NUM_LIT:0> ) ) <EOL> line = view . rowcol ( sel [ <NUM_LIT:0> ] . a ) [ <NUM_LIT:0> ] <EOL> errors = list ( errors ) <EOL> if line in errors : errors . remove ( line ) <EOL> errors = sorted ( errors + [ line ] ) <EOL> i = errors . index ( line ) + direction <EOL> if i >= len ( errors ) : <EOL> i -= len ( errors ) <EOL> select_line ( view , errors [ i ] ) <EOL> view . show_at_center ( sel [ <NUM_LIT:0> ] ) <EOL> class sublimelint_all_errors ( sublime_plugin . TextCommand ) : <EOL> @ error_command <EOL> def run ( self , view , errors ) : <EOL> options = [ ] <EOL> option_to_line = [ ] <EOL> for lineno , messages in sorted ( errors . items ( ) ) : <EOL> line = view . substr ( <EOL> view . full_line ( view . text_point ( lineno , <NUM_LIT:0> ) ) <EOL> ) <EOL> while messages : <EOL> option_to_line . append ( lineno ) <EOL> options . append ( <EOL> [ ( \"<STR_LIT>\" % ( lineno + <NUM_LIT:1> , line . strip ( ) ) ) ] + <EOL> [ m for m in messages [ : <NUM_LIT:2> ] ] <EOL> ) <EOL> messages = messages [ <NUM_LIT:2> : ] <EOL> def center_line ( i ) : <EOL> if i != - <NUM_LIT:1> : <EOL> select_line ( view , option_to_line [ i ] ) <EOL> view . show_at_center ( view . sel ( ) [ <NUM_LIT:0> ] ) <EOL> view . window ( ) . show_quick_panel ( options , center_line , sublime . MONOSPACE_FONT ) <EOL> class sublimelint_report ( sublime_plugin . WindowCommand ) : <EOL> def run ( self , on = '<STR_LIT>' ) : <EOL> output = self . window . new_file ( ) <EOL> output . set_name ( '<STR_LIT>' ) <EOL> output . set_scratch ( True ) <EOL> if on == '<STR_LIT>' or on == '<STR_LIT>' : <EOL> for view in self . window . views ( ) : <EOL> self . report ( output , view ) <EOL> if on == '<STR_LIT>' or on == '<STR_LIT>' : <EOL> for folder in self . window . folders ( ) : <EOL> self . folder ( output , folder ) <EOL> def folder ( self , output , folder ) : <EOL> for root , dirs , files in os . walk ( folder ) : <EOL> for name in files : <EOL> path = os . path . join ( root , name ) <EOL> if os . stat ( path ) . st_size < <NUM_LIT> * <NUM_LIT> : <EOL> pass <EOL> def report ( self , output , view ) : <EOL> def finish_lint ( view , linters ) : <EOL> if not linters : <EOL> return <EOL> with Edit ( output ) as edit : <EOL> if not any ( l . errors for l in linters ) : <EOL> return <EOL> filename = os . path . basename ( linters [ <NUM_LIT:0> ] . filename or '<STR_LIT>' ) <EOL> out = '<STR_LIT>' . format ( filename ) <EOL> for linter in linters : <EOL> if linter . errors : <EOL> for line , errors in sorted ( linter . errors . items ( ) ) : <EOL> for error in errors : <EOL> out += '<STR_LIT>' . format ( line , error ) <EOL> edit . insert ( output . size ( ) , out ) <EOL> args = ( view . id ( ) , finish_lint ) <EOL>", "answer": "Thread ( target = sublimelint . SublimeLint . lint , args = args ) . start ( ) "}, {"prompt": "<s> from nova import utils <EOL> class BaseImageService ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> BASE_IMAGE_ATTRS = [ '<STR_LIT:id>' , '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:status>' , '<STR_LIT>' ] <EOL> SERVICE_IMAGE_ATTRS = [ ] <EOL> def index ( self , context , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> def detail ( self , context , * args , ** kwargs ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> def show ( self , context , image_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> def get ( self , context , data ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> def create ( self , context , metadata , data = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> def update ( self , context , image_id , metadata , data = None ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> def delete ( self , context , image_id ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> raise NotImplementedError <EOL> @ staticmethod <EOL> def _is_image_available ( context , image_meta ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if image_meta [ '<STR_LIT>' ] or context . is_admin : <EOL> return True <EOL> properties = image_meta [ '<STR_LIT>' ] <EOL> if context . project_id and ( '<STR_LIT>' in properties ) : <EOL> return str ( properties [ '<STR_LIT>' ] ) == str ( context . project_id ) <EOL> if context . project_id and ( '<STR_LIT>' in properties ) : <EOL> return str ( properties [ '<STR_LIT>' ] ) == str ( context . project_id ) <EOL> try : <EOL> user_id = properties [ '<STR_LIT>' ] <EOL> except KeyError : <EOL> return False <EOL> return str ( user_id ) == str ( context . user_id ) <EOL> @ classmethod <EOL> def _translate_to_base ( cls , metadata ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return cls . _propertify_metadata ( metadata , cls . BASE_IMAGE_ATTRS ) <EOL> @ classmethod <EOL> def _translate_to_service ( cls , metadata ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not cls . SERVICE_IMAGE_ATTRS : <EOL>", "answer": "raise NotImplementedError ( _ ( '<STR_LIT>'"}, {"prompt": "<s> class FileTypeError ( Exception ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Tangible ( )"}, {"prompt": "<s> from logpy . unification import unify , reify , _unify , _reify <EOL> from logpy import var <EOL> def test_reify ( ) : <EOL> x , y , z = var ( ) , var ( ) , var ( ) <EOL> s = { x : <NUM_LIT:1> , y : <NUM_LIT:2> , z : ( x , y ) } <EOL> assert reify ( x , s ) == <NUM_LIT:1> <EOL> assert reify ( <NUM_LIT:10> , s ) == <NUM_LIT:10> <EOL> assert reify ( ( <NUM_LIT:1> , y ) , s ) == ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> assert reify ( ( <NUM_LIT:1> , ( x , ( y , <NUM_LIT:2> ) ) ) , s ) == ( <NUM_LIT:1> , ( <NUM_LIT:1> , ( <NUM_LIT:2> , <NUM_LIT:2> ) ) ) <EOL> assert reify ( z , s ) == ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> def test_reify_dict ( ) : <EOL> x , y = var ( ) , var ( ) <EOL> s = { x : <NUM_LIT:2> , y : <NUM_LIT:4> } <EOL> e = { <NUM_LIT:1> : x , <NUM_LIT:3> : { <NUM_LIT:5> : y } } <EOL> assert reify ( e , s ) == { <NUM_LIT:1> : <NUM_LIT:2> , <NUM_LIT:3> : { <NUM_LIT:5> : <NUM_LIT:4> } } <EOL> def test_reify_list ( ) : <EOL> x , y = var ( ) , var ( ) <EOL>", "answer": "s = { x : <NUM_LIT:2> , y : <NUM_LIT:4> }"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> from codalab . bundles . named_bundle import NamedBundle <EOL> from codalab . common import State <EOL> from codalab . objects . metadata_spec import MetadataSpec <EOL> class UploadedBundle ( NamedBundle ) : <EOL> METADATA_SPECS = list ( NamedBundle . METADATA_SPECS ) <EOL> METADATA_SPECS . append ( MetadataSpec ( '<STR_LIT>' , basestring , '<STR_LIT>' ) ) <EOL> METADATA_SPECS . append ( MetadataSpec ( '<STR_LIT>' , basestring , '<STR_LIT>' ) ) <EOL> @ classmethod <EOL> def construct ( cls , metadata , owner_id , uuid = None ) : <EOL>", "answer": "row = {"}, {"prompt": "<s> import os <EOL> import re <EOL> def parse_url_rules ( urls_fp ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> url_rules = [ ] <EOL> for line in urls_fp : <EOL> re_url = line . strip ( ) <EOL> if re_url : <EOL> url_rules . append ( { '<STR_LIT:str>' : re_url , '<STR_LIT>' : re . compile ( re_url ) } ) <EOL> return url_rules <EOL> def makedir_if_none_exists ( d ) : <EOL> if not os . path . exists ( d ) : <EOL> os . makedirs ( d ) <EOL> def total_seconds ( td ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return ( td . microseconds + ( td . seconds + td . days * <NUM_LIT> * <NUM_LIT> ) * <NUM_LIT> ) / <NUM_LIT> <EOL> def smart_str ( s , encoding = '<STR_LIT:utf-8>' ) : <EOL> if isinstance ( s , unicode ) : <EOL> return s . encode ( encoding ) <EOL> elif s and encoding != '<STR_LIT:utf-8>' : <EOL> return s . decode ( '<STR_LIT:utf-8>' , '<STR_LIT:ignore>' ) . encode ( encoding , '<STR_LIT:ignore>' ) <EOL> else : <EOL> return str ( s ) <EOL> def smart_unicode ( s , encoding = '<STR_LIT:utf-8>' ) : <EOL> if isinstance ( s , unicode ) : <EOL> return s <EOL>", "answer": "return s . decode ( encoding , '<STR_LIT:ignore>' ) "}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Creature ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = <NUM_LIT:9> <EOL> result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL>", "answer": "return result "}, {"prompt": "<s> import os <EOL> import click <EOL> from supernova import config , utils <EOL> class TestUtils ( object ) : <EOL> def test_assemble_username ( self ) : <EOL> result = utils . assemble_username ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> assert result == \"<STR_LIT>\" <EOL> def test_env_var_warning ( self ) : <EOL> os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" <EOL> result = utils . check_environment_presets ( ) <EOL> assert not result <EOL> def test_env_var_pass ( self ) : <EOL> os . environ = { \"<STR_LIT>\" : '<STR_LIT:value>' } <EOL> result = utils . check_environment_presets ( ) <EOL> assert result <EOL> def test_confirm_credential_display_forced ( self ) : <EOL> result = utils . confirm_credential_display ( True ) <EOL> assert result <EOL> def test_confirm_credential_display_not_forced ( self , monkeypatch ) : <EOL> def mockreturn ( text ) : <EOL>", "answer": "return True"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from pygments . style import Style <EOL> from pygments . token import Token , Comment , Name , Keyword , Generic , Number , String , Whitespace <EOL> class FruityStyle ( Style ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> import requests <EOL> import collections <EOL> import sys <EOL> import time <EOL> import json <EOL> Entry = collections . namedtuple ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> ROW_TYPES = { } <EOL> def row_type_for_columns ( name , column_names ) : <EOL> column_names = tuple ( column_names ) <EOL> row_type = ROW_TYPES . get ( ( name , column_names ) ) <EOL> if row_type is None : <EOL> row_type = collections . namedtuple ( name , column_names ) <EOL>", "answer": "ROW_TYPES [ ( name , column_names ) ] = row_type"}, {"prompt": "<s> VERSION = ( <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:9> ) <EOL>", "answer": "__version__ = \"<STR_LIT>\" "}, {"prompt": "<s> from django . contrib . auth . backends import RemoteUserBackend <EOL> class RemoteNoUnknownUserBackend ( RemoteUserBackend ) : <EOL>", "answer": "\"\"\"<STR_LIT>\"\"\""}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Mission ( ) <EOL>", "answer": "result . template = \"<STR_LIT>\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> from __future__ import print_function <EOL> from nltk . grammar import CFG , FeatureGrammar , PCFG <EOL> from nltk . data import load <EOL> from nltk . parse . chart import Chart , ChartParser <EOL> from nltk . parse . pchart import InsideChartParser <EOL> from nltk . parse . featurechart import FeatureChart , FeatureChartParser <EOL> def load_parser ( grammar_url , trace = <NUM_LIT:0> , <EOL> parser = None , chart_class = None , <EOL> beam_size = <NUM_LIT:0> , ** load_args ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> grammar = load ( grammar_url , ** load_args ) <EOL> if not isinstance ( grammar , CFG ) : <EOL> raise ValueError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> if isinstance ( grammar , PCFG ) : <EOL> if parser is None : <EOL> parser = InsideChartParser <EOL> return parser ( grammar , trace = trace , beam_size = beam_size ) <EOL> elif isinstance ( grammar , FeatureGrammar ) : <EOL> if parser is None : <EOL> parser = FeatureChartParser <EOL> if chart_class is None : <EOL> chart_class = FeatureChart <EOL> return parser ( grammar , trace = trace , chart_class = chart_class ) <EOL> else : <EOL> if parser is None : <EOL> parser = ChartParser <EOL> if chart_class is None : <EOL> chart_class = Chart <EOL> return parser ( grammar , trace = trace , chart_class = chart_class ) <EOL> def taggedsent_to_conll ( sentence ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for ( i , ( word , tag ) ) in enumerate ( sentence , start = <NUM_LIT:1> ) : <EOL> input_str = [ str ( i ) , word , '<STR_LIT:_>' , tag , tag , '<STR_LIT:_>' , '<STR_LIT:0>' , '<STR_LIT:a>' , '<STR_LIT:_>' , '<STR_LIT:_>' ] <EOL> input_str = \"<STR_LIT:\\t>\" . join ( input_str ) + \"<STR_LIT:\\n>\" <EOL> yield input_str <EOL> def taggedsents_to_conll ( sentences ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for sentence in sentences : <EOL> for input_str in taggedsent_to_conll ( sentence ) : <EOL> yield input_str <EOL> yield '<STR_LIT>' <EOL> class TestGrammar ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , grammar , suite , accept = None , reject = None ) : <EOL> self . test_grammar = grammar <EOL> self . cp = load_parser ( grammar , trace = <NUM_LIT:0> ) <EOL> self . suite = suite <EOL> self . _accept = accept <EOL> self . _reject = reject <EOL> def run ( self , show_trees = False ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> for test in self . suite : <EOL> print ( test [ '<STR_LIT>' ] + \"<STR_LIT::>\" , end = '<STR_LIT:U+0020>' ) <EOL>", "answer": "for key in [ '<STR_LIT>' , '<STR_LIT>' ] :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> NUM_THREADS = <NUM_LIT:20> <EOL> FILES_PER_THREAD = <NUM_LIT:50> <EOL> import tempfile <EOL> from test . test_support import start_threads , run_unittest , import_module <EOL>", "answer": "threading = import_module ( '<STR_LIT>' )"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL>", "answer": "result = Tangible ( )"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import threading <EOL> import keyring <EOL> from oauth2client . client import Credentials <EOL> from oauth2client . client import Storage as BaseStorage <EOL> __author__ = '<STR_LIT>' <EOL> class Storage ( BaseStorage ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , service_name , user_name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> super ( Storage , self ) . __init__ ( lock = threading . Lock ( ) ) <EOL> self . _service_name = service_name <EOL> self . _user_name = user_name <EOL> def locked_get ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> credentials = None <EOL> content = keyring . get_password ( self . _service_name , self . _user_name ) <EOL> if content is not None : <EOL> try : <EOL> credentials = Credentials . new_from_json ( content ) <EOL> credentials . set_store ( self ) <EOL> except ValueError : <EOL>", "answer": "pass"}, {"prompt": "<s> from neutron import context as n_ctx <EOL> from sqlalchemy . orm import exc as orm_exc <EOL> from gbpservice . neutron . db . grouppolicy . extensions import group_proxy_db <EOL> from gbpservice . neutron . tests . unit . services . grouppolicy import ( <EOL> test_extension_driver_api as test_ext_base ) <EOL> class ExtensionDriverTestCaseMixin ( object ) : <EOL> def test_proxy_group_extension ( self ) : <EOL> l3p = self . create_l3_policy ( ) [ '<STR_LIT>' ] <EOL> self . assertEqual ( '<STR_LIT>' , l3p [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( <NUM_LIT> , l3p [ '<STR_LIT>' ] ) <EOL> l2p = self . create_l2_policy ( l3_policy_id = l3p [ '<STR_LIT:id>' ] ) [ '<STR_LIT>' ] <EOL> ptg = self . create_policy_target_group ( <EOL> l2_policy_id = l2p [ '<STR_LIT:id>' ] ) [ '<STR_LIT>' ] <EOL> self . assertIsNone ( ptg [ '<STR_LIT>' ] ) <EOL> self . assertIsNone ( ptg [ '<STR_LIT>' ] ) <EOL> self . assertIsNone ( ptg [ '<STR_LIT>' ] ) <EOL> l3p = self . show_l3_policy ( l3p [ '<STR_LIT:id>' ] ) [ '<STR_LIT>' ] <EOL> self . assertEqual ( '<STR_LIT>' , l3p [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( <NUM_LIT> , l3p [ '<STR_LIT>' ] ) <EOL> ptg_proxy = self . create_policy_target_group ( <EOL> proxied_group_id = ptg [ '<STR_LIT:id>' ] ) [ '<STR_LIT>' ] <EOL> self . assertIsNone ( ptg_proxy [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( ptg [ '<STR_LIT:id>' ] , ptg_proxy [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( '<STR_LIT>' , ptg_proxy [ '<STR_LIT>' ] ) <EOL> ptg = self . show_policy_target_group ( ptg [ '<STR_LIT:id>' ] ) [ '<STR_LIT>' ] <EOL> self . assertEqual ( ptg_proxy [ '<STR_LIT:id>' ] , ptg [ '<STR_LIT>' ] ) <EOL> self . assertIsNone ( ptg [ '<STR_LIT>' ] ) <EOL> pt = self . create_policy_target ( <EOL> policy_target_group_id = ptg_proxy [ '<STR_LIT:id>' ] ) [ '<STR_LIT>' ] <EOL> self . assertFalse ( pt [ '<STR_LIT>' ] ) <EOL> self . assertFalse ( pt [ '<STR_LIT>' ] ) <EOL> pt = self . create_policy_target ( <EOL> policy_target_group_id = ptg_proxy [ '<STR_LIT:id>' ] , <EOL> proxy_gateway = True , group_default_gateway = True ) [ '<STR_LIT>' ] <EOL> self . assertTrue ( pt [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( pt [ '<STR_LIT>' ] ) <EOL> pt = self . show_policy_target ( pt [ '<STR_LIT:id>' ] ) [ '<STR_LIT>' ] <EOL> self . assertTrue ( pt [ '<STR_LIT>' ] ) <EOL> self . assertTrue ( pt [ '<STR_LIT>' ] ) <EOL> def test_preexisting_pt ( self ) : <EOL> ptg = self . create_policy_target_group ( ) [ '<STR_LIT>' ] <EOL> pt = self . create_policy_target ( <EOL> policy_target_group_id = ptg [ '<STR_LIT:id>' ] ) [ '<STR_LIT>' ] <EOL> self . assertTrue ( '<STR_LIT>' in pt ) <EOL> self . assertTrue ( '<STR_LIT>' in pt ) <EOL> admin_context = n_ctx . get_admin_context ( ) <EOL> mapping = admin_context . session . query ( <EOL> group_proxy_db . ProxyGatewayMapping ) . filter_by ( <EOL> policy_target_id = pt [ '<STR_LIT:id>' ] ) . one ( ) <EOL> admin_context . session . delete ( mapping ) <EOL> query = admin_context . session . query ( <EOL> group_proxy_db . ProxyGatewayMapping ) . filter_by ( <EOL> policy_target_id = pt [ '<STR_LIT:id>' ] ) <EOL> self . assertRaises ( orm_exc . NoResultFound , query . one ) <EOL> pt = self . show_policy_target ( pt [ '<STR_LIT:id>' ] , <EOL> expected_res_status = <NUM_LIT:200> ) [ '<STR_LIT>' ] <EOL> self . assertFalse ( '<STR_LIT>' in pt ) <EOL> self . assertFalse ( '<STR_LIT>' in pt ) <EOL> pt = self . update_policy_target ( <EOL> pt [ '<STR_LIT:id>' ] , name = '<STR_LIT>' , <EOL> expected_res_status = <NUM_LIT:200> ) [ '<STR_LIT>' ] <EOL> self . assertEqual ( '<STR_LIT>' , pt [ '<STR_LIT:name>' ] ) <EOL> self . assertFalse ( '<STR_LIT>' in pt ) <EOL> self . assertFalse ( '<STR_LIT>' in pt ) <EOL> def test_proxy_group_multiple_proxies ( self ) : <EOL> ptg = self . create_policy_target_group ( ) [ '<STR_LIT>' ] <EOL> self . create_policy_target_group ( proxied_group_id = ptg [ '<STR_LIT:id>' ] ) <EOL> res = self . create_policy_target_group ( proxied_group_id = ptg [ '<STR_LIT:id>' ] , <EOL> expected_res_status = <NUM_LIT> ) <EOL> self . assertEqual ( '<STR_LIT>' , res [ '<STR_LIT>' ] [ '<STR_LIT:type>' ] ) <EOL> def test_proxy_group_chain_proxy ( self ) : <EOL> ptg0 = self . create_policy_target_group ( ) [ '<STR_LIT>' ] <EOL> ptg1 = self . create_policy_target_group ( <EOL> proxied_group_id = ptg0 [ '<STR_LIT:id>' ] , <EOL> expected_res_status = <NUM_LIT> ) [ '<STR_LIT>' ] <EOL> self . create_policy_target_group ( proxied_group_id = ptg1 [ '<STR_LIT:id>' ] , <EOL> expected_res_status = <NUM_LIT> ) <EOL> def test_proxy_group_no_update ( self ) : <EOL> ptg0 = self . create_policy_target_group ( ) [ '<STR_LIT>' ] <EOL> ptg1 = self . create_policy_target_group ( ) [ '<STR_LIT>' ] <EOL> ptg_proxy = self . create_policy_target_group ( <EOL> proxied_group_id = ptg0 [ '<STR_LIT:id>' ] ) [ '<STR_LIT>' ] <EOL> self . update_policy_target_group ( <EOL> ptg_proxy [ '<STR_LIT:id>' ] , proxied_group_id = ptg1 [ '<STR_LIT:id>' ] , <EOL> expected_res_status = <NUM_LIT> ) <EOL> def test_different_proxy_type ( self ) : <EOL> ptg = self . create_policy_target_group ( ) [ '<STR_LIT>' ] <EOL> ptg_proxy = self . create_policy_target_group ( <EOL> proxied_group_id = ptg [ '<STR_LIT:id>' ] , proxy_type = '<STR_LIT>' ) [ '<STR_LIT>' ] <EOL> self . assertEqual ( '<STR_LIT>' , ptg_proxy [ '<STR_LIT>' ] ) <EOL> ptg_proxy = self . show_policy_target_group ( <EOL> ptg_proxy [ '<STR_LIT:id>' ] ) [ '<STR_LIT>' ] <EOL> self . assertEqual ( '<STR_LIT>' , ptg_proxy [ '<STR_LIT>' ] ) <EOL> def test_proxy_type_fails ( self ) : <EOL> ptg = self . create_policy_target_group ( ) [ '<STR_LIT>' ] <EOL> res = self . create_policy_target_group ( proxy_type = '<STR_LIT>' , <EOL> expected_res_status = <NUM_LIT> ) <EOL> self . assertEqual ( '<STR_LIT>' , <EOL> res [ '<STR_LIT>' ] [ '<STR_LIT:type>' ] ) <EOL>", "answer": "self . create_policy_target_group ( proxied_group_id = ptg [ '<STR_LIT:id>' ] ,"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import logging <EOL> import shutil <EOL> import socket <EOL> import tempfile <EOL> import time <EOL> from ganeti import compat <EOL> from ganeti import constants <EOL> from ganeti import errors <EOL> from ganeti import locking <EOL> from ganeti import utils <EOL> from ganeti . masterd import iallocator <EOL>", "answer": "from ganeti . cmdlib . base import NoHooksLU"}, {"prompt": "<s> from swgpy . object import * <EOL> def create ( kernel ) : <EOL> result = Static ( ) <EOL> result . template = \"<STR_LIT>\" <EOL> result . attribute_template_id = - <NUM_LIT:1> <EOL>", "answer": "result . stfName ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"prompt": "<s> from peewee import * <EOL> from peewee import sort_models_topologically <EOL> from playhouse . tests . base import PeeweeTestCase <EOL> from playhouse . tests . base import test_db <EOL> class TestHelperMethods ( PeeweeTestCase ) : <EOL> def test_assert_query_count ( self ) : <EOL> def execute_queries ( n ) : <EOL> for i in range ( n ) : <EOL> test_db . execute_sql ( '<STR_LIT>' ) <EOL> with self . assertQueryCount ( <NUM_LIT:0> ) : <EOL> pass <EOL> with self . assertQueryCount ( <NUM_LIT:1> ) : <EOL> execute_queries ( <NUM_LIT:1> ) <EOL> with self . assertQueryCount ( <NUM_LIT:2> ) : <EOL> execute_queries ( <NUM_LIT:2> ) <EOL> def fails_low ( ) : <EOL> with self . assertQueryCount ( <NUM_LIT:2> ) : <EOL> execute_queries ( <NUM_LIT:1> ) <EOL> def fails_high ( ) : <EOL> with self . assertQueryCount ( <NUM_LIT:1> ) : <EOL> execute_queries ( <NUM_LIT:2> ) <EOL> self . assertRaises ( AssertionError , fails_low ) <EOL> self . assertRaises ( AssertionError , fails_high ) <EOL> class TestTopologicalSorting ( PeeweeTestCase ) : <EOL> def test_topological_sort_fundamentals ( self ) : <EOL> FKF = ForeignKeyField <EOL> class A ( Model ) : pass <EOL> class B ( Model ) : a = FKF ( A ) <EOL> class C ( Model ) : a , b = FKF ( A ) , FKF ( B ) <EOL> class D ( Model ) : c = FKF ( C ) <EOL> class E ( Model ) : e = FKF ( '<STR_LIT>' ) <EOL> class Excluded ( Model ) : e = FKF ( E ) <EOL> repeatable_ordering = None <EOL> for input_ordering in permutations ( [ A , B , C , D , E ] ) : <EOL> output_ordering = sort_models_topologically ( input_ordering ) <EOL> repeatable_ordering = repeatable_ordering or output_ordering <EOL> self . assertEqual ( repeatable_ordering , output_ordering ) <EOL> self . assertEqual ( len ( output_ordering ) , <NUM_LIT:5> ) <EOL> self . assertFalse ( Excluded in output_ordering ) <EOL> def assert_precedes ( X , Y ) : <EOL> lhs , rhs = map ( output_ordering . index , [ X , Y ] ) <EOL> self . assertTrue ( lhs < rhs ) <EOL> assert_precedes ( A , B ) <EOL> assert_precedes ( B , C ) <EOL> assert_precedes ( C , D ) <EOL> assert_precedes ( A , E ) <EOL> def permutations ( xs ) : <EOL> if not xs : <EOL> yield [ ] <EOL> else : <EOL> for y , ys in selections ( xs ) : <EOL> for pys in permutations ( ys ) : <EOL> yield [ y ] + pys <EOL> def selections ( xs ) : <EOL> for i in range ( len ( xs ) ) : <EOL>", "answer": "yield ( xs [ i ] , xs [ : i ] + xs [ i + <NUM_LIT:1> : ] ) "}, {"prompt": "<s> from cffi import FFI <EOL> from xcffib . ffi_build import ffi as xcffib_ffi <EOL> from cairocffi . ffi_build import ffi as cairocffi_ffi <EOL> pango_ffi = FFI ( ) <EOL> if hasattr ( pango_ffi , '<STR_LIT>' ) : <EOL> pango_ffi . set_source ( \"<STR_LIT>\" , None ) <EOL> pango_ffi . include ( cairocffi_ffi ) <EOL> pango_ffi . cdef ( \"\"\"<STR_LIT>\"\"\" ) <EOL> xcursors_ffi = FFI ( ) <EOL> if hasattr ( xcursors_ffi , '<STR_LIT>' ) : <EOL> xcursors_ffi . set_source ( \"<STR_LIT>\" , None ) <EOL>", "answer": "xcursors_ffi . include ( xcffib_ffi )"}, {"prompt": "<s> import json <EOL> from django . contrib . admin . sites import site <EOL> from django . template import Context <EOL> from django . template . base import Template <EOL> from django . utils . encoding import force_text <EOL> from cms . api import add_plugin <EOL> from cms . constants import PLUGIN_MOVE_ACTION , PLUGIN_COPY_ACTION <EOL> from cms . models import StaticPlaceholder , Placeholder , CMSPlugin <EOL> from cms . tests . test_plugins import PluginsTestBaseCase <EOL> from cms . utils . i18n import force_language <EOL> from cms . utils . urlutils import admin_reverse <EOL> class StaticPlaceholderTestCase ( PluginsTestBaseCase ) : <EOL> @ property <EOL> def admin_class ( self ) : <EOL> return site . _registry [ StaticPlaceholder ] <EOL> def fill_placeholder ( self , placeholder = None ) : <EOL> if placeholder is None : <EOL> placeholder = Placeholder ( slot = u\"<STR_LIT>\" ) <EOL> placeholder . save ( ) <EOL> plugin_1 = add_plugin ( placeholder , u\"<STR_LIT>\" , u\"<STR_LIT>\" , <EOL> body = u\"<STR_LIT>\" , <EOL> ) <EOL> plugin_1 . save ( ) <EOL> plugin_2 = add_plugin ( placeholder , u\"<STR_LIT>\" , u\"<STR_LIT>\" , <EOL> body = u\"<STR_LIT>\" , <EOL> ) <EOL> plugin_1 = self . reload ( plugin_1 ) <EOL> plugin_2 . parent = plugin_1 <EOL> plugin_2 . save ( ) <EOL> return placeholder <EOL> def get_admin ( self ) : <EOL> usr = self . _create_user ( \"<STR_LIT>\" , True , True ) <EOL> return usr <EOL> def test_template_creation ( self ) : <EOL> self . assertObjectDoesNotExist ( StaticPlaceholder . objects . all ( ) , code = '<STR_LIT>' ) <EOL> self . assertObjectDoesNotExist ( Placeholder . objects . all ( ) , slot = '<STR_LIT>' ) <EOL> t = Template ( '<STR_LIT>' ) <EOL> t . render ( self . get_context ( '<STR_LIT:/>' ) ) <EOL> self . assertObjectExist ( StaticPlaceholder . objects . all ( ) , code = '<STR_LIT>' , <EOL> creation_method = StaticPlaceholder . CREATION_BY_TEMPLATE ) <EOL> self . assertEqual ( Placeholder . objects . filter ( slot = '<STR_LIT>' ) . count ( ) , <NUM_LIT:2> ) <EOL> def test_empty ( self ) : <EOL> self . assertObjectDoesNotExist ( StaticPlaceholder . objects . all ( ) , code = '<STR_LIT>' ) <EOL> self . assertObjectDoesNotExist ( Placeholder . objects . all ( ) , slot = '<STR_LIT>' ) <EOL> t = Template ( '<STR_LIT>' ) <EOL> rendered = t . render ( self . get_context ( '<STR_LIT:/>' ) ) <EOL> self . assertIn ( \"<STR_LIT>\" , rendered ) <EOL> t = Template ( '<STR_LIT>' ) <EOL> rendered = t . render ( self . get_context ( '<STR_LIT:/>' ) ) <EOL> self . assertEqual ( \"<STR_LIT>\" , rendered ) <EOL> t = Template ( '<STR_LIT>' ) <EOL> rendered = t . render ( Context ( { '<STR_LIT:code>' : StaticPlaceholder . objects . all ( ) [ <NUM_LIT:0> ] } ) ) <EOL> self . assertIn ( \"<STR_LIT>\" , rendered ) <EOL> for p in Placeholder . objects . all ( ) : <EOL> add_plugin ( p , '<STR_LIT>' , '<STR_LIT>' , body = '<STR_LIT:test>' ) <EOL> t = Template ( '<STR_LIT>' ) <EOL> rendered = t . render ( self . get_context ( '<STR_LIT:/>' ) ) <EOL> self . assertNotIn ( \"<STR_LIT>\" , rendered ) <EOL> self . assertEqual ( StaticPlaceholder . objects . filter ( site_id__isnull = True , code = '<STR_LIT>' ) . count ( ) , <NUM_LIT:1> ) <EOL>", "answer": "def test_local ( self ) :"}, {"prompt": "<s> from __future__ import absolute_import , division , print_function <EOL> from glue . viewers . common . qt . mpl_widget import MplWidget <EOL> from glue . viewers . common . qt . mouse_mode import MouseMode <EOL> from glue . icons . qt import get_icon <EOL> from . . toolbar import GlueToolbar <EOL> class MouseModeTest ( MouseMode ) : <EOL> def __init__ ( self , axes , release_callback = None ) : <EOL> super ( MouseModeTest , self ) . __init__ ( axes , release_callback = release_callback ) <EOL> self . icon = get_icon ( '<STR_LIT>' ) <EOL> self . mode_id = '<STR_LIT>' <EOL> self . action_text = '<STR_LIT>' <EOL> self . tool_tip = '<STR_LIT>' <EOL> self . last_mode = None <EOL> def press ( self , event ) : <EOL> self . last_mode = '<STR_LIT>' <EOL> def move ( self , event ) : <EOL> self . last_mode = '<STR_LIT>' <EOL> class TestToolbar ( object ) : <EOL> def setup_method ( self , method ) : <EOL> from glue . external . qt import QtGui <EOL> assert QtGui . QApplication . instance ( ) is not None <EOL> self . win = QtGui . QMainWindow ( ) <EOL> widget , axes = self . _make_plot_widget ( self . win ) <EOL> self . canvas = widget . canvas <EOL> self . axes = axes <EOL> self . tb = GlueToolbar ( self . canvas , self . win ) <EOL> self . mode = MouseModeTest ( self . axes , release_callback = self . callback ) <EOL> self . tb . add_mode ( self . mode ) <EOL> self . win . addToolBar ( self . tb ) <EOL> self . _called_back = False <EOL> def teardown_method ( self , method ) : <EOL> self . win . close ( ) <EOL> def _make_plot_widget ( self , parent ) : <EOL> widget = MplWidget ( parent ) <EOL> ax = widget . canvas . fig . add_subplot ( <NUM_LIT> ) <EOL> p = ax . plot ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] ) [ <NUM_LIT:0> ] <EOL>", "answer": "return widget , ax"}, {"prompt": "<s> '''<STR_LIT>''' <EOL> import itertools <EOL> import collections <EOL> import functools <EOL> from python_toolbox import cute_iter_tools <EOL> from python_toolbox import misc_tools <EOL> from python_toolbox import address_tools <EOL> class Emitter : <EOL> '''<STR_LIT>''' <EOL> _is_atomically_pickleable = False <EOL> def __init__ ( self , inputs = ( ) , outputs = ( ) , name = None ) : <EOL> '''<STR_LIT>''' <EOL> from python_toolbox import sequence_tools <EOL> inputs = sequence_tools . to_tuple ( inputs , <EOL> item_type = Emitter ) <EOL> outputs = sequence_tools . to_tuple ( outputs , <EOL> item_type = ( collections . Callable , <EOL> Emitter ) ) <EOL> self . _inputs = set ( ) <EOL> '''<STR_LIT>''' <EOL> self . _outputs = set ( ) <EOL> '''<STR_LIT>''' <EOL> for output in outputs : <EOL> self . add_output ( output ) <EOL> self . __total_callable_outputs_cache = None <EOL> '''<STR_LIT>''' <EOL> self . _recalculate_total_callable_outputs ( ) <EOL> for input in inputs : <EOL> self . add_input ( input ) <EOL> self . name = name <EOL> '''<STR_LIT>''' <EOL> def get_inputs ( self ) : <EOL> '''<STR_LIT>''' <EOL> return self . _inputs <EOL> def get_outputs ( self ) : <EOL> '''<STR_LIT>''' <EOL> return self . _outputs <EOL> def _get_input_layers ( self ) : <EOL> '''<STR_LIT>''' <EOL> input_layers = [ self . _inputs ] <EOL> current_layer = self . _inputs <EOL> while current_layer : <EOL> next_layer = functools . reduce ( <EOL> set . union , <EOL> ( input . _inputs for input in current_layer ) , <EOL> set ( ) <EOL> ) <EOL> for ancestor_layer in input_layers : <EOL> assert isinstance ( next_layer , set ) <EOL> next_layer -= ancestor_layer <EOL> input_layers . append ( next_layer ) <EOL> current_layer = next_layer <EOL> return input_layers <EOL> def _recalculate_total_callable_outputs_recursively ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . _recalculate_total_callable_outputs ( ) <EOL> input_layers = self . _get_input_layers ( ) <EOL> for input_layer in input_layers : <EOL> for input in input_layer : <EOL> input . _recalculate_total_callable_outputs ( ) <EOL> def _recalculate_total_callable_outputs ( self ) : <EOL> '''<STR_LIT>''' <EOL> children_callable_outputs = functools . reduce ( <EOL> set . union , <EOL> ( emitter . get_total_callable_outputs ( ) for emitter <EOL> in self . _get_emitter_outputs ( ) if emitter is not self ) , <EOL> set ( ) <EOL> ) <EOL> self . __total_callable_outputs_cache = children_callable_outputs . union ( self . _get_callable_outputs ( ) ) <EOL> def add_input ( self , emitter ) : <EOL> '''<STR_LIT>''' <EOL> assert isinstance ( emitter , Emitter ) <EOL>", "answer": "self . _inputs . add ( emitter )"}, {"prompt": "<s> from django import forms <EOL> from django . forms import widgets <EOL> from django . utils . translation import ugettext_lazy as _ <EOL> from userena . utils import get_user_model <EOL> class CommaSeparatedUserInput ( widgets . Input ) : <EOL> input_type = '<STR_LIT:text>' <EOL> def render ( self , name , value , attrs = None ) : <EOL> if value is None : <EOL> value = '<STR_LIT>' <EOL> elif isinstance ( value , ( list , tuple ) ) : <EOL> value = ( '<STR_LIT:U+002CU+0020>' . join ( [ user . username for user in value ] ) ) <EOL> return super ( CommaSeparatedUserInput , self ) . render ( name , value , attrs ) <EOL> class CommaSeparatedUserField ( forms . Field ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> widget = CommaSeparatedUserInput <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> recipient_filter = kwargs . pop ( '<STR_LIT>' , None ) <EOL> self . _recipient_filter = recipient_filter <EOL> super ( CommaSeparatedUserField , self ) . __init__ ( * args , ** kwargs ) <EOL>", "answer": "def clean ( self , value ) :"}, {"prompt": "<s> import sys <EOL> from optparse import OptionParser <EOL> try : <EOL> from coverage import coverage <EOL> except ImportError : <EOL> coverage = None <EOL> parser = OptionParser ( ) <EOL> parser . add_option ( '<STR_LIT>' , '<STR_LIT>' , action = '<STR_LIT:store_true>' , <EOL> help = '<STR_LIT>' ) <EOL> if coverage : <EOL> parser . add_option ( '<STR_LIT:-c>' , '<STR_LIT>' , action = '<STR_LIT:store_true>' , <EOL> help = '<STR_LIT>' ) <EOL> options , args = parser . parse_args ( ) <EOL> if args : <EOL> parser . print_help ( ) <EOL> sys . exit ( <NUM_LIT:2> ) <EOL> if coverage and options . coverage : <EOL> cov = coverage ( ) <EOL> cov . start ( ) <EOL> import tests <EOL> result = tests . run ( options . verbose ) <EOL> if result . wasSuccessful ( ) and options . coverage : <EOL> exclude = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> def include_module ( name ) : <EOL> for prefix in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> if name . startswith ( prefix ) : <EOL> return False <EOL>", "answer": "return name . startswith ( '<STR_LIT>' )"}, {"prompt": "<s> from __future__ import print_function <EOL> from six . moves import urllib <EOL> from six . moves import input <EOL> class InvalidInput ( Exception ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def __init__ ( self , reason = \"<STR_LIT>\" ) : <EOL> self . reason = reason <EOL> def prompt ( q , coerce_fn = None , error_msg = \"<STR_LIT>\" , prompt_fn = input ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if coerce_fn is None : <EOL> coerce_fn = lambda x : x <EOL> while <NUM_LIT:1> : <EOL> r = prompt_fn ( q + \"<STR_LIT>\" ) <EOL> try : <EOL> return coerce_fn ( r ) <EOL> except InvalidInput as e : <EOL> print ( e . reason or error_msg ) <EOL> _yes_no_mapping = { \"<STR_LIT:y>\" : True , \"<STR_LIT:n>\" : False } <EOL> def _yes_no_coerce_fn ( r ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> try : <EOL> return _yes_no_mapping [ r . lower ( ) ] <EOL> except KeyError : <EOL> raise InvalidInput ( \"<STR_LIT>\" ) <EOL> def prompt_yes_no ( q ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return prompt ( q + \"<STR_LIT>\" , _yes_no_coerce_fn ) <EOL> def _normalized_coerce_fn ( r ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return r . lower ( ) . strip ( ) <EOL> def prompt_normalized ( q ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return prompt ( q , _normalized_coerce_fn ) <EOL> def _url_coerce_fn ( r ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> p = urllib . parse . urlparse ( r ) <EOL> if not p . scheme : <EOL> raise InvalidInput ( \"<STR_LIT>\" ) <EOL> if not p . netloc : <EOL> raise InvalidInput ( \"<STR_LIT>\" ) <EOL> if p . path and p . path != \"<STR_LIT:/>\" : <EOL> raise InvalidInput ( \"<STR_LIT>\" ) <EOL> if p . params or p . query or p . fragment : <EOL> raise InvalidInput ( \"<STR_LIT>\" ) <EOL> if not p . path : <EOL>", "answer": "r += \"<STR_LIT:/>\""}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import itertools <EOL> from django . db import models <EOL> from django . db . models import FieldDoesNotExist <EOL> try : <EOL> from django . db . models . fields . related import RelatedObject <EOL> from django . db . models . fields . related import RelatedField <EOL> NEW_META_API = False <EOL> except ImportError : <EOL> NEW_META_API = True <EOL> try : <EOL> from django . db . models . query import ValuesQuerySet <EOL> from django . db . models . sql . where import Constraint <EOL> NEW_RELATED_API = False <EOL> except ImportError : <EOL> from django . db . models . query import ValuesIterable <EOL> NEW_RELATED_API = True <EOL> from django . utils . six import moves <EOL> from django . utils . tree import Node <EOL> try : <EOL> from django . db . models . lookups import Lookup <EOL> from django . db . models . sql . datastructures import Col <EOL> NEW_LOOKUPS = True <EOL> except ImportError : <EOL> NEW_LOOKUPS = False <EOL> from modeltranslation import settings <EOL> from modeltranslation . fields import TranslationField <EOL> from modeltranslation . utils import ( build_localized_fieldname , get_language , <EOL> auto_populate , resolution_order ) <EOL> def get_translatable_fields_for_model ( model ) : <EOL> from modeltranslation . translator import NotRegistered , translator <EOL> try : <EOL> return translator . get_options_for_model ( model ) . get_field_names ( ) <EOL> except NotRegistered : <EOL> return None <EOL> def rewrite_lookup_key ( model , lookup_key ) : <EOL> pieces = lookup_key . split ( '<STR_LIT>' , <NUM_LIT:1> ) <EOL> original_key = pieces [ <NUM_LIT:0> ] <EOL> translatable_fields = get_translatable_fields_for_model ( model ) <EOL> if translatable_fields is not None : <EOL> if pieces [ <NUM_LIT:0> ] in translatable_fields : <EOL> pieces [ <NUM_LIT:0> ] = build_localized_fieldname ( pieces [ <NUM_LIT:0> ] , get_language ( ) ) <EOL> if len ( pieces ) > <NUM_LIT:1> : <EOL> fields_to_trans_models = get_fields_to_translatable_models ( model ) <EOL> if original_key in fields_to_trans_models : <EOL> transmodel = fields_to_trans_models [ original_key ] <EOL> pieces [ <NUM_LIT:1> ] = rewrite_lookup_key ( transmodel , pieces [ <NUM_LIT:1> ] ) <EOL> return '<STR_LIT>' . join ( pieces ) <EOL> def append_fallback ( model , fields ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> fields = set ( fields ) <EOL> trans = set ( ) <EOL> from modeltranslation . translator import translator <EOL> opts = translator . get_options_for_model ( model ) <EOL> for key , _ in opts . fields . items ( ) : <EOL> if key in fields : <EOL> langs = resolution_order ( get_language ( ) , getattr ( model , key ) . fallback_languages ) <EOL> fields = fields . union ( build_localized_fieldname ( key , lang ) for lang in langs ) <EOL> fields . remove ( key ) <EOL> trans . add ( key ) <EOL> return fields , trans <EOL> def append_translated ( model , fields ) : <EOL> \"<STR_LIT>\" <EOL> fields = set ( fields ) <EOL> from modeltranslation . translator import translator <EOL> opts = translator . get_options_for_model ( model ) <EOL> for key , translated in opts . fields . items ( ) : <EOL> if key in fields : <EOL> fields = fields . union ( f . name for f in translated ) <EOL> return fields <EOL> def append_lookup_key ( model , lookup_key ) : <EOL> \"<STR_LIT>\" <EOL> pieces = lookup_key . split ( '<STR_LIT>' , <NUM_LIT:1> ) <EOL> fields = append_translated ( model , ( pieces [ <NUM_LIT:0> ] , ) ) <EOL> if len ( pieces ) > <NUM_LIT:1> : <EOL> fields_to_trans_models = get_fields_to_translatable_models ( model ) <EOL> if pieces [ <NUM_LIT:0> ] in fields_to_trans_models : <EOL> transmodel = fields_to_trans_models [ pieces [ <NUM_LIT:0> ] ] <EOL> rest = append_lookup_key ( transmodel , pieces [ <NUM_LIT:1> ] ) <EOL> fields = set ( '<STR_LIT>' . join ( pr ) for pr in itertools . product ( fields , rest ) ) <EOL> else : <EOL> fields = set ( '<STR_LIT>' % ( f , pieces [ <NUM_LIT:1> ] ) for f in fields ) <EOL> return fields <EOL> def append_lookup_keys ( model , fields ) : <EOL> return moves . reduce ( set . union , ( append_lookup_key ( model , field ) for field in fields ) , set ( ) ) <EOL> def rewrite_order_lookup_key ( model , lookup_key ) : <EOL> if lookup_key . startswith ( '<STR_LIT:->' ) : <EOL> return '<STR_LIT:->' + rewrite_lookup_key ( model , lookup_key [ <NUM_LIT:1> : ] ) <EOL> else : <EOL> return rewrite_lookup_key ( model , lookup_key ) <EOL> _F2TM_CACHE = { } <EOL> def get_fields_to_translatable_models ( model ) : <EOL> if model in _F2TM_CACHE : <EOL> return _F2TM_CACHE [ model ] <EOL> results = [ ] <EOL> if NEW_META_API : <EOL> for f in model . _meta . get_fields ( ) : <EOL> if f . is_relation and f . related_model : <EOL> if get_translatable_fields_for_model ( f . related_model ) is not None : <EOL> results . append ( ( f . name , f . related_model ) ) <EOL> else : <EOL> for field_name in model . _meta . get_all_field_names ( ) : <EOL> field_object , modelclass , direct , m2m = model . _meta . get_field_by_name ( field_name ) <EOL> if direct and isinstance ( field_object , RelatedField ) : <EOL> if get_translatable_fields_for_model ( field_object . related . parent_model ) is not None : <EOL> results . append ( ( field_name , field_object . related . parent_model ) ) <EOL> if isinstance ( field_object , RelatedObject ) : <EOL> if get_translatable_fields_for_model ( field_object . model ) is not None : <EOL> results . append ( ( field_name , field_object . model ) ) <EOL> _F2TM_CACHE [ model ] = dict ( results ) <EOL> return _F2TM_CACHE [ model ] <EOL> _C2F_CACHE = { } <EOL> def get_field_by_colum_name ( model , col ) : <EOL> try : <EOL> field = model . _meta . get_field ( col ) <EOL> if field . column == col : <EOL> return field <EOL> except FieldDoesNotExist : <EOL> pass <EOL> field = _C2F_CACHE . get ( ( model , col ) , None ) <EOL> if field : <EOL> return field <EOL> for field in model . _meta . fields : <EOL> if field . column == col : <EOL> _C2F_CACHE [ ( model , col ) ] = field <EOL> return field <EOL> assert False , \"<STR_LIT>\" % col <EOL> class MultilingualQuerySet ( models . query . QuerySet ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MultilingualQuerySet , self ) . __init__ ( * args , ** kwargs ) <EOL> self . _post_init ( ) <EOL> def _post_init ( self ) : <EOL> self . _rewrite = True <EOL> self . _populate = None <EOL> if self . model and ( not self . query . order_by ) : <EOL> if self . model . _meta . ordering : <EOL> ordering = [ ] <EOL> for key in self . model . _meta . ordering : <EOL> ordering . append ( rewrite_order_lookup_key ( self . model , key ) ) <EOL> self . query . add_ordering ( * ordering ) <EOL> def __reduce__ ( self ) : <EOL> return multilingual_queryset_factory , ( self . __class__ . __bases__ [ <NUM_LIT:0> ] , ) , self . __getstate__ ( ) <EOL> if NEW_RELATED_API : <EOL> def _clone ( self , klass = None , ** kwargs ) : <EOL> kwargs . setdefault ( '<STR_LIT>' , self . _rewrite ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . _populate ) <EOL> if hasattr ( self , '<STR_LIT>' ) : <EOL> kwargs . setdefault ( '<STR_LIT>' , self . translation_fields ) <EOL> if hasattr ( self , '<STR_LIT>' ) : <EOL> kwargs . setdefault ( '<STR_LIT>' , self . fields_to_del ) <EOL> if hasattr ( self , '<STR_LIT>' ) : <EOL> kwargs . setdefault ( '<STR_LIT>' , self . original_fields ) <EOL> return super ( MultilingualQuerySet , self ) . _clone ( ** kwargs ) <EOL> else : <EOL> def _clone ( self , klass = None , * args , ** kwargs ) : <EOL> if klass is not None and not issubclass ( klass , MultilingualQuerySet ) : <EOL> class NewClass ( klass , MultilingualQuerySet ) : <EOL> pass <EOL> NewClass . __name__ = '<STR_LIT>' % klass . __name__ <EOL> klass = NewClass <EOL> kwargs . setdefault ( '<STR_LIT>' , self . _rewrite ) <EOL> kwargs . setdefault ( '<STR_LIT>' , self . _populate ) <EOL> return super ( MultilingualQuerySet , self ) . _clone ( klass , * args , ** kwargs ) <EOL> def rewrite ( self , mode = True ) : <EOL> return self . _clone ( _rewrite = mode ) <EOL> def populate ( self , mode = '<STR_LIT:all>' ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> return self . _clone ( _populate = mode ) <EOL> def _rewrite_applied_operations ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . _rewrite_where ( self . query . where ) <EOL> if not NEW_RELATED_API : <EOL> self . _rewrite_where ( self . query . having ) <EOL> self . _rewrite_order ( ) <EOL> self . _rewrite_select_related ( ) <EOL> def select_related ( self , * fields , ** kwargs ) : <EOL> if not self . _rewrite : <EOL> return super ( MultilingualQuerySet , self ) . select_related ( * fields , ** kwargs ) <EOL> new_args = [ ] <EOL> for key in fields : <EOL> new_args . append ( rewrite_lookup_key ( self . model , key ) ) <EOL> return super ( MultilingualQuerySet , self ) . select_related ( * new_args , ** kwargs ) <EOL> def _rewrite_col ( self , col ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( col , Col ) : <EOL> new_name = rewrite_lookup_key ( self . model , col . target . name ) <EOL> if col . target . name != new_name : <EOL> new_field = self . model . _meta . get_field ( new_name ) <EOL> if col . target is col . source : <EOL> col . source = new_field <EOL> col . target = new_field <EOL> elif hasattr ( col , '<STR_LIT>' ) : <EOL> self . _rewrite_col ( col . col ) <EOL> elif hasattr ( col , '<STR_LIT>' ) : <EOL> self . _rewrite_col ( col . lhs ) <EOL> def _rewrite_where ( self , q ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not NEW_LOOKUPS and isinstance ( q , tuple ) and isinstance ( q [ <NUM_LIT:0> ] , Constraint ) : <EOL> c = q [ <NUM_LIT:0> ] <EOL> if c . field is None : <EOL> c . field = get_field_by_colum_name ( self . model , c . col ) <EOL> new_name = rewrite_lookup_key ( self . model , c . field . name ) <EOL> if c . field . name != new_name : <EOL> c . field = self . model . _meta . get_field ( new_name ) <EOL> c . col = c . field . column <EOL> elif NEW_LOOKUPS and isinstance ( q , Lookup ) : <EOL> self . _rewrite_col ( q . lhs ) <EOL> if isinstance ( q , Node ) : <EOL> for child in q . children : <EOL> self . _rewrite_where ( child ) <EOL> def _rewrite_order ( self ) : <EOL> self . query . order_by = [ rewrite_order_lookup_key ( self . model , field_name ) <EOL> for field_name in self . query . order_by ] <EOL> def _rewrite_select_related ( self ) : <EOL> if isinstance ( self . query . select_related , dict ) : <EOL> new = { } <EOL> for field_name , value in self . query . select_related . items ( ) : <EOL> new [ rewrite_order_lookup_key ( self . model , field_name ) ] = value <EOL> self . query . select_related = new <EOL> def _rewrite_q ( self , q ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( q , tuple ) and len ( q ) == <NUM_LIT:2> : <EOL> return rewrite_lookup_key ( self . model , q [ <NUM_LIT:0> ] ) , q [ <NUM_LIT:1> ] <EOL> if isinstance ( q , Node ) : <EOL> q . children = list ( map ( self . _rewrite_q , q . children ) ) <EOL> return q <EOL> def _rewrite_f ( self , q ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if isinstance ( q , models . F ) : <EOL> q . name = rewrite_lookup_key ( self . model , q . name ) <EOL> return q <EOL> if isinstance ( q , Node ) : <EOL> q . children = list ( map ( self . _rewrite_f , q . children ) ) <EOL> if hasattr ( q , '<STR_LIT>' ) : <EOL> q . lhs = self . _rewrite_f ( q . lhs ) <EOL> if hasattr ( q , '<STR_LIT>' ) : <EOL> q . rhs = self . _rewrite_f ( q . rhs ) <EOL> return q <EOL> def _filter_or_exclude ( self , negate , * args , ** kwargs ) : <EOL>", "answer": "if not self . _rewrite :"}, {"prompt": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import hashlib <EOL> import json <EOL> import os <EOL> import shutil <EOL> import thread <EOL> import time <EOL> import BaseHTTPServer <EOL> import httplib2 <EOL> from glance . tests import functional <EOL> from glance . tests . utils import ( skip_if_disabled , <EOL> execute , <EOL> xattr_writes_supported ) <EOL> FIVE_KB = <NUM_LIT:5> * <NUM_LIT> <EOL> class RemoteImageHandler ( BaseHTTPServer . BaseHTTPRequestHandler ) : <EOL> def do_HEAD ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in s . path : <EOL> s . send_response ( <NUM_LIT:200> ) <EOL> s . send_header ( '<STR_LIT:Content-Type>' , '<STR_LIT>' ) <EOL> s . send_header ( '<STR_LIT>' , FIVE_KB ) <EOL> s . end_headers ( ) <EOL> return <EOL> else : <EOL> self . send_error ( <NUM_LIT> , '<STR_LIT>' % self . path ) <EOL> return <EOL> def do_GET ( s ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if '<STR_LIT>' in s . path : <EOL> s . send_response ( <NUM_LIT:200> ) <EOL> s . send_header ( '<STR_LIT:Content-Type>' , '<STR_LIT>' ) <EOL> s . send_header ( '<STR_LIT>' , FIVE_KB ) <EOL> s . end_headers ( ) <EOL> image_data = '<STR_LIT:*>' * FIVE_KB <EOL> s . wfile . write ( image_data ) <EOL> self . wfile . close ( ) <EOL> return <EOL> else : <EOL> self . send_error ( <NUM_LIT> , '<STR_LIT>' % self . path ) <EOL> return <EOL> class BaseCacheMiddlewareTest ( object ) : <EOL> @ skip_if_disabled <EOL> def test_cache_middleware_transparent ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . cleanup ( ) <EOL> self . start_servers ( ** self . __dict__ . copy ( ) ) <EOL> api_port = self . api_port <EOL> registry_port = self . registry_port <EOL> image_data = \"<STR_LIT:*>\" * FIVE_KB <EOL> headers = { '<STR_LIT:Content-Type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT:True>' } <EOL> path = \"<STR_LIT>\" % ( \"<STR_LIT>\" , self . api_port ) <EOL> http = httplib2 . Http ( ) <EOL> response , content = http . request ( path , '<STR_LIT:POST>' , headers = headers , <EOL> body = image_data ) <EOL> self . assertEqual ( response . status , <NUM_LIT> ) <EOL> data = json . loads ( content ) <EOL> self . assertEqual ( data [ '<STR_LIT:image>' ] [ '<STR_LIT>' ] , <EOL> hashlib . md5 ( image_data ) . hexdigest ( ) ) <EOL> self . assertEqual ( data [ '<STR_LIT:image>' ] [ '<STR_LIT:size>' ] , FIVE_KB ) <EOL> self . assertEqual ( data [ '<STR_LIT:image>' ] [ '<STR_LIT:name>' ] , \"<STR_LIT>\" ) <EOL> self . assertEqual ( data [ '<STR_LIT:image>' ] [ '<STR_LIT>' ] , True ) <EOL> image_id = data [ '<STR_LIT:image>' ] [ '<STR_LIT:id>' ] <EOL> image_cached_path = os . path . join ( self . api_server . image_cache_dir , <EOL> image_id ) <EOL> self . assertFalse ( os . path . exists ( image_cached_path ) ) <EOL> path = \"<STR_LIT>\" % ( \"<STR_LIT>\" , self . api_port , <EOL> image_id ) <EOL> http = httplib2 . Http ( ) <EOL> response , content = http . request ( path , '<STR_LIT:GET>' ) <EOL> self . assertEqual ( response . status , <NUM_LIT:200> ) <EOL> image_cached_path = os . path . join ( self . api_server . image_cache_dir , <EOL> image_id ) <EOL> i = <NUM_LIT:0> <EOL> while not os . path . exists ( image_cached_path ) and i < <NUM_LIT:30> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> i = i + <NUM_LIT:1> <EOL> self . assertTrue ( os . path . exists ( image_cached_path ) ) <EOL> path = \"<STR_LIT>\" % ( \"<STR_LIT>\" , self . api_port , <EOL> image_id ) <EOL> http = httplib2 . Http ( ) <EOL> response , content = http . request ( path , '<STR_LIT>' ) <EOL> self . assertEqual ( response . status , <NUM_LIT:200> ) <EOL> self . assertFalse ( os . path . exists ( image_cached_path ) ) <EOL> self . stop_servers ( ) <EOL> @ skip_if_disabled <EOL> def test_cache_remote_image ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . cleanup ( ) <EOL> self . start_servers ( ** self . __dict__ . copy ( ) ) <EOL> api_port = self . api_port <EOL> registry_port = self . registry_port <EOL> server_class = BaseHTTPServer . HTTPServer <EOL> remote_server = server_class ( ( '<STR_LIT:127.0.0.1>' , <NUM_LIT:0> ) , RemoteImageHandler ) <EOL> remote_ip , remote_port = remote_server . server_address <EOL> def serve_requests ( httpd ) : <EOL> httpd . serve_forever ( ) <EOL> thread . start_new_thread ( serve_requests , ( remote_server , ) ) <EOL> remote_uri = '<STR_LIT>' % ( remote_ip , remote_port ) <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT:True>' , <EOL> '<STR_LIT>' : remote_uri } <EOL> path = \"<STR_LIT>\" % ( \"<STR_LIT>\" , self . api_port ) <EOL> http = httplib2 . Http ( ) <EOL> response , content = http . request ( path , '<STR_LIT:POST>' , headers = headers ) <EOL> self . assertEqual ( response . status , <NUM_LIT> ) <EOL> data = json . loads ( content ) <EOL> self . assertEqual ( data [ '<STR_LIT:image>' ] [ '<STR_LIT:size>' ] , FIVE_KB ) <EOL> image_id = data [ '<STR_LIT:image>' ] [ '<STR_LIT:id>' ] <EOL> path = \"<STR_LIT>\" % ( \"<STR_LIT>\" , self . api_port , <EOL> image_id ) <EOL> http = httplib2 . Http ( ) <EOL> response , content = http . request ( path , '<STR_LIT:GET>' ) <EOL> self . assertEqual ( response . status , <NUM_LIT:200> ) <EOL> http = httplib2 . Http ( ) <EOL> response , content = http . request ( path , '<STR_LIT:GET>' ) <EOL> self . assertEqual ( response . status , <NUM_LIT:200> ) <EOL> self . assertEqual ( int ( response [ '<STR_LIT>' ] ) , FIVE_KB ) <EOL> remote_server . shutdown ( ) <EOL> self . stop_servers ( ) <EOL> class BaseCacheManageMiddlewareTest ( object ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def verify_no_images ( self ) : <EOL> path = \"<STR_LIT>\" % ( \"<STR_LIT>\" , self . api_port ) <EOL> http = httplib2 . Http ( ) <EOL> response , content = http . request ( path , '<STR_LIT:GET>' ) <EOL> self . assertEqual ( response . status , <NUM_LIT:200> ) <EOL> data = json . loads ( content ) <EOL> self . assertTrue ( '<STR_LIT>' in data ) <EOL> self . assertEqual ( <NUM_LIT:0> , len ( data [ '<STR_LIT>' ] ) ) <EOL> def add_image ( self , name ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> image_data = \"<STR_LIT:*>\" * FIVE_KB <EOL> headers = { '<STR_LIT:Content-Type>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT:%s>' % name , <EOL> '<STR_LIT>' : '<STR_LIT:True>' } <EOL> path = \"<STR_LIT>\" % ( \"<STR_LIT>\" , self . api_port ) <EOL> http = httplib2 . Http ( ) <EOL> response , content = http . request ( path , '<STR_LIT:POST>' , headers = headers , <EOL> body = image_data ) <EOL> self . assertEqual ( response . status , <NUM_LIT> ) <EOL> data = json . loads ( content ) <EOL> self . assertEqual ( data [ '<STR_LIT:image>' ] [ '<STR_LIT>' ] , <EOL> hashlib . md5 ( image_data ) . hexdigest ( ) ) <EOL> self . assertEqual ( data [ '<STR_LIT:image>' ] [ '<STR_LIT:size>' ] , FIVE_KB ) <EOL> self . assertEqual ( data [ '<STR_LIT:image>' ] [ '<STR_LIT:name>' ] , name ) <EOL> self . assertEqual ( data [ '<STR_LIT:image>' ] [ '<STR_LIT>' ] , True ) <EOL> return data [ '<STR_LIT:image>' ] [ '<STR_LIT:id>' ] <EOL> def verify_no_cached_images ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> path = \"<STR_LIT>\" % ( \"<STR_LIT>\" , self . api_port ) <EOL> http = httplib2 . Http ( ) <EOL> response , content = http . request ( path , '<STR_LIT:GET>' ) <EOL> self . assertEqual ( response . status , <NUM_LIT:200> ) <EOL> data = json . loads ( content ) <EOL> self . assertTrue ( '<STR_LIT>' in data ) <EOL> self . assertEqual ( data [ '<STR_LIT>' ] , [ ] ) <EOL> @ skip_if_disabled <EOL> def test_cache_manage_get_cached_images ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . cleanup ( ) <EOL> self . start_servers ( ** self . __dict__ . copy ( ) ) <EOL> api_port = self . api_port <EOL> registry_port = self . registry_port <EOL> self . verify_no_images ( ) <EOL> image_id = self . add_image ( \"<STR_LIT>\" ) <EOL> self . verify_no_cached_images ( ) <EOL> path = \"<STR_LIT>\" % ( \"<STR_LIT>\" , self . api_port , <EOL> image_id ) <EOL> http = httplib2 . Http ( ) <EOL> response , content = http . request ( path , '<STR_LIT:GET>' ) <EOL> self . assertEqual ( response . status , <NUM_LIT:200> ) <EOL> path = \"<STR_LIT>\" % ( \"<STR_LIT>\" , self . api_port ) <EOL> http = httplib2 . Http ( ) <EOL> response , content = http . request ( path , '<STR_LIT:GET>' ) <EOL> self . assertEqual ( response . status , <NUM_LIT:200> ) <EOL> data = json . loads ( content ) <EOL> self . assertTrue ( '<STR_LIT>' in data ) <EOL> cached_images = data [ '<STR_LIT>' ] <EOL> self . assertEqual ( <NUM_LIT:1> , len ( cached_images ) ) <EOL> self . assertEqual ( image_id , cached_images [ <NUM_LIT:0> ] [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( <NUM_LIT:0> , cached_images [ <NUM_LIT:0> ] [ '<STR_LIT>' ] ) <EOL> path = \"<STR_LIT>\" % ( \"<STR_LIT>\" , self . api_port , <EOL> image_id ) <EOL> http = httplib2 . Http ( ) <EOL> response , content = http . request ( path , '<STR_LIT:GET>' ) <EOL> self . assertEqual ( response . status , <NUM_LIT:200> ) <EOL> path = \"<STR_LIT>\" % ( \"<STR_LIT>\" , self . api_port ) <EOL> http = httplib2 . Http ( ) <EOL> response , content = http . request ( path , '<STR_LIT:GET>' ) <EOL> self . assertEqual ( response . status , <NUM_LIT:200> ) <EOL> data = json . loads ( content ) <EOL> self . assertTrue ( '<STR_LIT>' in data ) <EOL> cached_images = data [ '<STR_LIT>' ] <EOL> self . assertEqual ( <NUM_LIT:1> , len ( cached_images ) ) <EOL> self . assertEqual ( image_id , cached_images [ <NUM_LIT:0> ] [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( <NUM_LIT:1> , cached_images [ <NUM_LIT:0> ] [ '<STR_LIT>' ] ) <EOL> self . stop_servers ( ) <EOL> @ skip_if_disabled <EOL> def test_cache_manage_delete_cached_images ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> self . cleanup ( ) <EOL> self . start_servers ( ** self . __dict__ . copy ( ) ) <EOL> api_port = self . api_port <EOL>", "answer": "registry_port = self . registry_port"}, {"prompt": "<s> from . context import * <EOL> from . engine import * <EOL> from . graph import * <EOL>", "answer": "from . pipeline import * "}, {"prompt": "<s> from cloudferry . lib . base . action import action <EOL> DEFAULT = <NUM_LIT:0> <EOL> PATH_ONE = <NUM_LIT:1> <EOL> PATH_TWO = <NUM_LIT:2> <EOL> class IsOption ( action . Action ) : <EOL> def __init__ ( self , init , option_name ) : <EOL> self . option_name = option_name <EOL> super ( IsOption , self ) . __init__ ( init ) <EOL>", "answer": "def run ( self , ** kwargs ) :"}]